
// --------------    FAKE ELEMENTS GWT ASSUMES EXIST   -------------- 
var $wnd;
if (typeof window !== 'undefined')
    $wnd = window
else if (typeof global !== 'undefined')
    $wnd = global // nodejs
else if (typeof self !== 'undefined')
    $wnd = self // web worker

var $moduleName,
    $moduleBase;

// --------------    GENERATED CODE    -------------- 
var $intern_0 = 2147483647, $intern_1 = {3:1, 4:1, 5:1}, $intern_2 = {111:1}, $intern_3 = {3:1, 111:1}, $intern_4 = {47:1}, $intern_5 = {39:1}, $intern_6 = {20:1, 13:1}, $intern_7 = {20:1, 13:1, 19:1}, $intern_8 = {267:1, 47:1}, $intern_9 = {267:1, 47:1, 122:1}, $intern_10 = {249:1, 3:1}, $intern_11 = {57:1}, $intern_12 = {20:1, 28:1, 13:1}, $intern_13 = 1742, $intern_14 = {20:1, 28:1, 13:1, 19:1}, $intern_15 = {111:1, 124:1, 118:1}, $intern_16 = {20:1, 28:1, 13:1, 19:1, 62:1}, $intern_17 = {20:1, 28:1, 13:1, 200:1, 19:1, 62:1}, $intern_18 = {47:1, 122:1}, $intern_19 = {410:1, 39:1}, $intern_20 = {249:1, 494:1, 3:1}, $intern_21 = 16384, $intern_22 = {201:1}, $intern_23 = {l:4194303, m:4194303, h:524287}, $intern_24 = 1073741824, $intern_25 = {147:1, 57:1}, $intern_26 = {227:1, 3:1, 34:1}, $intern_27 = {20:1}, $intern_28 = {3:1, 20:1, 28:1, 13:1}, $intern_29 = {166:1, 3:1, 20:1, 28:1, 13:1, 15:1, 50:1}, $intern_30 = {3:1, 20:1, 28:1, 13:1, 19:1}, $intern_31 = {20:1, 13:1, 19:1, 62:1}, $intern_32 = {3:1, 20:1, 28:1, 13:1, 19:1, 62:1}, $intern_33 = {3:1, 6:1, 4:1, 5:1}, $intern_34 = 461845907, $intern_35 = -862048943, $intern_36 = {20:1, 28:1, 43:1, 13:1, 15:1}, $intern_37 = {20:1, 28:1, 43:1, 13:1, 15:1, 50:1}, $intern_38 = {3:1, 6:1, 4:1, 10:1, 5:1}, $intern_39 = {147:1, 362:1, 3:1, 34:1, 22:1, 57:1}, $intern_40 = {59:1}, $intern_41 = {3:1, 59:1}, $intern_42 = 1.0E-4, $intern_43 = -2147483648, $intern_44 = {3:1, 102:1, 54:1, 79:1}, $intern_45 = {181:1, 3:1, 4:1}, $intern_46 = 1000, $intern_47 = 65535, $intern_48 = 1900, $intern_49 = {40:1, 3:1, 4:1}, $intern_50 = {3:1, 4:1, 34:1, 185:1}, $intern_51 = 1743, $intern_52 = 4194303, $intern_53 = 1048575, $intern_54 = 524288, $intern_55 = 4194304, $intern_56 = 17592186044416, $intern_57 = 1000000000, $intern_58 = -17592186044416, $intern_59 = {3:1, 102:1, 80:1, 54:1, 79:1}, $intern_60 = {3:1, 282:1, 79:1}, $intern_61 = 3.4028234663852886E38, $intern_62 = Infinity, $intern_63 = -Infinity, $intern_64 = 4096, $intern_65 = {3:1, 4:1, 350:1}, $intern_66 = 65536, $intern_67 = 55296, $intern_68 = 10000, $intern_69 = {108:1, 3:1, 4:1}, $intern_70 = 100000, $intern_71 = 0.3010299956639812, $intern_72 = 4294967295, $intern_73 = 4294967296, $intern_74 = {3:1, 4:1, 20:1, 28:1, 43:1, 12:1, 13:1, 15:1, 50:1}, $intern_75 = {3:1, 20:1, 28:1, 43:1, 13:1, 15:1, 50:1}, $intern_76 = {20:1, 13:1, 15:1}, $intern_77 = {189:1}, $intern_78 = {3:1, 4:1, 111:1}, $intern_79 = {3:1, 4:1, 20:1, 28:1, 13:1, 65:1, 19:1}, $intern_80 = {262:1}, $intern_81 = 1.4901161193847656E-8, $intern_82 = 1.1102230246251565E-16, $intern_83 = 15525485, $intern_84 = 5.9604644775390625E-8, $intern_85 = 16777216, $intern_86 = 16777215, $intern_87 = {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 50:1}, $intern_88 = {3:1, 34:1, 22:1, 287:1}, $intern_89 = 1024, $intern_90 = {56:1}, $intern_91 = {139:1, 56:1}, $intern_92 = {141:1}, $intern_93 = {229:1, 3:1, 4:1}, $intern_94 = {175:1, 314:1}, $intern_95 = {3:1, 4:1, 5:1, 562:1}, $intern_96 = 0.01, $intern_97 = 4.9E-324, $intern_98 = 1.7976931348623157E308, $intern_99 = {3:1, 94:1, 130:1}, $intern_100 = {197:1}, $intern_101 = 1.5707963267948966, $intern_102 = {3:1, 4:1, 5:1, 180:1}, $intern_103 = {3:1, 6:1, 4:1, 5:1, 67:1, 73:1}, $intern_104 = 0.001, $intern_105 = 1.600000023841858, $intern_106 = {3:1, 6:1, 4:1, 5:1, 87:1, 67:1, 73:1}, $intern_107 = {3:1, 6:1, 4:1, 5:1, 101:1, 87:1, 67:1, 73:1}, $intern_108 = {45:1}, $intern_109 = {3:1, 6:1, 4:1, 5:1, 87:1, 125:1, 151:1, 67:1, 73:1}, $intern_110 = {3:1, 4:1, 137:1, 218:1, 443:1}, $intern_111 = {3:1, 4:1, 116:1, 218:1, 443:1}, $intern_112 = {3:1, 6:1, 4:1, 5:1, 87:1, 639:1, 151:1, 67:1, 73:1}, $intern_113 = 1.0E-8, $intern_114 = {447:1}, $intern_115 = {215:1}, $intern_116 = {3:1, 4:1, 5:1, 638:1}, $intern_117 = {126:1, 45:1}, $intern_118 = {433:1, 215:1}, $intern_119 = {766:1, 3:1, 4:1}, $intern_120 = {3:1, 4:1, 5:1, 774:1}, $intern_121 = 1.0E-5, $intern_122 = 1.0E-6, $intern_123 = -1.0E-6, $intern_124 = -1.7976931348623157E308, $intern_125 = 0.09999999999999998, $intern_126 = 4.71238898038469, $intern_127 = 3.141592653589793, $intern_128 = 6.283185307179586, $intern_129 = {3:1, 4:1, 5:1, 67:1}, $intern_130 = 5.497787143782138, $intern_131 = 3.9269908169872414, $intern_132 = 2.356194490192345, $intern_133 = {351:1}, $intern_134 = {295:1}, $intern_135 = 0.05, $intern_136 = 1.2999999523162842, $intern_137 = {92:1, 89:1}, $intern_138 = 32768, $intern_139 = {98:1, 92:1, 89:1, 51:1, 46:1, 93:1}, $intern_140 = {178:1, 3:1, 4:1}, $intern_141 = {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 50:1, 61:1, 55:1, 52:1}, $intern_142 = {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 47:1, 15:1, 50:1, 61:1, 55:1, 52:1, 557:1}, $intern_143 = {393:1, 629:1}, $intern_144 = {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 61:1, 52:1}, $intern_145 = {352:1, 142:1}, $intern_146 = {3:1, 4:1, 5:1, 119:1}, $intern_147 = {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 50:1, 61:1, 52:1}, $intern_148 = {3:1, 6:1, 4:1, 5:1, 180:1}, $intern_149 = {3:1, 4:1, 5:1, 353:1}, $intern_150 = {3:1, 20:1, 13:1, 15:1, 52:1, 558:1, 82:1, 69:1}, $intern_151 = 8192, $intern_152 = 2048, $intern_153 = {3:1, 4:1, 5:1, 232:1}, $intern_154 = {3:1, 4:1, 5:1, 630:1}, $intern_155 = {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 50:1, 61:1, 55:1, 52:1, 69:1}, $intern_156 = {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 50:1, 61:1, 55:1, 52:1, 82:1, 69:1}, $intern_157 = {3:1, 4:1, 5:1, 631:1}, $intern_158 = {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 61:1, 52:1, 82:1, 69:1}, $intern_159 = {20:1, 28:1, 43:1, 13:1, 15:1, 52:1, 69:1}, $intern_160 = {47:1, 122:1, 272:1}, $intern_161 = {76:1, 319:1}, $intern_162 = 1219, $intern_163 = -32768, $intern_164 = {49:1}, $intern_165 = {3:1, 4:1, 5:1, 127:1}, $intern_166 = {92:1, 89:1, 559:1, 1714:1}, $intern_167 = 1114111, $intern_168 = {3:1, 113:1}, $intern_169 = {3:1, 4:1, 5:1, 354:1};
var _, prototypesByTypeId_0, initFnList_0, permutationId = -1;
function setGwtProperty(propertyName, propertyValue){
  typeof window === 'object' && typeof window['$gwt'] === 'object' && (window['$gwt'][propertyName] = propertyValue);
}

function gwtOnLoad_0(errFn, modName, modBase, softPermutationId){
  ensureModuleInit();
  var initFnList = initFnList_0;
  $moduleName = modName;
  $moduleBase = modBase;
  permutationId = softPermutationId;
  function initializeModules(){
    for (var i = 0; i < initFnList.length; i++) {
      initFnList[i]();
    }
  }

  if (errFn) {
    try {
      $entry(initializeModules)();
    }
     catch (e) {
      errFn(modName, e);
    }
  }
   else {
    $entry(initializeModules)();
  }
}

function ensureModuleInit(){
  initFnList_0 == null && (initFnList_0 = []);
}

function addInitFunctions(){
  ensureModuleInit();
  var initFnList = initFnList_0;
  for (var i = 0; i < arguments.length; i++) {
    initFnList.push(arguments[i]);
  }
}

function typeMarkerFn(){
}

function toString_41(object){
  if (Array.isArray(object) && object.typeMarker === typeMarkerFn) {
    return $getName(getClass__Ljava_lang_Class___devirtual$(object)) + '@' + (hashCode__I__devirtual$(object) >>> 0).toString(16);
  }
  return object.toString();
}

function portableObjCreate(obj){
  function F(){
  }

  ;
  F.prototype = obj || {};
  return new F;
}

function emptyMethod(){
}

function defineClass(typeId, superTypeIdOrPrototype, castableTypeMap){
  var prototypesByTypeId = prototypesByTypeId_0, superPrototype;
  var prototype_0 = prototypesByTypeId[typeId];
  var clazz = prototype_0 instanceof Array?prototype_0[0]:null;
  if (prototype_0 && !clazz) {
    _ = prototype_0;
  }
   else {
    _ = (superPrototype = superTypeIdOrPrototype && superTypeIdOrPrototype.prototype , !superPrototype && (superPrototype = prototypesByTypeId_0[superTypeIdOrPrototype]) , portableObjCreate(superPrototype));
    _.castableTypeMap = castableTypeMap;
    _.constructor = _;
    !superTypeIdOrPrototype && (_.typeMarker = typeMarkerFn);
    prototypesByTypeId[typeId] = _;
  }
  for (var i = 3; i < arguments.length; ++i) {
    arguments[i].prototype = _;
  }
  clazz && (_.___clazz = clazz);
}

function bootstrap(){
  prototypesByTypeId_0 = {};
  !Array.isArray && (Array.isArray = function(vArg){
    return Object.prototype.toString.call(vArg) === '[object Array]';
  }
  );
}

bootstrap();
function Object_0(){
}

function equals_Ljava_lang_Object__Z__devirtual$(this$static, other){
  return instanceOfString(this$static)?$equals_4(this$static, other):instanceOfDouble(this$static)?(checkCriticalNotNull(this$static) , this$static === other):instanceOfBoolean(this$static)?(checkCriticalNotNull(this$static) , this$static === other):hasJavaObjectVirtualDispatch(this$static)?this$static.equals_0(other):isJavaArray(this$static)?this$static === other:$equals_3(this$static, other);
}

function getClass__Ljava_lang_Class___devirtual$(this$static){
  return instanceOfString(this$static)?Ljava_lang_String_2_classLit:instanceOfDouble(this$static)?Ljava_lang_Double_2_classLit:instanceOfBoolean(this$static)?Ljava_lang_Boolean_2_classLit:hasJavaObjectVirtualDispatch(this$static)?this$static.___clazz:isJavaArray(this$static)?this$static.___clazz:this$static.___clazz || Array.isArray(this$static) && getClassLiteralForArray(Lcom_google_gwt_core_client_JavaScriptObject_2_classLit, 1) || Lcom_google_gwt_core_client_JavaScriptObject_2_classLit;
}

function hashCode__I__devirtual$(this$static){
  return instanceOfString(this$static)?getHashCode_1(this$static):instanceOfDouble(this$static)?round_int((checkCriticalNotNull(this$static) , this$static)):instanceOfBoolean(this$static)?(checkCriticalNotNull(this$static) , this$static)?1231:1237:hasJavaObjectVirtualDispatch(this$static)?this$static.hashCode_1():isJavaArray(this$static)?getHashCode_0(this$static):$hashCode(this$static);
}

defineClass(1, null, {}, Object_0);
_.equals_0 = function equals(other){
  return this === other;
}
;
_.getClass_0 = function getClass_0(){
  return this.___clazz;
}
;
_.hashCode_1 = function hashCode_0(){
  return getHashCode_0(this);
}
;
_.toString_0 = function toString_0(){
  return $getName(getClass__Ljava_lang_Class___devirtual$(this)) + '@' + (hashCode__I__devirtual$(this) >>> 0).toString(16);
}
;
_.equals = function(other){
  return this.equals_0(other);
}
;
_.hashCode = function(){
  return this.hashCode_1();
}
;
_.toString = function(){
  return this.toString_0();
}
;
function canCast(src_0, dstId){
  if (instanceOfString(src_0)) {
    return !!stringCastMap[dstId];
  }
   else if (src_0.castableTypeMap) {
    return !!src_0.castableTypeMap[dstId];
  }
   else if (instanceOfDouble(src_0)) {
    return !!doubleCastMap[dstId];
  }
   else if (instanceOfBoolean(src_0)) {
    return !!booleanCastMap[dstId];
  }
  return false;
}

function castTo(src_0, dstId){
  checkCriticalType(src_0 == null || canCast(src_0, dstId));
  return src_0;
}

function castToArray(src_0){
  var elementTypeCategory;
  checkCriticalType(src_0 == null || Array.isArray(src_0) && (elementTypeCategory = getElementTypeCategory(src_0) , !(elementTypeCategory >= 14 && elementTypeCategory <= 16)));
  return src_0;
}

function castToBoolean(src_0){
  checkCriticalType(src_0 == null || instanceOfBoolean(src_0));
  return src_0;
}

function castToDouble(src_0){
  checkCriticalType(src_0 == null || instanceOfDouble(src_0));
  return src_0;
}

function castToJso(src_0){
  checkCriticalType(src_0 == null || isJsObjectOrFunction(src_0) && !(src_0.typeMarker === typeMarkerFn));
  return src_0;
}

function castToString(src_0){
  checkCriticalType(src_0 == null || instanceOfString(src_0));
  return src_0;
}

function charToString(x_0){
  return String.fromCharCode(x_0);
}

function hasJavaObjectVirtualDispatch(src_0){
  return !Array.isArray(src_0) && src_0.typeMarker === typeMarkerFn;
}

function instanceOf(src_0, dstId){
  return src_0 != null && canCast(src_0, dstId);
}

function instanceOfBoolean(src_0){
  return typeof src_0 === 'boolean';
}

function instanceOfDouble(src_0){
  return typeof src_0 === 'number';
}

function instanceOfJso(src_0){
  return src_0 != null && isJsObjectOrFunction(src_0) && !(src_0.typeMarker === typeMarkerFn);
}

function instanceOfString(src_0){
  return typeof src_0 === 'string';
}

function isJsObjectOrFunction(src_0){
  return typeof src_0 === 'object' || typeof src_0 === 'function';
}

function maskUndefined(src_0){
  return src_0 == null?null:src_0;
}

function round_int(x_0){
  return Math.max(Math.min(x_0, $intern_0), -2147483648) | 0;
}

function throwClassCastExceptionUnlessNull(o){
  checkCriticalType(o == null);
  return o;
}

var booleanCastMap, doubleCastMap, stringCastMap;
function $ensureNamesAreInitialized(this$static){
  if (this$static.typeName != null) {
    return;
  }
  initializeNames(this$static);
}

function $getEnumConstants(this$static){
  return this$static.enumConstantsFunc && this$static.enumConstantsFunc();
}

function $getName(this$static){
  $ensureNamesAreInitialized(this$static);
  return this$static.typeName;
}

function $toString_4(this$static){
  return ((this$static.modifiers & 2) != 0?'interface ':(this$static.modifiers & 1) != 0?'':'class ') + ($ensureNamesAreInitialized(this$static) , this$static.typeName);
}

function Class(){
  ++nextSequentialId;
  this.typeName = null;
  this.simpleName = null;
  this.packageName = null;
  this.compoundName = null;
  this.canonicalName = null;
  this.typeId = null;
  this.arrayLiterals = null;
}

function createClassObject(packageName, compoundClassName){
  var clazz;
  clazz = new Class;
  clazz.packageName = packageName;
  clazz.compoundName = compoundClassName;
  return clazz;
}

function createForClass(packageName, compoundClassName, typeId){
  var clazz;
  clazz = createClassObject(packageName, compoundClassName);
  maybeSetClassLiteral(typeId, clazz);
  return clazz;
}

function createForEnum(packageName, compoundClassName, typeId, superclass, enumConstantsFunc, enumValueOfFunc){
  var clazz;
  clazz = createClassObject(packageName, compoundClassName);
  maybeSetClassLiteral(typeId, clazz);
  clazz.modifiers = enumConstantsFunc?8:0;
  clazz.enumSuperclass = superclass;
  clazz.enumConstantsFunc = enumConstantsFunc;
  clazz.enumValueOfFunc = enumValueOfFunc;
  return clazz;
}

function createForInterface(packageName, compoundClassName){
  var clazz;
  clazz = createClassObject(packageName, compoundClassName);
  clazz.modifiers = 2;
  return clazz;
}

function createForPrimitive(className, primitiveTypeId){
  var clazz;
  clazz = createClassObject('', className);
  clazz.typeId = primitiveTypeId;
  clazz.modifiers = 1;
  return clazz;
}

function getClassLiteralForArray_0(leafClass, dimensions){
  var arrayLiterals = leafClass.arrayLiterals = leafClass.arrayLiterals || [];
  return arrayLiterals[dimensions] || (arrayLiterals[dimensions] = leafClass.createClassLiteralForArray(dimensions));
}

function getPrototypeForClass(clazz){
  if (clazz.isPrimitive()) {
    return null;
  }
  var typeId = clazz.typeId;
  var prototype_0 = prototypesByTypeId_0[typeId];
  return prototype_0;
}

function initializeNames(clazz){
  if (clazz.isArray_1()) {
    var componentType = clazz.componentType;
    componentType.isPrimitive()?(clazz.typeName = '[' + componentType.typeId):!componentType.isArray_1()?(clazz.typeName = '[L' + componentType.getName() + ';'):(clazz.typeName = '[' + componentType.getName());
    clazz.canonicalName = componentType.getCanonicalName() + '[]';
    clazz.simpleName = componentType.getSimpleName() + '[]';
    return;
  }
  var packageName = clazz.packageName;
  var compoundName = clazz.compoundName;
  compoundName = compoundName.split('/');
  clazz.typeName = join_0('.', [packageName, join_0('$', compoundName)]);
  clazz.canonicalName = join_0('.', [packageName, join_0('.', compoundName)]);
  clazz.simpleName = compoundName[compoundName.length - 1];
}

function join_0(separator, strings){
  var i = 0;
  while (!strings[i] || strings[i] == '') {
    i++;
  }
  var result = strings[i++];
  for (; i < strings.length; i++) {
    if (!strings[i] || strings[i] == '') {
      continue;
    }
    result += separator + strings[i];
  }
  return result;
}

function maybeSetClassLiteral(typeId, clazz){
  var proto;
  if (!typeId) {
    return;
  }
  clazz.typeId = typeId;
  var prototype_0 = getPrototypeForClass(clazz);
  if (!prototype_0) {
    prototypesByTypeId_0[typeId] = [clazz];
    return;
  }
  prototype_0.___clazz = clazz;
}

defineClass(283, 1, {283:1, 1794:1}, Class);
_.createClassLiteralForArray = function createClassLiteralForArray(dimensions){
  var clazz;
  clazz = new Class;
  clazz.modifiers = 4;
  dimensions > 1?(clazz.componentType = getClassLiteralForArray_0(this, dimensions - 1)):(clazz.componentType = this);
  return clazz;
}
;
_.getCanonicalName = function getCanonicalName(){
  $ensureNamesAreInitialized(this);
  return this.canonicalName;
}
;
_.getName = function getName(){
  return $getName(this);
}
;
_.getSimpleName = function getSimpleName(){
  return $ensureNamesAreInitialized(this) , this.simpleName;
}
;
_.isArray_1 = function isArray_1(){
  return (this.modifiers & 4) != 0;
}
;
_.isPrimitive = function isPrimitive(){
  return (this.modifiers & 1) != 0;
}
;
_.toString_0 = function toString_45(){
  return $toString_4(this);
}
;
_.modifiers = 0;
var nextSequentialId = 1;
var Ljava_lang_Object_2_classLit = createForClass('java.lang', 'Object', 1);
var Ljava_lang_Class_2_classLit = createForClass('java.lang', 'Class', 283);
defineClass(1775, 1, {3:1});
var Lcom_google_common_base_Optional_2_classLit = createForClass('com.google.common.base', 'Optional', 1775);
function $clinit_Absent(){
  $clinit_Absent = emptyMethod;
  INSTANCE = new Absent;
}

function Absent(){
}

defineClass(1147, 1775, {3:1}, Absent);
_.equals_0 = function equals_0(object){
  return object === this;
}
;
_.hashCode_1 = function hashCode_1(){
  return 2040732332;
}
;
_.toString_0 = function toString_1(){
  return 'Optional.absent()';
}
;
_.transform = function transform(function_0){
  checkNotNull(function_0);
  return $clinit_Absent() , INSTANCE;
}
;
var INSTANCE;
var Lcom_google_common_base_Absent_2_classLit = createForClass('com.google.common.base', 'Absent', 1147);
var Lcom_google_common_base_Function_2_classLit = createForInterface('com.google.common.base', 'Function');
function $appendTo(this$static, appendable, parts){
  checkNotNull(appendable);
  if (parts.hasNext_0()) {
    $append_7(appendable, this$static.toString_1(parts.next_1()));
    while (parts.hasNext_0()) {
      $append_7(appendable, this$static.separator);
      $append_7(appendable, this$static.toString_1(parts.next_1()));
    }
  }
  return appendable;
}

function $appendTo_0(this$static, builder, parts){
  var impossible;
  try {
    $appendTo(this$static, builder, parts);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 563)) {
      impossible = $e0;
      throw toJs(new AssertionError_0(impossible));
    }
     else 
      throw toJs($e0);
  }
  return builder;
}

function $join(this$static, parts){
  return $appendTo_0(this$static, new StringBuilder, parts).string;
}

function $toString(part){
  checkNotNull(part);
  return instanceOf(part, 495)?castTo(part, 495):toString_41(part);
}

function $useForNull(this$static){
  checkNotNull('null');
  return new Joiner$1(this$static, this$static);
}

function Joiner(separator){
  this.separator = castToString(checkNotNull(separator));
}

defineClass(411, 1, {}, Joiner);
_.toString_1 = function toString_2(part){
  return $toString(part);
}
;
var Lcom_google_common_base_Joiner_2_classLit = createForClass('com.google.common.base', 'Joiner', 411);
function Joiner$1(this$0, $anonymous0){
  this.this$01 = this$0;
  this.val$nullText3 = 'null';
  this.separator = $anonymous0.separator;
}

defineClass(909, 411, {}, Joiner$1);
_.toString_1 = function toString_3(part){
  return part == null?this.val$nullText3:$toString(part);
}
;
var Lcom_google_common_base_Joiner$1_2_classLit = createForClass('com.google.common.base', 'Joiner/1', 909);
function Joiner$MapJoiner(keyValueSeparator){
  castToString(checkNotNull(keyValueSeparator));
}

defineClass(908, 1, {}, Joiner$MapJoiner);
var Lcom_google_common_base_Joiner$MapJoiner_2_classLit = createForClass('com.google.common.base', 'Joiner/MapJoiner', 908);
function equal(a, b){
  return maskUndefined(a) === maskUndefined(b) || a != null && equals_Ljava_lang_Object__Z__devirtual$(a, b);
}

function badElementIndex(index_0, size_0){
  if (index_0 < 0) {
    return format('%s (%s) must not be negative', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, ['index', valueOf_4(index_0)]));
  }
   else if (size_0 < 0) {
    throw toJs(new IllegalArgumentException_0('negative size: ' + size_0));
  }
   else {
    return format('%s (%s) must be less than size (%s)', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, ['index', valueOf_4(index_0), valueOf_4(size_0)]));
  }
}

function badPositionIndex(index_0, size_0, desc){
  if (index_0 < 0) {
    return format('%s (%s) must not be negative', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [desc, valueOf_4(index_0)]));
  }
   else if (size_0 < 0) {
    throw toJs(new IllegalArgumentException_0('negative size: ' + size_0));
  }
   else {
    return format('%s (%s) must not be greater than size (%s)', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [desc, valueOf_4(index_0), valueOf_4(size_0)]));
  }
}

function badPositionIndexes(start_0, end, size_0){
  if (start_0 < 0 || start_0 > size_0) {
    return badPositionIndex(start_0, size_0, 'start index');
  }
  if (end < 0 || end > size_0) {
    return badPositionIndex(end, size_0, 'end index');
  }
  return format('end index (%s) must not be less than start index (%s)', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [valueOf_4(end), valueOf_4(start_0)]));
}

function checkArgument(expression){
  if (!expression) {
    throw toJs(new IllegalArgumentException);
  }
}

function checkArgument_0(expression, errorMessage){
  if (!expression) {
    throw toJs(new IllegalArgumentException_0(errorMessage));
  }
}

function checkArgument_1(b, p1){
  if (!b) {
    throw toJs(new IllegalArgumentException_0(format('value already present: %s', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [p1]))));
  }
}

function checkElementIndex(index_0, size_0){
  if (index_0 < 0 || index_0 >= size_0) {
    throw toJs(new IndexOutOfBoundsException_0(badElementIndex(index_0, size_0)));
  }
  return index_0;
}

function checkNotNull(reference){
  if (reference == null) {
    throw toJs(new NullPointerException);
  }
  return reference;
}

function checkNotNull_0(reference, errorMessage){
  if (reference == null) {
    throw toJs(new NullPointerException_0(errorMessage));
  }
  return reference;
}

function checkPositionIndex(index_0, size_0){
  if (index_0 < 0 || index_0 > size_0) {
    throw toJs(new IndexOutOfBoundsException_0(badPositionIndex(index_0, size_0, 'index')));
  }
  return index_0;
}

function checkPositionIndexes(start_0, end, size_0){
  if (start_0 < 0 || end < start_0 || end > size_0) {
    throw toJs(new IndexOutOfBoundsException_0(badPositionIndexes(start_0, end, size_0)));
  }
}

function checkState(expression){
  if (!expression) {
    throw toJs(new IllegalStateException);
  }
}

function checkState_0(expression, errorMessage){
  if (!expression) {
    throw toJs(new IllegalStateException_0(errorMessage));
  }
}

function format(template, args){
  var builder, i, placeholderStart, templateStart;
  template = template;
  builder = new StringBuilder_0;
  templateStart = 0;
  i = 0;
  while (i < args.length) {
    placeholderStart = template.indexOf('%s', templateStart);
    if (placeholderStart == -1) {
      break;
    }
    builder.string += '' + template.substr(templateStart, placeholderStart - templateStart);
    $append_10(builder, args[i++]);
    templateStart = placeholderStart + 2;
  }
  $append_9(builder, template, templateStart, template.length);
  if (i < args.length) {
    builder.string += ' [';
    $append_10(builder, args[i++]);
    while (i < args.length) {
      builder.string += ', ';
      $append_10(builder, args[i++]);
    }
    builder.string += ']';
  }
  return builder.string;
}

var Lcom_google_common_base_Predicate_2_classLit = createForInterface('com.google.common.base', 'Predicate');
function $clinit_Predicates(){
  $clinit_Predicates = emptyMethod;
  COMMA_JOINER = new Joiner(String.fromCharCode(44));
}

var COMMA_JOINER;
function Predicates$AndPredicate(components){
  this.components = components;
}

defineClass(517, 1, {139:1, 517:1, 3:1, 56:1}, Predicates$AndPredicate);
_.test_0 = function test_0(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_1(t){
  var i;
  for (i = 0; i < this.components.array.length; i++) {
    if (!castTo($get_8(this.components, i), 139).apply_1(t)) {
      return false;
    }
  }
  return true;
}
;
_.equals_0 = function equals_1(obj){
  var that;
  if (instanceOf(obj, 517)) {
    that = castTo(obj, 517);
    return $equals_2(this.components, that.components);
  }
  return false;
}
;
_.hashCode_1 = function hashCode_2(){
  return hashCode_45(this.components) + 306654252;
}
;
_.toString_0 = function toString_4(){
  return 'Predicates.and(' + $join(($clinit_Predicates() , COMMA_JOINER), new AbstractList$IteratorImpl(this.components)) + ')';
}
;
var Lcom_google_common_base_Predicates$AndPredicate_2_classLit = createForClass('com.google.common.base', 'Predicates/AndPredicate', 517);
function $apply(this$static, t){
  try {
    return this$static.target.contains(t);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 172)) {
      return false;
    }
     else if (instanceOf($e0, 182)) {
      return false;
    }
     else 
      throw toJs($e0);
  }
}

function Predicates$InPredicate(target){
  this.target = castTo(checkNotNull(target), 13);
}

defineClass(518, 1, {139:1, 518:1, 3:1, 56:1}, Predicates$InPredicate);
_.test_0 = function test_1(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_2(t){
  return $apply(this, t);
}
;
_.equals_0 = function equals_2(obj){
  var that;
  if (instanceOf(obj, 518)) {
    that = castTo(obj, 518);
    return equals_Ljava_lang_Object__Z__devirtual$(this.target, that.target);
  }
  return false;
}
;
_.hashCode_1 = function hashCode_3(){
  return hashCode__I__devirtual$(this.target);
}
;
_.toString_0 = function toString_5(){
  return 'Predicates.in(' + this.target + ')';
}
;
var Lcom_google_common_base_Predicates$InPredicate_2_classLit = createForClass('com.google.common.base', 'Predicates/InPredicate', 518);
function Present(reference){
  this.reference = reference;
}

defineClass(390, 1775, {390:1, 3:1}, Present);
_.equals_0 = function equals_3(object){
  var other;
  if (instanceOf(object, 390)) {
    other = castTo(object, 390);
    return equals_Ljava_lang_Object__Z__devirtual$(this.reference, other.reference);
  }
  return false;
}
;
_.hashCode_1 = function hashCode_4(){
  return 1502476572 + hashCode__I__devirtual$(this.reference);
}
;
_.toString_0 = function toString_6(){
  return 'Optional.of(' + this.reference + ')';
}
;
_.transform = function transform_0(function_0){
  return new Present(checkNotNull_0(function_0.apply_0(this.reference), 'the Function passed to Optional.transform() must not return null.'));
}
;
var Lcom_google_common_base_Present_2_classLit = createForClass('com.google.common.base', 'Present', 390);
defineClass(1745, 1, {});
_.toString_0 = function toString_7(){
  return toString_41(this.delegate_0());
}
;
var Lcom_google_common_collect_ForwardingObject_2_classLit = createForClass('com.google.common.collect', 'ForwardingObject', 1745);
function $forEach_1(this$static, consumer){
  var entry, entry$iterator;
  checkCriticalNotNull(consumer);
  for (entry$iterator = this$static.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    consumer.accept_0(entry.getKey(), entry.getValue());
  }
}

function $merge(this$static, key, value_0, remappingFunction){
  var currentValue, newValue;
  checkCriticalNotNull(remappingFunction);
  checkCriticalNotNull(value_0);
  currentValue = this$static.get_0(key);
  newValue = currentValue == null?value_0:addAll_12(castTo(currentValue, 15), castTo(value_0, 13));
  newValue == null?this$static.remove(key):this$static.put(key, newValue);
  return newValue;
}

var Ljava_util_Map_2_classLit = createForInterface('java.util', 'Map');
function $containsKey(this$static, key){
  return this$static.delegate_1().containsKey(key);
}

function $get(this$static, key){
  return this$static.delegate_1().get_0(key);
}

defineClass(1752, 1745, $intern_2);
_.delegate_0 = function delegate_0(){
  return this.delegate_1();
}
;
_.forEach = function forEach(consumer){
  $forEach_1(this, consumer);
}
;
_.merge = function merge(key, value_0, remappingFunction){
  return $merge(this, key, value_0, remappingFunction);
}
;
_.clear_0 = function clear_0(){
  this.delegate_1().clear_0();
}
;
_.containsKey = function containsKey(key){
  return $containsKey(this, key);
}
;
_.containsValue = function containsValue(value_0){
  return this.delegate_1().containsValue(value_0);
}
;
_.entrySet_0 = function entrySet(){
  return this.delegate_1().entrySet_0();
}
;
_.equals_0 = function equals_4(object){
  return object === this || $equals(this.delegate_1(), object);
}
;
_.get_0 = function get_0(key){
  return $get(this, key);
}
;
_.hashCode_1 = function hashCode_5(){
  return hashCode_44(this.delegate_1().entrySet_0());
}
;
_.isEmpty = function isEmpty(){
  return this.delegate_1().size_1() == 0;
}
;
_.keySet_0 = function keySet(){
  return this.delegate_1().keySet_0();
}
;
_.put = function put(key, value_0){
  return this.delegate_1().put(key, value_0);
}
;
_.remove = function remove_0(object){
  return this.delegate_1().remove(object);
}
;
_.size_1 = function size_1(){
  return this.delegate_1().size_1();
}
;
_.values_0 = function values_1(){
  return new AbstractMap$2(this.delegate_1());
}
;
var Lcom_google_common_collect_ForwardingMap_2_classLit = createForClass('com.google.common.collect', 'ForwardingMap', 1752);
function $clear(this$static){
  this$static.delegate.clear_0();
  this$static.inverse.delegate.clear_0();
}

function $containsValue(this$static, value_0){
  return $containsKey(this$static.inverse, value_0);
}

function $entrySet(this$static){
  var result;
  result = this$static.entrySet;
  return !result?(this$static.entrySet = new AbstractBiMap$EntrySet(this$static)):result;
}

function $keySet(this$static){
  var result;
  result = this$static.keySet;
  return !result?(this$static.keySet = new AbstractBiMap$KeySet(this$static)):result;
}

function $putInBothMaps(this$static, key, value_0, force){
  var containedKey, oldValue;
  this$static.checkKey(key);
  this$static.checkValue(value_0);
  containedKey = this$static.delegate.containsKey(key);
  if (containedKey && equal(value_0, this$static.delegate.get_0(key))) {
    return value_0;
  }
  force?$remove(this$static.inverse, value_0):checkArgument_1(!$containsKey(this$static.inverse, value_0), value_0);
  oldValue = this$static.delegate.put(key, value_0);
  containedKey && this$static.inverse.delegate.remove(oldValue);
  this$static.inverse.delegate.put(value_0, key);
  return oldValue;
}

function $remove(this$static, key){
  return this$static.delegate.containsKey(key)?$removeFromBothMaps(this$static, key):null;
}

function $removeFromBothMaps(this$static, key){
  var oldValue;
  oldValue = this$static.delegate.remove(key);
  this$static.inverse.delegate.remove(oldValue);
  return oldValue;
}

function $removeFromInverseMap(this$static, oldValue){
  this$static.inverse.delegate.remove(oldValue);
}

function $updateInverseMap(this$static, key, oldValue, newValue){
  this$static.inverse.delegate.remove(oldValue);
  this$static.inverse.delegate.put(newValue, key);
}

function AbstractBiMap(forward_0, backward){
  checkState(!this.delegate);
  checkState(!this.inverse);
  checkArgument($size_0(forward_0.map_0) == 0);
  checkArgument(backward.hashCodeMap.size_0 + backward.stringMap.size_0 == 0);
  checkArgument(true);
  this.delegate = forward_0;
  this.inverse = this.makeInverse(backward);
}

defineClass(654, 1752, $intern_3);
_.values_0 = function values_2(){
  var result;
  return result = this.valueSet , !result?(this.valueSet = new AbstractBiMap$ValueSet(this)):result;
}
;
_.checkKey = function checkKey(key){
  return key;
}
;
_.checkValue = function checkValue(value_0){
  return value_0;
}
;
_.clear_0 = function clear_1(){
  $clear(this);
}
;
_.containsValue = function containsValue_0(value_0){
  return $containsValue(this, value_0);
}
;
_.delegate_1 = function delegate_1(){
  return this.delegate;
}
;
_.entrySet_0 = function entrySet_0(){
  return $entrySet(this);
}
;
_.entrySetIterator = function entrySetIterator(){
  var iterator;
  iterator = this.delegate.entrySet_0().iterator_0();
  return new AbstractBiMap$1(this, iterator);
}
;
_.keySet_0 = function keySet_0(){
  return $keySet(this);
}
;
_.makeInverse = function makeInverse(backward){
  return new AbstractBiMap$Inverse(backward, this);
}
;
_.put = function put_0(key, value_0){
  return $putInBothMaps(this, key, value_0, false);
}
;
_.remove = function remove_1(key){
  return $remove(this, key);
}
;
_.values_1 = function values_3(){
  var result;
  return result = this.valueSet , !result?(this.valueSet = new AbstractBiMap$ValueSet(this)):result;
}
;
var Lcom_google_common_collect_AbstractBiMap_2_classLit = createForClass('com.google.common.collect', 'AbstractBiMap', 654);
function $forEachRemaining(this$static, consumer){
  checkCriticalNotNull(consumer);
  while (this$static.hasNext_0()) {
    consumer.accept(this$static.next_1());
  }
}

function $remove_21(){
  throw toJs(new UnsupportedOperationException);
}

function AbstractBiMap$1(this$0, val$iterator){
  this.this$01 = this$0;
  this.val$iterator2 = val$iterator;
}

defineClass(936, 1, $intern_4, AbstractBiMap$1);
_.forEachRemaining = function forEachRemaining(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_0(){
  return this.entry = castTo(this.val$iterator2.next_1(), 39) , new AbstractBiMap$BiMapEntry(this.this$01, this.entry);
}
;
_.hasNext_0 = function hasNext(){
  return this.val$iterator2.hasNext_0();
}
;
_.remove_0 = function remove_2(){
  var value_0;
  checkState_0(!!this.entry, 'no calls to next() since the last call to remove()');
  value_0 = this.entry.getValue();
  this.val$iterator2.remove_0();
  $removeFromInverseMap(this.this$01, value_0);
}
;
var Lcom_google_common_collect_AbstractBiMap$1_2_classLit = createForClass('com.google.common.collect', 'AbstractBiMap/1', 936);
var Ljava_util_Map$Entry_2_classLit = createForInterface('java.util', 'Map/Entry');
defineClass(1753, 1745, $intern_5);
_.delegate_0 = function delegate_2(){
  return this.delegate;
}
;
_.equals_0 = function equals_5(object){
  return this.delegate.equals_0(object);
}
;
_.getKey = function getKey(){
  return this.delegate.getKey();
}
;
_.getValue = function getValue(){
  return this.delegate.getValue();
}
;
_.hashCode_1 = function hashCode_6(){
  return this.delegate.hashCode_1();
}
;
_.setValue = function setValue(value_0){
  return this.delegate.setValue(value_0);
}
;
var Lcom_google_common_collect_ForwardingMapEntry_2_classLit = createForClass('com.google.common.collect', 'ForwardingMapEntry', 1753);
function AbstractBiMap$BiMapEntry(this$0, delegate){
  this.this$01 = this$0;
  this.delegate = delegate;
}

defineClass(934, 1753, $intern_5, AbstractBiMap$BiMapEntry);
_.setValue = function setValue_0(value_0){
  var oldValue;
  checkState_0($contains($entrySet(this.this$01), this), 'entry no longer in map');
  if (equal(value_0, this.delegate.getValue())) {
    return value_0;
  }
  checkArgument_1(!$containsValue(this.this$01, value_0), value_0);
  oldValue = this.delegate.setValue(value_0);
  checkState_0(equal(value_0, $get(this.this$01, this.delegate.getKey())), 'entry no longer in map');
  $updateInverseMap(this.this$01, this.delegate.getKey(), oldValue, value_0);
  return oldValue;
}
;
var Lcom_google_common_collect_AbstractBiMap$BiMapEntry_2_classLit = createForClass('com.google.common.collect', 'AbstractBiMap/BiMapEntry', 934);
function $forEach(this$static, action){
  var t, t$iterator;
  checkCriticalNotNull(action);
  for (t$iterator = this$static.iterator_0(); t$iterator.hasNext_0();) {
    t = t$iterator.next_1();
    action.accept(t);
  }
}

defineClass(1746, 1745, $intern_6);
_.delegate_0 = function delegate_3(){
  return this.delegate_2();
}
;
_.forEach_0 = function forEach_0(action){
  $forEach(this, action);
}
;
_.parallelStream = function parallelStream(){
  return this.stream();
}
;
_.spliterator_0 = function spliterator_0(){
  return new Spliterators$IteratorSpliterator(this, 0);
}
;
_.stream = function stream(){
  return new Stream$StreamSource(null, this.spliterator_0());
}
;
_.add_1 = function add_1(element){
  return this.delegate_2().add_1(element);
}
;
_.addAll = function addAll(collection){
  return this.delegate_2().addAll(collection);
}
;
_.clear_0 = function clear_2(){
  this.delegate_2().clear_0();
}
;
_.contains = function contains(object){
  return this.delegate_2().contains(object);
}
;
_.containsAll = function containsAll(collection){
  return this.delegate_2().containsAll(collection);
}
;
_.isEmpty = function isEmpty_0(){
  return this.delegate_2().isEmpty();
}
;
_.iterator_0 = function iterator_0(){
  return this.delegate_2().iterator_0();
}
;
_.remove_1 = function remove_3(object){
  return this.delegate_2().remove_1(object);
}
;
_.size_1 = function size_2(){
  return this.delegate_2().size_1();
}
;
_.toArray = function toArray(){
  return this.delegate_2().toArray();
}
;
_.toArray_0 = function toArray_0(array){
  return this.delegate_2().toArray_0(array);
}
;
var Lcom_google_common_collect_ForwardingCollection_2_classLit = createForClass('com.google.common.collect', 'ForwardingCollection', 1746);
var Ljava_util_Set_2_classLit = createForInterface('java.util', 'Set');
defineClass(1747, 1746, $intern_7);
_.delegate_2 = function delegate_4(){
  return this.delegate_3();
}
;
_.spliterator_0 = function spliterator_1(){
  return new Spliterators$IteratorSpliterator(this, 1);
}
;
_.equals_0 = function equals_6(object){
  return object === this || equals_Ljava_lang_Object__Z__devirtual$(this.delegate_3(), object);
}
;
_.hashCode_1 = function hashCode_7(){
  return hashCode__I__devirtual$(this.delegate_3());
}
;
var Lcom_google_common_collect_ForwardingSet_2_classLit = createForClass('com.google.common.collect', 'ForwardingSet', 1747);
function $contains(this$static, o){
  return containsEntryImpl(this$static.esDelegate, o);
}

function AbstractBiMap$EntrySet(this$0){
  this.this$01 = this$0;
  this.esDelegate = this.this$01.delegate.entrySet_0();
}

defineClass(935, 1747, $intern_7, AbstractBiMap$EntrySet);
_.clear_0 = function clear_3(){
  $clear(this.this$01);
}
;
_.contains = function contains_0(o){
  return $contains(this, o);
}
;
_.containsAll = function containsAll_0(c){
  return $clinit_Collections2() , all_0(c, ($clinit_Predicates() , new Predicates$InPredicate(this)));
}
;
_.delegate_3 = function delegate_5(){
  return this.esDelegate;
}
;
_.iterator_0 = function iterator_1(){
  return this.this$01.entrySetIterator();
}
;
_.remove_1 = function remove_4(object){
  var entry;
  if (!this.esDelegate.contains(object)) {
    return false;
  }
  entry = castTo(object, 39);
  this.this$01.inverse.delegate.remove(entry.getValue());
  this.esDelegate.remove_1(entry);
  return true;
}
;
_.toArray = function toArray_1(){
  var newArray;
  return newArray = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, this.esDelegate.size_1(), 5, 1) , toArrayImpl(this, newArray);
}
;
_.toArray_0 = function toArray_2(array){
  return toArrayImpl(this, array);
}
;
var Lcom_google_common_collect_AbstractBiMap$EntrySet_2_classLit = createForClass('com.google.common.collect', 'AbstractBiMap/EntrySet', 935);
function AbstractBiMap$Inverse(backward, forward_0){
  this.delegate = backward;
  this.inverse = forward_0;
}

defineClass(655, 654, $intern_3, AbstractBiMap$Inverse);
_.checkKey = function checkKey_0(key){
  return this.inverse.checkValue(key);
}
;
_.checkValue = function checkValue_0(value_0){
  return this.inverse.checkKey(value_0);
}
;
var Lcom_google_common_collect_AbstractBiMap$Inverse_2_classLit = createForClass('com.google.common.collect', 'AbstractBiMap/Inverse', 655);
function AbstractBiMap$KeySet(this$0){
  this.this$01 = this$0;
}

defineClass(933, 1747, $intern_7, AbstractBiMap$KeySet);
_.clear_0 = function clear_4(){
  $clear(this.this$01);
}
;
_.delegate_3 = function delegate_6(){
  return this.this$01.delegate.keySet_0();
}
;
_.iterator_0 = function iterator_2(){
  return $clinit_Maps() , transform_3($entrySet(this.this$01).this$01.entrySetIterator(), ($clinit_Maps$EntryFunction() , KEY));
}
;
_.remove_1 = function remove_5(key){
  if (!this.this$01.delegate.keySet_0().contains(key)) {
    return false;
  }
  $removeFromBothMaps(this.this$01, key);
  return true;
}
;
var Lcom_google_common_collect_AbstractBiMap$KeySet_2_classLit = createForClass('com.google.common.collect', 'AbstractBiMap/KeySet', 933);
function AbstractBiMap$ValueSet(this$0){
  this.this$01 = this$0;
  this.valuesDelegate = $keySet(this.this$01.inverse);
}

defineClass(656, 1747, $intern_7, AbstractBiMap$ValueSet);
_.delegate_3 = function delegate_7(){
  return this.valuesDelegate;
}
;
_.iterator_0 = function iterator_3(){
  return $clinit_Maps() , transform_3($entrySet(this.this$01).this$01.entrySetIterator(), ($clinit_Maps$EntryFunction() , VALUE));
}
;
_.toArray = function toArray_3(){
  var newArray;
  return newArray = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, this.valuesDelegate.this$01.delegate.keySet_0().size_1(), 5, 1) , toArrayImpl(this, newArray);
}
;
_.toArray_0 = function toArray_4(array){
  return toArrayImpl(this, array);
}
;
_.toString_0 = function toString_8(){
  var sb;
  return $clinit_Collections2() , sb = $append_5(newStringBuilderForCollection(this.valuesDelegate.this$01.delegate.keySet_0().size_1()), 91) , $appendTo_0(STANDARD_JOINER, sb, $iterator_1(transform_2(this, new Collections2$1(this)))) , (sb.string += ']' , sb).string;
}
;
var Lcom_google_common_collect_AbstractBiMap$ValueSet_2_classLit = createForClass('com.google.common.collect', 'AbstractBiMap/ValueSet', 656);
function $remove_0(){
  throw toJs(new UnsupportedOperationException);
}

defineClass(267, 1, $intern_8);
_.forEachRemaining = function forEachRemaining_0(consumer){
  $forEachRemaining(this, consumer);
}
;
_.remove_0 = function remove_6(){
  $remove_0();
}
;
var Lcom_google_common_collect_UnmodifiableIterator_2_classLit = createForClass('com.google.common.collect', 'UnmodifiableIterator', 267);
defineClass(1749, 267, $intern_9);
_.remove_0 = function remove_7(){
  $remove_0();
}
;
_.add_2 = function add_2(e){
  throw toJs(new UnsupportedOperationException);
}
;
_.set_1 = function set_1(e){
  throw toJs(new UnsupportedOperationException);
}
;
var Lcom_google_common_collect_UnmodifiableListIterator_2_classLit = createForClass('com.google.common.collect', 'UnmodifiableListIterator', 1749);
defineClass(880, 1749, $intern_9);
_.hasNext_0 = function hasNext_0(){
  return this.position < this.size_0;
}
;
_.hasPrevious = function hasPrevious(){
  return this.position > 0;
}
;
_.next_1 = function next_1(){
  if (this.position >= this.size_0) {
    throw toJs(new NoSuchElementException);
  }
  return $get_2(this, this.position++);
}
;
_.nextIndex_0 = function nextIndex_0(){
  return this.position;
}
;
_.previous_0 = function previous_0(){
  if (this.position <= 0) {
    throw toJs(new NoSuchElementException);
  }
  return $get_2(this, --this.position);
}
;
_.previousIndex = function previousIndex(){
  return this.position - 1;
}
;
_.position = 0;
_.size_0 = 0;
var Lcom_google_common_collect_AbstractIndexedListIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractIndexedListIterator', 880);
function $hasNext(this$static){
  checkState(this$static.state != 3);
  switch (this$static.state) {
    case 2:
      return false;
    case 0:
      return true;
  }
  return $tryToComputeNext(this$static);
}

function $next(this$static){
  var result;
  if (!$hasNext(this$static)) {
    throw toJs(new NoSuchElementException);
  }
  this$static.state = 1;
  result = this$static.next_0;
  this$static.next_0 = null;
  return result;
}

function $tryToComputeNext(this$static){
  this$static.state = 3;
  this$static.next_0 = $computeNext(this$static);
  if (this$static.state != 2) {
    this$static.state = 0;
    return true;
  }
  return false;
}

defineClass(987, 267, $intern_8);
_.hasNext_0 = function hasNext_1(){
  return $hasNext(this);
}
;
_.next_1 = function next_2(){
  return $next(this);
}
;
_.state = 1;
var Lcom_google_common_collect_AbstractIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractIterator', 987);
function $containsEntry(this$static, key, value_0){
  var collection;
  collection = castTo(this$static.asMap_0().get_0(key), 13);
  return !!collection && collection.contains(value_0);
}

function $containsValue_0(this$static, value_0){
  var collection, collection$iterator;
  for (collection$iterator = this$static.asMap_0().values_0().iterator_0(); collection$iterator.hasNext_0();) {
    collection = castTo(collection$iterator.next_1(), 13);
    if (collection.contains(value_0)) {
      return true;
    }
  }
  return false;
}

function $keySet_0(this$static){
  var result;
  result = this$static.keySet;
  return !result?(this$static.keySet = this$static.createKeySet()):result;
}

function $remove_1(this$static, key, value_0){
  var collection;
  collection = castTo(this$static.asMap_0().get_0(key), 13);
  return !!collection && collection.remove_1(value_0);
}

defineClass(1761, 1, {249:1});
_.asMap_0 = function asMap(){
  var result;
  return result = this.asMap , !result?(this.asMap = this.createAsMap()):result;
}
;
_.createKeySet = function createKeySet(){
  return new Maps$KeySet(this.asMap_0());
}
;
_.entrySpliterator = function entrySpliterator_0(){
  return new Spliterators$IteratorSpliterator_1(this.entryIterator_0(), this.size_1(), instanceOf(this, 494)?1:0);
}
;
_.equals_0 = function equals_7(object){
  return equalsImpl_0(this, object);
}
;
_.hashCode_1 = function hashCode_8(){
  return hashCode__I__devirtual$(this.asMap_0());
}
;
_.isEmpty = function isEmpty_1(){
  return this.size_1() == 0;
}
;
_.keySet_0 = function keySet_1(){
  return $keySet_0(this);
}
;
_.toString_0 = function toString_9(){
  return toString_41(this.asMap_0());
}
;
var Lcom_google_common_collect_AbstractMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractMultimap', 1761);
function $clear_0(this$static){
  var collection, collection$iterator;
  for (collection$iterator = this$static.map_0.values_0().iterator_0(); collection$iterator.hasNext_0();) {
    collection = castTo(collection$iterator.next_1(), 13);
    collection.clear_0();
  }
  this$static.map_0.clear_0();
  this$static.totalSize = 0;
}

function $get_0(this$static, key){
  var collection;
  collection = castTo(this$static.map_0.get_0(key), 13);
  !collection && (collection = this$static.createCollection_0(key));
  return instanceOf(collection, 200)?new AbstractMapBasedMultimap$WrappedNavigableSet(this$static, key, castTo(collection, 200)):instanceOf(collection, 62)?new AbstractMapBasedMultimap$WrappedSortedSet(this$static, key, castTo(collection, 62)):instanceOf(collection, 19)?new AbstractMapBasedMultimap$WrappedSet(this$static, key, castTo(collection, 19)):instanceOf(collection, 15)?$wrapList(this$static, key, castTo(collection, 15), null):new AbstractMapBasedMultimap$WrappedCollection(this$static, key, collection, null);
}

function $put(this$static, key, value_0){
  var collection;
  collection = castTo(this$static.map_0.get_0(key), 13);
  if (!collection) {
    collection = this$static.createCollection_0(key);
    if (collection.add_1(value_0)) {
      ++this$static.totalSize;
      this$static.map_0.put(key, collection);
      return true;
    }
     else {
      throw toJs(new AssertionError_0('New Collection violated the Collection spec'));
    }
  }
   else if (collection.add_1(value_0)) {
    ++this$static.totalSize;
    return true;
  }
   else {
    return false;
  }
}

function $removeAll(this$static, key){
  var collection, output;
  collection = castTo(this$static.map_0.remove(key), 13);
  if (!collection) {
    return this$static.createUnmodifiableEmptyCollection();
  }
  output = this$static.createCollection();
  output.addAll(collection);
  this$static.totalSize -= collection.size_1();
  collection.clear_0();
  return instanceOf(output, 200)?unmodifiableNavigableSet(castTo(output, 200)):instanceOf(output, 62)?($clinit_Collections() , new Collections$UnmodifiableSortedSet(castTo(output, 62))):instanceOf(output, 19)?($clinit_Collections() , new Collections$UnmodifiableSet(castTo(output, 19))):instanceOf(output, 15)?unmodifiableList(castTo(output, 15)):($clinit_Collections() , new Collections$UnmodifiableCollection(output));
}

function $removeValuesForKey(this$static, key){
  var collection, count;
  collection = castTo(safeRemove(this$static.map_0, key), 13);
  if (collection) {
    count = collection.size_1();
    collection.clear_0();
    this$static.totalSize -= count;
  }
}

function $values(this$static){
  var result;
  return result = this$static.values , !result?(this$static.values = new AbstractMultimap$Values(this$static)):result;
}

function $wrapCollection(this$static, key, collection){
  return instanceOf(collection, 200)?new AbstractMapBasedMultimap$WrappedNavigableSet(this$static, key, castTo(collection, 200)):instanceOf(collection, 62)?new AbstractMapBasedMultimap$WrappedSortedSet(this$static, key, castTo(collection, 62)):instanceOf(collection, 19)?new AbstractMapBasedMultimap$WrappedSet(this$static, key, castTo(collection, 19)):instanceOf(collection, 15)?$wrapList(this$static, key, castTo(collection, 15), null):new AbstractMapBasedMultimap$WrappedCollection(this$static, key, collection, null);
}

function $wrapList(this$static, key, list, ancestor){
  return instanceOf(list, 50)?new AbstractMapBasedMultimap$RandomAccessWrappedList(this$static, key, list, ancestor):new AbstractMapBasedMultimap$WrappedList(this$static, key, list, ancestor);
}

function AbstractMapBasedMultimap(map_0){
  checkArgument(map_0.isEmpty());
  this.map_0 = map_0;
}

function iteratorOrListIterator(collection){
  return instanceOf(collection, 15)?castTo(collection, 15).listIterator_0():collection.iterator_0();
}

function lambda$2(key_0, value_1){
  return $clinit_Maps() , new ImmutableEntry(key_0, value_1);
}

function unmodifiableCollectionSubclass(collection){
  return instanceOf(collection, 200)?unmodifiableNavigableSet(castTo(collection, 200)):instanceOf(collection, 62)?($clinit_Collections() , new Collections$UnmodifiableSortedSet(castTo(collection, 62))):instanceOf(collection, 19)?($clinit_Collections() , new Collections$UnmodifiableSet(castTo(collection, 19))):instanceOf(collection, 15)?unmodifiableList(castTo(collection, 15)):($clinit_Collections() , new Collections$UnmodifiableCollection(collection));
}

defineClass(673, 1761, $intern_10);
_.clear_0 = function clear_5(){
  $clear_0(this);
}
;
_.containsKey = function containsKey_0(key){
  return this.map_0.containsKey(key);
}
;
_.createAsMap = function createAsMap(){
  return instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableAsMap(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedAsMap(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$AsMap(this, this.map_0);
}
;
_.createCollection_0 = function createCollection(key){
  return this.createCollection();
}
;
_.createKeySet = function createKeySet_0(){
  return instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableKeySet(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedKeySet(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$KeySet(this, this.map_0);
}
;
_.createUnmodifiableEmptyCollection = function createUnmodifiableEmptyCollection(){
  return unmodifiableCollectionSubclass(this.createCollection());
}
;
_.entryIterator_0 = function entryIterator_0(){
  return new AbstractMapBasedMultimap$2(this);
}
;
_.entrySpliterator = function entrySpliterator_1(){
  return flatMap(this.map_0.entrySet_0().spliterator_0(), new AbstractMapBasedMultimap$lambda$0$Type, 64, this.totalSize);
}
;
_.get_1 = function get_1(key){
  return $get_0(this, key);
}
;
_.removeAll = function removeAll(key){
  return $removeAll(this, key);
}
;
_.size_1 = function size_3(){
  return this.totalSize;
}
;
_.valueIterator_0 = function valueIterator(){
  return new AbstractMapBasedMultimap$1(this);
}
;
_.valueSpliterator = function valueSpliterator(){
  return flatMap(this.map_0.values_0().spliterator_0(), new AbstractMapBasedMultimap$1methodref$spliterator$Type, 64, this.totalSize);
}
;
_.totalSize = 0;
var Lcom_google_common_collect_AbstractMapBasedMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap', 673);
function AbstractListMultimap(map_0){
  AbstractMapBasedMultimap.call(this, map_0);
}

defineClass(1478, 673, $intern_10);
_.createCollection = function createCollection_0(){
  return new ArrayList_0(this.expectedValuesPerKey);
}
;
_.createUnmodifiableEmptyCollection = function createUnmodifiableEmptyCollection_0(){
  return $clinit_ImmutableList() , $clinit_ImmutableList() , EMPTY;
}
;
_.get_1 = function get_2(key){
  return castTo($get_0(this, key), 15);
}
;
_.removeAll = function removeAll_0(key){
  return castTo($removeAll(this, key), 15);
}
;
_.asMap_0 = function asMap_0(){
  var result;
  return result = this.asMap , !result?(this.asMap = instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableAsMap(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedAsMap(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$AsMap(this, this.map_0)):result;
}
;
_.equals_0 = function equals_8(object){
  return equalsImpl_0(this, object);
}
;
_.get_2 = function get_3(key){
  return castTo($get_0(this, key), 15);
}
;
_.removeAll_0 = function removeAll_1(key){
  return castTo($removeAll(this, key), 15);
}
;
var Lcom_google_common_collect_AbstractListMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractListMultimap', 1478);
function AbstractMapBasedMultimap$Itr(this$0){
  this.this$01 = this$0;
  this.keyIterator = this$0.map_0.entrySet_0().iterator_0();
  this.key = null;
  this.collection = null;
  this.valueIterator = ($clinit_Iterators() , $clinit_Iterators() , EMPTY_MODIFIABLE_ITERATOR);
}

defineClass(680, 1, $intern_4);
_.forEachRemaining = function forEachRemaining_1(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_2(){
  return this.keyIterator.hasNext_0() || this.valueIterator.hasNext_0();
}
;
_.next_1 = function next_3(){
  var mapEntry;
  if (!this.valueIterator.hasNext_0()) {
    mapEntry = castTo(this.keyIterator.next_1(), 39);
    this.key = mapEntry.getKey();
    this.collection = castTo(mapEntry.getValue(), 13);
    this.valueIterator = this.collection.iterator_0();
  }
  return this.output(this.key, this.valueIterator.next_1());
}
;
_.remove_0 = function remove_8(){
  this.valueIterator.remove_0();
  this.collection.isEmpty() && this.keyIterator.remove_0();
  --this.this$01.totalSize;
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$Itr_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/Itr', 680);
function AbstractMapBasedMultimap$1(this$0){
  AbstractMapBasedMultimap$Itr.call(this, this$0);
}

defineClass(1011, 680, $intern_4, AbstractMapBasedMultimap$1);
_.output = function output_0(key, value_0){
  return value_0;
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$1_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/1', 1011);
function AbstractMapBasedMultimap$1methodref$spliterator$Type(){
}

defineClass(1012, 1, $intern_11, AbstractMapBasedMultimap$1methodref$spliterator$Type);
_.apply_0 = function apply_3(arg0){
  return castTo(arg0, 13).spliterator_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$1methodref$spliterator$Type_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/1methodref$spliterator$Type', 1012);
function AbstractMapBasedMultimap$2(this$0){
  AbstractMapBasedMultimap$Itr.call(this, this$0);
}

defineClass(1013, 680, $intern_4, AbstractMapBasedMultimap$2);
_.output = function output_1(key, value_0){
  return $clinit_Maps() , new ImmutableEntry(key, value_0);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$2_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/2', 1013);
function $containsEntry_0(this$static, entry){
  var key, ourValue, value_0;
  key = entry.getKey();
  value_0 = entry.getValue();
  ourValue = this$static.get_0(key);
  if (!(maskUndefined(value_0) === maskUndefined(ourValue) || value_0 != null && equals_Ljava_lang_Object__Z__devirtual$(value_0, ourValue))) {
    return false;
  }
  if (ourValue == null && !this$static.containsKey(key)) {
    return false;
  }
  return true;
}

function $equals(this$static, obj){
  var entry, entry$iterator, otherMap;
  if (obj === this$static) {
    return true;
  }
  if (!instanceOf(obj, 111)) {
    return false;
  }
  otherMap = castTo(obj, 111);
  if (this$static.size_1() != otherMap.size_1()) {
    return false;
  }
  for (entry$iterator = otherMap.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    if (!this$static.containsEntry(entry)) {
      return false;
    }
  }
  return true;
}

function $implFindEntry(this$static, key, remove){
  var entry, iter, k;
  for (iter = this$static.entrySet_0().iterator_0(); iter.hasNext_0();) {
    entry = castTo(iter.next_1(), 39);
    k = entry.getKey();
    if (maskUndefined(key) === maskUndefined(k) || key != null && equals_Ljava_lang_Object__Z__devirtual$(key, k)) {
      if (remove) {
        entry = new AbstractMap$SimpleEntry(entry.getKey(), entry.getValue());
        iter.remove_0();
      }
      return entry;
    }
  }
  return null;
}

function $putAll(this$static, map_0){
  var e, e$iterator;
  checkCriticalNotNull(map_0);
  for (e$iterator = map_0.entrySet_0().iterator_0(); e$iterator.hasNext_0();) {
    e = castTo(e$iterator.next_1(), 39);
    this$static.put(e.getKey(), e.getValue());
  }
}

function $toString_0(this$static, o){
  return o === this$static?'(this Map)':o == null?'null':toString_41(o);
}

function getEntryKeyOrNull(entry){
  return !entry?null:entry.key;
}

function getEntryValueOrNull(entry){
  return !entry?null:entry.getValue();
}

defineClass(1750, 1, $intern_2);
_.forEach = function forEach_1(consumer){
  $forEach_1(this, consumer);
}
;
_.merge = function merge_0(key, value_0, remappingFunction){
  return $merge(this, key, value_0, remappingFunction);
}
;
_.clear_0 = function clear_6(){
  this.entrySet_0().clear_0();
}
;
_.containsEntry = function containsEntry(entry){
  return $containsEntry_0(this, entry);
}
;
_.containsKey = function containsKey_1(key){
  return !!$implFindEntry(this, key, false);
}
;
_.containsValue = function containsValue_1(value_0){
  var entry, entry$iterator, v;
  for (entry$iterator = this.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    v = entry.getValue();
    if (maskUndefined(value_0) === maskUndefined(v) || value_0 != null && equals_Ljava_lang_Object__Z__devirtual$(value_0, v)) {
      return true;
    }
  }
  return false;
}
;
_.equals_0 = function equals_9(obj){
  return $equals(this, obj);
}
;
_.get_0 = function get_4(key){
  return getEntryValueOrNull($implFindEntry(this, key, false));
}
;
_.hashCode_1 = function hashCode_9(){
  return hashCode_44(this.entrySet_0());
}
;
_.isEmpty = function isEmpty_2(){
  return this.size_1() == 0;
}
;
_.keySet_0 = function keySet_2(){
  return new AbstractMap$1(this);
}
;
_.put = function put_1(key, value_0){
  throw toJs(new UnsupportedOperationException_0('Put not supported on this map'));
}
;
_.remove = function remove_9(key){
  return getEntryValueOrNull($implFindEntry(this, key, true));
}
;
_.size_1 = function size_4(){
  return this.entrySet_0().size_1();
}
;
_.toString_0 = function toString_10(){
  var entry, entry$iterator, joiner;
  joiner = new StringJoiner('{', '}');
  for (entry$iterator = this.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    $add_9(joiner, $toString_0(this, entry.getKey()) + '=' + $toString_0(this, entry.getValue()));
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}
;
_.values_0 = function values_4(){
  return new AbstractMap$2(this);
}
;
var Ljava_util_AbstractMap_2_classLit = createForClass('java.util', 'AbstractMap', 1750);
function $entrySet_0(this$static){
  var result;
  result = this$static.entrySet;
  return !result?(this$static.entrySet = this$static.createEntrySet()):result;
}

defineClass(1762, 1750, $intern_2);
_.createKeySet = function createKeySet_1(){
  return new Maps$KeySet(this);
}
;
_.entrySet_0 = function entrySet_1(){
  return $entrySet_0(this);
}
;
_.keySet_0 = function keySet_3(){
  var result;
  result = this.keySet;
  return !result?(this.keySet = this.createKeySet()):result;
}
;
_.values_0 = function values_5(){
  var result;
  result = this.values;
  return !result?(this.values = new Maps$Values(this)):result;
}
;
var Lcom_google_common_collect_Maps$ViewCachingAbstractMap_2_classLit = createForClass('com.google.common.collect', 'Maps/ViewCachingAbstractMap', 1762);
function $get_1(this$static, key){
  var collection;
  collection = castTo(safeGet(this$static.submap, key), 13);
  if (!collection) {
    return null;
  }
  return $wrapCollection(this$static.this$01_1, key, collection);
}

function $remove_2(this$static, key){
  var collection, output;
  collection = castTo(this$static.submap.remove(key), 13);
  if (!collection) {
    return null;
  }
  output = this$static.this$01_1.createCollection();
  output.addAll(collection);
  this$static.this$01_1.totalSize -= collection.size_1();
  collection.clear_0();
  return output;
}

function $wrapEntry(this$static, entry){
  var key;
  key = entry.getKey();
  return $clinit_Maps() , new ImmutableEntry(key, $wrapCollection(this$static.this$01_1, key, castTo(entry.getValue(), 13)));
}

function AbstractMapBasedMultimap$AsMap(this$0, submap){
  this.this$01_1 = this$0;
  this.submap = submap;
}

defineClass(369, 1762, $intern_2, AbstractMapBasedMultimap$AsMap);
_.get_0 = function get_5(key){
  return $get_1(this, key);
}
;
_.remove = function remove_10(key){
  return $remove_2(this, key);
}
;
_.clear_0 = function clear_7(){
  this.submap == this.this$01_1.map_0?this.this$01_1.clear_0():clear_17(new AbstractMapBasedMultimap$AsMap$AsMapIterator(this));
}
;
_.containsKey = function containsKey_2(key){
  return safeContainsKey(this.submap, key);
}
;
_.createEntrySet_0 = function createEntrySet(){
  return new AbstractMapBasedMultimap$AsMap$AsMapEntries(this);
}
;
_.createEntrySet = function(){
  return this.createEntrySet_0();
}
;
_.equals_0 = function equals_10(object){
  return this === object || equals_Ljava_lang_Object__Z__devirtual$(this.submap, object);
}
;
_.hashCode_1 = function hashCode_10(){
  return hashCode__I__devirtual$(this.submap);
}
;
_.keySet_0 = function keySet_4(){
  return this.this$01_1.keySet_0();
}
;
_.size_1 = function size_5(){
  return this.submap.size_1();
}
;
_.toString_0 = function toString_11(){
  return toString_41(this.submap);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$AsMap_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/AsMap', 369);
function $addAll(this$static, c){
  var changed, e, e$iterator;
  checkCriticalNotNull(c);
  changed = false;
  for (e$iterator = c.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    changed = changed | this$static.add_1(e);
  }
  return changed;
}

function $advanceToFind(this$static, o, remove){
  var e, iter;
  for (iter = this$static.iterator_0(); iter.hasNext_0();) {
    e = iter.next_1();
    if (maskUndefined(o) === maskUndefined(e) || o != null && equals_Ljava_lang_Object__Z__devirtual$(o, e)) {
      remove && iter.remove_0();
      return true;
    }
  }
  return false;
}

function $clear_1(this$static){
  var iter;
  for (iter = this$static.iterator_0(); iter.hasNext_0();) {
    iter.next_1();
    iter.remove_0();
  }
}

function $containsAll(this$static, c){
  var e, e$iterator;
  checkCriticalNotNull(c);
  for (e$iterator = c.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    if (!this$static.contains(e)) {
      return false;
    }
  }
  return true;
}

function $toArray(this$static){
  return this$static.toArray_0(initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, this$static.size_1(), 5, 1));
}

function $toArray_0(this$static, a){
  var i, it, result, size_0;
  size_0 = this$static.size_1();
  a.length < size_0 && (a = (result = new Array(size_0) , stampJavaTypeInfo_0(result, a)));
  it = this$static.iterator_0();
  for (i = 0; i < size_0; ++i) {
    setCheck(a, i, it.next_1());
  }
  a.length > size_0 && setCheck(a, size_0, null);
  return a;
}

function $toString_1(this$static){
  var e, e$iterator, joiner;
  joiner = new StringJoiner('[', ']');
  for (e$iterator = this$static.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    $add_9(joiner, e === this$static?'(this Collection)':e == null?'null':toString_41(e));
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

defineClass(28, 1, $intern_12);
_.forEach_0 = function forEach_2(action){
  $forEach(this, action);
}
;
_.parallelStream = function parallelStream_0(){
  return new Stream$StreamSource(null, this.spliterator_0());
}
;
_.spliterator_0 = function spliterator_2(){
  return new Spliterators$IteratorSpliterator(this, 0);
}
;
_.stream = function stream_0(){
  return new Stream$StreamSource(null, this.spliterator_0());
}
;
_.add_1 = function add_3(o){
  throw toJs(new UnsupportedOperationException_0('Add not supported on this collection'));
}
;
_.addAll = function addAll_0(c){
  return $addAll(this, c);
}
;
_.clear_0 = function clear_8(){
  $clear_1(this);
}
;
_.contains = function contains_1(o){
  return $advanceToFind(this, o, false);
}
;
_.containsAll = function containsAll_1(c){
  return $containsAll(this, c);
}
;
_.isEmpty = function isEmpty_3(){
  return this.size_1() == 0;
}
;
_.remove_1 = function remove_11(o){
  return $advanceToFind(this, o, true);
}
;
_.toArray = function toArray_5(){
  return $toArray(this);
}
;
_.toArray_0 = function toArray_6(a){
  return $toArray_0(this, a);
}
;
_.toString_0 = function toString_12(){
  return $toString_1(this);
}
;
var Ljava_util_AbstractCollection_2_classLit = createForClass('java.util', 'AbstractCollection', 28);
function $equals_0(this$static, o){
  var other;
  if (o === this$static) {
    return true;
  }
  if (!instanceOf(o, 19)) {
    return false;
  }
  other = castTo(o, 19);
  if (other.size_1() != this$static.size_1()) {
    return false;
  }
  return this$static.containsAll(other);
}

function $removeAll_0(this$static, c){
  var iter, o, o$iterator, size_0;
  checkCriticalNotNull(c);
  size_0 = this$static.map_0.size_1();
  if (size_0 < c.size_1()) {
    for (iter = this$static.map_0.keySet_0().iterator_0(); iter.hasNext_0();) {
      o = iter.next_1();
      c.contains(o) && iter.remove_0();
    }
  }
   else {
    for (o$iterator = c.iterator_0(); o$iterator.hasNext_0();) {
      o = o$iterator.next_1();
      this$static.map_0.remove(o) != null;
    }
  }
  return size_0 != this$static.map_0.size_1();
}

defineClass($intern_13, 28, $intern_14);
_.spliterator_0 = function spliterator_3(){
  return new Spliterators$IteratorSpliterator(this, 1);
}
;
_.equals_0 = function equals_11(o){
  return $equals_0(this, o);
}
;
_.hashCode_1 = function hashCode_11(){
  return hashCode_44(this);
}
;
var Ljava_util_AbstractSet_2_classLit = createForClass('java.util', 'AbstractSet', $intern_13);
defineClass(1744, $intern_13, $intern_14);
var Lcom_google_common_collect_Sets$ImprovedAbstractSet_2_classLit = createForClass('com.google.common.collect', 'Sets/ImprovedAbstractSet', 1744);
function $contains_0(this$static, o){
  var entry, key, value_0;
  if (instanceOf(o, 39)) {
    entry = castTo(o, 39);
    key = entry.getKey();
    value_0 = safeGet(this$static.map_1(), key);
    return equal(value_0, entry.getValue()) && (value_0 != null || this$static.map_1().containsKey(key));
  }
  return false;
}

defineClass(1763, 1744, $intern_14);
_.clear_0 = function clear_9(){
  this.map_1().clear_0();
}
;
_.contains = function contains_2(o){
  return $contains_0(this, o);
}
;
_.isEmpty = function isEmpty_4(){
  return this.map_1().isEmpty();
}
;
_.remove_1 = function remove_12(o){
  var entry;
  if (this.contains(o)) {
    entry = castTo(o, 39);
    return this.map_1().keySet_0().remove_1(entry.getKey());
  }
  return false;
}
;
_.size_1 = function size_6(){
  return this.map_1().size_1();
}
;
var Lcom_google_common_collect_Maps$EntrySet_2_classLit = createForClass('com.google.common.collect', 'Maps/EntrySet', 1763);
function AbstractMapBasedMultimap$AsMap$AsMapEntries(this$1){
  this.this$11 = this$1;
}

defineClass(1009, 1763, $intern_14, AbstractMapBasedMultimap$AsMap$AsMapEntries);
_.contains = function contains_3(o){
  return safeContains(this.this$11.submap.entrySet_0(), o);
}
;
_.iterator_0 = function iterator_4(){
  return new AbstractMapBasedMultimap$AsMap$AsMapIterator(this.this$11);
}
;
_.map_1 = function map_1(){
  return this.this$11;
}
;
_.remove_1 = function remove_13(o){
  var entry;
  if (!safeContains(this.this$11.submap.entrySet_0(), o)) {
    return false;
  }
  entry = castTo(o, 39);
  $removeValuesForKey(this.this$11.this$01_1, entry.getKey());
  return true;
}
;
_.spliterator_0 = function spliterator_4(){
  return map_2(this.this$11.submap.entrySet_0().spliterator_0(), new AbstractMapBasedMultimap$AsMap$AsMapEntries$0methodref$wrapEntry$Type(this.this$11));
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$AsMap$AsMapEntries_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/AsMap/AsMapEntries', 1009);
function AbstractMapBasedMultimap$AsMap$AsMapEntries$0methodref$wrapEntry$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1010, 1, $intern_11, AbstractMapBasedMultimap$AsMap$AsMapEntries$0methodref$wrapEntry$Type);
_.apply_0 = function apply_4(arg0){
  return $wrapEntry(this.$$outer_0, castTo(arg0, 39));
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$AsMap$AsMapEntries$0methodref$wrapEntry$Type_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/AsMap/AsMapEntries/0methodref$wrapEntry$Type', 1010);
function AbstractMapBasedMultimap$AsMap$AsMapIterator(this$1){
  this.this$11 = this$1;
  this.delegateIterator = this.this$11.submap.entrySet_0().iterator_0();
}

defineClass(678, 1, $intern_4, AbstractMapBasedMultimap$AsMap$AsMapIterator);
_.forEachRemaining = function forEachRemaining_2(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_4(){
  var entry;
  return entry = castTo(this.delegateIterator.next_1(), 39) , this.collection = castTo(entry.getValue(), 13) , $wrapEntry(this.this$11, entry);
}
;
_.hasNext_0 = function hasNext_3(){
  return this.delegateIterator.hasNext_0();
}
;
_.remove_0 = function remove_14(){
  this.delegateIterator.remove_0();
  this.this$11.this$01_1.totalSize -= this.collection.size_1();
  this.collection.clear_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$AsMap$AsMapIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/AsMap/AsMapIterator', 678);
function Maps$KeySet(map_0){
  this.map_0 = castTo(checkNotNull(map_0), 111);
}

defineClass(567, 1744, $intern_14, Maps$KeySet);
_.clear_0 = function clear_10(){
  this.map_0.clear_0();
}
;
_.contains = function contains_4(o){
  return this.map_0.containsKey(o);
}
;
_.forEach_0 = function forEach_3(action){
  checkNotNull(action);
  this.map_0.forEach(new Maps$KeySet$lambda$0$Type(action));
}
;
_.isEmpty = function isEmpty_5(){
  return this.map_0.isEmpty();
}
;
_.iterator_0 = function iterator_5(){
  return $clinit_Maps() , transform_3(this.map_0.entrySet_0().iterator_0(), ($clinit_Maps$EntryFunction() , KEY));
}
;
_.remove_1 = function remove_15(o){
  if (this.map_0.containsKey(o)) {
    this.map_0.remove(o);
    return true;
  }
  return false;
}
;
_.size_1 = function size_7(){
  return this.map_0.size_1();
}
;
var Lcom_google_common_collect_Maps$KeySet_2_classLit = createForClass('com.google.common.collect', 'Maps/KeySet', 567);
function AbstractMapBasedMultimap$KeySet(this$0, subMap){
  this.this$01 = this$0;
  Maps$KeySet.call(this, subMap);
}

defineClass(368, 567, $intern_14, AbstractMapBasedMultimap$KeySet);
_.clear_0 = function clear_11(){
  var entryIterator;
  clear_17((entryIterator = this.map_0.entrySet_0().iterator_0() , new AbstractMapBasedMultimap$KeySet$1(this, entryIterator)));
}
;
_.containsAll = function containsAll_2(c){
  return this.map_0.keySet_0().containsAll(c);
}
;
_.equals_0 = function equals_12(object){
  return this === object || equals_Ljava_lang_Object__Z__devirtual$(this.map_0.keySet_0(), object);
}
;
_.hashCode_1 = function hashCode_12(){
  return hashCode__I__devirtual$(this.map_0.keySet_0());
}
;
_.iterator_0 = function iterator_6(){
  var entryIterator;
  return entryIterator = this.map_0.entrySet_0().iterator_0() , new AbstractMapBasedMultimap$KeySet$1(this, entryIterator);
}
;
_.remove_1 = function remove_16(key){
  var collection, count;
  count = 0;
  collection = castTo(this.map_0.remove(key), 13);
  if (collection) {
    count = collection.size_1();
    collection.clear_0();
    this.this$01.totalSize -= count;
  }
  return count > 0;
}
;
_.spliterator_0 = function spliterator_5(){
  return this.map_0.keySet_0().spliterator_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$KeySet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/KeySet', 368);
function AbstractMapBasedMultimap$KeySet$1(this$1, val$entryIterator){
  this.this$11 = this$1;
  this.val$entryIterator2 = val$entryIterator;
}

defineClass(679, 1, $intern_4, AbstractMapBasedMultimap$KeySet$1);
_.forEachRemaining = function forEachRemaining_3(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_4(){
  return this.val$entryIterator2.hasNext_0();
}
;
_.next_1 = function next_5(){
  this.entry = castTo(this.val$entryIterator2.next_1(), 39);
  return this.entry.getKey();
}
;
_.remove_0 = function remove_17(){
  var collection;
  checkState_0(!!this.entry, 'no calls to next() since the last call to remove()');
  collection = castTo(this.entry.getValue(), 13);
  this.val$entryIterator2.remove_0();
  this.this$11.this$01.totalSize -= collection.size_1();
  collection.clear_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$KeySet$1_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/KeySet/1', 679);
function AbstractMapBasedMultimap$SortedAsMap(this$0, submap){
  this.this$01_0 = this$0;
  AbstractMapBasedMultimap$AsMap.call(this, this$0, submap);
}

defineClass(370, 369, {111:1, 118:1}, AbstractMapBasedMultimap$SortedAsMap);
_.createKeySet = function createKeySet_2(){
  return this.createKeySet_0();
}
;
_.keySet_0 = function keySet_5(){
  return this.keySet_1();
}
;
_.createKeySet_0 = function createKeySet_3(){
  return new AbstractMapBasedMultimap$SortedKeySet(this.this$01_0, this.sortedMap());
}
;
_.keySet_1 = function keySet_6(){
  var result;
  return result = this.sortedKeySet , !result?(this.sortedKeySet = this.createKeySet_0()):result;
}
;
_.sortedMap = function sortedMap(){
  return castTo(this.submap, 118);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$SortedAsMap_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/SortedAsMap', 370);
function AbstractMapBasedMultimap$NavigableAsMap(this$0, submap){
  this.this$01 = this$0;
  AbstractMapBasedMultimap$SortedAsMap.call(this, this$0, submap);
}

defineClass(414, 370, $intern_15, AbstractMapBasedMultimap$NavigableAsMap);
_.createKeySet_0 = function createKeySet_4(){
  return new AbstractMapBasedMultimap$NavigableKeySet(this.this$01, castTo(castTo(this.submap, 118), 124));
}
;
_.keySet_0 = function keySet_7(){
  var result;
  return result = this.sortedKeySet , castTo(!result?(this.sortedKeySet = new AbstractMapBasedMultimap$NavigableKeySet(this.this$01, castTo(castTo(this.submap, 118), 124))):result, 200);
}
;
_.keySet_1 = function keySet_8(){
  var result;
  return result = this.sortedKeySet , castTo(!result?(this.sortedKeySet = new AbstractMapBasedMultimap$NavigableKeySet(this.this$01, castTo(castTo(this.submap, 118), 124))):result, 200);
}
;
_.sortedMap = function sortedMap_0(){
  return castTo(castTo(this.submap, 118), 124);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$NavigableAsMap_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/NavigableAsMap', 414);
function AbstractMapBasedMultimap$SortedKeySet(this$0, subMap){
  AbstractMapBasedMultimap$KeySet.call(this, this$0, subMap);
}

defineClass(338, 368, $intern_16, AbstractMapBasedMultimap$SortedKeySet);
_.spliterator_0 = function spliterator_6(){
  return this.map_0.keySet_0().spliterator_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$SortedKeySet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/SortedKeySet', 338);
function AbstractMapBasedMultimap$NavigableKeySet(this$0, subMap){
  AbstractMapBasedMultimap$SortedKeySet.call(this, this$0, subMap);
}

defineClass(306, 338, $intern_17, AbstractMapBasedMultimap$NavigableKeySet);
var Lcom_google_common_collect_AbstractMapBasedMultimap$NavigableKeySet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/NavigableKeySet', 306);
function $addToMap(this$static){
  this$static.ancestor?$addToMap(this$static.ancestor):this$static.this$01_0.map_0.put(this$static.key, this$static.delegate);
}

function $refreshIfEmpty(this$static){
  var newDelegate;
  if (this$static.ancestor) {
    $refreshIfEmpty(this$static.ancestor);
    if (this$static.ancestor.delegate != this$static.ancestorDelegate) {
      throw toJs(new ConcurrentModificationException);
    }
  }
   else if (this$static.delegate.isEmpty()) {
    newDelegate = castTo(this$static.this$01_0.map_0.get_0(this$static.key), 13);
    !!newDelegate && (this$static.delegate = newDelegate);
  }
}

function $removeIfEmpty(this$static){
  this$static.ancestor?$removeIfEmpty(this$static.ancestor):this$static.delegate.isEmpty() && this$static.this$01_0.map_0.remove(this$static.key);
}

function $size(this$static){
  $refreshIfEmpty(this$static);
  return this$static.delegate.size_1();
}

function AbstractMapBasedMultimap$WrappedCollection(this$0, key, delegate, ancestor){
  this.this$01_0 = this$0;
  this.key = key;
  this.delegate = delegate;
  this.ancestor = ancestor;
  this.ancestorDelegate = !ancestor?null:ancestor.delegate;
}

defineClass(463, 28, $intern_12, AbstractMapBasedMultimap$WrappedCollection);
_.add_1 = function add_4(value_0){
  var changed, wasEmpty;
  $refreshIfEmpty(this);
  wasEmpty = this.delegate.isEmpty();
  changed = this.delegate.add_1(value_0);
  if (changed) {
    ++this.this$01_0.totalSize;
    wasEmpty && $addToMap(this);
  }
  return changed;
}
;
_.addAll = function addAll_1(collection){
  var changed, newSize, oldSize;
  if (collection.isEmpty()) {
    return false;
  }
  oldSize = ($refreshIfEmpty(this) , this.delegate.size_1());
  changed = this.delegate.addAll(collection);
  if (changed) {
    newSize = this.delegate.size_1();
    this.this$01_0.totalSize += newSize - oldSize;
    oldSize == 0 && $addToMap(this);
  }
  return changed;
}
;
_.clear_0 = function clear_12(){
  var oldSize;
  oldSize = ($refreshIfEmpty(this) , this.delegate.size_1());
  if (oldSize == 0) {
    return;
  }
  this.delegate.clear_0();
  this.this$01_0.totalSize -= oldSize;
  $removeIfEmpty(this);
}
;
_.contains = function contains_5(o){
  $refreshIfEmpty(this);
  return this.delegate.contains(o);
}
;
_.containsAll = function containsAll_3(c){
  $refreshIfEmpty(this);
  return this.delegate.containsAll(c);
}
;
_.equals_0 = function equals_13(object){
  if (object === this) {
    return true;
  }
  $refreshIfEmpty(this);
  return equals_Ljava_lang_Object__Z__devirtual$(this.delegate, object);
}
;
_.hashCode_1 = function hashCode_13(){
  $refreshIfEmpty(this);
  return hashCode__I__devirtual$(this.delegate);
}
;
_.iterator_0 = function iterator_7(){
  $refreshIfEmpty(this);
  return new AbstractMapBasedMultimap$WrappedCollection$WrappedIterator(this);
}
;
_.remove_1 = function remove_18(o){
  var changed;
  $refreshIfEmpty(this);
  changed = this.delegate.remove_1(o);
  if (changed) {
    --this.this$01_0.totalSize;
    $removeIfEmpty(this);
  }
  return changed;
}
;
_.size_1 = function size_8(){
  return $size(this);
}
;
_.spliterator_0 = function spliterator_7(){
  return $refreshIfEmpty(this) , this.delegate.spliterator_0();
}
;
_.toString_0 = function toString_13(){
  $refreshIfEmpty(this);
  return toString_41(this.delegate);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedCollection_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedCollection', 463);
function $sort_0(this$static, c){
  var a, i;
  a = this$static.toArray();
  mergeSort(a, 0, a.length, c);
  for (i = 0; i < a.length; i++) {
    this$static.set_2(i, a[i]);
  }
}

var Ljava_util_List_2_classLit = createForInterface('java.util', 'List');
function AbstractMapBasedMultimap$WrappedList(this$0, key, delegate, ancestor){
  this.this$01 = this$0;
  AbstractMapBasedMultimap$WrappedCollection.call(this, this$0, key, delegate, ancestor);
}

defineClass(676, 463, {20:1, 28:1, 13:1, 15:1}, AbstractMapBasedMultimap$WrappedList);
_.sort_0 = function sort_0(c){
  $sort_0(this, c);
}
;
_.spliterator_0 = function spliterator_8(){
  return $refreshIfEmpty(this) , this.delegate.spliterator_0();
}
;
_.add_3 = function add_5(index_0, element){
  var wasEmpty;
  $refreshIfEmpty(this);
  wasEmpty = this.delegate.isEmpty();
  castTo(this.delegate, 15).add_3(index_0, element);
  ++this.this$01.totalSize;
  wasEmpty && $addToMap(this);
}
;
_.get_3 = function get_6(index_0){
  $refreshIfEmpty(this);
  return castTo(this.delegate, 15).get_3(index_0);
}
;
_.indexOf_0 = function indexOf(o){
  $refreshIfEmpty(this);
  return castTo(this.delegate, 15).indexOf_0(o);
}
;
_.listIterator_0 = function listIterator(){
  $refreshIfEmpty(this);
  return new AbstractMapBasedMultimap$WrappedList$WrappedListIterator(this);
}
;
_.listIterator_1 = function listIterator_0(index_0){
  $refreshIfEmpty(this);
  return new AbstractMapBasedMultimap$WrappedList$WrappedListIterator_0(this, index_0);
}
;
_.remove_2 = function remove_19(index_0){
  var value_0;
  $refreshIfEmpty(this);
  value_0 = castTo(this.delegate, 15).remove_2(index_0);
  --this.this$01.totalSize;
  $removeIfEmpty(this);
  return value_0;
}
;
_.set_2 = function set_2(index_0, element){
  $refreshIfEmpty(this);
  return castTo(this.delegate, 15).set_2(index_0, element);
}
;
_.subList = function subList_0(fromIndex, toIndex){
  $refreshIfEmpty(this);
  return $wrapList(this.this$01, this.key, castTo(this.delegate, 15).subList(fromIndex, toIndex), !this.ancestor?this:this.ancestor);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedList_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedList', 676);
function AbstractMapBasedMultimap$RandomAccessWrappedList(this$0, key, delegate, ancestor){
  AbstractMapBasedMultimap$WrappedList.call(this, this$0, key, delegate, ancestor);
}

defineClass(1008, 676, {20:1, 28:1, 13:1, 15:1, 50:1}, AbstractMapBasedMultimap$RandomAccessWrappedList);
var Lcom_google_common_collect_AbstractMapBasedMultimap$RandomAccessWrappedList_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/RandomAccessWrappedList', 1008);
function $$init(this$static){
  this$static.originalDelegate = this$static.this$11_0.delegate;
}

function $remove_3(this$static){
  this$static.delegateIterator.remove_0();
  --this$static.this$11_0.this$01_0.totalSize;
  $removeIfEmpty(this$static.this$11_0);
}

function $validateIterator(this$static){
  $refreshIfEmpty(this$static.this$11_0);
  if (this$static.this$11_0.delegate != this$static.originalDelegate) {
    throw toJs(new ConcurrentModificationException);
  }
}

function AbstractMapBasedMultimap$WrappedCollection$WrappedIterator(this$1){
  this.this$11_0 = this$1;
  $$init(this);
  this.delegateIterator = iteratorOrListIterator(this$1.delegate);
}

function AbstractMapBasedMultimap$WrappedCollection$WrappedIterator_0(this$1, delegateIterator){
  this.this$11_0 = this$1;
  $$init(this);
  this.delegateIterator = delegateIterator;
}

defineClass(586, 1, $intern_4, AbstractMapBasedMultimap$WrappedCollection$WrappedIterator);
_.forEachRemaining = function forEachRemaining_4(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_5(){
  $validateIterator(this);
  return this.delegateIterator.hasNext_0();
}
;
_.next_1 = function next_6(){
  $validateIterator(this);
  return this.delegateIterator.next_1();
}
;
_.remove_0 = function remove_20(){
  $remove_3(this);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedCollection$WrappedIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedCollection/WrappedIterator', 586);
function AbstractMapBasedMultimap$WrappedList$WrappedListIterator(this$1){
  this.this$11 = this$1;
  AbstractMapBasedMultimap$WrappedCollection$WrappedIterator.call(this, this$1);
}

function AbstractMapBasedMultimap$WrappedList$WrappedListIterator_0(this$1, index_0){
  this.this$11 = this$1;
  AbstractMapBasedMultimap$WrappedCollection$WrappedIterator_0.call(this, this$1, castTo(this$1.delegate, 15).listIterator_1(index_0));
}

defineClass(677, 586, $intern_18, AbstractMapBasedMultimap$WrappedList$WrappedListIterator, AbstractMapBasedMultimap$WrappedList$WrappedListIterator_0);
_.remove_0 = function remove_21(){
  $remove_3(this);
}
;
_.add_2 = function add_6(value_0){
  var wasEmpty;
  wasEmpty = $size(this.this$11) == 0;
  ($validateIterator(this) , castTo(this.delegateIterator, 122)).add_2(value_0);
  ++this.this$11.this$01.totalSize;
  wasEmpty && $addToMap(this.this$11);
}
;
_.hasPrevious = function hasPrevious_0(){
  return ($validateIterator(this) , castTo(this.delegateIterator, 122)).hasPrevious();
}
;
_.nextIndex_0 = function nextIndex_1(){
  return ($validateIterator(this) , castTo(this.delegateIterator, 122)).nextIndex_0();
}
;
_.previous_0 = function previous_1(){
  return ($validateIterator(this) , castTo(this.delegateIterator, 122)).previous_0();
}
;
_.previousIndex = function previousIndex_0(){
  return ($validateIterator(this) , castTo(this.delegateIterator, 122)).previousIndex();
}
;
_.set_1 = function set_3(value_0){
  ($validateIterator(this) , castTo(this.delegateIterator, 122)).set_1(value_0);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedList$WrappedListIterator_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedList/WrappedListIterator', 677);
function AbstractMapBasedMultimap$WrappedSortedSet(this$0, key, delegate){
  AbstractMapBasedMultimap$WrappedCollection.call(this, this$0, key, delegate, null);
}

defineClass(587, 463, $intern_16, AbstractMapBasedMultimap$WrappedSortedSet);
_.spliterator_0 = function spliterator_9(){
  return $refreshIfEmpty(this) , this.delegate.spliterator_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedSortedSet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedSortedSet', 587);
function AbstractMapBasedMultimap$WrappedNavigableSet(this$0, key, delegate){
  AbstractMapBasedMultimap$WrappedSortedSet.call(this, this$0, key, delegate);
}

defineClass(675, 587, $intern_17, AbstractMapBasedMultimap$WrappedNavigableSet);
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedNavigableSet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedNavigableSet', 675);
function AbstractMapBasedMultimap$WrappedSet(this$0, key, delegate){
  AbstractMapBasedMultimap$WrappedCollection.call(this, this$0, key, delegate, null);
}

defineClass(674, 463, $intern_14, AbstractMapBasedMultimap$WrappedSet);
_.spliterator_0 = function spliterator_10(){
  return $refreshIfEmpty(this) , this.delegate.spliterator_0();
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$WrappedSet_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/WrappedSet', 674);
function AbstractMapBasedMultimap$lambda$0$Type(){
}

defineClass(1015, 1, $intern_11, AbstractMapBasedMultimap$lambda$0$Type);
_.apply_0 = function apply_5(arg0){
  var key, valueCollection;
  return key = arg0.getKey() , valueCollection = castTo(arg0.getValue(), 13) , map_2(valueCollection.spliterator_0(), new AbstractMapBasedMultimap$lambda$2$Type(key));
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/lambda$0$Type', 1015);
function AbstractMapBasedMultimap$lambda$2$Type(key_0){
  this.key_0 = key_0;
}

defineClass(1014, 1, $intern_11, AbstractMapBasedMultimap$lambda$2$Type);
_.apply_0 = function apply_6(arg0){
  return lambda$2(this.key_0, arg0);
}
;
var Lcom_google_common_collect_AbstractMapBasedMultimap$lambda$2$Type_2_classLit = createForClass('com.google.common.collect', 'AbstractMapBasedMultimap/lambda$2$Type', 1014);
defineClass(410, 1, $intern_19);
_.equals_0 = function equals_14(object){
  var that;
  if (instanceOf(object, 39)) {
    that = castTo(object, 39);
    return equal(this.getKey(), that.getKey()) && equal(this.getValue(), that.getValue());
  }
  return false;
}
;
_.hashCode_1 = function hashCode_14(){
  var k, v;
  k = this.getKey();
  v = this.getValue();
  return (k == null?0:hashCode__I__devirtual$(k)) ^ (v == null?0:hashCode__I__devirtual$(v));
}
;
_.setValue = function setValue_1(value_0){
  throw toJs(new UnsupportedOperationException);
}
;
_.toString_0 = function toString_14(){
  return this.getKey() + '=' + this.getValue();
}
;
var Lcom_google_common_collect_AbstractMapEntry_2_classLit = createForClass('com.google.common.collect', 'AbstractMapEntry', 410);
defineClass(1764, 28, $intern_12);
_.clear_0 = function clear_13(){
  this.multimap_0().clear_0();
}
;
_.contains = function contains_6(o){
  var entry;
  if (instanceOf(o, 39)) {
    entry = castTo(o, 39);
    return $containsEntry(this.multimap_0(), entry.getKey(), entry.getValue());
  }
  return false;
}
;
_.remove_1 = function remove_22(o){
  var entry;
  if (instanceOf(o, 39)) {
    entry = castTo(o, 39);
    return $remove_1(this.multimap_0(), entry.getKey(), entry.getValue());
  }
  return false;
}
;
_.size_1 = function size_9(){
  return this.multimap_0().size_1();
}
;
var Lcom_google_common_collect_Multimaps$Entries_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Entries', 1764);
defineClass(1016, 1764, $intern_12);
_.iterator_0 = function iterator_8(){
  return this.this$01.entryIterator_0();
}
;
_.multimap_0 = function multimap_0(){
  return this.this$01;
}
;
_.spliterator_0 = function spliterator_11(){
  return this.this$01.entrySpliterator();
}
;
var Lcom_google_common_collect_AbstractMultimap$Entries_2_classLit = createForClass('com.google.common.collect', 'AbstractMultimap/Entries', 1016);
function AbstractMultimap$EntrySet(this$0){
  this.this$01 = this$0;
}

defineClass(681, 1016, $intern_14, AbstractMultimap$EntrySet);
_.spliterator_0 = function spliterator_12(){
  return this.this$01.entrySpliterator();
}
;
_.equals_0 = function equals_15(obj){
  return equalsImpl_2(this, obj);
}
;
_.hashCode_1 = function hashCode_15(){
  return hashCodeImpl_0(this);
}
;
var Lcom_google_common_collect_AbstractMultimap$EntrySet_2_classLit = createForClass('com.google.common.collect', 'AbstractMultimap/EntrySet', 681);
function AbstractMultimap$Values(this$0){
  this.this$01 = this$0;
}

defineClass(682, 28, $intern_12, AbstractMultimap$Values);
_.clear_0 = function clear_14(){
  this.this$01.clear_0();
}
;
_.contains = function contains_7(o){
  return $containsValue_0(this.this$01, o);
}
;
_.iterator_0 = function iterator_9(){
  return this.this$01.valueIterator_0();
}
;
_.size_1 = function size_10(){
  return this.this$01.totalSize;
}
;
_.spliterator_0 = function spliterator_13(){
  return this.this$01.valueSpliterator();
}
;
var Lcom_google_common_collect_AbstractMultimap$Values_2_classLit = createForClass('com.google.common.collect', 'AbstractMultimap/Values', 682);
function lambda$1_0(action_0, entry_1){
  var count, elem, i;
  elem = entry_1.val$backingEntry2.getKey();
  count = castTo(entry_1.val$backingEntry2.getValue(), 13).size_1();
  for (i = 0; i < count; i++) {
    action_0.accept(elem);
  }
}

function $add(){
  throw toJs(new UnsupportedOperationException);
}

function $entrySet_1(this$static){
  var result;
  result = this$static.entrySet;
  !result && (this$static.entrySet = result = new Multimaps$Keys$KeysEntrySet(this$static));
  return result;
}

defineClass(1765, 28, {768:1, 20:1, 28:1, 13:1});
_.forEach_0 = function forEach_4(action){
  checkNotNull(action);
  $entrySet_1(this).forEach_0(new Multiset$lambda$1$Type(action));
}
;
_.spliterator_0 = function spliterator_14(){
  var entrySpliterator;
  return entrySpliterator = $entrySet_1(this).spliterator_0() , flatMap(entrySpliterator, new Multisets$lambda$0$Type, 64 | entrySpliterator.characteristics_0() & 1296, sizeImpl(this));
}
;
_.add_1 = function add_7(element){
  $add();
  return true;
}
;
_.addAll = function addAll_2(elementsToAdd){
  return addAllImpl(this, elementsToAdd);
}
;
_.clear_0 = function clear_15(){
  clear_17(new Multimaps$Keys$1($entrySet_0($asMap(this.multimap)).iterator_0()));
}
;
_.contains = function contains_8(element){
  var values;
  return values = castTo(safeGet($asMap(this.multimap), element), 13) , (!values?0:values.size_1()) > 0;
}
;
_.equals_0 = function equals_16(object){
  return equalsImpl_1(this, object);
}
;
_.hashCode_1 = function hashCode_16(){
  return hashCode__I__devirtual$($entrySet_1(this));
}
;
_.isEmpty = function isEmpty_6(){
  return $entrySet_1(this).isEmpty();
}
;
_.iterator_0 = function iterator_10(){
  return new Multisets$MultisetIteratorImpl(this, $entrySet_1(this).iterator_0());
}
;
_.remove_1 = function remove_23(element){
  return $remove_6(this, element, 1) > 0;
}
;
_.size_1 = function size_11(){
  return sizeImpl(this);
}
;
_.toString_0 = function toString_15(){
  return toString_41($entrySet_1(this));
}
;
var Lcom_google_common_collect_AbstractMultiset_2_classLit = createForClass('com.google.common.collect', 'AbstractMultiset', 1765);
function AbstractSetMultimap(map_0){
  AbstractMapBasedMultimap.call(this, map_0);
}

defineClass(585, 673, $intern_20);
_.createCollection = function createCollection_1(){
  return this.createCollection_1();
}
;
_.createUnmodifiableEmptyCollection = function createUnmodifiableEmptyCollection_1(){
  return this.createUnmodifiableEmptyCollection_0();
}
;
_.get_1 = function get_7(key){
  return this.get_4(key);
}
;
_.removeAll = function removeAll_2(key){
  return this.removeAll_1(key);
}
;
_.asMap_0 = function asMap_1(){
  var result;
  return result = this.asMap , !result?(this.asMap = instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableAsMap(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedAsMap(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$AsMap(this, this.map_0)):result;
}
;
_.createUnmodifiableEmptyCollection_0 = function createUnmodifiableEmptyCollection_2(){
  return $clinit_ImmutableCollection() , $clinit_RegularImmutableSet() , EMPTY_0;
}
;
_.equals_0 = function equals_17(object){
  return equalsImpl_0(this, object);
}
;
_.get_4 = function get_8(key){
  return castTo($get_0(this, key), 19);
}
;
_.removeAll_1 = function removeAll_3(key){
  return castTo($removeAll(this, key), 19);
}
;
var Lcom_google_common_collect_AbstractSetMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractSetMultimap', 585);
function $values_0(this$static){
  var result;
  return result = this$static.values , !result?(this$static.values = new AbstractMultimap$Values(this$static)):result;
}

defineClass(1505, 585, $intern_20);
_.createCollection_1 = function createCollection_2(){
  return new TreeSet_0(this.valueComparator);
}
;
_.createUnmodifiableEmptyCollection_0 = function createUnmodifiableEmptyCollection_3(){
  var comparator;
  return comparator = this.valueComparator , !comparator?($clinit_Collections() , new Collections$UnmodifiableSortedSet(new TreeSet_0(this.valueComparator))):emptySet(this.valueComparator);
}
;
_.get_1 = function get_9(key){
  return castTo(castTo($get_0(this, key), 19), 62);
}
;
_.get_4 = function get_10(key){
  return castTo(castTo($get_0(this, key), 19), 62);
}
;
_.removeAll = function removeAll_4(key){
  return castTo(castTo($removeAll(this, key), 19), 62);
}
;
_.removeAll_1 = function removeAll_5(key){
  return castTo(castTo($removeAll(this, key), 19), 62);
}
;
_.asMap_0 = function asMap_2(){
  var result;
  return result = this.asMap , !result?(this.asMap = instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableAsMap(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedAsMap(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$AsMap(this, this.map_0)):result;
}
;
var Lcom_google_common_collect_AbstractSortedSetMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractSortedSetMultimap', 1505);
function AbstractSortedKeySortedSetMultimap(map_0){
  AbstractSetMultimap.call(this, map_0);
}

defineClass(1506, 1505, $intern_20);
_.asMap_0 = function asMap_3(){
  var result;
  return result = this.asMap , castTo(castTo(!result?(this.asMap = instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableAsMap(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedAsMap(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$AsMap(this, this.map_0)):result, 118), 124);
}
;
_.keySet_0 = function keySet_9(){
  var result;
  return result = this.keySet , castTo(castTo(!result?(this.keySet = instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableKeySet(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedKeySet(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$KeySet(this, this.map_0)):result, 62), 200);
}
;
var Lcom_google_common_collect_AbstractSortedKeySortedSetMultimap_2_classLit = createForClass('com.google.common.collect', 'AbstractSortedKeySortedSetMultimap', 1506);
function ArrayListMultimap(){
  AbstractListMultimap.call(this, new HashMap);
  this.expectedValuesPerKey = 3;
}

defineClass(540, 1478, $intern_10, ArrayListMultimap);
_.expectedValuesPerKey = 0;
var Lcom_google_common_collect_ArrayListMultimap_2_classLit = createForClass('com.google.common.collect', 'ArrayListMultimap', 540);
function checkNonnegative(value_0, name_0){
  if (value_0 < 0) {
    throw toJs(new IllegalArgumentException_0(name_0 + ' cannot be negative but was: ' + value_0));
  }
  return value_0;
}

function flatMap(fromSpliterator, function_0, topCharacteristics, topSize){
  checkArgument_0((topCharacteristics & $intern_21) == 0, 'flatMap does not support SUBSIZED characteristic');
  checkArgument_0((topCharacteristics & 4) == 0, 'flatMap does not support SORTED characteristic');
  checkNotNull(fromSpliterator);
  checkNotNull(function_0);
  return new CollectSpliterators$1FlatMapSpliterator(fromSpliterator, topCharacteristics, topSize, function_0);
}

function map_2(fromSpliterator, function_0){
  checkNotNull(fromSpliterator);
  checkNotNull(function_0);
  return new CollectSpliterators$1(fromSpliterator, function_0);
}

function $forEachRemaining_1(this$static, consumer){
  while (this$static.tryAdvance(consumer))
  ;
}

function CollectSpliterators$1(val$fromSpliterator, val$function){
  this.val$fromSpliterator1 = val$fromSpliterator;
  this.val$function2 = val$function;
}

defineClass(1195, 1, $intern_22, CollectSpliterators$1);
_.characteristics_0 = function characteristics_0(){
  return this.val$fromSpliterator1.characteristics_0() & -262;
}
;
_.estimateSize_0 = function estimateSize(){
  return this.val$fromSpliterator1.estimateSize_0();
}
;
_.forEachRemaining = function forEachRemaining_5(action){
  this.val$fromSpliterator1.forEachRemaining(new CollectSpliterators$1$lambda$1$Type(action, this.val$function2));
}
;
_.tryAdvance = function tryAdvance(action){
  return this.val$fromSpliterator1.tryAdvance(new CollectSpliterators$1$lambda$0$Type(action, this.val$function2));
}
;
var Lcom_google_common_collect_CollectSpliterators$1_2_classLit = createForClass('com.google.common.collect', 'CollectSpliterators/1', 1195);
function CollectSpliterators$1$lambda$0$Type(action_0, function_1){
  this.action_0 = action_0;
  this.function_1 = function_1;
}

defineClass(1196, 1, {}, CollectSpliterators$1$lambda$0$Type);
_.accept = function accept_0(arg0){
  this.action_0.accept(this.function_1.apply_0(arg0));
}
;
var Lcom_google_common_collect_CollectSpliterators$1$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'CollectSpliterators/1/lambda$0$Type', 1196);
function CollectSpliterators$1$lambda$1$Type(action_0, function_1){
  this.action_0 = action_0;
  this.function_1 = function_1;
}

defineClass(1197, 1, {}, CollectSpliterators$1$lambda$1$Type);
_.accept = function accept_1(arg0){
  this.action_0.accept(this.function_1.apply_0(arg0));
}
;
var Lcom_google_common_collect_CollectSpliterators$1$lambda$1$Type_2_classLit = createForClass('com.google.common.collect', 'CollectSpliterators/1/lambda$1$Type', 1197);
function $lambda$0(this$static, function_1, fromElement_1){
  return this$static.prefix = castTo(function_1.apply_0(fromElement_1), 201);
}

function CollectSpliterators$1FlatMapSpliterator(from, characteristics, estimatedSize, val$function){
  this.val$function6 = val$function;
  this.prefix = null;
  this.from = from;
  this.characteristics = characteristics;
  this.estimatedSize = estimatedSize;
}

function lambda$1(function_0, action_1, fromElement_2){
  castTo(function_0.apply_0(fromElement_2), 201).forEachRemaining(action_1);
}

defineClass(1198, 1, $intern_22, CollectSpliterators$1FlatMapSpliterator);
_.characteristics_0 = function characteristics_1(){
  return this.characteristics;
}
;
_.estimateSize_0 = function estimateSize_0(){
  !!this.prefix && (this.estimatedSize = max_2(this.estimatedSize, this.prefix.estimateSize_0()));
  return max_2(this.estimatedSize, 0);
}
;
_.forEachRemaining = function forEachRemaining_6(action){
  if (this.prefix) {
    this.prefix.forEachRemaining(action);
    this.prefix = null;
  }
  this.from.forEachRemaining(new CollectSpliterators$1FlatMapSpliterator$lambda$1$Type(this.val$function6, action));
  this.estimatedSize = 0;
}
;
_.tryAdvance = function tryAdvance_0(action){
  while (true) {
    if (!!this.prefix && this.prefix.tryAdvance(action)) {
      neq(this.estimatedSize, $intern_23) && (this.estimatedSize = sub_2(this.estimatedSize, 1));
      return true;
    }
     else {
      this.prefix = null;
    }
    if (!this.from.tryAdvance(new CollectSpliterators$1FlatMapSpliterator$lambda$0$Type(this, this.val$function6))) {
      return false;
    }
  }
}
;
_.characteristics = 0;
_.estimatedSize = 0;
var Lcom_google_common_collect_CollectSpliterators$1FlatMapSpliterator_2_classLit = createForClass('com.google.common.collect', 'CollectSpliterators/1FlatMapSpliterator', 1198);
function CollectSpliterators$1FlatMapSpliterator$lambda$0$Type($$outer_0, function_1){
  this.$$outer_0 = $$outer_0;
  this.function_1 = function_1;
}

defineClass(1199, 1, {}, CollectSpliterators$1FlatMapSpliterator$lambda$0$Type);
_.accept = function accept_2(arg0){
  $lambda$0(this.$$outer_0, this.function_1, arg0);
}
;
var Lcom_google_common_collect_CollectSpliterators$1FlatMapSpliterator$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'CollectSpliterators/1FlatMapSpliterator/lambda$0$Type', 1199);
function CollectSpliterators$1FlatMapSpliterator$lambda$1$Type(function_0, action_1){
  this.function_0 = function_0;
  this.action_1 = action_1;
}

defineClass(1200, 1, {}, CollectSpliterators$1FlatMapSpliterator$lambda$1$Type);
_.accept = function accept_3(arg0){
  lambda$1(this.function_0, this.action_1, arg0);
}
;
var Lcom_google_common_collect_CollectSpliterators$1FlatMapSpliterator$lambda$1$Type_2_classLit = createForClass('com.google.common.collect', 'CollectSpliterators/1FlatMapSpliterator/lambda$1$Type', 1200);
function $clinit_Collections2(){
  $clinit_Collections2 = emptyMethod;
  STANDARD_JOINER = $useForNull(new Joiner(', '));
}

function newStringBuilderForCollection(size_0){
  checkNonnegative(size_0, 'size');
  return toInt_0(lt(mul_0(size_0, 8), $intern_24)?mul_0(size_0, 8):$intern_24) , new StringBuilder_0;
}

function safeContains(collection, object){
  $clinit_Collections2();
  checkNotNull(collection);
  try {
    return collection.contains(object);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 182)) {
      return false;
    }
     else if (instanceOf($e0, 172)) {
      return false;
    }
     else 
      throw toJs($e0);
  }
}

var STANDARD_JOINER;
function Collections2$1(val$collection){
  this.val$collection1 = val$collection;
}

defineClass(877, 1, $intern_25, Collections2$1);
_.equals_0 = function equals_18(other){
  return this === other;
}
;
_.apply_0 = function apply_7(input_0){
  return maskUndefined(input_0) === maskUndefined(this.val$collection1)?'(this Collection)':input_0;
}
;
var Lcom_google_common_collect_Collections2$1_2_classLit = createForClass('com.google.common.collect', 'Collections2/1', 877);
function $equals_1(this$static, obj){
  var compareResult, that;
  if (instanceOf(obj, 227)) {
    that = castTo(obj, 227);
    try {
      compareResult = this$static.compareTo(that);
      return compareResult == 0;
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (!instanceOf($e0, 182))
        throw toJs($e0);
    }
  }
  return false;
}

function Cut(endpoint){
  this.endpoint = endpoint;
}

defineClass(227, 1, $intern_26);
_.compareTo_0 = function compareTo_0(that){
  return this.compareTo(castTo(that, 227));
}
;
_.compareTo = function compareTo(that){
  var result;
  if (that == ($clinit_Cut$BelowAll() , INSTANCE_1)) {
    return 1;
  }
  if (that == ($clinit_Cut$AboveAll() , INSTANCE_0)) {
    return -1;
  }
  result = ($clinit_Range() , compareTo_Ljava_lang_Object__I__devirtual$(this.endpoint, that.endpoint));
  if (result != 0) {
    return result;
  }
  return instanceOf(this, 488) == instanceOf(that, 488)?0:instanceOf(this, 488)?1:-1;
}
;
_.endpoint_0 = function endpoint_0(){
  return this.endpoint;
}
;
_.equals_0 = function equals_19(obj){
  return $equals_1(this, obj);
}
;
var Lcom_google_common_collect_Cut_2_classLit = createForClass('com.google.common.collect', 'Cut', 227);
function $clinit_Cut$AboveAll(){
  $clinit_Cut$AboveAll = emptyMethod;
  INSTANCE_0 = new Cut$AboveAll;
}

function Cut$AboveAll(){
  Cut.call(this, null);
}

defineClass(1575, 227, $intern_26, Cut$AboveAll);
_.compareTo = function compareTo_1(o){
  return o == this?0:1;
}
;
_.describeAsLowerBound = function describeAsLowerBound(sb){
  throw toJs(new AssertionError);
}
;
_.describeAsUpperBound = function describeAsUpperBound(sb){
  sb.string += '+\u221E)';
}
;
_.endpoint_0 = function endpoint_1(){
  throw toJs(new IllegalStateException_0('range unbounded on this side'));
}
;
_.isLessThan = function isLessThan(value_0){
  return false;
}
;
_.toString_0 = function toString_16(){
  return '+\u221E';
}
;
var INSTANCE_0;
var Lcom_google_common_collect_Cut$AboveAll_2_classLit = createForClass('com.google.common.collect', 'Cut/AboveAll', 1575);
function Cut$AboveValue(endpoint){
  Cut.call(this, castTo(checkNotNull(endpoint), 34));
}

defineClass(488, 227, {227:1, 488:1, 3:1, 34:1}, Cut$AboveValue);
_.describeAsLowerBound = function describeAsLowerBound_0(sb){
  $append_10((sb.string += '(' , sb), this.endpoint);
}
;
_.describeAsUpperBound = function describeAsUpperBound_0(sb){
  $append_5($append_10(sb, this.endpoint), 93);
}
;
_.hashCode_1 = function hashCode_17(){
  return ~hashCode__I__devirtual$(this.endpoint);
}
;
_.isLessThan = function isLessThan_0(value_0){
  return $clinit_Range() , compareTo_Ljava_lang_Object__I__devirtual$(this.endpoint, value_0) < 0;
}
;
_.toString_0 = function toString_17(){
  return '/' + this.endpoint + '\\';
}
;
var Lcom_google_common_collect_Cut$AboveValue_2_classLit = createForClass('com.google.common.collect', 'Cut/AboveValue', 488);
function $clinit_Cut$BelowAll(){
  $clinit_Cut$BelowAll = emptyMethod;
  INSTANCE_1 = new Cut$BelowAll;
}

function Cut$BelowAll(){
  Cut.call(this, null);
}

defineClass(1574, 227, $intern_26, Cut$BelowAll);
_.compareTo = function compareTo_2(o){
  return o == this?0:-1;
}
;
_.describeAsLowerBound = function describeAsLowerBound_1(sb){
  sb.string += '(-\u221E';
}
;
_.describeAsUpperBound = function describeAsUpperBound_1(sb){
  throw toJs(new AssertionError);
}
;
_.endpoint_0 = function endpoint_2(){
  throw toJs(new IllegalStateException_0('range unbounded on this side'));
}
;
_.isLessThan = function isLessThan_1(value_0){
  return true;
}
;
_.toString_0 = function toString_18(){
  return '-\u221E';
}
;
var INSTANCE_1;
var Lcom_google_common_collect_Cut$BelowAll_2_classLit = createForClass('com.google.common.collect', 'Cut/BelowAll', 1574);
function Cut$BelowValue(endpoint){
  Cut.call(this, castTo(checkNotNull(endpoint), 34));
}

defineClass(1576, 227, $intern_26, Cut$BelowValue);
_.describeAsLowerBound = function describeAsLowerBound_2(sb){
  $append_10((sb.string += '[' , sb), this.endpoint);
}
;
_.describeAsUpperBound = function describeAsUpperBound_2(sb){
  $append_5($append_10(sb, this.endpoint), 41);
}
;
_.hashCode_1 = function hashCode_18(){
  return hashCode__I__devirtual$(this.endpoint);
}
;
_.isLessThan = function isLessThan_2(value_0){
  return $clinit_Range() , compareTo_Ljava_lang_Object__I__devirtual$(this.endpoint, value_0) <= 0;
}
;
_.toString_0 = function toString_19(){
  return '\\' + this.endpoint + '/';
}
;
var Lcom_google_common_collect_Cut$BelowValue_2_classLit = createForClass('com.google.common.collect', 'Cut/BelowValue', 1576);
function FluentIterable(){
  $clinit_Absent();
}

function concat_0(inputs){
  checkNotNull(inputs);
  return new FluentIterable$2(inputs);
}

defineClass(502, 1, $intern_27);
_.forEach_0 = function forEach_5(action){
  $forEach(this, action);
}
;
_.toString_0 = function toString_20(){
  return toString_25(castTo(checkNotNull_0(this, 'use Optional.orNull() instead of Optional.or(null)'), 20).iterator_0());
}
;
var Lcom_google_common_collect_FluentIterable_2_classLit = createForClass('com.google.common.collect', 'FluentIterable', 502);
function $iterator(this$static){
  return $clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(this$static.val$inputs1, new Iterables$12)));
}

function FluentIterable$2(val$inputs){
  this.val$inputs1 = val$inputs;
  FluentIterable.call(this);
}

defineClass(336, 502, $intern_27, FluentIterable$2);
_.iterator_0 = function iterator_11(){
  return $iterator(this);
}
;
var Lcom_google_common_collect_FluentIterable$2_2_classLit = createForClass('com.google.common.collect', 'FluentIterable/2', 336);
function $clinit_ImmutableCollection(){
  $clinit_ImmutableCollection = emptyMethod;
  new ForwardingImmutableCollection(($clinit_Collections() , $clinit_Collections() , EMPTY_LIST));
}

function $removeAll_1(){
  throw toJs(new UnsupportedOperationException);
}

defineClass(1754, 28, $intern_28);
_.iterator_0 = function iterator_12(){
  return this.iterator_1();
}
;
_.add_1 = function add_8(e){
  throw toJs(new UnsupportedOperationException);
}
;
_.addAll = function addAll_3(newElements){
  throw toJs(new UnsupportedOperationException);
}
;
_.clear_0 = function clear_16(){
  throw toJs(new UnsupportedOperationException);
}
;
_.contains = function contains_9(object){
  return object != null && $advanceToFind(this, object, false);
}
;
_.remove_1 = function remove_24(object){
  throw toJs(new UnsupportedOperationException);
}
;
var Lcom_google_common_collect_ImmutableCollection_2_classLit = createForClass('com.google.common.collect', 'ImmutableCollection', 1754);
function ForwardingImmutableCollection(delegate){
  this.delegate = delegate;
}

defineClass(950, 1754, $intern_28, ForwardingImmutableCollection);
_.iterator_0 = function iterator_14(){
  return unmodifiableIterator(($clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4));
}
;
_.contains = function contains_10(object){
  return false;
}
;
_.containsAll = function containsAll_4(targets){
  return $containsAll(this.delegate, targets);
}
;
_.isEmpty = function isEmpty_7(){
  return true;
}
;
_.iterator_1 = function iterator_13(){
  return unmodifiableIterator(($clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4));
}
;
_.size_1 = function size_12(){
  return 0;
}
;
_.toArray = function toArray_7(){
  return $toArray(this.delegate);
}
;
_.toArray_0 = function toArray_8(other){
  return $toArray_0(this.delegate, other);
}
;
_.toString_0 = function toString_21(){
  return $toString_1(this.delegate);
}
;
var Lcom_google_common_collect_ForwardingImmutableCollection_2_classLit = createForClass('com.google.common.collect', 'ForwardingImmutableCollection', 950);
function $clinit_ImmutableList(){
  $clinit_ImmutableList = emptyMethod;
  $clinit_ImmutableCollection();
  EMPTY = new RegularImmutableList(($clinit_Collections() , $clinit_Collections() , EMPTY_LIST));
}

function $reverse(this$static){
  var list;
  list = (checkNotNull(this$static) , new ArrayList_1(($clinit_Collections2() , this$static)));
  reverse_2(list);
  return unsafeDelegateList(list);
}

function nullCheckedList(array){
  $clinit_ImmutableList();
  var i, len;
  for (i = 0 , len = array.length; i < len; i++) {
    if (array[i] == null) {
      throw toJs(new NullPointerException_0('at index ' + i));
    }
  }
  return new Arrays$ArrayList(array);
}

function unsafeDelegateList(list){
  switch (list.size_1()) {
    case 0:
      return EMPTY;
    case 1:
      return new SingletonImmutableList(list.iterator_0().next_1());
    default:return new RegularImmutableList(list);
  }
}

defineClass(166, 1754, $intern_29);
_.iterator_0 = function iterator_16(){
  return this.iterator_1();
}
;
_.listIterator_0 = function listIterator_1(){
  return new ImmutableList$1(this, this.size_1(), 0);
}
;
_.listIterator_1 = function listIterator_2(index_0){
  return new ImmutableList$1(this, this.size_1(), index_0);
}
;
_.sort_0 = function sort_1(c){
  $sort_0(this, c);
}
;
_.spliterator_0 = function spliterator_15(){
  return new Spliterators$IteratorSpliterator(this, 16);
}
;
_.subList = function subList_2(fromIndex, toIndex){
  return this.subList_0(fromIndex, toIndex);
}
;
_.add_3 = function add_9(index_0, element){
  throw toJs(new UnsupportedOperationException);
}
;
_.equals_0 = function equals_20(obj){
  return equalsImpl(this, obj);
}
;
_.hashCode_1 = function hashCode_19(){
  return hashCodeImpl(this);
}
;
_.indexOf_0 = function indexOf_0(object){
  return object == null?-1:indexOfRandomAccess(this, object);
}
;
_.iterator_1 = function iterator_15(){
  return new ImmutableList$1(this, this.size_1(), 0);
}
;
_.remove_2 = function remove_25(index_0){
  throw toJs(new UnsupportedOperationException);
}
;
_.set_2 = function set_4(index_0, element){
  throw toJs(new UnsupportedOperationException);
}
;
_.subList_0 = function subList_1(fromIndex, toIndex){
  var wrapper;
  return unsafeDelegateList((wrapper = new Lists$1(this) , new AbstractList$SubList(wrapper, fromIndex, toIndex)));
}
;
var EMPTY;
var Lcom_google_common_collect_ImmutableList_2_classLit = createForClass('com.google.common.collect', 'ImmutableList', 166);
defineClass(1759, 166, $intern_29);
_.iterator_0 = function iterator_18(){
  return unmodifiableIterator(this.delegateList().iterator_0());
}
;
_.subList = function subList_4(fromIndex, toIndex){
  return unsafeDelegateList(this.delegateList().subList(fromIndex, toIndex));
}
;
_.contains = function contains_11(object){
  return object != null && this.delegateList().contains(object);
}
;
_.containsAll = function containsAll_5(targets){
  return this.delegateList().containsAll(targets);
}
;
_.equals_0 = function equals_21(obj){
  return equals_Ljava_lang_Object__Z__devirtual$(this.delegateList(), obj);
}
;
_.get_3 = function get_11(index_0){
  return this.delegateList().get_3(index_0);
}
;
_.hashCode_1 = function hashCode_20(){
  return hashCode__I__devirtual$(this.delegateList());
}
;
_.indexOf_0 = function indexOf_1(object){
  return this.delegateList().indexOf_0(object);
}
;
_.isEmpty = function isEmpty_8(){
  return this.delegateList().isEmpty();
}
;
_.iterator_1 = function iterator_17(){
  return unmodifiableIterator(this.delegateList().iterator_0());
}
;
_.size_1 = function size_13(){
  return this.delegateList().size_1();
}
;
_.subList_0 = function subList_3(fromIndex, toIndex){
  return unsafeDelegateList(this.delegateList().subList(fromIndex, toIndex));
}
;
_.toArray = function toArray_9(){
  return this.delegateList().toArray_0(initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, this.delegateList().size_1(), 5, 1));
}
;
_.toArray_0 = function toArray_10(other){
  return this.delegateList().toArray_0(other);
}
;
_.toString_0 = function toString_22(){
  return toString_41(this.delegateList());
}
;
var Lcom_google_common_collect_ForwardingImmutableList_2_classLit = createForClass('com.google.common.collect', 'ForwardingImmutableList', 1759);
function copyOf(elements){
  var delegate, first;
  if (elements.i >= elements.this$01.array.length) {
    return $clinit_RegularImmutableSet() , EMPTY_0;
  }
  first = $next_10(elements);
  if (elements.i >= elements.this$01.array.length) {
    return new SingletonImmutableSet(first);
  }
  delegate = new LinkedHashSet;
  $add_6(delegate, checkNotNull(first));
  do {
    $add_6(delegate, checkNotNull($next_10(elements)));
  }
   while (elements.i < elements.this$01.array.length);
  return unsafeDelegate(delegate);
}

function create(elements){
  $clinit_ImmutableCollection();
  var element, element$iterator, set_0;
  set_0 = new LinkedHashSet;
  addAll_8(set_0, elements);
  for (element$iterator = set_0.map_0.keySet_0().iterator_0(); element$iterator.hasNext_0();) {
    element = element$iterator.next_1();
    checkNotNull(element);
  }
  switch (set_0.map_0.size_1()) {
    case 0:
      return $clinit_RegularImmutableSet() , EMPTY_0;
    case 1:
      return new SingletonImmutableSet(set_0.map_0.keySet_0().iterator_0().next_1());
    default:return new RegularImmutableSet(set_0);
  }
}

function of(e1, e2, e3, e4, e5, e6, others){
  $clinit_ImmutableCollection();
  var all, size_0;
  size_0 = others.length + 6;
  all = new ArrayList_0(size_0);
  addAll_8(all, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [e1, e2, e3, e4, e5, e6]));
  addAll_8(all, others);
  return copyOf(new ArrayList$1(all));
}

function unsafeDelegate(delegate){
  switch (delegate.map_0.size_1()) {
    case 0:
      return $clinit_RegularImmutableSet() , EMPTY_0;
    case 1:
      return new SingletonImmutableSet(delegate.map_0.keySet_0().iterator_0().next_1());
    default:return new RegularImmutableSet(delegate);
  }
}

defineClass(1755, 1754, $intern_30);
_.iterator_0 = function iterator_19(){
  return this.iterator_1();
}
;
_.spliterator_0 = function spliterator_16(){
  return new Spliterators$IteratorSpliterator(this, 1);
}
;
_.equals_0 = function equals_22(obj){
  return equalsImpl_2(this, obj);
}
;
_.hashCode_1 = function hashCode_21(){
  return hashCodeImpl_0(this);
}
;
var Lcom_google_common_collect_ImmutableSet_2_classLit = createForClass('com.google.common.collect', 'ImmutableSet', 1755);
function ForwardingImmutableSet(delegate){
  $clinit_ImmutableCollection();
  this.delegate = ($clinit_Collections() , new Collections$UnmodifiableSet(delegate));
}

defineClass(576, 1755, $intern_30);
_.iterator_0 = function iterator_21(){
  return this.iterator_1();
}
;
_.contains = function contains_12(object){
  return object != null && $contains_3(this.delegate, object);
}
;
_.containsAll = function containsAll_6(targets){
  return $containsAll_0(this.delegate, targets);
}
;
_.hashCode_1 = function hashCode_22(){
  return hashCode__I__devirtual$(this.delegate.coll);
}
;
_.isEmpty = function isEmpty_9(){
  return this.delegate.coll.isEmpty();
}
;
_.iterator_1 = function iterator_20(){
  return unmodifiableIterator(new Collections$UnmodifiableCollectionIterator(this.delegate.coll.iterator_0()));
}
;
_.size_1 = function size_14(){
  return this.delegate.coll.size_1();
}
;
_.toArray = function toArray_11(){
  return this.delegate.coll.toArray();
}
;
_.toArray_0 = function toArray_12(other){
  return $toArray_4(this.delegate, other);
}
;
_.toString_0 = function toString_23(){
  return toString_41(this.delegate.coll);
}
;
var Lcom_google_common_collect_ForwardingImmutableSet_2_classLit = createForClass('com.google.common.collect', 'ForwardingImmutableSet', 576);
defineClass(1748, 1747, $intern_31);
_.delegate_3 = function delegate_8(){
  return $clinit_Collections() , new Collections$UnmodifiableSortedSet(this.delegate);
}
;
_.spliterator_0 = function spliterator_17(){
  return new SortedSet$1(this);
}
;
var Lcom_google_common_collect_ForwardingSortedSet_2_classLit = createForClass('com.google.common.collect', 'ForwardingSortedSet', 1748);
function HashBiMap(){
  AbstractBiMap.call(this, new LinkedHashMap, new HashMap);
}

defineClass(501, 654, $intern_3, HashBiMap);
_.makeInverse = function makeInverse_0(backward){
  return new HashBiMap$1(this, backward, this);
}
;
_.put = function put_2(key, value_0){
  return $putInBothMaps(this, key, value_0, false);
}
;
var Lcom_google_common_collect_HashBiMap_2_classLit = createForClass('com.google.common.collect', 'HashBiMap', 501);
function HashBiMap$1(this$0, $anonymous0, $anonymous1){
  this.this$01 = this$0;
  AbstractBiMap$Inverse.call(this, $anonymous0, $anonymous1);
}

defineClass(930, 655, $intern_3, HashBiMap$1);
_.entrySetIterator = function entrySetIterator_0(){
  return new HashBiMap$1$1(this, this.this$01.delegate.entrySet_0().iterator_0());
}
;
var Lcom_google_common_collect_HashBiMap$1_2_classLit = createForClass('com.google.common.collect', 'HashBiMap/1', 930);
function $next_0(this$static){
  return this$static.transform_0(this$static.backingIterator.next_1());
}

function TransformedIterator(backingIterator){
  this.backingIterator = castTo(checkNotNull(backingIterator), 47);
}

defineClass(499, 1, $intern_4);
_.forEachRemaining = function forEachRemaining_7(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_6(){
  return this.backingIterator.hasNext_0();
}
;
_.next_1 = function next_7(){
  return $next_0(this);
}
;
_.remove_0 = function remove_26(){
  this.backingIterator.remove_0();
}
;
var Lcom_google_common_collect_TransformedIterator_2_classLit = createForClass('com.google.common.collect', 'TransformedIterator', 499);
function HashBiMap$1$1(this$1, $anonymous0){
  this.this$11 = this$1;
  TransformedIterator.call(this, $anonymous0);
}

defineClass(931, 499, $intern_4, HashBiMap$1$1);
_.transform_1 = function transform_1(forwardEntry){
  return new HashBiMap$1$1$1(this, castTo(forwardEntry, 39));
}
;
_.transform_0 = function(forwardEntry){
  return this.transform_1(forwardEntry);
}
;
var Lcom_google_common_collect_HashBiMap$1$1_2_classLit = createForClass('com.google.common.collect', 'HashBiMap/1/1', 931);
function HashBiMap$1$1$1(this$2, val$forwardEntry){
  this.this$21 = this$2;
  this.val$forwardEntry2 = val$forwardEntry;
  this.value_0 = this.val$forwardEntry2.getValue();
}

defineClass(932, 410, $intern_19, HashBiMap$1$1$1);
_.getKey = function getKey_0(){
  return this.value_0;
}
;
_.getValue = function getValue_0(){
  return this.this$21.this$11.delegate.get_0(this.value_0);
}
;
_.setValue = function setValue_2(newKey){
  var oldKey;
  checkState_0($contains($entrySet(this.this$21.this$11), this), 'entry no longer in map');
  oldKey = this.this$21.this$11.delegate.get_0(this.value_0);
  if (maskUndefined(newKey) === maskUndefined(oldKey) || newKey != null && equals_Ljava_lang_Object__Z__devirtual$(newKey, oldKey)) {
    return newKey;
  }
  $putInBothMaps(this.this$21.this$11, this.value_0, newKey, true);
  return oldKey;
}
;
var Lcom_google_common_collect_HashBiMap$1$1$1_2_classLit = createForClass('com.google.common.collect', 'HashBiMap/1/1/1', 932);
function HashMultimap(){
  AbstractSetMultimap.call(this, new HashMap);
}

defineClass(305, 585, $intern_20, HashMultimap);
_.createCollection_1 = function createCollection_3(){
  return new HashSet_0(capacity_0(this.expectedValuesPerKey));
}
;
_.expectedValuesPerKey = 2;
var Lcom_google_common_collect_HashMultimap_2_classLit = createForClass('com.google.common.collect', 'HashMultimap', 305);
function closedTableSize(expectedEntries){
  var tableSize;
  expectedEntries = expectedEntries > 2?expectedEntries:2;
  tableSize = highestOneBit(expectedEntries);
  if (expectedEntries > tableSize) {
    tableSize <<= 1;
    return tableSize > 0?tableSize:$intern_24;
  }
  return tableSize;
}

function needsResizing(size_0, tableSize){
  return size_0 > tableSize && tableSize < $intern_24;
}

function ImmutableEntry(key, value_0){
  this.key = key;
  this.value_0 = value_0;
}

defineClass(386, 410, {410:1, 386:1, 3:1, 39:1}, ImmutableEntry);
_.getKey = function getKey_1(){
  return this.key;
}
;
_.getValue = function getValue_1(){
  return this.value_0;
}
;
_.setValue = function setValue_3(value_0){
  throw toJs(new UnsupportedOperationException);
}
;
var Lcom_google_common_collect_ImmutableEntry_2_classLit = createForClass('com.google.common.collect', 'ImmutableEntry', 386);
function ImmutableEnumSet(delegate){
  ForwardingImmutableSet.call(this, delegate);
}

function asImmutable(delegate){
  $clinit_ImmutableCollection();
  switch (delegate.size_0) {
    case 0:
      return $clinit_RegularImmutableSet() , EMPTY_0;
    case 1:
      return new SingletonImmutableSet(getOnlyElement(new EnumSet$EnumSetImpl$IteratorImpl(delegate)));
    default:return new ImmutableEnumSet(delegate);
  }
}

defineClass(941, 576, $intern_30, ImmutableEnumSet);
var Lcom_google_common_collect_ImmutableEnumSet_2_classLit = createForClass('com.google.common.collect', 'ImmutableEnumSet', 941);
function $get_2(this$static, index_0){
  return this$static.this$01.get_3(index_0);
}

function ImmutableList$1(this$0, $anonymous0, $anonymous1){
  this.this$01 = this$0;
  checkPositionIndex($anonymous1, $anonymous0);
  this.size_0 = $anonymous0;
  this.position = $anonymous1;
}

defineClass(570, 880, $intern_9, ImmutableList$1);
var Lcom_google_common_collect_ImmutableList$1_2_classLit = createForClass('com.google.common.collect', 'ImmutableList/1', 570);
function $clinit_ImmutableSortedSet(){
  $clinit_ImmutableSortedSet = emptyMethod;
  $clinit_ImmutableCollection();
  NATURAL_ORDER = ($clinit_NaturalOrdering() , INSTANCE_2);
  NATURAL_EMPTY_SET = new RegularImmutableSortedSet(new TreeSet_0(NATURAL_ORDER));
}

function emptySet(comparator){
  $clinit_ImmutableSortedSet();
  checkNotNull(comparator);
  return NATURAL_ORDER == comparator?NATURAL_EMPTY_SET:new RegularImmutableSortedSet(new TreeSet_0(comparator));
}

defineClass(1706, 576, $intern_32);
_.iterator_0 = function iterator_23(){
  return unmodifiableIterator(new Collections$UnmodifiableCollectionIterator(this.delegate.coll.iterator_0()));
}
;
_.spliterator_0 = function spliterator_18(){
  return new SortedSet$1(this);
}
;
_.contains = function contains_13(object){
  try {
    return object != null && $contains_3(this.sortedDelegate, object);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 182)) {
      return false;
    }
     else 
      throw toJs($e0);
  }
}
;
_.containsAll = function containsAll_7(targets){
  var target, target$iterator;
  for (target$iterator = targets.iterator_0(); target$iterator.hasNext_0();) {
    target = target$iterator.next_1();
    if (target == null) {
      return false;
    }
  }
  try {
    return $containsAll_0(this.sortedDelegate, targets);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 182)) {
      return false;
    }
     else 
      throw toJs($e0);
  }
}
;
_.iterator_1 = function iterator_22(){
  return unmodifiableIterator(new Collections$UnmodifiableCollectionIterator(this.delegate.coll.iterator_0()));
}
;
_.toArray = function toArray_13(){
  return fillArray(this, initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, this.delegate.coll.size_1(), 5, 1));
}
;
_.toArray_0 = function toArray_14(other){
  return toArrayImpl(this, other);
}
;
var NATURAL_EMPTY_SET, NATURAL_ORDER;
var Lcom_google_common_collect_ImmutableSortedSet_2_classLit = createForClass('com.google.common.collect', 'ImmutableSortedSet', 1706);
function addAll_4(addTo, elementsToAdd){
  var c;
  if (instanceOf(elementsToAdd, 13)) {
    c = ($clinit_Collections2() , castTo(elementsToAdd, 13));
    return addTo.addAll(c);
  }
  return addAll_5(addTo, castTo(checkNotNull(elementsToAdd), 20).iterator_0());
}

function all_0(iterable, predicate){
  return all_1(iterable.iterator_0(), predicate);
}

function any_0(iterable, predicate){
  return $clinit_Iterators() , indexOf_2(iterable.iterator_0(), predicate) != -1;
}

function concat_1(a, b){
  return concat_0(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [a, b])))));
}

function concat_2(a, b, c){
  return concat_0(($clinit_ImmutableList() , new RegularImmutableList(nullCheckedList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [a, b, c])))));
}

function filter_0(unfiltered, retainIfTrue){
  checkNotNull(unfiltered);
  checkNotNull(retainIfTrue);
  return new Iterables$4(unfiltered, retainIfTrue);
}

function get_12(iterable){
  checkNotNull(iterable);
  return get_13(($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(iterable.val$inputs1, new Iterables$12)))));
}

function getLast(iterable){
  if (iterable) {
    if (iterable.isEmpty()) {
      throw toJs(new NoSuchElementException);
    }
    return iterable.get_3(iterable.size_1() - 1);
  }
  return getLast_0(null.iterator_0());
}

function isEmpty_10(iterable){
  if (instanceOf(iterable, 13)) {
    return castTo(iterable, 13).isEmpty();
  }
  return !iterable.iterator_0().hasNext_0();
}

function size_15(iterable){
  return instanceOf(iterable, 13)?castTo(iterable, 13).size_1():size_16(iterable.iterator_0());
}

function transform_2(fromIterable, function_0){
  checkNotNull(fromIterable);
  checkNotNull(function_0);
  return new Iterables$5(fromIterable, function_0);
}

function Iterables$1(val$iterable){
  this.val$iterable1 = val$iterable;
  FluentIterable.call(this);
}

defineClass(942, 502, $intern_27, Iterables$1);
_.iterator_0 = function iterator_24(){
  return cycle(this.val$iterable1);
}
;
_.toString_0 = function toString_24(){
  return $toString_1(this.val$iterable1) + ' (cycled)';
}
;
var Lcom_google_common_collect_Iterables$1_2_classLit = createForClass('com.google.common.collect', 'Iterables/1', 942);
function Iterables$12(){
}

defineClass(208, 1, $intern_25, Iterables$12);
_.apply_0 = function apply_8(iterable){
  return castTo(iterable, 20).iterator_0();
}
;
_.equals_0 = function equals_23(other){
  return this === other;
}
;
var Lcom_google_common_collect_Iterables$12_2_classLit = createForClass('com.google.common.collect', 'Iterables/12', 208);
function $iterator_0(this$static){
  return filter_1(this$static.val$unfiltered1.iterator_0(), this$static.val$retainIfTrue2);
}

function Iterables$4(val$unfiltered, val$retainIfTrue){
  this.val$unfiltered1 = val$unfiltered;
  this.val$retainIfTrue2 = val$retainIfTrue;
  FluentIterable.call(this);
}

function lambda$0(retainIfTrue_0, action_1, a_2){
  retainIfTrue_0.test_0(a_2) && action_1.accept(a_2);
}

defineClass(943, 502, $intern_27, Iterables$4);
_.forEach_0 = function forEach_6(action){
  checkNotNull(action);
  this.val$unfiltered1.forEach_0(new Iterables$4$lambda$0$Type(this.val$retainIfTrue2, action));
}
;
_.iterator_0 = function iterator_25(){
  return $iterator_0(this);
}
;
var Lcom_google_common_collect_Iterables$4_2_classLit = createForClass('com.google.common.collect', 'Iterables/4', 943);
function Iterables$4$lambda$0$Type(retainIfTrue_0, action_1){
  this.retainIfTrue_0 = retainIfTrue_0;
  this.action_1 = action_1;
}

defineClass(944, 1, {}, Iterables$4$lambda$0$Type);
_.accept = function accept_4(arg0){
  lambda$0(this.retainIfTrue_0, this.action_1, arg0);
}
;
var Lcom_google_common_collect_Iterables$4$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'Iterables/4/lambda$0$Type', 944);
function $iterator_1(this$static){
  return transform_3(this$static.val$fromIterable1.iterator_0(), this$static.val$function2);
}

function Iterables$5(val$fromIterable, val$function){
  this.val$fromIterable1 = val$fromIterable;
  this.val$function2 = val$function;
  FluentIterable.call(this);
}

defineClass(945, 502, $intern_27, Iterables$5);
_.forEach_0 = function forEach_7(action){
  checkNotNull(action);
  this.val$fromIterable1.forEach_0(new Iterables$5$lambda$0$Type(action, this.val$function2));
}
;
_.iterator_0 = function iterator_26(){
  return $iterator_1(this);
}
;
var Lcom_google_common_collect_Iterables$5_2_classLit = createForClass('com.google.common.collect', 'Iterables/5', 945);
function Iterables$5$lambda$0$Type(action_0, function_1){
  this.action_0 = action_0;
  this.function_1 = function_1;
}

defineClass(946, 1, {}, Iterables$5$lambda$0$Type);
_.accept = function accept_5(arg0){
  this.action_0.accept(this.function_1.apply_0(arg0));
}
;
var Lcom_google_common_collect_Iterables$5$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'Iterables/5/lambda$0$Type', 946);
function $clinit_Iterators(){
  $clinit_Iterators = emptyMethod;
  EMPTY_LIST_ITERATOR = new Iterators$1;
  EMPTY_MODIFIABLE_ITERATOR = new Iterators$2;
}

function addAll_5(addTo, iterator){
  $clinit_Iterators();
  var wasModified;
  checkNotNull(addTo);
  checkNotNull(iterator);
  wasModified = false;
  while (iterator.hasNext_0()) {
    wasModified = wasModified | addTo.add_1(iterator.next_1());
  }
  return wasModified;
}

function advance(iterator){
  var i;
  checkNotNull(iterator);
  checkArgument_0(true, 'numberToAdvance must be nonnegative');
  for (i = 0; i < 0 && $hasNext_0(iterator); i++) {
    $next_2(iterator);
  }
  return i;
}

function all_1(iterator, predicate){
  $clinit_Iterators();
  var element;
  checkNotNull(predicate);
  while (iterator.hasNext_0()) {
    element = iterator.next_1();
    if (!predicate.apply_1(element)) {
      return false;
    }
  }
  return true;
}

function clear_17(iterator){
  $clinit_Iterators();
  checkNotNull(iterator);
  while (iterator.hasNext_0()) {
    iterator.next_1();
    iterator.remove_0();
  }
}

function cycle(iterable){
  $clinit_Iterators();
  checkNotNull(iterable);
  return new Iterators$4(iterable);
}

function elementsEqual(iterator1, iterator2){
  $clinit_Iterators();
  var o1, o2;
  while (iterator1.hasNext_0()) {
    if (!iterator2.hasNext_0()) {
      return false;
    }
    o1 = iterator1.next_1();
    o2 = iterator2.next_1();
    if (!(maskUndefined(o1) === maskUndefined(o2) || o1 != null && equals_Ljava_lang_Object__Z__devirtual$(o1, o2))) {
      return false;
    }
  }
  return !iterator2.hasNext_0();
}

function filter_1(unfiltered, retainIfTrue){
  $clinit_Iterators();
  checkNotNull(unfiltered);
  checkNotNull(retainIfTrue);
  return new Iterators$6(unfiltered, retainIfTrue);
}

function get_13(iterator){
  $clinit_Iterators();
  var skipped;
  skipped = advance(iterator);
  if (!$hasNext_0(iterator)) {
    throw toJs(new IndexOutOfBoundsException_0('position (0) must be less than the number of elements that remained (' + skipped + ')'));
  }
  return $next_2(iterator);
}

function getLast_0(iterator){
  $clinit_Iterators();
  var current;
  while (true) {
    current = iterator.next_1();
    if (!iterator.hasNext_0()) {
      return current;
    }
  }
}

function getLast_1(iterator){
  $clinit_Iterators();
  return $hasNext_4(iterator.val$edgesIter2)?getLast_0(iterator):null;
}

function getNext(iterator){
  $clinit_Iterators();
  return iterator.hasNext_0()?iterator.next_1():null;
}

function getOnlyElement(iterator){
  $clinit_Iterators();
  var first, i, sb;
  first = $next_11(iterator);
  if (iterator.i >= iterator.this$11.all.length) {
    return first;
  }
  sb = $append_10($append_11(new StringBuilder, 'expected one element but was: <'), first);
  for (i = 0; i < 4 && iterator.i < iterator.this$11.all.length; i++) {
    $append_10((sb.string += ', ' , sb), $next_11(iterator));
  }
  iterator.i < iterator.this$11.all.length && (sb.string += ', ...' , sb);
  sb.string += '>';
  throw toJs(new IllegalArgumentException_0(sb.string));
}

function indexOf_2(iterator, predicate){
  $clinit_Iterators();
  var current, i;
  checkNotNull_0(predicate, 'predicate');
  for (i = 0; iterator.hasNext_0(); i++) {
    current = iterator.next_1();
    if (predicate.apply_1(current)) {
      return i;
    }
  }
  return -1;
}

function size_16(iterator){
  $clinit_Iterators();
  var count;
  count = 0;
  while (iterator.hasNext_0()) {
    iterator.next_1();
    count = add_20(count, 1);
  }
  return saturatedCast(count);
}

function toString_25(iterator){
  $clinit_Iterators();
  return $append_5($appendTo_0(($clinit_Collections2() , STANDARD_JOINER), $append_5(new StringBuilder, 91), iterator), 93).string;
}

function transform_3(fromIterator, function_0){
  $clinit_Iterators();
  checkNotNull(function_0);
  return new Iterators$7(fromIterator, function_0);
}

function unmodifiableIterator(iterator){
  $clinit_Iterators();
  var result;
  checkNotNull(iterator);
  if (instanceOf(iterator, 267)) {
    result = castTo(iterator, 267);
    return result;
  }
  return new Iterators$3(iterator);
}

var EMPTY_LIST_ITERATOR, EMPTY_MODIFIABLE_ITERATOR;
function Iterators$1(){
}

defineClass(983, 1749, $intern_9, Iterators$1);
_.hasNext_0 = function hasNext_7(){
  return false;
}
;
_.hasPrevious = function hasPrevious_1(){
  return false;
}
;
_.next_1 = function next_8(){
  throw toJs(new NoSuchElementException);
}
;
_.nextIndex_0 = function nextIndex_2(){
  return 0;
}
;
_.previous_0 = function previous_2(){
  throw toJs(new NoSuchElementException);
}
;
_.previousIndex = function previousIndex_1(){
  return -1;
}
;
var Lcom_google_common_collect_Iterators$1_2_classLit = createForClass('com.google.common.collect', 'Iterators/1', 983);
function Iterators$11(val$value){
  this.val$value1 = val$value;
}

defineClass(583, 267, $intern_8, Iterators$11);
_.hasNext_0 = function hasNext_8(){
  return !this.done_0;
}
;
_.next_1 = function next_9(){
  if (this.done_0) {
    throw toJs(new NoSuchElementException);
  }
  this.done_0 = true;
  return this.val$value1;
}
;
_.done_0 = false;
var Lcom_google_common_collect_Iterators$11_2_classLit = createForClass('com.google.common.collect', 'Iterators/11', 583);
function Iterators$2(){
}

defineClass(984, 1, $intern_4, Iterators$2);
_.forEachRemaining = function forEachRemaining_8(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_9(){
  return false;
}
;
_.next_1 = function next_10(){
  throw toJs(new NoSuchElementException);
}
;
_.remove_0 = function remove_27(){
  checkState_0(false, 'no calls to next() since the last call to remove()');
}
;
var Lcom_google_common_collect_Iterators$2_2_classLit = createForClass('com.google.common.collect', 'Iterators/2', 984);
function Iterators$3(val$iterator){
  this.val$iterator1 = val$iterator;
}

defineClass(985, 267, $intern_8, Iterators$3);
_.hasNext_0 = function hasNext_10(){
  return this.val$iterator1.hasNext_0();
}
;
_.next_1 = function next_11(){
  return this.val$iterator1.next_1();
}
;
var Lcom_google_common_collect_Iterators$3_2_classLit = createForClass('com.google.common.collect', 'Iterators/3', 985);
function $next_1(this$static){
  if (!this$static.iterator.hasNext_0()) {
    this$static.iterator = this$static.val$iterable1.iterator_0();
    if (!this$static.iterator.hasNext_0()) {
      throw toJs(new NoSuchElementException);
    }
  }
  return this$static.iterator.next_1();
}

function Iterators$4(val$iterable){
  this.val$iterable1 = val$iterable;
  this.iterator = ($clinit_Iterators() , $clinit_Iterators() , EMPTY_MODIFIABLE_ITERATOR);
}

defineClass(986, 1, $intern_4, Iterators$4);
_.forEachRemaining = function forEachRemaining_9(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_11(){
  return this.iterator.hasNext_0() || this.val$iterable1.iterator_0().hasNext_0();
}
;
_.next_1 = function next_12(){
  return $next_1(this);
}
;
_.remove_0 = function remove_28(){
  this.iterator.remove_0();
}
;
var Lcom_google_common_collect_Iterators$4_2_classLit = createForClass('com.google.common.collect', 'Iterators/4', 986);
function $computeNext(this$static){
  var element;
  while (this$static.val$unfiltered1.hasNext_0()) {
    element = this$static.val$unfiltered1.next_1();
    if (this$static.val$retainIfTrue2.apply_1(element)) {
      return element;
    }
  }
  return this$static.state = 2 , null;
}

function Iterators$6(val$unfiltered, val$retainIfTrue){
  this.val$unfiltered1 = val$unfiltered;
  this.val$retainIfTrue2 = val$retainIfTrue;
}

defineClass(988, 987, $intern_8, Iterators$6);
var Lcom_google_common_collect_Iterators$6_2_classLit = createForClass('com.google.common.collect', 'Iterators/6', 988);
function Iterators$7($anonymous0, val$function){
  this.val$function2 = val$function;
  TransformedIterator.call(this, $anonymous0);
}

defineClass(989, 499, $intern_4, Iterators$7);
_.transform_0 = function transform_4(from){
  return this.val$function2.apply_0(from);
}
;
var Lcom_google_common_collect_Iterators$7_2_classLit = createForClass('com.google.common.collect', 'Iterators/7', 989);
function $hasNext_0(this$static){
  checkNotNull(this$static.current);
  if (this$static.current.hasNext_0()) {
    return true;
  }
  while (this$static.backingIterator.hasNext_0()) {
    checkNotNull(this$static.current = this$static.transform_2(this$static.backingIterator.next_1()));
    if (this$static.current.hasNext_0()) {
      return true;
    }
  }
  return false;
}

function $next_2(this$static){
  if (!$hasNext_0(this$static)) {
    throw toJs(new NoSuchElementException);
  }
  this$static.removeFrom = this$static.current;
  return this$static.current.next_1();
}

function MultitransformedIterator(backingIterator){
  this.current = ($clinit_Iterators() , $clinit_Iterators() , $clinit_Iterators() , EMPTY_LIST_ITERATOR);
  this.backingIterator = castTo(checkNotNull(backingIterator), 47);
}

defineClass(666, 1, $intern_4);
_.forEachRemaining = function forEachRemaining_10(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_12(){
  return $hasNext_0(this);
}
;
_.next_1 = function next_13(){
  return $next_2(this);
}
;
_.remove_0 = function remove_29(){
  checkState_0(!!this.removeFrom, 'no calls to next() since the last call to remove()');
  this.removeFrom.remove_0();
  this.removeFrom = null;
}
;
var Lcom_google_common_collect_MultitransformedIterator_2_classLit = createForClass('com.google.common.collect', 'MultitransformedIterator', 666);
function Iterators$ConcatenatedIterator(iterators){
  MultitransformedIterator.call(this, new Iterators$ConcatenatedIterator$1(iterators));
}

defineClass(186, 666, {186:1, 47:1}, Iterators$ConcatenatedIterator);
_.transform_2 = function transform_5(iterator){
  return castTo(iterator, 47);
}
;
var Lcom_google_common_collect_Iterators$ConcatenatedIterator_2_classLit = createForClass('com.google.common.collect', 'Iterators/ConcatenatedIterator', 186);
function $transform(iterator){
  var concatIterator;
  if (instanceOf(iterator, 186)) {
    concatIterator = castTo(iterator, 186);
    return new Iterators$ConcatenatedIterator$1(concatIterator.backingIterator);
  }
   else {
    return $clinit_Iterators() , new Iterators$11(iterator);
  }
}

function Iterators$ConcatenatedIterator$1($anonymous0){
  MultitransformedIterator.call(this, $anonymous0);
}

defineClass(667, 666, $intern_4, Iterators$ConcatenatedIterator$1);
_.transform_2 = function transform_6(iterator){
  return $transform(castTo(iterator, 47));
}
;
var Lcom_google_common_collect_Iterators$ConcatenatedIterator$1_2_classLit = createForClass('com.google.common.collect', 'Iterators/ConcatenatedIterator/1', 667);
function LinkedHashMultimap(){
  AbstractSetMultimap.call(this, new LinkedHashMap_0(16));
  checkNonnegative(2, 'expectedValuesPerKey');
  this.valueSetCapacity = 2;
  this.multimapHeaderEntry = new LinkedHashMultimap$ValueEntry(null, null, 0, null);
  succeedsInMultimap(this.multimapHeaderEntry, this.multimapHeaderEntry);
}

function succeedsInMultimap(pred, succ){
  pred.successorInMultimap = succ;
  succ.predecessorInMultimap = pred;
}

function succeedsInValueSet(pred, succ){
  pred.setSuccessorInValueSet(succ);
  succ.setPredecessorInValueSet(pred);
}

defineClass(1622, 585, $intern_20, LinkedHashMultimap);
_.clear_0 = function clear_18(){
  $clear_0(this);
  succeedsInMultimap(this.multimapHeaderEntry, this.multimapHeaderEntry);
}
;
_.createCollection_1 = function createCollection_4(){
  return new LinkedHashSet_0(this.valueSetCapacity);
}
;
_.createCollection_0 = function createCollection_5(key){
  return new LinkedHashMultimap$ValueSet(this, key, this.valueSetCapacity);
}
;
_.entryIterator_0 = function entryIterator_1(){
  return new LinkedHashMultimap$1(this);
}
;
_.entrySpliterator = function entrySpliterator_2(){
  var result;
  return new Spliterators$IteratorSpliterator((result = this.entries_0 , castTo(!result?(this.entries_0 = new AbstractMultimap$EntrySet(this)):result, 19)), 17);
}
;
_.keySet_0 = function keySet_10(){
  var result;
  return result = this.keySet , !result?(this.keySet = instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableKeySet(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedKeySet(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$KeySet(this, this.map_0)):result;
}
;
_.valueIterator_0 = function valueIterator_0(){
  return $clinit_Maps() , transform_3(new LinkedHashMultimap$1(this), ($clinit_Maps$EntryFunction() , VALUE));
}
;
_.valueSpliterator = function valueSpliterator_0(){
  var result;
  return map_2(new Spliterators$IteratorSpliterator((result = this.entries_0 , castTo(!result?(this.entries_0 = new AbstractMultimap$EntrySet(this)):result, 19)), 17), new LinkedHashMultimap$0methodref$getValue$Type);
}
;
_.valueSetCapacity = 2;
var Lcom_google_common_collect_LinkedHashMultimap_2_classLit = createForClass('com.google.common.collect', 'LinkedHashMultimap', 1622);
function LinkedHashMultimap$0methodref$getValue$Type(){
}

defineClass(1625, 1, $intern_11, LinkedHashMultimap$0methodref$getValue$Type);
_.apply_0 = function apply_9(arg0){
  return castTo(arg0, 39).getValue();
}
;
var Lcom_google_common_collect_LinkedHashMultimap$0methodref$getValue$Type_2_classLit = createForClass('com.google.common.collect', 'LinkedHashMultimap/0methodref$getValue$Type', 1625);
function $next_3(this$static){
  var result;
  if (this$static.nextEntry == this$static.this$01.multimapHeaderEntry) {
    throw toJs(new NoSuchElementException);
  }
  result = this$static.nextEntry;
  this$static.toRemove = result;
  this$static.nextEntry = this$static.nextEntry.successorInMultimap;
  return result;
}

function LinkedHashMultimap$1(this$0){
  this.this$01 = this$0;
  this.nextEntry = this.this$01.multimapHeaderEntry.successorInMultimap;
}

defineClass(757, 1, $intern_4, LinkedHashMultimap$1);
_.forEachRemaining = function forEachRemaining_11(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_14(){
  return $next_3(this);
}
;
_.hasNext_0 = function hasNext_13(){
  return this.nextEntry != this.this$01.multimapHeaderEntry;
}
;
_.remove_0 = function remove_30(){
  checkState_0(!!this.toRemove, 'no calls to next() since the last call to remove()');
  $remove_1(this.this$01, this.toRemove.key, this.toRemove.value_0);
  this.toRemove = null;
}
;
var Lcom_google_common_collect_LinkedHashMultimap$1_2_classLit = createForClass('com.google.common.collect', 'LinkedHashMultimap/1', 757);
function LinkedHashMultimap$ValueEntry(key, value_0, smearedValueHash, nextInValueBucket){
  ImmutableEntry.call(this, key, value_0);
  this.smearedValueHash = smearedValueHash;
  this.nextInValueBucket = nextInValueBucket;
}

defineClass(318, 386, {410:1, 386:1, 318:1, 1788:1, 3:1, 39:1}, LinkedHashMultimap$ValueEntry);
_.getSuccessorInValueSet = function getSuccessorInValueSet(){
  return this.successorInValueSet;
}
;
_.setPredecessorInValueSet = function setPredecessorInValueSet(entry){
  this.predecessorInValueSet = entry;
}
;
_.setSuccessorInValueSet = function setSuccessorInValueSet(entry){
  this.successorInValueSet = entry;
}
;
_.smearedValueHash = 0;
var Lcom_google_common_collect_LinkedHashMultimap$ValueEntry_2_classLit = createForClass('com.google.common.collect', 'LinkedHashMultimap/ValueEntry', 318);
function $rehashIfNecessary(this$static){
  var bucket, entry, hashTable, mask, valueEntry;
  if (needsResizing(this$static.size_0, this$static.hashTable.length)) {
    hashTable = initUnidimensionalArray(Lcom_google_common_collect_LinkedHashMultimap$ValueEntry_2_classLit, $intern_33, 318, this$static.hashTable.length * 2, 0, 1);
    this$static.hashTable = hashTable;
    mask = hashTable.length - 1;
    for (entry = this$static.firstEntry; entry != this$static; entry = entry.getSuccessorInValueSet()) {
      valueEntry = castTo(entry, 318);
      bucket = valueEntry.smearedValueHash & mask;
      valueEntry.nextInValueBucket = hashTable[bucket];
      hashTable[bucket] = valueEntry;
    }
  }
}

function $remove_4(this$static, o){
  var bucket, entry, prev, smearedHash;
  smearedHash = $intern_34 * rotateLeft((o == null?0:hashCode__I__devirtual$(o)) * $intern_35, 15);
  bucket = smearedHash & this$static.hashTable.length - 1;
  prev = null;
  for (entry = this$static.hashTable[bucket]; entry; prev = entry , entry = entry.nextInValueBucket) {
    if (entry.smearedValueHash == smearedHash && equal(entry.value_0, o)) {
      !prev?(this$static.hashTable[bucket] = entry.nextInValueBucket):(prev.nextInValueBucket = entry.nextInValueBucket);
      succeedsInValueSet(entry.predecessorInValueSet, entry.successorInValueSet);
      succeedsInMultimap(entry.predecessorInMultimap, entry.successorInMultimap);
      --this$static.size_0;
      ++this$static.modCount;
      return true;
    }
  }
  return false;
}

function LinkedHashMultimap$ValueSet(this$0, key, expectedValues){
  var hashTable, tableSize;
  this.this$01 = this$0;
  this.key = key;
  this.firstEntry = this;
  this.lastEntry = this;
  tableSize = closedTableSize(expectedValues);
  hashTable = initUnidimensionalArray(Lcom_google_common_collect_LinkedHashMultimap$ValueEntry_2_classLit, $intern_33, 318, tableSize, 0, 1);
  this.hashTable = hashTable;
}

defineClass(1623, 1744, {1788:1, 20:1, 28:1, 13:1, 19:1}, LinkedHashMultimap$ValueSet);
_.add_1 = function add_10(value_0){
  var bucket, entry, newEntry, rowHead, smearedHash;
  smearedHash = $intern_34 * rotateLeft((value_0 == null?0:hashCode__I__devirtual$(value_0)) * $intern_35, 15);
  bucket = smearedHash & this.hashTable.length - 1;
  rowHead = this.hashTable[bucket];
  for (entry = rowHead; entry; entry = entry.nextInValueBucket) {
    if (entry.smearedValueHash == smearedHash && equal(entry.value_0, value_0)) {
      return false;
    }
  }
  newEntry = new LinkedHashMultimap$ValueEntry(this.key, value_0, smearedHash, rowHead);
  succeedsInValueSet(this.lastEntry, newEntry);
  newEntry.successorInValueSet = this;
  this.lastEntry = newEntry;
  succeedsInMultimap(this.this$01.multimapHeaderEntry.predecessorInMultimap, newEntry);
  succeedsInMultimap(newEntry, this.this$01.multimapHeaderEntry);
  this.hashTable[bucket] = newEntry;
  ++this.size_0;
  ++this.modCount;
  $rehashIfNecessary(this);
  return true;
}
;
_.clear_0 = function clear_19(){
  var entry, valueEntry;
  fill_3(this.hashTable, null);
  this.size_0 = 0;
  for (entry = this.firstEntry; entry != this; entry = entry.getSuccessorInValueSet()) {
    valueEntry = castTo(entry, 318);
    succeedsInMultimap(valueEntry.predecessorInMultimap, valueEntry.successorInMultimap);
  }
  this.firstEntry = this;
  this.lastEntry = this;
  ++this.modCount;
}
;
_.contains = function contains_14(o){
  var entry, smearedHash;
  smearedHash = $intern_34 * rotateLeft((o == null?0:hashCode__I__devirtual$(o)) * $intern_35, 15);
  for (entry = this.hashTable[smearedHash & this.hashTable.length - 1]; entry; entry = entry.nextInValueBucket) {
    if (entry.smearedValueHash == smearedHash && equal(entry.value_0, o)) {
      return true;
    }
  }
  return false;
}
;
_.forEach_0 = function forEach_8(action){
  var entry;
  checkNotNull(action);
  for (entry = this.firstEntry; entry != this; entry = entry.getSuccessorInValueSet()) {
    action.accept(castTo(entry, 318).value_0);
  }
}
;
_.getSuccessorInValueSet = function getSuccessorInValueSet_0(){
  return this.firstEntry;
}
;
_.iterator_0 = function iterator_27(){
  return new LinkedHashMultimap$ValueSet$1(this);
}
;
_.remove_1 = function remove_31(o){
  return $remove_4(this, o);
}
;
_.setPredecessorInValueSet = function setPredecessorInValueSet_0(entry){
  this.lastEntry = entry;
}
;
_.setSuccessorInValueSet = function setSuccessorInValueSet_0(entry){
  this.firstEntry = entry;
}
;
_.size_1 = function size_17(){
  return this.size_0;
}
;
_.modCount = 0;
_.size_0 = 0;
var Lcom_google_common_collect_LinkedHashMultimap$ValueSet_2_classLit = createForClass('com.google.common.collect', 'LinkedHashMultimap/ValueSet', 1623);
function $checkForComodification(this$static){
  if (this$static.this$11.modCount != this$static.expectedModCount) {
    throw toJs(new ConcurrentModificationException);
  }
}

function LinkedHashMultimap$ValueSet$1(this$1){
  this.this$11 = this$1;
  this.nextEntry = this.this$11.firstEntry;
  this.expectedModCount = this.this$11.modCount;
}

defineClass(1624, 1, $intern_4, LinkedHashMultimap$ValueSet$1);
_.forEachRemaining = function forEachRemaining_12(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_14(){
  return $checkForComodification(this) , this.nextEntry != this.this$11;
}
;
_.next_1 = function next_15(){
  var entry, result;
  $checkForComodification(this);
  if (this.nextEntry == this.this$11) {
    throw toJs(new NoSuchElementException);
  }
  entry = castTo(this.nextEntry, 318);
  result = entry.value_0;
  this.toRemove = entry;
  this.nextEntry = entry.successorInValueSet;
  return result;
}
;
_.remove_0 = function remove_32(){
  $checkForComodification(this);
  checkState_0(!!this.toRemove, 'no calls to next() since the last call to remove()');
  $remove_4(this.this$11, this.toRemove.value_0);
  this.expectedModCount = this.this$11.modCount;
  this.toRemove = null;
}
;
_.expectedModCount = 0;
var Lcom_google_common_collect_LinkedHashMultimap$ValueSet$1_2_classLit = createForClass('com.google.common.collect', 'LinkedHashMultimap/ValueSet/1', 1624);
function $addNode(this$static, key, value_0, nextSibling){
  var keyList, keyTail, node;
  node = new LinkedListMultimap$Node(key, value_0);
  if (!this$static.head) {
    this$static.head = this$static.tail = node;
    $put_1(this$static.keyToKeyList, key, new LinkedListMultimap$KeyList(node));
    ++this$static.modCount;
  }
   else if (!nextSibling) {
    this$static.tail.next_0 = node;
    node.previous = this$static.tail;
    this$static.tail = node;
    keyList = castTo($get_6(this$static.keyToKeyList, key), 275);
    if (!keyList) {
      $put_1(this$static.keyToKeyList, key, new LinkedListMultimap$KeyList(node));
      ++this$static.modCount;
    }
     else {
      ++keyList.count;
      keyTail = keyList.tail;
      keyTail.nextSibling = node;
      node.previousSibling = keyTail;
      keyList.tail = node;
    }
  }
   else {
    keyList = castTo($get_6(this$static.keyToKeyList, key), 275);
    ++keyList.count;
    node.previous = nextSibling.previous;
    node.previousSibling = nextSibling.previousSibling;
    node.next_0 = nextSibling;
    node.nextSibling = nextSibling;
    !nextSibling.previousSibling?(castTo($get_6(this$static.keyToKeyList, key), 275).head = node):(nextSibling.previousSibling.nextSibling = node);
    !nextSibling.previous?(this$static.head = node):(nextSibling.previous.next_0 = node);
    nextSibling.previous = node;
    nextSibling.previousSibling = node;
  }
  ++this$static.size_0;
  return node;
}

function $asMap(this$static){
  var result;
  return result = this$static.asMap , !result?(this$static.asMap = new Multimaps$AsMap(this$static)):result;
}

function $clear_2(this$static){
  this$static.head = null;
  this$static.tail = null;
  $reset(this$static.keyToKeyList);
  this$static.size_0 = 0;
  ++this$static.modCount;
}

function $containsKey_0(this$static, key){
  return $containsKey_2(this$static.keyToKeyList, key);
}

function $entries(this$static){
  var result;
  return result = this$static.entries_0 , castTo(!result?(this$static.entries_0 = new LinkedListMultimap$1EntriesImpl(this$static)):result, 15);
}

function $removeAll_2(this$static, key){
  var oldValues;
  oldValues = unmodifiableList(newArrayList_0(new LinkedListMultimap$ValueForKeyIterator(this$static, key)));
  clear_17(new LinkedListMultimap$ValueForKeyIterator(this$static, key));
  return oldValues;
}

function $removeNode(this$static, node){
  var keyList;
  node.previous?(node.previous.next_0 = node.next_0):(this$static.head = node.next_0);
  node.next_0?(node.next_0.previous = node.previous):(this$static.tail = node.previous);
  if (!node.previousSibling && !node.nextSibling) {
    keyList = castTo($remove_7(this$static.keyToKeyList, node.key), 275);
    keyList.count = 0;
    ++this$static.modCount;
  }
   else {
    keyList = castTo($get_6(this$static.keyToKeyList, node.key), 275);
    --keyList.count;
    !node.previousSibling?(keyList.head = node.nextSibling):(node.previousSibling.nextSibling = node.nextSibling);
    !node.nextSibling?(keyList.tail = node.previousSibling):(node.nextSibling.previousSibling = node.previousSibling);
  }
  --this$static.size_0;
}

function LinkedListMultimap(){
  this.keyToKeyList = ($clinit_Maps() , new HashMap);
}

function checkElement(node){
  if (!node) {
    throw toJs(new NoSuchElementException);
  }
}

defineClass(711, 1761, $intern_10, LinkedListMultimap);
_.asMap_0 = function asMap_4(){
  return $asMap(this);
}
;
_.equals_0 = function equals_24(object){
  return equalsImpl_0(this, object);
}
;
_.get_1 = function get_14(key){
  return new LinkedListMultimap$1(this, key);
}
;
_.removeAll = function removeAll_6(key){
  return $removeAll_2(this, key);
}
;
_.clear_0 = function clear_20(){
  $clear_2(this);
}
;
_.containsKey = function containsKey_3(key){
  return $containsKey_0(this, key);
}
;
_.createAsMap = function createAsMap_0(){
  return new Multimaps$AsMap(this);
}
;
_.createKeySet = function createKeySet_5(){
  return new LinkedListMultimap$1KeySetImpl(this);
}
;
_.entryIterator_0 = function entryIterator_2(){
  throw toJs(new AssertionError_0('should never be called'));
}
;
_.get_2 = function get_15(key){
  return new LinkedListMultimap$1(this, key);
}
;
_.isEmpty = function isEmpty_11(){
  return !this.head;
}
;
_.removeAll_0 = function removeAll_7(key){
  return $removeAll_2(this, key);
}
;
_.size_1 = function size_18(){
  return this.size_0;
}
;
_.modCount = 0;
_.size_0 = 0;
var Lcom_google_common_collect_LinkedListMultimap_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap', 711);
function $equals_2(this$static, o){
  var elem, elem$iterator, elemOther, iterOther, other;
  if (o === this$static) {
    return true;
  }
  if (!instanceOf(o, 15)) {
    return false;
  }
  other = castTo(o, 15);
  if (this$static.size_1() != other.size_1()) {
    return false;
  }
  iterOther = other.iterator_0();
  for (elem$iterator = this$static.iterator_0(); elem$iterator.hasNext_0();) {
    elem = elem$iterator.next_1();
    elemOther = iterOther.next_1();
    if (!(maskUndefined(elem) === maskUndefined(elemOther) || elem != null && equals_Ljava_lang_Object__Z__devirtual$(elem, elemOther))) {
      return false;
    }
  }
  return true;
}

function $indexOf(this$static, toFind){
  var i, n;
  for (i = 0 , n = this$static.size_1(); i < n; ++i) {
    if (equals_56(toFind, this$static.get_3(i))) {
      return i;
    }
  }
  return -1;
}

defineClass(43, 28, $intern_36);
_.sort_0 = function sort_2(c){
  $sort_0(this, c);
}
;
_.spliterator_0 = function spliterator_19(){
  return new Spliterators$IteratorSpliterator(this, 16);
}
;
_.add_3 = function add_11(index_0, element){
  throw toJs(new UnsupportedOperationException_0('Add not supported on this list'));
}
;
_.add_1 = function add_12(obj){
  this.add_3(this.size_1(), obj);
  return true;
}
;
_.clear_0 = function clear_21(){
  this.removeRange(0, this.size_1());
}
;
_.equals_0 = function equals_25(o){
  return $equals_2(this, o);
}
;
_.hashCode_1 = function hashCode_23(){
  return hashCode_45(this);
}
;
_.indexOf_0 = function indexOf_3(toFind){
  return $indexOf(this, toFind);
}
;
_.iterator_0 = function iterator_28(){
  return new AbstractList$IteratorImpl(this);
}
;
_.listIterator_0 = function listIterator_3(){
  return this.listIterator_1(0);
}
;
_.listIterator_1 = function listIterator_4(from){
  return new AbstractList$ListIteratorImpl(this, from);
}
;
_.remove_2 = function remove_33(index_0){
  throw toJs(new UnsupportedOperationException_0('Remove not supported on this list'));
}
;
_.removeRange = function removeRange(fromIndex, endIndex){
  var i, iter;
  iter = this.listIterator_1(fromIndex);
  for (i = fromIndex; i < endIndex; ++i) {
    iter.next_1();
    iter.remove_0();
  }
}
;
_.set_2 = function set_5(index_0, o){
  throw toJs(new UnsupportedOperationException_0('Set not supported on this list'));
}
;
_.subList = function subList_5(fromIndex, toIndex){
  return new AbstractList$SubList(this, fromIndex, toIndex);
}
;
_.modCount = 0;
var Ljava_util_AbstractList_2_classLit = createForClass('java.util', 'AbstractList', 43);
function $add_0(this$static, index_0, element){
  var iter;
  iter = this$static.listIterator_1(index_0);
  iter.add_2(element);
}

function $addAll_0(this$static, index_0, c){
  var e, e$iterator, iter, modified;
  checkCriticalNotNull(c);
  modified = false;
  iter = $listIterator_1(this$static, index_0);
  for (e$iterator = $listIterator_1(c, 0); e$iterator.currentNode != e$iterator.this$01.tail;) {
    e = $next_13(e$iterator);
    $add_8(iter, e);
    modified = true;
  }
  return modified;
}

function $get_3(this$static, index_0){
  var iter;
  iter = this$static.listIterator_1(index_0);
  try {
    return iter.next_1();
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 104)) {
      throw toJs(new IndexOutOfBoundsException_0("Can't get element " + index_0));
    }
     else 
      throw toJs($e0);
  }
}

function $remove_5(this$static, index_0){
  var iter, old;
  iter = this$static.listIterator_1(index_0);
  try {
    old = iter.next_1();
    iter.remove_0();
    return old;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 104)) {
      throw toJs(new IndexOutOfBoundsException_0("Can't remove element " + index_0));
    }
     else 
      throw toJs($e0);
  }
}

defineClass(1741, 43, $intern_36);
_.add_3 = function add_13(index_0, element){
  $add_0(this, index_0, element);
}
;
_.get_3 = function get_16(index_0){
  return $get_3(this, index_0);
}
;
_.iterator_0 = function iterator_29(){
  return this.listIterator_1(0);
}
;
_.remove_2 = function remove_34(index_0){
  return $remove_5(this, index_0);
}
;
_.set_2 = function set_6(index_0, element){
  var iter, old;
  iter = this.listIterator_1(index_0);
  try {
    old = iter.next_1();
    iter.set_1(element);
    return old;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 104)) {
      throw toJs(new IndexOutOfBoundsException_0("Can't set element " + index_0));
    }
     else 
      throw toJs($e0);
  }
}
;
var Ljava_util_AbstractSequentialList_2_classLit = createForClass('java.util', 'AbstractSequentialList', 1741);
function $listIterator(this$static, index_0){
  return new LinkedListMultimap$ValueForKeyIterator_0(this$static.this$01, this$static.val$key2, index_0);
}

function LinkedListMultimap$1(this$0, val$key){
  this.this$01 = this$0;
  this.val$key2 = val$key;
}

defineClass(600, 1741, $intern_36, LinkedListMultimap$1);
_.listIterator_1 = function listIterator_5(index_0){
  return $listIterator(this, index_0);
}
;
_.size_1 = function size_19(){
  var keyList;
  keyList = castTo($get_6(this.this$01.keyToKeyList, this.val$key2), 275);
  return !keyList?0:keyList.count;
}
;
var Lcom_google_common_collect_LinkedListMultimap$1_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/1', 600);
function LinkedListMultimap$1EntriesImpl(this$0){
  this.this$01 = this$0;
}

defineClass(712, 1741, $intern_36, LinkedListMultimap$1EntriesImpl);
_.forEach_0 = function forEach_9(action){
  var node;
  checkNotNull(action);
  for (node = this.this$01.head; node; node = node.next_0) {
    action.accept(node);
  }
}
;
_.listIterator_1 = function listIterator_6(index_0){
  return new LinkedListMultimap$NodeIterator(this.this$01, index_0);
}
;
_.size_1 = function size_20(){
  return this.this$01.size_0;
}
;
var Lcom_google_common_collect_LinkedListMultimap$1EntriesImpl_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/1EntriesImpl', 712);
function LinkedListMultimap$1KeySetImpl(this$0){
  this.this$01 = this$0;
}

defineClass(1181, 1744, $intern_14, LinkedListMultimap$1KeySetImpl);
_.contains = function contains_15(key){
  return $containsKey_0(this.this$01, key);
}
;
_.iterator_0 = function iterator_30(){
  return new LinkedListMultimap$DistinctKeyIterator(this.this$01);
}
;
_.remove_1 = function remove_35(o){
  return !$removeAll_2(this.this$01, o).list.isEmpty();
}
;
_.size_1 = function size_21(){
  return $size_0(this.this$01.keyToKeyList);
}
;
var Lcom_google_common_collect_LinkedListMultimap$1KeySetImpl_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/1KeySetImpl', 1181);
function $checkForConcurrentModification(this$static){
  if (this$static.this$01.modCount != this$static.expectedModCount) {
    throw toJs(new ConcurrentModificationException);
  }
}

function LinkedListMultimap$DistinctKeyIterator(this$0){
  this.this$01 = this$0;
  this.seenKeys = new HashSet_0(capacity_0($keySet_0(this.this$01).size_1()));
  this.next_0 = this.this$01.head;
  this.expectedModCount = this.this$01.modCount;
}

defineClass(1180, 1, $intern_4, LinkedListMultimap$DistinctKeyIterator);
_.forEachRemaining = function forEachRemaining_13(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_15(){
  $checkForConcurrentModification(this);
  return !!this.next_0;
}
;
_.next_1 = function next_16(){
  $checkForConcurrentModification(this);
  checkElement(this.next_0);
  this.current = this.next_0;
  $add_6(this.seenKeys, this.current.key);
  do {
    this.next_0 = this.next_0.next_0;
  }
   while (!!this.next_0 && !$add_6(this.seenKeys, this.next_0.key));
  return this.current.key;
}
;
_.remove_0 = function remove_36(){
  $checkForConcurrentModification(this);
  checkState_0(!!this.current, 'no calls to next() since the last call to remove()');
  clear_17(new LinkedListMultimap$ValueForKeyIterator(this.this$01, this.current.key));
  this.current = null;
  this.expectedModCount = this.this$01.modCount;
}
;
_.expectedModCount = 0;
var Lcom_google_common_collect_LinkedListMultimap$DistinctKeyIterator_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/DistinctKeyIterator', 1180);
function LinkedListMultimap$KeyList(firstNode){
  this.head = firstNode;
  this.tail = firstNode;
  firstNode.previousSibling = null;
  firstNode.nextSibling = null;
  this.count = 1;
}

defineClass(275, 1, {275:1}, LinkedListMultimap$KeyList);
_.count = 0;
var Lcom_google_common_collect_LinkedListMultimap$KeyList_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/KeyList', 275);
function LinkedListMultimap$Node(key, value_0){
  this.key = key;
  this.value_0 = value_0;
}

defineClass(1178, 410, $intern_19, LinkedListMultimap$Node);
_.getKey = function getKey_2(){
  return this.key;
}
;
_.getValue = function getValue_2(){
  return this.value_0;
}
;
_.setValue = function setValue_4(newValue){
  var result;
  result = this.value_0;
  this.value_0 = newValue;
  return result;
}
;
var Lcom_google_common_collect_LinkedListMultimap$Node_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/Node', 1178);
function $add_1(){
  throw toJs(new UnsupportedOperationException);
}

function $checkForConcurrentModification_0(this$static){
  if (this$static.this$01.modCount != this$static.expectedModCount) {
    throw toJs(new ConcurrentModificationException);
  }
}

function $next_4(this$static){
  $checkForConcurrentModification_0(this$static);
  checkElement(this$static.next_0);
  this$static.previous = this$static.current = this$static.next_0;
  this$static.next_0 = this$static.next_0.next_0;
  ++this$static.nextIndex;
  return this$static.current;
}

function $previous(this$static){
  $checkForConcurrentModification_0(this$static);
  checkElement(this$static.previous);
  this$static.next_0 = this$static.current = this$static.previous;
  this$static.previous = this$static.previous.previous;
  --this$static.nextIndex;
  return this$static.current;
}

function $set(){
  throw toJs(new UnsupportedOperationException);
}

function LinkedListMultimap$NodeIterator(this$0, index_0){
  var size_0;
  this.this$01 = this$0;
  this.expectedModCount = this.this$01.modCount;
  size_0 = this$0.size_0;
  checkPositionIndex(index_0, size_0);
  if (index_0 >= (size_0 / 2 | 0)) {
    this.previous = this$0.tail;
    this.nextIndex = size_0;
    while (index_0++ < size_0) {
      $previous(this);
    }
  }
   else {
    this.next_0 = this$0.head;
    while (index_0-- > 0) {
      $next_4(this);
    }
  }
  this.current = null;
}

defineClass(1179, 1, $intern_18, LinkedListMultimap$NodeIterator);
_.add_2 = function add_14(e){
  castTo(e, 39);
  $add_1();
}
;
_.forEachRemaining = function forEachRemaining_14(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_17(){
  return $next_4(this);
}
;
_.previous_0 = function previous_3(){
  return $previous(this);
}
;
_.set_1 = function set_7(e){
  castTo(e, 39);
  $set();
}
;
_.hasNext_0 = function hasNext_16(){
  $checkForConcurrentModification_0(this);
  return !!this.next_0;
}
;
_.hasPrevious = function hasPrevious_2(){
  $checkForConcurrentModification_0(this);
  return !!this.previous;
}
;
_.nextIndex_0 = function nextIndex_3(){
  return this.nextIndex;
}
;
_.previousIndex = function previousIndex_2(){
  return this.nextIndex - 1;
}
;
_.remove_0 = function remove_37(){
  $checkForConcurrentModification_0(this);
  checkState_0(!!this.current, 'no calls to next() since the last call to remove()');
  if (this.current != this.next_0) {
    this.previous = this.current.previous;
    --this.nextIndex;
  }
   else {
    this.next_0 = this.current.next_0;
  }
  $removeNode(this.this$01, this.current);
  this.current = null;
  this.expectedModCount = this.this$01.modCount;
}
;
_.expectedModCount = 0;
_.nextIndex = 0;
var Lcom_google_common_collect_LinkedListMultimap$NodeIterator_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/NodeIterator', 1179);
function $next_5(this$static){
  checkElement(this$static.next_0);
  this$static.previous = this$static.current = this$static.next_0;
  this$static.next_0 = this$static.next_0.nextSibling;
  ++this$static.nextIndex;
  return this$static.current.value_0;
}

function $previous_0(this$static){
  checkElement(this$static.previous);
  this$static.next_0 = this$static.current = this$static.previous;
  this$static.previous = this$static.previous.previousSibling;
  --this$static.nextIndex;
  return this$static.current.value_0;
}

function LinkedListMultimap$ValueForKeyIterator(this$0, key){
  var keyList;
  this.this$01 = this$0;
  this.key = key;
  keyList = castTo($get_6(this$0.keyToKeyList, key), 275);
  this.next_0 = !keyList?null:keyList.head;
}

function LinkedListMultimap$ValueForKeyIterator_0(this$0, key, index_0){
  var keyList, size_0;
  this.this$01 = this$0;
  keyList = castTo($get_6(this$0.keyToKeyList, key), 275);
  size_0 = !keyList?0:keyList.count;
  checkPositionIndex(index_0, size_0);
  if (index_0 >= (size_0 / 2 | 0)) {
    this.previous = !keyList?null:keyList.tail;
    this.nextIndex = size_0;
    while (index_0++ < size_0) {
      $previous_0(this);
    }
  }
   else {
    this.next_0 = !keyList?null:keyList.head;
    while (index_0-- > 0) {
      $next_5(this);
    }
  }
  this.key = key;
  this.current = null;
}

defineClass(525, 1, $intern_18, LinkedListMultimap$ValueForKeyIterator, LinkedListMultimap$ValueForKeyIterator_0);
_.forEachRemaining = function forEachRemaining_15(consumer){
  $forEachRemaining(this, consumer);
}
;
_.add_2 = function add_15(value_0){
  this.previous = $addNode(this.this$01, this.key, value_0, this.next_0);
  ++this.nextIndex;
  this.current = null;
}
;
_.hasNext_0 = function hasNext_17(){
  return !!this.next_0;
}
;
_.hasPrevious = function hasPrevious_3(){
  return !!this.previous;
}
;
_.next_1 = function next_18(){
  return $next_5(this);
}
;
_.nextIndex_0 = function nextIndex_4(){
  return this.nextIndex;
}
;
_.previous_0 = function previous_4(){
  return $previous_0(this);
}
;
_.previousIndex = function previousIndex_3(){
  return this.nextIndex - 1;
}
;
_.remove_0 = function remove_38(){
  checkState_0(!!this.current, 'no calls to next() since the last call to remove()');
  if (this.current != this.next_0) {
    this.previous = this.current.previousSibling;
    --this.nextIndex;
  }
   else {
    this.next_0 = this.current.nextSibling;
  }
  $removeNode(this.this$01, this.current);
  this.current = null;
}
;
_.set_1 = function set_8(value_0){
  checkState(!!this.current);
  this.current.value_0 = value_0;
}
;
_.nextIndex = 0;
var Lcom_google_common_collect_LinkedListMultimap$ValueForKeyIterator_2_classLit = createForClass('com.google.common.collect', 'LinkedListMultimap/ValueForKeyIterator', 525);
function computeArrayListCapacity(arraySize){
  checkNonnegative(arraySize, 'arraySize');
  return saturatedCast(add_20(add_20(5, arraySize), arraySize / 10 | 0));
}

function equalsImpl(thisList, other){
  var i, otherList, size_0;
  if (maskUndefined(other) === maskUndefined(checkNotNull(thisList))) {
    return true;
  }
  if (!instanceOf(other, 15)) {
    return false;
  }
  otherList = castTo(other, 15);
  size_0 = thisList.size_1();
  if (size_0 != otherList.size_1()) {
    return false;
  }
  if (instanceOf(otherList, 50)) {
    for (i = 0; i < size_0; i++) {
      if (!equal(thisList.get_3(i), otherList.get_3(i))) {
        return false;
      }
    }
    return true;
  }
   else {
    return elementsEqual(thisList.iterator_0(), otherList.iterator_0());
  }
}

function hashCodeImpl(list){
  var hashCode, o, o$iterator;
  hashCode = 1;
  for (o$iterator = list.iterator_0(); o$iterator.hasNext_0();) {
    o = o$iterator.next_1();
    hashCode = 31 * hashCode + (o == null?0:hashCode__I__devirtual$(o));
    hashCode = ~~hashCode;
  }
  return hashCode;
}

function indexOfRandomAccess(list, element){
  var i, size_0;
  size_0 = list.size_1();
  if (element == null) {
    for (i = 0; i < size_0; i++) {
      if (list.get_3(i) == null) {
        return i;
      }
    }
  }
   else {
    for (i = 0; i < size_0; i++) {
      if (equals_Ljava_lang_Object__Z__devirtual$(element, list.get_3(i))) {
        return i;
      }
    }
  }
  return -1;
}

function newArrayList(elements){
  checkNotNull(elements);
  return instanceOf(elements, 13)?new ArrayList_1(($clinit_Collections2() , castTo(elements, 13))):newArrayList_0(elements.iterator_0());
}

function newArrayList_0(elements){
  var list;
  list = new ArrayList;
  addAll_5(list, elements);
  return list;
}

function newArrayList_1(elements){
  var capacity, list;
  checkNotNull(elements);
  capacity = computeArrayListCapacity(elements.length);
  list = new ArrayList_0(capacity);
  addAll_8(list, elements);
  return list;
}

function newArrayListWithCapacity(initialArraySize){
  checkNonnegative(initialArraySize, 'initialArraySize');
  return new ArrayList_0(initialArraySize);
}

function newArrayListWithExpectedSize(estimatedSize){
  return new ArrayList_0((checkNonnegative(estimatedSize, 'arraySize') , saturatedCast(add_20(add_20(5, estimatedSize), estimatedSize / 10 | 0))));
}

function newLinkedList(elements){
  var list;
  list = new LinkedList;
  addAll_4(list, elements);
  return list;
}

function reverse_0(list){
  return instanceOf(list, 166)?$reverse(castTo(list, 166)):instanceOf(list, 138)?castTo(list, 138).forwardList:instanceOf(list, 50)?new Lists$RandomAccessReverseList(list):new Lists$ReverseList(list);
}

defineClass(937, 43, $intern_36);
_.add_3 = function add_16(index_0, element){
  this.backingList.add_3(index_0, element);
}
;
_.contains = function contains_16(o){
  return this.backingList.contains(o);
}
;
_.get_3 = function get_17(index_0){
  return this.backingList.get_3(index_0);
}
;
_.remove_2 = function remove_39(index_0){
  return this.backingList.remove_2(index_0);
}
;
_.set_2 = function set_9(index_0, element){
  return this.backingList.set_2(index_0, element);
}
;
_.size_1 = function size_22(){
  return this.backingList.size_1();
}
;
var Lcom_google_common_collect_Lists$AbstractListWrapper_2_classLit = createForClass('com.google.common.collect', 'Lists/AbstractListWrapper', 937);
defineClass(938, 937, $intern_37);
var Lcom_google_common_collect_Lists$RandomAccessListWrapper_2_classLit = createForClass('com.google.common.collect', 'Lists/RandomAccessListWrapper', 938);
function Lists$1($anonymous0){
  this.backingList = castTo(checkNotNull($anonymous0), 15);
}

defineClass(940, 938, $intern_37, Lists$1);
_.listIterator_1 = function listIterator_7(index_0){
  return this.backingList.listIterator_1(index_0);
}
;
var Lcom_google_common_collect_Lists$1_2_classLit = createForClass('com.google.common.collect', 'Lists/1', 940);
function $listIterator_0(this$static, index_0){
  var forwardIterator, start_0;
  start_0 = $reversePosition(this$static, index_0);
  forwardIterator = this$static.forwardList.listIterator_1(start_0);
  return new Lists$ReverseList$1(this$static, forwardIterator);
}

function $reverseIndex(this$static, index_0){
  var size_0;
  size_0 = this$static.forwardList.size_1();
  checkElementIndex(index_0, size_0);
  return size_0 - 1 - index_0;
}

function $reversePosition(this$static, index_0){
  var size_0;
  size_0 = this$static.forwardList.size_1();
  checkPositionIndex(index_0, size_0);
  return size_0 - index_0;
}

function Lists$ReverseList(forwardList){
  this.forwardList = castTo(checkNotNull(forwardList), 15);
}

defineClass(138, 43, {138:1, 20:1, 28:1, 43:1, 13:1, 15:1}, Lists$ReverseList);
_.add_3 = function add_17(index_0, element){
  this.forwardList.add_3($reversePosition(this, index_0), element);
}
;
_.clear_0 = function clear_22(){
  this.forwardList.clear_0();
}
;
_.get_3 = function get_18(index_0){
  return this.forwardList.get_3($reverseIndex(this, index_0));
}
;
_.iterator_0 = function iterator_31(){
  return $listIterator_0(this, 0);
}
;
_.listIterator_1 = function listIterator_8(index_0){
  return $listIterator_0(this, index_0);
}
;
_.remove_2 = function remove_40(index_0){
  return this.forwardList.remove_2($reverseIndex(this, index_0));
}
;
_.removeRange = function removeRange_0(fromIndex, toIndex){
  (checkPositionIndexes(fromIndex, toIndex, this.forwardList.size_1()) , reverse_0(this.forwardList.subList($reversePosition(this, toIndex), $reversePosition(this, fromIndex)))).clear_0();
}
;
_.set_2 = function set_10(index_0, element){
  return this.forwardList.set_2($reverseIndex(this, index_0), element);
}
;
_.size_1 = function size_23(){
  return this.forwardList.size_1();
}
;
_.subList = function subList_6(fromIndex, toIndex){
  return checkPositionIndexes(fromIndex, toIndex, this.forwardList.size_1()) , reverse_0(this.forwardList.subList($reversePosition(this, toIndex), $reversePosition(this, fromIndex)));
}
;
var Lcom_google_common_collect_Lists$ReverseList_2_classLit = createForClass('com.google.common.collect', 'Lists/ReverseList', 138);
function Lists$RandomAccessReverseList(forwardList){
  Lists$ReverseList.call(this, forwardList);
}

defineClass(286, 138, {138:1, 20:1, 28:1, 43:1, 13:1, 15:1, 50:1}, Lists$RandomAccessReverseList);
var Lcom_google_common_collect_Lists$RandomAccessReverseList_2_classLit = createForClass('com.google.common.collect', 'Lists/RandomAccessReverseList', 286);
function $next_6(this$static){
  if (!this$static.val$forwardIterator2.hasPrevious()) {
    throw toJs(new NoSuchElementException);
  }
  this$static.canRemoveOrSet = true;
  return this$static.val$forwardIterator2.previous_0();
}

function Lists$ReverseList$1(this$1, val$forwardIterator){
  this.this$11 = this$1;
  this.val$forwardIterator2 = val$forwardIterator;
}

defineClass(939, 1, $intern_18, Lists$ReverseList$1);
_.forEachRemaining = function forEachRemaining_16(consumer){
  $forEachRemaining(this, consumer);
}
;
_.add_2 = function add_18(e){
  this.val$forwardIterator2.add_2(e);
  this.val$forwardIterator2.previous_0();
  this.canRemoveOrSet = false;
}
;
_.hasNext_0 = function hasNext_18(){
  return this.val$forwardIterator2.hasPrevious();
}
;
_.hasPrevious = function hasPrevious_4(){
  return this.val$forwardIterator2.hasNext_0();
}
;
_.next_1 = function next_19(){
  return $next_6(this);
}
;
_.nextIndex_0 = function nextIndex_5(){
  return $reversePosition(this.this$11, this.val$forwardIterator2.nextIndex_0());
}
;
_.previous_0 = function previous_5(){
  if (!this.val$forwardIterator2.hasNext_0()) {
    throw toJs(new NoSuchElementException);
  }
  this.canRemoveOrSet = true;
  return this.val$forwardIterator2.next_1();
}
;
_.previousIndex = function previousIndex_4(){
  return $reversePosition(this.this$11, this.val$forwardIterator2.nextIndex_0()) - 1;
}
;
_.remove_0 = function remove_41(){
  checkState_0(this.canRemoveOrSet, 'no calls to next() since the last call to remove()');
  this.val$forwardIterator2.remove_0();
  this.canRemoveOrSet = false;
}
;
_.set_1 = function set_11(e){
  checkState(this.canRemoveOrSet);
  this.val$forwardIterator2.set_1(e);
}
;
_.canRemoveOrSet = false;
var Lcom_google_common_collect_Lists$ReverseList$1_2_classLit = createForClass('com.google.common.collect', 'Lists/ReverseList/1', 939);
function $clinit_Maps(){
  $clinit_Maps = emptyMethod;
  new Joiner$MapJoiner(($clinit_Collections2() , '='));
}

function asMapEntryIterator(set_0, function_0){
  $clinit_Maps();
  return new Maps$1(set_0.iterator_0(), function_0);
}

function capacity_0(expectedSize){
  $clinit_Maps();
  if (expectedSize < 3) {
    checkNonnegative(expectedSize, 'expectedSize');
    return expectedSize + 1;
  }
  if (expectedSize < $intern_24) {
    return round_int(expectedSize / 0.75 + 1);
  }
  return $intern_0;
}

function containsEntryImpl(c, o){
  $clinit_Maps();
  if (!instanceOf(o, 39)) {
    return false;
  }
  return c.contains(unmodifiableEntry(castTo(o, 39)));
}

function safeContainsKey(map_0, key){
  $clinit_Maps();
  checkNotNull(map_0);
  try {
    return map_0.containsKey(key);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 182)) {
      return false;
    }
     else if (instanceOf($e0, 172)) {
      return false;
    }
     else 
      throw toJs($e0);
  }
}

function safeGet(map_0, key){
  $clinit_Maps();
  checkNotNull(map_0);
  try {
    return map_0.get_0(key);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 182)) {
      return null;
    }
     else if (instanceOf($e0, 172)) {
      return null;
    }
     else 
      throw toJs($e0);
  }
}

function safeRemove(map_0, key){
  $clinit_Maps();
  checkNotNull(map_0);
  try {
    return map_0.remove(key);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 182)) {
      return null;
    }
     else if (instanceOf($e0, 172)) {
      return null;
    }
     else 
      throw toJs($e0);
  }
}

function unmodifiableEntry(entry){
  checkNotNull(entry);
  return new Maps$4(entry);
}

function Maps$1($anonymous0, val$function){
  this.val$function2 = val$function;
  TransformedIterator.call(this, $anonymous0);
}

defineClass(874, 499, $intern_4, Maps$1);
_.transform_0 = function transform_7(key){
  return $clinit_Maps() , new ImmutableEntry(key, $apply_0(this.val$function2, key));
}
;
var Lcom_google_common_collect_Maps$1_2_classLit = createForClass('com.google.common.collect', 'Maps/1', 874);
function Maps$4(val$entry){
  this.val$entry1 = val$entry;
}

defineClass(875, 410, $intern_19, Maps$4);
_.getKey = function getKey_3(){
  return this.val$entry1.getKey();
}
;
_.getValue = function getValue_3(){
  return this.val$entry1.getValue();
}
;
var Lcom_google_common_collect_Maps$4_2_classLit = createForClass('com.google.common.collect', 'Maps/4', 875);
function $compareTo(this$static, other){
  return this$static.ordinal - other.ordinal;
}

function $toString_2(this$static){
  return this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal;
}

function Enum(name_0, ordinal){
  this.name_0 = name_0;
  this.ordinal = ordinal;
}

function createValueOfMap(enumConstants){
  var result, value_0, value$index, value$max;
  result = {};
  for (value$index = 0 , value$max = enumConstants.length; value$index < value$max; ++value$index) {
    value_0 = enumConstants[value$index];
    result[':' + (value_0.name_0 != null?value_0.name_0:'' + value_0.ordinal)] = value_0;
  }
  return result;
}

function valueOf(map_0, name_0){
  var result;
  checkCriticalNotNull(name_0);
  result = map_0[':' + name_0];
  checkCriticalArgument_1(!!result, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [name_0]));
  return result;
}

function valueOf_0(enumType, name_0){
  var enumValueOfFunc;
  enumValueOfFunc = (checkCriticalNotNull(enumType) , enumType).enumValueOfFunc;
  checkCriticalArgument(!!enumValueOfFunc);
  checkCriticalNotNull(name_0);
  return enumValueOfFunc(name_0);
}

defineClass(22, 1, {3:1, 34:1, 22:1});
_.compareTo_0 = function compareTo_3(other){
  return $compareTo(this, castTo(other, 22));
}
;
_.equals_0 = function equals_26(other){
  return this === other;
}
;
_.hashCode_1 = function hashCode_24(){
  return getHashCode_0(this);
}
;
_.toString_0 = function toString_26(){
  return $toString_2(this);
}
;
_.ordinal = 0;
var Ljava_lang_Enum_2_classLit = createForClass('java.lang', 'Enum', 22);
function $clinit_Maps$EntryFunction(){
  $clinit_Maps$EntryFunction = emptyMethod;
  KEY = new Maps$EntryFunction$1;
  VALUE = new Maps$EntryFunction$2;
}

function Maps$EntryFunction(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_1(name_0){
  $clinit_Maps$EntryFunction();
  return valueOf(($clinit_Maps$EntryFunction$Map() , $MAP), name_0);
}

function values_6(){
  $clinit_Maps$EntryFunction();
  return stampJavaTypeInfo(getClassLiteralForArray(Lcom_google_common_collect_Maps$EntryFunction_2_classLit, 1), $intern_38, 362, 0, [KEY, VALUE]);
}

defineClass(362, 22, $intern_39);
var KEY, VALUE;
var Lcom_google_common_collect_Maps$EntryFunction_2_classLit = createForEnum('com.google.common.collect', 'Maps/EntryFunction', 362, Ljava_lang_Enum_2_classLit, values_6, valueOf_1);
function Maps$EntryFunction$1(){
  Maps$EntryFunction.call(this, 'KEY', 0);
}

defineClass(870, 362, $intern_39, Maps$EntryFunction$1);
_.apply_0 = function apply_10(entry){
  return castTo(entry, 39).getKey();
}
;
var Lcom_google_common_collect_Maps$EntryFunction$1_2_classLit = createForEnum('com.google.common.collect', 'Maps/EntryFunction/1', 870, Lcom_google_common_collect_Maps$EntryFunction_2_classLit, null, null);
function Maps$EntryFunction$2(){
  Maps$EntryFunction.call(this, 'VALUE', 1);
}

defineClass(871, 362, $intern_39, Maps$EntryFunction$2);
_.apply_0 = function apply_11(entry){
  return castTo(entry, 39).getValue();
}
;
var Lcom_google_common_collect_Maps$EntryFunction$2_2_classLit = createForEnum('com.google.common.collect', 'Maps/EntryFunction/2', 871, Lcom_google_common_collect_Maps$EntryFunction_2_classLit, null, null);
function $clinit_Maps$EntryFunction$Map(){
  $clinit_Maps$EntryFunction$Map = emptyMethod;
  $MAP = createValueOfMap(($clinit_Maps$EntryFunction() , stampJavaTypeInfo(getClassLiteralForArray(Lcom_google_common_collect_Maps$EntryFunction_2_classLit, 1), $intern_38, 362, 0, [KEY, VALUE])));
}

var $MAP;
function Maps$KeySet$lambda$0$Type(action_0){
  this.action_0 = action_0;
}

defineClass(872, 1, {}, Maps$KeySet$lambda$0$Type);
_.accept_0 = function accept_6(arg0, arg1){
  this.action_0.accept(arg0);
}
;
var Lcom_google_common_collect_Maps$KeySet$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'Maps/KeySet/lambda$0$Type', 872);
function Maps$Values(map_0){
  this.map_0 = castTo(checkNotNull(map_0), 111);
}

defineClass(869, 28, $intern_12, Maps$Values);
_.clear_0 = function clear_23(){
  this.map_0.clear_0();
}
;
_.contains = function contains_17(o){
  return this.map_0.containsValue(o);
}
;
_.forEach_0 = function forEach_10(action){
  checkNotNull(action);
  this.map_0.forEach(new Maps$Values$lambda$0$Type(action));
}
;
_.isEmpty = function isEmpty_12(){
  return this.map_0.isEmpty();
}
;
_.iterator_0 = function iterator_32(){
  return $clinit_Maps() , transform_3(this.map_0.entrySet_0().iterator_0(), ($clinit_Maps$EntryFunction() , VALUE));
}
;
_.remove_1 = function remove_42(o){
  var entry, entry$iterator;
  try {
    return $advanceToFind(this, o, true);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 48)) {
      for (entry$iterator = this.map_0.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
        entry = castTo(entry$iterator.next_1(), 39);
        if (equal(o, entry.getValue())) {
          this.map_0.remove(entry.getKey());
          return true;
        }
      }
      return false;
    }
     else 
      throw toJs($e0);
  }
}
;
_.size_1 = function size_24(){
  return this.map_0.size_1();
}
;
var Lcom_google_common_collect_Maps$Values_2_classLit = createForClass('com.google.common.collect', 'Maps/Values', 869);
function Maps$Values$lambda$0$Type(action_0){
  this.action_0 = action_0;
}

defineClass(873, 1, {}, Maps$Values$lambda$0$Type);
_.accept_0 = function accept_7(arg0, arg1){
  this.action_0.accept(arg1);
}
;
var Lcom_google_common_collect_Maps$Values$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'Maps/Values/lambda$0$Type', 873);
function equalsImpl_0(multimap, object){
  var that;
  if (object === multimap) {
    return true;
  }
  if (instanceOf(object, 249)) {
    that = castTo(object, 249);
    return equals_Ljava_lang_Object__Z__devirtual$(multimap.asMap_0(), that.asMap_0());
  }
  return false;
}

function invertFrom(source, dest){
  var entry, entry$iterator, result;
  checkNotNull(dest);
  for (entry$iterator = (result = source.entries_0 , castTo(!result?(source.entries_0 = new LinkedListMultimap$1EntriesImpl(source)):result, 15)).iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    $put(dest, entry.getValue(), entry.getKey());
  }
  return dest;
}

function $removeValuesForKey_0(this$static, key){
  this$static.multimap.keySet_0().remove_1(key);
}

function Multimaps$AsMap(multimap){
  this.multimap = castTo(checkNotNull(multimap), 249);
}

defineClass(683, 1762, $intern_2, Multimaps$AsMap);
_.get_0 = function get_19(key){
  return this.multimap.containsKey(key)?this.multimap.get_1(key):null;
}
;
_.remove = function remove_43(key){
  return this.multimap.containsKey(key)?this.multimap.removeAll(key):null;
}
;
_.clear_0 = function clear_24(){
  this.multimap.clear_0();
}
;
_.containsKey = function containsKey_4(key){
  return this.multimap.containsKey(key);
}
;
_.createEntrySet_0 = function createEntrySet_0(){
  return new Multimaps$AsMap$EntrySet(this);
}
;
_.createEntrySet = function(){
  return this.createEntrySet_0();
}
;
_.isEmpty = function isEmpty_13(){
  return this.multimap.isEmpty();
}
;
_.keySet_0 = function keySet_11(){
  return this.multimap.keySet_0();
}
;
_.size_1 = function size_25(){
  return this.multimap.keySet_0().size_1();
}
;
var Lcom_google_common_collect_Multimaps$AsMap_2_classLit = createForClass('com.google.common.collect', 'Multimaps/AsMap', 683);
function Multimaps$AsMap$EntrySet(this$1){
  this.this$11 = this$1;
}

defineClass(1018, 1763, $intern_14, Multimaps$AsMap$EntrySet);
_.iterator_0 = function iterator_33(){
  return asMapEntryIterator(this.this$11.multimap.keySet_0(), new Multimaps$AsMap$EntrySet$1(this));
}
;
_.map_1 = function map_3(){
  return this.this$11;
}
;
_.remove_1 = function remove_44(o){
  var entry;
  if (!$contains_0(this, o)) {
    return false;
  }
  entry = castTo(o, 39);
  $removeValuesForKey_0(this.this$11, entry.getKey());
  return true;
}
;
var Lcom_google_common_collect_Multimaps$AsMap$EntrySet_2_classLit = createForClass('com.google.common.collect', 'Multimaps/AsMap/EntrySet', 1018);
function $apply_0(this$static, key){
  return this$static.this$21.this$11.multimap.get_1(key);
}

function Multimaps$AsMap$EntrySet$1(this$2){
  this.this$21 = this$2;
}

defineClass(1021, 1, $intern_25, Multimaps$AsMap$EntrySet$1);
_.apply_0 = function apply_12(key){
  return $apply_0(this, key);
}
;
_.equals_0 = function equals_27(other){
  return this === other;
}
;
var Lcom_google_common_collect_Multimaps$AsMap$EntrySet$1_2_classLit = createForClass('com.google.common.collect', 'Multimaps/AsMap/EntrySet/1', 1021);
function $count(this$static, element){
  var values;
  values = castTo(safeGet($asMap(this$static.multimap), element), 13);
  return !values?0:values.size_1();
}

function $iterator_2(this$static){
  return $clinit_Maps() , transform_3($entries(this$static.multimap).iterator_0(), ($clinit_Maps$EntryFunction() , KEY));
}

function $remove_6(this$static, element, occurrences){
  var i, iterator, oldCount, values, values0;
  checkNonnegative(occurrences, 'occurrences');
  if (occurrences == 0) {
    return values0 = castTo(safeGet($asMap(this$static.multimap), element), 13) , !values0?0:values0.size_1();
  }
  values = castTo(safeGet($asMap(this$static.multimap), element), 13);
  if (!values) {
    return 0;
  }
  oldCount = values.size_1();
  if (occurrences >= oldCount) {
    values.clear_0();
  }
   else {
    iterator = values.iterator_0();
    for (i = 0; i < occurrences; i++) {
      iterator.next_1();
      iterator.remove_0();
    }
  }
  return oldCount;
}

function Multimaps$Keys(multimap){
  this.multimap = multimap;
}

defineClass(507, 1765, {507:1, 768:1, 20:1, 28:1, 13:1}, Multimaps$Keys);
_.clear_0 = function clear_25(){
  $clear_2(this.multimap);
}
;
_.contains = function contains_18(element){
  return $containsKey_0(this.multimap, element);
}
;
_.forEach_0 = function forEach_11(consumer){
  checkNotNull(consumer);
  $entries(this.multimap).forEach_0(new Multimaps$Keys$lambda$0$Type(consumer));
}
;
_.iterator_0 = function iterator_34(){
  return $iterator_2(this);
}
;
_.spliterator_0 = function spliterator_20(){
  return map_2($entries(this.multimap).spliterator_0(), new Multimaps$Keys$0methodref$getKey$Type);
}
;
var Lcom_google_common_collect_Multimaps$Keys_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys', 507);
function Multimaps$Keys$0methodref$getKey$Type(){
}

defineClass(1019, 1, $intern_11, Multimaps$Keys$0methodref$getKey$Type);
_.apply_0 = function apply_13(arg0){
  return castTo(arg0, 39).getKey();
}
;
var Lcom_google_common_collect_Multimaps$Keys$0methodref$getKey$Type_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys/0methodref$getKey$Type', 1019);
function Multimaps$Keys$1($anonymous0){
  TransformedIterator.call(this, $anonymous0);
}

defineClass(684, 499, $intern_4, Multimaps$Keys$1);
_.transform_0 = function transform_8(backingEntry){
  return new Multimaps$Keys$1$1(castTo(backingEntry, 39));
}
;
var Lcom_google_common_collect_Multimaps$Keys$1_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys/1', 684);
defineClass(1767, 1, {320:1});
_.equals_0 = function equals_28(object){
  var that;
  if (instanceOf(object, 307)) {
    that = castTo(object, 320);
    return castTo(this.val$backingEntry2.getValue(), 13).size_1() == castTo(that.val$backingEntry2.getValue(), 13).size_1() && equal(this.val$backingEntry2.getKey(), that.val$backingEntry2.getKey());
  }
  return false;
}
;
_.hashCode_1 = function hashCode_25(){
  var e;
  e = this.val$backingEntry2.getKey();
  return (e == null?0:hashCode__I__devirtual$(e)) ^ castTo(this.val$backingEntry2.getValue(), 13).size_1();
}
;
_.toString_0 = function toString_27(){
  var n, text_0;
  text_0 = valueOf_7(this.val$backingEntry2.getKey());
  n = castTo(this.val$backingEntry2.getValue(), 13).size_1();
  return n == 1?text_0:text_0 + ' x ' + n;
}
;
var Lcom_google_common_collect_Multisets$AbstractEntry_2_classLit = createForClass('com.google.common.collect', 'Multisets/AbstractEntry', 1767);
function Multimaps$Keys$1$1(val$backingEntry){
  this.val$backingEntry2 = val$backingEntry;
}

defineClass(307, 1767, {307:1, 320:1}, Multimaps$Keys$1$1);
var Lcom_google_common_collect_Multimaps$Keys$1$1_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys/1/1', 307);
defineClass(1766, 1744, $intern_14);
_.clear_0 = function clear_26(){
  $clear_2(this.this$11.multimap);
}
;
_.contains = function contains_19(o){
  var count, entry;
  if (instanceOf(o, 307)) {
    entry = castTo(o, 320);
    if (castTo(entry.val$backingEntry2.getValue(), 13).size_1() <= 0) {
      return false;
    }
    count = $count(this.this$11, entry.val$backingEntry2.getKey());
    return count == castTo(entry.val$backingEntry2.getValue(), 13).size_1();
  }
  return false;
}
;
_.remove_1 = function remove_45(object){
  var element, entry, entryCount, multiset;
  if (instanceOf(object, 307)) {
    entry = castTo(object, 320);
    element = entry.val$backingEntry2.getKey();
    entryCount = castTo(entry.val$backingEntry2.getValue(), 13).size_1();
    if (entryCount != 0) {
      multiset = this.this$11;
      return setCountImpl(multiset, element, entryCount);
    }
  }
  return false;
}
;
var Lcom_google_common_collect_Multisets$EntrySet_2_classLit = createForClass('com.google.common.collect', 'Multisets/EntrySet', 1766);
function Multimaps$Keys$KeysEntrySet(this$1){
  this.this$11 = this$1;
}

defineClass(1017, 1766, $intern_14, Multimaps$Keys$KeysEntrySet);
_.contains = function contains_20(o){
  var collection, entry;
  if (instanceOf(o, 307)) {
    entry = castTo(o, 320);
    collection = castTo($asMap(this.this$11.multimap).get_0(entry.val$backingEntry2.getKey()), 13);
    return !!collection && collection.size_1() == castTo(entry.val$backingEntry2.getValue(), 13).size_1();
  }
  return false;
}
;
_.isEmpty = function isEmpty_14(){
  return !this.this$11.multimap.head;
}
;
_.iterator_0 = function iterator_35(){
  return new Multimaps$Keys$1($entrySet_0($asMap(this.this$11.multimap)).iterator_0());
}
;
_.remove_1 = function remove_46(o){
  var collection, entry;
  if (instanceOf(o, 307)) {
    entry = castTo(o, 320);
    collection = castTo($asMap(this.this$11.multimap).get_0(entry.val$backingEntry2.getKey()), 13);
    if (!!collection && collection.size_1() == castTo(entry.val$backingEntry2.getValue(), 13).size_1()) {
      collection.clear_0();
      return true;
    }
  }
  return false;
}
;
_.size_1 = function size_26(){
  return $asMap(this.this$11.multimap).size_1();
}
;
var Lcom_google_common_collect_Multimaps$Keys$KeysEntrySet_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys/KeysEntrySet', 1017);
function Multimaps$Keys$lambda$0$Type(consumer_0){
  this.consumer_0 = consumer_0;
}

defineClass(1020, 1, {}, Multimaps$Keys$lambda$0$Type);
_.accept = function accept_8(arg0){
  this.consumer_0.accept(castTo(arg0, 39).getKey());
}
;
var Lcom_google_common_collect_Multimaps$Keys$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'Multimaps/Keys/lambda$0$Type', 1020);
function Multiset$lambda$1$Type(action_0){
  this.action_0 = action_0;
}

defineClass(685, 1, {}, Multiset$lambda$1$Type);
_.accept = function accept_9(arg0){
  lambda$1_0(this.action_0, arg0);
}
;
var Lcom_google_common_collect_Multiset$lambda$1$Type_2_classLit = createForClass('com.google.common.collect', 'Multiset/lambda$1$Type', 685);
function addAllImpl(self_0, elements){
  var entry, entry$iterator, that;
  if (elements.isEmpty()) {
    return false;
  }
  if (instanceOf(elements, 507)) {
    that = castTo(elements, 768);
    for (entry$iterator = $entrySet_1(that).iterator_0(); entry$iterator.hasNext_0();) {
      entry = castTo(entry$iterator.next_1(), 320);
      entry.val$backingEntry2.getKey();
      castTo(entry.val$backingEntry2.getValue(), 13).size_1();
      $add();
    }
  }
   else {
    addAll_5(self_0, elements.iterator_0());
  }
  return true;
}

function equalsImpl_1(multiset, object){
  var entry, entry$iterator, that;
  if (object === multiset) {
    return true;
  }
  if (instanceOf(object, 507)) {
    that = castTo(object, 768);
    if (sizeImpl(multiset) != sizeImpl(that) || $entrySet_1(multiset).size_1() != $entrySet_1(that).size_1()) {
      return false;
    }
    for (entry$iterator = $entrySet_1(that).iterator_0(); entry$iterator.hasNext_0();) {
      entry = castTo(entry$iterator.next_1(), 320);
      if ($count(multiset, entry.val$backingEntry2.getKey()) != castTo(entry.val$backingEntry2.getValue(), 13).size_1()) {
        return false;
      }
    }
    return true;
  }
  return false;
}

function setCountImpl(self_0, element, oldCount){
  var values, oldCount_0, values_0, delta;
  checkNonnegative(oldCount, 'oldCount');
  checkNonnegative(0, 'newCount');
  values = castTo(safeGet($asMap(self_0.multimap), element), 13);
  if ((!values?0:values.size_1()) == oldCount) {
    checkNonnegative(0, 'count');
    oldCount_0 = (values_0 = castTo(safeGet($asMap(self_0.multimap), element), 13) , !values_0?0:values_0.size_1());
    delta = -oldCount_0;
    delta > 0?$add():delta < 0 && $remove_6(self_0, element, -delta);
    return true;
  }
   else {
    return false;
  }
}

function sizeImpl(multiset){
  var entry, entry$iterator, size_0;
  size_0 = 0;
  for (entry$iterator = $entrySet_1(multiset).iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 320);
    size_0 = add_20(size_0, castTo(entry.val$backingEntry2.getValue(), 13).size_1());
  }
  return saturatedCast(size_0);
}

function Multisets$MultisetIteratorImpl(multiset, entryIterator){
  this.multiset = multiset;
  this.entryIterator = entryIterator;
}

defineClass(1022, 1, $intern_4, Multisets$MultisetIteratorImpl);
_.forEachRemaining = function forEachRemaining_17(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_19(){
  return this.laterCount > 0 || this.entryIterator.hasNext_0();
}
;
_.next_1 = function next_20(){
  if (!(this.laterCount > 0 || this.entryIterator.hasNext_0())) {
    throw toJs(new NoSuchElementException);
  }
  if (this.laterCount == 0) {
    this.currentEntry = castTo(this.entryIterator.next_1(), 320);
    this.totalCount = this.laterCount = castTo(this.currentEntry.val$backingEntry2.getValue(), 13).size_1();
  }
  --this.laterCount;
  this.canRemove = true;
  return this.currentEntry.val$backingEntry2.getKey();
}
;
_.remove_0 = function remove_47(){
  checkState_0(this.canRemove, 'no calls to next() since the last call to remove()');
  this.totalCount == 1?this.entryIterator.remove_0():$remove_6(this.multiset, this.currentEntry.val$backingEntry2.getKey(), 1) > 0;
  --this.totalCount;
  this.canRemove = false;
}
;
_.canRemove = false;
_.laterCount = 0;
_.totalCount = 0;
var Lcom_google_common_collect_Multisets$MultisetIteratorImpl_2_classLit = createForClass('com.google.common.collect', 'Multisets/MultisetIteratorImpl', 1022);
function Multisets$lambda$0$Type(){
}

defineClass(686, 1, $intern_11, Multisets$lambda$0$Type);
_.apply_0 = function apply_14(arg0){
  return new Spliterators$IteratorSpliterator(nCopies(castTo(castTo(arg0, 307).val$backingEntry2.getValue(), 13).size_1(), castTo(arg0, 307).val$backingEntry2.getKey()), 16);
}
;
var Lcom_google_common_collect_Multisets$lambda$0$Type_2_classLit = createForClass('com.google.common.collect', 'Multisets/lambda$0$Type', 686);
defineClass(1768, 1, $intern_40);
_.equals_0 = function equals_29(other){
  return this === other;
}
;
_.reversed = function reversed_0(){
  return new Comparators$ReversedComparator(this);
}
;
var Lcom_google_common_collect_Ordering_2_classLit = createForClass('com.google.common.collect', 'Ordering', 1768);
function $clinit_NaturalOrdering(){
  $clinit_NaturalOrdering = emptyMethod;
  INSTANCE_2 = new NaturalOrdering;
}

function $compare(left, right){
  checkNotNull(left);
  checkNotNull(right);
  return compareTo_Ljava_lang_Object__I__devirtual$(left, right);
}

function NaturalOrdering(){
}

defineClass(1707, 1768, $intern_41, NaturalOrdering);
_.compare_0 = function compare_0(left, right){
  return $compare(castTo(left, 34), castTo(right, 34));
}
;
_.toString_0 = function toString_28(){
  return 'Ordering.natural()';
}
;
var INSTANCE_2;
var Lcom_google_common_collect_NaturalOrdering_2_classLit = createForClass('com.google.common.collect', 'NaturalOrdering', 1707);
function fillArray(elements, array){
  var element, element$iterator, i;
  i = 0;
  for (element$iterator = elements.iterator_0(); element$iterator.hasNext_0();) {
    element = element$iterator.next_1();
    setCheck(array, i++, element);
  }
  return array;
}

function toArrayImpl(c, array){
  var size_0, clone;
  size_0 = c.size_1();
  array.length < size_0 && (array = (clone = (checkCriticalArraySize(0) , copyObjectArray(array, 0)) , clone.length = size_0 , clone));
  fillArray(c, array);
  array.length > size_0 && setCheck(array, size_0, null);
  return array;
}

function $clinit_Range(){
  $clinit_Range = emptyMethod;
  new Range_0(($clinit_Cut$BelowAll() , INSTANCE_1), ($clinit_Cut$AboveAll() , INSTANCE_0));
}

function $apply_1(this$static, input_0){
  return checkNotNull(input_0) , this$static.lowerBound.isLessThan(input_0) && !this$static.upperBound.isLessThan(input_0);
}

function Range_0(lowerBound, upperBound){
  this.lowerBound = castTo(checkNotNull(lowerBound), 227);
  this.upperBound = castTo(checkNotNull(upperBound), 227);
  if (lowerBound.compareTo(upperBound) > 0 || lowerBound == ($clinit_Cut$AboveAll() , INSTANCE_0) || upperBound == ($clinit_Cut$BelowAll() , INSTANCE_1)) {
    throw toJs(new IllegalArgumentException_0('Invalid range: ' + toString_30(lowerBound, upperBound)));
  }
}

function closed_0(lower, upper){
  $clinit_Range();
  return new Range_0(new Cut$BelowValue(lower), new Cut$AboveValue(upper));
}

function toString_30(lowerBound, upperBound){
  var sb;
  sb = new StringBuilder_0;
  lowerBound.describeAsLowerBound(sb);
  sb.string += '..';
  upperBound.describeAsUpperBound(sb);
  return sb.string;
}

defineClass(484, 1, {139:1, 484:1, 3:1, 56:1}, Range_0);
_.apply_1 = function apply_15(input_0){
  return $apply_1(this, castTo(input_0, 34));
}
;
_.test_0 = function test_2(input_0){
  return this.apply_1(input_0);
}
;
_.equals_0 = function equals_30(object){
  var other;
  if (instanceOf(object, 484)) {
    other = castTo(object, 484);
    return $equals_1(this.lowerBound, other.lowerBound) && $equals_1(this.upperBound, other.upperBound);
  }
  return false;
}
;
_.hashCode_1 = function hashCode_26(){
  return hashCode__I__devirtual$(this.lowerBound) * 31 + hashCode__I__devirtual$(this.upperBound);
}
;
_.toString_0 = function toString_29(){
  return toString_30(this.lowerBound, this.upperBound);
}
;
var Lcom_google_common_collect_Range_2_classLit = createForClass('com.google.common.collect', 'Range', 484);
function RegularImmutableList(delegate){
  $clinit_ImmutableList();
  this.delegate = ($clinit_Collections() , instanceOf(delegate, 50)?new Collections$UnmodifiableRandomAccessList(delegate):new Collections$UnmodifiableList(delegate));
}

defineClass(506, 1759, $intern_29, RegularImmutableList);
_.delegateList = function delegateList(){
  return this.delegate;
}
;
var Lcom_google_common_collect_RegularImmutableList_2_classLit = createForClass('com.google.common.collect', 'RegularImmutableList', 506);
function $clinit_RegularImmutableSet(){
  $clinit_RegularImmutableSet = emptyMethod;
  $clinit_ImmutableCollection();
  EMPTY_0 = new RegularImmutableSet(($clinit_Collections() , $clinit_Collections() , EMPTY_SET));
}

function RegularImmutableSet(delegate){
  $clinit_RegularImmutableSet();
  ForwardingImmutableSet.call(this, delegate);
}

defineClass(582, 576, $intern_30, RegularImmutableSet);
var EMPTY_0;
var Lcom_google_common_collect_RegularImmutableSet_2_classLit = createForClass('com.google.common.collect', 'RegularImmutableSet', 582);
function RegularImmutableSortedSet(delegate){
  ForwardingImmutableSet.call(this, delegate);
  this.sortedDelegate = ($clinit_Collections() , new Collections$UnmodifiableSortedSet(delegate));
}

defineClass(763, 1706, $intern_32, RegularImmutableSortedSet);
var Lcom_google_common_collect_RegularImmutableSortedSet_2_classLit = createForClass('com.google.common.collect', 'RegularImmutableSortedSet', 763);
function equalsImpl_2(s, object){
  var o;
  if (s === object) {
    return true;
  }
  if (instanceOf(object, 19)) {
    o = castTo(object, 19);
    try {
      return s.size_1() == o.size_1() && s.containsAll(o);
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (instanceOf($e0, 172)) {
        return false;
      }
       else if (instanceOf($e0, 182)) {
        return false;
      }
       else 
        throw toJs($e0);
    }
  }
  return false;
}

function hashCodeImpl_0(s){
  var hashCode, o, o$iterator;
  hashCode = 0;
  for (o$iterator = s.iterator_0(); o$iterator.hasNext_0();) {
    o = o$iterator.next_1();
    hashCode += o != null?hashCode__I__devirtual$(o):0;
    hashCode = ~~hashCode;
  }
  return hashCode;
}

function newHashSet(elements){
  return instanceOf(elements, 13)?new HashSet_1(($clinit_Collections2() , castTo(elements, 13))):newHashSet_0(elements.iterator_0());
}

function newHashSet_0(elements){
  var set_0;
  set_0 = new HashSet;
  addAll_5(set_0, elements);
  return set_0;
}

function newHashSet_1(elements){
  var set_0;
  set_0 = new HashSet_0(capacity_0(elements.length));
  addAll_8(set_0, elements);
  return set_0;
}

function newLinkedHashSet(elements){
  var set_0;
  if (elements) {
    return new LinkedHashSet_1(($clinit_Collections2() , elements));
  }
  set_0 = new LinkedHashSet;
  addAll_4(set_0, null);
  return set_0;
}

function newTreeSet(elements){
  var set_0;
  set_0 = new TreeSet;
  addAll_4(set_0, elements);
  return set_0;
}

function unmodifiableNavigableSet(set_0){
  if (instanceOf(set_0, 569)) {
    return set_0;
  }
  return new Sets$UnmodifiableNavigableSet(set_0);
}

function Sets$UnmodifiableNavigableSet(delegate){
  this.delegate = castTo(checkNotNull(delegate), 200);
}

defineClass(569, 1748, {569:1, 3:1, 20:1, 13:1, 200:1, 19:1, 62:1}, Sets$UnmodifiableNavigableSet);
var Lcom_google_common_collect_Sets$UnmodifiableNavigableSet_2_classLit = createForClass('com.google.common.collect', 'Sets/UnmodifiableNavigableSet', 569);
function SingletonImmutableList(element){
  this.delegate = ($clinit_Collections() , new Collections$SingletonList(checkNotNull(element)));
}

defineClass(1255, 1759, $intern_29, SingletonImmutableList);
_.delegateList = function delegateList_0(){
  return this.delegate;
}
;
var Lcom_google_common_collect_SingletonImmutableList_2_classLit = createForClass('com.google.common.collect', 'SingletonImmutableList', 1255);
function SingletonImmutableSet(element){
  $clinit_ImmutableCollection();
  this.element = checkNotNull(element);
}

defineClass(337, 1755, $intern_30, SingletonImmutableSet);
_.iterator_0 = function iterator_37(){
  return $clinit_Iterators() , new Iterators$11(this.element);
}
;
_.contains = function contains_21(object){
  return equals_Ljava_lang_Object__Z__devirtual$(this.element, object);
}
;
_.iterator_1 = function iterator_36(){
  return $clinit_Iterators() , new Iterators$11(this.element);
}
;
_.size_1 = function size_27(){
  return 1;
}
;
var Lcom_google_common_collect_SingletonImmutableSet_2_classLit = createForClass('com.google.common.collect', 'SingletonImmutableSet', 337);
function TreeMultimap(keyComparator, valueComparator){
  AbstractSortedKeySortedSetMultimap.call(this, new TreeMap_0(keyComparator));
  this.keyComparator = keyComparator;
  this.valueComparator = valueComparator;
}

function create_0(keyComparator, valueComparator){
  return new TreeMultimap(castTo(checkNotNull(keyComparator), 59), castTo(checkNotNull(valueComparator), 59));
}

defineClass(1507, 1506, $intern_20, TreeMultimap);
_.asMap_0 = function asMap_5(){
  var result;
  return result = this.asMap , castTo(castTo(!result?(this.asMap = instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableAsMap(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedAsMap(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$AsMap(this, this.map_0)):result, 118), 124);
}
;
_.keySet_0 = function keySet_12(){
  var result;
  return result = this.keySet , castTo(castTo(!result?(this.keySet = instanceOf(this.map_0, 124)?new AbstractMapBasedMultimap$NavigableKeySet(this, castTo(this.map_0, 124)):instanceOf(this.map_0, 118)?new AbstractMapBasedMultimap$SortedKeySet(this, castTo(this.map_0, 118)):new AbstractMapBasedMultimap$KeySet(this, this.map_0)):result, 62), 200);
}
;
_.createCollection_0 = function createCollection_6(key){
  key == null && this.keyComparator.compare_0(null, null);
  return new TreeSet_0(this.valueComparator);
}
;
var Lcom_google_common_collect_TreeMultimap_2_classLit = createForClass('com.google.common.collect', 'TreeMultimap', 1507);
function $clinit_DoubleMath(){
  $clinit_DoubleMath = emptyMethod;
  $wnd.Math.log(2);
}

function fuzzyCompare(a, b){
  $clinit_DoubleMath();
  return checkNonNegative($intern_42) , $wnd.Math.abs(a - b) <= $intern_42 || a == b || isNaN(a) && isNaN(b)?0:a < b?-1:a > b?1:compare_1(isNaN(a), isNaN(b));
}

function fuzzyEquals(a, b){
  $clinit_DoubleMath();
  checkNonNegative($intern_42);
  return $wnd.Math.abs(a - b) <= $intern_42 || a == b || isNaN(a) && isNaN(b);
}

function checkNonNegative(x_0){
  if (x_0 < 0) {
    throw toJs(new IllegalArgumentException_0('tolerance (' + x_0 + ') must be >= 0'));
  }
  return x_0;
}

function compare_1(a, b){
  return a == b?0:a?1:-1;
}

function saturatedCast(value_0){
  if (compare_3(value_0, $intern_0) > 0) {
    return $intern_0;
  }
  if (compare_3(value_0, $intern_43) < 0) {
    return $intern_43;
  }
  return toInt_0(value_0);
}

function $$init_0(this$static){
  this$static.stackTrace = initUnidimensionalArray(Ljava_lang_StackTraceElement_2_classLit, $intern_33, 296, 0, 0, 1);
}

function $addSuppressed(this$static, exception){
  checkCriticalNotNull_0(exception, 'Cannot suppress a null exception.');
  checkCriticalArgument_0(exception != this$static, 'Exception can not suppress itself.');
  if (this$static.disableSuppression) {
    return;
  }
  this$static.suppressedExceptions == null?(this$static.suppressedExceptions = stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Throwable_2_classLit, 1), $intern_33, 79, 0, [exception])):(this$static.suppressedExceptions[this$static.suppressedExceptions.length] = exception);
}

function $fillInStackTrace(this$static){
  if (this$static.writetableStackTrace) {
    this$static.backingJsObject !== '__noinit__' && this$static.initializeBackingError();
    this$static.stackTrace = null;
  }
  return this$static;
}

function $printStackTraceImpl(this$static, out, ident){
  var t, t$array, t$index, t$max, theCause;
  $printStackTraceItems(this$static);
  for (t$array = (this$static.suppressedExceptions == null && (this$static.suppressedExceptions = initUnidimensionalArray(Ljava_lang_Throwable_2_classLit, $intern_33, 79, 0, 0, 1)) , this$static.suppressedExceptions) , t$index = 0 , t$max = t$array.length; t$index < t$max; ++t$index) {
    t = t$array[t$index];
    $printStackTraceImpl(t, out, '\t' + ident);
  }
  theCause = this$static.cause;
  !!theCause && $printStackTraceImpl(theCause, out, ident);
}

function $printStackTraceItems(this$static){
  var element$array, element$index, element$max, stackTrace;
  for (element$array = (this$static.stackTrace == null && (this$static.stackTrace = ($clinit_StackTraceCreator() , stackTrace = collector_1.getStackTrace(this$static) , dropInternalFrames(stackTrace))) , this$static.stackTrace) , element$index = 0 , element$max = element$array.length; element$index < element$max; ++element$index)
  ;
}

function $setBackingJsObject(this$static, backingJsObject){
  this$static.backingJsObject = backingJsObject;
  backingJsObject != null && setPropertySafe(backingJsObject, '__java$exception', this$static);
}

function $toString_3(this$static, message){
  var className;
  className = $getName(this$static.___clazz);
  return message == null?className:className + ': ' + message;
}

function Throwable(){
  $$init_0(this);
  $fillInStackTrace(this);
  this.initializeBackingError();
}

function Throwable_0(message){
  $$init_0(this);
  this.detailMessage = message;
  $fillInStackTrace(this);
  this.initializeBackingError();
}

function fixIE(e){
  if (!('stack' in e)) {
    try {
      throw e;
    }
     catch (ignored) {
    }
  }
  return e;
}

defineClass(79, 1, {3:1, 79:1});
_.createError = function createError(msg){
  return new $wnd.Error(msg);
}
;
_.getMessage = function getMessage(){
  return this.detailMessage;
}
;
_.initializeBackingError = function initializeBackingError(){
  var className, errorMessage, message;
  message = this.detailMessage == null?null:this.detailMessage.replace(new $wnd.RegExp('\n', 'g'), ' ');
  errorMessage = (className = $getName(this.___clazz) , message == null?className:className + ': ' + message);
  $setBackingJsObject(this, fixIE(this.createError(errorMessage)));
  captureStackTrace(this);
}
;
_.toString_0 = function toString_31(){
  return $toString_3(this, this.getMessage());
}
;
_.backingJsObject = '__noinit__';
_.disableSuppression = false;
_.writetableStackTrace = true;
var Ljava_lang_Throwable_2_classLit = createForClass('java.lang', 'Throwable', 79);
defineClass(102, 79, {3:1, 102:1, 79:1});
var Ljava_lang_Exception_2_classLit = createForClass('java.lang', 'Exception', 102);
function RuntimeException(){
  Throwable.call(this);
}

function RuntimeException_0(message){
  Throwable_0.call(this, message);
}

defineClass(54, 102, $intern_44, RuntimeException, RuntimeException_0);
var Ljava_lang_RuntimeException_2_classLit = createForClass('java.lang', 'RuntimeException', 54);
defineClass(564, 54, $intern_44);
var Ljava_lang_JsException_2_classLit = createForClass('java.lang', 'JsException', 564);
defineClass(792, 564, $intern_44);
var Lcom_google_gwt_core_client_impl_JavaScriptExceptionBase_2_classLit = createForClass('com.google.gwt.core.client.impl', 'JavaScriptExceptionBase', 792);
function $clinit_JavaScriptException(){
  $clinit_JavaScriptException = emptyMethod;
  NOT_SET = new Object_0;
}

function $ensureInit(this$static){
  var exception;
  if (this$static.message_0 == null) {
    exception = maskUndefined(this$static.e) === maskUndefined(NOT_SET)?null:this$static.e;
    this$static.name_0 = exception == null?'null':instanceOfJso(exception)?getExceptionName0(castToJso(exception)):instanceOfString(exception)?'String':$getName(getClass__Ljava_lang_Class___devirtual$(exception));
    this$static.description = this$static.description + ': ' + (instanceOfJso(exception)?getExceptionDescription0(castToJso(exception)):exception + '');
    this$static.message_0 = '(' + this$static.name_0 + ') ' + this$static.description;
  }
}

function JavaScriptException(e){
  $clinit_JavaScriptException();
  $$init_0(this);
  $fillInStackTrace(this);
  this.backingJsObject = e;
  e != null && setPropertySafe(e, '__java$exception', this);
  this.detailMessage = e == null?'null':toString_41(e);
  this.description = '';
  this.e = e;
  this.description = '';
}

function getExceptionDescription0(e){
  return e == null?null:e.message;
}

function getExceptionName0(e){
  return e == null?null:e.name;
}

defineClass(450, 792, {450:1, 3:1, 102:1, 54:1, 79:1}, JavaScriptException);
_.getMessage = function getMessage_0(){
  $ensureInit(this);
  return this.message_0;
}
;
_.getThrown = function getThrown(){
  return maskUndefined(this.e) === maskUndefined(NOT_SET)?null:this.e;
}
;
var NOT_SET;
var Lcom_google_gwt_core_client_JavaScriptException_2_classLit = createForClass('com.google.gwt.core.client', 'JavaScriptException', 450);
function $equals_3(this$static, other){
  return !!this$static && !!this$static.equals?this$static.equals(other):maskUndefined(this$static) === maskUndefined(other);
}

function $hashCode(this$static){
  return !!this$static && !!this$static.hashCode?this$static.hashCode():getHashCode_0(this$static);
}

var Lcom_google_gwt_core_client_JavaScriptObject_2_classLit = createForClass('com.google.gwt.core.client', 'JavaScriptObject$', 0);
function now_1(){
  if (Date.now) {
    return Date.now();
  }
  return (new Date).getTime();
}

function escapeChar(c, escapeTable){
  var lookedUp = escapeTable_0[c.charCodeAt(0)];
  return lookedUp == null?c:lookedUp;
}

function escapeValue(toEscape){
  var escapeTable = (!escapeTable_0 && (escapeTable_0 = initEscapeTable()) , escapeTable_0);
  var s = toEscape.replace(/[\x00-\x1f\xad\u0600-\u0603\u06dd\u070f\u17b4\u17b5\u200b-\u200f\u2028-\u202e\u2060-\u2064\u206a-\u206f\ufeff\ufff9-\ufffb"\\]/g, function(x_0){
    return escapeChar(x_0, escapeTable);
  }
  );
  return '"' + s + '"';
}

function initEscapeTable(){
  var out = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000B', '\\f', '\\r', '\\u000E', '\\u000F', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001A', '\\u001B', '\\u001C', '\\u001D', '\\u001E', '\\u001F'];
  out[34] = '\\"';
  out[92] = '\\\\';
  out[173] = '\\u00ad';
  out[1536] = '\\u0600';
  out[1537] = '\\u0601';
  out[1538] = '\\u0602';
  out[1539] = '\\u0603';
  out[1757] = '\\u06dd';
  out[1807] = '\\u070f';
  out[6068] = '\\u17b4';
  out[6069] = '\\u17b5';
  out[8203] = '\\u200b';
  out[8204] = '\\u200c';
  out[8205] = '\\u200d';
  out[8206] = '\\u200e';
  out[8207] = '\\u200f';
  out[8232] = '\\u2028';
  out[8233] = '\\u2029';
  out[8234] = '\\u202a';
  out[8235] = '\\u202b';
  out[8236] = '\\u202c';
  out[8237] = '\\u202d';
  out[8238] = '\\u202e';
  out[8288] = '\\u2060';
  out[8289] = '\\u2061';
  out[8290] = '\\u2062';
  out[8291] = '\\u2063';
  out[8292] = '\\u2064';
  out[8298] = '\\u206a';
  out[8299] = '\\u206b';
  out[8300] = '\\u206c';
  out[8301] = '\\u206d';
  out[8302] = '\\u206e';
  out[8303] = '\\u206f';
  out[65279] = '\\ufeff';
  out[65529] = '\\ufff9';
  out[65530] = '\\ufffa';
  out[65531] = '\\ufffb';
  return out;
}

var escapeTable_0;
defineClass(1725, 1, {});
var Lcom_google_gwt_core_client_Scheduler_2_classLit = createForClass('com.google.gwt.core.client', 'Scheduler', 1725);
function $clinit_Impl(){
  $clinit_Impl = emptyMethod;
  !!($clinit_StackTraceCreator() , collector_1);
}

function apply_16(jsFunction, thisObj, args){
  return jsFunction.apply(thisObj, args);
  var __0;
}

function enter_0(){
  var now_0;
  if (entryDepth != 0) {
    now_0 = now_1();
    if (now_0 - watchdogEntryDepthLastScheduled > 2000) {
      watchdogEntryDepthLastScheduled = now_0;
      watchdogEntryDepthTimerId = $wnd.setTimeout(watchdogEntryDepthRun, 10);
    }
  }
  if (entryDepth++ == 0) {
    $flushEntryCommands(($clinit_SchedulerImpl() , INSTANCE_3));
    return true;
  }
  return false;
}

function entry_0(jsFunction){
  $clinit_Impl();
  return function(){
    return entry0_0(jsFunction, this, arguments);
    var __0;
  }
  ;
}

function entry0_0(jsFunction, thisObj, args){
  var initialEntry;
  initialEntry = enter_0();
  try {
    return apply_16(jsFunction, thisObj, args);
  }
   finally {
    exit(initialEntry);
  }
}

function exit(initialEntry){
  initialEntry && $flushFinallyCommands(($clinit_SchedulerImpl() , INSTANCE_3));
  --entryDepth;
  if (initialEntry) {
    if (watchdogEntryDepthTimerId != -1) {
      watchdogEntryDepthCancel(watchdogEntryDepthTimerId);
      watchdogEntryDepthTimerId = -1;
    }
  }
}

function reportToBrowser(e){
  $clinit_Impl();
  $wnd.setTimeout(function(){
    throw e;
  }
  , 0);
}

function watchdogEntryDepthCancel(timerId){
  $wnd.clearTimeout(timerId);
}

function watchdogEntryDepthRun(){
  entryDepth != 0 && (entryDepth = 0);
  watchdogEntryDepthTimerId = -1;
}

var entryDepth = 0, watchdogEntryDepthLastScheduled = 0, watchdogEntryDepthTimerId = -1;
function $clinit_SchedulerImpl(){
  $clinit_SchedulerImpl = emptyMethod;
  INSTANCE_3 = new SchedulerImpl;
}

function $flushEntryCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.entryCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.entryCommands;
      this$static.entryCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.entryCommands);
    this$static.entryCommands = rescheduled;
  }
}

function $flushFinallyCommands(this$static){
  var oldQueue, rescheduled;
  if (this$static.finallyCommands) {
    rescheduled = null;
    do {
      oldQueue = this$static.finallyCommands;
      this$static.finallyCommands = null;
      rescheduled = runScheduledTasks(oldQueue, rescheduled);
    }
     while (this$static.finallyCommands);
    this$static.finallyCommands = rescheduled;
  }
}

function SchedulerImpl(){
}

function push_0(queue, task){
  !queue && (queue = []);
  queue[queue.length] = task;
  return queue;
}

function runScheduledTasks(tasks, rescheduled){
  var e, i, j, t;
  for (i = 0 , j = tasks.length; i < j; i++) {
    t = tasks[i];
    try {
      t[1]?t[0].$_nullMethod() && (rescheduled = push_0(rescheduled, t)):t[0].$_nullMethod();
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (instanceOf($e0, 79)) {
        e = $e0;
        $clinit_Impl();
        reportToBrowser(instanceOf(e, 450)?castTo(e, 450).getThrown():e);
      }
       else 
        throw toJs($e0);
    }
  }
  return rescheduled;
}

defineClass(819, 1725, {}, SchedulerImpl);
var INSTANCE_3;
var Lcom_google_gwt_core_client_impl_SchedulerImpl_2_classLit = createForClass('com.google.gwt.core.client.impl', 'SchedulerImpl', 819);
function $clinit_StackTraceCreator(){
  $clinit_StackTraceCreator = emptyMethod;
  var c, enforceLegacy;
  enforceLegacy = !supportsErrorStack();
  c = new StackTraceCreator$CollectorModernNoSourceMap;
  collector_1 = enforceLegacy?new StackTraceCreator$CollectorLegacy:c;
}

function captureStackTrace(error){
  $clinit_StackTraceCreator();
  collector_1.collect(error);
}

function dropInternalFrames(stackTrace){
  var dropFrameUntilFnName, dropFrameUntilFnName2, i, numberOfFramesToSearch;
  dropFrameUntilFnName = 'captureStackTrace';
  dropFrameUntilFnName2 = 'initializeBackingError';
  numberOfFramesToSearch = min_1(stackTrace.length, 5);
  for (i = numberOfFramesToSearch - 1; i >= 0; i--) {
    if ($equals_4(stackTrace[i].methodName, dropFrameUntilFnName) || $equals_4(stackTrace[i].methodName, dropFrameUntilFnName2)) {
      stackTrace.length >= i + 1 && (stackTrace.splice(0, i + 1) , undefined);
      break;
    }
  }
  return stackTrace;
}

function extractFunctionName(fnName){
  var fnRE = /function(?:\s+([\w$]+))?\s*\(/;
  var match_0 = fnRE.exec(fnName);
  return match_0 && match_0[1] || 'anonymous';
}

function parseInt_0(number){
  $clinit_StackTraceCreator();
  return parseInt(number) || -1;
}

function supportsErrorStack(){
  if (Error.stackTraceLimit > 0) {
    $wnd.Error.stackTraceLimit = Error.stackTraceLimit = 64;
    return true;
  }
  return 'stack' in new Error;
}

var collector_1;
defineClass(1737, 1, {});
var Lcom_google_gwt_core_client_impl_StackTraceCreator$Collector_2_classLit = createForClass('com.google.gwt.core.client.impl', 'StackTraceCreator/Collector', 1737);
function StackTraceCreator$CollectorLegacy(){
}

defineClass(793, 1737, {}, StackTraceCreator$CollectorLegacy);
_.collect = function collect(error){
  var seen = {}, name_1;
  var fnStack = [];
  error['fnStack'] = fnStack;
  var callee = arguments.callee.caller;
  while (callee) {
    var name_0 = ($clinit_StackTraceCreator() , callee.name || (callee.name = extractFunctionName(callee.toString())));
    fnStack.push(name_0);
    var keyName = ':' + name_0;
    var withThisName = seen[keyName];
    if (withThisName) {
      var i, j;
      for (i = 0 , j = withThisName.length; i < j; i++) {
        if (withThisName[i] === callee) {
          return;
        }
      }
    }
    (withThisName || (seen[keyName] = [])).push(callee);
    callee = callee.caller;
  }
}
;
_.getStackTrace = function getStackTrace(t){
  var i, length_0, stack_0, stackTrace;
  stack_0 = ($clinit_StackTraceCreator() , t && t['fnStack']?t['fnStack']:[]);
  length_0 = stack_0.length;
  stackTrace = initUnidimensionalArray(Ljava_lang_StackTraceElement_2_classLit, $intern_33, 296, length_0, 0, 1);
  for (i = 0; i < length_0; i++) {
    stackTrace[i] = new StackTraceElement(stack_0[i], null, -1);
  }
  return stackTrace;
}
;
var Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorLegacy_2_classLit = createForClass('com.google.gwt.core.client.impl', 'StackTraceCreator/CollectorLegacy', 793);
function $parse(this$static, stString){
  var closeParen, col, endFileUrlIndex, fileName, index_0, lastColonIndex, line, location_0, toReturn;
  if (stString.length == 0) {
    return this$static.createSte('Unknown', 'anonymous', -1, -1);
  }
  toReturn = $trim(stString);
  $equals_4(toReturn.substr(0, 3), 'at ') && (toReturn = toReturn.substr(3, toReturn.length - 3));
  toReturn = toReturn.replace(/\[.*?\]/g, '');
  index_0 = toReturn.indexOf('(');
  if (index_0 == -1) {
    index_0 = toReturn.indexOf('@');
    if (index_0 == -1) {
      location_0 = toReturn;
      toReturn = '';
    }
     else {
      location_0 = $trim(toReturn.substr(index_0 + 1, toReturn.length - (index_0 + 1)));
      toReturn = $trim(toReturn.substr(0, index_0));
    }
  }
   else {
    closeParen = toReturn.indexOf(')', index_0);
    location_0 = toReturn.substr(index_0 + 1, closeParen - (index_0 + 1));
    toReturn = $trim(toReturn.substr(0, index_0));
  }
  index_0 = $indexOf_1(toReturn, fromCodePoint(46));
  index_0 != -1 && (toReturn = toReturn.substr(index_0 + 1, toReturn.length - (index_0 + 1)));
  (toReturn.length == 0 || $equals_4(toReturn, 'Anonymous function')) && (toReturn = 'anonymous');
  lastColonIndex = $lastIndexOf(location_0, fromCodePoint(58));
  endFileUrlIndex = $lastIndexOf_0(location_0, fromCodePoint(58), lastColonIndex - 1);
  line = -1;
  col = -1;
  fileName = 'Unknown';
  if (lastColonIndex != -1 && endFileUrlIndex != -1) {
    fileName = location_0.substr(0, endFileUrlIndex);
    line = parseInt_0(location_0.substr(endFileUrlIndex + 1, lastColonIndex - (endFileUrlIndex + 1)));
    col = parseInt_0(location_0.substr(lastColonIndex + 1, location_0.length - (lastColonIndex + 1)));
  }
  return this$static.createSte(fileName, toReturn, line, col);
}

defineClass(1738, 1737, {});
_.collect = function collect_0(error){
}
;
_.createSte = function createSte(fileName, method, line, col){
  return new StackTraceElement(method, fileName + '@' + col, line < 0?-1:line);
}
;
_.getStackTrace = function getStackTrace_0(t){
  var addIndex, i, length_0, stack_0, stackTrace, ste, e;
  stack_0 = ($clinit_StackTraceCreator() , e = t.backingJsObject , e && e.stack?e.stack.split('\n'):[]);
  stackTrace = initUnidimensionalArray(Ljava_lang_StackTraceElement_2_classLit, $intern_33, 296, 0, 0, 1);
  addIndex = 0;
  length_0 = stack_0.length;
  if (length_0 == 0) {
    return stackTrace;
  }
  ste = $parse(this, stack_0[0]);
  $equals_4(ste.methodName, 'anonymous') || (stackTrace[addIndex++] = ste);
  for (i = 1; i < length_0; i++) {
    stackTrace[addIndex++] = $parse(this, stack_0[i]);
  }
  return stackTrace;
}
;
var Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorModern_2_classLit = createForClass('com.google.gwt.core.client.impl', 'StackTraceCreator/CollectorModern', 1738);
function StackTraceCreator$CollectorModernNoSourceMap(){
}

defineClass(794, 1738, {}, StackTraceCreator$CollectorModernNoSourceMap);
_.createSte = function createSte_0(fileName, method, line, col){
  return new StackTraceElement(method, fileName, -1);
}
;
var Lcom_google_gwt_core_client_impl_StackTraceCreator$CollectorModernNoSourceMap_2_classLit = createForClass('com.google.gwt.core.client.impl', 'StackTraceCreator/CollectorModernNoSourceMap', 794);
function $clinit_DateTimeFormat(){
  $clinit_DateTimeFormat = emptyMethod;
  new HashMap;
}

function $addPart(this$static, buf, count){
  var oldLength;
  if (buf.string.length > 0) {
    $add_4(this$static.patternParts, new DateTimeFormat$PatternPart(buf.string, count));
    oldLength = buf.string.length;
    0 < oldLength?(buf.string = buf.string.substr(0, 0)):0 > oldLength && (buf.string += valueOf_8(initUnidimensionalArray(C_classLit, $intern_45, 23, -oldLength, 15, 1)));
  }
}

function $format(this$static, date, timeZone){
  var ch_0, diff, i, j, keepDate, keepTime, n, toAppendTo, trailQuote;
  !timeZone && (timeZone = createTimeZone(date.jsdate.getTimezoneOffset()));
  diff = (date.jsdate.getTimezoneOffset() - timeZone.standardOffset) * 60000;
  keepDate = new Date_2(add_20(fromDouble_0(date.jsdate.getTime()), diff));
  keepTime = keepDate;
  if (keepDate.jsdate.getTimezoneOffset() != date.jsdate.getTimezoneOffset()) {
    diff > 0?(diff -= 86400000):(diff += 86400000);
    keepTime = new Date_2(add_20(fromDouble_0(date.jsdate.getTime()), diff));
  }
  toAppendTo = new StringBuilder_0;
  n = this$static.pattern.length;
  for (i = 0; i < n;) {
    ch_0 = $charAt(this$static.pattern, i);
    if (ch_0 >= 97 && ch_0 <= 122 || ch_0 >= 65 && ch_0 <= 90) {
      for (j = i + 1; j < n && $charAt(this$static.pattern, j) == ch_0; ++j)
      ;
      $subFormat(toAppendTo, ch_0, j - i, keepDate, keepTime, timeZone);
      i = j;
    }
     else if (ch_0 == 39) {
      ++i;
      if (i < n && $charAt(this$static.pattern, i) == 39) {
        toAppendTo.string += "'";
        ++i;
        continue;
      }
      trailQuote = false;
      while (!trailQuote) {
        j = i;
        while (j < n && $charAt(this$static.pattern, j) != 39) {
          ++j;
        }
        if (j >= n) {
          throw toJs(new IllegalArgumentException_0("Missing trailing '"));
        }
        j + 1 < n && $charAt(this$static.pattern, j + 1) == 39?++j:(trailQuote = true);
        $append_11(toAppendTo, $substring_1(this$static.pattern, i, j));
        i = j + 1;
      }
    }
     else {
      toAppendTo.string += String.fromCharCode(ch_0);
      ++i;
    }
  }
  return toAppendTo.string;
}

function $formatFractionalSeconds(buf, count, date){
  var time, value_0;
  time = fromDouble_0(date.jsdate.getTime());
  if (compare_3(time, 0) < 0) {
    value_0 = $intern_46 - toInt_0(mod(neg_0(time), $intern_46));
    value_0 == $intern_46 && (value_0 = 0);
  }
   else {
    value_0 = toInt_0(mod(time, $intern_46));
  }
  if (count == 1) {
    value_0 = ((value_0 + 50) / 100 | 0) < 9?(value_0 + 50) / 100 | 0:9;
    $append_5(buf, 48 + value_0 & $intern_47);
  }
   else if (count == 2) {
    value_0 = ((value_0 + 5) / 10 | 0) < 99?(value_0 + 5) / 10 | 0:99;
    $zeroPaddingNumber(buf, value_0, 2);
  }
   else {
    $zeroPaddingNumber(buf, value_0, 3);
    count > 3 && $zeroPaddingNumber(buf, 0, count - 3);
  }
}

function $formatMonth(buf, count, date){
  var value_0;
  value_0 = date.jsdate.getMonth();
  switch (count) {
    case 5:
      $append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'])[value_0]);
      break;
    case 4:
      $append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'])[value_0]);
      break;
    case 3:
      $append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])[value_0]);
      break;
    default:$zeroPaddingNumber(buf, value_0 + 1, count);
  }
}

function $formatYear(buf, count, date){
  var value_0;
  value_0 = date.jsdate.getFullYear() - $intern_48 + $intern_48;
  value_0 < 0 && (value_0 = -value_0);
  switch (count) {
    case 1:
      buf.string += value_0;
      break;
    case 2:
      $zeroPaddingNumber(buf, value_0 % 100, 2);
      break;
    default:$zeroPaddingNumber(buf, value_0, count);
  }
}

function $getNextCharCountInPattern(pattern, start_0){
  var ch_0, next;
  ch_0 = pattern.charCodeAt(start_0);
  next = start_0 + 1;
  while (next < pattern.length && pattern.charCodeAt(next) == ch_0) {
    ++next;
  }
  return next - start_0;
}

function $identifyAbutStart(this$static){
  var abut, i, len;
  abut = false;
  len = this$static.patternParts.array.length;
  for (i = 0; i < len; i++) {
    if ($isNumeric(castTo($get_7(this$static.patternParts, i), 412))) {
      if (!abut && i + 1 < len && $isNumeric(castTo($get_7(this$static.patternParts, i + 1), 412))) {
        abut = true;
        castTo($get_7(this$static.patternParts, i), 412).abutStart = true;
      }
    }
     else {
      abut = false;
    }
  }
}

function $isNumeric(part){
  var i;
  if (part.count <= 0) {
    return false;
  }
  i = $indexOf_1('MLydhHmsSDkK', fromCodePoint(part.text_0.charCodeAt(0)));
  return i > 1 || i >= 0 && part.count < 3;
}

function $matchString(text_0, start_0, data_0, pos){
  var bestMatch, bestMatchLength, count, i, length_0, textInLowerCase;
  count = data_0.length;
  bestMatchLength = 0;
  bestMatch = -1;
  textInLowerCase = $toLowerCase(text_0.substr(start_0, text_0.length - start_0), ($clinit_Locale() , ROOT));
  for (i = 0; i < count; ++i) {
    length_0 = data_0[i].length;
    if (length_0 > bestMatchLength && $startsWith(textInLowerCase, $toLowerCase(data_0[i], ROOT))) {
      bestMatch = i;
      bestMatchLength = length_0;
    }
  }
  bestMatch >= 0 && (pos[0] = start_0 + bestMatchLength);
  return bestMatch;
}

function $parse_0(this$static, text_0, date){
  var abutPass, abutPat, abutStart, cal, count, i, parsePos, part, s;
  cal = new DateRecord;
  parsePos = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [0]);
  abutPat = -1;
  abutStart = 0;
  abutPass = 0;
  for (i = 0; i < this$static.patternParts.array.length; ++i) {
    part = castTo($get_7(this$static.patternParts, i), 412);
    if (part.count > 0) {
      if (abutPat < 0 && part.abutStart) {
        abutPat = i;
        abutStart = parsePos[0];
        abutPass = 0;
      }
      if (abutPat >= 0) {
        count = part.count;
        if (i == abutPat) {
          count -= abutPass++;
          if (count == 0) {
            return 0;
          }
        }
        if (!$subParse(text_0, parsePos, part, count, cal)) {
          i = abutPat - 1;
          parsePos[0] = abutStart;
          continue;
        }
      }
       else {
        abutPat = -1;
        if (!$subParse(text_0, parsePos, part, 0, cal)) {
          return 0;
        }
      }
    }
     else {
      abutPat = -1;
      if (part.text_0.charCodeAt(0) == 32) {
        s = parsePos[0];
        $skipSpace(text_0, parsePos);
        if (parsePos[0] > s) {
          continue;
        }
      }
       else if ($startsWith_0(text_0, part.text_0, parsePos[0])) {
        parsePos[0] += part.text_0.length;
        continue;
      }
      return 0;
    }
  }
  if (!$calcDate(cal, date)) {
    return 0;
  }
  return parsePos[0];
}

function $parse_1(this$static, text_0){
  var charsConsumed, curDate, date;
  curDate = new Date_0;
  date = new Date_1(curDate.jsdate.getFullYear() - $intern_48, curDate.jsdate.getMonth(), curDate.jsdate.getDate());
  charsConsumed = $parse_0(this$static, text_0, date);
  if (charsConsumed == 0 || charsConsumed < text_0.length) {
    throw toJs(new IllegalArgumentException_0(text_0));
  }
  return date;
}

function $parseInt(text_0, pos){
  var ch_0, ind, ret;
  ret = 0;
  ind = pos[0];
  if (ind >= text_0.length) {
    return -1;
  }
  ch_0 = text_0.charCodeAt(ind);
  while (ch_0 >= 48 && ch_0 <= 57) {
    ret = ret * 10 + (ch_0 - 48);
    ++ind;
    if (ind >= text_0.length) {
      break;
    }
    ch_0 = text_0.charCodeAt(ind);
  }
  ind > pos[0]?(pos[0] = ind):(ret = -1);
  return ret;
}

function $parsePattern(this$static, pattern){
  var buf, ch_0, count, i, inQuote;
  buf = new StringBuilder_0;
  inQuote = false;
  for (i = 0; i < pattern.length; i++) {
    ch_0 = pattern.charCodeAt(i);
    if (ch_0 == 32) {
      $addPart(this$static, buf, 0);
      buf.string += ' ';
      $addPart(this$static, buf, 0);
      while (i + 1 < pattern.length && pattern.charCodeAt(i + 1) == 32) {
        ++i;
      }
      continue;
    }
    if (inQuote) {
      if (ch_0 == 39) {
        if (i + 1 < pattern.length && pattern.charCodeAt(i + 1) == 39) {
          buf.string += "'";
          ++i;
        }
         else {
          inQuote = false;
        }
      }
       else {
        buf.string += String.fromCharCode(ch_0);
      }
      continue;
    }
    if ($indexOf_1('GyMLdkHmsSEcDahKzZv', fromCodePoint(ch_0)) > 0) {
      $addPart(this$static, buf, 0);
      buf.string += String.fromCharCode(ch_0);
      count = $getNextCharCountInPattern(pattern, i);
      $addPart(this$static, buf, count);
      i += count - 1;
      continue;
    }
    if (ch_0 == 39) {
      if (i + 1 < pattern.length && pattern.charCodeAt(i + 1) == 39) {
        buf.string += "'";
        ++i;
      }
       else {
        inQuote = true;
      }
    }
     else {
      buf.string += String.fromCharCode(ch_0);
    }
  }
  $addPart(this$static, buf, 0);
  $identifyAbutStart(this$static);
}

function $parseTimeZoneOffset(text_0, pos, cal){
  var offset, sign, st, value_0;
  if (pos[0] >= text_0.length) {
    cal.tzOffset = 0;
    return true;
  }
  switch (text_0.charCodeAt(pos[0])) {
    case 43:
      sign = 1;
      break;
    case 45:
      sign = -1;
      break;
    default:cal.tzOffset = 0;
      return true;
  }
  ++pos[0];
  st = pos[0];
  value_0 = $parseInt(text_0, pos);
  if (value_0 == 0 && pos[0] == st) {
    return false;
  }
  if (pos[0] < text_0.length && text_0.charCodeAt(pos[0]) == 58) {
    offset = value_0 * 60;
    ++pos[0];
    st = pos[0];
    value_0 = $parseInt(text_0, pos);
    if (value_0 == 0 && pos[0] == st) {
      return false;
    }
    offset += value_0;
  }
   else {
    offset = value_0;
    value_0 < 24 && pos[0] - st <= 2?(offset *= 60):(offset = value_0 % 100 + (value_0 / 100 | 0) * 60);
  }
  offset *= sign;
  cal.tzOffset = -offset;
  return true;
}

function $skipSpace(text_0, pos){
  while (pos[0] < text_0.length && $indexOf_1(' \t\r\n', fromCodePoint(text_0.charCodeAt(pos[0]))) >= 0) {
    ++pos[0];
  }
}

function $subFormat(buf, ch_0, count, adjustedDate, adjustedTime, timezone){
  var value_0, value0, value1, value10, value2, value3, value4, value5, value6, value7, value8, value9;
  switch (ch_0) {
    case 71:
      value0 = adjustedDate.jsdate.getFullYear() - $intern_48 >= -1900?1:0;
      count >= 4?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Before Christ', 'Anno Domini'])[value0]):$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['BC', 'AD'])[value0]);
      break;
    case 121:
      $formatYear(buf, count, adjustedDate);
      break;
    case 77:
      $formatMonth(buf, count, adjustedDate);
      break;
    case 107:
      value1 = adjustedTime.jsdate.getHours();
      value1 == 0?$zeroPaddingNumber(buf, 24, count):$zeroPaddingNumber(buf, value1, count);
      break;
    case 83:
      $formatFractionalSeconds(buf, count, adjustedTime);
      break;
    case 69:
      value2 = adjustedDate.jsdate.getDay();
      count == 5?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['S', 'M', 'T', 'W', 'T', 'F', 'S'])[value2]):count == 4?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'])[value2]):$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'])[value2]);
      break;
    case 97:
      adjustedTime.jsdate.getHours() >= 12 && adjustedTime.jsdate.getHours() < 24?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['AM', 'PM'])[1]):$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['AM', 'PM'])[0]);
      break;
    case 104:
      value3 = adjustedTime.jsdate.getHours() % 12;
      value3 == 0?$zeroPaddingNumber(buf, 12, count):$zeroPaddingNumber(buf, value3, count);
      break;
    case 75:
      value4 = adjustedTime.jsdate.getHours() % 12;
      $zeroPaddingNumber(buf, value4, count);
      break;
    case 72:
      value5 = adjustedTime.jsdate.getHours();
      $zeroPaddingNumber(buf, value5, count);
      break;
    case 99:
      value6 = adjustedDate.jsdate.getDay();
      count == 5?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['S', 'M', 'T', 'W', 'T', 'F', 'S'])[value6]):count == 4?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'])[value6]):count == 3?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'])[value6]):$zeroPaddingNumber(buf, value6, 1);
      break;
    case 76:
      value7 = adjustedDate.jsdate.getMonth();
      count == 5?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'])[value7]):count == 4?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'])[value7]):count == 3?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'])[value7]):$zeroPaddingNumber(buf, value7 + 1, count);
      break;
    case 81:
      value8 = adjustedDate.jsdate.getMonth() / 3 | 0;
      count < 4?$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Q1', 'Q2', 'Q3', 'Q4'])[value8]):$append_11(buf, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'])[value8]);
      break;
    case 100:
      value9 = adjustedDate.jsdate.getDate();
      $zeroPaddingNumber(buf, value9, count);
      break;
    case 109:
      value10 = adjustedTime.jsdate.getMinutes();
      $zeroPaddingNumber(buf, value10, count);
      break;
    case 115:
      value_0 = adjustedTime.jsdate.getSeconds();
      $zeroPaddingNumber(buf, value_0, count);
      break;
    case 122:
      count < 4?$append_11(buf, timezone.tzNames[0]):$append_11(buf, timezone.tzNames[1]);
      break;
    case 118:
      $append_11(buf, timezone.timezoneID);
      break;
    case 90:
      count < 3?$append_11(buf, $getRFCTimeZoneString(timezone)):count == 3?$append_11(buf, $getISOTimeZoneString(timezone)):$append_11(buf, composeGMTString(timezone.standardOffset));
      break;
    default:return false;
  }
  return true;
}

function $subParse(text_0, pos, part, digitCount, cal){
  var ch_0, start_0, value_0;
  $skipSpace(text_0, pos);
  start_0 = pos[0];
  ch_0 = part.text_0.charCodeAt(0);
  value_0 = -1;
  if ($isNumeric(part)) {
    if (digitCount > 0) {
      if (start_0 + digitCount > text_0.length) {
        return false;
      }
      value_0 = $parseInt(text_0.substr(0, start_0 + digitCount), pos);
    }
     else {
      value_0 = $parseInt(text_0, pos);
    }
  }
  switch (ch_0) {
    case 71:
      value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Before Christ', 'Anno Domini']), pos);
      cal.era = value_0;
      return true;
    case 77:
      return $subParseMonth(text_0, pos, cal, value_0, start_0);
    case 76:
      return $subParseStandaloneMonth(text_0, pos, cal, value_0, start_0);
    case 69:
      return $subParseDayOfWeek(text_0, pos, start_0, cal);
    case 99:
      return $subParseStandaloneDay(text_0, pos, start_0, cal);
    case 97:
      value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['AM', 'PM']), pos);
      cal.ampm = value_0;
      return true;
    case 121:
      return $subParseYear(text_0, pos, start_0, value_0, part, cal);
    case 100:
      if (value_0 <= 0) {
        return false;
      }

      cal.dayOfMonth = value_0;
      return true;
    case 83:
      if (value_0 < 0) {
        return false;
      }

      return $subParseFractionalSeconds(value_0, start_0, pos[0], cal);
    case 104:
      value_0 == 12 && (value_0 = 0);
    case 75:
    case 72:
      if (value_0 < 0) {
        return false;
      }

      cal.hours = value_0;
      cal.midnightIs24 = false;
      return true;
    case 107:
      if (value_0 < 0) {
        return false;
      }

      cal.hours = value_0;
      cal.midnightIs24 = true;
      return true;
    case 109:
      if (value_0 < 0) {
        return false;
      }

      cal.minutes = value_0;
      return true;
    case 115:
      if (value_0 < 0) {
        return false;
      }

      cal.seconds = value_0;
      return true;
    case 90:
      if (start_0 < text_0.length && text_0.charCodeAt(start_0) == 90) {
        ++pos[0];
        cal.tzOffset = 0;
        return true;
      }

    case 122:
    case 118:
      return $subParseTimeZoneInGMT(text_0, start_0, pos, cal);
    default:return false;
  }
}

function $subParseDayOfWeek(text_0, pos, start_0, cal){
  var value_0;
  value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']), pos);
  value_0 < 0 && (value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']), pos));
  if (value_0 < 0) {
    return false;
  }
  cal.dayOfWeek = value_0;
  return true;
}

function $subParseFractionalSeconds(value_0, start_0, end, cal){
  var a, i;
  i = end - start_0;
  if (i < 3) {
    while (i < 3) {
      value_0 *= 10;
      ++i;
    }
  }
   else {
    a = 1;
    while (i > 3) {
      a *= 10;
      --i;
    }
    value_0 = (value_0 + (a >> 1)) / a | 0;
  }
  cal.milliseconds = value_0;
  return true;
}

function $subParseMonth(text_0, pos, cal, value_0, start_0){
  if (value_0 < 0) {
    value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']), pos);
    value_0 < 0 && (value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']), pos));
    if (value_0 < 0) {
      return false;
    }
    cal.month = value_0;
    return true;
  }
   else if (value_0 > 0) {
    cal.month = value_0 - 1;
    return true;
  }
  return false;
}

function $subParseStandaloneDay(text_0, pos, start_0, cal){
  var value_0;
  value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']), pos);
  value_0 < 0 && (value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']), pos));
  if (value_0 < 0) {
    return false;
  }
  cal.dayOfWeek = value_0;
  return true;
}

function $subParseStandaloneMonth(text_0, pos, cal, value_0, start_0){
  if (value_0 < 0) {
    value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']), pos);
    value_0 < 0 && (value_0 = $matchString(text_0, start_0, stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']), pos));
    if (value_0 < 0) {
      return false;
    }
    cal.month = value_0;
    return true;
  }
   else if (value_0 > 0) {
    cal.month = value_0 - 1;
    return true;
  }
  return false;
}

function $subParseTimeZoneInGMT(text_0, start_0, pos, cal){
  if (start_0 >= 0 && $equals_4(text_0.substr(start_0, 'GMT'.length), 'GMT')) {
    pos[0] = start_0 + 3;
    return $parseTimeZoneOffset(text_0, pos, cal);
  }
  if (start_0 >= 0 && $equals_4(text_0.substr(start_0, 'UTC'.length), 'UTC')) {
    pos[0] = start_0 + 3;
    return $parseTimeZoneOffset(text_0, pos, cal);
  }
  return $parseTimeZoneOffset(text_0, pos, cal);
}

function $subParseYear(text_0, pos, start_0, value_0, part, cal){
  var ambiguousTwoDigitYear, ch_0, date, defaultCenturyStartYear;
  ch_0 = 32;
  if (value_0 < 0) {
    if (pos[0] >= text_0.length) {
      return false;
    }
    ch_0 = text_0.charCodeAt(pos[0]);
    if (ch_0 != 43 && ch_0 != 45) {
      return false;
    }
    ++pos[0];
    value_0 = $parseInt(text_0, pos);
    if (value_0 < 0) {
      return false;
    }
    ch_0 == 45 && (value_0 = -value_0);
  }
  if (ch_0 == 32 && pos[0] - start_0 == 2 && part.count == 2) {
    date = new Date_0;
    defaultCenturyStartYear = date.jsdate.getFullYear() - $intern_48 + $intern_48 - 80;
    ambiguousTwoDigitYear = defaultCenturyStartYear % 100;
    cal.ambiguousYear = value_0 == ambiguousTwoDigitYear;
    value_0 += (defaultCenturyStartYear / 100 | 0) * 100 + (value_0 < ambiguousTwoDigitYear?100:0);
  }
  cal.year = value_0;
  return true;
}

function $zeroPaddingNumber(buf, value_0, minWidth){
  var b, i;
  b = 10;
  for (i = 0; i < minWidth - 1; i++) {
    value_0 < b && (buf.string += '0' , buf);
    b *= 10;
  }
  buf.string += value_0;
}

defineClass(990, 1, {});
var Lcom_google_gwt_i18n_shared_DateTimeFormat_2_classLit = createForClass('com.google.gwt.i18n.shared', 'DateTimeFormat', 990);
function $clinit_DateTimeFormat_0(){
  $clinit_DateTimeFormat_0 = emptyMethod;
  $clinit_DateTimeFormat();
  cache = new HashMap;
}

function DateTimeFormat(pattern){
  $clinit_DateTimeFormat();
  this.patternParts = new ArrayList;
  this.pattern = pattern;
  $parsePattern(this, pattern);
}

function getFormat(pattern, dtfi){
  $clinit_DateTimeFormat_0();
  var defaultDtfi, dtf;
  defaultDtfi = $getDateTimeFormatInfo(($clinit_LocaleInfo() , $clinit_LocaleInfo() , instance_0));
  dtf = null;
  dtfi == defaultDtfi && (dtf = castTo($getStringValue(cache, pattern), 584));
  if (!dtf) {
    dtf = new DateTimeFormat(pattern);
    dtfi == defaultDtfi && $putStringValue(cache, pattern, dtf);
  }
  return dtf;
}

defineClass(584, 990, {584:1}, DateTimeFormat);
var cache;
var Lcom_google_gwt_i18n_client_DateTimeFormat_2_classLit = createForClass('com.google.gwt.i18n.client', 'DateTimeFormat', 584);
defineClass(1777, 1, {});
var Lcom_google_gwt_i18n_shared_DefaultDateTimeFormatInfo_2_classLit = createForClass('com.google.gwt.i18n.shared', 'DefaultDateTimeFormatInfo', 1777);
defineClass(1778, 1777, {});
var Lcom_google_gwt_i18n_client_DefaultDateTimeFormatInfo_2_classLit = createForClass('com.google.gwt.i18n.client', 'DefaultDateTimeFormatInfo', 1778);
function $clinit_LocaleInfo(){
  $clinit_LocaleInfo = emptyMethod;
  instance_0 = new LocaleInfo;
}

function $getDateTimeFormatInfo(this$static){
  !this$static.dateTimeFormatInfo && (this$static.dateTimeFormatInfo = new DateTimeFormatInfoImpl);
  return this$static.dateTimeFormatInfo;
}

function LocaleInfo(){
}

defineClass(1005, 1, {}, LocaleInfo);
var instance_0;
var Lcom_google_gwt_i18n_client_LocaleInfo_2_classLit = createForClass('com.google.gwt.i18n.client', 'LocaleInfo', 1005);
function $getISOTimeZoneString(this$static){
  var data_0, offset;
  offset = -this$static.standardOffset;
  data_0 = stampJavaTypeInfo(getClassLiteralForArray(C_classLit, 1), $intern_45, 23, 15, [43, 48, 48, 58, 48, 48]);
  if (offset < 0) {
    data_0[0] = 45;
    offset = -offset;
  }
  data_0[1] = data_0[1] + ((offset / 60 | 0) / 10 | 0) & $intern_47;
  data_0[2] = data_0[2] + (offset / 60 | 0) % 10 & $intern_47;
  data_0[4] = data_0[4] + (offset % 60 / 10 | 0) & $intern_47;
  data_0[5] = data_0[5] + offset % 10 & $intern_47;
  return valueOf_9(data_0, 0, data_0.length);
}

function $getRFCTimeZoneString(this$static){
  var data_0, offset;
  offset = -this$static.standardOffset;
  data_0 = stampJavaTypeInfo(getClassLiteralForArray(C_classLit, 1), $intern_45, 23, 15, [43, 48, 48, 48, 48]);
  if (offset < 0) {
    data_0[0] = 45;
    offset = -offset;
  }
  data_0[1] = data_0[1] + ((offset / 60 | 0) / 10 | 0) & $intern_47;
  data_0[2] = data_0[2] + (offset / 60 | 0) % 10 & $intern_47;
  data_0[3] = data_0[3] + (offset % 60 / 10 | 0) & $intern_47;
  data_0[4] = data_0[4] + offset % 10 & $intern_47;
  return valueOf_9(data_0, 0, data_0.length);
}

function TimeZone(){
}

function composeGMTString(offset){
  var data_0;
  data_0 = stampJavaTypeInfo(getClassLiteralForArray(C_classLit, 1), $intern_45, 23, 15, [71, 77, 84, 45, 48, 48, 58, 48, 48]);
  if (offset <= 0) {
    data_0[3] = 43;
    offset = -offset;
  }
  data_0[4] = data_0[4] + ((offset / 60 | 0) / 10 | 0) & $intern_47;
  data_0[5] = data_0[5] + (offset / 60 | 0) % 10 & $intern_47;
  data_0[7] = data_0[7] + (offset % 60 / 10 | 0) & $intern_47;
  data_0[8] = data_0[8] + offset % 10 & $intern_47;
  return valueOf_9(data_0, 0, data_0.length);
}

function composePOSIXTimeZoneID(offset){
  var str;
  if (offset == 0) {
    return 'Etc/GMT';
  }
  if (offset < 0) {
    offset = -offset;
    str = 'Etc/GMT-';
  }
   else {
    str = 'Etc/GMT+';
  }
  return str + offsetDisplay(offset);
}

function composeUTCString(offset){
  var str;
  if (offset == 0) {
    return 'UTC';
  }
  if (offset < 0) {
    offset = -offset;
    str = 'UTC+';
  }
   else {
    str = 'UTC-';
  }
  return str + offsetDisplay(offset);
}

function createTimeZone(timeZoneOffsetInMinutes){
  var tz;
  tz = new TimeZone;
  tz.standardOffset = timeZoneOffsetInMinutes;
  tz.timezoneID = composePOSIXTimeZoneID(timeZoneOffsetInMinutes);
  tz.tzNames = initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, 2, 6, 1);
  tz.tzNames[0] = composeUTCString(timeZoneOffsetInMinutes);
  tz.tzNames[1] = composeUTCString(timeZoneOffsetInMinutes);
  return tz;
}

function offsetDisplay(offset){
  var hour, mins;
  hour = offset / 60 | 0;
  mins = offset % 60;
  if (mins == 0) {
    return '' + hour;
  }
  return '' + hour + ':' + ('' + mins);
}

defineClass(1709, 1, {}, TimeZone);
_.standardOffset = 0;
var Lcom_google_gwt_i18n_client_TimeZone_2_classLit = createForClass('com.google.gwt.i18n.client', 'TimeZone', 1709);
function DateTimeFormatInfoImpl(){
}

defineClass(1159, 1778, {}, DateTimeFormatInfoImpl);
var Lcom_google_gwt_i18n_client_impl_cldr_DateTimeFormatInfoImpl_2_classLit = createForClass('com.google.gwt.i18n.client.impl.cldr', 'DateTimeFormatInfoImpl', 1159);
function DateTimeFormat$PatternPart(txt, cnt){
  this.text_0 = txt;
  this.count = cnt;
  this.abutStart = false;
}

defineClass(412, 1, {412:1}, DateTimeFormat$PatternPart);
_.abutStart = false;
_.count = 0;
var Lcom_google_gwt_i18n_shared_DateTimeFormat$PatternPart_2_classLit = createForClass('com.google.gwt.i18n.shared', 'DateTimeFormat/PatternPart', 412);
function $compareTo_0(this$static, other){
  return compare_7(fromDouble_0(this$static.jsdate.getTime()), fromDouble_0(other.jsdate.getTime()));
}

function $fixDaylightSavings(this$static, requestedHours){
  var badHours, copy, day, newTime, originalTimeInMillis, timeDiff, timeDiffHours, timeDiffMinutes;
  requestedHours %= 24;
  if (this$static.jsdate.getHours() != requestedHours) {
    copy = new $wnd.Date(this$static.jsdate.getTime());
    copy.setDate(copy.getDate() + 1);
    timeDiff = this$static.jsdate.getTimezoneOffset() - copy.getTimezoneOffset();
    if (timeDiff > 0) {
      timeDiffHours = timeDiff / 60 | 0;
      timeDiffMinutes = timeDiff % 60;
      day = this$static.jsdate.getDate();
      badHours = this$static.jsdate.getHours();
      badHours + timeDiffHours >= 24 && ++day;
      newTime = new $wnd.Date(this$static.jsdate.getFullYear(), this$static.jsdate.getMonth(), day, requestedHours + timeDiffHours, this$static.jsdate.getMinutes() + timeDiffMinutes, this$static.jsdate.getSeconds(), this$static.jsdate.getMilliseconds());
      this$static.jsdate.setTime(newTime.getTime());
    }
  }
  originalTimeInMillis = this$static.jsdate.getTime();
  this$static.jsdate.setTime(originalTimeInMillis + 3600000);
  this$static.jsdate.getHours() != requestedHours && this$static.jsdate.setTime(originalTimeInMillis);
}

function $setDate(this$static, date){
  var hours;
  hours = this$static.jsdate.getHours();
  this$static.jsdate.setDate(date);
  $fixDaylightSavings(this$static, hours);
}

function $setHours(this$static, hours){
  this$static.jsdate.setHours(hours);
  $fixDaylightSavings(this$static, hours);
}

function $setMinutes(this$static, minutes){
  var hours;
  hours = this$static.jsdate.getHours() + (minutes / 60 | 0);
  this$static.jsdate.setMinutes(minutes);
  $fixDaylightSavings(this$static, hours);
}

function $setMonth(this$static, month){
  var hours;
  hours = this$static.jsdate.getHours();
  this$static.jsdate.setMonth(month);
  $fixDaylightSavings(this$static, hours);
}

function $setSeconds(this$static, seconds){
  var hours;
  hours = this$static.jsdate.getHours() + (seconds / 3600 | 0);
  this$static.jsdate.setSeconds(seconds);
  $fixDaylightSavings(this$static, hours);
}

function $setTime(this$static, time){
  this$static.jsdate.setTime(toDouble_0(time));
}

function $setYear(this$static, year){
  var hours;
  hours = this$static.jsdate.getHours();
  this$static.jsdate.setFullYear(year + $intern_48);
  $fixDaylightSavings(this$static, hours);
}

function Date_0(){
  this.jsdate = new $wnd.Date;
}

function Date_1(year, month, date){
  this.jsdate = new $wnd.Date;
  this.jsdate.setFullYear(year + $intern_48, month, date);
  this.jsdate.setHours(0, 0, 0, 0);
  $fixDaylightSavings(this, 0);
}

function Date_2(date){
  this.jsdate = new $wnd.Date(toDouble_0(date));
}

function padTwo(number){
  return number < 10?'0' + number:'' + number;
}

defineClass(185, 1, $intern_50, Date_0, Date_1, Date_2);
_.compareTo_0 = function compareTo_4(other){
  return $compareTo_0(this, castTo(other, 185));
}
;
_.equals_0 = function equals_31(obj){
  return instanceOf(obj, 185) && eq(fromDouble_0(this.jsdate.getTime()), fromDouble_0(castTo(obj, 185).jsdate.getTime()));
}
;
_.hashCode_1 = function hashCode_27(){
  var time;
  time = fromDouble_0(this.jsdate.getTime());
  return toInt_0(xor_0(time, shru_0(time, 32)));
}
;
_.toString_0 = function toString_32(){
  var hourOffset, minuteOffset, offset;
  offset = -this.jsdate.getTimezoneOffset();
  hourOffset = (offset >= 0?'+':'') + (offset / 60 | 0);
  minuteOffset = (offset < 0?-offset:offset) % 60 < 10?'0' + (offset < 0?-offset:offset) % 60:'' + (offset < 0?-offset:offset) % 60;
  return ($clinit_Date$StringData() , DAYS)[this.jsdate.getDay()] + ' ' + MONTHS[this.jsdate.getMonth()] + ' ' + padTwo(this.jsdate.getDate()) + ' ' + padTwo(this.jsdate.getHours()) + ':' + padTwo(this.jsdate.getMinutes()) + ':' + padTwo(this.jsdate.getSeconds()) + ' GMT' + hourOffset + minuteOffset + ' ' + this.jsdate.getFullYear();
}
;
var Ljava_util_Date_2_classLit = createForClass('java.util', 'Date', 185);
function $calcDate(this$static, date){
  var adjustment, daysInCurrentMonth, defaultCenturyStart, offset, orgDayOfMonth, orgMonth, tmp;
  this$static.era == 0 && this$static.year > 0 && (this$static.year = -(this$static.year - 1));
  this$static.year > $intern_43 && $setYear(date, this$static.year - $intern_48);
  orgDayOfMonth = date.jsdate.getDate();
  $setDate(date, 1);
  this$static.month >= 0 && $setMonth(date, this$static.month);
  if (this$static.dayOfMonth >= 0) {
    $setDate(date, this$static.dayOfMonth);
  }
   else if (this$static.month >= 0) {
    tmp = new Date_1(date.jsdate.getFullYear() - $intern_48, date.jsdate.getMonth(), 35);
    daysInCurrentMonth = 35 - tmp.jsdate.getDate();
    $setDate(date, daysInCurrentMonth < orgDayOfMonth?daysInCurrentMonth:orgDayOfMonth);
  }
   else {
    $setDate(date, orgDayOfMonth);
  }
  this$static.hours < 0 && (this$static.hours = date.jsdate.getHours());
  this$static.ampm > 0 && this$static.hours < 12 && (this$static.hours += 12);
  $setHours(date, this$static.hours == 24 && this$static.midnightIs24?0:this$static.hours);
  this$static.minutes >= 0 && $setMinutes(date, this$static.minutes);
  this$static.seconds >= 0 && $setSeconds(date, this$static.seconds);
  this$static.milliseconds >= 0 && $setTime(date, add_20(mul_0(div(fromDouble_0(date.jsdate.getTime()), $intern_46), $intern_46), this$static.milliseconds));
  if (this$static.ambiguousYear) {
    defaultCenturyStart = new Date_0;
    $setYear(defaultCenturyStart, defaultCenturyStart.jsdate.getFullYear() - $intern_48 - 80);
    lt(fromDouble_0(date.jsdate.getTime()), fromDouble_0(defaultCenturyStart.jsdate.getTime())) && $setYear(date, defaultCenturyStart.jsdate.getFullYear() - $intern_48 + 100);
  }
  if (this$static.dayOfWeek >= 0) {
    if (this$static.dayOfMonth == -1) {
      adjustment = (7 + this$static.dayOfWeek - date.jsdate.getDay()) % 7;
      adjustment > 3 && (adjustment -= 7);
      orgMonth = date.jsdate.getMonth();
      $setDate(date, date.jsdate.getDate() + adjustment);
      date.jsdate.getMonth() != orgMonth && $setDate(date, date.jsdate.getDate() + (adjustment > 0?-7:7));
    }
     else {
      if (date.jsdate.getDay() != this$static.dayOfWeek) {
        return false;
      }
    }
  }
  if (this$static.tzOffset > $intern_43) {
    offset = date.jsdate.getTimezoneOffset();
    $setTime(date, add_20(fromDouble_0(date.jsdate.getTime()), (this$static.tzOffset - offset) * 60 * $intern_46));
  }
  return true;
}

function DateRecord(){
  Date_0.call(this);
  this.era = -1;
  this.ambiguousYear = false;
  this.year = $intern_43;
  this.month = -1;
  this.dayOfMonth = -1;
  this.ampm = -1;
  this.midnightIs24 = false;
  this.hours = -1;
  this.minutes = -1;
  this.seconds = -1;
  this.milliseconds = -1;
  this.dayOfWeek = -1;
  this.tzOffset = $intern_43;
}

defineClass(1705, 185, $intern_50, DateRecord);
_.ambiguousYear = false;
_.ampm = 0;
_.dayOfMonth = 0;
_.dayOfWeek = 0;
_.era = 0;
_.hours = 0;
_.midnightIs24 = false;
_.milliseconds = 0;
_.minutes = 0;
_.month = 0;
_.seconds = 0;
_.tzOffset = 0;
_.year = 0;
var Lcom_google_gwt_i18n_shared_impl_DateRecord_2_classLit = createForClass('com.google.gwt.i18n.shared.impl', 'DateRecord', 1705);
defineClass($intern_51, 1, {});
_.isArray_0 = function isArray(){
  return null;
}
;
_.isBoolean = function isBoolean(){
  return null;
}
;
_.isNumber = function isNumber(){
  return null;
}
;
_.isObject = function isObject(){
  return null;
}
;
_.isString = function isString(){
  return null;
}
;
var Lcom_google_gwt_json_client_JSONValue_2_classLit = createForClass('com.google.gwt.json.client', 'JSONValue', $intern_51);
function $get_4(this$static, index_0){
  var v = this$static.jsArray[index_0];
  var func = ($clinit_JSONParser() , typeMap)[typeof v];
  return func?func(v):throwUnknownTypeException(typeof v);
}

function $set_0(this$static, index_0, value_0){
  var previous;
  previous = $get_4(this$static, index_0);
  $set0(this$static, index_0, value_0);
  return previous;
}

function $set0(this$static, index_0, value_0){
  if (value_0) {
    var func = value_0.getUnwrapper();
    value_0 = func(value_0);
  }
   else {
    value_0 = undefined;
  }
  this$static.jsArray[index_0] = value_0;
}

function JSONArray(){
  this.jsArray = [];
}

function JSONArray_0(arr){
  this.jsArray = arr;
}

function unwrap(value_0){
  return value_0.jsArray;
}

defineClass(216, $intern_51, {216:1}, JSONArray, JSONArray_0);
_.equals_0 = function equals_32(other){
  if (!instanceOf(other, 216)) {
    return false;
  }
  return $equals_3(this.jsArray, castTo(other, 216).jsArray);
}
;
_.getUnwrapper = function getUnwrapper(){
  return unwrap;
}
;
_.hashCode_1 = function hashCode_28(){
  return $hashCode(this.jsArray);
}
;
_.isArray_0 = function isArray_0(){
  return this;
}
;
_.toString_0 = function toString_33(){
  var c, i, sb;
  sb = new StringBuilder_1('[');
  for (i = 0 , c = this.jsArray.length; i < c; i++) {
    i > 0 && (sb.string += ',' , sb);
    $append_10(sb, $get_4(this, i));
  }
  sb.string += ']';
  return sb.string;
}
;
var Lcom_google_gwt_json_client_JSONArray_2_classLit = createForClass('com.google.gwt.json.client', 'JSONArray', 216);
function $clinit_JSONBoolean(){
  $clinit_JSONBoolean = emptyMethod;
  FALSE = new JSONBoolean(false);
  TRUE = new JSONBoolean(true);
}

function JSONBoolean(value_0){
  this.value_0 = value_0;
}

function unwrap_0(value_0){
  return value_0.value_0;
}

defineClass(459, $intern_51, {459:1}, JSONBoolean);
_.getUnwrapper = function getUnwrapper_0(){
  return unwrap_0;
}
;
_.isBoolean = function isBoolean_0(){
  return this;
}
;
_.toString_0 = function toString_34(){
  return $clinit_Boolean() , '' + this.value_0;
}
;
_.value_0 = false;
var FALSE, TRUE;
var Lcom_google_gwt_json_client_JSONBoolean_2_classLit = createForClass('com.google.gwt.json.client', 'JSONBoolean', 459);
function JSONException(message){
  RuntimeException_0.call(this, message);
}

defineClass(911, 54, $intern_44, JSONException);
var Lcom_google_gwt_json_client_JSONException_2_classLit = createForClass('com.google.gwt.json.client', 'JSONException', 911);
function $clinit_JSONNull(){
  $clinit_JSONNull = emptyMethod;
  instance_1 = new JSONNull;
}

function JSONNull(){
}

function unwrap_1(){
  return null;
}

defineClass(951, $intern_51, {}, JSONNull);
_.getUnwrapper = function getUnwrapper_1(){
  return unwrap_1;
}
;
_.toString_0 = function toString_35(){
  return 'null';
}
;
var instance_1;
var Lcom_google_gwt_json_client_JSONNull_2_classLit = createForClass('com.google.gwt.json.client', 'JSONNull', 951);
function JSONNumber(value_0){
  this.value_0 = value_0;
}

function unwrap_2(value_0){
  return value_0.value_0;
}

defineClass(270, $intern_51, {270:1}, JSONNumber);
_.equals_0 = function equals_33(other){
  if (!instanceOf(other, 270)) {
    return false;
  }
  return this.value_0 == castTo(other, 270).value_0;
}
;
_.getUnwrapper = function getUnwrapper_2(){
  return unwrap_2;
}
;
_.hashCode_1 = function hashCode_29(){
  return round_int(checkNotNull_1(this.value_0));
}
;
_.isNumber = function isNumber_0(){
  return this;
}
;
_.toString_0 = function toString_36(){
  return this.value_0 + '';
}
;
_.value_0 = 0;
var Lcom_google_gwt_json_client_JSONNumber_2_classLit = createForClass('com.google.gwt.json.client', 'JSONNumber', 270);
function $computeKeys0(this$static, result){
  var jsObject = this$static.jsObject;
  var i = 0;
  for (var key in jsObject) {
    jsObject.hasOwnProperty(key) && (result[i++] = key);
  }
  return result;
}

function $containsKey_1(this$static, key){
  return key in this$static.jsObject;
}

function $get_5(this$static, key){
  if (key == null) {
    throw toJs(new NullPointerException);
  }
  return $get0(this$static, key);
}

function $get0(this$static, key){
  var jsObject = this$static.jsObject;
  var v;
  key = String(key);
  jsObject.hasOwnProperty(key) && (v = jsObject[key]);
  var func = ($clinit_JSONParser() , typeMap)[typeof v];
  var ret = func?func(v):throwUnknownTypeException(typeof v);
  return ret;
}

function $put_0(this$static, key, jsonValue){
  var previous;
  if (key == null) {
    throw toJs(new NullPointerException);
  }
  previous = $get_5(this$static, key);
  $put0(this$static, key, jsonValue);
  return previous;
}

function $put0(this$static, key, value_0){
  if (value_0) {
    var func = value_0.getUnwrapper();
    this$static.jsObject[key] = func(value_0);
  }
   else {
    delete this$static.jsObject[key];
  }
}

function JSONObject(){
  JSONObject_0.call(this, {});
}

function JSONObject_0(jsValue){
  this.jsObject = jsValue;
}

function unwrap_3(value_0){
  return value_0.jsObject;
}

defineClass(195, $intern_51, {195:1}, JSONObject, JSONObject_0);
_.equals_0 = function equals_34(other){
  if (!instanceOf(other, 195)) {
    return false;
  }
  return $equals_3(this.jsObject, castTo(other, 195).jsObject);
}
;
_.getUnwrapper = function getUnwrapper_3(){
  return unwrap_3;
}
;
_.hashCode_1 = function hashCode_30(){
  return $hashCode(this.jsObject);
}
;
_.isObject = function isObject_0(){
  return this;
}
;
_.toString_0 = function toString_37(){
  var first, key, key$index, key$max, keys_0, sb;
  sb = new StringBuilder_1('{');
  first = true;
  keys_0 = $computeKeys0(this, initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, 0, 6, 1));
  for (key$index = 0 , key$max = keys_0.length; key$index < key$max; ++key$index) {
    key = keys_0[key$index];
    first?(first = false):(sb.string += ', ' , sb);
    $append_11(sb, escapeValue(key));
    sb.string += ':';
    $append_10(sb, $get_5(this, key));
  }
  sb.string += '}';
  return sb.string;
}
;
var Lcom_google_gwt_json_client_JSONObject_2_classLit = createForClass('com.google.gwt.json.client', 'JSONObject', 195);
function JSONObject$1(this$0, val$keys){
  this.this$01 = this$0;
  this.val$keys2 = val$keys;
}

defineClass(644, $intern_13, $intern_14, JSONObject$1);
_.contains = function contains_22(o){
  return instanceOfString(o) && $containsKey_1(this.this$01, castToString(o));
}
;
_.iterator_0 = function iterator_38(){
  return new AbstractList$IteratorImpl(new Arrays$ArrayList(this.val$keys2));
}
;
_.size_1 = function size_28(){
  return this.val$keys2.length;
}
;
var Lcom_google_gwt_json_client_JSONObject$1_2_classLit = createForClass('com.google.gwt.json.client', 'JSONObject/1', 644);
function $clinit_JSONParser(){
  $clinit_JSONParser = emptyMethod;
  typeMap = {'boolean':createBoolean, 'number':createNumber, 'string':createString, 'object':createObject, 'function':createObject, 'undefined':createUndefined};
}

function createBoolean(v){
  return $clinit_JSONBoolean() , v?TRUE:FALSE;
}

function createNumber(v){
  return new JSONNumber(v);
}

function createObject(o){
  if (!o) {
    return $clinit_JSONNull() , instance_1;
  }
  var v = o.valueOf?o.valueOf():o;
  if (v !== o) {
    var func = typeMap[typeof v];
    return func?func(v):throwUnknownTypeException(typeof v);
  }
   else if (o instanceof Array || o instanceof $wnd.Array) {
    return new JSONArray_0(o);
  }
   else {
    return new JSONObject_0(o);
  }
}

function createString(v){
  return new JSONString(v);
}

function createUndefined(){
  return null;
}

function throwUnknownTypeException(typeString){
  $clinit_JSONParser();
  throw toJs(new JSONException("Unexpected typeof result '" + typeString + "'; please report this bug to the GWT team"));
}

var typeMap;
function JSONString(value_0){
  if (value_0 == null) {
    throw toJs(new NullPointerException);
  }
  this.value_0 = value_0;
}

function unwrap_4(value_0){
  return value_0.value_0;
}

defineClass(205, $intern_51, {205:1}, JSONString);
_.equals_0 = function equals_35(other){
  if (!instanceOf(other, 205)) {
    return false;
  }
  return $equals_4(this.value_0, castTo(other, 205).value_0);
}
;
_.getUnwrapper = function getUnwrapper_4(){
  return unwrap_4;
}
;
_.hashCode_1 = function hashCode_31(){
  return getHashCode_1(this.value_0);
}
;
_.isString = function isString_0(){
  return this;
}
;
_.toString_0 = function toString_38(){
  return escapeValue(this.value_0);
}
;
var Lcom_google_gwt_json_client_JSONString_2_classLit = createForClass('com.google.gwt.json.client', 'JSONString', 205);
function canSet(array, value_0){
  var elementTypeCategory;
  switch (getElementTypeCategory(array)) {
    case 6:
      return instanceOfString(value_0);
    case 7:
      return instanceOfDouble(value_0);
    case 8:
      return instanceOfBoolean(value_0);
    case 3:
      return Array.isArray(value_0) && (elementTypeCategory = getElementTypeCategory(value_0) , !(elementTypeCategory >= 14 && elementTypeCategory <= 16));
    case 11:
      return value_0 != null && typeof value_0 === 'function';
    case 12:
      return value_0 != null && (typeof value_0 === 'object' || typeof value_0 == 'function');
    case 0:
      return canCast(value_0, array.__elementTypeId$);
    case 2:
      return isJsObjectOrFunction(value_0) && !(value_0.typeMarker === typeMarkerFn);
    case 1:
      return isJsObjectOrFunction(value_0) && !(value_0.typeMarker === typeMarkerFn) || canCast(value_0, array.__elementTypeId$);
    default:return true;
  }
}

function getClassLiteralForArray(clazz, dimensions){
  return getClassLiteralForArray_0(clazz, dimensions);
}

function getElementTypeCategory(array){
  return array.__elementTypeCategory$ == null?10:array.__elementTypeCategory$;
}

function initMultidimensionalArray(leafClassLiteral, castableTypeMapExprs, elementTypeIds, leafElementTypeCategory, dimExprs, count){
  return initMultidimensionalArray_0(leafClassLiteral, castableTypeMapExprs, elementTypeIds, leafElementTypeCategory, dimExprs, 0, count);
}

function initMultidimensionalArray_0(leafClassLiteral, castableTypeMapExprs, elementTypeIds, leafElementTypeCategory, dimExprs, index_0, count){
  var elementTypeCategory, i, isLastDimension, length_0, result;
  length_0 = dimExprs[index_0];
  isLastDimension = index_0 == count - 1;
  elementTypeCategory = isLastDimension?leafElementTypeCategory:0;
  result = initializeArrayElementsWithDefaults(elementTypeCategory, length_0);
  leafElementTypeCategory != 10 && stampJavaTypeInfo(getClassLiteralForArray(leafClassLiteral, count - index_0), castableTypeMapExprs[index_0], elementTypeIds[index_0], elementTypeCategory, result);
  if (!isLastDimension) {
    ++index_0;
    for (i = 0; i < length_0; ++i) {
      result[i] = initMultidimensionalArray_0(leafClassLiteral, castableTypeMapExprs, elementTypeIds, leafElementTypeCategory, dimExprs, index_0, count);
    }
  }
  return result;
}

function initUnidimensionalArray(leafClassLiteral, castableTypeMap, elementTypeId, length_0, elementTypeCategory, dimensions){
  var result;
  result = initializeArrayElementsWithDefaults(elementTypeCategory, length_0);
  elementTypeCategory != 10 && stampJavaTypeInfo(getClassLiteralForArray(leafClassLiteral, dimensions), castableTypeMap, elementTypeId, elementTypeCategory, result);
  return result;
}

function initializeArrayElementsWithDefaults(elementTypeCategory, length_0){
  var array = new Array(length_0);
  var initValue;
  switch (elementTypeCategory) {
    case 14:
    case 15:
      initValue = 0;
      break;
    case 16:
      initValue = false;
      break;
    default:return array;
  }
  for (var i = 0; i < length_0; ++i) {
    array[i] = initValue;
  }
  return array;
}

function isJavaArray(src_0){
  return Array.isArray(src_0) && src_0.typeMarker === typeMarkerFn;
}

function setCheck(array, index_0, value_0){
  checkCriticalArrayType(value_0 == null || canSet(array, value_0));
  return array[index_0] = value_0;
}

function stampJavaTypeInfo(arrayClass, castableTypeMap, elementTypeId, elementTypeCategory, array){
  array.___clazz = arrayClass;
  array.castableTypeMap = castableTypeMap;
  array.typeMarker = typeMarkerFn;
  array.__elementTypeId$ = elementTypeId;
  array.__elementTypeCategory$ = elementTypeCategory;
  return array;
}

function stampJavaTypeInfo_0(array, referenceType){
  getElementTypeCategory(referenceType) != 10 && stampJavaTypeInfo(getClass__Ljava_lang_Class___devirtual$(referenceType), referenceType.castableTypeMap, referenceType.__elementTypeId$, getElementTypeCategory(referenceType), array);
  return array;
}

function create_1(value_0){
  var a0, a1, a2;
  a0 = value_0 & $intern_52;
  a1 = value_0 >> 22 & $intern_52;
  a2 = value_0 < 0?$intern_53:0;
  return create0(a0, a1, a2);
}

function create_2(a){
  return create0(a.l, a.m, a.h);
}

function create0(l, m, h){
  return {l:l, m:m, h:h};
}

function divMod(a, b, computeRemainder){
  var aIsCopy, aIsMinValue, aIsNegative, bpower, c, negative;
  if (b.l == 0 && b.m == 0 && b.h == 0) {
    throw toJs(new ArithmeticException('divide by zero'));
  }
  if (a.l == 0 && a.m == 0 && a.h == 0) {
    computeRemainder && (remainder = create0(0, 0, 0));
    return create0(0, 0, 0);
  }
  if (b.h == $intern_54 && b.m == 0 && b.l == 0) {
    return divModByMinValue(a, computeRemainder);
  }
  negative = false;
  if (b.h >> 19 != 0) {
    b = neg(b);
    negative = true;
  }
  bpower = powerOfTwo(b);
  aIsNegative = false;
  aIsMinValue = false;
  aIsCopy = false;
  if (a.h == $intern_54 && a.m == 0 && a.l == 0) {
    aIsMinValue = true;
    aIsNegative = true;
    if (bpower == -1) {
      a = create_2(($clinit_BigLongLib$Const() , MAX_VALUE));
      aIsCopy = true;
      negative = !negative;
    }
     else {
      c = shr(a, bpower);
      negative && negate(c);
      computeRemainder && (remainder = create0(0, 0, 0));
      return c;
    }
  }
   else if (a.h >> 19 != 0) {
    aIsNegative = true;
    a = neg(a);
    aIsCopy = true;
    negative = !negative;
  }
  if (bpower != -1) {
    return divModByShift(a, bpower, negative, aIsNegative, computeRemainder);
  }
  if (compare_2(a, b) < 0) {
    computeRemainder && (aIsNegative?(remainder = neg(a)):(remainder = create0(a.l, a.m, a.h)));
    return create0(0, 0, 0);
  }
  return divModHelper(aIsCopy?a:create0(a.l, a.m, a.h), b, negative, aIsNegative, aIsMinValue, computeRemainder);
}

function divModByMinValue(a, computeRemainder){
  if (a.h == $intern_54 && a.m == 0 && a.l == 0) {
    computeRemainder && (remainder = create0(0, 0, 0));
    return create_2(($clinit_BigLongLib$Const() , ONE));
  }
  computeRemainder && (remainder = create0(a.l, a.m, a.h));
  return create0(0, 0, 0);
}

function divModByShift(a, bpower, negative, aIsNegative, computeRemainder){
  var c;
  c = shr(a, bpower);
  negative && negate(c);
  if (computeRemainder) {
    a = maskRight(a, bpower);
    aIsNegative?(remainder = neg(a)):(remainder = create0(a.l, a.m, a.h));
  }
  return c;
}

function divModHelper(a, b, negative, aIsNegative, aIsMinValue, computeRemainder){
  var bshift, gte, quotient, shift_0, a1, a2, a0;
  shift_0 = numberOfLeadingZeros(b) - numberOfLeadingZeros(a);
  bshift = shl(b, shift_0);
  quotient = create0(0, 0, 0);
  while (shift_0 >= 0) {
    gte = trialSubtract(a, bshift);
    if (gte) {
      shift_0 < 22?(quotient.l |= 1 << shift_0 , undefined):shift_0 < 44?(quotient.m |= 1 << shift_0 - 22 , undefined):(quotient.h |= 1 << shift_0 - 44 , undefined);
      if (a.l == 0 && a.m == 0 && a.h == 0) {
        break;
      }
    }
    a1 = bshift.m;
    a2 = bshift.h;
    a0 = bshift.l;
    bshift.h = a2 >>> 1;
    bshift.m = a1 >>> 1 | (a2 & 1) << 21;
    bshift.l = a0 >>> 1 | (a1 & 1) << 21;
    --shift_0;
  }
  negative && negate(quotient);
  if (computeRemainder) {
    if (aIsNegative) {
      remainder = neg(a);
      aIsMinValue && (remainder = sub_1(remainder, ($clinit_BigLongLib$Const() , ONE)));
    }
     else {
      remainder = create0(a.l, a.m, a.h);
    }
  }
  return quotient;
}

function maskRight(a, bits){
  var b0, b1, b2;
  if (bits <= 22) {
    b0 = a.l & (1 << bits) - 1;
    b1 = b2 = 0;
  }
   else if (bits <= 44) {
    b0 = a.l;
    b1 = a.m & (1 << bits - 22) - 1;
    b2 = 0;
  }
   else {
    b0 = a.l;
    b1 = a.m;
    b2 = a.h & (1 << bits - 44) - 1;
  }
  return create0(b0, b1, b2);
}

function negate(a){
  var neg0, neg1, neg2;
  neg0 = ~a.l + 1 & $intern_52;
  neg1 = ~a.m + (neg0 == 0?1:0) & $intern_52;
  neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & $intern_53;
  a.l = neg0;
  a.m = neg1;
  a.h = neg2;
}

function numberOfLeadingZeros(a){
  var b1, b2;
  b2 = numberOfLeadingZeros_0(a.h);
  if (b2 == 32) {
    b1 = numberOfLeadingZeros_0(a.m);
    return b1 == 32?numberOfLeadingZeros_0(a.l) + 32:b1 + 20 - 10;
  }
   else {
    return b2 - 12;
  }
}

function powerOfTwo(a){
  var h, l, m;
  l = a.l;
  if ((l & l - 1) != 0) {
    return -1;
  }
  m = a.m;
  if ((m & m - 1) != 0) {
    return -1;
  }
  h = a.h;
  if ((h & h - 1) != 0) {
    return -1;
  }
  if (h == 0 && m == 0 && l == 0) {
    return -1;
  }
  if (h == 0 && m == 0 && l != 0) {
    return numberOfTrailingZeros(l);
  }
  if (h == 0 && m != 0 && l == 0) {
    return numberOfTrailingZeros(m) + 22;
  }
  if (h != 0 && m == 0 && l == 0) {
    return numberOfTrailingZeros(h) + 44;
  }
  return -1;
}

function toDoubleHelper(a){
  return a.l + a.m * $intern_55 + a.h * $intern_56;
}

function trialSubtract(a, b){
  var sum0, sum1, sum2;
  sum2 = a.h - b.h;
  if (sum2 < 0) {
    return false;
  }
  sum0 = a.l - b.l;
  sum1 = a.m - b.m + (sum0 >> 22);
  sum2 += sum1 >> 22;
  if (sum2 < 0) {
    return false;
  }
  a.l = sum0 & $intern_52;
  a.m = sum1 & $intern_52;
  a.h = sum2 & $intern_53;
  return true;
}

var remainder;
function add_19(a, b){
  var sum0, sum1, sum2;
  sum0 = a.l + b.l;
  sum1 = a.m + b.m + (sum0 >> 22);
  sum2 = a.h + b.h + (sum1 >> 22);
  return create0(sum0 & $intern_52, sum1 & $intern_52, sum2 & $intern_53);
}

function and(a, b){
  return create0(a.l & b.l, a.m & b.m, a.h & b.h);
}

function compare_2(a, b){
  var a0, a1, a2, b0, b1, b2, signA, signB;
  signA = a.h >> 19;
  signB = b.h >> 19;
  if (signA != signB) {
    return signB - signA;
  }
  a2 = a.h;
  b2 = b.h;
  if (a2 != b2) {
    return a2 - b2;
  }
  a1 = a.m;
  b1 = b.m;
  if (a1 != b1) {
    return a1 - b1;
  }
  a0 = a.l;
  b0 = b.l;
  return a0 - b0;
}

function fromDouble(value_0){
  var a0, a1, a2, negative, result;
  if (isNaN(value_0)) {
    return $clinit_BigLongLib$Const() , ZERO;
  }
  if (value_0 < -9223372036854775808) {
    return $clinit_BigLongLib$Const() , MIN_VALUE;
  }
  if (value_0 >= 9223372036854775807) {
    return $clinit_BigLongLib$Const() , MAX_VALUE;
  }
  negative = false;
  if (value_0 < 0) {
    negative = true;
    value_0 = -value_0;
  }
  a2 = 0;
  if (value_0 >= $intern_56) {
    a2 = round_int(value_0 / $intern_56);
    value_0 -= a2 * $intern_56;
  }
  a1 = 0;
  if (value_0 >= $intern_55) {
    a1 = round_int(value_0 / $intern_55);
    value_0 -= a1 * $intern_55;
  }
  a0 = round_int(value_0);
  result = create0(a0, a1, a2);
  negative && negate(result);
  return result;
}

function mul(a, b){
  var a0, a1, a2, a3, a4, b0, b1, b2, b3, b4, c0, c00, c01, c1, c10, c11, c12, c13, c2, c22, c23, c24, p0, p1, p2, p3, p4;
  a0 = a.l & 8191;
  a1 = a.l >> 13 | (a.m & 15) << 9;
  a2 = a.m >> 4 & 8191;
  a3 = a.m >> 17 | (a.h & 255) << 5;
  a4 = (a.h & 1048320) >> 8;
  b0 = b.l & 8191;
  b1 = b.l >> 13 | (b.m & 15) << 9;
  b2 = b.m >> 4 & 8191;
  b3 = b.m >> 17 | (b.h & 255) << 5;
  b4 = (b.h & 1048320) >> 8;
  p0 = a0 * b0;
  p1 = a1 * b0;
  p2 = a2 * b0;
  p3 = a3 * b0;
  p4 = a4 * b0;
  if (b1 != 0) {
    p1 += a0 * b1;
    p2 += a1 * b1;
    p3 += a2 * b1;
    p4 += a3 * b1;
  }
  if (b2 != 0) {
    p2 += a0 * b2;
    p3 += a1 * b2;
    p4 += a2 * b2;
  }
  if (b3 != 0) {
    p3 += a0 * b3;
    p4 += a1 * b3;
  }
  b4 != 0 && (p4 += a0 * b4);
  c00 = p0 & $intern_52;
  c01 = (p1 & 511) << 13;
  c0 = c00 + c01;
  c10 = p0 >> 22;
  c11 = p1 >> 9;
  c12 = (p2 & 262143) << 4;
  c13 = (p3 & 31) << 17;
  c1 = c10 + c11 + c12 + c13;
  c22 = p2 >> 18;
  c23 = p3 >> 5;
  c24 = (p4 & 4095) << 8;
  c2 = c22 + c23 + c24;
  c1 += c0 >> 22;
  c0 &= $intern_52;
  c2 += c1 >> 22;
  c1 &= $intern_52;
  c2 &= $intern_53;
  return create0(c0, c1, c2);
}

function neg(a){
  var neg0, neg1, neg2;
  neg0 = ~a.l + 1 & $intern_52;
  neg1 = ~a.m + (neg0 == 0?1:0) & $intern_52;
  neg2 = ~a.h + (neg0 == 0 && neg1 == 0?1:0) & $intern_53;
  return create0(neg0, neg1, neg2);
}

function not(a){
  return create0(~a.l & $intern_52, ~a.m & $intern_52, ~a.h & $intern_53);
}

function or(a, b){
  return create0(a.l | b.l, a.m | b.m, a.h | b.h);
}

function shl(a, n){
  var res0, res1, res2;
  n &= 63;
  if (n < 22) {
    res0 = a.l << n;
    res1 = a.m << n | a.l >> 22 - n;
    res2 = a.h << n | a.m >> 22 - n;
  }
   else if (n < 44) {
    res0 = 0;
    res1 = a.l << n - 22;
    res2 = a.m << n - 22 | a.l >> 44 - n;
  }
   else {
    res0 = 0;
    res1 = 0;
    res2 = a.l << n - 44;
  }
  return create0(res0 & $intern_52, res1 & $intern_52, res2 & $intern_53);
}

function shr(a, n){
  var a2, negative, res0, res1, res2;
  n &= 63;
  a2 = a.h;
  negative = (a2 & $intern_54) != 0;
  negative && (a2 |= -1048576);
  if (n < 22) {
    res2 = a2 >> n;
    res1 = a.m >> n | a2 << 22 - n;
    res0 = a.l >> n | a.m << 22 - n;
  }
   else if (n < 44) {
    res2 = negative?$intern_53:0;
    res1 = a2 >> n - 22;
    res0 = a.m >> n - 22 | a2 << 44 - n;
  }
   else {
    res2 = negative?$intern_53:0;
    res1 = negative?$intern_52:0;
    res0 = a2 >> n - 44;
  }
  return create0(res0 & $intern_52, res1 & $intern_52, res2 & $intern_53);
}

function shru(a, n){
  var a2, res0, res1, res2;
  n &= 63;
  a2 = a.h & $intern_53;
  if (n < 22) {
    res2 = a2 >>> n;
    res1 = a.m >> n | a2 << 22 - n;
    res0 = a.l >> n | a.m << 22 - n;
  }
   else if (n < 44) {
    res2 = 0;
    res1 = a2 >>> n - 22;
    res0 = a.m >> n - 22 | a.h << 44 - n;
  }
   else {
    res2 = 0;
    res1 = 0;
    res0 = a2 >>> n - 44;
  }
  return create0(res0 & $intern_52, res1 & $intern_52, res2 & $intern_53);
}

function sub_1(a, b){
  var sum0, sum1, sum2;
  sum0 = a.l - b.l;
  sum1 = a.m - b.m + (sum0 >> 22);
  sum2 = a.h - b.h + (sum1 >> 22);
  return create0(sum0 & $intern_52, sum1 & $intern_52, sum2 & $intern_53);
}

function toDouble(a){
  if (compare_2(a, ($clinit_BigLongLib$Const() , ZERO)) < 0) {
    return -toDoubleHelper(neg(a));
  }
  return a.l + a.m * $intern_55 + a.h * $intern_56;
}

function toInt(a){
  return a.l | a.m << 22;
}

function toString_39(a){
  var digits, rem, res, tenPowerLong, zeroesNeeded;
  if (a.l == 0 && a.m == 0 && a.h == 0) {
    return '0';
  }
  if (a.h == $intern_54 && a.m == 0 && a.l == 0) {
    return '-9223372036854775808';
  }
  if (a.h >> 19 != 0) {
    return '-' + toString_39(neg(a));
  }
  rem = a;
  res = '';
  while (!(rem.l == 0 && rem.m == 0 && rem.h == 0)) {
    tenPowerLong = create_1($intern_57);
    rem = divMod(rem, tenPowerLong, true);
    digits = '' + toInt(remainder);
    if (!(rem.l == 0 && rem.m == 0 && rem.h == 0)) {
      zeroesNeeded = 9 - digits.length;
      for (; zeroesNeeded > 0; zeroesNeeded--) {
        digits = '0' + digits;
      }
    }
    res = digits + res;
  }
  return res;
}

function xor(a, b){
  return create0(a.l ^ b.l, a.m ^ b.m, a.h ^ b.h);
}

function $clinit_BigLongLib$Const(){
  $clinit_BigLongLib$Const = emptyMethod;
  MAX_VALUE = create0($intern_52, $intern_52, 524287);
  MIN_VALUE = create0(0, 0, $intern_54);
  ONE = create_1(1);
  create_1(2);
  ZERO = create_1(0);
}

var MAX_VALUE, MIN_VALUE, ONE, ZERO;
function toJava(e){
  var javaException;
  if (instanceOf(e, 79)) {
    return e;
  }
  javaException = e && e['__java$exception'];
  if (!javaException) {
    javaException = new JavaScriptException(e);
    captureStackTrace(javaException);
  }
  return javaException;
}

function toJs(t){
  return t.backingJsObject;
}

function add_20(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a + b;
    if ($intern_58 < result && result < $intern_56) {
      return result;
    }
  }
  return createLongEmul(add_19(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function and_0(a, b){
  return createLongEmul(and(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function compare_3(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a - b;
    if (!isNaN(result)) {
      return result;
    }
  }
  return compare_2(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b);
}

function createLongEmul(big_0){
  var a2;
  a2 = big_0.h;
  if (a2 == 0) {
    return big_0.l + big_0.m * $intern_55;
  }
  if (a2 == $intern_53) {
    return big_0.l + big_0.m * $intern_55 - $intern_56;
  }
  return big_0;
}

function div(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a / b;
    if ($intern_58 < result && result < $intern_56) {
      return result < 0?$wnd.Math.ceil(result):$wnd.Math.floor(result);
    }
  }
  return createLongEmul(divMod(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b, false));
}

function eq(a, b){
  return compare_3(a, b) == 0;
}

function fromDouble_0(value_0){
  if ($intern_58 < value_0 && value_0 < $intern_56) {
    return value_0 < 0?$wnd.Math.ceil(value_0):$wnd.Math.floor(value_0);
  }
  return createLongEmul(fromDouble(value_0));
}

function gt(a, b){
  return compare_3(a, b) > 0;
}

function isSmallLong0(value_0){
  return typeof value_0 === 'number';
}

function lt(a, b){
  return compare_3(a, b) < 0;
}

function mod(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a % b;
    if ($intern_58 < result && result < $intern_56) {
      return result;
    }
  }
  return createLongEmul((divMod(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b, true) , remainder));
}

function mul_0(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a * b;
    if ($intern_58 < result && result < $intern_56) {
      return result;
    }
  }
  return createLongEmul(mul(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function neg_0(a){
  var result;
  if (isSmallLong0(a)) {
    result = 0 - a;
    if (!isNaN(result)) {
      return result;
    }
  }
  return createLongEmul(neg(a));
}

function neq(a, b){
  return compare_3(a, b) != 0;
}

function not_0(a){
  return createLongEmul(not(isSmallLong0(a)?toBigLong(a):a));
}

function or_0(a, b){
  return createLongEmul(or(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function shl_0(a, n){
  return createLongEmul(shl(isSmallLong0(a)?toBigLong(a):a, n));
}

function shr_0(a, n){
  return createLongEmul(shr(isSmallLong0(a)?toBigLong(a):a, n));
}

function shru_0(a, n){
  return createLongEmul(shru(isSmallLong0(a)?toBigLong(a):a, n));
}

function sub_2(a, b){
  var result;
  if (isSmallLong0(a) && isSmallLong0(b)) {
    result = a - b;
    if ($intern_58 < result && result < $intern_56) {
      return result;
    }
  }
  return createLongEmul(sub_1(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function toBigLong(longValue){
  var a0, a1, a3, value_0;
  value_0 = longValue;
  a3 = 0;
  if (value_0 < 0) {
    value_0 += $intern_56;
    a3 = $intern_53;
  }
  a1 = round_int(value_0 / $intern_55);
  a0 = round_int(value_0 - a1 * $intern_55);
  return create0(a0, a1, a3);
}

function toDouble_0(a){
  var d;
  if (isSmallLong0(a)) {
    d = a;
    return d == -0.?0:d;
  }
  return toDouble(a);
}

function toInt_0(a){
  if (isSmallLong0(a)) {
    return a | 0;
  }
  return toInt(a);
}

function toString_40(a){
  if (isSmallLong0(a)) {
    return '' + a;
  }
  return toString_39(a);
}

function xor_0(a, b){
  return createLongEmul(xor(isSmallLong0(a)?toBigLong(a):a, isSmallLong0(b)?toBigLong(b):b));
}

function init(){
  $clinit_ElkJs();
  exportLayout();
}

function $split(this$static, input_0){
  return input_0.split(this$static);
}

defineClass(1739, 1, {});
var Ljava_io_OutputStream_2_classLit = createForClass('java.io', 'OutputStream', 1739);
defineClass(1740, 1739, {});
var Ljava_io_FilterOutputStream_2_classLit = createForClass('java.io', 'FilterOutputStream', 1740);
function PrintStream(){
}

defineClass(645, 1740, {}, PrintStream);
var Ljava_io_PrintStream_2_classLit = createForClass('java.io', 'PrintStream', 645);
function $replace0(this$static, start_0, end, toInsert){
  this$static.string = $substring_1(this$static.string, 0, start_0) + ('' + toInsert) + $substring_0(this$static.string, end);
}

function $substring(this$static, end){
  return $substring_1(this$static.string, 0, end);
}

function AbstractStringBuilder(string){
  this.string = string;
}

defineClass(395, 1, {495:1});
_.toString_0 = function toString_42(){
  return this.string;
}
;
var Ljava_lang_AbstractStringBuilder_2_classLit = createForClass('java.lang', 'AbstractStringBuilder', 395);
function ArithmeticException(explanation){
  RuntimeException_0.call(this, explanation);
}

defineClass(497, 54, $intern_44, ArithmeticException);
var Ljava_lang_ArithmeticException_2_classLit = createForClass('java.lang', 'ArithmeticException', 497);
function IndexOutOfBoundsException(){
  RuntimeException.call(this);
}

function IndexOutOfBoundsException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(80, 54, $intern_59, IndexOutOfBoundsException, IndexOutOfBoundsException_0);
var Ljava_lang_IndexOutOfBoundsException_2_classLit = createForClass('java.lang', 'IndexOutOfBoundsException', 80);
function ArrayIndexOutOfBoundsException(){
  IndexOutOfBoundsException.call(this);
}

function ArrayIndexOutOfBoundsException_0(msg){
  IndexOutOfBoundsException_0.call(this, msg);
}

defineClass(312, 80, {3:1, 312:1, 102:1, 80:1, 54:1, 79:1}, ArrayIndexOutOfBoundsException, ArrayIndexOutOfBoundsException_0);
var Ljava_lang_ArrayIndexOutOfBoundsException_2_classLit = createForClass('java.lang', 'ArrayIndexOutOfBoundsException', 312);
function ArrayStoreException(){
  RuntimeException.call(this);
}

function ArrayStoreException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(496, 54, $intern_44, ArrayStoreException, ArrayStoreException_0);
var Ljava_lang_ArrayStoreException_2_classLit = createForClass('java.lang', 'ArrayStoreException', 496);
function Error_0(message){
  Throwable_0.call(this, message);
}

function Error_1(message, cause){
  $$init_0(this);
  this.cause = cause;
  this.detailMessage = message;
  $fillInStackTrace(this);
  this.initializeBackingError();
}

defineClass(282, 79, $intern_60, Error_0);
var Ljava_lang_Error_2_classLit = createForClass('java.lang', 'Error', 282);
function AssertionError(){
  Throwable.call(this);
}

function AssertionError_0(message){
  Error_1.call(this, message == null?'null':toString_41(message), instanceOf(message, 79)?castTo(message, 79):null);
}

defineClass(170, 282, $intern_60, AssertionError, AssertionError_0);
var Ljava_lang_AssertionError_2_classLit = createForClass('java.lang', 'AssertionError', 170);
function $clinit_Boolean(){
  $clinit_Boolean = emptyMethod;
  FALSE_0 = ($clinit_Boolean() , false);
  TRUE_0 = true;
}

function $compareTo_1(this$static, b){
  return compare_4((checkCriticalNotNull(this$static) , this$static), (checkCriticalNotNull(b) , b));
}

function compare_4(x_0, y_0){
  $clinit_Boolean();
  return x_0 == y_0?0:x_0?1:-1;
}

function compareTo_Ljava_lang_Object__I__devirtual$(this$static, other){
  $clinit_Boolean();
  return instanceOfString(this$static)?$compareTo_9(this$static, castToString(other)):instanceOfDouble(this$static)?$compareTo_4(this$static, castToDouble(other)):instanceOfBoolean(this$static)?$compareTo_1(this$static, castToBoolean(other)):this$static.compareTo_0(other);
}

booleanCastMap = {3:1, 449:1, 34:1};
var FALSE_0, TRUE_0;
var Ljava_lang_Boolean_2_classLit = createForClass('java.lang', 'Boolean', 449);
function __parseAndValidateDouble(s){
  floatRegex == null && (floatRegex = /^\s*[+-]?(NaN|Infinity|((\d+\.?\d*)|(\.\d+))([eE][+-]?\d+)?[dDfF]?)\s*$/);
  if (!floatRegex.test(s)) {
    throw toJs(new NumberFormatException('For input string: "' + s + '"'));
  }
  return parseFloat(s);
}

function __parseAndValidateInt(s, lowerBound, upperBound){
  var i, isTooLow, length_0, startIndex, toReturn;
  if (s == null) {
    throw toJs(new NumberFormatException('null'));
  }
  length_0 = s.length;
  startIndex = length_0 > 0 && (s.charCodeAt(0) == 45 || s.charCodeAt(0) == 43)?1:0;
  for (i = startIndex; i < length_0; i++) {
    if (digit_0(s.charCodeAt(i)) == -1) {
      throw toJs(new NumberFormatException('For input string: "' + s + '"'));
    }
  }
  toReturn = parseInt(s, 10);
  isTooLow = toReturn < lowerBound;
  if (isNaN(toReturn)) {
    throw toJs(new NumberFormatException('For input string: "' + s + '"'));
  }
   else if (isTooLow || toReturn > upperBound) {
    throw toJs(new NumberFormatException('For input string: "' + s + '"'));
  }
  return toReturn;
}

function __parseAndValidateLong(s){
  var c, firstTime, head, i, length_0, maxDigits, minValue, negative, orig, radixPower, toReturn;
  if (s == null) {
    throw toJs(new NumberFormatException('null'));
  }
  orig = s;
  length_0 = s.length;
  negative = false;
  if (length_0 > 0) {
    c = s.charCodeAt(0);
    if (c == 45 || c == 43) {
      s = s.substr(1, s.length - 1);
      --length_0;
      negative = c == 45;
    }
  }
  if (length_0 == 0) {
    throw toJs(new NumberFormatException('For input string: "' + orig + '"'));
  }
  while (s.length > 0 && s.charCodeAt(0) == 48) {
    s = s.substr(1, s.length - 1);
    --length_0;
  }
  if (length_0 > ($clinit_Number$__ParseLong() , maxLengthForRadix)[10]) {
    throw toJs(new NumberFormatException('For input string: "' + orig + '"'));
  }
  for (i = 0; i < length_0; i++) {
    if (digit_0(s.charCodeAt(i)) == -1) {
      throw toJs(new NumberFormatException('For input string: "' + orig + '"'));
    }
  }
  toReturn = 0;
  maxDigits = maxDigitsForRadix[10];
  radixPower = maxDigitsRadixPower[10];
  minValue = neg_0(maxValueForRadix[10]);
  firstTime = true;
  head = length_0 % maxDigits;
  if (head > 0) {
    toReturn = -parseInt_1(s.substr(0, head), 10);
    s = s.substr(head, s.length - head);
    length_0 -= head;
    firstTime = false;
  }
  while (length_0 >= maxDigits) {
    head = parseInt_1(s.substr(0, maxDigits), 10);
    s = s.substr(maxDigits, s.length - maxDigits);
    length_0 -= maxDigits;
    if (firstTime) {
      firstTime = false;
    }
     else {
      if (compare_3(toReturn, minValue) < 0) {
        throw toJs(new NumberFormatException('For input string: "' + orig + '"'));
      }
      toReturn = mul_0(toReturn, radixPower);
    }
    toReturn = sub_2(toReturn, head);
  }
  if (compare_3(toReturn, 0) > 0) {
    throw toJs(new NumberFormatException('For input string: "' + orig + '"'));
  }
  if (!negative) {
    toReturn = neg_0(toReturn);
    if (compare_3(toReturn, 0) < 0) {
      throw toJs(new NumberFormatException('For input string: "' + orig + '"'));
    }
  }
  return toReturn;
}

function doubleValue__D__devirtual$(this$static){
  return instanceOfDouble(this$static)?(checkCriticalNotNull(this$static) , this$static):this$static.doubleValue();
}

defineClass(217, 1, {3:1, 217:1});
var floatRegex;
var Ljava_lang_Number_2_classLit = createForClass('java.lang', 'Number', 217);
function $compareTo_2(this$static, b){
  return this$static.value_0 - b.value_0;
}

function Byte(value_0){
  this.value_0 = value_0;
}

function valueOf_2(b){
  var rebase, result;
  rebase = b + 128;
  result = ($clinit_Byte$BoxedValues() , boxedValues)[rebase];
  !result && (result = boxedValues[rebase] = new Byte(b));
  return result;
}

defineClass(196, 217, {3:1, 196:1, 34:1, 217:1}, Byte);
_.compareTo_0 = function compareTo_5(b){
  return $compareTo_2(this, castTo(b, 196));
}
;
_.doubleValue = function doubleValue_0(){
  return this.value_0;
}
;
_.equals_0 = function equals_36(o){
  return instanceOf(o, 196) && castTo(o, 196).value_0 == this.value_0;
}
;
_.hashCode_1 = function hashCode_32(){
  return this.value_0;
}
;
_.toString_0 = function toString_43(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
var Ljava_lang_Byte_2_classLit = createForClass('java.lang', 'Byte', 196);
function $clinit_Byte$BoxedValues(){
  $clinit_Byte$BoxedValues = emptyMethod;
  boxedValues = initUnidimensionalArray(Ljava_lang_Byte_2_classLit, $intern_33, 196, 256, 0, 1);
}

var boxedValues;
function $compareTo_3(this$static, c){
  return this$static.value_0 - c.value_0;
}

function Character(value_0){
  this.value_0 = value_0;
}

function digit_0(c){
  if (c >= 48 && c < 58) {
    return c - 48;
  }
  if (c >= 97 && c < 97) {
    return c - 97 + 10;
  }
  if (c >= 65 && c < 65) {
    return c - 65 + 10;
  }
  return -1;
}

function valueOf_3(c){
  var result;
  if (c < 128) {
    result = ($clinit_Character$BoxedValues() , boxedValues_0)[c];
    !result && (result = boxedValues_0[c] = new Character(c));
    return result;
  }
  return new Character(c);
}

defineClass(161, 1, {3:1, 161:1, 34:1}, Character);
_.compareTo_0 = function compareTo_6(c){
  return $compareTo_3(this, castTo(c, 161));
}
;
_.equals_0 = function equals_37(o){
  return instanceOf(o, 161) && castTo(o, 161).value_0 == this.value_0;
}
;
_.hashCode_1 = function hashCode_33(){
  return this.value_0;
}
;
_.toString_0 = function toString_44(){
  return String.fromCharCode(this.value_0);
}
;
_.value_0 = 0;
var Ljava_lang_Character_2_classLit = createForClass('java.lang', 'Character', 161);
function $clinit_Character$BoxedValues(){
  $clinit_Character$BoxedValues = emptyMethod;
  boxedValues_0 = initUnidimensionalArray(Ljava_lang_Character_2_classLit, $intern_33, 161, 128, 0, 1);
}

var boxedValues_0;
function ClassCastException(){
  RuntimeException.call(this);
}

function ClassCastException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(182, 54, {3:1, 182:1, 102:1, 54:1, 79:1}, ClassCastException, ClassCastException_0);
var Ljava_lang_ClassCastException_2_classLit = createForClass('java.lang', 'ClassCastException', 182);
function $compareTo_4(this$static, b){
  return compare_5((checkCriticalNotNull(this$static) , this$static), (checkCriticalNotNull(b) , b));
}

function compare_5(x_0, y_0){
  if (x_0 < y_0) {
    return -1;
  }
  if (x_0 > y_0) {
    return 1;
  }
  if (x_0 == y_0) {
    return 0;
  }
  return isNaN(x_0)?isNaN(y_0)?0:1:-1;
}

function isInfinite(x_0){
  return !isNaN(x_0) && !isFinite(x_0);
}

doubleCastMap = {3:1, 34:1, 323:1, 217:1};
var Ljava_lang_Double_2_classLit = createForClass('java.lang', 'Double', 323);
function $compareTo_5(this$static, b){
  return compare_5(this$static.value_0, b.value_0);
}

function Float(value_0){
  this.value_0 = value_0;
}

function Float_0(s){
  this.value_0 = parseFloat_0(s);
}

function parseFloat_0(s){
  var doubleValue;
  doubleValue = __parseAndValidateDouble(s);
  if (doubleValue > $intern_61) {
    return $intern_62;
  }
   else if (doubleValue < -3.4028234663852886E38) {
    return $intern_63;
  }
  return doubleValue;
}

defineClass(128, 217, {3:1, 34:1, 128:1, 217:1}, Float, Float_0);
_.compareTo_0 = function compareTo_7(b){
  return $compareTo_5(this, castTo(b, 128));
}
;
_.doubleValue = function doubleValue_1(){
  return this.value_0;
}
;
_.equals_0 = function equals_38(o){
  return instanceOf(o, 128) && castTo(o, 128).value_0 == this.value_0;
}
;
_.hashCode_1 = function hashCode_34(){
  return round_int(this.value_0);
}
;
_.toString_0 = function toString_46(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
var Ljava_lang_Float_2_classLit = createForClass('java.lang', 'Float', 128);
function IllegalArgumentException(){
  RuntimeException.call(this);
}

function IllegalArgumentException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(30, 54, {3:1, 102:1, 30:1, 54:1, 79:1}, IllegalArgumentException, IllegalArgumentException_0);
var Ljava_lang_IllegalArgumentException_2_classLit = createForClass('java.lang', 'IllegalArgumentException', 30);
function IllegalStateException(){
  RuntimeException.call(this);
}

function IllegalStateException_0(s){
  RuntimeException_0.call(this, s);
}

defineClass(72, 54, $intern_44, IllegalStateException, IllegalStateException_0);
var Ljava_lang_IllegalStateException_2_classLit = createForClass('java.lang', 'IllegalStateException', 72);
function $compareTo_6(this$static, b){
  return compare_6(this$static.value_0, b.value_0);
}

function Integer(value_0){
  this.value_0 = value_0;
}

function bitCount(x_0){
  x_0 -= x_0 >> 1 & 1431655765;
  x_0 = (x_0 >> 2 & 858993459) + (x_0 & 858993459);
  x_0 = (x_0 >> 4) + x_0 & 252645135;
  x_0 += x_0 >> 8;
  x_0 += x_0 >> 16;
  return x_0 & 63;
}

function compare_6(x_0, y_0){
  return x_0 < y_0?-1:x_0 > y_0?1:0;
}

function highestOneBit(i){
  var rtn;
  if (i < 0) {
    return $intern_43;
  }
   else if (i == 0) {
    return 0;
  }
   else {
    for (rtn = $intern_24; (rtn & i) == 0; rtn >>= 1)
    ;
    return rtn;
  }
}

function numberOfLeadingZeros_0(i){
  var m, n, y_0;
  if (i < 0) {
    return 0;
  }
   else if (i == 0) {
    return 32;
  }
   else {
    y_0 = -(i >> 16);
    m = y_0 >> 16 & 16;
    n = 16 - m;
    i = i >> m;
    y_0 = i - 256;
    m = y_0 >> 16 & 8;
    n += m;
    i <<= m;
    y_0 = i - $intern_64;
    m = y_0 >> 16 & 4;
    n += m;
    i <<= m;
    y_0 = i - $intern_21;
    m = y_0 >> 16 & 2;
    n += m;
    i <<= m;
    y_0 = i >> 14;
    m = y_0 & ~(y_0 >> 1);
    return n + 2 - m;
  }
}

function numberOfTrailingZeros(i){
  var r, rtn;
  if (i == 0) {
    return 32;
  }
   else {
    rtn = 0;
    for (r = 1; (r & i) == 0; r <<= 1) {
      ++rtn;
    }
    return rtn;
  }
}

function reverse_1(i){
  var nibbles;
  nibbles = ($clinit_Integer$ReverseNibbles() , reverseNibbles);
  return nibbles[i >>> 28] | nibbles[i >> 24 & 15] << 4 | nibbles[i >> 20 & 15] << 8 | nibbles[i >> 16 & 15] << 12 | nibbles[i >> 12 & 15] << 16 | nibbles[i >> 8 & 15] << 20 | nibbles[i >> 4 & 15] << 24 | nibbles[i & 15] << 28;
}

function rotateLeft(i, distance){
  while (distance-- > 0) {
    i = i << 1 | (i < 0?1:0);
  }
  return i;
}

function valueOf_4(i){
  var rebase, result;
  if (i > -129 && i < 128) {
    rebase = i + 128;
    result = ($clinit_Integer$BoxedValues() , boxedValues_1)[rebase];
    !result && (result = boxedValues_1[rebase] = new Integer(i));
    return result;
  }
  return new Integer(i);
}

defineClass(21, 217, {3:1, 34:1, 21:1, 217:1}, Integer);
_.compareTo_0 = function compareTo_8(b){
  return $compareTo_6(this, castTo(b, 21));
}
;
_.doubleValue = function doubleValue_2(){
  return this.value_0;
}
;
_.equals_0 = function equals_39(o){
  return instanceOf(o, 21) && castTo(o, 21).value_0 == this.value_0;
}
;
_.hashCode_1 = function hashCode_35(){
  return this.value_0;
}
;
_.toString_0 = function toString_47(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
var Ljava_lang_Integer_2_classLit = createForClass('java.lang', 'Integer', 21);
function $clinit_Integer$BoxedValues(){
  $clinit_Integer$BoxedValues = emptyMethod;
  boxedValues_1 = initUnidimensionalArray(Ljava_lang_Integer_2_classLit, $intern_33, 21, 256, 0, 1);
}

var boxedValues_1;
function $clinit_Integer$ReverseNibbles(){
  $clinit_Integer$ReverseNibbles = emptyMethod;
  reverseNibbles = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]);
}

var reverseNibbles;
function $compareTo_7(this$static, b){
  return compare_7(this$static.value_0, b.value_0);
}

function Long(value_0){
  this.value_0 = value_0;
}

function compare_7(x_0, y_0){
  return compare_3(x_0, y_0) < 0?-1:compare_3(x_0, y_0) > 0?1:0;
}

function valueOf_5(i){
  var rebase, result;
  if (compare_3(i, -129) > 0 && compare_3(i, 128) < 0) {
    rebase = toInt_0(i) + 128;
    result = ($clinit_Long$BoxedValues() , boxedValues_2)[rebase];
    !result && (result = boxedValues_2[rebase] = new Long(i));
    return result;
  }
  return new Long(i);
}

defineClass(152, 217, {3:1, 34:1, 152:1, 217:1}, Long);
_.compareTo_0 = function compareTo_9(b){
  return $compareTo_7(this, castTo(b, 152));
}
;
_.doubleValue = function doubleValue_3(){
  return toDouble_0(this.value_0);
}
;
_.equals_0 = function equals_40(o){
  return instanceOf(o, 152) && eq(castTo(o, 152).value_0, this.value_0);
}
;
_.hashCode_1 = function hashCode_36(){
  return toInt_0(this.value_0);
}
;
_.toString_0 = function toString_48(){
  return '' + toString_40(this.value_0);
}
;
_.value_0 = 0;
var Ljava_lang_Long_2_classLit = createForClass('java.lang', 'Long', 152);
function $clinit_Long$BoxedValues(){
  $clinit_Long$BoxedValues = emptyMethod;
  boxedValues_2 = initUnidimensionalArray(Ljava_lang_Long_2_classLit, $intern_33, 152, 256, 0, 1);
}

var boxedValues_2;
function abs_0(x_0){
  return x_0 < 0?-x_0:x_0;
}

function max_1(x_0, y_0){
  return x_0 > y_0?x_0:y_0;
}

function max_2(x_0, y_0){
  return compare_3(x_0, y_0) > 0?x_0:y_0;
}

function min_1(x_0, y_0){
  return x_0 < y_0?x_0:y_0;
}

function signum(d){
  return d == 0 || isNaN(d)?d:d < 0?-1:1;
}

function NegativeArraySizeException(message){
  RuntimeException_0.call(this, message);
}

defineClass(1334, 54, $intern_44, NegativeArraySizeException);
var Ljava_lang_NegativeArraySizeException_2_classLit = createForClass('java.lang', 'NegativeArraySizeException', 1334);
function NullPointerException(){
  RuntimeException.call(this);
}

function NullPointerException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(172, 564, {3:1, 102:1, 172:1, 54:1, 79:1}, NullPointerException, NullPointerException_0);
_.createError = function createError_0(msg){
  return new $wnd.TypeError(msg);
}
;
var Ljava_lang_NullPointerException_2_classLit = createForClass('java.lang', 'NullPointerException', 172);
function $clinit_Number$__ParseLong(){
  $clinit_Number$__ParseLong = emptyMethod;
  var i;
  maxDigitsForRadix = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [-1, -1, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5]);
  maxDigitsRadixPower = initUnidimensionalArray(I_classLit, $intern_49, 23, 37, 15, 1);
  maxLengthForRadix = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [-1, -1, 63, 40, 32, 28, 25, 23, 21, 20, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13]);
  maxValueForRadix = initUnidimensionalArray(J_classLit, $intern_65, 23, 37, 14, 1);
  for (i = 2; i <= 36; i++) {
    maxDigitsRadixPower[i] = round_int($wnd.Math.pow(i, maxDigitsForRadix[i]));
    maxValueForRadix[i] = div($intern_23, maxDigitsRadixPower[i]);
  }
}

var maxDigitsForRadix, maxDigitsRadixPower, maxLengthForRadix, maxValueForRadix;
function NumberFormatException(message){
  IllegalArgumentException_0.call(this, message);
}

defineClass(120, 30, {3:1, 102:1, 30:1, 120:1, 54:1, 79:1}, NumberFormatException);
var Ljava_lang_NumberFormatException_2_classLit = createForClass('java.lang', 'NumberFormatException', 120);
function $compareTo_8(this$static, b){
  return this$static.value_0 - b.value_0;
}

function Short(value_0){
  this.value_0 = value_0;
}

function valueOf_6(s){
  var rebase, result;
  if (s > -129 && s < 128) {
    rebase = s + 128;
    result = ($clinit_Short$BoxedValues() , boxedValues_3)[rebase];
    !result && (result = boxedValues_3[rebase] = new Short(s));
    return result;
  }
  return new Short(s);
}

defineClass(171, 217, {3:1, 34:1, 217:1, 171:1}, Short);
_.compareTo_0 = function compareTo_10(b){
  return $compareTo_8(this, castTo(b, 171));
}
;
_.doubleValue = function doubleValue_4(){
  return this.value_0;
}
;
_.equals_0 = function equals_41(o){
  return instanceOf(o, 171) && castTo(o, 171).value_0 == this.value_0;
}
;
_.hashCode_1 = function hashCode_37(){
  return this.value_0;
}
;
_.toString_0 = function toString_49(){
  return '' + this.value_0;
}
;
_.value_0 = 0;
var Ljava_lang_Short_2_classLit = createForClass('java.lang', 'Short', 171);
function $clinit_Short$BoxedValues(){
  $clinit_Short$BoxedValues = emptyMethod;
  boxedValues_3 = initUnidimensionalArray(Ljava_lang_Short_2_classLit, $intern_33, 171, 256, 0, 1);
}

var boxedValues_3;
function StackTraceElement(methodName, fileName, lineNumber){
  this.className = 'Unknown';
  this.methodName = methodName;
  this.fileName = fileName;
  this.lineNumber = lineNumber;
}

defineClass(296, 1, {3:1, 296:1}, StackTraceElement);
_.equals_0 = function equals_42(other){
  var st;
  if (instanceOf(other, 296)) {
    st = castTo(other, 296);
    return this.lineNumber == st.lineNumber && equals_56(this.methodName, st.methodName) && equals_56(this.className, st.className) && equals_56(this.fileName, st.fileName);
  }
  return false;
}
;
_.hashCode_1 = function hashCode_38(){
  return hashCode_43(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [valueOf_4(this.lineNumber), this.className, this.methodName, this.fileName]));
}
;
_.toString_0 = function toString_50(){
  return this.className + '.' + this.methodName + '(' + (this.fileName != null?this.fileName:'Unknown Source') + (this.lineNumber >= 0?':' + this.lineNumber:'') + ')';
}
;
_.lineNumber = 0;
var Ljava_lang_StackTraceElement_2_classLit = createForClass('java.lang', 'StackTraceElement', 296);
function $charAt(this$static, index_0){
  return this$static.charCodeAt(index_0);
}

function $compareTo_9(this$static, other){
  return compare_12((checkCriticalNotNull(this$static) , this$static), (checkCriticalNotNull(other) , other));
}

function $equals_4(this$static, other){
  return checkCriticalNotNull(this$static) , this$static === other;
}

function $equalsIgnoreCase(this$static, other){
  checkCriticalNotNull(this$static);
  if (other == null) {
    return false;
  }
  if ($equals_4(this$static, other)) {
    return true;
  }
  return this$static.length == other.length && $equals_4(this$static.toLowerCase(), other.toLowerCase());
}

function $getChars0(this$static, srcBegin, srcEnd, dst, dstBegin){
  while (srcBegin < srcEnd) {
    dst[dstBegin++] = $charAt(this$static, srcBegin++);
  }
}

function $indexOf_0(this$static, codePoint, startIndex){
  return $indexOf_2(this$static, fromCodePoint(codePoint), startIndex);
}

function $indexOf_1(this$static, str){
  return this$static.indexOf(str);
}

function $indexOf_2(this$static, str, startIndex){
  return this$static.indexOf(str, startIndex);
}

function $lastIndexOf(this$static, str){
  return this$static.lastIndexOf(str);
}

function $lastIndexOf_0(this$static, str, start_0){
  return this$static.lastIndexOf(str, start_0);
}

function $split_0(this$static, regex){
  var compiled, count, lastNonEmpty, lastTrail, matchObj, out, trail;
  compiled = new $wnd.RegExp(regex, 'g');
  out = initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, 0, 6, 1);
  count = 0;
  trail = this$static;
  lastTrail = null;
  while (true) {
    matchObj = compiled.exec(trail);
    if (matchObj == null || trail == '') {
      out[count] = trail;
      break;
    }
     else {
      out[count] = $substring_1(trail, 0, matchObj.index);
      trail = $substring_1(trail, matchObj.index + matchObj[0].length, trail.length);
      compiled.lastIndex = 0;
      if (lastTrail == trail) {
        out[count] = trail.substr(0, 1);
        trail = trail.substr(1, trail.length - 1);
      }
      lastTrail = trail;
      ++count;
    }
  }
  if (this$static.length > 0) {
    lastNonEmpty = out.length;
    while (lastNonEmpty > 0 && out[lastNonEmpty - 1] == '') {
      --lastNonEmpty;
    }
    lastNonEmpty < out.length && (out.length = lastNonEmpty , undefined);
  }
  return out;
}

function $startsWith(this$static, prefix){
  return $equals_4(this$static.substr(0, prefix.length), prefix);
}

function $startsWith_0(this$static, prefix, toffset){
  return toffset >= 0 && $equals_4(this$static.substr(toffset, prefix.length), prefix);
}

function $substring_0(this$static, beginIndex){
  return this$static.substr(beginIndex, this$static.length - beginIndex);
}

function $substring_1(this$static, beginIndex, endIndex){
  return this$static.substr(beginIndex, endIndex - beginIndex);
}

function $toCharArray(this$static){
  var charArr, n;
  n = this$static.length;
  charArr = initUnidimensionalArray(C_classLit, $intern_45, 23, n, 15, 1);
  $getChars0(this$static, 0, n, charArr, 0);
  return charArr;
}

function $toLowerCase(this$static, locale){
  return locale == ($clinit_Locale() , $clinit_Locale() , defaultLocale)?this$static.toLocaleLowerCase():this$static.toLowerCase();
}

function $trim(this$static){
  var end, length_0, start_0;
  length_0 = this$static.length;
  start_0 = 0;
  while (start_0 < length_0 && this$static.charCodeAt(start_0) <= 32) {
    ++start_0;
  }
  end = length_0;
  while (end > start_0 && this$static.charCodeAt(end - 1) <= 32) {
    --end;
  }
  return start_0 > 0 || end < length_0?this$static.substr(start_0, end - start_0):this$static;
}

function fromCharCode(array){
  return String.fromCharCode.apply(null, array);
}

function fromCodePoint(codePoint){
  var hiSurrogate, loSurrogate;
  if (codePoint >= $intern_66) {
    hiSurrogate = $intern_67 + (codePoint - $intern_66 >> 10 & 1023) & $intern_47;
    loSurrogate = 56320 + (codePoint - $intern_66 & 1023) & $intern_47;
    return String.fromCharCode(hiSurrogate) + ('' + String.fromCharCode(loSurrogate));
  }
   else {
    return String.fromCharCode(codePoint & $intern_47);
  }
}

function valueOf_7(x_0){
  return x_0 == null?'null':toString_41(x_0);
}

function valueOf_8(x_0){
  return valueOf_9(x_0, 0, x_0.length);
}

function valueOf_9(x_0, offset, count){
  var batchEnd, batchStart, end, s;
  end = offset + count;
  checkCriticalStringBounds(offset, end, x_0.length);
  s = '';
  for (batchStart = offset; batchStart < end;) {
    batchEnd = batchStart + $intern_68 < end?batchStart + $intern_68:end;
    s += fromCharCode(x_0.slice(batchStart, batchEnd));
    batchStart = batchEnd;
  }
  return s;
}

stringCastMap = {3:1, 495:1, 34:1, 2:1};
var Ljava_lang_String_2_classLit = createForClass('java.lang', 'String', 2);
function $append(this$static, x_0){
  this$static.string += String.fromCharCode(x_0);
  return this$static;
}

function $append_0(this$static, x_0){
  this$static.string += x_0;
  return this$static;
}

function $append_1(this$static, x_0){
  this$static.string += x_0;
  return this$static;
}

function $append_2(this$static, x_0){
  this$static.string += '' + x_0;
  return this$static;
}

function $append_3(this$static, x_0){
  this$static.string += '' + x_0;
  return this$static;
}

function $append_4(this$static, x_0){
  this$static.string += x_0;
  return this$static;
}

function $deleteCharAt(this$static, start_0){
  this$static.string = $substring_1(this$static.string, 0, start_0) + '' + $substring_0(this$static.string, start_0 + 1);
  return this$static;
}

function StringBuffer(){
  AbstractStringBuilder.call(this, '');
}

function StringBuffer_0(){
  AbstractStringBuilder.call(this, '');
}

function StringBuffer_1(s){
  AbstractStringBuilder.call(this, (checkCriticalNotNull(s) , s));
}

defineClass(103, 395, {495:1}, StringBuffer, StringBuffer_0, StringBuffer_1);
var Ljava_lang_StringBuffer_2_classLit = createForClass('java.lang', 'StringBuffer', 103);
function $append_5(this$static, x_0){
  this$static.string += String.fromCharCode(x_0);
  return this$static;
}

function $append_6(this$static, x_0){
  this$static.string += x_0;
  return this$static;
}

function $append_7(this$static, x_0){
  return this$static.string += '' + x_0 , this$static;
}

function $append_8(this$static, x_0){
  this$static.string += '' + x_0;
  return this$static;
}

function $append_9(this$static, x_0, start_0, end){
  this$static.string += '' + x_0.substr(start_0, end - start_0);
  return this$static;
}

function $append_10(this$static, x_0){
  this$static.string += '' + x_0;
  return this$static;
}

function $append_11(this$static, x_0){
  this$static.string += '' + x_0;
  return this$static;
}

function $append_12(this$static, x_0){
  this$static.string += valueOf_9(x_0, 0, x_0.length);
  return this$static;
}

function $append_13(this$static, x_0, len){
  this$static.string += valueOf_9(x_0, 0, len);
  return this$static;
}

function $insert(this$static, index_0, x_0){
  this$static.string = $substring_1(this$static.string, 0, index_0) + ('' + x_0) + $substring_0(this$static.string, index_0);
  return this$static;
}

function StringBuilder(){
  AbstractStringBuilder.call(this, '');
}

function StringBuilder_0(){
  AbstractStringBuilder.call(this, '');
}

function StringBuilder_1(s){
  AbstractStringBuilder.call(this, (checkCriticalNotNull(s) , s));
}

defineClass(95, 395, {495:1}, StringBuilder, StringBuilder_0, StringBuilder_1);
var Ljava_lang_StringBuilder_2_classLit = createForClass('java.lang', 'StringBuilder', 95);
function StringIndexOutOfBoundsException(message){
  IndexOutOfBoundsException_0.call(this, message);
}

defineClass(795, 80, $intern_59, StringIndexOutOfBoundsException);
var Ljava_lang_StringIndexOutOfBoundsException_2_classLit = createForClass('java.lang', 'StringIndexOutOfBoundsException', 795);
function $clinit_System(){
  $clinit_System = emptyMethod;
  err_0 = new PrintStream;
  out_0 = new PrintStream;
}

function arraycopy(src_0, srcOfs, dest, destOfs, len){
  $clinit_System();
  var destArray, destComp, destEnd, destType, destlen, srcArray, srcComp, srcType, srclen;
  checkCriticalNotNull_0(src_0, 'src');
  checkCriticalNotNull_0(dest, 'dest');
  srcType = getClass__Ljava_lang_Class___devirtual$(src_0);
  destType = getClass__Ljava_lang_Class___devirtual$(dest);
  checkCriticalArrayType_0((srcType.modifiers & 4) != 0, 'srcType is not an array');
  checkCriticalArrayType_0((destType.modifiers & 4) != 0, 'destType is not an array');
  srcComp = srcType.componentType;
  destComp = destType.componentType;
  checkCriticalArrayType_0((srcComp.modifiers & 1) != 0?srcComp == destComp:(destComp.modifiers & 1) == 0, "Array types don't match");
  srclen = src_0.length;
  destlen = dest.length;
  if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > srclen || destOfs + len > destlen) {
    throw toJs(new IndexOutOfBoundsException);
  }
  if ((srcComp.modifiers & 1) == 0 && srcType != destType) {
    srcArray = castToArray(src_0);
    destArray = castToArray(dest);
    if (maskUndefined(src_0) === maskUndefined(dest) && srcOfs < destOfs) {
      srcOfs += len;
      for (destEnd = destOfs + len; destEnd-- > destOfs;) {
        setCheck(destArray, destEnd, srcArray[--srcOfs]);
      }
    }
     else {
      for (destEnd = destOfs + len; destOfs < destEnd;) {
        setCheck(destArray, destOfs++, srcArray[srcOfs++]);
      }
    }
  }
   else 
    len > 0 && copy_0(src_0, srcOfs, dest, destOfs, len, true);
}

defineClass(1805, 1, {});
var err_0, out_0;
function UnsupportedOperationException(){
  RuntimeException.call(this);
}

function UnsupportedOperationException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(48, 54, {3:1, 102:1, 54:1, 79:1, 48:1}, UnsupportedOperationException, UnsupportedOperationException_0);
var Ljava_lang_UnsupportedOperationException_2_classLit = createForClass('java.lang', 'UnsupportedOperationException', 48);
function $clinit_BigDecimal(){
  $clinit_BigDecimal = emptyMethod;
  var i, j, j0;
  new BigDecimal(1, 0);
  new BigDecimal(10, 0);
  new BigDecimal(0, 0);
  BI_SCALED_BY_ZERO = initUnidimensionalArray(Ljava_math_BigDecimal_2_classLit, $intern_33, 222, 11, 0, 1);
  CH_ZEROS = initUnidimensionalArray(C_classLit, $intern_45, 23, 100, 15, 1);
  DOUBLE_FIVE_POW = stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625, 48828125, 244140625, 1220703125, 6103515625, 30517578125, 152587890625, 762939453125, 3814697265625, 19073486328125, 95367431640625, 476837158203125, 2384185791015625]);
  DOUBLE_FIVE_POW_BIT_LENGTH = initUnidimensionalArray(I_classLit, $intern_49, 23, DOUBLE_FIVE_POW.length, 15, 1);
  DOUBLE_TEN_POW = stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [1, 10, 100, $intern_46, $intern_68, $intern_70, 1000000, 10000000, 100000000, $intern_57, 10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000, 1000000000000000, 10000000000000000]);
  DOUBLE_TEN_POW_BIT_LENGTH = initUnidimensionalArray(I_classLit, $intern_49, 23, DOUBLE_TEN_POW.length, 15, 1);
  ZERO_SCALED_BY = initUnidimensionalArray(Ljava_math_BigDecimal_2_classLit, $intern_33, 222, 11, 0, 1);
  i = 0;
  for (; i < ZERO_SCALED_BY.length; i++) {
    BI_SCALED_BY_ZERO[i] = new BigDecimal(i, 0);
    ZERO_SCALED_BY[i] = new BigDecimal(0, i);
    CH_ZEROS[i] = 48;
  }
  for (; i < CH_ZEROS.length; i++) {
    CH_ZEROS[i] = 48;
  }
  for (j0 = 0; j0 < DOUBLE_FIVE_POW_BIT_LENGTH.length; j0++) {
    DOUBLE_FIVE_POW_BIT_LENGTH[j0] = bitLength(DOUBLE_FIVE_POW[j0]);
  }
  for (j = 0; j < DOUBLE_TEN_POW_BIT_LENGTH.length; j++) {
    DOUBLE_TEN_POW_BIT_LENGTH[j] = bitLength(DOUBLE_TEN_POW[j]);
  }
  $clinit_Multiplication();
}

function $compareTo_10(this$static, val){
  var diffPrecision, diffScale, thisSign, thisUnscaled, valUnscaled, valueSign;
  thisSign = $signum(this$static);
  valueSign = $signum(val);
  if (thisSign == valueSign) {
    if (this$static.scale == val.scale && this$static.bitLength < 54 && val.bitLength < 54) {
      return this$static.smallValue < val.smallValue?-1:this$static.smallValue > val.smallValue?1:0;
    }
    diffScale = this$static.scale - val.scale;
    diffPrecision = (this$static.precision > 0?this$static.precision:$wnd.Math.floor((this$static.bitLength - 1) * $intern_71) + 1) - (val.precision > 0?val.precision:$wnd.Math.floor((val.bitLength - 1) * $intern_71) + 1);
    if (diffPrecision > diffScale + 1) {
      return thisSign;
    }
     else if (diffPrecision < diffScale - 1) {
      return -thisSign;
    }
     else {
      thisUnscaled = (!this$static.intVal && (this$static.intVal = valueOf_10(this$static.smallValue)) , this$static.intVal);
      valUnscaled = (!val.intVal && (val.intVal = valueOf_10(val.smallValue)) , val.intVal);
      diffScale < 0?(thisUnscaled = $multiply(thisUnscaled, powerOf10(-diffScale))):diffScale > 0 && (valUnscaled = $multiply(valUnscaled, powerOf10(diffScale)));
      return $compareTo_11(thisUnscaled, valUnscaled);
    }
  }
   else 
    return thisSign < valueSign?-1:1;
}

function $initFrom(this$static, val){
  var begin, ch_0, i, last, offset, scaleString, unscaled, unscaledBuffer;
  begin = 0;
  offset = 0;
  last = val.length;
  unscaledBuffer = new StringBuilder_0;
  if (0 < last && val.charCodeAt(0) == 43) {
    ++offset;
    ++begin;
    if (offset < last && (val.charCodeAt(offset) == 43 || val.charCodeAt(offset) == 45)) {
      throw toJs(new NumberFormatException('For input string: "' + val + '"'));
    }
  }
  while (offset < last && val.charCodeAt(offset) != 46 && val.charCodeAt(offset) != 101 && val.charCodeAt(offset) != 69) {
    ++offset;
  }
  unscaledBuffer.string += '' + (val == null?'null':val).substr(begin, offset - begin);
  if (offset < last && val.charCodeAt(offset) == 46) {
    ++offset;
    begin = offset;
    while (offset < last && val.charCodeAt(offset) != 101 && val.charCodeAt(offset) != 69) {
      ++offset;
    }
    this$static.scale = offset - begin;
    unscaledBuffer.string += '' + (val == null?'null':val).substr(begin, offset - begin);
  }
   else {
    this$static.scale = 0;
  }
  if (offset < last && (val.charCodeAt(offset) == 101 || val.charCodeAt(offset) == 69)) {
    ++offset;
    begin = offset;
    if (offset < last && val.charCodeAt(offset) == 43) {
      ++offset;
      offset < last && val.charCodeAt(offset) != 45 && ++begin;
    }
    scaleString = val.substr(begin, last - begin);
    this$static.scale = this$static.scale - __parseAndValidateInt(scaleString, $intern_43, $intern_0);
    if (this$static.scale != round_int(this$static.scale)) {
      throw toJs(new NumberFormatException('Scale out of range.'));
    }
  }
  unscaled = unscaledBuffer.string;
  if (unscaled.length < 16) {
    this$static.smallValue = (unscaledRegex == null && (unscaledRegex = /^[+-]?\d*$/i) , unscaledRegex.test(unscaled)?parseInt(unscaled, 10):NaN);
    if (isNaN_0(this$static.smallValue)) {
      throw toJs(new NumberFormatException('For input string: "' + val + '"'));
    }
    this$static.bitLength = bitLength(this$static.smallValue);
  }
   else {
    $setUnscaledValue(this$static, new BigInteger_4(unscaled));
  }
  this$static.precision = unscaledBuffer.string.length;
  for (i = 0; i < unscaledBuffer.string.length; ++i) {
    ch_0 = $charAt(unscaledBuffer.string, i);
    if (ch_0 != 45 && ch_0 != 48) {
      break;
    }
    --this$static.precision;
  }
  this$static.precision == 0 && (this$static.precision = 1);
}

function $setUnscaledValue(this$static, unscaledValue){
  var value_0;
  this$static.intVal = unscaledValue;
  this$static.bitLength = bitLength_1(unscaledValue);
  this$static.bitLength < 54 && (this$static.smallValue = (value_0 = unscaledValue.numberLength > 1?or_0(shl_0(unscaledValue.digits[1], 32), and_0(unscaledValue.digits[0], $intern_72)):and_0(unscaledValue.digits[0], $intern_72) , toDouble_0(mul_0(unscaledValue.sign, value_0))));
}

function $signum(this$static){
  if (this$static.bitLength < 54) {
    return this$static.smallValue < 0?-1:this$static.smallValue > 0?1:0;
  }
  return (!this$static.intVal && (this$static.intVal = valueOf_10(this$static.smallValue)) , this$static.intVal).sign;
}

function $toPlainString(this$static){
  var begin, delta, intStr, result;
  intStr = toDecimalScaledString_0((!this$static.intVal && (this$static.intVal = valueOf_10(this$static.smallValue)) , this$static.intVal), 0);
  if (this$static.scale == 0 || this$static.bitLength == 0 && this$static.smallValue != -1 && this$static.scale < 0) {
    return intStr;
  }
  begin = $signum(this$static) < 0?1:0;
  delta = this$static.scale;
  result = (intStr.length + 1 + abs_0(round_int(this$static.scale)) , new StringBuilder_0);
  begin == 1 && (result.string += '-' , result);
  if (this$static.scale > 0) {
    delta -= intStr.length - begin;
    if (delta >= 0) {
      result.string += '0.';
      for (; delta > CH_ZEROS.length; delta -= CH_ZEROS.length) {
        $append_12(result, CH_ZEROS);
      }
      $append_13(result, CH_ZEROS, round_int(delta));
      $append_11(result, intStr.substr(begin, intStr.length - begin));
    }
     else {
      delta = begin - delta;
      $append_11(result, $substring_1(intStr, begin, round_int(delta)));
      result.string += '.';
      $append_11(result, $substring_0(intStr, round_int(delta)));
    }
  }
   else {
    $append_11(result, intStr.substr(begin, intStr.length - begin));
    for (; delta < -CH_ZEROS.length; delta += CH_ZEROS.length) {
      $append_12(result, CH_ZEROS);
    }
    $append_13(result, CH_ZEROS, round_int(-delta));
  }
  return result.string;
}

function $toString_5(this$static){
  var begin, end, exponent, intString, result;
  if (this$static.toStringImage != null) {
    return this$static.toStringImage;
  }
  if (this$static.bitLength < 32) {
    this$static.toStringImage = toDecimalScaledString(fromDouble_0(this$static.smallValue), round_int(this$static.scale));
    return this$static.toStringImage;
  }
  intString = toDecimalScaledString_0((!this$static.intVal && (this$static.intVal = valueOf_10(this$static.smallValue)) , this$static.intVal), 0);
  if (this$static.scale == 0) {
    return intString;
  }
  begin = (!this$static.intVal && (this$static.intVal = valueOf_10(this$static.smallValue)) , this$static.intVal).sign < 0?2:1;
  end = intString.length;
  exponent = -this$static.scale + end - begin;
  result = new StringBuilder;
  result.string += '' + intString;
  if (this$static.scale > 0 && exponent >= -6) {
    if (exponent >= 0) {
      $insert(result, end - round_int(this$static.scale), String.fromCharCode(46));
    }
     else {
      result.string = $substring_1(result.string, 0, begin - 1) + '0.' + $substring_0(result.string, begin - 1);
      $insert(result, begin + 1, valueOf_9(CH_ZEROS, 0, -round_int(exponent) - 1));
    }
  }
   else {
    if (end - begin >= 1) {
      $insert(result, begin, String.fromCharCode(46));
      ++end;
    }
    $insert(result, end, String.fromCharCode(69));
    exponent > 0 && $insert(result, ++end, String.fromCharCode(43));
    $insert(result, ++end, '' + toString_40(fromDouble_0(exponent)));
  }
  this$static.toStringImage = result.string;
  return this$static.toStringImage;
}

function BigDecimal(smallValue, scale){
  this.scale = scale;
  this.bitLength = bitLength_0(smallValue);
  this.bitLength < 54?(this.smallValue = toDouble_0(smallValue)):(this.intVal = valueOf_11(smallValue));
}

function BigDecimal_0(val){
  $clinit_BigDecimal();
  $initFrom(this, val);
}

function bitLength(value_0){
  var negative, result;
  if (value_0 > -140737488355328 && value_0 < 140737488355328) {
    if (value_0 == 0) {
      return 0;
    }
    negative = value_0 < 0;
    negative && (value_0 = -value_0);
    result = round_int($wnd.Math.floor($wnd.Math.log(value_0) / 0.6931471805599453));
    (!negative || value_0 != $wnd.Math.pow(2, result)) && ++result;
    return result;
  }
  return bitLength_0(fromDouble_0(value_0));
}

function bitLength_0(value_0){
  var high;
  compare_3(value_0, 0) < 0 && (value_0 = not_0(value_0));
  return high = toInt_0(shr_0(value_0, 32)) , 64 - (high != 0?numberOfLeadingZeros_0(high):numberOfLeadingZeros_0(toInt_0(value_0)) + 32);
}

defineClass(222, 217, {3:1, 34:1, 217:1, 222:1}, BigDecimal, BigDecimal_0);
_.compareTo_0 = function compareTo_11(val){
  return $compareTo_10(this, castTo(val, 222));
}
;
_.doubleValue = function doubleValue_5(){
  return __parseAndValidateDouble($toString_5(this));
}
;
_.equals_0 = function equals_43(x_0){
  var x1;
  if (this === x_0) {
    return true;
  }
  if (instanceOf(x_0, 222)) {
    x1 = castTo(x_0, 222);
    return this.scale == x1.scale && $compareTo_10(this, x1) == 0;
  }
  return false;
}
;
_.hashCode_1 = function hashCode_39(){
  var longValue;
  if (this.hashCode_0 != 0) {
    return this.hashCode_0;
  }
  if (this.bitLength < 54) {
    longValue = fromDouble_0(this.smallValue);
    this.hashCode_0 = toInt_0(and_0(longValue, -1));
    this.hashCode_0 = 33 * this.hashCode_0 + toInt_0(and_0(shr_0(longValue, 32), -1));
    this.hashCode_0 = 17 * this.hashCode_0 + round_int(this.scale);
    return this.hashCode_0;
  }
  this.hashCode_0 = 17 * $hashCode_0(this.intVal) + round_int(this.scale);
  return this.hashCode_0;
}
;
_.toString_0 = function toString_51(){
  return $toString_5(this);
}
;
_.bitLength = 0;
_.hashCode_0 = 0;
_.precision = 0;
_.scale = 0;
_.smallValue = 0;
var BI_SCALED_BY_ZERO, CH_ZEROS, DOUBLE_FIVE_POW, DOUBLE_FIVE_POW_BIT_LENGTH, DOUBLE_TEN_POW, DOUBLE_TEN_POW_BIT_LENGTH, ZERO_SCALED_BY, unscaledRegex;
var Ljava_math_BigDecimal_2_classLit = createForClass('java.math', 'BigDecimal', 222);
function $clinit_BigInteger(){
  $clinit_BigInteger = emptyMethod;
  var i;
  ONE_0 = new BigInteger_0(1, 1);
  TEN = new BigInteger_0(1, 10);
  ZERO_0 = new BigInteger_0(0, 0);
  MINUS_ONE = new BigInteger_0(-1, 1);
  SMALL_VALUES = stampJavaTypeInfo(getClassLiteralForArray(Ljava_math_BigInteger_2_classLit, 1), $intern_33, 90, 0, [ZERO_0, ONE_0, new BigInteger_0(1, 2), new BigInteger_0(1, 3), new BigInteger_0(1, 4), new BigInteger_0(1, 5), new BigInteger_0(1, 6), new BigInteger_0(1, 7), new BigInteger_0(1, 8), new BigInteger_0(1, 9), TEN]);
  TWO_POWS = initUnidimensionalArray(Ljava_math_BigInteger_2_classLit, $intern_33, 90, 32, 0, 1);
  for (i = 0; i < TWO_POWS.length; i++) {
    TWO_POWS[i] = valueOf_11(shl_0(1, i));
  }
}

function $compareTo_11(this$static, val){
  if (this$static.sign > val.sign) {
    return 1;
  }
  if (this$static.sign < val.sign) {
    return -1;
  }
  if (this$static.numberLength > val.numberLength) {
    return this$static.sign;
  }
  if (this$static.numberLength < val.numberLength) {
    return -val.sign;
  }
  return this$static.sign * compareArrays(this$static.digits, val.digits, this$static.numberLength);
}

function $cutOffLeadingZeroes(this$static){
  while (this$static.numberLength > 0 && this$static.digits[--this$static.numberLength] == 0)
  ;
  this$static.digits[this$static.numberLength++] == 0 && (this$static.sign = 0);
}

function $equals_5(this$static, x_0){
  var x1;
  if (this$static === x_0) {
    return true;
  }
  if (instanceOf(x_0, 90)) {
    x1 = castTo(x_0, 90);
    return this$static.sign == x1.sign && this$static.numberLength == x1.numberLength && $equalsArrays(this$static, x1.digits);
  }
  return false;
}

function $equalsArrays(this$static, b){
  var i;
  for (i = this$static.numberLength - 1; i >= 0 && this$static.digits[i] === b[i]; i--)
  ;
  return i < 0;
}

function $getFirstNonzeroDigit(this$static){
  var i;
  if (this$static.firstNonzeroDigit == -2) {
    if (this$static.sign == 0) {
      i = -1;
    }
     else {
      for (i = 0; this$static.digits[i] == 0; i++)
      ;
    }
    this$static.firstNonzeroDigit = i;
  }
  return this$static.firstNonzeroDigit;
}

function $hashCode_0(this$static){
  var i;
  if (this$static.hashCode_0 != 0) {
    return this$static.hashCode_0;
  }
  for (i = 0; i < this$static.digits.length; i++) {
    this$static.hashCode_0 = this$static.hashCode_0 * 33 + (this$static.digits[i] & -1);
  }
  this$static.hashCode_0 = this$static.hashCode_0 * this$static.sign;
  return this$static.hashCode_0;
}

function $multiply(this$static, val){
  if (val.sign == 0) {
    return ZERO_0;
  }
  if (this$static.sign == 0) {
    return ZERO_0;
  }
  return $clinit_Multiplication() , karatsuba(this$static, val);
}

function $pow(this$static, exp_0){
  var x_0;
  if (exp_0 < 0) {
    throw toJs(new ArithmeticException('Negative exponent'));
  }
  if (exp_0 == 0) {
    return ONE_0;
  }
   else if (exp_0 == 1 || $equals_5(this$static, ONE_0) || $equals_5(this$static, ZERO_0)) {
    return this$static;
  }
  if (!$testBit(this$static, 0)) {
    x_0 = 1;
    while (!$testBit(this$static, x_0)) {
      ++x_0;
    }
    return $multiply(getPowerOfTwo(x_0 * exp_0), $pow($shiftRight(this$static, x_0), exp_0));
  }
  return pow_0(this$static, exp_0);
}

function $shiftLeft(this$static, n){
  if (n == 0 || this$static.sign == 0) {
    return this$static;
  }
  return n > 0?shiftLeft(this$static, n):shiftRight(this$static, -n);
}

function $shiftRight(this$static, n){
  if (n == 0 || this$static.sign == 0) {
    return this$static;
  }
  return n > 0?shiftRight(this$static, n):shiftLeft(this$static, -n);
}

function $testBit(this$static, n){
  var digit, firstNonZeroDigit, intCount;
  if (n == 0) {
    return (this$static.digits[0] & 1) != 0;
  }
  if (n < 0) {
    throw toJs(new ArithmeticException('Negative bit address'));
  }
  intCount = n >> 5;
  if (intCount >= this$static.numberLength) {
    return this$static.sign < 0;
  }
  digit = this$static.digits[intCount];
  n = 1 << (n & 31);
  if (this$static.sign < 0) {
    firstNonZeroDigit = $getFirstNonzeroDigit(this$static);
    if (intCount < firstNonZeroDigit) {
      return false;
    }
     else 
      firstNonZeroDigit == intCount?(digit = -digit):(digit = ~digit);
  }
  return (digit & n) != 0;
}

function BigInteger(sign, val){
  this.sign = sign;
  if (val < $intern_73) {
    this.numberLength = 1;
    this.digits = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [val | 0]);
  }
   else {
    this.numberLength = 2;
    this.digits = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [val % $intern_73 | 0, val / $intern_73 | 0]);
  }
}

function BigInteger_0(sign, value_0){
  $clinit_BigInteger();
  this.sign = sign;
  this.numberLength = 1;
  this.digits = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [value_0]);
}

function BigInteger_1(sign, numberLength, digits){
  $clinit_BigInteger();
  this.sign = sign;
  this.numberLength = numberLength;
  this.digits = digits;
}

function BigInteger_2(sign, val){
  this.sign = sign;
  if (eq(and_0(val, -4294967296), 0)) {
    this.numberLength = 1;
    this.digits = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [toInt_0(val)]);
  }
   else {
    this.numberLength = 2;
    this.digits = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [toInt_0(val), toInt_0(shr_0(val, 32))]);
  }
}

function BigInteger_3(digits){
  $clinit_BigInteger();
  if (digits.length == 0) {
    this.sign = 0;
    this.numberLength = 1;
    this.digits = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [0]);
  }
   else {
    this.sign = 1;
    this.numberLength = digits.length;
    this.digits = digits;
    $cutOffLeadingZeroes(this);
  }
}

function BigInteger_4(val){
  $clinit_BigInteger();
  BigInteger_5.call(this, val);
}

function BigInteger_5(val){
  checkCriticalNotNull(val);
  if (val.length == 0) {
    throw toJs(new NumberFormatException('Zero length BigInteger'));
  }
  setFromString(this, val);
}

function getPowerOfTwo(exp_0){
  var bitN, intCount, resDigits;
  if (exp_0 < TWO_POWS.length) {
    return TWO_POWS[exp_0];
  }
  intCount = exp_0 >> 5;
  bitN = exp_0 & 31;
  resDigits = initUnidimensionalArray(I_classLit, $intern_49, 23, intCount + 1, 15, 1);
  resDigits[intCount] = 1 << bitN;
  return new BigInteger_1(1, intCount + 1, resDigits);
}

function setFromString(bi, val){
  var bigRadix, bigRadixDigit, bigRadixDigitsLength, charsPerInt, digitIndex, digits, endChar, newDigit, sign, startChar, stringLength, substrEnd, substrStart, topChars;
  stringLength = val.length;
  endChar = stringLength;
  if (val.charCodeAt(0) == 45) {
    sign = -1;
    startChar = 1;
    --stringLength;
  }
   else {
    sign = 1;
    startChar = 0;
  }
  charsPerInt = ($clinit_Conversion() , digitFitInInt)[10];
  bigRadixDigitsLength = stringLength / charsPerInt | 0;
  topChars = stringLength % charsPerInt;
  topChars != 0 && ++bigRadixDigitsLength;
  digits = initUnidimensionalArray(I_classLit, $intern_49, 23, bigRadixDigitsLength, 15, 1);
  bigRadix = bigRadices[8];
  digitIndex = 0;
  substrEnd = startChar + (topChars == 0?charsPerInt:topChars);
  for (substrStart = startChar; substrStart < endChar; substrStart = substrEnd , substrEnd = substrEnd + charsPerInt) {
    bigRadixDigit = __parseAndValidateInt(val.substr(substrStart, substrEnd - substrStart), $intern_43, $intern_0);
    newDigit = ($clinit_Multiplication() , multiplyByInt(digits, digits, digitIndex, bigRadix));
    newDigit += inplaceAdd(digits, digitIndex, bigRadixDigit);
    digits[digitIndex++] = newDigit;
  }
  bi.sign = sign;
  bi.numberLength = digitIndex;
  bi.digits = digits;
  $cutOffLeadingZeroes(bi);
}

function valueOf_10(val){
  $clinit_BigInteger();
  if (val < 0) {
    if (val != -1) {
      return new BigInteger(-1, -val);
    }
    return MINUS_ONE;
  }
   else 
    return val <= 10?SMALL_VALUES[round_int(val)]:new BigInteger(1, val);
}

function valueOf_11(val){
  $clinit_BigInteger();
  if (compare_3(val, 0) < 0) {
    if (compare_3(val, -1) != 0) {
      return new BigInteger_2(-1, neg_0(val));
    }
    return MINUS_ONE;
  }
   else 
    return compare_3(val, 10) <= 0?SMALL_VALUES[toInt_0(val)]:new BigInteger_2(1, val);
}

defineClass(90, 217, {3:1, 34:1, 217:1, 90:1}, BigInteger, BigInteger_0, BigInteger_1, BigInteger_2, BigInteger_3, BigInteger_4);
_.compareTo_0 = function compareTo_12(val){
  return $compareTo_11(this, castTo(val, 90));
}
;
_.doubleValue = function doubleValue_6(){
  return __parseAndValidateDouble(toDecimalScaledString_0(this, 0));
}
;
_.equals_0 = function equals_44(x_0){
  return $equals_5(this, x_0);
}
;
_.hashCode_1 = function hashCode_40(){
  return $hashCode_0(this);
}
;
_.toString_0 = function toString_52(){
  return toDecimalScaledString_0(this, 0);
}
;
_.firstNonzeroDigit = -2;
_.hashCode_0 = 0;
_.numberLength = 0;
_.sign = 0;
var MINUS_ONE, ONE_0, SMALL_VALUES, TEN, TWO_POWS, ZERO_0;
var Ljava_math_BigInteger_2_classLit = createForClass('java.math', 'BigInteger', 90);
function bitLength_1(val){
  var bLength, highDigit, i;
  if (val.sign == 0) {
    return 0;
  }
  bLength = val.numberLength << 5;
  highDigit = val.digits[val.numberLength - 1];
  if (val.sign < 0) {
    i = $getFirstNonzeroDigit(val);
    if (i == val.numberLength - 1) {
      --highDigit;
      highDigit = highDigit | 0;
    }
  }
  bLength -= numberOfLeadingZeros_0(highDigit);
  return bLength;
}

function shiftLeft(source, count){
  var intCount, resDigits, resLength, result;
  intCount = count >> 5;
  count &= 31;
  resLength = source.numberLength + intCount + (count == 0?0:1);
  resDigits = initUnidimensionalArray(I_classLit, $intern_49, 23, resLength, 15, 1);
  shiftLeft_0(resDigits, source.digits, intCount, count);
  result = new BigInteger_1(source.sign, resLength, resDigits);
  $cutOffLeadingZeroes(result);
  return result;
}

function shiftLeft_0(result, source, intCount, count){
  var i, i0, rightShiftCount;
  if (count == 0) {
    arraycopy(source, 0, result, intCount, result.length - intCount);
  }
   else {
    rightShiftCount = 32 - count;
    result[result.length - 1] = 0;
    for (i0 = result.length - 1; i0 > intCount; i0--) {
      result[i0] |= source[i0 - intCount - 1] >>> rightShiftCount;
      result[i0 - 1] = source[i0 - intCount - 1] << count;
    }
  }
  for (i = 0; i < intCount; i++) {
    result[i] = 0;
  }
}

function shiftLeftOneBit(result, source, srcLen){
  var carry, i, val;
  carry = 0;
  for (i = 0; i < srcLen; i++) {
    val = source[i];
    result[i] = val << 1 | carry;
    carry = val >>> 31;
  }
  carry != 0 && (result[srcLen] = carry);
}

function shiftRight(source, count){
  var i, intCount, resDigits, resLength, result;
  intCount = count >> 5;
  count &= 31;
  if (intCount >= source.numberLength) {
    return source.sign < 0?($clinit_BigInteger() , MINUS_ONE):($clinit_BigInteger() , ZERO_0);
  }
  resLength = source.numberLength - intCount;
  resDigits = initUnidimensionalArray(I_classLit, $intern_49, 23, resLength + 1, 15, 1);
  shiftRight_0(resDigits, resLength, source.digits, intCount, count);
  if (source.sign < 0) {
    for (i = 0; i < intCount && source.digits[i] == 0; i++)
    ;
    if (i < intCount || count > 0 && source.digits[i] << 32 - count != 0) {
      for (i = 0; i < resLength && resDigits[i] == -1; i++) {
        resDigits[i] = 0;
      }
      i == resLength && ++resLength;
      ++resDigits[i];
    }
  }
  result = new BigInteger_1(source.sign, resLength, resDigits);
  $cutOffLeadingZeroes(result);
  return result;
}

function shiftRight_0(result, resultLen, source, intCount, count){
  var allZero, i, leftShiftCount;
  allZero = true;
  for (i = 0; i < intCount; i++) {
    allZero = allZero & source[i] == 0;
  }
  if (count == 0) {
    arraycopy(source, intCount, result, 0, resultLen);
  }
   else {
    leftShiftCount = 32 - count;
    allZero = allZero & source[i] << leftShiftCount == 0;
    for (i = 0; i < resultLen - 1; i++) {
      result[i] = source[i + intCount] >>> count | source[i + intCount + 1] << leftShiftCount;
    }
    result[i] = source[i + intCount] >>> count;
    ++i;
  }
  return allZero;
}

function $clinit_Conversion(){
  $clinit_Conversion = emptyMethod;
  bigRadices = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [$intern_43, 1162261467, $intern_24, 1220703125, 362797056, 1977326743, $intern_24, 387420489, $intern_57, 214358881, 429981696, 815730721, 1475789056, 170859375, 268435456, 410338673, 612220032, 893871739, 1280000000, 1801088541, 113379904, 148035889, 191102976, 244140625, 308915776, 387420489, 481890304, 594823321, 729000000, 887503681, $intern_24, 1291467969, 1544804416, 1838265625, 60466176]);
  digitFitInInt = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [-1, -1, 31, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5]);
}

function divideLongByBillion(a){
  var aPos, quot, rem;
  if (compare_3(a, 0) >= 0) {
    quot = div(a, $intern_57);
    rem = mod(a, $intern_57);
  }
   else {
    aPos = shru_0(a, 1);
    quot = div(aPos, 500000000);
    rem = mod(aPos, 500000000);
    rem = add_20(shl_0(rem, 1), and_0(a, 1));
  }
  return or_0(shl_0(rem, 32), and_0(quot, $intern_72));
}

function toDecimalScaledString(value_0, scale){
  $clinit_Conversion();
  var currentChar, exponent, insertPoint, j, j0, negNumber, prev, result, result1, result10, startPoint, v;
  negNumber = compare_3(value_0, 0) < 0;
  negNumber && (value_0 = neg_0(value_0));
  if (compare_3(value_0, 0) == 0) {
    switch (scale) {
      case 0:
        return '0';
      case 1:
        return '0.0';
      case 2:
        return '0.00';
      case 3:
        return '0.000';
      case 4:
        return '0.0000';
      case 5:
        return '0.00000';
      case 6:
        return '0.000000';
      default:result10 = new StringBuilder;
        scale < 0?(result10.string += '0E+' , result10):(result10.string += '0E' , result10);
        result10.string += scale == $intern_43?'2147483648':'' + -scale;
        return result10.string;
    }
  }
  result = initUnidimensionalArray(C_classLit, $intern_45, 23, 19, 15, 1);
  currentChar = 18;
  v = value_0;
  do {
    prev = v;
    v = div(v, 10);
    result[--currentChar] = toInt_0(add_20(48, sub_2(prev, mul_0(v, 10)))) & $intern_47;
  }
   while (compare_3(v, 0) != 0);
  exponent = sub_2(sub_2(sub_2(18, currentChar), scale), 1);
  if (scale == 0) {
    negNumber && (result[--currentChar] = 45);
    return valueOf_9(result, currentChar, 18 - currentChar);
  }
  if (scale > 0 && compare_3(exponent, -6) >= 0) {
    if (compare_3(exponent, 0) >= 0) {
      insertPoint = currentChar + toInt_0(exponent);
      for (j0 = 17; j0 >= insertPoint; j0--) {
        result[j0 + 1] = result[j0];
      }
      result[++insertPoint] = 46;
      negNumber && (result[--currentChar] = 45);
      return valueOf_9(result, currentChar, 18 - currentChar + 1);
    }
    for (j = 2; lt(j, add_20(neg_0(exponent), 1)); j++) {
      result[--currentChar] = 48;
    }
    result[--currentChar] = 46;
    result[--currentChar] = 48;
    negNumber && (result[--currentChar] = 45);
    return valueOf_9(result, currentChar, 18 - currentChar);
  }
  startPoint = currentChar + 1;
  result1 = new StringBuilder_0;
  negNumber && (result1.string += '-' , result1);
  if (18 - startPoint >= 1) {
    $append_5(result1, result[currentChar]);
    result1.string += '.';
    result1.string += valueOf_9(result, currentChar + 1, 18 - currentChar - 1);
  }
   else {
    result1.string += valueOf_9(result, currentChar, 18 - currentChar);
  }
  result1.string += 'E';
  compare_3(exponent, 0) > 0 && (result1.string += '+' , result1);
  result1.string += '' + toString_40(exponent);
  return result1.string;
}

function toDecimalScaledString_0(val, scale){
  $clinit_Conversion();
  var currentChar, delta, digits, exponent, highDigit, i, i1, insertPoint, j, j0, negNumber, numberLength, prev, previous, res, resDigit, resLengthInChars, result, result1, result10, result11, sign, startPoint, temp, temp1, tempLen, v;
  sign = val.sign;
  numberLength = val.numberLength;
  digits = val.digits;
  if (sign == 0) {
    switch (scale) {
      case 0:
        return '0';
      case 1:
        return '0.0';
      case 2:
        return '0.00';
      case 3:
        return '0.000';
      case 4:
        return '0.0000';
      case 5:
        return '0.00000';
      case 6:
        return '0.000000';
      default:result10 = new StringBuilder;
        scale < 0?(result10.string += '0E+' , result10):(result10.string += '0E' , result10);
        result10.string += -scale;
        return result10.string;
    }
  }
  resLengthInChars = numberLength * 10 + 1 + 7;
  result = initUnidimensionalArray(C_classLit, $intern_45, 23, resLengthInChars + 1, 15, 1);
  currentChar = resLengthInChars;
  if (numberLength == 1) {
    highDigit = digits[0];
    if (highDigit < 0) {
      v = and_0(highDigit, $intern_72);
      do {
        prev = v;
        v = div(v, 10);
        result[--currentChar] = 48 + toInt_0(sub_2(prev, mul_0(v, 10))) & $intern_47;
      }
       while (compare_3(v, 0) != 0);
    }
     else {
      v = highDigit;
      do {
        prev = v;
        v = v / 10 | 0;
        result[--currentChar] = 48 + (prev - v * 10) & $intern_47;
      }
       while (v != 0);
    }
  }
   else {
    temp = initUnidimensionalArray(I_classLit, $intern_49, 23, numberLength, 15, 1);
    tempLen = numberLength;
    arraycopy(digits, 0, temp, 0, numberLength);
    BIG_LOOP: while (true) {
      result11 = 0;
      for (i1 = tempLen - 1; i1 >= 0; i1--) {
        temp1 = add_20(shl_0(result11, 32), and_0(temp[i1], $intern_72));
        res = divideLongByBillion(temp1);
        temp[i1] = toInt_0(res);
        result11 = toInt_0(shr_0(res, 32));
      }
      resDigit = toInt_0(result11);
      previous = currentChar;
      do {
        result[--currentChar] = 48 + resDigit % 10 & $intern_47;
      }
       while ((resDigit = resDigit / 10 | 0) != 0 && currentChar != 0);
      delta = 9 - previous + currentChar;
      for (i = 0; i < delta && currentChar > 0; i++) {
        result[--currentChar] = 48;
      }
      j = tempLen - 1;
      for (; temp[j] == 0; j--) {
        if (j == 0) {
          break BIG_LOOP;
        }
      }
      tempLen = j + 1;
    }
    while (result[currentChar] == 48) {
      ++currentChar;
    }
  }
  negNumber = sign < 0;
  exponent = resLengthInChars - currentChar - scale - 1;
  if (scale == 0) {
    negNumber && (result[--currentChar] = 45);
    return valueOf_9(result, currentChar, resLengthInChars - currentChar);
  }
  if (scale > 0 && exponent >= -6) {
    if (exponent >= 0) {
      insertPoint = currentChar + exponent;
      for (j0 = resLengthInChars - 1; j0 >= insertPoint; j0--) {
        result[j0 + 1] = result[j0];
      }
      result[++insertPoint] = 46;
      negNumber && (result[--currentChar] = 45);
      return valueOf_9(result, currentChar, resLengthInChars - currentChar + 1);
    }
    for (j = 2; j < -exponent + 1; j++) {
      result[--currentChar] = 48;
    }
    result[--currentChar] = 46;
    result[--currentChar] = 48;
    negNumber && (result[--currentChar] = 45);
    return valueOf_9(result, currentChar, resLengthInChars - currentChar);
  }
  startPoint = currentChar + 1;
  result1 = new StringBuilder_0;
  negNumber && (result1.string += '-' , result1);
  if (resLengthInChars - startPoint >= 1) {
    $append_5(result1, result[currentChar]);
    result1.string += '.';
    result1.string += valueOf_9(result, currentChar + 1, resLengthInChars - currentChar - 1);
  }
   else {
    result1.string += valueOf_9(result, currentChar, resLengthInChars - currentChar);
  }
  result1.string += 'E';
  exponent > 0 && (result1.string += '+' , result1);
  result1.string += '' + exponent;
  return result1.string;
}

var bigRadices, digitFitInInt;
function add_21(op1, op2){
  var a, b, cmp, op1Len, op1Sign, op2Len, op2Sign, res, res0, resDigits, resSign, valueHi, valueLo;
  op1Sign = op1.sign;
  op2Sign = op2.sign;
  if (op1Sign == 0) {
    return op2;
  }
  if (op2Sign == 0) {
    return op1;
  }
  op1Len = op1.numberLength;
  op2Len = op2.numberLength;
  if (op1Len + op2Len == 2) {
    a = and_0(op1.digits[0], $intern_72);
    b = and_0(op2.digits[0], $intern_72);
    if (op1Sign == op2Sign) {
      res0 = add_20(a, b);
      valueLo = toInt_0(res0);
      valueHi = toInt_0(shru_0(res0, 32));
      return valueHi == 0?new BigInteger_0(op1Sign, valueLo):new BigInteger_1(op1Sign, 2, stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [valueLo, valueHi]));
    }
    return valueOf_11(op1Sign < 0?sub_2(b, a):sub_2(a, b));
  }
   else if (op1Sign == op2Sign) {
    resSign = op1Sign;
    resDigits = op1Len >= op2Len?add_22(op1.digits, op1Len, op2.digits, op2Len):add_22(op2.digits, op2Len, op1.digits, op1Len);
  }
   else {
    cmp = op1Len != op2Len?op1Len > op2Len?1:-1:compareArrays(op1.digits, op2.digits, op1Len);
    if (cmp == 0) {
      return $clinit_BigInteger() , ZERO_0;
    }
    if (cmp == 1) {
      resSign = op1Sign;
      resDigits = subtract_0(op1.digits, op1Len, op2.digits, op2Len);
    }
     else {
      resSign = op2Sign;
      resDigits = subtract_0(op2.digits, op2Len, op1.digits, op1Len);
    }
  }
  res = new BigInteger_1(resSign, resDigits.length, resDigits);
  $cutOffLeadingZeroes(res);
  return res;
}

function add_22(a, aSize, b, bSize){
  var res;
  res = initUnidimensionalArray(I_classLit, $intern_49, 23, aSize + 1, 15, 1);
  add_23(res, a, aSize, b, bSize);
  return res;
}

function add_23(res, a, aSize, b, bSize){
  var carry, i;
  carry = add_20(and_0(a[0], $intern_72), and_0(b[0], $intern_72));
  res[0] = toInt_0(carry);
  carry = shr_0(carry, 32);
  if (aSize >= bSize) {
    for (i = 1; i < bSize; i++) {
      carry = add_20(carry, add_20(and_0(a[i], $intern_72), and_0(b[i], $intern_72)));
      res[i] = toInt_0(carry);
      carry = shr_0(carry, 32);
    }
    for (; i < aSize; i++) {
      carry = add_20(carry, and_0(a[i], $intern_72));
      res[i] = toInt_0(carry);
      carry = shr_0(carry, 32);
    }
  }
   else {
    for (i = 1; i < aSize; i++) {
      carry = add_20(carry, add_20(and_0(a[i], $intern_72), and_0(b[i], $intern_72)));
      res[i] = toInt_0(carry);
      carry = shr_0(carry, 32);
    }
    for (; i < bSize; i++) {
      carry = add_20(carry, and_0(b[i], $intern_72));
      res[i] = toInt_0(carry);
      carry = shr_0(carry, 32);
    }
  }
  compare_3(carry, 0) != 0 && (res[i] = toInt_0(carry));
}

function compareArrays(a, b, size_0){
  var i;
  for (i = size_0 - 1; i >= 0 && a[i] === b[i]; i--)
  ;
  return i < 0?0:lt(and_0(a[i], $intern_72), and_0(b[i], $intern_72))?-1:1;
}

function inplaceAdd(a, aSize, addend){
  var carry, i;
  carry = and_0(addend, $intern_72);
  for (i = 0; compare_3(carry, 0) != 0 && i < aSize; i++) {
    carry = add_20(carry, and_0(a[i], $intern_72));
    a[i] = toInt_0(carry);
    carry = shr_0(carry, 32);
  }
  return toInt_0(carry);
}

function subtract(op1, op2){
  var a, b, cmp, op1Len, op1Sign, op2Len, op2Sign, res, resDigits, resSign;
  op1Sign = op1.sign;
  op2Sign = op2.sign;
  if (op2Sign == 0) {
    return op1;
  }
  if (op1Sign == 0) {
    return op2.sign == 0?op2:new BigInteger_1(-op2.sign, op2.numberLength, op2.digits);
  }
  op1Len = op1.numberLength;
  op2Len = op2.numberLength;
  if (op1Len + op2Len == 2) {
    a = and_0(op1.digits[0], $intern_72);
    b = and_0(op2.digits[0], $intern_72);
    op1Sign < 0 && (a = neg_0(a));
    op2Sign < 0 && (b = neg_0(b));
    return valueOf_11(sub_2(a, b));
  }
  cmp = op1Len != op2Len?op1Len > op2Len?1:-1:compareArrays(op1.digits, op2.digits, op1Len);
  if (cmp == -1) {
    resSign = -op2Sign;
    resDigits = op1Sign == op2Sign?subtract_0(op2.digits, op2Len, op1.digits, op1Len):add_22(op2.digits, op2Len, op1.digits, op1Len);
  }
   else {
    resSign = op1Sign;
    if (op1Sign == op2Sign) {
      if (cmp == 0) {
        return $clinit_BigInteger() , ZERO_0;
      }
      resDigits = subtract_0(op1.digits, op1Len, op2.digits, op2Len);
    }
     else {
      resDigits = add_22(op1.digits, op1Len, op2.digits, op2Len);
    }
  }
  res = new BigInteger_1(resSign, resDigits.length, resDigits);
  $cutOffLeadingZeroes(res);
  return res;
}

function subtract_0(a, aSize, b, bSize){
  var res;
  res = initUnidimensionalArray(I_classLit, $intern_49, 23, aSize, 15, 1);
  subtract_1(res, a, aSize, b, bSize);
  return res;
}

function subtract_1(res, a, aSize, b, bSize){
  var borrow, i;
  borrow = 0;
  for (i = 0; i < bSize; i++) {
    borrow = add_20(borrow, sub_2(and_0(a[i], $intern_72), and_0(b[i], $intern_72)));
    res[i] = toInt_0(borrow);
    borrow = shr_0(borrow, 32);
  }
  for (; i < aSize; i++) {
    borrow = add_20(borrow, and_0(a[i], $intern_72));
    res[i] = toInt_0(borrow);
    borrow = shr_0(borrow, 32);
  }
}

function $clinit_Multiplication(){
  $clinit_Multiplication = emptyMethod;
  var fivePow, i;
  bigFivePows = initUnidimensionalArray(Ljava_math_BigInteger_2_classLit, $intern_33, 90, 32, 0, 1);
  bigTenPows = initUnidimensionalArray(Ljava_math_BigInteger_2_classLit, $intern_33, 90, 32, 0, 1);
  fivePow = 1;
  for (i = 0; i <= 18; i++) {
    bigFivePows[i] = valueOf_11(fivePow);
    bigTenPows[i] = valueOf_11(shl_0(fivePow, i));
    fivePow = mul_0(fivePow, 5);
  }
  for (; i < bigTenPows.length; i++) {
    bigFivePows[i] = $multiply(bigFivePows[i - 1], bigFivePows[1]);
    bigTenPows[i] = $multiply(bigTenPows[i - 1], ($clinit_BigInteger() , TEN));
  }
}

function karatsuba(op1, op2){
  $clinit_Multiplication();
  var lower, lowerOp1, lowerOp2, middle, ndiv2, temp, upper, upperOp1, upperOp2;
  if (op2.numberLength > op1.numberLength) {
    temp = op1;
    op1 = op2;
    op2 = temp;
  }
  if (op2.numberLength < 63) {
    return multiplyPAP(op1, op2);
  }
  ndiv2 = (op1.numberLength & -2) << 4;
  upperOp1 = $shiftRight(op1, ndiv2);
  upperOp2 = $shiftRight(op2, ndiv2);
  lowerOp1 = subtract(op1, $shiftLeft(upperOp1, ndiv2));
  lowerOp2 = subtract(op2, $shiftLeft(upperOp2, ndiv2));
  upper = karatsuba(upperOp1, upperOp2);
  lower = karatsuba(lowerOp1, lowerOp2);
  middle = karatsuba(subtract(upperOp1, lowerOp1), subtract(lowerOp2, upperOp2));
  middle = add_21(add_21(middle, upper), lower);
  middle = $shiftLeft(middle, ndiv2);
  upper = $shiftLeft(upper, ndiv2 << 1);
  return add_21(add_21(upper, middle), lower);
}

function multArraysPAP(aDigits, aLen, bDigits, bLen, resDigits){
  if (aLen == 0 || bLen == 0) {
    return;
  }
  aLen == 1?(resDigits[bLen] = multiplyByInt(resDigits, bDigits, bLen, aDigits[0])):bLen == 1?(resDigits[aLen] = multiplyByInt(resDigits, aDigits, aLen, bDigits[0])):multPAP(aDigits, bDigits, resDigits, aLen, bLen);
}

function multPAP(a, b, t, aLen, bLen){
  var aI, carry, i, j;
  if (maskUndefined(a) === maskUndefined(b) && aLen == bLen) {
    square(a, aLen, t);
    return;
  }
  for (i = 0; i < aLen; i++) {
    carry = 0;
    aI = a[i];
    for (j = 0; j < bLen; j++) {
      carry = add_20(add_20(mul_0(and_0(aI, $intern_72), and_0(b[j], $intern_72)), and_0(t[i + j], $intern_72)), and_0(toInt_0(carry), $intern_72));
      t[i + j] = toInt_0(carry);
      carry = shru_0(carry, 32);
    }
    t[i + bLen] = toInt_0(carry);
  }
}

function multiplyByInt(res, a, aSize, factor){
  $clinit_Multiplication();
  var carry, i;
  carry = 0;
  for (i = 0; i < aSize; i++) {
    carry = add_20(mul_0(and_0(a[i], $intern_72), and_0(factor, $intern_72)), and_0(toInt_0(carry), $intern_72));
    res[i] = toInt_0(carry);
    carry = shru_0(carry, 32);
  }
  return toInt_0(carry);
}

function multiplyPAP(a, b){
  var aDigits, aLen, bDigits, bLen, resDigits, resLength, resSign, result, val, valueHi, valueLo;
  aLen = a.numberLength;
  bLen = b.numberLength;
  resLength = aLen + bLen;
  resSign = a.sign != b.sign?-1:1;
  if (resLength == 2) {
    val = mul_0(and_0(a.digits[0], $intern_72), and_0(b.digits[0], $intern_72));
    valueLo = toInt_0(val);
    valueHi = toInt_0(shru_0(val, 32));
    return valueHi == 0?new BigInteger_0(resSign, valueLo):new BigInteger_1(resSign, 2, stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [valueLo, valueHi]));
  }
  aDigits = a.digits;
  bDigits = b.digits;
  resDigits = initUnidimensionalArray(I_classLit, $intern_49, 23, resLength, 15, 1);
  multArraysPAP(aDigits, aLen, bDigits, bLen, resDigits);
  result = new BigInteger_1(resSign, resLength, resDigits);
  $cutOffLeadingZeroes(result);
  return result;
}

function pow_0(base, exponent){
  $clinit_Multiplication();
  var acc, res;
  res = ($clinit_BigInteger() , ONE_0);
  acc = base;
  for (; exponent > 1; exponent >>= 1) {
    (exponent & 1) != 0 && (res = $multiply(res, acc));
    acc.numberLength == 1?(acc = $multiply(acc, acc)):(acc = new BigInteger_3(square(acc.digits, acc.numberLength, initUnidimensionalArray(I_classLit, $intern_49, 23, acc.numberLength << 1, 15, 1))));
  }
  res = $multiply(res, acc);
  return res;
}

function powerOf10(exp_0){
  $clinit_Multiplication();
  var intExp, longExp, powerOfFive, res;
  intExp = round_int(exp_0);
  if (exp_0 < bigTenPows.length) {
    return bigTenPows[intExp];
  }
   else if (exp_0 <= 50) {
    return $pow(($clinit_BigInteger() , TEN), intExp);
  }
   else if (exp_0 <= $intern_46) {
    return $shiftLeft($pow(bigFivePows[1], intExp), intExp);
  }
  if (exp_0 > 1000000) {
    throw toJs(new ArithmeticException('power of ten too big'));
  }
  if (exp_0 <= $intern_0) {
    return $shiftLeft($pow(bigFivePows[1], intExp), intExp);
  }
  powerOfFive = $pow(bigFivePows[1], $intern_0);
  res = powerOfFive;
  longExp = fromDouble_0(exp_0 - $intern_0);
  intExp = round_int(exp_0 % $intern_0);
  while (compare_3(longExp, $intern_0) > 0) {
    res = $multiply(res, powerOfFive);
    longExp = sub_2(longExp, $intern_0);
  }
  res = $multiply(res, $pow(bigFivePows[1], intExp));
  res = $shiftLeft(res, $intern_0);
  longExp = fromDouble_0(exp_0 - $intern_0);
  while (compare_3(longExp, $intern_0) > 0) {
    res = $shiftLeft(res, $intern_0);
    longExp = sub_2(longExp, $intern_0);
  }
  res = $shiftLeft(res, intExp);
  return res;
}

function square(a, aLen, res){
  var carry, i, i0, index_0, j;
  for (i0 = 0; i0 < aLen; i0++) {
    carry = 0;
    for (j = i0 + 1; j < aLen; j++) {
      carry = add_20(add_20(mul_0(and_0(a[i0], $intern_72), and_0(a[j], $intern_72)), and_0(res[i0 + j], $intern_72)), and_0(toInt_0(carry), $intern_72));
      res[i0 + j] = toInt_0(carry);
      carry = shru_0(carry, 32);
    }
    res[i0 + aLen] = toInt_0(carry);
  }
  shiftLeftOneBit(res, res, aLen << 1);
  carry = 0;
  for (i = 0 , index_0 = 0; i < aLen; ++i , index_0++) {
    carry = add_20(add_20(mul_0(and_0(a[i], $intern_72), and_0(a[i], $intern_72)), and_0(res[index_0], $intern_72)), and_0(toInt_0(carry), $intern_72));
    res[index_0] = toInt_0(carry);
    carry = shru_0(carry, 32);
    ++index_0;
    carry = add_20(carry, and_0(res[index_0], $intern_72));
    res[index_0] = toInt_0(carry);
    carry = shru_0(carry, 32);
  }
  return res;
}

var bigFivePows, bigTenPows;
function $containsKey_2(this$static, key){
  return instanceOfString(key)?$hasStringValue(this$static, key):!!$getEntry(this$static.hashCodeMap, key);
}

function $containsValue_1(this$static, value_0, entries){
  var entry, entry$iterator;
  for (entry$iterator = entries.iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    if (this$static.equals_1(value_0, entry.getValue())) {
      return true;
    }
  }
  return false;
}

function $get_6(this$static, key){
  return instanceOfString(key)?$getStringValue(this$static, key):getEntryValueOrNull($getEntry(this$static.hashCodeMap, key));
}

function $getStringValue(this$static, key){
  return key == null?getEntryValueOrNull($getEntry(this$static.hashCodeMap, null)):$get_11(this$static.stringMap, key);
}

function $hasStringValue(this$static, key){
  return key == null?!!$getEntry(this$static.hashCodeMap, null):$contains_7(this$static.stringMap, key);
}

function $put_1(this$static, key, value_0){
  return instanceOfString(key)?$putStringValue(this$static, key, value_0):$put_4(this$static.hashCodeMap, key, value_0);
}

function $putStringValue(this$static, key, value_0){
  return key == null?$put_4(this$static.hashCodeMap, null, value_0):$put_5(this$static.stringMap, key, value_0);
}

function $remove_7(this$static, key){
  return instanceOfString(key)?key == null?$remove_19(this$static.hashCodeMap, null):$remove_20(this$static.stringMap, key):$remove_19(this$static.hashCodeMap, key);
}

function $reset(this$static){
  var modCount;
  this$static.hashCodeMap = new InternalHashCodeMap(this$static);
  this$static.stringMap = new InternalStringMap(this$static);
  modCount = this$static['_gwt_modCount'] | 0;
  this$static['_gwt_modCount'] = modCount + 1;
}

function $size_0(this$static){
  return this$static.hashCodeMap.size_0 + this$static.stringMap.size_0;
}

function AbstractHashMap(ignored, alsoIgnored){
  checkCriticalArgument_0(ignored >= 0, 'Negative initial capacity');
  checkCriticalArgument_0(alsoIgnored >= 0, 'Non-positive load factor');
  $reset(this);
}

defineClass(457, 1750, $intern_2);
_.clear_0 = function clear_27(){
  $reset(this);
}
;
_.containsKey = function containsKey_5(key){
  return $containsKey_2(this, key);
}
;
_.containsValue = function containsValue_2(value_0){
  return $containsValue_1(this, value_0, this.stringMap) || $containsValue_1(this, value_0, this.hashCodeMap);
}
;
_.entrySet_0 = function entrySet_2(){
  return new AbstractHashMap$EntrySet(this);
}
;
_.get_0 = function get_20(key){
  return $get_6(this, key);
}
;
_.put = function put_3(key, value_0){
  return $put_1(this, key, value_0);
}
;
_.remove = function remove_48(key){
  return $remove_7(this, key);
}
;
_.size_1 = function size_29(){
  return $size_0(this);
}
;
var Ljava_util_AbstractHashMap_2_classLit = createForClass('java.util', 'AbstractHashMap', 457);
function $contains_1(this$static, o){
  if (instanceOf(o, 39)) {
    return $containsEntry_0(this$static.this$01, castTo(o, 39));
  }
  return false;
}

function AbstractHashMap$EntrySet(this$0){
  this.this$01 = this$0;
}

defineClass(252, $intern_13, $intern_14, AbstractHashMap$EntrySet);
_.clear_0 = function clear_28(){
  this.this$01.clear_0();
}
;
_.contains = function contains_23(o){
  return $contains_1(this, o);
}
;
_.iterator_0 = function iterator_39(){
  return new AbstractHashMap$EntrySetIterator(this.this$01);
}
;
_.remove_1 = function remove_49(entry){
  var key;
  if ($contains_1(this, entry)) {
    key = castTo(entry, 39).getKey();
    this.this$01.remove(key);
    return true;
  }
  return false;
}
;
_.size_1 = function size_30(){
  return this.this$01.size_1();
}
;
var Ljava_util_AbstractHashMap$EntrySet_2_classLit = createForClass('java.util', 'AbstractHashMap/EntrySet', 252);
function $computeHasNext(this$static){
  if (this$static.current.hasNext_0()) {
    return true;
  }
  if (this$static.current != this$static.stringMapEntries) {
    return false;
  }
  this$static.current = new InternalHashCodeMap$1(this$static.this$01.hashCodeMap);
  return this$static.current.hasNext_0();
}

function $next_7(this$static){
  var rv;
  checkStructuralChange(this$static.this$01, this$static);
  checkCriticalElement(this$static.hasNext);
  this$static.last = this$static.current;
  rv = castTo(this$static.current.next_1(), 39);
  this$static.hasNext = $computeHasNext(this$static);
  return rv;
}

function $remove_8(this$static){
  checkCriticalState(!!this$static.last);
  checkStructuralChange(this$static.this$01, this$static);
  this$static.last.remove_0();
  this$static.last = null;
  this$static.hasNext = $computeHasNext(this$static);
  recordLastKnownStructure(this$static.this$01, this$static);
}

function AbstractHashMap$EntrySetIterator(this$0){
  var modCount;
  this.this$01 = this$0;
  this.stringMapEntries = new InternalStringMap$1(this.this$01.stringMap);
  this.current = this.stringMapEntries;
  this.hasNext = $computeHasNext(this);
  modCount = this$0['_gwt_modCount'];
  this['_gwt_modCount'] = modCount;
}

defineClass(253, 1, $intern_4, AbstractHashMap$EntrySetIterator);
_.forEachRemaining = function forEachRemaining_18(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_21(){
  return $next_7(this);
}
;
_.hasNext_0 = function hasNext_20(){
  return this.hasNext;
}
;
_.remove_0 = function remove_50(){
  $remove_8(this);
}
;
_.hasNext = false;
var Ljava_util_AbstractHashMap$EntrySetIterator_2_classLit = createForClass('java.util', 'AbstractHashMap/EntrySetIterator', 253);
function $hasNext_1(this$static){
  return this$static.i < this$static.this$01_0.size_1();
}

function $next_8(this$static){
  checkCriticalElement(this$static.i < this$static.this$01_0.size_1());
  return this$static.this$01_0.get_3(this$static.last = this$static.i++);
}

function $remove_9(this$static){
  checkCriticalState(this$static.last != -1);
  this$static.this$01_0.remove_2(this$static.last);
  this$static.i = this$static.last;
  this$static.last = -1;
}

function AbstractList$IteratorImpl(this$0){
  this.this$01_0 = this$0;
}

defineClass(394, 1, $intern_4, AbstractList$IteratorImpl);
_.forEachRemaining = function forEachRemaining_19(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_21(){
  return $hasNext_1(this);
}
;
_.next_1 = function next_22(){
  return $next_8(this);
}
;
_.remove_0 = function remove_51(){
  $remove_9(this);
}
;
_.i = 0;
_.last = -1;
var Ljava_util_AbstractList$IteratorImpl_2_classLit = createForClass('java.util', 'AbstractList/IteratorImpl', 394);
function $add_2(this$static, o){
  this$static.this$01.add_3(this$static.i, o);
  ++this$static.i;
  this$static.last = -1;
}

function AbstractList$ListIteratorImpl(this$0, start_0){
  this.this$01 = this$0;
  AbstractList$IteratorImpl.call(this, this$0);
  checkCriticalPositionIndex(start_0, this$0.size_1());
  this.i = start_0;
}

defineClass(96, 394, $intern_18, AbstractList$ListIteratorImpl);
_.remove_0 = function remove_52(){
  $remove_9(this);
}
;
_.add_2 = function add_24(o){
  $add_2(this, o);
}
;
_.hasPrevious = function hasPrevious_5(){
  return this.i > 0;
}
;
_.nextIndex_0 = function nextIndex_6(){
  return this.i;
}
;
_.previous_0 = function previous_6(){
  return checkCriticalElement(this.i > 0) , this.this$01.get_3(this.last = --this.i);
}
;
_.previousIndex = function previousIndex_5(){
  return this.i - 1;
}
;
_.set_1 = function set_12(o){
  checkCriticalState(this.last != -1);
  this.this$01.set_2(this.last, o);
}
;
var Ljava_util_AbstractList$ListIteratorImpl_2_classLit = createForClass('java.util', 'AbstractList/ListIteratorImpl', 96);
function AbstractList$SubList(wrapped, fromIndex, toIndex){
  checkCriticalPositionIndexes(fromIndex, toIndex, wrapped.size_1());
  this.wrapped = wrapped;
  this.fromIndex = fromIndex;
  this.size_0 = toIndex - fromIndex;
}

defineClass(219, 43, $intern_36, AbstractList$SubList);
_.add_3 = function add_25(index_0, element){
  checkCriticalPositionIndex(index_0, this.size_0);
  this.wrapped.add_3(this.fromIndex + index_0, element);
  ++this.size_0;
}
;
_.get_3 = function get_21(index_0){
  checkCriticalElementIndex(index_0, this.size_0);
  return this.wrapped.get_3(this.fromIndex + index_0);
}
;
_.remove_2 = function remove_53(index_0){
  var result;
  checkCriticalElementIndex(index_0, this.size_0);
  result = this.wrapped.remove_2(this.fromIndex + index_0);
  --this.size_0;
  return result;
}
;
_.set_2 = function set_13(index_0, element){
  checkCriticalElementIndex(index_0, this.size_0);
  return this.wrapped.set_2(this.fromIndex + index_0, element);
}
;
_.size_1 = function size_31(){
  return this.size_0;
}
;
_.fromIndex = 0;
_.size_0 = 0;
var Ljava_util_AbstractList$SubList_2_classLit = createForClass('java.util', 'AbstractList/SubList', 219);
function AbstractMap$1(this$0){
  this.this$01 = this$0;
}

defineClass(364, $intern_13, $intern_14, AbstractMap$1);
_.clear_0 = function clear_29(){
  this.this$01.clear_0();
}
;
_.contains = function contains_24(key){
  return this.this$01.containsKey(key);
}
;
_.iterator_0 = function iterator_40(){
  var outerIter;
  return outerIter = this.this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter);
}
;
_.remove_1 = function remove_54(key){
  if (this.this$01.containsKey(key)) {
    this.this$01.remove(key);
    return true;
  }
  return false;
}
;
_.size_1 = function size_32(){
  return this.this$01.size_1();
}
;
var Ljava_util_AbstractMap$1_2_classLit = createForClass('java.util', 'AbstractMap/1', 364);
function AbstractMap$1$1(val$outerIter){
  this.val$outerIter2 = val$outerIter;
}

defineClass(568, 1, $intern_4, AbstractMap$1$1);
_.forEachRemaining = function forEachRemaining_20(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_22(){
  return this.val$outerIter2.hasNext_0();
}
;
_.next_1 = function next_23(){
  var entry;
  return entry = castTo(this.val$outerIter2.next_1(), 39) , entry.getKey();
}
;
_.remove_0 = function remove_55(){
  this.val$outerIter2.remove_0();
}
;
var Ljava_util_AbstractMap$1$1_2_classLit = createForClass('java.util', 'AbstractMap/1/1', 568);
function AbstractMap$2(this$0){
  this.this$01 = this$0;
}

defineClass(233, 28, $intern_12, AbstractMap$2);
_.clear_0 = function clear_30(){
  this.this$01.clear_0();
}
;
_.contains = function contains_25(value_0){
  return this.this$01.containsValue(value_0);
}
;
_.iterator_0 = function iterator_41(){
  var outerIter;
  return outerIter = this.this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter);
}
;
_.size_1 = function size_33(){
  return this.this$01.size_1();
}
;
var Ljava_util_AbstractMap$2_2_classLit = createForClass('java.util', 'AbstractMap/2', 233);
function AbstractMap$2$1(val$outerIter){
  this.val$outerIter2 = val$outerIter;
}

defineClass(331, 1, $intern_4, AbstractMap$2$1);
_.forEachRemaining = function forEachRemaining_21(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_23(){
  return this.val$outerIter2.hasNext_0();
}
;
_.next_1 = function next_24(){
  var entry;
  return entry = castTo(this.val$outerIter2.next_1(), 39) , entry.getValue();
}
;
_.remove_0 = function remove_56(){
  this.val$outerIter2.remove_0();
}
;
var Ljava_util_AbstractMap$2$1_2_classLit = createForClass('java.util', 'AbstractMap/2/1', 331);
function $setValue(this$static, value_0){
  var oldValue;
  oldValue = this$static.value_0;
  this$static.value_0 = value_0;
  return oldValue;
}

defineClass(456, 1, {456:1, 39:1});
_.equals_0 = function equals_45(other){
  var entry;
  if (!instanceOf(other, 39)) {
    return false;
  }
  entry = castTo(other, 39);
  return equals_56(this.key, entry.getKey()) && equals_56(this.value_0, entry.getValue());
}
;
_.getKey = function getKey_4(){
  return this.key;
}
;
_.getValue = function getValue_4(){
  return this.value_0;
}
;
_.hashCode_1 = function hashCode_41(){
  return hashCode_49(this.key) ^ hashCode_49(this.value_0);
}
;
_.setValue = function setValue_5(value_0){
  return $setValue(this, value_0);
}
;
_.toString_0 = function toString_53(){
  return this.key + '=' + this.value_0;
}
;
var Ljava_util_AbstractMap$AbstractEntry_2_classLit = createForClass('java.util', 'AbstractMap/AbstractEntry', 456);
function AbstractMap$SimpleEntry(key, value_0){
  this.key = key;
  this.value_0 = value_0;
}

defineClass(363, 456, {456:1, 363:1, 39:1}, AbstractMap$SimpleEntry);
var Ljava_util_AbstractMap$SimpleEntry_2_classLit = createForClass('java.util', 'AbstractMap/SimpleEntry', 363);
defineClass(1756, 1, $intern_5);
_.equals_0 = function equals_46(other){
  var entry;
  if (!instanceOf(other, 39)) {
    return false;
  }
  entry = castTo(other, 39);
  return equals_56(this.getKey(), entry.getKey()) && equals_56(this.getValue(), entry.getValue());
}
;
_.hashCode_1 = function hashCode_42(){
  return hashCode_49(this.getKey()) ^ hashCode_49(this.getValue());
}
;
_.toString_0 = function toString_54(){
  return this.getKey() + '=' + this.getValue();
}
;
var Ljava_util_AbstractMapEntry_2_classLit = createForClass('java.util', 'AbstractMapEntry', 1756);
function $containsEntry_1(this$static, entry){
  var key, lookupEntry;
  key = entry.getKey();
  lookupEntry = $getEntry_0(this$static, key);
  return !!lookupEntry && equals_56(lookupEntry.value_0, entry.getValue());
}

function $containsKey_3(this$static, k){
  return !!$getEntry_0(this$static, k);
}

function getKeyOrNSE(entry){
  if (!entry) {
    throw toJs(new NoSuchElementException);
  }
  return entry.key;
}

defineClass(1769, 1750, $intern_15);
_.containsEntry = function containsEntry_0(entry){
  return $containsEntry_1(this, entry);
}
;
_.containsKey = function containsKey_6(k){
  return $containsKey_3(this, k);
}
;
_.entrySet_0 = function entrySet_3(){
  return new AbstractNavigableMap$EntrySet(this);
}
;
_.get_0 = function get_22(k){
  return getEntryValueOrNull($getEntry_0(this, k));
}
;
_.keySet_0 = function keySet_13(){
  return new AbstractNavigableMap$NavigableKeySet(this);
}
;
var Ljava_util_AbstractNavigableMap_2_classLit = createForClass('java.util', 'AbstractNavigableMap', 1769);
function AbstractNavigableMap$EntrySet(this$0){
  this.this$01_0 = this$0;
}

defineClass(687, $intern_13, $intern_14, AbstractNavigableMap$EntrySet);
_.contains = function contains_26(o){
  return instanceOf(o, 39) && $containsEntry_1(this.this$01_0, castTo(o, 39));
}
;
_.iterator_0 = function iterator_42(){
  return new TreeMap$EntryIterator(this.this$01_0);
}
;
_.remove_1 = function remove_57(o){
  var entry;
  if (instanceOf(o, 39)) {
    entry = castTo(o, 39);
    return $removeEntry(this.this$01_0, entry);
  }
  return false;
}
;
_.size_1 = function size_34(){
  return this.this$01_0.size_0;
}
;
var Ljava_util_AbstractNavigableMap$EntrySet_2_classLit = createForClass('java.util', 'AbstractNavigableMap/EntrySet', 687);
function AbstractNavigableMap$NavigableKeySet(map_0){
  this.map_0 = map_0;
}

defineClass(464, $intern_13, $intern_17, AbstractNavigableMap$NavigableKeySet);
_.spliterator_0 = function spliterator_21(){
  return new SortedSet$1(this);
}
;
_.clear_0 = function clear_31(){
  $clear_6(this.map_0);
}
;
_.contains = function contains_27(o){
  return $containsKey_3(this.map_0, o);
}
;
_.iterator_0 = function iterator_43(){
  var entryIterator;
  return entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet(this.map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator);
}
;
_.remove_1 = function remove_58(o){
  if ($containsKey_3(this.map_0, o)) {
    $remove_26(this.map_0, o);
    return true;
  }
  return false;
}
;
_.size_1 = function size_35(){
  return this.map_0.size_0;
}
;
var Ljava_util_AbstractNavigableMap$NavigableKeySet_2_classLit = createForClass('java.util', 'AbstractNavigableMap/NavigableKeySet', 464);
function AbstractNavigableMap$NavigableKeySet$1(val$entryIterator){
  this.val$entryIterator2 = val$entryIterator;
}

defineClass(465, 1, $intern_4, AbstractNavigableMap$NavigableKeySet$1);
_.forEachRemaining = function forEachRemaining_22(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_24(){
  return $hasNext_1(this.val$entryIterator2.iter);
}
;
_.next_1 = function next_25(){
  var entry;
  return entry = $next_14(this.val$entryIterator2) , entry.getKey();
}
;
_.remove_0 = function remove_59(){
  $remove_27(this.val$entryIterator2);
}
;
var Ljava_util_AbstractNavigableMap$NavigableKeySet$1_2_classLit = createForClass('java.util', 'AbstractNavigableMap/NavigableKeySet/1', 465);
defineClass(1779, 28, $intern_12);
_.add_1 = function add_26(o){
  return checkCriticalState_0($offer(this, o)) , true;
}
;
_.addAll = function addAll_6(c){
  checkCriticalNotNull(c);
  checkCriticalArgument_0(c != this, "Can't add a queue to itself");
  return $addAll(this, c);
}
;
_.clear_0 = function clear_32(){
  while ($poll_0(this) != null)
  ;
}
;
var Ljava_util_AbstractQueue_2_classLit = createForClass('java.util', 'AbstractQueue', 1779);
function $$init_1(this$static){
  this$static.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 8, 5, 1);
}

function $addFirst(this$static, e){
  checkCriticalNotNull(e);
  this$static.head = this$static.head - 1 & this$static.array.length - 1;
  setCheck(this$static.array, this$static.head, e);
  $ensureCapacity(this$static);
}

function $addLast(this$static, e){
  checkCriticalNotNull(e);
  setCheck(this$static.array, this$static.tail, e);
  this$static.tail = this$static.tail + 1 & this$static.array.length - 1;
  $ensureCapacity(this$static);
}

function $clear_3(this$static){
  if (this$static.head == this$static.tail) {
    return;
  }
  this$static.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 8, 5, 1);
  this$static.head = 0;
  this$static.tail = 0;
}

function $contains_2(it, o){
  if (o == null) {
    return false;
  }
  while (it.currentIndex != it.fence) {
    if (equals_Ljava_lang_Object__Z__devirtual$(o, $next_9(it))) {
      return true;
    }
  }
  return false;
}

function $copyElements(this$static, dest, count){
  var dstIdx, i, mask;
  mask = this$static.array.length - 1;
  for (i = this$static.head , dstIdx = 0; dstIdx < count; i = i + 1 & mask , ++dstIdx) {
    setCheck(dest, dstIdx, this$static.array[i]);
  }
}

function $ensureCapacity(this$static){
  var newArray, newLength, numElements;
  if (this$static.head != this$static.tail) {
    return;
  }
  numElements = this$static.array.length;
  newLength = highestOneBit(8 > numElements?8:numElements) << 1;
  if (this$static.head != 0) {
    newArray = createFrom(this$static.array, newLength);
    $copyElements(this$static, newArray, numElements);
    this$static.array = newArray;
    this$static.head = 0;
  }
   else {
    setLength(this$static.array, newLength);
  }
  this$static.tail = numElements;
}

function $isEmpty(this$static){
  return this$static.head == this$static.tail;
}

function $pollFirst(this$static){
  var e;
  e = this$static.array[this$static.head];
  if (e == null) {
    return null;
  }
  setCheck(this$static.array, this$static.head, null);
  this$static.head = this$static.head + 1 & this$static.array.length - 1;
  return e;
}

function $remove_10(it, o){
  if ($contains_2(it, o)) {
    $remove_11(it);
    return true;
  }
  return false;
}

function $removeAtIndex(this$static, i){
  var headDistance, mask, size_0, tailDistance;
  mask = this$static.array.length - 1;
  headDistance = i - this$static.head & mask;
  tailDistance = this$static.tail - i & mask;
  size_0 = this$static.tail - this$static.head & mask;
  checkConcurrentModification(headDistance < size_0);
  if (headDistance >= tailDistance) {
    $shiftLeftAtIndex(this$static, i);
    return -1;
  }
   else {
    $shiftRightAtIndex(this$static, i);
    return 1;
  }
}

function $removeFirst(this$static){
  var e;
  e = $pollFirst(this$static);
  checkCriticalElement(e != null);
  return e;
}

function $shiftLeftAtIndex(this$static, i){
  var mask, nextOffset;
  mask = this$static.array.length - 1;
  this$static.tail = this$static.tail - 1 & mask;
  while (i != this$static.tail) {
    nextOffset = i + 1 & mask;
    setCheck(this$static.array, i, this$static.array[nextOffset]);
    i = nextOffset;
  }
  setCheck(this$static.array, this$static.tail, null);
}

function $shiftRightAtIndex(this$static, i){
  var mask, prevOffset;
  mask = this$static.array.length - 1;
  while (i != this$static.head) {
    prevOffset = i - 1 & mask;
    setCheck(this$static.array, i, this$static.array[prevOffset]);
    i = prevOffset;
  }
  setCheck(this$static.array, this$static.head, null);
  this$static.head = this$static.head + 1 & mask;
}

function ArrayDeque(){
  $$init_1(this);
}

function ArrayDeque_0(numElements){
  $$init_1(this);
  setLength(this.array, highestOneBit(8 > numElements?8:numElements) << 1);
}

function checkConcurrentModification(expression){
  if (!expression) {
    throw toJs(new ConcurrentModificationException);
  }
}

defineClass(347, 28, {4:1, 20:1, 28:1, 13:1}, ArrayDeque, ArrayDeque_0);
_.add_1 = function add_27(e){
  return $addLast(this, e) , true;
}
;
_.clear_0 = function clear_33(){
  $clear_3(this);
}
;
_.contains = function contains_28(o){
  return $contains_2(new ArrayDeque$IteratorImpl(this), o);
}
;
_.isEmpty = function isEmpty_15(){
  return $isEmpty(this);
}
;
_.iterator_0 = function iterator_44(){
  return new ArrayDeque$IteratorImpl(this);
}
;
_.remove_1 = function remove_60(o){
  return $remove_10(new ArrayDeque$IteratorImpl(this), o);
}
;
_.size_1 = function size_36(){
  return this.tail - this.head & this.array.length - 1;
}
;
_.spliterator_0 = function spliterator_22(){
  return new Spliterators$IteratorSpliterator(this, 272);
}
;
_.toArray_0 = function toArray_15(out){
  var result, size_0;
  size_0 = this.tail - this.head & this.array.length - 1;
  out.length < size_0 && (out = (result = new Array(size_0) , stampJavaTypeInfo_0(result, out)));
  $copyElements(this, out, size_0);
  out.length > size_0 && setCheck(out, size_0, null);
  return out;
}
;
_.head = 0;
_.tail = 0;
var Ljava_util_ArrayDeque_2_classLit = createForClass('java.util', 'ArrayDeque', 347);
function $next_9(this$static){
  var e;
  checkCriticalElement(this$static.currentIndex != this$static.fence);
  e = this$static.this$01.array[this$static.currentIndex];
  checkConcurrentModification(this$static.fence == this$static.this$01.tail && e != null);
  this$static.lastIndex = this$static.currentIndex;
  this$static.currentIndex = this$static.currentIndex + 1 & this$static.this$01.array.length - 1;
  return e;
}

function $remove_11(this$static){
  checkCriticalState(this$static.lastIndex >= 0);
  if ($removeAtIndex(this$static.this$01, this$static.lastIndex) < 0) {
    this$static.currentIndex = this$static.currentIndex - 1 & this$static.this$01.array.length - 1;
    this$static.fence = this$static.this$01.tail;
  }
  this$static.lastIndex = -1;
}

function ArrayDeque$IteratorImpl(this$0){
  this.this$01 = this$0;
  this.currentIndex = this.this$01.head;
  this.fence = this.this$01.tail;
}

defineClass(425, 1, $intern_4, ArrayDeque$IteratorImpl);
_.forEachRemaining = function forEachRemaining_23(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_25(){
  return this.currentIndex != this.fence;
}
;
_.next_1 = function next_26(){
  return $next_9(this);
}
;
_.remove_0 = function remove_61(){
  $remove_11(this);
}
;
_.currentIndex = 0;
_.fence = 0;
_.lastIndex = -1;
var Ljava_util_ArrayDeque$IteratorImpl_2_classLit = createForClass('java.util', 'ArrayDeque/IteratorImpl', 425);
function $$init_2(this$static){
  this$static.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}

function $add_3(this$static, index_0, o){
  checkCriticalPositionIndex(index_0, this$static.array.length);
  insertTo(this$static.array, index_0, o);
}

function $add_4(this$static, o){
  this$static.array[this$static.array.length] = o;
  return true;
}

function $addAll_1(this$static, c){
  var cArray, len;
  checkCriticalPositionIndex(0, this$static.array.length);
  cArray = $toArray_0(c, initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, c.map_0.size_1(), 5, 1));
  len = cArray.length;
  if (len == 0) {
    return false;
  }
  insertTo_0(this$static.array, 0, cArray);
  return true;
}

function $addAll_2(this$static, c){
  var cArray, len;
  cArray = c.toArray();
  len = cArray.length;
  if (len == 0) {
    return false;
  }
  insertTo_0(this$static.array, this$static.array.length, cArray);
  return true;
}

function $forEach_0(this$static, consumer){
  var e, e$array, e$index, e$max;
  checkCriticalNotNull(consumer);
  for (e$array = this$static.array , e$index = 0 , e$max = e$array.length; e$index < e$max; ++e$index) {
    e = e$array[e$index];
    consumer.accept(e);
  }
}

function $get_7(this$static, index_0){
  checkCriticalElementIndex(index_0, this$static.array.length);
  return this$static.array[index_0];
}

function $indexOf_3(this$static, o, index_0){
  for (; index_0 < this$static.array.length; ++index_0) {
    if (equals_56(o, this$static.array[index_0])) {
      return index_0;
    }
  }
  return -1;
}

function $remove_12(this$static, index_0){
  var previous;
  previous = (checkCriticalElementIndex(index_0, this$static.array.length) , this$static.array[index_0]);
  removeFrom(this$static.array, index_0, 1);
  return previous;
}

function $remove_13(this$static, o){
  var i;
  i = $indexOf_3(this$static, o, 0);
  if (i == -1) {
    return false;
  }
  $remove_12(this$static, i);
  return true;
}

function $removeRange(this$static, fromIndex, endIndex){
  var count;
  checkCriticalPositionIndexes(fromIndex, endIndex, this$static.array.length);
  count = endIndex - fromIndex;
  removeFrom(this$static.array, fromIndex, count);
}

function $set_1(this$static, index_0, o){
  var previous;
  previous = (checkCriticalElementIndex(index_0, this$static.array.length) , this$static.array[index_0]);
  this$static.array[index_0] = o;
  return previous;
}

function $sort(this$static, c){
  sort_4(this$static.array, this$static.array.length, c);
}

function $toArray_1(this$static){
  return clone_0(this$static.array, this$static.array.length);
}

function $toArray_2(this$static, out){
  var i, result, size_0;
  size_0 = this$static.array.length;
  out.length < size_0 && (out = (result = new Array(size_0) , stampJavaTypeInfo_0(result, out)));
  for (i = 0; i < size_0; ++i) {
    setCheck(out, i, this$static.array[i]);
  }
  out.length > size_0 && setCheck(out, size_0, null);
  return out;
}

function ArrayList(){
  $$init_2(this);
}

function ArrayList_0(initialCapacity){
  $$init_2(this);
  checkCriticalArgument_0(initialCapacity >= 0, 'Initial capacity must not be negative');
}

function ArrayList_1(c){
  $$init_2(this);
  insertTo_0(this.array, 0, c.toArray());
}

defineClass(12, 43, $intern_74, ArrayList, ArrayList_0, ArrayList_1);
_.add_3 = function add_28(index_0, o){
  $add_3(this, index_0, o);
}
;
_.add_1 = function add_29(o){
  return $add_4(this, o);
}
;
_.addAll = function addAll_7(c){
  return $addAll_2(this, c);
}
;
_.clear_0 = function clear_34(){
  this.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}
;
_.contains = function contains_29(o){
  return $indexOf_3(this, o, 0) != -1;
}
;
_.forEach_0 = function forEach_12(consumer){
  $forEach_0(this, consumer);
}
;
_.get_3 = function get_23(index_0){
  return $get_7(this, index_0);
}
;
_.indexOf_0 = function indexOf_4(o){
  return $indexOf_3(this, o, 0);
}
;
_.isEmpty = function isEmpty_16(){
  return this.array.length == 0;
}
;
_.iterator_0 = function iterator_45(){
  return new ArrayList$1(this);
}
;
_.remove_2 = function remove_62(index_0){
  return $remove_12(this, index_0);
}
;
_.remove_1 = function remove_63(o){
  return $remove_13(this, o);
}
;
_.removeRange = function removeRange_1(fromIndex, endIndex){
  $removeRange(this, fromIndex, endIndex);
}
;
_.set_2 = function set_14(index_0, o){
  return $set_1(this, index_0, o);
}
;
_.size_1 = function size_37(){
  return this.array.length;
}
;
_.sort_0 = function sort_3(c){
  $sort(this, c);
}
;
_.toArray = function toArray_16(){
  return $toArray_1(this);
}
;
_.toArray_0 = function toArray_17(out){
  return $toArray_2(this, out);
}
;
var Ljava_util_ArrayList_2_classLit = createForClass('java.util', 'ArrayList', 12);
function $hasNext_2(this$static){
  return this$static.i < this$static.this$01.array.length;
}

function $next_10(this$static){
  checkCriticalElement(this$static.i < this$static.this$01.array.length);
  this$static.last = this$static.i++;
  return this$static.this$01.array[this$static.last];
}

function $remove_14(this$static){
  checkCriticalState(this$static.last != -1);
  $remove_12(this$static.this$01, this$static.i = this$static.last);
  this$static.last = -1;
}

function ArrayList$1(this$0){
  this.this$01 = this$0;
}

defineClass(7, 1, $intern_4, ArrayList$1);
_.forEachRemaining = function forEachRemaining_24(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_26(){
  return $hasNext_2(this);
}
;
_.next_1 = function next_27(){
  return $next_10(this);
}
;
_.remove_0 = function remove_64(){
  $remove_14(this);
}
;
_.i = 0;
_.last = -1;
var Ljava_util_ArrayList$1_2_classLit = createForClass('java.util', 'ArrayList/1', 7);
function copyObjectArray(original, to){
  var copy, result;
  copy = (result = original.slice(0, to) , stampJavaTypeInfo_0(result, original));
  copy.length = to;
  return copy;
}

function copyOf_0(original, newLength){
  checkCriticalArraySize(newLength);
  return copyPrimitiveArray(original, initUnidimensionalArray(I_classLit, $intern_49, 23, newLength, 15, 1), newLength);
}

function copyOf_1(original, newLength){
  checkCriticalArraySize(newLength);
  return copyObjectArray(original, newLength);
}

function copyPrimitiveArray(original, copy, to){
  var copyLen, len;
  len = original.length;
  copyLen = to < len?to:len;
  copy_0(original, 0, copy, 0, copyLen, true);
  return copy;
}

function deepToString(a, arraysIveSeen){
  var joiner, obj, obj$index, obj$max, objArray, old, tempSet, elementTypeCategory;
  if (a == null) {
    return 'null';
  }
  old = arraysIveSeen.map_0.put(a, arraysIveSeen);
  if (old != null) {
    return '[...]';
  }
  joiner = new StringJoiner('[', ']');
  for (obj$index = 0 , obj$max = a.length; obj$index < obj$max; ++obj$index) {
    obj = a[obj$index];
    if (obj != null && (getClass__Ljava_lang_Class___devirtual$(obj).modifiers & 4) != 0) {
      if (Array.isArray(obj) && (elementTypeCategory = getElementTypeCategory(obj) , !(elementTypeCategory >= 14 && elementTypeCategory <= 16))) {
        if (arraysIveSeen.map_0.containsKey(obj)) {
          !joiner.builder?(joiner.builder = new StringBuilder_1(joiner.prefix)):$append_11(joiner.builder, joiner.delimiter);
          $append_8(joiner.builder, '[...]');
        }
         else {
          objArray = castToArray(obj);
          tempSet = new HashSet_1(arraysIveSeen);
          $add_9(joiner, deepToString(objArray, tempSet));
        }
      }
       else 
        instanceOf(obj, 229)?$add_9(joiner, toString_62(castTo(obj, 229))):instanceOf(obj, 178)?$add_9(joiner, toString_55(castTo(obj, 178))):instanceOf(obj, 181)?$add_9(joiner, toString_56(castTo(obj, 181))):instanceOf(obj, 1781)?$add_9(joiner, toString_61(castTo(obj, 1781))):instanceOf(obj, 40)?$add_9(joiner, toString_59(castTo(obj, 40))):instanceOf(obj, 350)?$add_9(joiner, toString_60(castTo(obj, 350))):instanceOf(obj, 766)?$add_9(joiner, toString_58(castTo(obj, 766))):instanceOf(obj, 108) && $add_9(joiner, toString_57(castTo(obj, 108)));
    }
     else {
      $add_9(joiner, obj == null?'null':toString_41(obj));
    }
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function equals_47(array1, array2){
  var i, val1, val2;
  if (maskUndefined(array1) === maskUndefined(array2)) {
    return true;
  }
  if (array1 == null || array2 == null) {
    return false;
  }
  if (array1.length != array2.length) {
    return false;
  }
  for (i = 0; i < array1.length; ++i) {
    val1 = array1[i];
    val2 = array2[i];
    if (!(maskUndefined(val1) === maskUndefined(val2) || val1 != null && equals_Ljava_lang_Object__Z__devirtual$(val1, val2))) {
      return false;
    }
  }
  return true;
}

function fill_0(a, fromIndex, toIndex, val){
  checkCriticalArrayBounds_0(fromIndex, toIndex, a.length);
  fill0(a, fromIndex, toIndex, val);
}

function fill_1(a, val){
  fill0_0(a, a.length, val);
}

function fill_2(a){
  fill0_1(a, a.length);
}

function fill_3(a, val){
  fill0_2(a, a.length, val);
}

function fill_4(a){
  fill0_3(a, a.length);
}

function fill0(a, fromIndex, toIndex, val){
  var i;
  for (i = fromIndex; i < toIndex; ++i) {
    a[i] = val;
  }
}

function fill0_0(a, toIndex, val){
  var i;
  for (i = 0; i < toIndex; ++i) {
    a[i] = val;
  }
}

function fill0_1(a, toIndex){
  var i;
  for (i = 0; i < toIndex; ++i) {
    a[i] = -1;
  }
}

function fill0_2(a, toIndex, val){
  var i;
  for (i = 0; i < toIndex; ++i) {
    setCheck(a, i, val);
  }
}

function fill0_3(a, toIndex){
  var i;
  for (i = 0; i < toIndex; ++i) {
    a[i] = false;
  }
}

function hashCode_43(a){
  var e, e$index, e$max, hashCode;
  hashCode = 1;
  for (e$index = 0 , e$max = a.length; e$index < e$max; ++e$index) {
    e = a[e$index];
    hashCode = 31 * hashCode + (e != null?hashCode__I__devirtual$(e):0);
    hashCode = hashCode | 0;
  }
  return hashCode;
}

function insertionSort(array, low, high, comp){
  var i, j, t;
  for (i = low + 1; i < high; ++i) {
    for (j = i; j > low && comp.compare_0(array[j - 1], array[j]) > 0; --j) {
      t = array[j];
      setCheck(array, j, array[j - 1]);
      setCheck(array, j - 1, t);
    }
  }
}

function merge_1(src_0, srcLow, srcMid, srcHigh, dest, destLow, destHigh, comp){
  var topIdx;
  topIdx = srcMid;
  while (destLow < destHigh) {
    topIdx >= srcHigh || srcLow < srcMid && comp.compare_0(src_0[srcLow], src_0[topIdx]) <= 0?setCheck(dest, destLow++, src_0[srcLow++]):setCheck(dest, destLow++, src_0[topIdx++]);
  }
}

function mergeSort(x_0, fromIndex, toIndex, comp){
  var temp;
  comp = ($clinit_Comparators() , !comp?INTERNAL_NATURAL_ORDER:comp);
  temp = x_0.slice(fromIndex, toIndex);
  mergeSort_0(temp, x_0, fromIndex, toIndex, -fromIndex, comp);
}

function mergeSort_0(temp, array, low, high, ofs, comp){
  var length_0, tempHigh, tempLow, tempMid;
  length_0 = high - low;
  if (length_0 < 7) {
    insertionSort(array, low, high, comp);
    return;
  }
  tempLow = low + ofs;
  tempHigh = high + ofs;
  tempMid = tempLow + (tempHigh - tempLow >> 1);
  mergeSort_0(array, temp, tempLow, tempMid, -ofs, comp);
  mergeSort_0(array, temp, tempMid, tempHigh, -ofs, comp);
  if (comp.compare_0(temp[tempMid - 1], temp[tempMid]) <= 0) {
    while (low < high) {
      setCheck(array, low++, temp[tempLow++]);
    }
    return;
  }
  merge_1(temp, tempLow, tempMid, tempHigh, array, low, high, comp);
}

function nativeNumberSort(array){
  array.sort(function(a, b){
    return a - b;
  }
  );
}

function sort_4(x_0, toIndex, c){
  checkCriticalArrayBounds_0(0, toIndex, x_0.length);
  mergeSort(x_0, 0, toIndex, c);
}

function sort_5(x_0, c){
  mergeSort(x_0, 0, x_0.length, c);
}

function spliterator_23(array, endExclusive){
  return checkCriticalArrayBounds(endExclusive, array.length) , new Spliterators$ArraySpliterator(array, endExclusive);
}

function stream_1(array){
  return new Stream$StreamSource(null, spliterator_23(array, array.length));
}

function toString_55(a){
  var element, element$index, element$max, joiner;
  if (a == null) {
    return 'null';
  }
  joiner = new StringJoiner('[', ']');
  for (element$index = 0 , element$max = a.length; element$index < element$max; ++element$index) {
    element = a[element$index];
    !joiner.builder?(joiner.builder = new StringBuilder_1(joiner.prefix)):$append_11(joiner.builder, joiner.delimiter);
    $append_8(joiner.builder, '' + element);
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function toString_56(a){
  var element, element$index, element$max, joiner;
  if (a == null) {
    return 'null';
  }
  joiner = new StringJoiner('[', ']');
  for (element$index = 0 , element$max = a.length; element$index < element$max; ++element$index) {
    element = a[element$index];
    $add_9(joiner, String.fromCharCode(element));
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function toString_57(a){
  var element, element$index, element$max, joiner;
  if (a == null) {
    return 'null';
  }
  joiner = new StringJoiner('[', ']');
  for (element$index = 0 , element$max = a.length; element$index < element$max; ++element$index) {
    element = a[element$index];
    !joiner.builder?(joiner.builder = new StringBuilder_1(joiner.prefix)):$append_11(joiner.builder, joiner.delimiter);
    $append_8(joiner.builder, '' + element);
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function toString_58(a){
  var element, element$index, element$max, joiner;
  if (a == null) {
    return 'null';
  }
  joiner = new StringJoiner('[', ']');
  for (element$index = 0 , element$max = a.length; element$index < element$max; ++element$index) {
    element = a[element$index];
    !joiner.builder?(joiner.builder = new StringBuilder_1(joiner.prefix)):$append_11(joiner.builder, joiner.delimiter);
    $append_8(joiner.builder, '' + element);
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function toString_59(a){
  var element, element$index, element$max, joiner;
  if (a == null) {
    return 'null';
  }
  joiner = new StringJoiner('[', ']');
  for (element$index = 0 , element$max = a.length; element$index < element$max; ++element$index) {
    element = a[element$index];
    !joiner.builder?(joiner.builder = new StringBuilder_1(joiner.prefix)):$append_11(joiner.builder, joiner.delimiter);
    $append_8(joiner.builder, '' + element);
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function toString_60(a){
  var element, element$index, element$max, joiner;
  if (a == null) {
    return 'null';
  }
  joiner = new StringJoiner('[', ']');
  for (element$index = 0 , element$max = a.length; element$index < element$max; ++element$index) {
    element = a[element$index];
    !joiner.builder?(joiner.builder = new StringBuilder_1(joiner.prefix)):$append_11(joiner.builder, joiner.delimiter);
    $append_8(joiner.builder, '' + toString_40(element));
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function toString_61(a){
  var element, element$index, element$max, joiner;
  if (a == null) {
    return 'null';
  }
  joiner = new StringJoiner('[', ']');
  for (element$index = 0 , element$max = a.length; element$index < element$max; ++element$index) {
    element = a[element$index];
    !joiner.builder?(joiner.builder = new StringBuilder_1(joiner.prefix)):$append_11(joiner.builder, joiner.delimiter);
    $append_8(joiner.builder, '' + element);
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function toString_62(a){
  var element, element$index, element$max, joiner;
  if (a == null) {
    return 'null';
  }
  joiner = new StringJoiner('[', ']');
  for (element$index = 0 , element$max = a.length; element$index < element$max; ++element$index) {
    element = a[element$index];
    !joiner.builder?(joiner.builder = new StringBuilder_1(joiner.prefix)):$append_11(joiner.builder, joiner.delimiter);
    $append_8(joiner.builder, '' + element);
  }
  return !joiner.builder?joiner.emptyValue:joiner.suffix.length == 0?joiner.builder.string:joiner.builder.string + ('' + joiner.suffix);
}

function $get_8(this$static, index_0){
  checkCriticalElementIndex(index_0, this$static.array.length);
  return this$static.array[index_0];
}

function $toArray_3(this$static, out){
  var i, result, size_0;
  size_0 = this$static.array.length;
  out.length < size_0 && (out = (result = new Array(size_0) , stampJavaTypeInfo_0(result, out)));
  for (i = 0; i < size_0; ++i) {
    setCheck(out, i, this$static.array[i]);
  }
  out.length > size_0 && setCheck(out, size_0, null);
  return out;
}

function Arrays$ArrayList(array){
  checkCriticalNotNull(array);
  this.array = array;
}

defineClass(160, 43, $intern_75, Arrays$ArrayList);
_.contains = function contains_30(o){
  return $indexOf(this, o) != -1;
}
;
_.forEach_0 = function forEach_13(consumer){
  var e, e$array, e$index, e$max;
  checkCriticalNotNull(consumer);
  for (e$array = this.array , e$index = 0 , e$max = e$array.length; e$index < e$max; ++e$index) {
    e = e$array[e$index];
    consumer.accept(e);
  }
}
;
_.get_3 = function get_24(index_0){
  return $get_8(this, index_0);
}
;
_.set_2 = function set_15(index_0, value_0){
  var was;
  was = (checkCriticalElementIndex(index_0, this.array.length) , this.array[index_0]);
  setCheck(this.array, index_0, value_0);
  return was;
}
;
_.size_1 = function size_38(){
  return this.array.length;
}
;
_.sort_0 = function sort_6(c){
  sort_4(this.array, this.array.length, c);
}
;
_.toArray = function toArray_18(){
  return $toArray_3(this, initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, this.array.length, 5, 1));
}
;
_.toArray_0 = function toArray_19(out){
  return $toArray_3(this, out);
}
;
var Ljava_util_Arrays$ArrayList_2_classLit = createForClass('java.util', 'Arrays/ArrayList', 160);
function $clinit_Collections(){
  $clinit_Collections = emptyMethod;
  EMPTY_LIST = new Collections$EmptyList;
  EMPTY_MAP = new Collections$EmptyMap;
  EMPTY_SET = new Collections$EmptySet;
}

function addAll_8(c, a){
  $clinit_Collections();
  var e, e$index, e$max, result;
  result = false;
  for (e$index = 0 , e$max = a.length; e$index < e$max; ++e$index) {
    e = a[e$index];
    result = result | c.add_1(e);
  }
  return result;
}

function disjoint(c1, c2){
  $clinit_Collections();
  var o, o$iterator;
  for (o$iterator = new ArrayList$1(c1); o$iterator.i < o$iterator.this$01.array.length;) {
    o = $next_10(o$iterator);
    if ($indexOf_3(c2, o, 0) != -1) {
      return false;
    }
  }
  return true;
}

function hashCode_44(collection){
  $clinit_Collections();
  var e, e$iterator, hashCode;
  hashCode = 0;
  for (e$iterator = collection.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    hashCode = hashCode + (e != null?hashCode__I__devirtual$(e):0);
    hashCode = hashCode | 0;
  }
  return hashCode;
}

function hashCode_45(list){
  $clinit_Collections();
  var e, e$iterator, hashCode;
  hashCode = 1;
  for (e$iterator = list.iterator_0(); e$iterator.hasNext_0();) {
    e = e$iterator.next_1();
    hashCode = 31 * hashCode + (e != null?hashCode__I__devirtual$(e):0);
    hashCode = hashCode | 0;
  }
  return hashCode;
}

function nCopies(n, o){
  $clinit_Collections();
  var i, list;
  list = new ArrayList;
  for (i = 0; i < n; ++i) {
    list.array[list.array.length] = o;
  }
  return new Collections$UnmodifiableRandomAccessList(list);
}

function reverse_2(l){
  var t;
  $clinit_Collections();
  var head, headElem, iBack, iFront, tail, tailElem;
  if (instanceOf(l, 50)) {
    for (iFront = 0 , iBack = l.size_1() - 1; iFront < iBack; ++iFront , --iBack) {
      t = l.get_3(iFront);
      l.set_2(iFront, l.get_3(iBack));
      l.set_2(iBack, t);
    }
  }
   else {
    head = l.listIterator_0();
    tail = l.listIterator_1(l.size_1());
    while (head.nextIndex_0() < tail.previousIndex()) {
      headElem = head.next_1();
      tailElem = tail.previous_0();
      head.set_1(tailElem);
      tail.set_1(headElem);
    }
  }
}

function reverseOrder(cmp){
  $clinit_Collections();
  return !cmp?($clinit_Comparators() , $clinit_Comparators() , REVERSE_NATURAL_ORDER):cmp.reversed();
}

function unmodifiableList(list){
  $clinit_Collections();
  return instanceOf(list, 50)?new Collections$UnmodifiableRandomAccessList(list):new Collections$UnmodifiableList(list);
}

var EMPTY_LIST, EMPTY_MAP, EMPTY_SET;
function $get_9(location_0){
  checkCriticalElementIndex(location_0, 0);
  return null;
}

function Collections$EmptyList(){
}

defineClass(893, 43, $intern_75, Collections$EmptyList);
_.contains = function contains_31(object){
  return false;
}
;
_.get_3 = function get_25(location_0){
  return $get_9(location_0);
}
;
_.iterator_0 = function iterator_46(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4;
}
;
_.listIterator_0 = function listIterator_9(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4;
}
;
_.size_1 = function size_39(){
  return 0;
}
;
var Ljava_util_Collections$EmptyList_2_classLit = createForClass('java.util', 'Collections/EmptyList', 893);
function $clinit_Collections$EmptyListIterator(){
  $clinit_Collections$EmptyListIterator = emptyMethod;
  INSTANCE_4 = new Collections$EmptyListIterator;
}

function Collections$EmptyListIterator(){
}

defineClass(894, 1, $intern_18, Collections$EmptyListIterator);
_.forEachRemaining = function forEachRemaining_25(consumer){
  $forEachRemaining(this, consumer);
}
;
_.add_2 = function add_30(o){
  throw toJs(new UnsupportedOperationException);
}
;
_.hasNext_0 = function hasNext_27(){
  return false;
}
;
_.hasPrevious = function hasPrevious_6(){
  return false;
}
;
_.next_1 = function next_28(){
  throw toJs(new NoSuchElementException);
}
;
_.nextIndex_0 = function nextIndex_7(){
  return 0;
}
;
_.previous_0 = function previous_7(){
  throw toJs(new NoSuchElementException);
}
;
_.previousIndex = function previousIndex_6(){
  return -1;
}
;
_.remove_0 = function remove_65(){
  throw toJs(new IllegalStateException);
}
;
_.set_1 = function set_16(o){
  throw toJs(new IllegalStateException);
}
;
var INSTANCE_4;
var Ljava_util_Collections$EmptyListIterator_2_classLit = createForClass('java.util', 'Collections/EmptyListIterator', 894);
function Collections$EmptyMap(){
}

defineClass(896, 1750, $intern_3, Collections$EmptyMap);
_.containsKey = function containsKey_7(key){
  return false;
}
;
_.containsValue = function containsValue_3(value_0){
  return false;
}
;
_.entrySet_0 = function entrySet_4(){
  return $clinit_Collections() , EMPTY_SET;
}
;
_.get_0 = function get_26(key){
  return null;
}
;
_.keySet_0 = function keySet_14(){
  return $clinit_Collections() , EMPTY_SET;
}
;
_.size_1 = function size_40(){
  return 0;
}
;
_.values_0 = function values_7(){
  return $clinit_Collections() , EMPTY_LIST;
}
;
var Ljava_util_Collections$EmptyMap_2_classLit = createForClass('java.util', 'Collections/EmptyMap', 896);
function Collections$EmptySet(){
}

defineClass(895, $intern_13, $intern_30, Collections$EmptySet);
_.contains = function contains_32(object){
  return false;
}
;
_.iterator_0 = function iterator_47(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4;
}
;
_.size_1 = function size_41(){
  return 0;
}
;
var Ljava_util_Collections$EmptySet_2_classLit = createForClass('java.util', 'Collections/EmptySet', 895);
function Collections$SingletonList(element){
  this.element = element;
}

defineClass(573, 43, {3:1, 20:1, 28:1, 43:1, 13:1, 15:1}, Collections$SingletonList);
_.contains = function contains_33(item_0){
  return equals_56(this.element, item_0);
}
;
_.get_3 = function get_27(index_0){
  checkCriticalElementIndex(index_0, 1);
  return this.element;
}
;
_.size_1 = function size_42(){
  return 1;
}
;
var Ljava_util_Collections$SingletonList_2_classLit = createForClass('java.util', 'Collections/SingletonList', 573);
function $contains_3(this$static, o){
  return this$static.coll.contains(o);
}

function $containsAll_0(this$static, c){
  return this$static.coll.containsAll(c);
}

function $toArray_4(this$static, a){
  return this$static.coll.toArray_0(a);
}

function Collections$UnmodifiableCollection(coll){
  this.coll = coll;
}

defineClass(356, 1, $intern_6, Collections$UnmodifiableCollection);
_.forEach_0 = function forEach_14(action){
  $forEach(this, action);
}
;
_.parallelStream = function parallelStream_1(){
  return this.stream();
}
;
_.spliterator_0 = function spliterator_24(){
  return new Spliterators$IteratorSpliterator(this, 0);
}
;
_.stream = function stream_2(){
  return new Stream$StreamSource(null, this.spliterator_0());
}
;
_.add_1 = function add_31(o){
  throw toJs(new UnsupportedOperationException);
}
;
_.addAll = function addAll_9(c){
  throw toJs(new UnsupportedOperationException);
}
;
_.clear_0 = function clear_35(){
  throw toJs(new UnsupportedOperationException);
}
;
_.contains = function contains_34(o){
  return $contains_3(this, o);
}
;
_.containsAll = function containsAll_8(c){
  return $containsAll_0(this, c);
}
;
_.isEmpty = function isEmpty_17(){
  return this.coll.isEmpty();
}
;
_.iterator_0 = function iterator_48(){
  return new Collections$UnmodifiableCollectionIterator(this.coll.iterator_0());
}
;
_.remove_1 = function remove_66(o){
  throw toJs(new UnsupportedOperationException);
}
;
_.size_1 = function size_43(){
  return this.coll.size_1();
}
;
_.toArray = function toArray_20(){
  return this.coll.toArray();
}
;
_.toArray_0 = function toArray_21(a){
  return $toArray_4(this, a);
}
;
_.toString_0 = function toString_63(){
  return toString_41(this.coll);
}
;
var Ljava_util_Collections$UnmodifiableCollection_2_classLit = createForClass('java.util', 'Collections/UnmodifiableCollection', 356);
function $remove_15(){
  throw toJs(new UnsupportedOperationException);
}

function Collections$UnmodifiableCollectionIterator(it){
  this.it = it;
}

defineClass(322, 1, $intern_4, Collections$UnmodifiableCollectionIterator);
_.forEachRemaining = function forEachRemaining_26(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_28(){
  return this.it.hasNext_0();
}
;
_.next_1 = function next_29(){
  return this.it.next_1();
}
;
_.remove_0 = function remove_67(){
  $remove_15();
}
;
var Ljava_util_Collections$UnmodifiableCollectionIterator_2_classLit = createForClass('java.util', 'Collections/UnmodifiableCollectionIterator', 322);
function Collections$UnmodifiableList(list){
  Collections$UnmodifiableCollection.call(this, list);
  this.list = list;
}

defineClass(500, 356, $intern_76, Collections$UnmodifiableList);
_.sort_0 = function sort_7(c){
  $sort_0(this, c);
}
;
_.spliterator_0 = function spliterator_25(){
  return new Spliterators$IteratorSpliterator(this, 16);
}
;
_.add_3 = function add_32(index_0, element){
  throw toJs(new UnsupportedOperationException);
}
;
_.equals_0 = function equals_48(o){
  return equals_Ljava_lang_Object__Z__devirtual$(this.list, o);
}
;
_.get_3 = function get_28(index_0){
  return this.list.get_3(index_0);
}
;
_.hashCode_1 = function hashCode_46(){
  return hashCode__I__devirtual$(this.list);
}
;
_.indexOf_0 = function indexOf_5(o){
  return this.list.indexOf_0(o);
}
;
_.isEmpty = function isEmpty_18(){
  return this.list.isEmpty();
}
;
_.listIterator_0 = function listIterator_10(){
  return new Collections$UnmodifiableListIterator(this.list.listIterator_1(0));
}
;
_.listIterator_1 = function listIterator_11(from){
  return new Collections$UnmodifiableListIterator(this.list.listIterator_1(from));
}
;
_.remove_2 = function remove_68(index_0){
  throw toJs(new UnsupportedOperationException);
}
;
_.set_2 = function set_17(index_0, element){
  throw toJs(new UnsupportedOperationException);
}
;
_.subList = function subList_7(fromIndex, toIndex){
  return new Collections$UnmodifiableList(this.list.subList(fromIndex, toIndex));
}
;
var Ljava_util_Collections$UnmodifiableList_2_classLit = createForClass('java.util', 'Collections/UnmodifiableList', 500);
function Collections$UnmodifiableListIterator(lit){
  Collections$UnmodifiableCollectionIterator.call(this, lit);
  this.lit = lit;
}

defineClass(650, 322, $intern_18, Collections$UnmodifiableListIterator);
_.remove_0 = function remove_69(){
  $remove_15();
}
;
_.add_2 = function add_33(o){
  throw toJs(new UnsupportedOperationException);
}
;
_.hasPrevious = function hasPrevious_7(){
  return this.lit.hasPrevious();
}
;
_.nextIndex_0 = function nextIndex_8(){
  return this.lit.nextIndex_0();
}
;
_.previous_0 = function previous_8(){
  return this.lit.previous_0();
}
;
_.previousIndex = function previousIndex_7(){
  return this.lit.previousIndex();
}
;
_.set_1 = function set_18(o){
  throw toJs(new UnsupportedOperationException);
}
;
var Ljava_util_Collections$UnmodifiableListIterator_2_classLit = createForClass('java.util', 'Collections/UnmodifiableListIterator', 650);
function Collections$UnmodifiableRandomAccessList(list){
  Collections$UnmodifiableList.call(this, list);
}

defineClass(574, 500, {20:1, 13:1, 15:1, 50:1}, Collections$UnmodifiableRandomAccessList);
var Ljava_util_Collections$UnmodifiableRandomAccessList_2_classLit = createForClass('java.util', 'Collections/UnmodifiableRandomAccessList', 574);
function Collections$UnmodifiableSet(set_0){
  Collections$UnmodifiableCollection.call(this, set_0);
}

defineClass(303, 356, $intern_7, Collections$UnmodifiableSet);
_.spliterator_0 = function spliterator_26(){
  return new Spliterators$IteratorSpliterator(this, 1);
}
;
_.equals_0 = function equals_49(o){
  return equals_Ljava_lang_Object__Z__devirtual$(this.coll, o);
}
;
_.hashCode_1 = function hashCode_47(){
  return hashCode__I__devirtual$(this.coll);
}
;
var Ljava_util_Collections$UnmodifiableSet_2_classLit = createForClass('java.util', 'Collections/UnmodifiableSet', 303);
function Collections$UnmodifiableSortedSet(sortedSet){
  Collections$UnmodifiableSet.call(this, sortedSet);
  this.sortedSet = sortedSet;
}

defineClass(458, 303, $intern_31, Collections$UnmodifiableSortedSet);
_.spliterator_0 = function spliterator_27(){
  return new SortedSet$1(this);
}
;
_.equals_0 = function equals_50(o){
  return equals_Ljava_lang_Object__Z__devirtual$(this.sortedSet, o);
}
;
_.hashCode_1 = function hashCode_48(){
  return hashCode__I__devirtual$(this.sortedSet);
}
;
var Ljava_util_Collections$UnmodifiableSortedSet_2_classLit = createForClass('java.util', 'Collections/UnmodifiableSortedSet', 458);
function Comparator$lambda$0$Type(){
}

defineClass(777, 1, $intern_41, Comparator$lambda$0$Type);
_.equals_0 = function equals_51(other){
  return this === other;
}
;
_.reversed = function reversed_1(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_8(a, b){
  var c;
  return c = lambda$2_4(a, b) , c != 0?c:lambda$4_3(a, b);
}
;
var Ljava_util_Comparator$lambda$0$Type_2_classLit = createForClass('java.util', 'Comparator/lambda$0$Type', 777);
function $clinit_Comparators(){
  $clinit_Comparators = emptyMethod;
  INTERNAL_NATURAL_ORDER = new Comparators$NaturalOrderComparator;
  NATURAL_ORDER_0 = new Comparators$NaturalOrderComparator;
  REVERSE_NATURAL_ORDER = new Comparators$ReverseNaturalOrderComparator;
}

var INTERNAL_NATURAL_ORDER, NATURAL_ORDER_0, REVERSE_NATURAL_ORDER;
function $compare_0(a, b){
  return checkCriticalNotNull(a) , compareTo_Ljava_lang_Object__I__devirtual$(a, (checkCriticalNotNull(b) , b));
}

function Comparators$NaturalOrderComparator(){
}

defineClass(704, 1, $intern_41, Comparators$NaturalOrderComparator);
_.compare_0 = function compare_9(a, b){
  return $compare_0(castTo(a, 34), castTo(b, 34));
}
;
_.equals_0 = function equals_52(other){
  return this === other;
}
;
_.reversed = function reversed_2(){
  return $clinit_Comparators() , REVERSE_NATURAL_ORDER;
}
;
var Ljava_util_Comparators$NaturalOrderComparator_2_classLit = createForClass('java.util', 'Comparators/NaturalOrderComparator', 704);
function $compare_1(a, b){
  return checkCriticalNotNull(b) , compareTo_Ljava_lang_Object__I__devirtual$(b, (checkCriticalNotNull(a) , a));
}

function Comparators$ReverseNaturalOrderComparator(){
}

defineClass(1146, 1, $intern_41, Comparators$ReverseNaturalOrderComparator);
_.compare_0 = function compare_10(a, b){
  return $compare_1(castTo(a, 34), castTo(b, 34));
}
;
_.equals_0 = function equals_53(other){
  return this === other;
}
;
_.reversed = function reversed_3(){
  return $clinit_Comparators() , NATURAL_ORDER_0;
}
;
var Ljava_util_Comparators$ReverseNaturalOrderComparator_2_classLit = createForClass('java.util', 'Comparators/ReverseNaturalOrderComparator', 1146);
function Comparators$ReversedComparator(comparator){
  this.comparator = comparator;
}

defineClass(64, 1, $intern_41, Comparators$ReversedComparator);
_.equals_0 = function equals_54(other){
  return this === other;
}
;
_.compare_0 = function compare_11(a, b){
  return this.comparator.compare_0(b, a);
}
;
_.reversed = function reversed_4(){
  return this.comparator;
}
;
var Ljava_util_Comparators$ReversedComparator_2_classLit = createForClass('java.util', 'Comparators/ReversedComparator', 64);
function checkStructuralChange(host, iterator){
  if (iterator['_gwt_modCount'] != host['_gwt_modCount']) {
    throw toJs(new ConcurrentModificationException);
  }
}

function recordLastKnownStructure(host, iterator){
  var modCount;
  modCount = host['_gwt_modCount'];
  iterator['_gwt_modCount'] = modCount;
}

function structureChanged(map_0){
  var modCount;
  modCount = map_0['_gwt_modCount'] | 0;
  map_0['_gwt_modCount'] = modCount + 1;
}

function ConcurrentModificationException(){
  RuntimeException.call(this);
}

defineClass(162, 54, $intern_44, ConcurrentModificationException);
var Ljava_util_ConcurrentModificationException_2_classLit = createForClass('java.util', 'ConcurrentModificationException', 162);
function $clinit_Date$StringData(){
  $clinit_Date$StringData = emptyMethod;
  DAYS = stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']);
  MONTHS = stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);
}

var DAYS, MONTHS;
function $accept(this$static, value_0){
  var compensatedValue, newSum;
  this$static.count = add_20(this$static.count, 1);
  this$static.min_0 = $wnd.Math.min(this$static.min_0, value_0);
  this$static.max_0 = $wnd.Math.max(this$static.max_0, value_0);
  this$static.naiveSum += value_0;
  compensatedValue = value_0 - this$static.sumError;
  newSum = this$static.sum + compensatedValue;
  this$static.sumError = newSum - this$static.sum - compensatedValue;
  this$static.sum = newSum;
}

function $getSum(this$static){
  var compensatedSum;
  compensatedSum = this$static.sum + this$static.sumError;
  if (isNaN(compensatedSum) && isInfinite(this$static.naiveSum)) {
    return this$static.naiveSum;
  }
  return compensatedSum;
}

function DoubleSummaryStatistics(){
}

defineClass(1640, 1, $intern_77, DoubleSummaryStatistics);
_.accept_1 = function accept_10(value_0){
  $accept(this, value_0);
}
;
_.toString_0 = function toString_64(){
  return 'DoubleSummaryStatistics[count = ' + toString_40(this.count) + ', avg = ' + (gt(this.count, 0)?$getSum(this) / toDouble_0(this.count):0) + ', min = ' + this.min_0 + ', max = ' + this.max_0 + ', sum = ' + $getSum(this) + ']';
}
;
_.count = 0;
_.max_0 = $intern_63;
_.min_0 = $intern_62;
_.naiveSum = 0;
_.sum = 0;
_.sumError = 0;
var Ljava_util_DoubleSummaryStatistics_2_classLit = createForClass('java.util', 'DoubleSummaryStatistics', 1640);
function EmptyStackException(){
  RuntimeException.call(this);
}

defineClass(1613, 54, $intern_44, EmptyStackException);
var Ljava_util_EmptyStackException_2_classLit = createForClass('java.util', 'EmptyStackException', 1613);
function $clear_4(this$static){
  $clear_1(this$static.keySet);
  this$static.values = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, this$static.values.length, 5, 1);
}

function $containsKey_4(this$static, key){
  return $contains_5(this$static.keySet, key);
}

function $get_10(this$static, k){
  return $contains_5(this$static.keySet, k)?this$static.values[castTo(k, 22).ordinal]:null;
}

function $put_2(this$static, key, value_0){
  $add_5(this$static.keySet, key);
  return $set_2(this$static, key.ordinal, value_0);
}

function $put_3(this$static, key, value_0){
  return $put_2(this$static, castTo(key, 22), value_0);
}

function $remove_16(this$static, key){
  return $remove_17(this$static.keySet, key)?$set_2(this$static, castTo(key, 22).ordinal, null):null;
}

function $set_2(this$static, ordinal, value_0){
  var was;
  was = this$static.values[ordinal];
  this$static.values[ordinal] = value_0;
  return was;
}

function EnumMap(type_0){
  var all;
  this.keySet = (all = castTo(type_0.enumConstantsFunc && type_0.enumConstantsFunc(), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  this.values = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, this.keySet.all.length, 5, 1);
}

defineClass(382, 1750, $intern_2, EnumMap);
_.put = function put_4(key, value_0){
  return $put_3(this, key, value_0);
}
;
_.clear_0 = function clear_36(){
  $clear_4(this);
}
;
_.containsKey = function containsKey_8(key){
  return $containsKey_4(this, key);
}
;
_.containsValue = function containsValue_4(value_0){
  var key, key$iterator;
  for (key$iterator = new EnumSet$EnumSetImpl$IteratorImpl(this.keySet); key$iterator.i < key$iterator.this$11.all.length;) {
    key = $next_11(key$iterator);
    if (equals_56(value_0, this.values[key.ordinal])) {
      return true;
    }
  }
  return false;
}
;
_.entrySet_0 = function entrySet_5(){
  return new EnumMap$EntrySet(this);
}
;
_.get_0 = function get_29(k){
  return $get_10(this, k);
}
;
_.remove = function remove_70(key){
  return $remove_16(this, key);
}
;
_.size_1 = function size_44(){
  return this.keySet.size_0;
}
;
var Ljava_util_EnumMap_2_classLit = createForClass('java.util', 'EnumMap', 382);
function $contains_4(this$static, o){
  if (instanceOf(o, 39)) {
    return $containsEntry_0(this$static.this$01, castTo(o, 39));
  }
  return false;
}

function EnumMap$EntrySet(this$0){
  this.this$01 = this$0;
}

defineClass(1210, $intern_13, $intern_14, EnumMap$EntrySet);
_.clear_0 = function clear_37(){
  $clear_4(this.this$01);
}
;
_.contains = function contains_35(o){
  return $contains_4(this, o);
}
;
_.iterator_0 = function iterator_49(){
  return new EnumMap$EntrySetIterator(this.this$01);
}
;
_.remove_1 = function remove_71(entry){
  var key;
  if ($contains_4(this, entry)) {
    key = castTo(entry, 39).getKey();
    $remove_16(this.this$01, key);
    return true;
  }
  return false;
}
;
_.size_1 = function size_45(){
  return this.this$01.keySet.size_0;
}
;
var Ljava_util_EnumMap$EntrySet_2_classLit = createForClass('java.util', 'EnumMap/EntrySet', 1210);
function EnumMap$EntrySetIterator(this$0){
  this.this$01 = this$0;
  this.it = new EnumSet$EnumSetImpl$IteratorImpl(this.this$01.keySet);
}

defineClass(1211, 1, $intern_4, EnumMap$EntrySetIterator);
_.forEachRemaining = function forEachRemaining_27(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_30(){
  return this.key = $next_11(this.it) , new EnumMap$MapEntry(this.this$01, this.key);
}
;
_.hasNext_0 = function hasNext_29(){
  return $hasNext_3(this.it);
}
;
_.remove_0 = function remove_72(){
  checkCriticalState(!!this.key);
  $remove_16(this.this$01, this.key);
  this.key = null;
}
;
var Ljava_util_EnumMap$EntrySetIterator_2_classLit = createForClass('java.util', 'EnumMap/EntrySetIterator', 1211);
function EnumMap$MapEntry(this$0, key){
  this.this$01 = this$0;
  this.key = key;
}

defineClass(1212, 1756, $intern_5, EnumMap$MapEntry);
_.getKey = function getKey_5(){
  return this.key;
}
;
_.getValue = function getValue_5(){
  return this.this$01.values[this.key.ordinal];
}
;
_.setValue = function setValue_6(value_0){
  return $set_2(this.this$01, this.key.ordinal, value_0);
}
;
var Ljava_util_EnumMap$MapEntry_2_classLit = createForClass('java.util', 'EnumMap/MapEntry', 1212);
function allOf(elementType){
  var all, set_0;
  all = castTo(elementType.enumConstantsFunc && elementType.enumConstantsFunc(), 10);
  set_0 = castTo(clone_0(all, all.length), 10);
  return new EnumSet$EnumSetImpl(all, set_0, all.length);
}

function of_0(first){
  var all, set_0, clazz, superclass;
  set_0 = (all = castTo($getEnumConstants((clazz = first.___clazz , superclass = clazz.enumSuperclass , superclass == Ljava_lang_Enum_2_classLit?clazz:superclass)), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  $add_5(set_0, first);
  return set_0;
}

function of_1(first, rest){
  var set_0;
  set_0 = of_0(first);
  addAll_8(set_0, rest);
  return set_0;
}

defineClass(190, $intern_13, {20:1, 28:1, 13:1, 190:1, 19:1});
var Ljava_util_EnumSet_2_classLit = createForClass('java.util', 'EnumSet', 190);
function $add_5(this$static, e){
  var ordinal;
  checkCriticalNotNull(e);
  ordinal = e.ordinal;
  if (!this$static.set_0[ordinal]) {
    setCheck(this$static.set_0, ordinal, e);
    ++this$static.size_0;
    return true;
  }
  return false;
}

function $clone(this$static){
  var clonedSet;
  clonedSet = castTo(clone_0(this$static.set_0, this$static.set_0.length), 10);
  return new EnumSet$EnumSetImpl(this$static.all, clonedSet, this$static.size_0);
}

function $contains_5(this$static, o){
  return instanceOf(o, 22) && $containsEnum(this$static, castTo(o, 22));
}

function $containsEnum(this$static, e){
  return !!e && this$static.set_0[e.ordinal] == e;
}

function $remove_17(this$static, o){
  return instanceOf(o, 22) && $removeEnum(this$static, castTo(o, 22));
}

function $removeEnum(this$static, e){
  if (!!e && this$static.set_0[e.ordinal] == e) {
    setCheck(this$static.set_0, e.ordinal, null);
    --this$static.size_0;
    return true;
  }
  return false;
}

function EnumSet$EnumSetImpl(all, set_0, size_0){
  this.all = all;
  this.set_0 = set_0;
  this.size_0 = size_0;
}

defineClass(134, 190, {20:1, 28:1, 13:1, 190:1, 134:1, 19:1}, EnumSet$EnumSetImpl);
_.add_1 = function add_34(e){
  return $add_5(this, castTo(e, 22));
}
;
_.contains = function contains_36(o){
  return $contains_5(this, o);
}
;
_.iterator_0 = function iterator_50(){
  return new EnumSet$EnumSetImpl$IteratorImpl(this);
}
;
_.remove_1 = function remove_73(o){
  return $remove_17(this, o);
}
;
_.size_1 = function size_46(){
  return this.size_0;
}
;
_.size_0 = 0;
var Ljava_util_EnumSet$EnumSetImpl_2_classLit = createForClass('java.util', 'EnumSet/EnumSetImpl', 134);
function $findNext(this$static){
  var c;
  ++this$static.i;
  for (c = this$static.this$11.all.length; this$static.i < c; ++this$static.i) {
    if (this$static.this$11.set_0[this$static.i]) {
      return;
    }
  }
}

function $hasNext_3(this$static){
  return this$static.i < this$static.this$11.all.length;
}

function $next_11(this$static){
  checkCriticalElement(this$static.i < this$static.this$11.all.length);
  this$static.last = this$static.i;
  $findNext(this$static);
  return this$static.this$11.set_0[this$static.last];
}

function EnumSet$EnumSetImpl$IteratorImpl(this$1){
  this.this$11 = this$1;
  $findNext(this);
}

defineClass(366, 1, $intern_4, EnumSet$EnumSetImpl$IteratorImpl);
_.forEachRemaining = function forEachRemaining_28(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_31(){
  return $next_11(this);
}
;
_.hasNext_0 = function hasNext_30(){
  return $hasNext_3(this);
}
;
_.remove_0 = function remove_74(){
  checkCriticalState(this.last != -1);
  setCheck(this.this$11.set_0, this.last, null);
  --this.this$11.size_0;
  this.last = -1;
}
;
_.i = -1;
_.last = -1;
var Ljava_util_EnumSet$EnumSetImpl$IteratorImpl_2_classLit = createForClass('java.util', 'EnumSet/EnumSetImpl/IteratorImpl', 366);
function HashMap(){
  $reset(this);
}

function HashMap_0(ignored){
  AbstractHashMap.call(this, ignored, 0);
}

function HashMap_1(toBeCopied){
  $reset(this);
  $putAll(this, toBeCopied);
}

defineClass(41, 457, $intern_78, HashMap, HashMap_0, HashMap_1);
_.equals_1 = function equals_55(value1, value2){
  return maskUndefined(value1) === maskUndefined(value2) || value1 != null && equals_Ljava_lang_Object__Z__devirtual$(value1, value2);
}
;
_.getHashCode = function getHashCode(key){
  var hashCode;
  hashCode = hashCode__I__devirtual$(key);
  return hashCode | 0;
}
;
var Ljava_util_HashMap_2_classLit = createForClass('java.util', 'HashMap', 41);
function $add_6(this$static, o){
  var old;
  old = this$static.map_0.put(o, this$static);
  return old == null;
}

function $contains_6(this$static, o){
  return this$static.map_0.containsKey(o);
}

function $remove_18(this$static, o){
  return this$static.map_0.remove(o) != null;
}

function HashSet(){
  this.map_0 = new HashMap;
}

function HashSet_0(initialCapacity){
  this.map_0 = new HashMap_0(initialCapacity);
}

function HashSet_1(c){
  this.map_0 = new HashMap_0(c.size_1());
  $addAll(this, c);
}

function HashSet_2(map_0){
  this.map_0 = map_0;
}

defineClass(65, $intern_13, $intern_79, HashSet, HashSet_0, HashSet_1);
_.add_1 = function add_35(o){
  return $add_6(this, o);
}
;
_.clear_0 = function clear_38(){
  this.map_0.clear_0();
}
;
_.contains = function contains_37(o){
  return $contains_6(this, o);
}
;
_.isEmpty = function isEmpty_19(){
  return this.map_0.size_1() == 0;
}
;
_.iterator_0 = function iterator_51(){
  return this.map_0.keySet_0().iterator_0();
}
;
_.remove_1 = function remove_75(o){
  return $remove_18(this, o);
}
;
_.size_1 = function size_47(){
  return this.map_0.size_1();
}
;
var Ljava_util_HashSet_2_classLit = createForClass('java.util', 'HashSet', 65);
function $accept_0(this$static, value_0){
  this$static.count = add_20(this$static.count, 1);
  this$static.min_0 = min_1(this$static.min_0, value_0);
  this$static.max_0 = max_1(this$static.max_0, value_0);
  this$static.sum = add_20(this$static.sum, value_0);
}

function IntSummaryStatistics(){
}

defineClass(1626, 1, $intern_80, IntSummaryStatistics);
_.accept_2 = function accept_11(value_0){
  $accept_0(this, value_0);
}
;
_.toString_0 = function toString_65(){
  return 'IntSummaryStatistics[count = ' + toString_40(this.count) + ', avg = ' + (gt(this.count, 0)?toDouble_0(this.sum) / toDouble_0(this.count):0) + ', min = ' + this.min_0 + ', max = ' + this.max_0 + ', sum = ' + toString_40(this.sum) + ']';
}
;
_.count = 0;
_.max_0 = $intern_43;
_.min_0 = $intern_0;
_.sum = 0;
var Ljava_util_IntSummaryStatistics_2_classLit = createForClass('java.util', 'IntSummaryStatistics', 1626);
function $findEntryInChain(this$static, key, chain){
  var entry, entry$index, entry$max;
  for (entry$index = 0 , entry$max = chain.length; entry$index < entry$max; ++entry$index) {
    entry = chain[entry$index];
    if (this$static.host.equals_1(key, entry.getKey())) {
      return entry;
    }
  }
  return null;
}

function $getChainOrEmpty(this$static, hashCode){
  var chain;
  chain = this$static.backingMap.get(hashCode);
  return chain == null?[]:chain;
}

function $getEntry(this$static, key){
  return $findEntryInChain(this$static, key, $getChainOrEmpty(this$static, key == null?0:this$static.host.getHashCode(key)));
}

function $put_4(this$static, key, value_0){
  var chain, chain0, entry, hashCode;
  hashCode = key == null?0:this$static.host.getHashCode(key);
  chain0 = (chain = this$static.backingMap.get(hashCode) , chain == null?[]:chain);
  if (chain0.length == 0) {
    this$static.backingMap.set(hashCode, chain0);
  }
   else {
    entry = $findEntryInChain(this$static, key, chain0);
    if (entry) {
      return entry.setValue(value_0);
    }
  }
  setCheck(chain0, chain0.length, new AbstractMap$SimpleEntry(key, value_0));
  ++this$static.size_0;
  structureChanged(this$static.host);
  return null;
}

function $remove_19(this$static, key){
  var chain, chain0, entry, hashCode, i;
  hashCode = key == null?0:this$static.host.getHashCode(key);
  chain0 = (chain = this$static.backingMap.get(hashCode) , chain == null?[]:chain);
  for (i = 0; i < chain0.length; i++) {
    entry = chain0[i];
    if (this$static.host.equals_1(key, entry.getKey())) {
      if (chain0.length == 1) {
        chain0.length = 0;
        this$static.backingMap['delete'](hashCode);
      }
       else {
        chain0.splice(i, 1);
      }
      --this$static.size_0;
      structureChanged(this$static.host);
      return entry.getValue();
    }
  }
  return null;
}

function InternalHashCodeMap(host){
  this.backingMap = newJsMap();
  this.host = host;
}

defineClass(949, 1, $intern_27, InternalHashCodeMap);
_.forEach_0 = function forEach_15(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_52(){
  return new InternalHashCodeMap$1(this);
}
;
_.size_0 = 0;
var Ljava_util_InternalHashCodeMap_2_classLit = createForClass('java.util', 'InternalHashCodeMap', 949);
function InternalHashCodeMap$1(this$0){
  this.this$01 = this$0;
  this.chains = this.this$01.backingMap.entries();
  this.chain = [];
}

defineClass(659, 1, $intern_4, InternalHashCodeMap$1);
_.forEachRemaining = function forEachRemaining_29(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_32(){
  return this.lastEntry = this.chain[this.itemIndex++] , this.lastEntry;
}
;
_.hasNext_0 = function hasNext_31(){
  var current;
  if (this.itemIndex < this.chain.length) {
    return true;
  }
  current = this.chains.next();
  if (!current.done) {
    this.chain = current.value[1];
    this.itemIndex = 0;
    return true;
  }
  return false;
}
;
_.remove_0 = function remove_76(){
  $remove_19(this.this$01, this.lastEntry.getKey());
  this.itemIndex != 0 && --this.itemIndex;
}
;
_.itemIndex = 0;
_.lastEntry = null;
var Ljava_util_InternalHashCodeMap$1_2_classLit = createForClass('java.util', 'InternalHashCodeMap/1', 659);
function $clinit_InternalJsMapFactory(){
  $clinit_InternalJsMapFactory = emptyMethod;
  jsMapCtor = getJsMapConstructor();
}

function canHandleObjectCreateAndProto(){
  if (!Object.create || !Object.getOwnPropertyNames) {
    return false;
  }
  var protoField = '__proto__';
  var map_0 = Object.create(null);
  if (map_0[protoField] !== undefined) {
    return false;
  }
  var keys_0 = Object.getOwnPropertyNames(map_0);
  if (keys_0.length != 0) {
    return false;
  }
  map_0[protoField] = 42;
  if (map_0[protoField] !== 42) {
    return false;
  }
  if (Object.getOwnPropertyNames(map_0).length == 0) {
    return false;
  }
  return true;
}

function getJsMapConstructor(){
  function isCorrectIterationProtocol(){
    try {
      return (new Map).entries().next().done;
    }
     catch (e) {
      return false;
    }
  }

  if (typeof Map === 'function' && Map.prototype.entries && isCorrectIterationProtocol()) {
    return Map;
  }
   else {
    return getJsMapPolyFill();
  }
}

function getJsMapPolyFill(){
  function Stringmap(){
    this.obj = this.createObject();
  }

  ;
  Stringmap.prototype.createObject = function(key){
    return Object.create(null);
  }
  ;
  Stringmap.prototype.get = function(key){
    return this.obj[key];
  }
  ;
  Stringmap.prototype.set = function(key, value_0){
    this.obj[key] = value_0;
  }
  ;
  Stringmap.prototype['delete'] = function(key){
    delete this.obj[key];
  }
  ;
  Stringmap.prototype.keys = function(){
    return Object.getOwnPropertyNames(this.obj);
  }
  ;
  Stringmap.prototype.entries = function(){
    var keys_0 = this.keys();
    var map_0 = this;
    var nextIndex = 0;
    return {next:function(){
      if (nextIndex >= keys_0.length)
        return {done:true};
      var key = keys_0[nextIndex++];
      return {value:[key, map_0.get(key)], done:false};
    }
    };
  }
  ;
  if (!canHandleObjectCreateAndProto()) {
    Stringmap.prototype.createObject = function(){
      return {};
    }
    ;
    Stringmap.prototype.get = function(key){
      return this.obj[':' + key];
    }
    ;
    Stringmap.prototype.set = function(key, value_0){
      this.obj[':' + key] = value_0;
    }
    ;
    Stringmap.prototype['delete'] = function(key){
      delete this.obj[':' + key];
    }
    ;
    Stringmap.prototype.keys = function(){
      var result = [];
      for (var key in this.obj) {
        key.charCodeAt(0) == 58 && result.push(key.substring(1));
      }
      return result;
    }
    ;
  }
  return Stringmap;
}

function newJsMap(){
  $clinit_InternalJsMapFactory();
  return new jsMapCtor;
}

var jsMapCtor;
function $contains_7(this$static, key){
  return !(this$static.backingMap.get(key) === undefined);
}

function $get_11(this$static, key){
  return this$static.backingMap.get(key);
}

function $put_5(this$static, key, value_0){
  var oldValue;
  oldValue = this$static.backingMap.get(key);
  this$static.backingMap.set(key, value_0 === undefined?null:value_0);
  if (oldValue === undefined) {
    ++this$static.size_0;
    structureChanged(this$static.host);
  }
   else {
    ++this$static.valueMod;
  }
  return oldValue;
}

function $remove_20(this$static, key){
  var value_0;
  value_0 = this$static.backingMap.get(key);
  if (value_0 === undefined) {
    ++this$static.valueMod;
  }
   else {
    this$static.backingMap['delete'](key);
    --this$static.size_0;
    structureChanged(this$static.host);
  }
  return value_0;
}

function InternalStringMap(host){
  this.backingMap = newJsMap();
  this.host = host;
}

defineClass(947, 1, $intern_27, InternalStringMap);
_.forEach_0 = function forEach_16(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_53(){
  return new InternalStringMap$1(this);
}
;
_.size_0 = 0;
_.valueMod = 0;
var Ljava_util_InternalStringMap_2_classLit = createForClass('java.util', 'InternalStringMap', 947);
function InternalStringMap$1(this$0){
  this.this$01 = this$0;
  this.entries_0 = this.this$01.backingMap.entries();
  this.current = this.entries_0.next();
}

defineClass(658, 1, $intern_4, InternalStringMap$1);
_.forEachRemaining = function forEachRemaining_30(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_33(){
  return this.last = this.current , this.current = this.entries_0.next() , new InternalStringMap$2(this.this$01, this.last, this.this$01.valueMod);
}
;
_.hasNext_0 = function hasNext_32(){
  return !this.current.done;
}
;
_.remove_0 = function remove_77(){
  $remove_20(this.this$01, this.last.value[0]);
}
;
var Ljava_util_InternalStringMap$1_2_classLit = createForClass('java.util', 'InternalStringMap/1', 658);
function InternalStringMap$2(this$0, val$entry, val$lastValueMod){
  this.this$01 = this$0;
  this.val$entry2 = val$entry;
  this.val$lastValueMod3 = val$lastValueMod;
}

defineClass(948, 1756, $intern_5, InternalStringMap$2);
_.getKey = function getKey_6(){
  return this.val$entry2.value[0];
}
;
_.getValue = function getValue_6(){
  if (this.this$01.valueMod != this.val$lastValueMod3) {
    return $get_11(this.this$01, this.val$entry2.value[0]);
  }
  return this.val$entry2.value[1];
}
;
_.setValue = function setValue_7(object){
  return $put_5(this.this$01, this.val$entry2.value[0], object);
}
;
_.val$lastValueMod3 = 0;
var Ljava_util_InternalStringMap$2_2_classLit = createForClass('java.util', 'InternalStringMap/2', 948);
function $$init_3(this$static){
  this$static.head = new LinkedHashMap$ChainEntry(this$static);
  this$static.map_0 = new HashMap;
}

function $clear_5(this$static){
  $reset(this$static.map_0);
  this$static.head.prev = this$static.head;
  this$static.head.next_0 = this$static.head;
}

function $get_12(this$static, key){
  var entry;
  entry = castTo($get_6(this$static.map_0, key), 365);
  if (entry) {
    $recordAccess(this$static, entry);
    return entry.value_0;
  }
  return null;
}

function $put_6(this$static, key, value_0){
  var newEntry, old, oldValue;
  old = castTo($get_6(this$static.map_0, key), 365);
  if (!old) {
    newEntry = new LinkedHashMap$ChainEntry_0(this$static, key, value_0);
    $put_1(this$static.map_0, key, newEntry);
    $addToEnd(newEntry);
    return null;
  }
   else {
    oldValue = $setValue(old, value_0);
    $recordAccess(this$static, old);
    return oldValue;
  }
}

function $recordAccess(this$static, entry){
  if (this$static.accessOrder) {
    $remove_23(entry);
    $addToEnd(entry);
  }
}

function $remove_22(this$static, key){
  var entry;
  entry = castTo($remove_7(this$static.map_0, key), 365);
  if (entry) {
    $remove_23(entry);
    return entry.value_0;
  }
  return null;
}

function LinkedHashMap(){
  HashMap.call(this);
  $$init_3(this);
  this.head.prev = this.head;
  this.head.next_0 = this.head;
}

function LinkedHashMap_0(ignored){
  AbstractHashMap.call(this, ignored, 0);
  $$init_3(this);
  this.head.prev = this.head;
  this.head.next_0 = this.head;
}

defineClass(220, 41, $intern_78, LinkedHashMap, LinkedHashMap_0);
_.clear_0 = function clear_39(){
  $clear_5(this);
}
;
_.containsKey = function containsKey_9(key){
  return $containsKey_2(this.map_0, key);
}
;
_.containsValue = function containsValue_5(value_0){
  var node;
  node = this.head.next_0;
  while (node != this.head) {
    if (equals_56(node.value_0, value_0)) {
      return true;
    }
    node = node.next_0;
  }
  return false;
}
;
_.entrySet_0 = function entrySet_6(){
  return new LinkedHashMap$EntrySet(this);
}
;
_.get_0 = function get_30(key){
  return $get_12(this, key);
}
;
_.put = function put_5(key, value_0){
  return $put_6(this, key, value_0);
}
;
_.remove = function remove_78(key){
  return $remove_22(this, key);
}
;
_.size_1 = function size_48(){
  return $size_0(this.map_0);
}
;
_.accessOrder = false;
var Ljava_util_LinkedHashMap_2_classLit = createForClass('java.util', 'LinkedHashMap', 220);
function $addToEnd(this$static){
  var tail;
  tail = this$static.this$01.head.prev;
  this$static.prev = tail;
  this$static.next_0 = this$static.this$01.head;
  tail.next_0 = this$static.this$01.head.prev = this$static;
}

function $remove_23(this$static){
  this$static.next_0.prev = this$static.prev;
  this$static.prev.next_0 = this$static.next_0;
  this$static.next_0 = this$static.prev = null;
}

function LinkedHashMap$ChainEntry(this$0){
  LinkedHashMap$ChainEntry_0.call(this, this$0, null, null);
}

function LinkedHashMap$ChainEntry_0(this$0, key, value_0){
  this.this$01 = this$0;
  AbstractMap$SimpleEntry.call(this, key, value_0);
}

defineClass(365, 363, {456:1, 363:1, 365:1, 39:1}, LinkedHashMap$ChainEntry, LinkedHashMap$ChainEntry_0);
var Ljava_util_LinkedHashMap$ChainEntry_2_classLit = createForClass('java.util', 'LinkedHashMap/ChainEntry', 365);
function $contains_8(this$static, o){
  if (instanceOf(o, 39)) {
    return $containsEntry_0(this$static.this$01, castTo(o, 39));
  }
  return false;
}

function LinkedHashMap$EntrySet(this$0){
  this.this$01 = this$0;
}

defineClass(571, $intern_13, $intern_14, LinkedHashMap$EntrySet);
_.clear_0 = function clear_40(){
  $clear_5(this.this$01);
}
;
_.contains = function contains_38(o){
  return $contains_8(this, o);
}
;
_.iterator_0 = function iterator_54(){
  return new LinkedHashMap$EntrySet$EntryIterator(this);
}
;
_.remove_1 = function remove_79(entry){
  var key;
  if ($contains_8(this, entry)) {
    key = castTo(entry, 39).getKey();
    $remove_22(this.this$01, key);
    return true;
  }
  return false;
}
;
_.size_1 = function size_49(){
  return $size_0(this.this$01.map_0);
}
;
var Ljava_util_LinkedHashMap$EntrySet_2_classLit = createForClass('java.util', 'LinkedHashMap/EntrySet', 571);
function $next_12(this$static){
  checkStructuralChange(this$static.this$11.this$01.map_0, this$static);
  checkCriticalElement(this$static.next_0 != this$static.this$11.this$01.head);
  this$static.last = this$static.next_0;
  this$static.next_0 = this$static.next_0.next_0;
  return this$static.last;
}

function LinkedHashMap$EntrySet$EntryIterator(this$1){
  this.this$11 = this$1;
  this.next_0 = this$1.this$01.head.next_0;
  recordLastKnownStructure(this$1.this$01.map_0, this);
}

defineClass(572, 1, $intern_4, LinkedHashMap$EntrySet$EntryIterator);
_.forEachRemaining = function forEachRemaining_31(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_34(){
  return $next_12(this);
}
;
_.hasNext_0 = function hasNext_33(){
  return this.next_0 != this.this$11.this$01.head;
}
;
_.remove_0 = function remove_80(){
  checkCriticalState(!!this.last);
  checkStructuralChange(this.this$11.this$01.map_0, this);
  $remove_23(this.last);
  $remove_7(this.this$11.this$01.map_0, this.last.key);
  recordLastKnownStructure(this.this$11.this$01.map_0, this);
  this.last = null;
}
;
var Ljava_util_LinkedHashMap$EntrySet$EntryIterator_2_classLit = createForClass('java.util', 'LinkedHashMap/EntrySet/EntryIterator', 572);
function LinkedHashSet(){
  HashSet_2.call(this, new LinkedHashMap);
}

function LinkedHashSet_0(ignored){
  HashSet_2.call(this, new LinkedHashMap_0(ignored));
}

function LinkedHashSet_1(c){
  HashSet_2.call(this, new LinkedHashMap);
  $addAll(this, c);
}

defineClass(129, 65, $intern_79, LinkedHashSet, LinkedHashSet_0, LinkedHashSet_1);
var Ljava_util_LinkedHashSet_2_classLit = createForClass('java.util', 'LinkedHashSet', 129);
function $$init_4(this$static){
  this$static.header = new LinkedList$Node;
  this$static.tail = new LinkedList$Node;
}

function $add_7(this$static, o){
  $addNode_0(this$static, o, this$static.tail.prev, this$static.tail);
  return true;
}

function $addFirst_0(this$static, o){
  $addNode_0(this$static, o, this$static.header, this$static.header.next_0);
}

function $addLast_0(this$static, o){
  $addNode_0(this$static, o, this$static.tail.prev, this$static.tail);
}

function $addNode_0(this$static, o, prev, next){
  var node;
  node = new LinkedList$Node;
  node.value_0 = o;
  node.prev = prev;
  node.next_0 = next;
  next.prev = prev.next_0 = node;
  ++this$static.size_0;
}

function $getFirst(this$static){
  checkCriticalElement(this$static.size_0 != 0);
  return this$static.header.next_0.value_0;
}

function $getLast(this$static){
  checkCriticalElement(this$static.size_0 != 0);
  return this$static.tail.prev.value_0;
}

function $listIterator_1(this$static, index_0){
  var i, node;
  checkCriticalPositionIndex(index_0, this$static.size_0);
  if (index_0 >= this$static.size_0 >> 1) {
    node = this$static.tail;
    for (i = this$static.size_0; i > index_0; --i) {
      node = node.prev;
    }
  }
   else {
    node = this$static.header.next_0;
    for (i = 0; i < index_0; ++i) {
      node = node.next_0;
    }
  }
  return new LinkedList$ListIteratorImpl(this$static, index_0, node);
}

function $poll(this$static){
  return this$static.size_0 == 0?null:(checkCriticalElement(this$static.size_0 != 0) , $removeNode_0(this$static, this$static.header.next_0));
}

function $removeFirst_0(this$static){
  checkCriticalElement(this$static.size_0 != 0);
  return $removeNode_0(this$static, this$static.header.next_0);
}

function $removeLast(this$static){
  checkCriticalElement(this$static.size_0 != 0);
  return $removeNode_0(this$static, this$static.tail.prev);
}

function $removeNode_0(this$static, node){
  var oldValue;
  oldValue = node.value_0;
  node.next_0.prev = node.prev;
  node.prev.next_0 = node.next_0;
  node.next_0 = node.prev = null;
  node.value_0 = null;
  --this$static.size_0;
  return oldValue;
}

function $reset_0(this$static){
  this$static.header.next_0 = this$static.tail;
  this$static.tail.prev = this$static.header;
  this$static.header.prev = this$static.tail.next_0 = null;
  this$static.size_0 = 0;
}

function LinkedList(){
  $$init_4(this);
  $reset_0(this);
}

function LinkedList_0(c){
  $$init_4(this);
  $reset_0(this);
  $addAll(this, c);
}

defineClass(68, 1741, {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 68:1, 15:1}, LinkedList, LinkedList_0);
_.add_1 = function add_36(o){
  return $add_7(this, o);
}
;
_.clear_0 = function clear_41(){
  $reset_0(this);
}
;
_.listIterator_1 = function listIterator_12(index_0){
  return $listIterator_1(this, index_0);
}
;
_.size_1 = function size_50(){
  return this.size_0;
}
;
_.size_0 = 0;
var Ljava_util_LinkedList_2_classLit = createForClass('java.util', 'LinkedList', 68);
function $add_8(this$static, o){
  $addNode_0(this$static.this$01, o, this$static.currentNode.prev, this$static.currentNode);
  ++this$static.currentIndex;
  this$static.lastNode = null;
}

function $hasNext_4(this$static){
  return this$static.currentNode != this$static.this$01.tail;
}

function $next_13(this$static){
  checkCriticalElement(this$static.currentNode != this$static.this$01.tail);
  this$static.lastNode = this$static.currentNode;
  this$static.currentNode = this$static.currentNode.next_0;
  ++this$static.currentIndex;
  return this$static.lastNode.value_0;
}

function $previous_1(this$static){
  checkCriticalElement(this$static.currentNode.prev != this$static.this$01.header);
  this$static.lastNode = this$static.currentNode = this$static.currentNode.prev;
  --this$static.currentIndex;
  return this$static.lastNode.value_0;
}

function $remove_24(this$static){
  var nextNode;
  checkCriticalState(!!this$static.lastNode);
  nextNode = this$static.lastNode.next_0;
  $removeNode_0(this$static.this$01, this$static.lastNode);
  this$static.currentNode == this$static.lastNode?(this$static.currentNode = nextNode):--this$static.currentIndex;
  this$static.lastNode = null;
}

function LinkedList$ListIteratorImpl(this$0, index_0, startNode){
  this.this$01 = this$0;
  this.currentNode = startNode;
  this.currentIndex = index_0;
}

defineClass(820, 1, $intern_18, LinkedList$ListIteratorImpl);
_.forEachRemaining = function forEachRemaining_32(consumer){
  $forEachRemaining(this, consumer);
}
;
_.add_2 = function add_37(o){
  $add_8(this, o);
}
;
_.hasNext_0 = function hasNext_34(){
  return $hasNext_4(this);
}
;
_.hasPrevious = function hasPrevious_8(){
  return this.currentNode.prev != this.this$01.header;
}
;
_.next_1 = function next_35(){
  return $next_13(this);
}
;
_.nextIndex_0 = function nextIndex_9(){
  return this.currentIndex;
}
;
_.previous_0 = function previous_9(){
  return $previous_1(this);
}
;
_.previousIndex = function previousIndex_8(){
  return this.currentIndex - 1;
}
;
_.remove_0 = function remove_81(){
  $remove_24(this);
}
;
_.set_1 = function set_19(o){
  checkCriticalState(!!this.lastNode);
  this.lastNode.value_0 = o;
}
;
_.currentIndex = 0;
_.lastNode = null;
var Ljava_util_LinkedList$ListIteratorImpl_2_classLit = createForClass('java.util', 'LinkedList/ListIteratorImpl', 820);
function LinkedList$Node(){
}

defineClass(565, 1, {}, LinkedList$Node);
var Ljava_util_LinkedList$Node_2_classLit = createForClass('java.util', 'LinkedList/Node', 565);
function $clinit_Locale(){
  $clinit_Locale = emptyMethod;
  ROOT = new Locale$1;
  defaultLocale = new Locale$4;
}

defineClass(1736, 1, {});
var ROOT, defaultLocale;
var Ljava_util_Locale_2_classLit = createForClass('java.util', 'Locale', 1736);
function Locale$1(){
}

defineClass(790, 1736, {}, Locale$1);
_.toString_0 = function toString_66(){
  return '';
}
;
var Ljava_util_Locale$1_2_classLit = createForClass('java.util', 'Locale/1', 790);
function Locale$4(){
}

defineClass(791, 1736, {}, Locale$4);
_.toString_0 = function toString_67(){
  return 'unknown';
}
;
var Ljava_util_Locale$4_2_classLit = createForClass('java.util', 'Locale/4', 791);
function NoSuchElementException(){
  RuntimeException.call(this);
}

defineClass(104, 54, {3:1, 102:1, 54:1, 79:1, 104:1}, NoSuchElementException);
var Ljava_util_NoSuchElementException_2_classLit = createForClass('java.util', 'NoSuchElementException', 104);
function equals_56(a, b){
  return maskUndefined(a) === maskUndefined(b) || a != null && equals_Ljava_lang_Object__Z__devirtual$(a, b);
}

function hashCode_49(o){
  return o != null?hashCode__I__devirtual$(o):0;
}

function requireNonNull(obj, message){
  if (!obj) {
    throw toJs(new NullPointerException_0(message));
  }
  return obj;
}

function $clinit_Optional(){
  $clinit_Optional = emptyMethod;
  EMPTY_1 = new Optional(null);
}

function $get_13(this$static){
  checkCriticalElement(this$static.ref != null);
  return this$static.ref;
}

function $ifPresent(this$static, consumer){
  this$static.ref != null && $accept_4(consumer, this$static.ref);
}

function Optional(ref){
  $clinit_Optional();
  this.ref = ref;
}

defineClass(419, 1, {419:1}, Optional);
_.equals_0 = function equals_57(obj){
  var other;
  if (obj === this) {
    return true;
  }
  if (!instanceOf(obj, 419)) {
    return false;
  }
  other = castTo(obj, 419);
  return equals_56(this.ref, other.ref);
}
;
_.hashCode_1 = function hashCode_50(){
  return hashCode_49(this.ref);
}
;
_.toString_0 = function toString_68(){
  return this.ref != null?'Optional.of(' + valueOf_7(this.ref) + ')':'Optional.empty()';
}
;
var EMPTY_1;
var Ljava_util_Optional_2_classLit = createForClass('java.util', 'Optional', 419);
function $clinit_OptionalDouble(){
  $clinit_OptionalDouble = emptyMethod;
  EMPTY_2 = new OptionalDouble;
}

function $orElse(this$static){
  return this$static.present?this$static.ref:0;
}

function $orElseGet(this$static, other){
  return this$static.present?this$static.ref:other.getAsDouble();
}

function OptionalDouble(){
  this.ref = 0;
  this.present = false;
}

function OptionalDouble_0(value_0){
  $clinit_OptionalDouble();
  this.ref = value_0;
  this.present = true;
}

defineClass(439, 1, {439:1}, OptionalDouble, OptionalDouble_0);
_.equals_0 = function equals_58(obj){
  var other;
  if (obj === this) {
    return true;
  }
  if (!instanceOf(obj, 439)) {
    return false;
  }
  other = castTo(obj, 439);
  return this.present == other.present && compare_5(this.ref, other.ref) == 0;
}
;
_.hashCode_1 = function hashCode_51(){
  return this.present?round_int(this.ref):0;
}
;
_.toString_0 = function toString_69(){
  return this.present?'OptionalDouble.of(' + ('' + this.ref) + ')':'OptionalDouble.empty()';
}
;
_.present = false;
_.ref = 0;
var EMPTY_2;
var Ljava_util_OptionalDouble_2_classLit = createForClass('java.util', 'OptionalDouble', 439);
function $clinit_OptionalInt(){
  $clinit_OptionalInt = emptyMethod;
  EMPTY_3 = new OptionalInt;
}

function $orElse_0(this$static){
  return this$static.present?this$static.ref:0;
}

function OptionalInt(){
  this.ref = 0;
  this.present = false;
}

function OptionalInt_0(value_0){
  $clinit_OptionalInt();
  this.ref = value_0;
  this.present = true;
}

defineClass(487, 1, {487:1}, OptionalInt, OptionalInt_0);
_.equals_0 = function equals_59(obj){
  var other;
  if (obj === this) {
    return true;
  }
  if (!instanceOf(obj, 487)) {
    return false;
  }
  other = castTo(obj, 487);
  return this.present == other.present && compare_6(this.ref, other.ref) == 0;
}
;
_.hashCode_1 = function hashCode_52(){
  return this.present?this.ref:0;
}
;
_.toString_0 = function toString_70(){
  return this.present?'OptionalInt.of(' + ('' + this.ref) + ')':'OptionalInt.empty()';
}
;
_.present = false;
_.ref = 0;
var EMPTY_3;
var Ljava_util_OptionalInt_2_classLit = createForClass('java.util', 'OptionalInt', 487);
function $forEachRemaining_0(this$static, consumer){
  checkCriticalNotNull(consumer);
  while (this$static.hasElement || (this$static.hasElement = $tryAdvance_1(this$static.spliterator, this$static)) , this$static.hasElement) {
    consumer.accept_1($nextDouble_0(this$static));
  }
}

function PrimitiveIterator$OfDouble$0methodref$accept$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(640, 1, $intern_77, PrimitiveIterator$OfDouble$0methodref$accept$Type);
_.accept_1 = function accept_12(arg0){
  this.$$outer_0.accept(arg0);
}
;
var Ljava_util_PrimitiveIterator$OfDouble$0methodref$accept$Type_2_classLit = createForClass('java.util', 'PrimitiveIterator/OfDouble/0methodref$accept$Type', 640);
function $addAll_3(this$static, c){
  checkCriticalNotNull(c);
  checkCriticalArgument(c != this$static);
  if ($addAll_2(this$static.heap, c)) {
    $makeHeap(this$static, 0);
    return true;
  }
  return false;
}

function $makeHeap(this$static, node){
  var rightChild;
  if (node * 2 + 1 >= this$static.heap.array.length) {
    return;
  }
  $makeHeap(this$static, 2 * node + 1);
  rightChild = 2 * node + 2;
  rightChild < this$static.heap.array.length && $makeHeap(this$static, rightChild);
  $mergeHeaps(this$static, node);
}

function $mergeHeaps(this$static, node){
  var heapSize, smallestChild, value_0, leftChild, rightChild, smallestChild_0;
  heapSize = this$static.heap.array.length;
  value_0 = $get_7(this$static.heap, node);
  while (node * 2 + 1 < heapSize) {
    smallestChild = (leftChild = 2 * node + 1 , rightChild = leftChild + 1 , smallestChild_0 = leftChild , rightChild < heapSize && this$static.cmp.compare_0($get_7(this$static.heap, rightChild), $get_7(this$static.heap, leftChild)) < 0 && (smallestChild_0 = rightChild) , smallestChild_0);
    if (this$static.cmp.compare_0(value_0, $get_7(this$static.heap, smallestChild)) < 0) {
      break;
    }
    $set_1(this$static.heap, node, $get_7(this$static.heap, smallestChild));
    node = smallestChild;
  }
  $set_1(this$static.heap, node, value_0);
}

function $offer(this$static, e){
  var childNode, node;
  checkCriticalNotNull(e);
  node = this$static.heap.array.length;
  $add_4(this$static.heap, e);
  while (node > 0) {
    childNode = node;
    node = (node - 1) / 2 | 0;
    if (this$static.cmp.compare_0($get_7(this$static.heap, node), e) <= 0) {
      $set_1(this$static.heap, childNode, e);
      return true;
    }
    $set_1(this$static.heap, childNode, $get_7(this$static.heap, node));
  }
  $set_1(this$static.heap, node, e);
  return true;
}

function $poll_0(this$static){
  var value_0;
  value_0 = this$static.heap.array.length == 0?null:$get_7(this$static.heap, 0);
  value_0 != null && $removeAtIndex_0(this$static, 0);
  return value_0;
}

function $remove_25(this$static, o){
  var index_0;
  index_0 = o == null?-1:$indexOf_3(this$static.heap, o, 0);
  if (index_0 < 0) {
    return false;
  }
  $removeAtIndex_0(this$static, index_0);
  return true;
}

function $removeAtIndex_0(this$static, index_0){
  var lastValue;
  lastValue = $remove_12(this$static.heap, this$static.heap.array.length - 1);
  if (index_0 < this$static.heap.array.length) {
    $set_1(this$static.heap, index_0, lastValue);
    $mergeHeaps(this$static, index_0);
  }
}

function PriorityQueue(comparator){
  this.heap = new ArrayList_0(11);
  this.cmp = ($clinit_Comparators() , comparator);
}

defineClass(472, 1779, $intern_12, PriorityQueue);
_.addAll = function addAll_10(c){
  return $addAll_3(this, c);
}
;
_.clear_0 = function clear_42(){
  this.heap.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}
;
_.contains = function contains_39(o){
  return (o == null?-1:$indexOf_3(this.heap, o, 0)) >= 0;
}
;
_.containsAll = function containsAll_9(c){
  return $containsAll(this.heap, c);
}
;
_.iterator_0 = function iterator_55(){
  return new Collections$UnmodifiableCollectionIterator(unmodifiableList(this.heap).coll.iterator_0());
}
;
_.remove_1 = function remove_82(o){
  return $remove_25(this, o);
}
;
_.size_1 = function size_51(){
  return this.heap.array.length;
}
;
_.spliterator_0 = function spliterator_28(){
  return new Spliterators$IteratorSpliterator(this, 256);
}
;
_.toArray = function toArray_22(){
  return $toArray_1(this.heap);
}
;
_.toArray_0 = function toArray_23(a){
  return $toArray_2(this.heap, a);
}
;
var Ljava_util_PriorityQueue_2_classLit = createForClass('java.util', 'PriorityQueue', 472);
function $clinit_Random(){
  $clinit_Random = emptyMethod;
  var i, i0, twoToTheXMinus24Tmp, twoToTheXMinus48Tmp;
  twoToTheXMinus24 = initUnidimensionalArray(D_classLit, $intern_69, 23, 25, 15, 1);
  twoToTheXMinus48 = initUnidimensionalArray(D_classLit, $intern_69, 23, 33, 15, 1);
  twoToTheXMinus48Tmp = 1.52587890625E-5;
  for (i0 = 32; i0 >= 0; i0--) {
    twoToTheXMinus48[i0] = twoToTheXMinus48Tmp;
    twoToTheXMinus48Tmp *= 0.5;
  }
  twoToTheXMinus24Tmp = 1;
  for (i = 24; i >= 0; i--) {
    twoToTheXMinus24[i] = twoToTheXMinus24Tmp;
    twoToTheXMinus24Tmp *= 0.5;
  }
}

function $nextDouble(this$static){
  return $nextInternal(this$static, 26) * $intern_81 + $nextInternal(this$static, 27) * $intern_82;
}

function $nextInt(this$static, n){
  var bits, val;
  checkCriticalArgument(n > 0);
  if ((n & -n) == n) {
    return round_int(n * $nextInternal(this$static, 31) * 4.6566128730773926E-10);
  }
  do {
    bits = $nextInternal(this$static, 31);
    val = bits % n;
  }
   while (bits - val + (n - 1) < 0);
  return round_int(val);
}

function $nextInternal(this$static, bits){
  var carry, dval, h, hi, l, lo;
  hi = this$static.seedhi * $intern_83 + this$static.seedlo * 1502;
  lo = this$static.seedlo * $intern_83 + 11;
  carry = $wnd.Math.floor(lo * $intern_84);
  hi += carry;
  lo -= carry * $intern_85;
  hi %= $intern_85;
  this$static.seedhi = hi;
  this$static.seedlo = lo;
  if (bits <= 24) {
    return $wnd.Math.floor(this$static.seedhi * twoToTheXMinus24[bits]);
  }
   else {
    h = this$static.seedhi * (1 << bits - 24);
    l = $wnd.Math.floor(this$static.seedlo * twoToTheXMinus48[bits]);
    dval = h + l;
    dval >= 2147483648 && (dval -= $intern_73);
    return dval;
  }
}

function $nextLong(this$static){
  return add_20(shl_0(fromDouble_0($nextInternal(this$static, 32)), 32), fromDouble_0($nextInternal(this$static, 32)));
}

function $setSeed(this$static, seedhi, seedlo){
  this$static.seedhi = seedhi ^ 1502;
  this$static.seedlo = seedlo ^ $intern_83;
}

function $setSeed_0(this$static, seed){
  $setSeed(this$static, toInt_0(and_0(shr_0(seed, 24), $intern_86)), toInt_0(and_0(seed, $intern_86)));
}

function Random(){
  $clinit_Random();
  var hi, lo, seed;
  seed = uniqueSeed++ + now_2();
  hi = round_int($wnd.Math.floor(seed * $intern_84)) & $intern_86;
  lo = round_int(seed - hi * $intern_85);
  this.seedhi = hi ^ 1502;
  this.seedlo = lo ^ $intern_83;
}

function Random_0(seed){
  $clinit_Random();
  $setSeed(this, toInt_0(and_0(shr_0(seed, 24), $intern_86)), toInt_0(and_0(seed, $intern_86)));
}

defineClass(221, 1, {221:1}, Random, Random_0);
_.seedhi = 0;
_.seedlo = 0;
var twoToTheXMinus24, twoToTheXMinus48, uniqueSeed = 0;
var Ljava_util_Random_2_classLit = createForClass('java.util', 'Random', 221);
function $initIterator(this$static){
  if (!this$static.it) {
    this$static.it = this$static.collection.iterator_0();
    this$static.estimateSize = this$static.collection.size_1();
  }
}

function $tryAdvance(this$static, consumer){
  checkCriticalNotNull(consumer);
  $initIterator(this$static);
  if (this$static.it.hasNext_0()) {
    consumer.accept(this$static.it.next_1());
    return true;
  }
  return false;
}

function Spliterators$IteratorSpliterator(collection, characteristics){
  this.collection = (checkCriticalNotNull(collection) , collection);
  this.characteristics = (characteristics & $intern_64) == 0?characteristics | 64 | $intern_21:characteristics;
}

function Spliterators$IteratorSpliterator_0(it){
  this.it = (checkCriticalNotNull(it) , it);
  this.characteristics = 0;
  this.estimateSize = $intern_23;
}

function Spliterators$IteratorSpliterator_1(it, size_0, characteristics){
  this.it = (checkCriticalNotNull(it) , it);
  this.characteristics = (characteristics & $intern_64) == 0?characteristics | 64 | $intern_21:characteristics;
  this.estimateSize = size_0;
}

defineClass(38, 1, $intern_22, Spliterators$IteratorSpliterator, Spliterators$IteratorSpliterator_0, Spliterators$IteratorSpliterator_1);
_.characteristics_0 = function characteristics_2(){
  return this.characteristics;
}
;
_.estimateSize_0 = function estimateSize_1(){
  $initIterator(this);
  return this.estimateSize;
}
;
_.forEachRemaining = function forEachRemaining_33(consumer){
  $initIterator(this);
  this.it.forEachRemaining(consumer);
}
;
_.tryAdvance = function tryAdvance_1(consumer){
  return $tryAdvance(this, consumer);
}
;
_.characteristics = 0;
_.estimateSize = 0;
var Ljava_util_Spliterators$IteratorSpliterator_2_classLit = createForClass('java.util', 'Spliterators/IteratorSpliterator', 38);
function SortedSet$1($anonymous0){
  Spliterators$IteratorSpliterator.call(this, $anonymous0, 21);
}

defineClass(396, 38, $intern_22, SortedSet$1);
var Ljava_util_SortedSet$1_2_classLit = createForClass('java.util', 'SortedSet/1', 396);
function $forEachRemaining_2(this$static, consumer){
  while (this$static.tryAdvance_0(consumer))
  ;
}

function Spliterator$OfDouble$0methodref$accept$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(646, 1, $intern_77, Spliterator$OfDouble$0methodref$accept$Type);
_.accept_1 = function accept_13(arg0){
  this.$$outer_0.accept(arg0);
}
;
var Ljava_util_Spliterator$OfDouble$0methodref$accept$Type_2_classLit = createForClass('java.util', 'Spliterator/OfDouble/0methodref$accept$Type', 646);
function Spliterator$OfDouble$1methodref$accept$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(647, 1, $intern_77, Spliterator$OfDouble$1methodref$accept$Type);
_.accept_1 = function accept_14(arg0){
  this.$$outer_0.accept(arg0);
}
;
var Ljava_util_Spliterator$OfDouble$1methodref$accept$Type_2_classLit = createForClass('java.util', 'Spliterator/OfDouble/1methodref$accept$Type', 647);
function Spliterator$OfInt$2methodref$accept$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(648, 1, $intern_80, Spliterator$OfInt$2methodref$accept$Type);
_.accept_2 = function accept_15(arg0){
  this.$$outer_0.accept(valueOf_4(arg0));
}
;
var Ljava_util_Spliterator$OfInt$2methodref$accept$Type_2_classLit = createForClass('java.util', 'Spliterator/OfInt/2methodref$accept$Type', 648);
function Spliterator$OfInt$3methodref$accept$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(649, 1, $intern_80, Spliterator$OfInt$3methodref$accept$Type);
_.accept_2 = function accept_16(arg0){
  this.$$outer_0.accept(valueOf_4(arg0));
}
;
var Ljava_util_Spliterator$OfInt$3methodref$accept$Type_2_classLit = createForClass('java.util', 'Spliterator/OfInt/3methodref$accept$Type', 649);
function checkCriticalArrayBounds(end, length_0){
  if (0 > end || end > length_0) {
    throw toJs(new ArrayIndexOutOfBoundsException_0('fromIndex: 0, toIndex: ' + end + ', length: ' + length_0));
  }
}

function Spliterators$BaseSpliterator(size_0, characteristics){
  this.sizeEstimate = size_0;
  this.characteristics = (characteristics & 64) != 0?characteristics | $intern_21:characteristics;
}

defineClass(580, 1, $intern_22);
_.forEachRemaining = function forEachRemaining_34(consumer){
  $forEachRemaining_1(this, consumer);
}
;
_.characteristics_0 = function characteristics_3(){
  return this.characteristics;
}
;
_.estimateSize_0 = function estimateSize_2(){
  return this.sizeEstimate;
}
;
_.characteristics = 0;
_.sizeEstimate = 0;
var Ljava_util_Spliterators$BaseSpliterator_2_classLit = createForClass('java.util', 'Spliterators/BaseSpliterator', 580);
function Spliterators$AbstractDoubleSpliterator(size_0, characteristics){
  Spliterators$BaseSpliterator.call(this, size_0, characteristics);
}

defineClass(969, 580, $intern_22);
_.forEachRemaining = function forEachRemaining_35(consumer){
  instanceOf(consumer, 189)?$forEachRemaining_2(this, castTo(consumer, 189)):$forEachRemaining_2(this, new Spliterator$OfDouble$1methodref$accept$Type(consumer));
}
;
_.tryAdvance = function tryAdvance_2(consumer){
  return instanceOf(consumer, 189)?$tryAdvance_1(this, castTo(consumer, 189)):$tryAdvance_1(this, new Spliterator$OfDouble$0methodref$accept$Type(consumer));
}
;
var Ljava_util_Spliterators$AbstractDoubleSpliterator_2_classLit = createForClass('java.util', 'Spliterators/AbstractDoubleSpliterator', 969);
function Spliterators$AbstractIntSpliterator(size_0, characteristics){
  Spliterators$BaseSpliterator.call(this, size_0, characteristics);
}

defineClass(967, 580, $intern_22);
_.forEachRemaining = function forEachRemaining_36(consumer){
  instanceOf(consumer, 262)?$forEachRemaining_2(this, castTo(consumer, 262)):$forEachRemaining_2(this, new Spliterator$OfInt$3methodref$accept$Type(consumer));
}
;
_.tryAdvance = function tryAdvance_3(consumer){
  return instanceOf(consumer, 262)?$tryAdvance_2(this, castTo(consumer, 262)):$tryAdvance_2(this, new Spliterator$OfInt$2methodref$accept$Type(consumer));
}
;
var Ljava_util_Spliterators$AbstractIntSpliterator_2_classLit = createForClass('java.util', 'Spliterators/AbstractIntSpliterator', 967);
function Spliterators$AbstractSpliterator(size_0, characteristics){
  Spliterators$BaseSpliterator.call(this, size_0, characteristics);
}

defineClass(505, 580, $intern_22);
var Ljava_util_Spliterators$AbstractSpliterator_2_classLit = createForClass('java.util', 'Spliterators/AbstractSpliterator', 505);
function $forEachRemaining_3(this$static, consumer){
  checkCriticalNotNull(consumer);
  while (this$static.index_0 < this$static.limit) {
    $consume(this$static, consumer, this$static.index_0++);
  }
}

function $tryAdvance_0(this$static, consumer){
  checkCriticalNotNull(consumer);
  if (this$static.index_0 < this$static.limit) {
    $consume(this$static, consumer, this$static.index_0++);
    return true;
  }
  return false;
}

defineClass(822, 1, $intern_22);
_.forEachRemaining = function forEachRemaining_37(consumer){
  $forEachRemaining_1(this, consumer);
}
;
_.characteristics_0 = function characteristics_4(){
  return this.characteristics;
}
;
_.estimateSize_0 = function estimateSize_3(){
  return this.limit - this.index_0;
}
;
_.characteristics = 0;
_.index_0 = 0;
_.limit = 0;
var Ljava_util_Spliterators$BaseArraySpliterator_2_classLit = createForClass('java.util', 'Spliterators/BaseArraySpliterator', 822);
function $consume(this$static, consumer, index_0){
  consumer.accept(this$static.array[index_0]);
}

function Spliterators$ArraySpliterator(array, limit){
  this.index_0 = 0;
  this.limit = limit;
  this.characteristics = 17488;
  this.array = array;
}

defineClass(823, 822, $intern_22, Spliterators$ArraySpliterator);
_.forEachRemaining = function forEachRemaining_38(consumer){
  $forEachRemaining_3(this, consumer);
}
;
_.tryAdvance = function tryAdvance_4(consumer){
  return $tryAdvance_0(this, consumer);
}
;
var Ljava_util_Spliterators$ArraySpliterator_2_classLit = createForClass('java.util', 'Spliterators/ArraySpliterator', 823);
function $nextDouble_0(this$static){
  checkCriticalElement((this$static.hasElement || (this$static.hasElement = $tryAdvance_1(this$static.spliterator, this$static)) , this$static.hasElement));
  this$static.hasElement = false;
  return this$static.nextElement;
}

function Spliterators$DoubleConsumerIterator(spliterator){
  this.spliterator = (checkCriticalNotNull(spliterator) , spliterator);
}

defineClass(821, 1, {47:1, 189:1}, Spliterators$DoubleConsumerIterator);
_.forEachRemaining = function forEachRemaining_39(consumer){
  instanceOf(consumer, 189)?$forEachRemaining_0(this, castTo(consumer, 189)):$forEachRemaining_0(this, new PrimitiveIterator$OfDouble$0methodref$accept$Type(consumer));
}
;
_.next_1 = function next_36(){
  return $nextDouble_0(this);
}
;
_.remove_0 = function remove_83(){
  $remove_21();
}
;
_.accept_1 = function accept_17(d){
  this.nextElement = d;
}
;
_.hasNext_0 = function hasNext_35(){
  return this.hasElement || (this.hasElement = $tryAdvance_1(this.spliterator, this)) , this.hasElement;
}
;
_.hasElement = false;
_.nextElement = 0;
var Ljava_util_Spliterators$DoubleConsumerIterator_2_classLit = createForClass('java.util', 'Spliterators/DoubleConsumerIterator', 821);
function $addElement(this$static, o){
  $add_4(this$static.arrayList, o);
}

function $elementAt(this$static, index_0){
  return checkArrayElementIndex(index_0, this$static.arrayList.array.length) , $get_7(this$static.arrayList, index_0);
}

function $setElementAt(this$static, o, index_0){
  checkArrayElementIndex(index_0, this$static.arrayList.array.length);
  $set_1(this$static.arrayList, index_0, o);
}

function Vector(){
  this.arrayList = new ArrayList;
}

function checkArrayElementIndex(index_0, size_0){
  if (index_0 < 0 || index_0 >= size_0) {
    throw toJs(new ArrayIndexOutOfBoundsException);
  }
}

defineClass(548, 43, $intern_87, Vector);
_.add_3 = function add_38(index_0, o){
  checkArrayElementIndex(index_0, this.arrayList.array.length + 1);
  $add_3(this.arrayList, index_0, o);
}
;
_.add_1 = function add_39(o){
  return $add_4(this.arrayList, o);
}
;
_.addAll = function addAll_11(c){
  return $addAll_2(this.arrayList, c);
}
;
_.clear_0 = function clear_43(){
  this.arrayList.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}
;
_.contains = function contains_40(elem){
  return $indexOf_3(this.arrayList, elem, 0) != -1;
}
;
_.containsAll = function containsAll_10(c){
  return $containsAll(this.arrayList, c);
}
;
_.forEach_0 = function forEach_17(consumer){
  $forEach_0(this.arrayList, consumer);
}
;
_.get_3 = function get_31(index_0){
  return checkArrayElementIndex(index_0, this.arrayList.array.length) , $get_7(this.arrayList, index_0);
}
;
_.indexOf_0 = function indexOf_6(elem){
  return $indexOf_3(this.arrayList, elem, 0);
}
;
_.isEmpty = function isEmpty_20(){
  return this.arrayList.array.length == 0;
}
;
_.iterator_0 = function iterator_56(){
  return new ArrayList$1(this.arrayList);
}
;
_.remove_2 = function remove_84(index_0){
  return checkArrayElementIndex(index_0, this.arrayList.array.length) , $remove_12(this.arrayList, index_0);
}
;
_.removeRange = function removeRange_2(fromIndex, endIndex){
  $removeRange(this.arrayList, fromIndex, endIndex);
}
;
_.set_2 = function set_20(index_0, elem){
  return checkArrayElementIndex(index_0, this.arrayList.array.length) , $set_1(this.arrayList, index_0, elem);
}
;
_.size_1 = function size_52(){
  return this.arrayList.array.length;
}
;
_.sort_0 = function sort_8(c){
  $sort(this.arrayList, c);
}
;
_.subList = function subList_8(fromIndex, toIndex){
  return new AbstractList$SubList(this.arrayList, fromIndex, toIndex);
}
;
_.toArray = function toArray_24(){
  return $toArray_1(this.arrayList);
}
;
_.toArray_0 = function toArray_25(a){
  return $toArray_2(this.arrayList, a);
}
;
_.toString_0 = function toString_71(){
  return $toString_1(this.arrayList);
}
;
var Ljava_util_Vector_2_classLit = createForClass('java.util', 'Vector', 548);
function $pop(this$static){
  var sz;
  sz = this$static.arrayList.array.length;
  if (sz > 0) {
    return checkArrayElementIndex(sz - 1, this$static.arrayList.array.length) , $remove_12(this$static.arrayList, sz - 1);
  }
   else {
    throw toJs(new EmptyStackException);
  }
}

function $push(this$static, o){
  $add_4(this$static.arrayList, o);
  return o;
}

function Stack(){
  Vector.call(this);
}

defineClass(749, 548, $intern_87, Stack);
var Ljava_util_Stack_2_classLit = createForClass('java.util', 'Stack', 749);
function $add_9(this$static, newElement){
  !this$static.builder?(this$static.builder = new StringBuilder_1(this$static.prefix)):$append_11(this$static.builder, this$static.delimiter);
  $append_8(this$static.builder, newElement);
  return this$static;
}

function StringJoiner(prefix, suffix){
  this.delimiter = ', ';
  this.prefix = prefix;
  this.suffix = suffix;
  this.emptyValue = this.prefix + ('' + this.suffix);
}

defineClass(263, 1, {}, StringJoiner);
_.toString_0 = function toString_72(){
  return !this.builder?this.emptyValue:this.suffix.length == 0?this.builder.string:this.builder.string + ('' + this.suffix);
}
;
var Ljava_util_StringJoiner_2_classLit = createForClass('java.util', 'StringJoiner', 263);
function $clear_6(this$static){
  this$static.root = null;
  this$static.size_0 = 0;
}

function $getEntry_0(this$static, key){
  var c, childNum, tree;
  tree = this$static.root;
  while (tree) {
    c = this$static.cmp.compare_0(key, tree.key);
    if (c == 0) {
      return tree;
    }
    childNum = c < 0?0:1;
    tree = tree.child[childNum];
  }
  return null;
}

function $getFirstEntry(this$static){
  var nextNode, node;
  if (!this$static.root) {
    return null;
  }
  node = this$static.root;
  while (nextNode = node.child[0]) {
    node = nextNode;
  }
  return node;
}

function $getNodeAfter(this$static, key, inclusive){
  var c, foundNode, node;
  foundNode = null;
  node = this$static.root;
  while (node) {
    c = this$static.cmp.compare_0(key, node.key);
    if (inclusive && c == 0) {
      return node;
    }
    if (c >= 0) {
      node = node.child[1];
    }
     else {
      foundNode = node;
      node = node.child[0];
    }
  }
  return foundNode;
}

function $getNodeBefore(this$static, key, inclusive){
  var c, foundNode, node;
  foundNode = null;
  node = this$static.root;
  while (node) {
    c = this$static.cmp.compare_0(key, node.key);
    if (inclusive && c == 0) {
      return node;
    }
    if (c <= 0) {
      node = node.child[0];
    }
     else {
      foundNode = node;
      node = node.child[1];
    }
  }
  return foundNode;
}

function $inOrderAdd(this$static, list, type_0, current, fromKey, fromInclusive, toKey, toInclusive){
  var leftNode, rightNode;
  if (!current) {
    return;
  }
  leftNode = current.child[0];
  !!leftNode && $inOrderAdd(this$static, list, type_0, leftNode, fromKey, fromInclusive, toKey, toInclusive);
  $inRange(this$static, type_0, current.key, fromKey, fromInclusive, toKey, toInclusive) && list.add_1(current);
  rightNode = current.child[1];
  !!rightNode && $inOrderAdd(this$static, list, type_0, rightNode, fromKey, fromInclusive, toKey, toInclusive);
}

function $inRange(this$static, type_0, key, fromKey, fromInclusive, toKey, toInclusive){
  var compare, compare0;
  if (type_0.fromKeyValid() && (compare0 = this$static.cmp.compare_0(key, fromKey) , compare0 < 0 || !fromInclusive && compare0 == 0)) {
    return false;
  }
  if (type_0.toKeyValid() && (compare = this$static.cmp.compare_0(key, toKey) , compare > 0 || !toInclusive && compare == 0)) {
    return false;
  }
  return true;
}

function $insert_0(this$static, tree, newNode, state){
  var c, childNum;
  if (!tree) {
    return newNode;
  }
   else {
    c = this$static.cmp.compare_0(newNode.key, tree.key);
    if (c == 0) {
      state.value_0 = $setValue(tree, newNode.value_0);
      state.found = true;
      return tree;
    }
    childNum = c < 0?0:1;
    tree.child[childNum] = $insert_0(this$static, tree.child[childNum], newNode, state);
    if ($isRed(tree.child[childNum])) {
      if ($isRed(tree.child[1 - childNum])) {
        tree.isRed = true;
        tree.child[0].isRed = false;
        tree.child[1].isRed = false;
      }
       else {
        $isRed(tree.child[childNum].child[childNum])?(tree = $rotateSingle(tree, 1 - childNum)):$isRed(tree.child[childNum].child[1 - childNum]) && (tree = $rotateDouble(tree, 1 - childNum));
      }
    }
  }
  return tree;
}

function $isRed(node){
  return !!node && node.isRed;
}

function $put_7(this$static, key, value_0){
  var node, state;
  node = new TreeMap$Node(key, value_0);
  state = new TreeMap$State;
  this$static.root = $insert_0(this$static, this$static.root, node, state);
  state.found || ++this$static.size_0;
  this$static.root.isRed = false;
  return state.value_0;
}

function $remove_26(this$static, k){
  var state;
  state = new TreeMap$State;
  $removeWithState(this$static, k, state);
  return state.value_0;
}

function $removeEntry(this$static, entry){
  var state;
  state = new TreeMap$State;
  state.matchValue = true;
  state.value_0 = entry.getValue();
  return $removeWithState(this$static, entry.getKey(), state);
}

function $removeWithState(this$static, key, state){
  var c, dir_0, dir2, found, grandparent, head, last, newNode, node, parent_0, sibling;
  if (!this$static.root) {
    return false;
  }
  found = null;
  parent_0 = null;
  head = new TreeMap$Node(null, null);
  dir_0 = 1;
  head.child[1] = this$static.root;
  node = head;
  while (node.child[dir_0]) {
    last = dir_0;
    grandparent = parent_0;
    parent_0 = node;
    node = node.child[dir_0];
    c = this$static.cmp.compare_0(key, node.key);
    dir_0 = c < 0?0:1;
    c == 0 && (!state.matchValue || equals_56(node.value_0, state.value_0)) && (found = node);
    if (!(!!node && node.isRed) && !$isRed(node.child[dir_0])) {
      if ($isRed(node.child[1 - dir_0])) {
        parent_0 = parent_0.child[last] = $rotateSingle(node, dir_0);
      }
       else if (!$isRed(node.child[1 - dir_0])) {
        sibling = parent_0.child[1 - last];
        if (sibling) {
          if (!$isRed(sibling.child[1 - last]) && !$isRed(sibling.child[last])) {
            parent_0.isRed = false;
            sibling.isRed = true;
            node.isRed = true;
          }
           else {
            dir2 = grandparent.child[1] == parent_0?1:0;
            $isRed(sibling.child[last])?(grandparent.child[dir2] = $rotateDouble(parent_0, last)):$isRed(sibling.child[1 - last]) && (grandparent.child[dir2] = $rotateSingle(parent_0, last));
            node.isRed = grandparent.child[dir2].isRed = true;
            grandparent.child[dir2].child[0].isRed = false;
            grandparent.child[dir2].child[1].isRed = false;
          }
        }
      }
    }
  }
  if (found) {
    state.found = true;
    state.value_0 = found.value_0;
    if (node != found) {
      newNode = new TreeMap$Node(node.key, node.value_0);
      $replaceNode(this$static, head, found, newNode);
      parent_0 == found && (parent_0 = newNode);
    }
    parent_0.child[parent_0.child[1] == node?1:0] = node.child[!node.child[0]?1:0];
    --this$static.size_0;
  }
  this$static.root = head.child[1];
  !!this$static.root && (this$static.root.isRed = false);
  return state.found;
}

function $replaceNode(this$static, head, node, newNode){
  var direction, parent_0;
  parent_0 = head;
  direction = parent_0.key == null || this$static.cmp.compare_0(node.key, parent_0.key) > 0?1:0;
  while (parent_0.child[direction] != node) {
    parent_0 = parent_0.child[direction];
    direction = this$static.cmp.compare_0(node.key, parent_0.key) > 0?1:0;
  }
  parent_0.child[direction] = newNode;
  newNode.isRed = node.isRed;
  newNode.child[0] = node.child[0];
  newNode.child[1] = node.child[1];
  node.child[0] = null;
  node.child[1] = null;
}

function $rotateDouble(tree, rotateDirection){
  var otherChildDir;
  otherChildDir = 1 - rotateDirection;
  tree.child[otherChildDir] = $rotateSingle(tree.child[otherChildDir], otherChildDir);
  return $rotateSingle(tree, rotateDirection);
}

function $rotateSingle(tree, rotateDirection){
  var otherChildDir, save;
  otherChildDir = 1 - rotateDirection;
  save = tree.child[otherChildDir];
  tree.child[otherChildDir] = save.child[rotateDirection];
  save.child[rotateDirection] = tree;
  tree.isRed = true;
  save.isRed = false;
  return save;
}

function TreeMap(){
  TreeMap_0.call(this, null);
}

function TreeMap_0(c){
  this.root = null;
  this.cmp = ($clinit_Comparators() , !c?INTERNAL_NATURAL_ORDER:c);
}

defineClass(508, 1769, {3:1, 111:1, 124:1, 118:1}, TreeMap, TreeMap_0);
_.clear_0 = function clear_44(){
  $clear_6(this);
}
;
_.entrySet_0 = function entrySet_7(){
  return new TreeMap$EntrySet(this);
}
;
_.put = function put_6(key, value_0){
  return $put_7(this, key, value_0);
}
;
_.remove = function remove_85(k){
  return $remove_26(this, k);
}
;
_.size_1 = function size_53(){
  return this.size_0;
}
;
_.size_0 = 0;
var Ljava_util_TreeMap_2_classLit = createForClass('java.util', 'TreeMap', 508);
function $next_14(this$static){
  return this$static.last = castTo($next_8(this$static.iter), 39);
}

function $remove_27(this$static){
  $remove_9(this$static.iter);
  $removeEntry(this$static.this$01, this$static.last);
  this$static.last = null;
}

function TreeMap$EntryIterator(this$0){
  TreeMap$EntryIterator_0.call(this, this$0, ($clinit_TreeMap$SubMapType() , All));
}

function TreeMap$EntryIterator_0(this$0, type_0){
  var list;
  this.this$01 = this$0;
  list = new ArrayList;
  $inOrderAdd(this$0, list, type_0, this$0.root, null, false, null, false);
  this.iter = new AbstractList$ListIteratorImpl(list, 0);
}

defineClass(371, 1, $intern_4, TreeMap$EntryIterator);
_.forEachRemaining = function forEachRemaining_40(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_37(){
  return $next_14(this);
}
;
_.hasNext_0 = function hasNext_36(){
  return $hasNext_1(this.iter);
}
;
_.remove_0 = function remove_86(){
  $remove_27(this);
}
;
var Ljava_util_TreeMap$EntryIterator_2_classLit = createForClass('java.util', 'TreeMap/EntryIterator', 371);
function TreeMap$EntrySet(this$0){
  this.this$01 = this$0;
  AbstractNavigableMap$EntrySet.call(this, this$0);
}

defineClass(415, 687, $intern_14, TreeMap$EntrySet);
_.clear_0 = function clear_45(){
  $clear_6(this.this$01);
}
;
var Ljava_util_TreeMap$EntrySet_2_classLit = createForClass('java.util', 'TreeMap/EntrySet', 415);
function TreeMap$Node(key, value_0){
  AbstractMap$SimpleEntry.call(this, key, value_0);
  this.child = initUnidimensionalArray(Ljava_util_TreeMap$Node_2_classLit, $intern_1, 416, 2, 0, 1);
  this.isRed = true;
}

defineClass(416, 363, {456:1, 363:1, 39:1, 416:1}, TreeMap$Node);
_.isRed = false;
var Ljava_util_TreeMap$Node_2_classLit = createForClass('java.util', 'TreeMap/Node', 416);
function TreeMap$State(){
}

defineClass(588, 1, {}, TreeMap$State);
_.toString_0 = function toString_73(){
  return 'State: mv=' + this.matchValue + ' value=' + this.value_0 + ' done=' + this.done_0 + ' found=' + this.found;
}
;
_.done_0 = false;
_.found = false;
_.matchValue = false;
var Ljava_util_TreeMap$State_2_classLit = createForClass('java.util', 'TreeMap/State', 588);
function $clinit_TreeMap$SubMapType(){
  $clinit_TreeMap$SubMapType = emptyMethod;
  All = new TreeMap$SubMapType('All', 0);
  Head = new TreeMap$SubMapType$1;
  Range_1 = new TreeMap$SubMapType$2;
  Tail = new TreeMap$SubMapType$3;
}

function TreeMap$SubMapType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_12(name_0){
  $clinit_TreeMap$SubMapType();
  return valueOf(($clinit_TreeMap$SubMapType$Map() , $MAP_0), name_0);
}

function values_8(){
  $clinit_TreeMap$SubMapType();
  return stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_TreeMap$SubMapType_2_classLit, 1), $intern_38, 287, 0, [All, Head, Range_1, Tail]);
}

defineClass(287, 22, $intern_88, TreeMap$SubMapType);
_.fromKeyValid = function fromKeyValid(){
  return false;
}
;
_.toKeyValid = function toKeyValid(){
  return false;
}
;
var All, Head, Range_1, Tail;
var Ljava_util_TreeMap$SubMapType_2_classLit = createForEnum('java.util', 'TreeMap/SubMapType', 287, Ljava_lang_Enum_2_classLit, values_8, valueOf_12);
function TreeMap$SubMapType$1(){
  TreeMap$SubMapType.call(this, 'Head', 1);
}

defineClass(1023, 287, $intern_88, TreeMap$SubMapType$1);
_.toKeyValid = function toKeyValid_0(){
  return true;
}
;
var Ljava_util_TreeMap$SubMapType$1_2_classLit = createForEnum('java.util', 'TreeMap/SubMapType/1', 1023, Ljava_util_TreeMap$SubMapType_2_classLit, null, null);
function TreeMap$SubMapType$2(){
  TreeMap$SubMapType.call(this, 'Range', 2);
}

defineClass($intern_89, 287, $intern_88, TreeMap$SubMapType$2);
_.fromKeyValid = function fromKeyValid_0(){
  return true;
}
;
_.toKeyValid = function toKeyValid_1(){
  return true;
}
;
var Ljava_util_TreeMap$SubMapType$2_2_classLit = createForEnum('java.util', 'TreeMap/SubMapType/2', $intern_89, Ljava_util_TreeMap$SubMapType_2_classLit, null, null);
function TreeMap$SubMapType$3(){
  TreeMap$SubMapType.call(this, 'Tail', 3);
}

defineClass(1025, 287, $intern_88, TreeMap$SubMapType$3);
_.fromKeyValid = function fromKeyValid_1(){
  return true;
}
;
var Ljava_util_TreeMap$SubMapType$3_2_classLit = createForEnum('java.util', 'TreeMap/SubMapType/3', 1025, Ljava_util_TreeMap$SubMapType_2_classLit, null, null);
function $clinit_TreeMap$SubMapType$Map(){
  $clinit_TreeMap$SubMapType$Map = emptyMethod;
  $MAP_0 = createValueOfMap(($clinit_TreeMap$SubMapType() , stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_TreeMap$SubMapType_2_classLit, 1), $intern_38, 287, 0, [All, Head, Range_1, Tail])));
}

var $MAP_0;
function $add_10(this$static, o){
  return $put_7(this$static.map_0, o, ($clinit_Boolean() , FALSE_0)) == null;
}

function $ceiling(this$static, e){
  return getEntryKeyOrNull($getNodeAfter(this$static.map_0, e, true));
}

function $floor(this$static, e){
  return getEntryKeyOrNull($getNodeBefore(this$static.map_0, e, true));
}

function $higher(this$static, e){
  return getEntryKeyOrNull($getNodeAfter(this$static.map_0, e, false));
}

function $lower(this$static, e){
  return getEntryKeyOrNull($getNodeBefore(this$static.map_0, e, false));
}

function $remove_28(this$static, o){
  return $remove_26(this$static.map_0, o) != null;
}

function TreeSet(){
  this.map_0 = new TreeMap;
}

function TreeSet_0(c){
  this.map_0 = new TreeMap_0(c);
}

defineClass(203, $intern_13, {3:1, 20:1, 28:1, 13:1, 200:1, 19:1, 62:1, 203:1}, TreeSet, TreeSet_0);
_.spliterator_0 = function spliterator_29(){
  return new SortedSet$1(this);
}
;
_.add_1 = function add_40(o){
  return $add_10(this, o);
}
;
_.clear_0 = function clear_46(){
  $clear_6(this.map_0);
}
;
_.contains = function contains_41(o){
  return $containsKey_3(this.map_0, o);
}
;
_.iterator_0 = function iterator_57(){
  var entryIterator;
  return entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet((new AbstractNavigableMap$NavigableKeySet(this.map_0)).map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator);
}
;
_.remove_1 = function remove_87(o){
  return $remove_28(this, o);
}
;
_.size_1 = function size_54(){
  return this.map_0.size_0;
}
;
var Ljava_util_TreeSet_2_classLit = createForClass('java.util', 'TreeSet', 203);
function BinaryOperator$lambda$0$Type(){
}

defineClass(878, 1, {}, BinaryOperator$lambda$0$Type);
_.apply_2 = function apply_17(arg0, arg1){
  return compare_6(castTo(arg0, 21).value_0, castTo(arg1, 21).value_0) <= 0?arg1:arg0;
}
;
var Ljava_util_function_BinaryOperator$lambda$0$Type_2_classLit = createForClass('java.util.function', 'BinaryOperator/lambda$0$Type', 878);
function BinaryOperator$lambda$1$Type(){
}

defineClass(879, 1, {}, BinaryOperator$lambda$1$Type);
_.apply_2 = function apply_18(arg0, arg1){
  return compare_6(castTo(arg0, 21).value_0, castTo(arg1, 21).value_0) <= 0?arg0:arg1;
}
;
var Ljava_util_function_BinaryOperator$lambda$1$Type_2_classLit = createForClass('java.util.function', 'BinaryOperator/lambda$1$Type', 879);
function Function$lambda$0$Type(){
}

defineClass(876, 1, $intern_11, Function$lambda$0$Type);
_.apply_0 = function apply_19(t){
  return t;
}
;
var Ljava_util_function_Function$lambda$0$Type_2_classLit = createForClass('java.util.function', 'Function/lambda$0$Type', 876);
function Predicate$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(566, 1, $intern_90, Predicate$lambda$0$Type);
_.test_0 = function test_3(t){
  return !this.$$outer_0.test_0(t);
}
;
var Ljava_util_function_Predicate$lambda$0$Type_2_classLit = createForClass('java.util.function', 'Predicate/lambda$0$Type', 566);
function of_2(supplier, accumulator, combiner, finisher, characteristics){
  checkCriticalNotNull(supplier);
  checkCriticalNotNull(accumulator);
  checkCriticalNotNull(combiner);
  checkCriticalNotNull(finisher);
  checkCriticalNotNull(characteristics);
  return new Collector$CollectorImpl_0(supplier, accumulator, finisher, characteristics);
}

function of_3(supplier, accumulator, combiner, characteristics){
  var lastArg;
  checkCriticalNotNull(supplier);
  checkCriticalNotNull(accumulator);
  checkCriticalNotNull(combiner);
  checkCriticalNotNull(characteristics);
  return new Collector$CollectorImpl(supplier, accumulator, (lastArg = new Function$lambda$0$Type , $clinit_Collections() , new Collections$UnmodifiableSet(of_1(($clinit_Collector$Characteristics() , IDENTITY_FINISH), characteristics)) , lastArg));
}

function $clinit_Collector$Characteristics(){
  $clinit_Collector$Characteristics = emptyMethod;
  CONCURRENT = new Collector$Characteristics('CONCURRENT', 0);
  IDENTITY_FINISH = new Collector$Characteristics('IDENTITY_FINISH', 1);
  UNORDERED = new Collector$Characteristics('UNORDERED', 2);
}

function Collector$Characteristics(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_13(name_0){
  $clinit_Collector$Characteristics();
  return valueOf(($clinit_Collector$Characteristics$Map() , $MAP_1), name_0);
}

function values_9(){
  $clinit_Collector$Characteristics();
  return stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [CONCURRENT, IDENTITY_FINISH, UNORDERED]);
}

defineClass(154, 22, {3:1, 34:1, 22:1, 154:1}, Collector$Characteristics);
var CONCURRENT, IDENTITY_FINISH, UNORDERED;
var Ljava_util_stream_Collector$Characteristics_2_classLit = createForEnum('java.util.stream', 'Collector/Characteristics', 154, Ljava_lang_Enum_2_classLit, values_9, valueOf_13);
function $clinit_Collector$Characteristics$Map(){
  $clinit_Collector$Characteristics$Map = emptyMethod;
  $MAP_1 = createValueOfMap(($clinit_Collector$Characteristics() , stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [CONCURRENT, IDENTITY_FINISH, UNORDERED])));
}

var $MAP_1;
function Collector$CollectorImpl(supplier, accumulator, finisher){
  this.supplier = supplier;
  this.accumulator = accumulator;
  this.finisher = finisher;
}

function Collector$CollectorImpl_0(supplier, accumulator, finisher, characteristics){
  var set_0;
  this.supplier = supplier;
  this.accumulator = accumulator;
  characteristics.length == 0?($clinit_Collections() , $clinit_Collections() , EMPTY_SET):characteristics.length == 1?($clinit_Collections() , set_0 = new HashSet_0(1) , set_0.map_0.put(characteristics[0], set_0) , new Collections$UnmodifiableSet(set_0)):($clinit_Collections() , new Collections$UnmodifiableSet(of_1(characteristics[0], characteristics)));
  this.finisher = finisher;
}

defineClass(703, 1, {}, Collector$CollectorImpl, Collector$CollectorImpl_0);
var Ljava_util_stream_Collector$CollectorImpl_2_classLit = createForClass('java.util.stream', 'Collector/CollectorImpl', 703);
function addAll_12(collection, items){
  collection.addAll(items);
  return collection;
}

function groupingBy0(supplier, classifier, downstream){
  return of_2(supplier, new Collectors$lambda$3$Type(classifier), new Collectors$lambda$4$Type, new Collectors$lambda$5$Type(downstream), stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, []));
}

function lambda$11(op_0, u_2){
  return setCheck(u_2, 0, $apply_2(u_2[0], valueOf_5(1)));
}

function lambda$12(op_0, u1_1, u2_2){
  setCheck(u1_1, 0, $apply_2(u1_1[0], u2_2[0]));
  return u1_1;
}

function lambda$3(classifier_0, m_1, o_2){
  var k, l;
  k = ($clinit_Boolean() , $test(o_2)?true:false);
  l = castTo(m_1.get_0(k), 15);
  if (!l) {
    l = new ArrayList;
    m_1.put(k, l);
  }
  l.add_1(o_2);
}

function lambda$5(downstream_1, m_2){
  var entry, entry$iterator, result;
  result = new HashMap;
  for (entry$iterator = m_2.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    $put_1(result, entry.getKey(), streamAndCollect(downstream_1, castTo(entry.getValue(), 15)));
  }
  return result;
}

function mergeAll(m1, m2, mergeFunction){
  var entry, entry$iterator;
  for (entry$iterator = m2.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    m1.merge(entry.getKey(), entry.getValue(), mergeFunction);
  }
  return m1;
}

function partitioningBy(predicate, downstream){
  return groupingBy0(new Collectors$lambda$8$Type, new Collectors$12methodref$test$Type(predicate), downstream);
}

function reducing(identity, op){
  return of_2(new Collectors$lambda$10$Type(identity), new Collectors$lambda$11$Type(op), new Collectors$lambda$12$Type(op), new Collectors$lambda$13$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, []));
}

function streamAndCollect(downstream, list){
  var a, t, t$iterator;
  a = downstream.supplier.get_5();
  for (t$iterator = list.iterator_0(); t$iterator.hasNext_0();) {
    t = t$iterator.next_1();
    downstream.accumulator.accept_0(a, t);
  }
  return downstream.finisher.apply_0(a);
}

function Collectors$12methodref$test$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1140, 1, $intern_11, Collectors$12methodref$test$Type);
_.apply_0 = function apply_20(arg0){
  return $clinit_Boolean() , $test(arg0)?true:false;
}
;
var Ljava_util_stream_Collectors$12methodref$test$Type_2_classLit = createForClass('java.util.stream', 'Collectors/12methodref$test$Type', 1140);
function Collectors$20methodref$add$Type(){
}

defineClass(376, 1, {}, Collectors$20methodref$add$Type);
_.accept_0 = function accept_18(arg0, arg1){
  castTo(arg0, 13).add_1(arg1);
}
;
var Ljava_util_stream_Collectors$20methodref$add$Type_2_classLit = createForClass('java.util.stream', 'Collectors/20methodref$add$Type', 376);
function Collectors$21methodref$ctor$Type(){
}

defineClass(378, 1, {}, Collectors$21methodref$ctor$Type);
_.get_5 = function get_32(){
  return new ArrayList;
}
;
var Ljava_util_stream_Collectors$21methodref$ctor$Type_2_classLit = createForClass('java.util.stream', 'Collectors/21methodref$ctor$Type', 378);
function Collectors$23methodref$ctor$Type(){
}

defineClass(339, 1, {}, Collectors$23methodref$ctor$Type);
_.get_5 = function get_33(){
  return new HashSet;
}
;
var Ljava_util_stream_Collectors$23methodref$ctor$Type_2_classLit = createForClass('java.util.stream', 'Collectors/23methodref$ctor$Type', 339);
function Collectors$24methodref$add$Type(){
}

defineClass(340, 1, {}, Collectors$24methodref$add$Type);
_.accept_0 = function accept_19(arg0, arg1){
  $add_6(castTo(arg0, 65), arg1);
}
;
var Ljava_util_stream_Collectors$24methodref$add$Type_2_classLit = createForClass('java.util.stream', 'Collectors/24methodref$add$Type', 340);
function Collectors$4methodref$addAll$Type(){
}

defineClass(1137, 1, {}, Collectors$4methodref$addAll$Type);
_.apply_2 = function apply_21(arg0, arg1){
  return addAll_12(castTo(arg0, 15), castTo(arg1, 13));
}
;
var Ljava_util_stream_Collectors$4methodref$addAll$Type_2_classLit = createForClass('java.util.stream', 'Collectors/4methodref$addAll$Type', 1137);
function $apply_2(arg0, arg1){
  return valueOf_5(add_20(valueOf_5(castTo(arg0, 152).value_0).value_0, castTo(arg1, 152).value_0));
}

function Collectors$lambda$1$Type(){
}

defineClass(702, 1, {}, Collectors$lambda$1$Type);
_.apply_2 = function apply_22(arg0, arg1){
  return $apply_2(arg0, arg1);
}
;
var Ljava_util_stream_Collectors$lambda$1$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$1$Type', 702);
function Collectors$lambda$10$Type(identity_0){
  this.identity_0 = identity_0;
}

defineClass(1142, 1, {}, Collectors$lambda$10$Type);
_.get_5 = function get_34(){
  return stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [this.identity_0]);
}
;
var Ljava_util_stream_Collectors$lambda$10$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$10$Type', 1142);
function Collectors$lambda$11$Type(op_0){
  this.op_0 = op_0;
}

defineClass(1143, 1, {}, Collectors$lambda$11$Type);
_.accept_0 = function accept_20(arg0, arg1){
  lambda$11(this.op_0, arg0);
}
;
var Ljava_util_stream_Collectors$lambda$11$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$11$Type', 1143);
function Collectors$lambda$12$Type(op_0){
  this.op_0 = op_0;
}

defineClass(1144, 1, {}, Collectors$lambda$12$Type);
_.apply_2 = function apply_23(arg0, arg1){
  return lambda$12(this.op_0, arg0, arg1);
}
;
var Ljava_util_stream_Collectors$lambda$12$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$12$Type', 1144);
function Collectors$lambda$13$Type(){
}

defineClass(1145, 1, $intern_11, Collectors$lambda$13$Type);
_.apply_0 = function apply_24(arg0){
  return castToArray(arg0)[0];
}
;
var Ljava_util_stream_Collectors$lambda$13$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$13$Type', 1145);
function Collectors$lambda$21$Type(){
}

defineClass(377, 1, {}, Collectors$lambda$21$Type);
_.apply_2 = function apply_25(arg0, arg1){
  return castTo(arg0, 13).addAll(castTo(arg1, 13)) , castTo(arg0, 13);
}
;
var Ljava_util_stream_Collectors$lambda$21$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$21$Type', 377);
function Collectors$lambda$25$Type(){
}

defineClass(341, 1, {}, Collectors$lambda$25$Type);
_.apply_2 = function apply_26(arg0, arg1){
  return $addAll(castTo(arg0, 65), castTo(arg1, 65)) , castTo(arg0, 65);
}
;
var Ljava_util_stream_Collectors$lambda$25$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$25$Type', 341);
function Collectors$lambda$26$Type(){
}

defineClass(342, 1, $intern_11, Collectors$lambda$26$Type);
_.apply_0 = function apply_27(arg0){
  return castTo(arg0, 65);
}
;
var Ljava_util_stream_Collectors$lambda$26$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$26$Type', 342);
function Collectors$lambda$3$Type(classifier_0){
  this.classifier_0 = classifier_0;
}

defineClass(1136, 1, {}, Collectors$lambda$3$Type);
_.accept_0 = function accept_21(arg0, arg1){
  lambda$3(this.classifier_0, arg0, arg1);
}
;
var Ljava_util_stream_Collectors$lambda$3$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$3$Type', 1136);
function Collectors$lambda$4$Type(){
}

defineClass(1138, 1, {}, Collectors$lambda$4$Type);
_.apply_2 = function apply_28(arg0, arg1){
  return mergeAll(castTo(arg0, 111), castTo(arg1, 111), new Collectors$4methodref$addAll$Type);
}
;
var Ljava_util_stream_Collectors$lambda$4$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$4$Type', 1138);
function Collectors$lambda$5$Type(downstream_1){
  this.downstream_1 = downstream_1;
}

defineClass(1139, 1, $intern_11, Collectors$lambda$5$Type);
_.apply_0 = function apply_29(arg0){
  return lambda$5(this.downstream_1, arg0);
}
;
var Ljava_util_stream_Collectors$lambda$5$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$5$Type', 1139);
function Collectors$lambda$8$Type(){
}

defineClass(1141, 1, {}, Collectors$lambda$8$Type);
_.get_5 = function get_35(){
  var partition;
  return partition = new LinkedHashMap , $put_6(partition, ($clinit_Boolean() , $clinit_Boolean() , false), new ArrayList) , $put_6(partition, (null , true), new ArrayList) , partition;
}
;
var Ljava_util_stream_Collectors$lambda$8$Type_2_classLit = createForClass('java.util.stream', 'Collectors/lambda$8$Type', 1141);
function $close(this$static){
  if (!this$static.root) {
    this$static.terminated = true;
    $runClosers(this$static);
  }
   else {
    $close(this$static.root);
  }
}

function $runClosers(this$static){
  var e, i, size_0, suppressed, throwables;
  throwables = new ArrayList;
  $forEach_0(this$static.onClose, new TerminatableStream$lambda$0$Type(throwables));
  this$static.onClose.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  if (throwables.array.length != 0) {
    e = (checkCriticalElementIndex(0, throwables.array.length) , castTo(throwables.array[0], 79));
    for (i = 1 , size_0 = throwables.array.length; i < size_0; ++i) {
      suppressed = (checkCriticalElementIndex(i, throwables.array.length) , castTo(throwables.array[i], 79));
      suppressed != e && $addSuppressed(e, suppressed);
    }
    if (instanceOf(e, 54)) {
      throw toJs(castTo(e, 54));
    }
    if (instanceOf(e, 282)) {
      throw toJs(castTo(e, 282));
    }
  }
}

function $terminate(this$static){
  if (!this$static.root) {
    $throwIfTerminated(this$static);
    this$static.terminated = true;
  }
   else {
    $terminate(this$static.root);
  }
}

function $throwIfTerminated(this$static){
  if (this$static.root) {
    $throwIfTerminated(this$static.root);
  }
   else if (this$static.terminated) {
    throw toJs(new IllegalStateException_0("Stream already terminated, can't be modified or used"));
  }
}

function TerminatableStream(previous){
  if (!previous) {
    this.root = null;
    this.onClose = new ArrayList;
  }
   else {
    this.root = previous;
    this.onClose = null;
  }
}

function lambda$0_0(throwables_0, runnable_1){
  var e;
  try {
    runnable_1.run();
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 79)) {
      e = $e0;
      throwables_0.array[throwables_0.array.length] = e;
    }
     else 
      throw toJs($e0);
  }
}

defineClass(581, 1, {});
_.terminated = false;
var Ljava_util_stream_TerminatableStream_2_classLit = createForClass('java.util.stream', 'TerminatableStream', 581);
function $collect(this$static){
  var acc;
  $terminate(this$static);
  acc = new DoubleSummaryStatistics;
  $forEachRemaining_2(this$static.spliterator, new DoubleStream$DoubleStreamSource$lambda$2$Type(acc));
  return acc;
}

function $iterator_3(this$static){
  return new Spliterators$DoubleConsumerIterator(($terminate(this$static) , this$static.spliterator));
}

function $max(this$static){
  var stats;
  stats = $collect(this$static);
  if (eq(stats.count, 0)) {
    return $clinit_OptionalDouble() , $clinit_OptionalDouble() , EMPTY_2;
  }
  return $clinit_OptionalDouble() , new OptionalDouble_0(stats.max_0);
}

function $min(this$static){
  var stats;
  stats = $collect(this$static);
  if (eq(stats.count, 0)) {
    return $clinit_OptionalDouble() , $clinit_OptionalDouble() , EMPTY_2;
  }
  return $clinit_OptionalDouble() , new OptionalDouble_0(stats.min_0);
}

function DoubleStream$DoubleStreamSource(previous, spliterator){
  TerminatableStream.call(this, previous);
  this.spliterator = spliterator;
}

defineClass(1508, 581, {}, DoubleStream$DoubleStreamSource);
var Ljava_util_stream_DoubleStream$DoubleStreamSource_2_classLit = createForClass('java.util.stream', 'DoubleStream/DoubleStreamSource', 1508);
function DoubleStream$DoubleStreamSource$lambda$2$Type(acc_1){
  this.acc_1 = acc_1;
}

defineClass(1509, 1, $intern_77, DoubleStream$DoubleStreamSource$lambda$2$Type);
_.accept_1 = function accept_22(arg0){
  $accept(this.acc_1, arg0);
}
;
var Ljava_util_stream_DoubleStream$DoubleStreamSource$lambda$2$Type_2_classLit = createForClass('java.util.stream', 'DoubleStream/DoubleStreamSource/lambda$2$Type', 1509);
function $max_0(this$static){
  var stats, acc;
  stats = ($terminate(this$static) , acc = new IntSummaryStatistics , $forEachRemaining_2(this$static.spliterator, new IntStream$IntStreamSource$lambda$2$Type(acc)) , acc);
  if (eq(stats.count, 0)) {
    return $clinit_OptionalInt() , $clinit_OptionalInt() , EMPTY_3;
  }
  return $clinit_OptionalInt() , new OptionalInt_0(stats.max_0);
}

function IntStream$IntStreamSource(previous, spliterator){
  TerminatableStream.call(this, previous);
  this.spliterator = spliterator;
}

defineClass(1484, 581, {}, IntStream$IntStreamSource);
var Ljava_util_stream_IntStream$IntStreamSource_2_classLit = createForClass('java.util.stream', 'IntStream/IntStreamSource', 1484);
function IntStream$IntStreamSource$lambda$2$Type(acc_1){
  this.acc_1 = acc_1;
}

defineClass(1485, 1, $intern_80, IntStream$IntStreamSource$lambda$2$Type);
_.accept_2 = function accept_23(arg0){
  $accept_0(this.acc_1, arg0);
}
;
var Ljava_util_stream_IntStream$IntStreamSource$lambda$2$Type_2_classLit = createForClass('java.util.stream', 'IntStream/IntStreamSource/lambda$2$Type', 1485);
function $lambda$0_0(this$static, action_1, item_1){
  if (this$static.filter.test_0(item_1)) {
    this$static.found = true;
    action_1.accept(item_1);
  }
}

function Stream$FilterSpliterator(filter, original){
  Spliterators$AbstractSpliterator.call(this, original.estimateSize_0(), original.characteristics_0() & -65);
  checkCriticalNotNull(filter);
  this.filter = filter;
  this.original = original;
}

defineClass(665, 505, $intern_22, Stream$FilterSpliterator);
_.tryAdvance = function tryAdvance_5(action){
  this.found = false;
  while (!this.found && this.original.tryAdvance(new Stream$FilterSpliterator$lambda$0$Type(this, action)))
  ;
  return this.found;
}
;
_.found = false;
var Ljava_util_stream_Stream$FilterSpliterator_2_classLit = createForClass('java.util.stream', 'Stream/FilterSpliterator', 665);
function Stream$FilterSpliterator$lambda$0$Type($$outer_0, action_1){
  this.$$outer_0 = $$outer_0;
  this.action_1 = action_1;
}

defineClass(974, 1, {}, Stream$FilterSpliterator$lambda$0$Type);
_.accept = function accept_24(arg0){
  $lambda$0_0(this.$$outer_0, this.action_1, arg0);
}
;
var Ljava_util_stream_Stream$FilterSpliterator$lambda$0$Type_2_classLit = createForClass('java.util.stream', 'Stream/FilterSpliterator/lambda$0$Type', 974);
function $lambda$0_1(this$static, action_1, u_1){
  action_1.accept_1(this$static.map_0.applyAsDouble(u_1));
}

function $tryAdvance_1(this$static, action){
  return this$static.original.tryAdvance(new Stream$MapToDoubleSpliterator$lambda$0$Type(this$static, action));
}

function Stream$MapToDoubleSpliterator(map_0, original){
  Spliterators$AbstractDoubleSpliterator.call(this, original.estimateSize_0(), original.characteristics_0() & -6);
  checkCriticalNotNull(map_0);
  this.map_0 = map_0;
  this.original = original;
}

defineClass(970, 969, $intern_22, Stream$MapToDoubleSpliterator);
_.tryAdvance_0 = function tryAdvance_6(action){
  return $tryAdvance_1(this, castTo(action, 189));
}
;
var Ljava_util_stream_Stream$MapToDoubleSpliterator_2_classLit = createForClass('java.util.stream', 'Stream/MapToDoubleSpliterator', 970);
function Stream$MapToDoubleSpliterator$lambda$0$Type($$outer_0, action_1){
  this.$$outer_0 = $$outer_0;
  this.action_1 = action_1;
}

defineClass(973, 1, {}, Stream$MapToDoubleSpliterator$lambda$0$Type);
_.accept = function accept_25(arg0){
  $lambda$0_1(this.$$outer_0, this.action_1, arg0);
}
;
var Ljava_util_stream_Stream$MapToDoubleSpliterator$lambda$0$Type_2_classLit = createForClass('java.util.stream', 'Stream/MapToDoubleSpliterator/lambda$0$Type', 973);
function $lambda$0_2(action_1, u_1){
  action_1.accept_2(($clinit_SplineEdgeRouter() , castTo(u_1, 121).rank + 1));
}

function $tryAdvance_2(this$static, action){
  return this$static.original.tryAdvance(new Stream$MapToIntSpliterator$lambda$0$Type(action));
}

function Stream$MapToIntSpliterator(map_0, original){
  Spliterators$AbstractIntSpliterator.call(this, original.estimateSize_0(), original.characteristics_0() & -6);
  checkCriticalNotNull(map_0);
  this.original = original;
}

defineClass(968, 967, $intern_22, Stream$MapToIntSpliterator);
_.tryAdvance_0 = function tryAdvance_7(action){
  return $tryAdvance_2(this, castTo(action, 262));
}
;
var Ljava_util_stream_Stream$MapToIntSpliterator_2_classLit = createForClass('java.util.stream', 'Stream/MapToIntSpliterator', 968);
function Stream$MapToIntSpliterator$lambda$0$Type(action_1){
  this.action_1 = action_1;
}

defineClass(972, 1, {}, Stream$MapToIntSpliterator$lambda$0$Type);
_.accept = function accept_26(arg0){
  $lambda$0_2(this.action_1, arg0);
}
;
var Ljava_util_stream_Stream$MapToIntSpliterator$lambda$0$Type_2_classLit = createForClass('java.util.stream', 'Stream/MapToIntSpliterator/lambda$0$Type', 972);
function $lambda$0_3(this$static, action_1, u_1){
  action_1.accept(this$static.map_0.apply_0(u_1));
}

function $tryAdvance_3(this$static, action){
  return this$static.original.tryAdvance(new Stream$MapToObjSpliterator$lambda$0$Type(this$static, action));
}

function Stream$MapToObjSpliterator(map_0, original){
  Spliterators$AbstractSpliterator.call(this, original.estimateSize_0(), original.characteristics_0() & -6);
  checkCriticalNotNull(map_0);
  this.map_0 = map_0;
  this.original = original;
}

defineClass(664, 505, $intern_22, Stream$MapToObjSpliterator);
_.tryAdvance = function tryAdvance_8(action){
  return $tryAdvance_3(this, action);
}
;
var Ljava_util_stream_Stream$MapToObjSpliterator_2_classLit = createForClass('java.util.stream', 'Stream/MapToObjSpliterator', 664);
function Stream$MapToObjSpliterator$lambda$0$Type($$outer_0, action_1){
  this.$$outer_0 = $$outer_0;
  this.action_1 = action_1;
}

defineClass(971, 1, {}, Stream$MapToObjSpliterator$lambda$0$Type);
_.accept = function accept_27(arg0){
  $lambda$0_3(this.$$outer_0, this.action_1, arg0);
}
;
var Ljava_util_stream_Stream$MapToObjSpliterator$lambda$0$Type_2_classLit = createForClass('java.util.stream', 'Stream/MapToObjSpliterator/lambda$0$Type', 971);
function $anyMatch(this$static, predicate){
  return ($throwIfTerminated(this$static) , $findFirst(new Stream$StreamSource(this$static, new Stream$FilterSpliterator(predicate, this$static.spliterator)))).ref != null;
}

function $collect_0(this$static, collector){
  var lastArg;
  return collector.finisher.apply_0($reduce(this$static, collector.supplier.get_5(), (lastArg = new Stream$StreamSource$lambda$3$Type(collector) , lastArg)));
}

function $count_0(this$static){
  var count;
  $terminate(this$static);
  count = 0;
  while (this$static.spliterator.tryAdvance(new Stream$StreamSource$lambda$0$Type)) {
    count = add_20(count, 1);
  }
  return count;
}

function $filter(this$static, predicate){
  $throwIfTerminated(this$static);
  return new Stream$StreamSource(this$static, new Stream$FilterSpliterator(predicate, this$static.spliterator));
}

function $findFirst(this$static){
  var holder;
  $terminate(this$static);
  holder = new Stream$ValueConsumer;
  if (this$static.spliterator.tryAdvance(holder)) {
    return $clinit_Optional() , new Optional(checkCriticalNotNull(holder.value_0));
  }
  return $clinit_Optional() , $clinit_Optional() , EMPTY_1;
}

function $flatMap(this$static, mapper){
  var flatMapSpliterator, spliteratorOfStreams;
  $throwIfTerminated(this$static);
  spliteratorOfStreams = new Stream$MapToObjSpliterator(mapper, this$static.spliterator);
  flatMapSpliterator = new Stream$StreamSource$1(spliteratorOfStreams);
  return new Stream$StreamSource(this$static, flatMapSpliterator);
}

function $forEach_2(this$static, action){
  $terminate(this$static);
  this$static.spliterator.forEachRemaining(action);
}

function $map(this$static, mapper){
  $throwIfTerminated(this$static);
  return new Stream$StreamSource(this$static, new Stream$MapToObjSpliterator(mapper, this$static.spliterator));
}

function $mapToDouble(this$static, mapper){
  $throwIfTerminated(this$static);
  return new DoubleStream$DoubleStreamSource(this$static, new Stream$MapToDoubleSpliterator(mapper, this$static.spliterator));
}

function $mapToInt(this$static, mapper){
  $throwIfTerminated(this$static);
  return new IntStream$IntStreamSource(this$static, new Stream$MapToIntSpliterator(mapper, this$static.spliterator));
}

function $reduce(this$static, identity, accumulator){
  var consumer;
  $terminate(this$static);
  consumer = new Stream$ValueConsumer;
  consumer.value_0 = identity;
  this$static.spliterator.forEachRemaining(new Stream$StreamSource$lambda$4$Type(consumer, accumulator));
  return consumer.value_0;
}

function $reduce_0(this$static, accumulator){
  var consumer;
  consumer = new Stream$ValueConsumer;
  if (!this$static.spliterator.tryAdvance(consumer)) {
    $terminate(this$static);
    return $clinit_Optional() , $clinit_Optional() , EMPTY_1;
  }
  return $clinit_Optional() , new Optional(checkCriticalNotNull($reduce(this$static, consumer.value_0, accumulator)));
}

function $sorted(this$static, comparator){
  var sortedSpliterator;
  $throwIfTerminated(this$static);
  sortedSpliterator = new Stream$StreamSource$5(this$static, this$static.spliterator.estimateSize_0(), this$static.spliterator.characteristics_0() | 4, comparator);
  return new Stream$StreamSource(this$static, sortedSpliterator);
}

function Stream$StreamSource(prev, spliterator){
  TerminatableStream.call(this, prev);
  this.spliterator = spliterator;
}

function lambda$3_0(collector_0, a_1, t_2){
  collector_0.accumulator.accept_0(a_1, t_2);
  return a_1;
}

function lambda$4(consumer_0, accumulator_1, item_2){
  $accept_1(consumer_0, accumulator_1.apply_2(consumer_0.value_0, item_2));
}

defineClass(44, 581, {}, Stream$StreamSource);
var Ljava_util_stream_Stream$StreamSource_2_classLit = createForClass('java.util.stream', 'Stream/StreamSource', 44);
function $advanceToNextSpliterator(this$static){
  while (!this$static.next_0) {
    if (!$tryAdvance_3(this$static.val$spliteratorOfStreams5, new Stream$StreamSource$1$lambda$0$Type(this$static))) {
      return false;
    }
  }
  return true;
}

function $lambda$0_4(this$static, n_0){
  if (n_0) {
    this$static.nextStream = n_0;
    this$static.next_0 = ($terminate(n_0) , n_0.spliterator);
  }
}

function Stream$StreamSource$1(val$spliteratorOfStreams){
  this.val$spliteratorOfStreams5 = val$spliteratorOfStreams;
  Spliterators$AbstractSpliterator.call(this, $intern_23, 0);
}

defineClass(978, 505, $intern_22, Stream$StreamSource$1);
_.tryAdvance = function tryAdvance_9(action){
  while ($advanceToNextSpliterator(this)) {
    if (this.next_0.tryAdvance(action)) {
      return true;
    }
     else {
      $close(this.nextStream);
      this.nextStream = null;
      this.next_0 = null;
    }
  }
  return false;
}
;
var Ljava_util_stream_Stream$StreamSource$1_2_classLit = createForClass('java.util.stream', 'Stream/StreamSource/1', 978);
function Stream$StreamSource$1$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(979, 1, {}, Stream$StreamSource$1$lambda$0$Type);
_.accept = function accept_28(arg0){
  $lambda$0_4(this.$$outer_0, arg0);
}
;
var Ljava_util_stream_Stream$StreamSource$1$lambda$0$Type_2_classLit = createForClass('java.util.stream', 'Stream/StreamSource/1/lambda$0$Type', 979);
function Stream$StreamSource$5(this$1, $anonymous0, $anonymous1, val$comparator){
  this.this$11 = this$1;
  this.val$comparator5 = val$comparator;
  Spliterators$AbstractSpliterator.call(this, $anonymous0, $anonymous1);
}

defineClass(980, 505, $intern_22, Stream$StreamSource$5);
_.tryAdvance = function tryAdvance_10(action){
  var list;
  if (!this.ordered) {
    list = new ArrayList;
    this.this$11.spliterator.forEachRemaining(new Stream$StreamSource$5$2methodref$add$Type(list));
    $clinit_Collections();
    $sort(list, this.val$comparator5);
    this.ordered = new Spliterators$IteratorSpliterator(list, 16);
  }
  return $tryAdvance(this.ordered, action);
}
;
_.ordered = null;
var Ljava_util_stream_Stream$StreamSource$5_2_classLit = createForClass('java.util.stream', 'Stream/StreamSource/5', 980);
function Stream$StreamSource$5$2methodref$add$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(981, 1, {}, Stream$StreamSource$5$2methodref$add$Type);
_.accept = function accept_29(arg0){
  $add_4(this.$$outer_0, arg0);
}
;
var Ljava_util_stream_Stream$StreamSource$5$2methodref$add$Type_2_classLit = createForClass('java.util.stream', 'Stream/StreamSource/5/2methodref$add$Type', 981);
function Stream$StreamSource$lambda$0$Type(){
}

defineClass(975, 1, {}, Stream$StreamSource$lambda$0$Type);
_.accept = function accept_30(arg0){
}
;
var Ljava_util_stream_Stream$StreamSource$lambda$0$Type_2_classLit = createForClass('java.util.stream', 'Stream/StreamSource/lambda$0$Type', 975);
function Stream$StreamSource$lambda$3$Type(collector_0){
  this.collector_0 = collector_0;
}

defineClass(976, 1, {}, Stream$StreamSource$lambda$3$Type);
_.apply_2 = function apply_30(arg0, arg1){
  return lambda$3_0(this.collector_0, arg0, arg1);
}
;
var Ljava_util_stream_Stream$StreamSource$lambda$3$Type_2_classLit = createForClass('java.util.stream', 'Stream/StreamSource/lambda$3$Type', 976);
function Stream$StreamSource$lambda$4$Type(consumer_0, accumulator_1){
  this.consumer_0 = consumer_0;
  this.accumulator_1 = accumulator_1;
}

defineClass(977, 1, {}, Stream$StreamSource$lambda$4$Type);
_.accept = function accept_31(arg0){
  lambda$4(this.consumer_0, this.accumulator_1, arg0);
}
;
var Ljava_util_stream_Stream$StreamSource$lambda$4$Type_2_classLit = createForClass('java.util.stream', 'Stream/StreamSource/lambda$4$Type', 977);
function $accept_1(this$static, value_0){
  this$static.value_0 = value_0;
}

function Stream$ValueConsumer(){
}

defineClass(579, 1, {}, Stream$ValueConsumer);
_.accept = function accept_32(value_0){
  $accept_1(this, value_0);
}
;
var Ljava_util_stream_Stream$ValueConsumer_2_classLit = createForClass('java.util.stream', 'Stream/ValueConsumer', 579);
function TerminatableStream$lambda$0$Type(throwables_0){
  this.throwables_0 = throwables_0;
}

defineClass(982, 1, {}, TerminatableStream$lambda$0$Type);
_.accept = function accept_33(arg0){
  lambda$0_0(this.throwables_0, arg0);
}
;
var Ljava_util_stream_TerminatableStream$lambda$0$Type_2_classLit = createForClass('java.util.stream', 'TerminatableStream/lambda$0$Type', 982);
function applySplice(array, index_0, deleteCount, arrayToAdd){
  Array.prototype.splice.apply(array, [index_0, deleteCount].concat(arrayToAdd));
}

function clone_0(array, toIndex){
  var result;
  result = array.slice(0, toIndex);
  return stampJavaTypeInfo_0(result, array);
}

function copy_0(src_0, srcOfs, dest, destOfs, len, overwrite){
  var batchEnd, batchStart, end;
  if (maskUndefined(src_0) === maskUndefined(dest)) {
    src_0 = src_0.slice(srcOfs, srcOfs + len);
    srcOfs = 0;
  }
  for (batchStart = srcOfs , end = srcOfs + len; batchStart < end;) {
    batchEnd = batchStart + $intern_68 < end?batchStart + $intern_68:end;
    len = batchEnd - batchStart;
    applySplice(dest, destOfs, overwrite?len:0, src_0.slice(batchStart, batchEnd));
    batchStart = batchEnd;
    destOfs += len;
  }
}

function createFrom(array, length_0){
  var result;
  result = new Array(length_0);
  return stampJavaTypeInfo_0(result, array);
}

function insertTo(array, index_0, value_0){
  array.splice(index_0, 0, value_0);
}

function insertTo_0(array, index_0, values){
  copy_0(values, 0, array, index_0, values.length, false);
}

function removeFrom(array, index_0, deleteCount){
  array.splice(index_0, deleteCount);
}

function setLength(array, length_0){
  array.length = length_0;
}

function now_2(){
  if (Date.now) {
    return Date.now();
  }
  return (new Date).getTime();
}

function checkCriticalArgument(expression){
  if (!expression) {
    throw toJs(new IllegalArgumentException);
  }
}

function checkCriticalArgument_0(expression, errorMessage){
  if (!expression) {
    throw toJs(new IllegalArgumentException_0(errorMessage));
  }
}

function checkCriticalArgument_1(expression, errorMessageArgs){
  if (!expression) {
    throw toJs(new IllegalArgumentException_0(format_0('Enum constant undefined: %s', errorMessageArgs)));
  }
}

function checkCriticalArrayBounds_0(start_0, end, length_0){
  if (start_0 > end) {
    throw toJs(new IllegalArgumentException_0('fromIndex: ' + start_0 + ' > toIndex: ' + end));
  }
  if (start_0 < 0 || end > length_0) {
    throw toJs(new ArrayIndexOutOfBoundsException_0('fromIndex: ' + start_0 + ', toIndex: ' + end + ', length: ' + length_0));
  }
}

function checkCriticalArraySize(size_0){
  if (size_0 < 0) {
    throw toJs(new NegativeArraySizeException('Negative array size: ' + size_0));
  }
}

function checkCriticalArrayType(expression){
  if (!expression) {
    throw toJs(new ArrayStoreException);
  }
}

function checkCriticalArrayType_0(expression, errorMessage){
  if (!expression) {
    throw toJs(new ArrayStoreException_0(errorMessage));
  }
}

function checkCriticalElement(expression){
  if (!expression) {
    throw toJs(new NoSuchElementException);
  }
}

function checkCriticalElementIndex(index_0, size_0){
  if (index_0 < 0 || index_0 >= size_0) {
    throw toJs(new IndexOutOfBoundsException_0('Index: ' + index_0 + ', Size: ' + size_0));
  }
}

function checkCriticalNotNull(reference){
  if (reference == null) {
    throw toJs(new NullPointerException);
  }
  return reference;
}

function checkCriticalNotNull_0(reference, errorMessage){
  if (reference == null) {
    throw toJs(new NullPointerException_0(errorMessage));
  }
}

function checkCriticalPositionIndex(index_0, size_0){
  if (index_0 < 0 || index_0 > size_0) {
    throw toJs(new IndexOutOfBoundsException_0('Index: ' + index_0 + ', Size: ' + size_0));
  }
}

function checkCriticalPositionIndexes(start_0, end, size_0){
  if (start_0 < 0 || end > size_0) {
    throw toJs(new IndexOutOfBoundsException_0('fromIndex: ' + start_0 + ', toIndex: ' + end + ', size: ' + size_0));
  }
  if (start_0 > end) {
    throw toJs(new IllegalArgumentException_0('fromIndex: ' + start_0 + ' > toIndex: ' + end));
  }
}

function checkCriticalState(expression){
  if (!expression) {
    throw toJs(new IllegalStateException);
  }
}

function checkCriticalState_0(expression){
  if (!expression) {
    throw toJs(new IllegalStateException_0('Unable to add element to queue'));
  }
}

function checkCriticalStringBounds(start_0, end, length_0){
  if (start_0 < 0 || end > length_0 || end < start_0) {
    throw toJs(new StringIndexOutOfBoundsException('fromIndex: ' + start_0 + ', toIndex: ' + end + ', length: ' + length_0));
  }
}

function checkCriticalType(expression){
  if (!expression) {
    throw toJs(new ClassCastException);
  }
}

function checkNotNull_1(reference){
  checkCriticalNotNull(reference);
  return reference;
}

function format_0(template, args){
  var builder, i, placeholderStart, templateStart;
  template = template;
  builder = new StringBuilder_0;
  templateStart = 0;
  i = 0;
  while (i < args.length) {
    placeholderStart = template.indexOf('%s', templateStart);
    if (placeholderStart == -1) {
      break;
    }
    $append_11(builder, template.substr(templateStart, placeholderStart - templateStart));
    $append_10(builder, args[i++]);
    templateStart = placeholderStart + 2;
  }
  $append_11(builder, template.substr(templateStart, template.length - templateStart));
  if (i < args.length) {
    builder.string += ' [';
    $append_10(builder, args[i++]);
    while (i < args.length) {
      builder.string += ', ';
      $append_10(builder, args[i++]);
    }
    builder.string += ']';
  }
  return builder.string;
}

function compare_12(a, b){
  return a == b?0:a < b?-1:1;
}

function isFinite_0(d){
  return isFinite(d);
}

function isNaN_0(d){
  return isNaN(d);
}

function parseInt_1(s, radix){
  return parseInt(s, radix);
}

function setPropertySafe(map_0, key, value_0){
  try {
    map_0[key] = value_0;
  }
   catch (ignored) {
  }
}

function getHashCode_0(o){
  return o.$H || (o.$H = ++nextHashId);
}

var nextHashId = 0;
function $clinit_StringHashCache(){
  $clinit_StringHashCache = emptyMethod;
  back_0 = {};
  front = {};
}

function compute(str){
  var hashCode, i, n, nBatch;
  hashCode = 0;
  n = str.length;
  nBatch = n - 4;
  i = 0;
  while (i < nBatch) {
    hashCode = str.charCodeAt(i + 3) + 31 * (str.charCodeAt(i + 2) + 31 * (str.charCodeAt(i + 1) + 31 * (str.charCodeAt(i) + 31 * hashCode)));
    hashCode = hashCode | 0;
    i += 4;
  }
  while (i < n) {
    hashCode = hashCode * 31 + $charAt(str, i++);
  }
  hashCode = hashCode | 0;
  return hashCode;
}

function getHashCode_1(str){
  $clinit_StringHashCache();
  var hashCode, key, result;
  key = ':' + str;
  result = front[key];
  if (!(result === undefined)) {
    return result;
  }
  result = back_0[key];
  hashCode = result === undefined?compute(str):result;
  increment_0();
  front[key] = hashCode;
  return hashCode;
}

function increment_0(){
  if (count_0 == 256) {
    back_0 = front;
    front = {};
    count_0 = 0;
  }
  ++count_0;
}

var back_0, count_0 = 0, front;
function triangulate(vertices){
  var bottomright, boundary, c, i, invalidTriangles, onBoundary, other, other$iterator, sa, sb, sc, size_0, superTriangle, tEdge, tEdge$iterator, tEdge$iterator0, tEdges, topleft, triangle, triangle$iterator, triangle$iterator0, triangulation, v, v$iterator, vertex, vertex$iterator;
  topleft = new KVector_1($intern_62, $intern_62);
  bottomright = new KVector_1($intern_63, $intern_63);
  for (v$iterator = new ArrayList$1(vertices); v$iterator.i < v$iterator.this$01.array.length;) {
    v = castTo($next_10(v$iterator), 8);
    topleft.x_0 = $wnd.Math.min(topleft.x_0, v.x_0);
    topleft.y_0 = $wnd.Math.min(topleft.y_0, v.y_0);
    bottomright.x_0 = $wnd.Math.max(bottomright.x_0, v.x_0);
    bottomright.y_0 = $wnd.Math.max(bottomright.y_0, v.y_0);
  }
  size_0 = new KVector_1(bottomright.x_0 - topleft.x_0, bottomright.y_0 - topleft.y_0);
  sa = new KVector_1(topleft.x_0 - 50, topleft.y_0 - size_0.x_0 - 50);
  sb = new KVector_1(topleft.x_0 - 50, bottomright.y_0 + size_0.x_0 + 50);
  sc = new KVector_1(bottomright.x_0 + size_0.y_0 / 2 + 50, topleft.y_0 + size_0.y_0 / 2);
  superTriangle = new TTriangle(sa, sb, sc);
  triangulation = new HashSet;
  invalidTriangles = new ArrayList;
  boundary = new ArrayList;
  triangulation.map_0.put(superTriangle, triangulation);
  for (vertex$iterator = new ArrayList$1(vertices); vertex$iterator.i < vertex$iterator.this$01.array.length;) {
    vertex = castTo($next_10(vertex$iterator), 8);
    invalidTriangles.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    for (triangle$iterator0 = triangulation.map_0.keySet_0().iterator_0(); triangle$iterator0.hasNext_0();) {
      triangle = castTo(triangle$iterator0.next_1(), 317);
      c = triangle.circumcenter;
      $distance_0(c, triangle.a);
      fuzzyCompare($distance_0(triangle.circumcenter, vertex), $distance_0(triangle.circumcenter, triangle.a)) < 0 && (invalidTriangles.array[invalidTriangles.array.length] = triangle , true);
    }
    boundary.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    for (triangle$iterator = new ArrayList$1(invalidTriangles); triangle$iterator.i < triangle$iterator.this$01.array.length;) {
      triangle = castTo($next_10(triangle$iterator), 317);
      for (tEdge$iterator0 = new ArrayList$1(triangle.tEdges); tEdge$iterator0.i < tEdge$iterator0.this$01.array.length;) {
        tEdge = castTo($next_10(tEdge$iterator0), 177);
        onBoundary = true;
        for (other$iterator = new ArrayList$1(invalidTriangles); other$iterator.i < other$iterator.this$01.array.length;) {
          other = castTo($next_10(other$iterator), 317);
          other != triangle && (equals_56(tEdge, $get_7(other.tEdges, 0)) || equals_56(tEdge, $get_7(other.tEdges, 1)) || equals_56(tEdge, $get_7(other.tEdges, 2))) && (onBoundary = false);
        }
        onBoundary && (boundary.array[boundary.array.length] = tEdge , true);
      }
    }
    $removeAll_0(triangulation, invalidTriangles);
    $forEach(triangulation, new BowyerWatsonTriangulation$lambda$0$Type);
    for (tEdge$iterator = new ArrayList$1(boundary); tEdge$iterator.i < tEdge$iterator.this$01.array.length;) {
      tEdge = castTo($next_10(tEdge$iterator), 177);
      $add_6(triangulation, new TTriangle(vertex, tEdge.u, tEdge.v));
    }
  }
  tEdges = new HashSet;
  $forEach(triangulation, new BowyerWatsonTriangulation$lambda$1$Type(tEdges));
  i = tEdges.map_0.keySet_0().iterator_0();
  while (i.hasNext_0()) {
    tEdge = castTo(i.next_1(), 177);
    ($contains_9(superTriangle, tEdge.u) || $contains_9(superTriangle, tEdge.v)) && i.remove_0();
  }
  $forEach(tEdges, new BowyerWatsonTriangulation$lambda$2$Type);
  return tEdges;
}

function BowyerWatsonTriangulation$lambda$0$Type(){
}

defineClass(1582, 1, {}, BowyerWatsonTriangulation$lambda$0$Type);
_.accept = function accept_34(arg0){
}
;
var Lorg_eclipse_elk_alg_common_BowyerWatsonTriangulation$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common', 'BowyerWatsonTriangulation/lambda$0$Type', 1582);
function BowyerWatsonTriangulation$lambda$1$Type(tEdges_0){
  this.tEdges_0 = tEdges_0;
}

defineClass(1583, 1, {}, BowyerWatsonTriangulation$lambda$1$Type);
_.accept = function accept_35(arg0){
  $addAll(this.tEdges_0, castTo(arg0, 317).tEdges);
}
;
var Lorg_eclipse_elk_alg_common_BowyerWatsonTriangulation$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.common', 'BowyerWatsonTriangulation/lambda$1$Type', 1583);
function BowyerWatsonTriangulation$lambda$2$Type(){
}

defineClass(1584, 1, {}, BowyerWatsonTriangulation$lambda$2$Type);
_.accept = function accept_36(arg0){
}
;
var Lorg_eclipse_elk_alg_common_BowyerWatsonTriangulation$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.common', 'BowyerWatsonTriangulation/lambda$2$Type', 1584);
function createSpanningTree(tEdges, root, costFunction){
  var edge, edge$iterator, edge$iterator0, edgeList, edges, minST, nextEdge, nextNode, nodeInTree, subTree, treeNodes, weight;
  weight = ($clinit_Maps() , new HashMap);
  for (edge$iterator0 = tEdges.map_0.keySet_0().iterator_0(); edge$iterator0.hasNext_0();) {
    edge = castTo(edge$iterator0.next_1(), 177);
    $put_1(weight, edge, costFunction.cost(edge));
  }
  edgeList = (checkNotNull(tEdges) , tEdges?new ArrayList_1(($clinit_Collections2() , tEdges)):newArrayList_0(null.map_0.keySet_0().iterator_0()));
  $sort(edgeList, new NaiveMinST$lambda$0$Type(weight));
  edges = newLinkedHashSet(edgeList);
  minST = new Tree(root);
  treeNodes = new HashMap;
  $put_4(treeNodes.hashCodeMap, root, minST);
  while (edges.map_0.size_1() != 0) {
    nextEdge = null;
    nextNode = null;
    nodeInTree = null;
    for (edge$iterator = edges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
      edge = castTo(edge$iterator.next_1(), 177);
      if (checkNotNull_1(castToDouble(getEntryValueOrNull($getEntry(weight.hashCodeMap, edge)))) <= $intern_62) {
        if ($containsKey_2(treeNodes, edge.u) && !$containsKey_2(treeNodes, edge.v)) {
          nextNode = edge.v;
          nodeInTree = edge.u;
          nextEdge = edge;
          break;
        }
        if ($containsKey_2(treeNodes, edge.v)) {
          if (!$containsKey_2(treeNodes, edge.u)) {
            nextNode = edge.u;
            nodeInTree = edge.v;
            nextEdge = edge;
            break;
          }
        }
      }
    }
    if (!nextEdge) {
      break;
    }
    subTree = new Tree(nextNode);
    $add_4(castTo(getEntryValueOrNull($getEntry(treeNodes.hashCodeMap, nodeInTree)), 257).children, subTree);
    $put_4(treeNodes.hashCodeMap, nextNode, subTree);
    edges.map_0.remove(nextEdge) != null;
  }
  return minST;
}

function lambda$0_1(weight_0, e1_1, e2_2){
  return $compareTo_4(castToDouble(getEntryValueOrNull($getEntry(weight_0.hashCodeMap, e1_1))), castToDouble(getEntryValueOrNull($getEntry(weight_0.hashCodeMap, e2_2))));
}

function NaiveMinST$lambda$0$Type(weight_0){
  this.weight_0 = weight_0;
}

defineClass(1579, 1, $intern_40, NaiveMinST$lambda$0$Type);
_.equals_0 = function equals_60(other){
  return this === other;
}
;
_.reversed = function reversed_5(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_13(arg0, arg1){
  return lambda$0_1(this.weight_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_common_NaiveMinST$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common', 'NaiveMinST/lambda$0$Type', 1579);
function TEdge(u, v){
  this.u = u;
  this.v = v;
}

defineClass(177, 1, {177:1}, TEdge);
_.equals_0 = function equals_61(obj){
  var other;
  if (instanceOf(obj, 177)) {
    other = castTo(obj, 177);
    return equals_56(this.u, other.u) && equals_56(this.v, other.v) || equals_56(this.u, other.v) && equals_56(this.v, other.u);
  }
   else {
    return false;
  }
}
;
_.hashCode_1 = function hashCode_53(){
  return hashCode_49(this.u) + hashCode_49(this.v);
}
;
var Lorg_eclipse_elk_alg_common_TEdge_2_classLit = createForClass('org.eclipse.elk.alg.common', 'TEdge', 177);
function $contains_9(this$static, vertex){
  return equals_56(vertex, $get_7(this$static.vertices, 0)) || equals_56(vertex, $get_7(this$static.vertices, 1)) || equals_56(vertex, $get_7(this$static.vertices, 2));
}

function TTriangle(a, b, c){
  var ab, ac, bc, e, f, g, px, py;
  this.a = a;
  this.b = b;
  this.c = c;
  this.tEdges = newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_TEdge_2_classLit, 1), $intern_1, 177, 0, [new TEdge(a, b), new TEdge(b, c), new TEdge(c, a)]));
  this.vertices = newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [a, b, c]));
  this.circumcenter = (ab = $sub_0($clone_0(this.b), this.a) , ac = $sub_0($clone_0(this.c), this.a) , bc = $sub_0($clone_0(this.c), this.b) , e = ab.x_0 * (this.a.x_0 + this.b.x_0) + ab.y_0 * (this.a.y_0 + this.b.y_0) , f = ac.x_0 * (this.a.x_0 + this.c.x_0) + ac.y_0 * (this.a.y_0 + this.c.y_0) , g = 2 * (ab.x_0 * bc.y_0 - ab.y_0 * bc.x_0) , px = (ac.y_0 * e - ab.y_0 * f) / g , py = (ab.x_0 * f - ac.x_0 * e) / g , new KVector_1(px, py));
}

defineClass(317, 1, {317:1}, TTriangle);
_.equals_0 = function equals_62(obj){
  var other;
  if (instanceOf(obj, 317)) {
    other = castTo(obj, 317);
    return $contains_9(this, other.a) && $contains_9(this, other.b) && $contains_9(this, other.c);
  }
   else {
    return false;
  }
}
;
_.hashCode_1 = function hashCode_54(){
  return hashCode_49(this.a) + hashCode_49(this.b) + hashCode_49(this.c);
}
;
var Lorg_eclipse_elk_alg_common_TTriangle_2_classLit = createForClass('org.eclipse.elk.alg.common', 'TTriangle', 317);
function Tree(n){
  this.node = n;
  this.children = new ArrayList;
}

defineClass(257, 1, {257:1}, Tree);
var Lorg_eclipse_elk_alg_common_Tree_2_classLit = createForClass('org.eclipse.elk.alg.common', 'Tree', 257);
function $go(this$static){
  var h, h$iterator, p, p$iterator;
  $clinit_Collections();
  $sort(this$static.points, this$static.comparator);
  for (p$iterator = new ArrayList$1(this$static.points); p$iterator.i < p$iterator.this$01.array.length;) {
    p = $next_10(p$iterator);
    for (h$iterator = new ArrayList$1(this$static.eventHandlers); h$iterator.i < h$iterator.this$01.array.length;) {
      h = castTo($next_10(h$iterator), 635);
      h.handle(p);
    }
  }
}

function Scanline(points, comparator, eventHandlers){
  this.comparator = comparator;
  this.points = points;
  this.eventHandlers = (checkNotNull(eventHandlers) , new ArrayList_1(($clinit_Collections2() , eventHandlers)));
}

function execute(points, comparator, eventHandlers){
  var copy;
  copy = (checkNotNull(points) , new ArrayList_1(($clinit_Collections2() , points)));
  $go(new Scanline(copy, comparator, eventHandlers));
}

defineClass(1082, 1, {}, Scanline);
var Lorg_eclipse_elk_alg_common_compaction_Scanline_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction', 'Scanline', 1082);
var Lorg_eclipse_elk_alg_common_compaction_Scanline$EventHandler_2_classLit = createForInterface('org.eclipse.elk.alg.common.compaction', 'Scanline/EventHandler');
function $supports(this$static, direction){
  return $containsEnum(this$static.supportedDirections, direction);
}

function CGraph(supportedDirections){
  this.cNodes = new ArrayList;
  this.cGroups = new ArrayList;
  this.predefinedHorizontalConstraints = new ArrayList;
  this.predefinedVerticalConstraints = new ArrayList;
  this.supportedDirections = supportedDirections;
}

defineClass(1543, 1, {}, CGraph);
var Lorg_eclipse_elk_alg_common_compaction_oned_CGraph_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'CGraph', 1543);
function $addCNode(this$static, cNode){
  if (cNode.cGroup) {
    throw toJs(new RuntimeException_0('CNode belongs to another CGroup.'));
  }
  $add_6(this$static.cNodes, cNode);
  cNode.cGroup = this$static;
  !this$static.reference && (this$static.reference = cNode);
}

function CGroup(){
  this.cNodes = new LinkedHashSet;
  this.incomingConstraints = new HashSet;
  this.outDegree = 0;
  this.outDegreeReal = 0;
}

defineClass(316, 1, {316:1}, CGroup);
_.delta = 0;
_.deltaNormalized = 0;
_.id_0 = 0;
_.outDegree = 0;
_.outDegreeReal = 0;
_.startPos = $intern_63;
var Lorg_eclipse_elk_alg_common_compaction_oned_CGroup_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'CGroup', 316);
function $create(this$static, graph){
  $add_4(graph.cGroups, this$static.group);
  return this$static.group;
}

function $master(this$static, master){
  this$static.group.master = master;
  return this$static;
}

function $nodes(this$static, nodes){
  var n, n$index, n$max;
  for (n$index = 0 , n$max = nodes.length; n$index < n$max; ++n$index) {
    n = nodes[n$index];
    $addCNode(this$static.group, n);
  }
  return this$static;
}

function CGroup$CGroupBuilder(){
  this.group = new CGroup;
}

defineClass(754, 1, {}, CGroup$CGroupBuilder);
var Lorg_eclipse_elk_alg_common_compaction_oned_CGroup$CGroupBuilder_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'CGroup/CGroupBuilder', 754);
function CNode(){
  this.cGroupOffset = new KVector;
  this.constraints = new ArrayList;
}

defineClass(60, 1, {60:1}, CNode);
_.toString_0 = function toString_74(){
  if (this.toStringDelegate) {
    return castToString(this.toStringDelegate.apply_0(this));
  }
  return $ensureNamesAreInitialized(Lorg_eclipse_elk_alg_common_compaction_oned_CNode_2_classLit) , Lorg_eclipse_elk_alg_common_compaction_oned_CNode_2_classLit.typeName + '@' + (getHashCode_0(this) >>> 0).toString(16);
}
;
_.id_0 = 0;
_.startPos = $intern_63;
var Lorg_eclipse_elk_alg_common_compaction_oned_CNode_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'CNode', 60);
function $create_0(this$static, graph){
  $add_4(graph.cNodes, this$static.node);
  return this$static.node;
}

function $hitbox(this$static, hitbox){
  this$static.node.hitbox = hitbox;
  return this$static;
}

function $origin(this$static, origin){
  this$static.node.origin = origin;
  return this$static;
}

function $toStringDelegate(this$static, delegate){
  this$static.node.toStringDelegate = delegate;
  return this$static;
}

function CNode$CNodeBuilder(){
  this.node = new CNode;
}

defineClass(753, 1, {}, CNode$CNodeBuilder);
var Lorg_eclipse_elk_alg_common_compaction_oned_CNode$CNodeBuilder_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'CNode/CNodeBuilder', 753);
function eq_0(d1, d2){
  return $clinit_DoubleMath() , checkNonNegative($intern_42) , $wnd.Math.abs(d1 - d2) <= $intern_42 || d1 == d2 || isNaN(d1) && isNaN(d2);
}

function gt_0(d1, d2){
  return $clinit_DoubleMath() , $clinit_DoubleMath() , checkNonNegative($intern_42) , ($wnd.Math.abs(d1 - d2) <= $intern_42 || d1 == d2 || isNaN(d1) && isNaN(d2)?0:d1 < d2?-1:d1 > d2?1:compare_1(isNaN(d1), isNaN(d2))) > 0;
}

function le(d1, d2){
  return $clinit_DoubleMath() , $clinit_DoubleMath() , checkNonNegative($intern_42) , ($wnd.Math.abs(d1 - d2) <= $intern_42 || d1 == d2 || isNaN(d1) && isNaN(d2)?0:d1 < d2?-1:d1 > d2?1:compare_1(isNaN(d1), isNaN(d2))) <= 0;
}

function lt_0(d1, d2){
  return $clinit_DoubleMath() , $clinit_DoubleMath() , checkNonNegative($intern_42) , ($wnd.Math.abs(d1 - d2) <= $intern_42 || d1 == d2 || isNaN(d1) && isNaN(d2)?0:d1 < d2?-1:d1 > d2?1:compare_1(isNaN(d1), isNaN(d2))) < 0;
}

function $clinit_ISpacingsHandler(){
  $clinit_ISpacingsHandler = emptyMethod;
  DEFAULT_SPACING_HANDLER = new ISpacingsHandler$1;
}

var DEFAULT_SPACING_HANDLER;
function ISpacingsHandler$1(){
}

defineClass(1408, 1, {}, ISpacingsHandler$1);
_.getHorizontalSpacing = function getHorizontalSpacing(cNode1, cNode2){
  return 0;
}
;
_.getVerticalSpacing = function getVerticalSpacing(cNode1, cNode2){
  return 0;
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_ISpacingsHandler$1_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'ISpacingsHandler/1', 1408);
function LongestPathCompaction(){
}

defineClass(1603, 1, {}, LongestPathCompaction);
_.compact = function compact(compactor){
  var cNode, cNode$iterator, cNode$iterator0, diff, group, group$iterator, incNode, incNode$iterator, minStartPos, node, node$iterator, node$iterator0, sinks, spacing, suggestedX;
  minStartPos = $intern_62;
  for (cNode$iterator0 = new ArrayList$1(compactor.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator0), 60);
    minStartPos = $wnd.Math.min(minStartPos, cNode.cGroup.reference.hitbox.x_0 + cNode.cGroupOffset.x_0);
  }
  sinks = new LinkedList;
  for (group$iterator = new ArrayList$1(compactor.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 316);
    group.startPos = minStartPos;
    group.outDegree == 0 && ($addNode_0(sinks, group, sinks.tail.prev, sinks.tail) , true);
  }
  while (sinks.size_0 != 0) {
    group = castTo(sinks.size_0 == 0?null:(checkCriticalElement(sinks.size_0 != 0) , $removeNode_0(sinks, sinks.header.next_0)), 316);
    diff = group.reference.hitbox.x_0;
    for (node$iterator0 = group.cNodes.map_0.keySet_0().iterator_0(); node$iterator0.hasNext_0();) {
      node = castTo(node$iterator0.next_1(), 60);
      suggestedX = group.startPos + node.cGroupOffset.x_0;
      !$isLocked(compactor, group, compactor.direction) || node.hitbox.x_0 < suggestedX?(node.startPos = suggestedX):(node.startPos = node.hitbox.x_0);
    }
    diff -= group.reference.startPos;
    group.delta += diff;
    compactor.direction == ($clinit_Direction_0() , RIGHT_5) || compactor.direction == DOWN_1?(group.deltaNormalized += diff):(group.deltaNormalized -= diff);
    for (node$iterator = group.cNodes.map_0.keySet_0().iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 60);
      for (incNode$iterator = node.constraints.iterator_0(); incNode$iterator.hasNext_0();) {
        incNode = castTo(incNode$iterator.next_1(), 60);
        $isHorizontal(compactor.direction)?(spacing = compactor.spacingsHandler.getHorizontalSpacing(node, incNode)):(spacing = compactor.spacingsHandler.getVerticalSpacing(node, incNode));
        incNode.cGroup.startPos = $wnd.Math.max(incNode.cGroup.startPos, node.startPos + node.hitbox.width_0 + spacing - incNode.cGroupOffset.x_0);
        $isLocked_0(compactor, incNode, compactor.direction) && (incNode.cGroup.startPos = $wnd.Math.max(incNode.cGroup.startPos, incNode.hitbox.x_0 - incNode.cGroupOffset.x_0));
        --incNode.cGroup.outDegree;
        incNode.cGroup.outDegree == 0 && $add_7(sinks, incNode.cGroup);
      }
    }
  }
  for (cNode$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    cNode.hitbox.x_0 = cNode.startPos;
  }
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_LongestPathCompaction_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'LongestPathCompaction', 1603);
function $clinit_OneDimensionalCompactor(){
  $clinit_OneDimensionalCompactor = emptyMethod;
  LONGEST_PATH_COMPACTION = new LongestPathCompaction;
  SCANLINE_CONSTRAINTS = new ScanlineConstraintCalculator;
  QUADRATIC_CONSTRAINTS = new QuadraticConstraintCalculation;
}

function $calculateConstraints(this$static){
  var cNode, cNode$iterator, cstrs;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    cNode.constraints.clear_0();
  }
  $isHorizontal(this$static.direction)?(cstrs = this$static.cGraph.predefinedHorizontalConstraints):(cstrs = this$static.cGraph.predefinedVerticalConstraints);
  $forEach_0(cstrs, new OneDimensionalCompactor$lambda$0$Type(this$static));
  this$static.constraintAlgorithm.calculateConstraints(this$static);
  $calculateConstraintsForCGroups(this$static);
}

function $calculateConstraintsForCGroups(this$static){
  var cNode, cNode$iterator, group, group$iterator, group$iterator0, inc, inc$iterator;
  for (group$iterator0 = new ArrayList$1(this$static.cGraph.cGroups); group$iterator0.i < group$iterator0.this$01.array.length;) {
    group = castTo($next_10(group$iterator0), 316);
    group.outDegree = 0;
    group.outDegreeReal = 0;
    group.incomingConstraints.map_0.clear_0();
  }
  for (group$iterator = new ArrayList$1(this$static.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 316);
    for (cNode$iterator = group.cNodes.map_0.keySet_0().iterator_0(); cNode$iterator.hasNext_0();) {
      cNode = castTo(cNode$iterator.next_1(), 60);
      for (inc$iterator = cNode.constraints.iterator_0(); inc$iterator.hasNext_0();) {
        inc = castTo(inc$iterator.next_1(), 60);
        if (inc.cGroup != group) {
          $add_6(group.incomingConstraints, inc);
          ++inc.cGroup.outDegree;
          ++inc.cGroup.outDegreeReal;
        }
      }
    }
  }
}

function $calculateGroupOffsets(this$static){
  var group, group$iterator, n, n$iterator, n$iterator0;
  for (group$iterator = new ArrayList$1(this$static.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 316);
    group.reference = null;
    for (n$iterator0 = group.cNodes.map_0.keySet_0().iterator_0(); n$iterator0.hasNext_0();) {
      n = castTo(n$iterator0.next_1(), 60);
      $reset_5(n.cGroupOffset);
      (!group.reference || n.hitbox.x_0 < group.reference.hitbox.x_0) && (group.reference = n);
    }
    for (n$iterator = group.cNodes.map_0.keySet_0().iterator_0(); n$iterator.hasNext_0();) {
      n = castTo(n$iterator.next_1(), 60);
      n.cGroupOffset.x_0 = n.hitbox.x_0 - group.reference.hitbox.x_0;
      n.cGroupOffset.y_0 = n.hitbox.y_0 - group.reference.hitbox.y_0;
    }
  }
  return this$static;
}

function $changeDirection(this$static, dir_0){
  var oldDirection;
  if (this$static.finished) {
    throw toJs(new IllegalStateException_0(($ensureNamesAreInitialized(Lorg_eclipse_elk_alg_common_compaction_oned_OneDimensionalCompactor_2_classLit) , 'The ' + Lorg_eclipse_elk_alg_common_compaction_oned_OneDimensionalCompactor_2_classLit.simpleName + ' instance has been finished already.')));
  }
  if (!$supports(this$static.cGraph, dir_0)) {
    throw toJs(new RuntimeException_0('The direction ' + dir_0 + ' is not supported by the CGraph instance.'));
  }
  if (dir_0 == this$static.direction) {
    return this$static;
  }
  oldDirection = this$static.direction;
  this$static.direction = dir_0;
  switch (oldDirection.ordinal) {
    case 0:
      switch (dir_0.ordinal) {
        case 2:
          $calculateConstraints(this$static);
          break;
        case 1:
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 4:
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 3:
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
      }

      break;
    case 2:
      switch (dir_0.ordinal) {
        case 1:
          $mirrorHitboxes(this$static);
          $reverseConstraints(this$static);
          break;
        case 4:
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 3:
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
      }

      break;
    case 1:
      switch (dir_0.ordinal) {
        case 2:
          $mirrorHitboxes(this$static);
          $reverseConstraints(this$static);
          break;
        case 4:
          $mirrorHitboxes(this$static);
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 3:
          $mirrorHitboxes(this$static);
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
      }

      break;
    case 4:
      switch (dir_0.ordinal) {
        case 2:
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 1:
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 3:
          $mirrorHitboxes(this$static);
          $reverseConstraints(this$static);
      }

      break;
    case 3:
      switch (dir_0.ordinal) {
        case 2:
          $mirrorHitboxes(this$static);
          $transposeHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 1:
          $mirrorHitboxes(this$static);
          $transposeHitboxes(this$static);
          $mirrorHitboxes(this$static);
          $calculateConstraints(this$static);
          break;
        case 4:
          $mirrorHitboxes(this$static);
          $reverseConstraints(this$static);
      }

  }
  return this$static;
}

function $compact(this$static){
  var g, g$iterator, n, n$iterator;
  if (this$static.finished) {
    throw toJs(new IllegalStateException_0(($ensureNamesAreInitialized(Lorg_eclipse_elk_alg_common_compaction_oned_OneDimensionalCompactor_2_classLit) , 'The ' + Lorg_eclipse_elk_alg_common_compaction_oned_OneDimensionalCompactor_2_classLit.simpleName + ' instance has been finished already.')));
  }
  this$static.direction == ($clinit_Direction_0() , UNDEFINED_3) && $changeDirection(this$static, LEFT_5);
  for (g$iterator = new ArrayList$1(this$static.cGraph.cGroups); g$iterator.i < g$iterator.this$01.array.length;) {
    g = castTo($next_10(g$iterator), 316);
    g.outDegree = g.outDegreeReal;
  }
  for (n$iterator = new ArrayList$1(this$static.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 60);
    n.startPos = $intern_63;
  }
  this$static.compactionAlgorithm.compact(this$static);
  return this$static;
}

function $isLocked(this$static, group, dir_0){
  var n, n$iterator;
  for (n$iterator = group.cNodes.map_0.keySet_0().iterator_0(); n$iterator.hasNext_0();) {
    n = castTo(n$iterator.next_1(), 60);
    if ($isLocked_0(this$static, n, dir_0)) {
      return true;
    }
  }
  return false;
}

function $isLocked_0(this$static, node, dir_0){
  if (this$static.lockFun) {
    return this$static.lockFun.isLocked(node, dir_0);
  }
  return false;
}

function $lambda$0_5(this$static, p_0){
  this$static.direction == ($clinit_Direction_0() , LEFT_5) || this$static.direction == UP_1?castTo(p_0.first, 60).constraints.add_1(castTo(p_0.second, 60)):castTo(p_0.second, 60).constraints.add_1(castTo(p_0.first, 60));
}

function $mirrorHitboxes(this$static){
  var cNode, cNode$iterator;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    cNode.hitbox.x_0 = -cNode.hitbox.x_0 - cNode.hitbox.width_0;
  }
  $calculateGroupOffsets(this$static);
}

function $reverseConstraints(this$static){
  var cNode, cNode$iterator, cNode$iterator0, cNode$iterator1, inc, inc$iterator, incMap;
  incMap = ($clinit_Maps() , new HashMap);
  for (cNode$iterator0 = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator0), 60);
    $put_1(incMap, cNode, new ArrayList);
  }
  for (cNode$iterator1 = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator1.i < cNode$iterator1.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator1), 60);
    cNode.startPos = $intern_63;
    for (inc$iterator = cNode.constraints.iterator_0(); inc$iterator.hasNext_0();) {
      inc = castTo(inc$iterator.next_1(), 60);
      castTo(getEntryValueOrNull($getEntry(incMap.hashCodeMap, inc)), 15).add_1(cNode);
    }
  }
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    cNode.constraints.clear_0();
    cNode.constraints = castTo(getEntryValueOrNull($getEntry(incMap.hashCodeMap, cNode)), 15);
  }
  $calculateConstraintsForCGroups(this$static);
}

function $setCompactionAlgorithm(this$static, compactor){
  this$static.compactionAlgorithm = compactor;
  return this$static;
}

function $setConstraintAlgorithm(this$static, theConstraintAlgorithm){
  this$static.constraintAlgorithm = theConstraintAlgorithm;
  return this$static;
}

function $setLockFunction(this$static, fun){
  this$static.lockFun = fun;
  return this$static;
}

function $setSpacingsHandler(this$static, handler){
  this$static.spacingsHandler = handler;
  return this$static;
}

function $transposeHitboxes(this$static){
  var cNode, cNode$iterator, tmp;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    tmp = cNode.hitbox.x_0;
    cNode.hitbox.x_0 = cNode.hitbox.y_0;
    cNode.hitbox.y_0 = tmp;
    tmp = cNode.hitbox.width_0;
    cNode.hitbox.width_0 = cNode.hitbox.height;
    cNode.hitbox.height = tmp;
    tmp = cNode.cGroupOffset.x_0;
    cNode.cGroupOffset.x_0 = cNode.cGroupOffset.y_0;
    cNode.cGroupOffset.y_0 = tmp;
  }
  $calculateGroupOffsets(this$static);
}

function OneDimensionalCompactor(cGraph){
  $clinit_OneDimensionalCompactor();
  var n, n$iterator;
  this.compactionAlgorithm = LONGEST_PATH_COMPACTION;
  this.constraintAlgorithm = SCANLINE_CONSTRAINTS;
  this.spacingsHandler = ($clinit_ISpacingsHandler() , DEFAULT_SPACING_HANDLER);
  this.direction = ($clinit_Direction_0() , UNDEFINED_3);
  this.cGraph = cGraph;
  $calculateGroupOffsets(this);
  for (n$iterator = new ArrayList$1(cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 60);
    !n.cGroup && $create($nodes(new CGroup$CGroupBuilder, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_oned_CNode_2_classLit, 1), $intern_1, 60, 0, [n])), cGraph);
    n.hitboxPreCompaction = new ElkRectangle_1(n.hitbox);
  }
}

defineClass(1541, 1, {}, OneDimensionalCompactor);
_.finished = false;
var LONGEST_PATH_COMPACTION, QUADRATIC_CONSTRAINTS, SCANLINE_CONSTRAINTS;
var Lorg_eclipse_elk_alg_common_compaction_oned_OneDimensionalCompactor_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'OneDimensionalCompactor', 1541);
function OneDimensionalCompactor$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1542, 1, {}, OneDimensionalCompactor$lambda$0$Type);
_.accept = function accept_37(arg0){
  $lambda$0_5(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_OneDimensionalCompactor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'OneDimensionalCompactor/lambda$0$Type', 1542);
function QuadraticConstraintCalculation(){
}

defineClass(1604, 1, {}, QuadraticConstraintCalculation);
_.calculateConstraints = function calculateConstraints(compactor){
  var cNode, cNode$iterator, cNode1, cNode1$iterator, cNode2, cNode2$iterator, spacing;
  for (cNode$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    cNode.constraints.clear_0();
  }
  for (cNode1$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode1$iterator.i < cNode1$iterator.this$01.array.length;) {
    cNode1 = castTo($next_10(cNode1$iterator), 60);
    for (cNode2$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode2$iterator.i < cNode2$iterator.this$01.array.length;) {
      cNode2 = castTo($next_10(cNode2$iterator), 60);
      if (cNode1 == cNode2) {
        continue;
      }
      if (!!cNode1.cGroup && cNode1.cGroup == cNode2.cGroup) {
        continue;
      }
      $isHorizontal(compactor.direction)?(spacing = compactor.spacingsHandler.getVerticalSpacing(cNode1, cNode2)):(spacing = compactor.spacingsHandler.getHorizontalSpacing(cNode1, cNode2));
      (cNode2.hitbox.x_0 > cNode1.hitbox.x_0 || cNode1.hitbox.x_0 == cNode2.hitbox.x_0 && cNode1.hitbox.width_0 < cNode2.hitbox.width_0) && gt_0(cNode2.hitbox.y_0 + cNode2.hitbox.height + spacing, cNode1.hitbox.y_0) && lt_0(cNode2.hitbox.y_0, cNode1.hitbox.y_0 + cNode1.hitbox.height + spacing) && cNode1.constraints.add_1(cNode2);
    }
  }
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_QuadraticConstraintCalculation_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'QuadraticConstraintCalculation', 1604);
function $applyOr(this$static, other){
  this$static.left = this$static.left | other.left;
  this$static.right = this$static.right | other.right;
  this$static.up = this$static.up | other.up;
  this$static.down = this$static.down | other.down;
}

function $get_14(this$static, direction){
  switch (direction.ordinal) {
    case 2:
      return this$static.left;
    case 1:
      return this$static.right;
    case 4:
      return this$static.up;
    case 3:
      return this$static.down;
    default:return false;
  }
}

function $set_3(this$static, value_0, direction){
  switch (direction.ordinal) {
    case 2:
      this$static.left = value_0;
      break;
    case 1:
      this$static.right = value_0;
      break;
    case 4:
      this$static.up = value_0;
      break;
    case 3:
      this$static.down = value_0;
  }
}

function $set_4(this$static){
  this$static.left = false;
  this$static.right = false;
  this$static.up = false;
  this$static.down = false;
}

function Quadruplet(){
  $set_4(this);
}

defineClass(490, 1, {490:1}, Quadruplet);
_.down = false;
_.left = false;
_.right = false;
_.up = false;
var Lorg_eclipse_elk_alg_common_compaction_oned_Quadruplet_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'Quadruplet', 490);
function $overlap(n1, n2){
  if (!n1 || !n2 || n1 == n2) {
    return false;
  }
  return le(n1.hitbox.x_0, n2.hitbox.x_0 + n2.hitbox.width_0) && le(n2.hitbox.x_0, n1.hitbox.x_0 + n1.hitbox.width_0);
}

function $sweep(this$static, filterFun){
  var n, n$iterator, points;
  points = new ArrayList;
  for (n$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 60);
    if (filterFun.apply_1(n)) {
      $add_4(points, new ScanlineConstraintCalculator$Timestamp(n, true));
      $add_4(points, new ScanlineConstraintCalculator$Timestamp(n, false));
    }
  }
  $reset_1(this$static.constraintsScanlineHandler);
  execute(points, this$static.constraintsScanlineComparator, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_Scanline$EventHandler_2_classLit, 1), $intern_1, 635, 0, [this$static.constraintsScanlineHandler])));
}

function ScanlineConstraintCalculator(){
  this.constraintsScanlineComparator = new ScanlineConstraintCalculator$lambda$0$Type;
  this.constraintsScanlineHandler = new ScanlineConstraintCalculator$ConstraintsScanlineHandler(this);
}

function lambda$0_2(p1_0, p2_1){
  var cmp, y1, y2;
  y1 = p1_0.node.hitbox.y_0;
  p1_0.low || (y1 += p1_0.node.hitbox.height);
  y2 = p2_1.node.hitbox.y_0;
  p2_1.low || (y2 += p2_1.node.hitbox.height);
  cmp = compare_5(y1, y2);
  if (cmp == 0) {
    if (!p1_0.low && p2_1.low) {
      return -1;
    }
     else if (!p2_1.low && p1_0.low) {
      return 1;
    }
  }
  return cmp;
}

defineClass(745, 1, {}, ScanlineConstraintCalculator);
_.calculateConstraints = function calculateConstraints_0(theCompactor){
  this.compactor = theCompactor;
  $sweep(this, new ScanlineConstraintCalculator$lambda$1$Type);
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_ScanlineConstraintCalculator_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'ScanlineConstraintCalculator', 745);
function $handle(this$static, p){
  var left, right;
  p.low?$insert_1(this$static, p):(left = castTo($lower(this$static.intervals, p.node), 60) , !!left && left == this$static.cand[p.node.id_0] && !!left.cGroup && left.cGroup != p.node.cGroup && left.constraints.add_1(p.node) , right = castTo($higher(this$static.intervals, p.node), 60) , !!right && this$static.cand[right.id_0] == p.node && !!right.cGroup && right.cGroup != p.node.cGroup && p.node.constraints.add_1(right) , $remove_28(this$static.intervals, p.node) , undefined);
}

function $insert_1(this$static, p){
  var right, success;
  success = $add_10(this$static.intervals, p.node);
  if (!success) {
    throw toJs(new IllegalStateException_0('Invalid hitboxes for scanline constraint calculation.'));
  }
  ($overlap(p.node, castTo($floor(this$static.intervals, p.node), 60)) || $overlap(p.node, castTo($ceiling(this$static.intervals, p.node), 60))) && ($clinit_System() , p.node + ' has overlap.');
  this$static.cand[p.node.id_0] = castTo($lower(this$static.intervals, p.node), 60);
  right = castTo($higher(this$static.intervals, p.node), 60);
  !!right && (this$static.cand[right.id_0] = p.node);
}

function $reset_1(this$static){
  var index_0, n, n$iterator;
  $clear_6(this$static.intervals.map_0);
  this$static.cand = initUnidimensionalArray(Lorg_eclipse_elk_alg_common_compaction_oned_CNode_2_classLit, $intern_1, 60, this$static.this$01.compactor.cGraph.cNodes.array.length, 0, 1);
  index_0 = 0;
  for (n$iterator = new ArrayList$1(this$static.this$01.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 60);
    n.id_0 = index_0++;
  }
}

function ScanlineConstraintCalculator$ConstraintsScanlineHandler(this$0){
  this.this$01 = this$0;
  this.intervals = new TreeSet_0(castTo(checkNotNull(new ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type), 59));
}

defineClass(1569, 1, {635:1}, ScanlineConstraintCalculator$ConstraintsScanlineHandler);
_.handle = function handle(p){
  $handle(this, castTo(p, 543));
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_ScanlineConstraintCalculator$ConstraintsScanlineHandler_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'ScanlineConstraintCalculator/ConstraintsScanlineHandler', 1569);
function ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type(){
}

defineClass(1570, 1, $intern_40, ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type);
_.equals_0 = function equals_63(other){
  return this === other;
}
;
_.reversed = function reversed_6(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_14(arg0, arg1){
  return compare_5(castTo(arg0, 60).hitbox.x_0 + castTo(arg0, 60).hitbox.width_0 / 2, castTo(arg1, 60).hitbox.x_0 + castTo(arg1, 60).hitbox.width_0 / 2);
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'ScanlineConstraintCalculator/ConstraintsScanlineHandler/lambda$0$Type', 1570);
function ScanlineConstraintCalculator$Timestamp(node, low){
  this.node = node;
  this.low = low;
}

defineClass(543, 1, {543:1}, ScanlineConstraintCalculator$Timestamp);
_.low = false;
var Lorg_eclipse_elk_alg_common_compaction_oned_ScanlineConstraintCalculator$Timestamp_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'ScanlineConstraintCalculator/Timestamp', 543);
function ScanlineConstraintCalculator$lambda$0$Type(){
}

defineClass(1571, 1, $intern_40, ScanlineConstraintCalculator$lambda$0$Type);
_.equals_0 = function equals_64(other){
  return this === other;
}
;
_.reversed = function reversed_7(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_15(arg0, arg1){
  return lambda$0_2(arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_ScanlineConstraintCalculator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'ScanlineConstraintCalculator/lambda$0$Type', 1571);
function ScanlineConstraintCalculator$lambda$1$Type(){
}

defineClass(1572, 1, $intern_91, ScanlineConstraintCalculator$lambda$1$Type);
_.equals_0 = function equals_65(other){
  return this === other;
}
;
_.test_0 = function test_4(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_31(arg0){
  return true;
}
;
var Lorg_eclipse_elk_alg_common_compaction_oned_ScanlineConstraintCalculator$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.oned', 'ScanlineConstraintCalculator/lambda$1$Type', 1572);
function $clinit_HighLevelSortingCriterion(){
  $clinit_HighLevelSortingCriterion = emptyMethod;
  NUM_OF_EXTERNAL_SIDES_THAN_NUM_OF_EXTENSIONS_LAST = new HighLevelSortingCriterion('NUM_OF_EXTERNAL_SIDES_THAN_NUM_OF_EXTENSIONS_LAST', 0);
  CORNER_CASES_THAN_SINGLE_SIDE_LAST = new HighLevelSortingCriterion('CORNER_CASES_THAN_SINGLE_SIDE_LAST', 1);
}

function HighLevelSortingCriterion(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_14(name_0){
  $clinit_HighLevelSortingCriterion();
  return valueOf(($clinit_HighLevelSortingCriterion$Map() , $MAP_2), name_0);
}

function values_10(){
  $clinit_HighLevelSortingCriterion();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_options_HighLevelSortingCriterion_2_classLit, 1), $intern_38, 407, 0, [NUM_OF_EXTERNAL_SIDES_THAN_NUM_OF_EXTENSIONS_LAST, CORNER_CASES_THAN_SINGLE_SIDE_LAST]);
}

defineClass(407, 22, {3:1, 34:1, 22:1, 407:1}, HighLevelSortingCriterion);
var CORNER_CASES_THAN_SINGLE_SIDE_LAST, NUM_OF_EXTERNAL_SIDES_THAN_NUM_OF_EXTENSIONS_LAST;
var Lorg_eclipse_elk_alg_common_compaction_options_HighLevelSortingCriterion_2_classLit = createForEnum('org.eclipse.elk.alg.common.compaction.options', 'HighLevelSortingCriterion', 407, Ljava_lang_Enum_2_classLit, values_10, valueOf_14);
function $clinit_HighLevelSortingCriterion$Map(){
  $clinit_HighLevelSortingCriterion$Map = emptyMethod;
  $MAP_2 = createValueOfMap(($clinit_HighLevelSortingCriterion() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_options_HighLevelSortingCriterion_2_classLit, 1), $intern_38, 407, 0, [NUM_OF_EXTERNAL_SIDES_THAN_NUM_OF_EXTENSIONS_LAST, CORNER_CASES_THAN_SINGLE_SIDE_LAST])));
}

var $MAP_2;
function $clinit_LowLevelSortingCriterion(){
  $clinit_LowLevelSortingCriterion = emptyMethod;
  BY_SIZE = new LowLevelSortingCriterion('BY_SIZE', 0);
  BY_SIZE_AND_SHAPE = new LowLevelSortingCriterion('BY_SIZE_AND_SHAPE', 1);
}

function LowLevelSortingCriterion(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_15(name_0){
  $clinit_LowLevelSortingCriterion();
  return valueOf(($clinit_LowLevelSortingCriterion$Map() , $MAP_3), name_0);
}

function values_11(){
  $clinit_LowLevelSortingCriterion();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_options_LowLevelSortingCriterion_2_classLit, 1), $intern_38, 406, 0, [BY_SIZE, BY_SIZE_AND_SHAPE]);
}

defineClass(406, 22, {3:1, 34:1, 22:1, 406:1}, LowLevelSortingCriterion);
var BY_SIZE, BY_SIZE_AND_SHAPE;
var Lorg_eclipse_elk_alg_common_compaction_options_LowLevelSortingCriterion_2_classLit = createForEnum('org.eclipse.elk.alg.common.compaction.options', 'LowLevelSortingCriterion', 406, Ljava_lang_Enum_2_classLit, values_11, valueOf_15);
function $clinit_LowLevelSortingCriterion$Map(){
  $clinit_LowLevelSortingCriterion$Map = emptyMethod;
  $MAP_3 = createValueOfMap(($clinit_LowLevelSortingCriterion() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_options_LowLevelSortingCriterion_2_classLit, 1), $intern_38, 406, 0, [BY_SIZE, BY_SIZE_AND_SHAPE])));
}

var $MAP_3;
var Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit = createForInterface('org.eclipse.elk.core.data', 'ILayoutMetaDataProvider');
function $clinit_PolyominoOptions(){
  $clinit_PolyominoOptions = emptyMethod;
  POLYOMINO_TRAVERSAL_STRATEGY_DEFAULT = ($clinit_TraversalStrategy() , QUADRANTS_LINE_BY_LINE);
  POLYOMINO_TRAVERSAL_STRATEGY = new Property_1('org.eclipse.elk.polyomino.traversalStrategy', POLYOMINO_TRAVERSAL_STRATEGY_DEFAULT);
  POLYOMINO_LOW_LEVEL_SORT_DEFAULT = ($clinit_LowLevelSortingCriterion() , BY_SIZE_AND_SHAPE);
  POLYOMINO_LOW_LEVEL_SORT = new Property_1('org.eclipse.elk.polyomino.lowLevelSort', POLYOMINO_LOW_LEVEL_SORT_DEFAULT);
  POLYOMINO_HIGH_LEVEL_SORT_DEFAULT = ($clinit_HighLevelSortingCriterion() , NUM_OF_EXTERNAL_SIDES_THAN_NUM_OF_EXTENSIONS_LAST);
  POLYOMINO_HIGH_LEVEL_SORT = new Property_1('org.eclipse.elk.polyomino.highLevelSort', POLYOMINO_HIGH_LEVEL_SORT_DEFAULT);
  POLYOMINO_FILL = new Property_1('org.eclipse.elk.polyomino.fill', ($clinit_Boolean() , $clinit_Boolean() , true));
}

function PolyominoOptions(){
  $clinit_PolyominoOptions();
}

defineClass(783, 1, $intern_92, PolyominoOptions);
_.apply_3 = function apply_32(registry){
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.polyomino.traversalStrategy'), 'polyomino'), 'Polyomino Traversal Strategy'), 'Traversal strategy for trying different candidate positions for polyominoes.'), POLYOMINO_TRAVERSAL_STRATEGY_DEFAULT), ($clinit_LayoutOptionData$Type() , ENUM)), Lorg_eclipse_elk_alg_common_compaction_options_TraversalStrategy_2_classLit), of_0(($clinit_LayoutOptionData$Target() , PARENTS)))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.polyomino.lowLevelSort'), 'polyomino'), 'Polyomino Secondary Sorting Criterion'), 'Possible secondary sorting criteria for the processing order of polyominoes. They are used when polyominoes are equal according to the primary sorting criterion HighLevelSortingCriterion.'), POLYOMINO_LOW_LEVEL_SORT_DEFAULT), ENUM), Lorg_eclipse_elk_alg_common_compaction_options_LowLevelSortingCriterion_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.polyomino.highLevelSort'), 'polyomino'), 'Polyomino Primary Sorting Criterion'), 'Possible primary sorting criteria for the processing order of polyominoes.'), POLYOMINO_HIGH_LEVEL_SORT_DEFAULT), ENUM), Lorg_eclipse_elk_alg_common_compaction_options_HighLevelSortingCriterion_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.polyomino.fill'), 'polyomino'), 'Fill Polyominoes'), 'Use the Profile Fill algorithm to fill polyominoes to prevent small polyominoes from being placed inside of big polyominoes with large holes. Might increase packing area.'), ($clinit_Boolean() , $clinit_Boolean() , true)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
}
;
var POLYOMINO_FILL, POLYOMINO_HIGH_LEVEL_SORT, POLYOMINO_HIGH_LEVEL_SORT_DEFAULT, POLYOMINO_LOW_LEVEL_SORT, POLYOMINO_LOW_LEVEL_SORT_DEFAULT, POLYOMINO_TRAVERSAL_STRATEGY, POLYOMINO_TRAVERSAL_STRATEGY_DEFAULT;
var Lorg_eclipse_elk_alg_common_compaction_options_PolyominoOptions_2_classLit = createForClass('org.eclipse.elk.alg.common.compaction.options', 'PolyominoOptions', 783);
function $clinit_TraversalStrategy(){
  $clinit_TraversalStrategy = emptyMethod;
  SPIRAL = new TraversalStrategy('SPIRAL', 0);
  LINE_BY_LINE = new TraversalStrategy('LINE_BY_LINE', 1);
  MANHATTAN = new TraversalStrategy('MANHATTAN', 2);
  JITTER = new TraversalStrategy('JITTER', 3);
  QUADRANTS_LINE_BY_LINE = new TraversalStrategy('QUADRANTS_LINE_BY_LINE', 4);
  QUADRANTS_MANHATTAN = new TraversalStrategy('QUADRANTS_MANHATTAN', 5);
  QUADRANTS_JITTER = new TraversalStrategy('QUADRANTS_JITTER', 6);
  COMBINE_LINE_BY_LINE_MANHATTAN = new TraversalStrategy('COMBINE_LINE_BY_LINE_MANHATTAN', 7);
  COMBINE_JITTER_MANHATTAN = new TraversalStrategy('COMBINE_JITTER_MANHATTAN', 8);
}

function TraversalStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_16(name_0){
  $clinit_TraversalStrategy();
  return valueOf(($clinit_TraversalStrategy$Map() , $MAP_4), name_0);
}

function values_12(){
  $clinit_TraversalStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_options_TraversalStrategy_2_classLit, 1), $intern_38, 237, 0, [SPIRAL, LINE_BY_LINE, MANHATTAN, JITTER, QUADRANTS_LINE_BY_LINE, QUADRANTS_MANHATTAN, QUADRANTS_JITTER, COMBINE_LINE_BY_LINE_MANHATTAN, COMBINE_JITTER_MANHATTAN]);
}

defineClass(237, 22, {3:1, 34:1, 22:1, 237:1}, TraversalStrategy);
var COMBINE_JITTER_MANHATTAN, COMBINE_LINE_BY_LINE_MANHATTAN, JITTER, LINE_BY_LINE, MANHATTAN, QUADRANTS_JITTER, QUADRANTS_LINE_BY_LINE, QUADRANTS_MANHATTAN, SPIRAL;
var Lorg_eclipse_elk_alg_common_compaction_options_TraversalStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.common.compaction.options', 'TraversalStrategy', 237, Ljava_lang_Enum_2_classLit, values_12, valueOf_16);
function $clinit_TraversalStrategy$Map(){
  $clinit_TraversalStrategy$Map = emptyMethod;
  $MAP_4 = createValueOfMap(($clinit_TraversalStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_options_TraversalStrategy_2_classLit, 1), $intern_38, 237, 0, [SPIRAL, LINE_BY_LINE, MANHATTAN, JITTER, QUADRANTS_LINE_BY_LINE, QUADRANTS_MANHATTAN, QUADRANTS_JITTER, COMBINE_LINE_BY_LINE_MANHATTAN, COMBINE_JITTER_MANHATTAN])));
}

var $MAP_4;
function $getOther(this$static, some_0){
  if (some_0 == this$static.source) {
    return this$static.target;
  }
   else if (some_0 == this$static.target) {
    return this$static.source;
  }
   else {
    throw toJs(new IllegalArgumentException_0('Node ' + some_0 + ' not part of edge ' + this$static));
  }
}

function NEdge(){
}

defineClass(193, 1, {193:1}, NEdge);
_.toString_0 = function toString_75(){
  return 'NEdge[id=' + this.id_0 + ' w=' + this.weight + ' d=' + this.delta + ']';
}
;
_.delta = 1;
_.id_0 = 0;
_.internalId = 0;
_.treeEdge = false;
_.weight = 0;
var Lorg_eclipse_elk_alg_common_networksimplex_NEdge_2_classLit = createForClass('org.eclipse.elk.alg.common.networksimplex', 'NEdge', 193);
function $create_1(this$static){
  if (!this$static.edge.source || !this$static.edge.target) {
    throw toJs(new IllegalStateException_0(($ensureNamesAreInitialized(Lorg_eclipse_elk_alg_common_networksimplex_NEdge_2_classLit) , Lorg_eclipse_elk_alg_common_networksimplex_NEdge_2_classLit.simpleName + ' must have a source and target ' + ($ensureNamesAreInitialized(Lorg_eclipse_elk_alg_common_networksimplex_NNode_2_classLit) , Lorg_eclipse_elk_alg_common_networksimplex_NNode_2_classLit.simpleName) + ' specified.')));
  }
  if (this$static.edge.source == this$static.edge.target) {
    throw toJs(new IllegalStateException_0('Network simplex does not support self-loops: ' + this$static.edge + ' ' + this$static.edge.source + ' ' + this$static.edge.target));
  }
  $add_11(this$static.edge.source.outgoingEdges, this$static.edge);
  $add_11(this$static.edge.target.incomingEdges, this$static.edge);
  return this$static.edge;
}

function $delta(this$static, delta){
  this$static.edge.delta = delta;
  return this$static;
}

function $source(this$static, source){
  this$static.edge.source = source;
  return this$static;
}

function $target(this$static, target){
  this$static.edge.target = target;
  return this$static;
}

function $weight(this$static, weight){
  this$static.edge.weight = weight;
  return this$static;
}

function NEdge$NEdgeBuilder(){
  this.edge = new NEdge;
}

defineClass(163, 1, {}, NEdge$NEdgeBuilder);
var Lorg_eclipse_elk_alg_common_networksimplex_NEdge$NEdgeBuilder_2_classLit = createForClass('org.eclipse.elk.alg.common.networksimplex', 'NEdge/NEdgeBuilder', 163);
function $createArtificialRootAndConnect(this$static, nodesToConnect){
  var root, src_0, src$iterator;
  root = $create_2(new NNode$NNodeBuilder, this$static);
  for (src$iterator = new ArrayList$1(nodesToConnect); src$iterator.i < src$iterator.this$01.array.length;) {
    src_0 = castTo($next_10(src$iterator), 115);
    $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 0), 0), root), src_0));
  }
  return root;
}

function $dfs(this$static, node, mark){
  var edge, edge$iterator, other;
  if (mark[node.internalId]) {
    return;
  }
  mark[node.internalId] = true;
  for (edge$iterator = new ArrayList$1($getConnectedEdges(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 193);
    other = $getOther(edge, node);
    $dfs(this$static, other, mark);
  }
}

function $findConCompRepresentatives(this$static){
  var ccRep, mark, node, node$iterator;
  ccRep = new ArrayList;
  mark = initUnidimensionalArray(Z_classLit, $intern_93, 23, this$static.nodes.array.length, 16, 1);
  fill0_3(mark, mark.length);
  for (node$iterator = new ArrayList$1(this$static.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    if (!mark[node.internalId]) {
      ccRep.array[ccRep.array.length] = node;
      $dfs(this$static, node, mark);
    }
  }
  return ccRep;
}

function $makeConnected(this$static){
  var ccRep, id_0, n, n$iterator, root;
  id_0 = 0;
  for (n$iterator = new ArrayList$1(this$static.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 115);
    n.internalId = id_0++;
  }
  ccRep = $findConCompRepresentatives(this$static);
  root = null;
  ccRep.array.length > 1 && (root = $createArtificialRootAndConnect(this$static, ccRep));
  return root;
}

function NGraph(){
  this.nodes = new ArrayList;
}

defineClass(613, 1, {}, NGraph);
var Lorg_eclipse_elk_alg_common_networksimplex_NGraph_2_classLit = createForClass('org.eclipse.elk.alg.common.networksimplex', 'NGraph', 613);
function $getConnectedEdges(this$static){
  if (this$static.incomingEdgesModCnt != this$static.incomingEdges.modCount || this$static.outgoingEdgesModCnt != this$static.outgoingEdges.modCount) {
    this$static.allEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    $addAll_2(this$static.allEdges, this$static.incomingEdges);
    $addAll_2(this$static.allEdges, this$static.outgoingEdges);
    this$static.incomingEdgesModCnt = this$static.incomingEdges.modCount;
    this$static.outgoingEdgesModCnt = this$static.outgoingEdges.modCount;
  }
  return this$static.allEdges;
}

function NNode(){
  this.outgoingEdges = new NNode$ChangeAwareArrayList;
  this.incomingEdges = new NNode$ChangeAwareArrayList;
  this.allEdges = new ArrayList;
  this.unknownCutvalues = new ArrayList;
}

defineClass(115, 1, {115:1}, NNode);
_.incomingEdgesModCnt = -1;
_.internalId = 0;
_.layer = 0;
_.outgoingEdgesModCnt = -1;
_.treeNode = false;
var Lorg_eclipse_elk_alg_common_networksimplex_NNode_2_classLit = createForClass('org.eclipse.elk.alg.common.networksimplex', 'NNode', 115);
function $add_11(this$static, e){
  ++this$static.modCount;
  return $add_4(this$static.list, e);
}

function $remove_29(this$static, o){
  ++this$static.modCount;
  return $remove_13(this$static.list, o);
}

function NNode$ChangeAwareArrayList(){
  this.list = new ArrayList;
}

defineClass(738, 1, $intern_76, NNode$ChangeAwareArrayList);
_.forEach_0 = function forEach_18(action){
  $forEach(this, action);
}
;
_.parallelStream = function parallelStream_2(){
  return this.stream();
}
;
_.sort_0 = function sort_9(c){
  $sort_0(this, c);
}
;
_.spliterator_0 = function spliterator_30(){
  return new Spliterators$IteratorSpliterator(this, 16);
}
;
_.stream = function stream_3(){
  return new Stream$StreamSource(null, this.spliterator_0());
}
;
_.add_3 = function add_41(index_0, element){
  ++this.modCount;
  $add_3(this.list, index_0, element);
}
;
_.add_1 = function add_42(e){
  return $add_11(this, e);
}
;
_.addAll = function addAll_13(c){
  ++this.modCount;
  return $addAll_2(this.list, c);
}
;
_.clear_0 = function clear_47(){
  ++this.modCount;
  this.list.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}
;
_.contains = function contains_42(o){
  return $indexOf_3(this.list, o, 0) != -1;
}
;
_.containsAll = function containsAll_11(c){
  return $containsAll(this.list, c);
}
;
_.get_3 = function get_36(index_0){
  return $get_7(this.list, index_0);
}
;
_.indexOf_0 = function indexOf_7(o){
  return $indexOf_3(this.list, o, 0);
}
;
_.isEmpty = function isEmpty_21(){
  return this.list.array.length == 0;
}
;
_.iterator_0 = function iterator_58(){
  return unmodifiableIterator(new ArrayList$1(this.list));
}
;
_.listIterator_0 = function listIterator_13(){
  throw toJs(new UnsupportedOperationException);
}
;
_.listIterator_1 = function listIterator_14(index_0){
  throw toJs(new UnsupportedOperationException);
}
;
_.remove_2 = function remove_88(index_0){
  ++this.modCount;
  return $remove_12(this.list, index_0);
}
;
_.remove_1 = function remove_89(o){
  return $remove_29(this, o);
}
;
_.set_2 = function set_21(index_0, element){
  ++this.modCount;
  return $set_1(this.list, index_0, element);
}
;
_.size_1 = function size_55(){
  return this.list.array.length;
}
;
_.subList = function subList_9(fromIndex, toIndex){
  return new AbstractList$SubList(this.list, fromIndex, toIndex);
}
;
_.toArray = function toArray_26(){
  return $toArray_1(this.list);
}
;
_.toArray_0 = function toArray_27(a){
  return $toArray_2(this.list, a);
}
;
_.modCount = 0;
var Lorg_eclipse_elk_alg_common_networksimplex_NNode$ChangeAwareArrayList_2_classLit = createForClass('org.eclipse.elk.alg.common.networksimplex', 'NNode/ChangeAwareArrayList', 738);
function $create_2(this$static, graph){
  $add_4(graph.nodes, this$static.node);
  return this$static.node;
}

function $origin_0(this$static, origin){
  this$static.node.origin = origin;
  return this$static;
}

function NNode$NNodeBuilder(){
  this.node = new NNode;
}

defineClass(260, 1, {}, NNode$NNodeBuilder);
var Lorg_eclipse_elk_alg_common_networksimplex_NNode$NNodeBuilder_2_classLit = createForClass('org.eclipse.elk.alg.common.networksimplex', 'NNode/NNodeBuilder', 260);
function $balance(this$static, filling){
  var i, newLayer, node, node$iterator, range;
  for (node$iterator = new ArrayList$1(this$static.graph_0.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    if (node.incomingEdges.list.array.length == node.outgoingEdges.list.array.length) {
      newLayer = node.layer;
      range = $minimalSpan(node);
      for (i = node.layer - castTo(range.first, 21).value_0 + 1; i < node.layer + castTo(range.second, 21).value_0; i++) {
        filling[i] < filling[newLayer] && (newLayer = i);
      }
      if (filling[newLayer] < filling[node.layer]) {
        --filling[node.layer];
        ++filling[newLayer];
        node.layer = newLayer;
      }
    }
  }
}

function $cutvalues(this$static){
  var edge, edge$iterator, leafs, node, node$iterator, node$iterator0, source, target, toDetermine, treeEdgeCount;
  leafs = new ArrayList;
  for (node$iterator0 = new ArrayList$1(this$static.graph_0.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 115);
    treeEdgeCount = 0;
    node.unknownCutvalues.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    for (edge$iterator = new ArrayList$1($getConnectedEdges(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 193);
      if (edge.treeEdge) {
        $add_4(node.unknownCutvalues, edge);
        ++treeEdgeCount;
      }
    }
    treeEdgeCount == 1 && (leafs.array[leafs.array.length] = node , true);
  }
  for (node$iterator = new ArrayList$1(leafs); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    while (node.unknownCutvalues.array.length == 1) {
      toDetermine = castTo($next_10(new ArrayList$1(node.unknownCutvalues)), 193);
      this$static.cutvalue[toDetermine.internalId] = toDetermine.weight;
      source = toDetermine.source;
      target = toDetermine.target;
      for (edge$iterator = new ArrayList$1($getConnectedEdges(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 193);
        equals_Ljava_lang_Object__Z__devirtual$(edge, toDetermine) || (edge.treeEdge?source == edge.source || target == edge.target?(this$static.cutvalue[toDetermine.internalId] -= this$static.cutvalue[edge.internalId] - edge.weight):(this$static.cutvalue[toDetermine.internalId] += this$static.cutvalue[edge.internalId] - edge.weight):node == source?edge.source == node?(this$static.cutvalue[toDetermine.internalId] += edge.weight):(this$static.cutvalue[toDetermine.internalId] -= edge.weight):edge.source == node?(this$static.cutvalue[toDetermine.internalId] -= edge.weight):(this$static.cutvalue[toDetermine.internalId] += edge.weight));
      }
      $remove_13(source.unknownCutvalues, toDetermine);
      $remove_13(target.unknownCutvalues, toDetermine);
      source == node?(node = toDetermine.target):(node = toDetermine.source);
    }
  }
}

function $enterEdge(this$static, leave){
  var edge, edge$iterator, repSlack, replace, slack, source, target;
  if (!leave.treeEdge) {
    throw toJs(new IllegalArgumentException_0('The input edge is not a tree edge.'));
  }
  replace = null;
  repSlack = $intern_0;
  for (edge$iterator = new ArrayList$1(this$static.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 193);
    source = edge.source;
    target = edge.target;
    if ($isInHead(this$static, source, leave) && !$isInHead(this$static, target, leave)) {
      slack = target.layer - source.layer - edge.delta;
      if (slack < repSlack) {
        repSlack = slack;
        replace = edge;
      }
    }
  }
  return replace;
}

function $exchange(this$static, leave, enter){
  var delta, node, node$iterator;
  if (!leave.treeEdge) {
    throw toJs(new IllegalArgumentException_0('Given leave edge is no tree edge.'));
  }
  if (enter.treeEdge) {
    throw toJs(new IllegalArgumentException_0('Given enter edge is a tree edge already.'));
  }
  leave.treeEdge = false;
  $remove_18(this$static.treeEdges, leave);
  enter.treeEdge = true;
  $add_6(this$static.treeEdges, enter);
  delta = enter.target.layer - enter.source.layer - enter.delta;
  $isInHead(this$static, enter.target, leave) || (delta = -delta);
  for (node$iterator = new ArrayList$1(this$static.graph_0.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    $isInHead(this$static, node, leave) || (node.layer += delta);
  }
  this$static.postOrder = 1;
  fill_4(this$static.edgeVisited);
  $postorderTraversal(this$static, castTo($next_10(new ArrayList$1(this$static.graph_0.nodes)), 115));
  $cutvalues(this$static);
}

function $execute(this$static, monitor){
  var e, iter, node, node$iterator, removeSubtrees;
  $begin(monitor, 'Network simplex', 1);
  if (this$static.graph_0.nodes.array.length < 1) {
    $done_0(monitor);
    return;
  }
  for (node$iterator = new ArrayList$1(this$static.graph_0.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    node.layer = 0;
  }
  removeSubtrees = this$static.graph_0.nodes.array.length >= 40;
  removeSubtrees && $removeSubtrees(this$static);
  $initialize(this$static);
  $feasibleTree(this$static);
  e = $leaveEdge(this$static);
  iter = 0;
  while (!!e && iter < this$static.iterationLimit) {
    $exchange(this$static, e, $enterEdge(this$static, e));
    e = $leaveEdge(this$static);
    ++iter;
  }
  removeSubtrees && $reattachSubtrees(this$static);
  this$static.balance?$balance(this$static, $normalize(this$static)):$normalize(this$static);
  this$static.cutvalue = null;
  this$static.edges = null;
  this$static.treeEdges = null;
  this$static.edgeVisited = null;
  this$static.lowestPoID = null;
  this$static.poID = null;
  this$static.sources = null;
  this$static.subtreeNodesStack = null;
  $done_0(monitor);
}

function $feasibleTree(this$static){
  var e, node, node$iterator, slack;
  $layeringTopologicalNumbering(this$static, this$static.sources);
  if (this$static.edges.array.length > 0) {
    fill_4(this$static.edgeVisited);
    while ($tightTreeDFS(this$static, castTo($next_10(new ArrayList$1(this$static.graph_0.nodes)), 115)) < this$static.graph_0.nodes.array.length) {
      e = $minimalSlack(this$static);
      slack = e.target.layer - e.source.layer - e.delta;
      e.target.treeNode && (slack = -slack);
      for (node$iterator = new ArrayList$1(this$static.graph_0.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
        node = castTo($next_10(node$iterator), 115);
        node.treeNode && (node.layer += slack);
      }
      fill_4(this$static.edgeVisited);
    }
    fill_4(this$static.edgeVisited);
    $postorderTraversal(this$static, castTo($next_10(new ArrayList$1(this$static.graph_0.nodes)), 115));
    $cutvalues(this$static);
  }
}

function $initialize(this$static){
  var counter, edge, edge$iterator, index_0, n, n$iterator, node, node$iterator, numEdges, numNodes, theEdges;
  numNodes = this$static.graph_0.nodes.array.length;
  for (n$iterator = new ArrayList$1(this$static.graph_0.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 115);
    n.treeNode = false;
  }
  this$static.poID = initUnidimensionalArray(I_classLit, $intern_49, 23, numNodes, 15, 1);
  this$static.lowestPoID = initUnidimensionalArray(I_classLit, $intern_49, 23, numNodes, 15, 1);
  this$static.sources = new ArrayList;
  index_0 = 0;
  theEdges = new ArrayList;
  for (node$iterator = new ArrayList$1(this$static.graph_0.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    node.internalId = index_0++;
    node.incomingEdges.list.array.length == 0 && $add_4(this$static.sources, node);
    $addAll_2(theEdges, node.outgoingEdges);
  }
  counter = 0;
  for (edge$iterator = new ArrayList$1(theEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 193);
    edge.internalId = counter++;
    edge.treeEdge = false;
  }
  numEdges = theEdges.array.length;
  if (this$static.cutvalue == null || this$static.cutvalue.length < numEdges) {
    this$static.cutvalue = initUnidimensionalArray(D_classLit, $intern_69, 23, numEdges, 15, 1);
    this$static.edgeVisited = initUnidimensionalArray(Z_classLit, $intern_93, 23, numEdges, 16, 1);
  }
   else {
    fill_4(this$static.edgeVisited);
  }
  this$static.edges = theEdges;
  this$static.treeEdges = new LinkedHashSet_0(capacity_0(this$static.edges.array.length));
  this$static.postOrder = 1;
}

function $isInHead(this$static, node, edge){
  var source, target;
  source = edge.source;
  target = edge.target;
  if (this$static.lowestPoID[source.internalId] <= this$static.poID[node.internalId] && this$static.poID[node.internalId] <= this$static.poID[source.internalId] && this$static.lowestPoID[target.internalId] <= this$static.poID[node.internalId] && this$static.poID[node.internalId] <= this$static.poID[target.internalId]) {
    if (this$static.poID[source.internalId] < this$static.poID[target.internalId]) {
      return false;
    }
    return true;
  }
  if (this$static.poID[source.internalId] < this$static.poID[target.internalId]) {
    return true;
  }
  return false;
}

function $layeringTopologicalNumbering(this$static, initialRootNodes){
  var edge, edge$iterator, incident, node, node$iterator, roots, target;
  incident = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.graph_0.nodes.array.length, 15, 1);
  for (node$iterator = new ArrayList$1(this$static.graph_0.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    incident[node.internalId] += node.incomingEdges.list.array.length;
  }
  roots = newLinkedList(initialRootNodes);
  while (roots.size_0 != 0) {
    node = castTo(roots.size_0 == 0?null:(checkCriticalElement(roots.size_0 != 0) , $removeNode_0(roots, roots.header.next_0)), 115);
    for (edge$iterator = unmodifiableIterator(new ArrayList$1(node.outgoingEdges.list)); edge$iterator.hasNext_0();) {
      edge = castTo(edge$iterator.next_1(), 193);
      target = edge.target;
      target.layer = max_1(target.layer, node.layer + edge.delta);
      --incident[target.internalId];
      incident[target.internalId] == 0 && ($addNode_0(roots, target, roots.tail.prev, roots.tail) , true);
    }
  }
}

function $leaveEdge(this$static){
  var edge, edge$iterator;
  for (edge$iterator = this$static.treeEdges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
    edge = castTo(edge$iterator.next_1(), 193);
    if (edge.treeEdge && this$static.cutvalue[edge.internalId] < -1.0E-10) {
      return edge;
    }
  }
  return null;
}

function $minimalSlack(this$static){
  var curSlack, edge, edge$iterator, minSlack, minSlackEdge;
  minSlack = $intern_0;
  minSlackEdge = null;
  for (edge$iterator = new ArrayList$1(this$static.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 193);
    if (edge.source.treeNode ^ edge.target.treeNode) {
      curSlack = edge.target.layer - edge.source.layer - edge.delta;
      if (curSlack < minSlack) {
        minSlack = curSlack;
        minSlackEdge = edge;
      }
    }
  }
  return minSlackEdge;
}

function $minimalSpan(node){
  var currentSpan, edge, edge$iterator, minSpanIn, minSpanOut;
  minSpanOut = $intern_0;
  minSpanIn = $intern_0;
  for (edge$iterator = new ArrayList$1($getConnectedEdges(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 193);
    currentSpan = edge.target.layer - edge.source.layer;
    edge.target == node && currentSpan < minSpanIn?(minSpanIn = currentSpan):currentSpan < minSpanOut && (minSpanOut = currentSpan);
  }
  minSpanIn == $intern_0 && (minSpanIn = -1);
  minSpanOut == $intern_0 && (minSpanOut = -1);
  return new Pair(valueOf_4(minSpanIn), valueOf_4(minSpanOut));
}

function $normalize(this$static){
  var filling, highest, layerID, lowest, node, node$iterator, node$iterator0, nodeCntInLayer, nodeCntInLayer$array, nodeCntInLayer$index, nodeCntInLayer$max;
  highest = $intern_43;
  lowest = $intern_0;
  for (node$iterator0 = new ArrayList$1(this$static.graph_0.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 115);
    lowest = min_1(lowest, node.layer);
    highest = max_1(highest, node.layer);
  }
  filling = initUnidimensionalArray(I_classLit, $intern_49, 23, highest - lowest + 1, 15, 1);
  for (node$iterator = new ArrayList$1(this$static.graph_0.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    node.layer -= lowest;
    ++filling[node.layer];
  }
  layerID = 0;
  if (this$static.previousLayeringNodeCounts != null) {
    for (nodeCntInLayer$array = this$static.previousLayeringNodeCounts , nodeCntInLayer$index = 0 , nodeCntInLayer$max = nodeCntInLayer$array.length; nodeCntInLayer$index < nodeCntInLayer$max; ++nodeCntInLayer$index) {
      nodeCntInLayer = nodeCntInLayer$array[nodeCntInLayer$index];
      filling[layerID++] += nodeCntInLayer;
      if (filling.length == layerID) {
        break;
      }
    }
  }
  return filling;
}

function $postorderTraversal(this$static, node){
  var edge, edge$iterator, lowest;
  lowest = $intern_0;
  for (edge$iterator = new ArrayList$1($getConnectedEdges(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 193);
    if (edge.treeEdge && !this$static.edgeVisited[edge.internalId]) {
      this$static.edgeVisited[edge.internalId] = true;
      lowest = min_1(lowest, $postorderTraversal(this$static, $getOther(edge, node)));
    }
  }
  this$static.poID[node.internalId] = this$static.postOrder;
  this$static.lowestPoID[node.internalId] = min_1(lowest, this$static.postOrder++);
  return this$static.lowestPoID[node.internalId];
}

function $reattachSubtrees(this$static){
  var edge, leafy, node, placed;
  while (!$isEmpty(this$static.subtreeNodesStack)) {
    leafy = castTo($removeFirst(this$static.subtreeNodesStack), 37);
    node = castTo(leafy.first, 115);
    edge = castTo(leafy.second, 193);
    placed = $getOther(edge, node);
    if (edge.target == node) {
      $add_11(placed.outgoingEdges, edge);
      node.layer = placed.layer + edge.delta;
    }
     else {
      $add_11(placed.incomingEdges, edge);
      node.layer = placed.layer - edge.delta;
    }
    $add_4(this$static.graph_0.nodes, node);
  }
}

function $removeSubtrees(this$static){
  var edge, isOutEdge, leafs, leafy, node, node$iterator, other;
  this$static.subtreeNodesStack = new ArrayDeque;
  leafs = new LinkedList;
  for (node$iterator = new ArrayList$1(this$static.graph_0.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 115);
    $getConnectedEdges(node).array.length == 1 && ($addNode_0(leafs, node, leafs.tail.prev, leafs.tail) , true);
  }
  while (leafs.size_0 != 0) {
    node = castTo(leafs.size_0 == 0?null:(checkCriticalElement(leafs.size_0 != 0) , $removeNode_0(leafs, leafs.header.next_0)), 115);
    if ($getConnectedEdges(node).array.length == 0) {
      continue;
    }
    edge = castTo($get_7($getConnectedEdges(node), 0), 193);
    isOutEdge = node.outgoingEdges.list.array.length > 0;
    other = $getOther(edge, node);
    isOutEdge?$remove_29(other.incomingEdges, edge):$remove_29(other.outgoingEdges, edge);
    $getConnectedEdges(other).array.length == 1 && ($addNode_0(leafs, other, leafs.tail.prev, leafs.tail) , true);
    leafy = new Pair(node, edge);
    $addFirst(this$static.subtreeNodesStack, leafy);
    $remove_13(this$static.graph_0.nodes, node);
  }
}

function $tightTreeDFS(this$static, node){
  var edge, edge$iterator, nodeCount, opposite;
  nodeCount = 1;
  node.treeNode = true;
  for (edge$iterator = new ArrayList$1($getConnectedEdges(node)); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 193);
    if (!this$static.edgeVisited[edge.internalId]) {
      this$static.edgeVisited[edge.internalId] = true;
      opposite = $getOther(edge, node);
      if (edge.treeEdge) {
        nodeCount += $tightTreeDFS(this$static, opposite);
      }
       else if (!opposite.treeNode && edge.delta == edge.target.layer - edge.source.layer) {
        edge.treeEdge = true;
        $add_6(this$static.treeEdges, edge);
        nodeCount += $tightTreeDFS(this$static, opposite);
      }
    }
  }
  return nodeCount;
}

function $withBalancing(this$static, doBalance){
  this$static.balance = doBalance;
  return this$static;
}

function $withIterationLimit(this$static, limit){
  this$static.iterationLimit = limit;
  return this$static;
}

function $withPreviousLayering(this$static, considerPreviousLayering){
  this$static.previousLayeringNodeCounts = considerPreviousLayering;
  return this$static;
}

function NetworkSimplex(){
}

function forGraph(graph){
  var ns;
  ns = new NetworkSimplex;
  ns.graph_0 = graph;
  return ns;
}

defineClass(1477, 1, {}, NetworkSimplex);
_.balance = false;
_.iterationLimit = $intern_0;
_.postOrder = 0;
var Lorg_eclipse_elk_alg_common_networksimplex_NetworkSimplex_2_classLit = createForClass('org.eclipse.elk.alg.common.networksimplex', 'NetworkSimplex', 1477);
function computeInsideNodeLabelPadding(node){
  var col, col$array, col$array0, col$index, col$index0, col$max, col$max0, labelCell, labelCellContainer, nodeContext, padding, row, row$array, row$array0, row$index, row$index0, row$max, row$max0;
  nodeContext = new NodeContext(node);
  createNodeLabelCellContainers(nodeContext, true);
  $forEach_0(nodeContext.node.getLabels(), new NodeLabelCellCreator$lambda$0$Type(nodeContext, true));
  labelCellContainer = nodeContext.insideNodeLabelContainer;
  padding = new ElkPadding;
  for (col$array0 = ($clinit_ContainerArea() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END])) , col$index0 = 0 , col$max0 = col$array0.length; col$index0 < col$max0; ++col$index0) {
    col = col$array0[col$index0];
    labelCell = $getCell(labelCellContainer, BEGIN, col);
    !!labelCell && (padding.top_0 = $wnd.Math.max(padding.top_0, labelCell.getMinimumHeight()));
  }
  for (col$array = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END]) , col$index = 0 , col$max = col$array.length; col$index < col$max; ++col$index) {
    col = col$array[col$index];
    labelCell = $getCell(labelCellContainer, END, col);
    !!labelCell && (padding.bottom = $wnd.Math.max(padding.bottom, labelCell.getMinimumHeight()));
  }
  for (row$array0 = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END]) , row$index0 = 0 , row$max0 = row$array0.length; row$index0 < row$max0; ++row$index0) {
    row = row$array0[row$index0];
    labelCell = $getCell(labelCellContainer, row, BEGIN);
    !!labelCell && (padding.left = $wnd.Math.max(padding.left, labelCell.getMinimumWidth()));
  }
  for (row$array = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END]) , row$index = 0 , row$max = row$array.length; row$index < row$max; ++row$index) {
    row = row$array[row$index];
    labelCell = $getCell(labelCellContainer, row, END);
    !!labelCell && (padding.right = $wnd.Math.max(padding.right, labelCell.getMinimumWidth()));
  }
  if (padding.top_0 > 0) {
    padding.top_0 += labelCellContainer.padding.top_0;
    padding.top_0 += labelCellContainer.gap;
  }
  if (padding.bottom > 0) {
    padding.bottom += labelCellContainer.padding.bottom;
    padding.bottom += labelCellContainer.gap;
  }
  if (padding.left > 0) {
    padding.left += labelCellContainer.padding.left;
    padding.left += labelCellContainer.gap;
  }
  if (padding.right > 0) {
    padding.right += labelCellContainer.padding.right;
    padding.right += labelCellContainer.gap;
  }
  return padding;
}

function process(node, applyStuff, ignoreInsidePortLabels){
  var minSize, nodeContext, outerNodeLabelsOverhang;
  nodeContext = new NodeContext(node);
  createPortContexts(nodeContext, ignoreInsidePortLabels);
  createNodeLabelCellContainers(nodeContext, false);
  $forEach_0(nodeContext.node.getLabels(), new NodeLabelCellCreator$lambda$0$Type(nodeContext, false));
  createInsidePortLabelCell(nodeContext, nodeContext.nodeContainer, ($clinit_ContainerArea() , BEGIN), ($clinit_PortSide() , NORTH_1));
  createInsidePortLabelCell(nodeContext, nodeContext.nodeContainer, END, SOUTH_1);
  createInsidePortLabelCell(nodeContext, nodeContext.nodeContainerMiddleRow, BEGIN, WEST_1);
  createInsidePortLabelCell(nodeContext, nodeContext.nodeContainerMiddleRow, END, EAST_1);
  setupNorthOrSouthPortLabelCell(nodeContext, NORTH_1);
  setupNorthOrSouthPortLabelCell(nodeContext, SOUTH_1);
  setupEastOrWestPortLabelCell(nodeContext, EAST_1);
  setupEastOrWestPortLabelCell(nodeContext, WEST_1);
  $clinit_NodeLabelAndSizeUtilities();
  minSize = nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , MINIMUM_SIZE)) && nodeContext.sizeOptions.contains(($clinit_SizeOptions() , MINIMUM_SIZE_ACCOUNTS_FOR_PADDING))?getMinimumNodeOrClientAreaSize(nodeContext):null;
  !!minSize && $setCenterCellMinimumSize(nodeContext.insideNodeLabelContainer, minSize);
  setupNodePaddingForPortsWithOffset(nodeContext);
  calculateHorizontalPortPlacementSize(nodeContext);
  calculateVerticalPortPlacementSize(nodeContext);
  configureCellSystemSizeContributions(nodeContext);
  setNodeWidth(nodeContext);
  placeHorizontalPorts(nodeContext);
  placePortLabels(nodeContext, NORTH_1);
  placePortLabels(nodeContext, SOUTH_1);
  updateVerticalInsidePortLabelCellPadding(nodeContext);
  setNodeHeight(nodeContext);
  if (!applyStuff) {
    return nodeContext.nodeSize;
  }
  offsetSouthernPortsByNodeSize(nodeContext);
  placeVerticalPorts(nodeContext);
  placePortLabels(nodeContext, EAST_1);
  placePortLabels(nodeContext, WEST_1);
  outerNodeLabelsOverhang = nodeContext.sizeOptions.contains(($clinit_SizeOptions() , OUTSIDE_NODE_LABELS_OVERHANG));
  placeHorizontalOuterNodeLabelContainer(nodeContext, outerNodeLabelsOverhang, NORTH_1);
  placeHorizontalOuterNodeLabelContainer(nodeContext, outerNodeLabelsOverhang, SOUTH_1);
  placeVerticalOuterNodeLabelContainer(nodeContext, outerNodeLabelsOverhang, EAST_1);
  placeVerticalOuterNodeLabelContainer(nodeContext, outerNodeLabelsOverhang, WEST_1);
  $forEach_2(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(new AbstractMap$2(nodeContext.nodeLabelCells), 0)), new LabelPlacer$lambda$0$Type);
  $forEach_2($filter(new Stream$StreamSource(null, $values_0(nodeContext.portContexts).spliterator_0()), new LabelPlacer$lambda$1$Type), new LabelPlacer$lambda$2$Type);
  setNodePadding(nodeContext);
  nodeContext.node.setSize(nodeContext.nodeSize);
  $forEach_2(new Stream$StreamSource(null, $values_0(nodeContext.portContexts).spliterator_0()), new NodeLabelAndSizeUtilities$lambda$0$Type);
  return nodeContext.nodeSize;
}

function NodeLabelAndSizeCalculator$lambda$0$Type(){
}

defineClass(705, 1, {}, NodeLabelAndSizeCalculator$lambda$0$Type);
_.accept = function accept_38(arg0){
  process(castTo(arg0, 769), true, false);
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_NodeLabelAndSizeCalculator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing', 'NodeLabelAndSizeCalculator/lambda$0$Type', 705);
function $computeLabelBox(labelBox, label_0, incomingEdge, node, port, portLabelSpace, labelSpacing){
  labelBox.x_0 = node.getPosition().x_0;
  labelBox.y_0 = node.getPosition().y_0;
  if (port) {
    labelBox.x_0 += port.getPosition().x_0;
    labelBox.y_0 += port.getPosition().y_0;
  }
  labelBox.width_0 = label_0.getSize().x_0;
  labelBox.height = label_0.getSize().y_0;
  if (!port) {
    incomingEdge?(labelBox.x_0 -= labelSpacing + label_0.getSize().x_0):(labelBox.x_0 += node.getSize().x_0 + labelSpacing);
  }
   else {
    switch (port.getSide().ordinal) {
      case 0:
      case 2:
        labelBox.x_0 += port.getSize().x_0 + labelSpacing + portLabelSpace.x_0 + labelSpacing;
        break;
      case 4:
        labelBox.x_0 -= labelSpacing + portLabelSpace.x_0 + labelSpacing + label_0.getSize().x_0;
        break;
      case 1:
        labelBox.x_0 += port.getSize().x_0 + labelSpacing;
        labelBox.y_0 -= labelSpacing + portLabelSpace.y_0 + labelSpacing + label_0.getSize().y_0;
        break;
      case 3:
        labelBox.x_0 += port.getSize().x_0 + labelSpacing;
        labelBox.y_0 += port.getSize().y_0 + labelSpacing + portLabelSpace.y_0 + labelSpacing;
    }
  }
}

function $excludeEdgeHeadTailLabels(this$static){
  this$static.includeEdgeHeadTailLabels = false;
  return this$static;
}

function $process(this$static){
  var node, node$iterator, spacing;
  spacing = checkNotNull_1(castToDouble(this$static.adapter.getProperty(($clinit_CoreOptions() , SPACING_LABEL_NODE_0))));
  for (node$iterator = new ArrayList$1(this$static.adapter.getNodes()); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 769);
    $processNode_0(this$static, node, spacing);
  }
}

function $processEdgeHeadTailLabels(boundingBox, outgoingEdges, incomingEdges, node, port, portLabelSpace, labelSpacing){
  var edge, edge$iterator, edge$iterator0, label_0, label$iterator, labelBox;
  labelBox = new ElkRectangle;
  for (edge$iterator0 = outgoingEdges.iterator_0(); edge$iterator0.hasNext_0();) {
    edge = castTo(edge$iterator0.next_1(), 771);
    for (label$iterator = new ArrayList$1(edge.getLabels()); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 281);
      if (maskUndefined(label_0.getProperty(($clinit_CoreOptions() , EDGE_LABELS_PLACEMENT_0))) === maskUndefined(($clinit_EdgeLabelPlacement() , TAIL))) {
        $computeLabelBox(labelBox, label_0, false, node, port, portLabelSpace, labelSpacing);
        $union_0(boundingBox, labelBox);
      }
    }
  }
  for (edge$iterator = incomingEdges.iterator_0(); edge$iterator.hasNext_0();) {
    edge = castTo(edge$iterator.next_1(), 771);
    for (label$iterator = new ArrayList$1(edge.getLabels()); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 281);
      if (maskUndefined(label_0.getProperty(($clinit_CoreOptions() , EDGE_LABELS_PLACEMENT_0))) === maskUndefined(($clinit_EdgeLabelPlacement() , HEAD))) {
        $computeLabelBox(labelBox, label_0, true, node, port, portLabelSpace, labelSpacing);
        $union_0(boundingBox, labelBox);
      }
    }
  }
}

function $processNode(this$static, node){
  var spacing;
  spacing = checkNotNull_1(castToDouble(this$static.adapter.getProperty(($clinit_CoreOptions() , SPACING_LABEL_NODE_0))));
  $processNode_0(this$static, node, spacing);
}

function $processNode_0(this$static, node, labelSpacing){
  var boundingBox, elementBox, label_0, label$iterator, margin, port, port$iterator, portX, portY, requiredPortLabelSpace;
  boundingBox = new ElkRectangle_0(node.getPosition().x_0, node.getPosition().y_0, node.getSize().x_0, node.getSize().y_0);
  elementBox = new ElkRectangle;
  if (this$static.includeLabels) {
    for (label$iterator = new ArrayList$1(node.getLabels()); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 281);
      elementBox.x_0 = label_0.getPosition().x_0 + node.getPosition().x_0;
      elementBox.y_0 = label_0.getPosition().y_0 + node.getPosition().y_0;
      elementBox.width_0 = label_0.getSize().x_0;
      elementBox.height = label_0.getSize().y_0;
      $union_0(boundingBox, elementBox);
    }
  }
  for (port$iterator = new ArrayList$1(node.getPorts()); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 770);
    portX = port.getPosition().x_0 + node.getPosition().x_0;
    portY = port.getPosition().y_0 + node.getPosition().y_0;
    if (this$static.includePorts) {
      elementBox.x_0 = portX;
      elementBox.y_0 = portY;
      elementBox.width_0 = port.getSize().x_0;
      elementBox.height = port.getSize().y_0;
      $union_0(boundingBox, elementBox);
    }
    if (this$static.includePortLabels) {
      for (label$iterator = new ArrayList$1(port.getLabels()); label$iterator.i < label$iterator.this$01.array.length;) {
        label_0 = castTo($next_10(label$iterator), 281);
        elementBox.x_0 = label_0.getPosition().x_0 + portX;
        elementBox.y_0 = label_0.getPosition().y_0 + portY;
        elementBox.width_0 = label_0.getSize().x_0;
        elementBox.height = label_0.getSize().y_0;
        $union_0(boundingBox, elementBox);
      }
    }
    if (this$static.includeEdgeHeadTailLabels) {
      requiredPortLabelSpace = new KVector_1(-labelSpacing, -labelSpacing);
      if (maskUndefined(node.getProperty(($clinit_CoreOptions() , PORT_LABELS_PLACEMENT_0))) === maskUndefined(($clinit_PortLabelPlacement() , OUTSIDE_0))) {
        for (label$iterator = new ArrayList$1(port.getLabels()); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_10(label$iterator), 281);
          requiredPortLabelSpace.x_0 += label_0.getSize().x_0 + labelSpacing;
          requiredPortLabelSpace.y_0 += label_0.getSize().y_0 + labelSpacing;
        }
      }
      requiredPortLabelSpace.x_0 = $wnd.Math.max(requiredPortLabelSpace.x_0, 0);
      requiredPortLabelSpace.y_0 = $wnd.Math.max(requiredPortLabelSpace.y_0, 0);
      $processEdgeHeadTailLabels(boundingBox, port.getOutgoingEdges(), port.getIncomingEdges(), node, port, requiredPortLabelSpace, labelSpacing);
    }
  }
  this$static.includeEdgeHeadTailLabels && $processEdgeHeadTailLabels(boundingBox, node.getOutgoingEdges(), node.getIncomingEdges(), node, null, null, labelSpacing);
  margin = new ElkMargin_2(node.getMargin());
  margin.top_0 = node.getPosition().y_0 - boundingBox.y_0;
  margin.bottom = boundingBox.y_0 + boundingBox.height - (node.getPosition().y_0 + node.getSize().y_0);
  margin.left = node.getPosition().x_0 - boundingBox.x_0;
  margin.right = boundingBox.x_0 + boundingBox.width_0 - (node.getPosition().x_0 + node.getSize().x_0);
  node.setMargin(margin);
}

function NodeMarginCalculator(adapter){
  this.adapter = adapter;
}

defineClass(522, 1, {}, NodeMarginCalculator);
_.includeEdgeHeadTailLabels = true;
_.includeLabels = true;
_.includePortLabels = true;
_.includePorts = true;
var Lorg_eclipse_elk_alg_common_nodespacing_NodeMarginCalculator_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing', 'NodeMarginCalculator', 522);
function $setContributesToMinimumHeight(this$static, contributesToMinimumHeight){
  this$static.contributesToMinimumHeight = contributesToMinimumHeight;
}

function Cell(){
  this.padding = new ElkPadding;
  this.cellRectangle = new ElkRectangle;
}

defineClass(175, 1, {175:1});
_.contributesToMinimumHeight = false;
_.contributesToMinimumWidth = false;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_Cell_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'Cell', 175);
function $getMinimumHeight(this$static){
  var padding;
  padding = this$static.padding;
  return this$static.minimumContentAreaSize.y_0 + padding.top_0 + padding.bottom;
}

function AtomicCell(){
  Cell.call(this);
  this.minimumContentAreaSize = new KVector;
}

defineClass(117, 175, {117:1, 175:1}, AtomicCell);
_.getMinimumHeight = function getMinimumHeight(){
  return $getMinimumHeight(this);
}
;
_.getMinimumWidth = function getMinimumWidth(){
  var padding;
  padding = this.padding;
  return this.minimumContentAreaSize.x_0 + padding.left + padding.right;
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_AtomicCell_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'AtomicCell', 117);
function $clinit_ContainerArea(){
  $clinit_ContainerArea = emptyMethod;
  BEGIN = new ContainerArea('BEGIN', 0);
  CENTER = new ContainerArea('CENTER', 1);
  END = new ContainerArea('END', 2);
}

function ContainerArea(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_17(name_0){
  $clinit_ContainerArea();
  return valueOf(($clinit_ContainerArea$Map() , $MAP_5), name_0);
}

function values_13(){
  $clinit_ContainerArea();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END]);
}

defineClass(211, 22, {3:1, 34:1, 22:1, 211:1}, ContainerArea);
var BEGIN, CENTER, END;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit = createForEnum('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'ContainerArea', 211, Ljava_lang_Enum_2_classLit, values_13, valueOf_17);
function $clinit_ContainerArea$Map(){
  $clinit_ContainerArea$Map = emptyMethod;
  $MAP_5 = createValueOfMap(($clinit_ContainerArea() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END])));
}

var $MAP_5;
function $applyHorizontalLayout(cell, x_0, width_0){
  var cellRect;
  if (cell) {
    cellRect = cell.cellRectangle;
    cellRect.x_0 = x_0;
    cellRect.width_0 = width_0;
  }
}

function $applyVerticalLayout(cell, y_0, height){
  var cellRect;
  if (cell) {
    cellRect = cell.cellRectangle;
    cellRect.y_0 = y_0;
    cellRect.height = height;
  }
}

function ContainerCell(){
  Cell.call(this);
}

function minHeightOfCell(cell, respectContributionFlag){
  if (!cell) {
    return 0;
  }
  if (respectContributionFlag && !cell.contributesToMinimumHeight) {
    return 0;
  }
  if (instanceOf(cell, 117)) {
    if (castTo(cell, 117).minimumContentAreaSize.y_0 == 0) {
      return 0;
    }
  }
  return cell.getMinimumHeight();
}

function minWidthOfCell(cell, respectContributionFlag){
  if (!cell) {
    return 0;
  }
  if (respectContributionFlag && !cell.contributesToMinimumWidth) {
    return 0;
  }
  if (instanceOf(cell, 117)) {
    if (castTo(cell, 117).minimumContentAreaSize.x_0 == 0) {
      return 0;
    }
  }
  return cell.getMinimumWidth();
}

defineClass(314, 175, $intern_94);
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerCell_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'ContainerCell', 314);
function $clinit_GridContainerCell(){
  $clinit_GridContainerCell = emptyMethod;
  ROWS = ($clinit_ContainerArea() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END])).length;
  COLUMNS = ROWS;
}

function $applyHeightToRow(this$static, row, y_0, rowHeights){
  var column;
  for (column = 0; column < COLUMNS; column++) {
    $applyVerticalLayout(this$static.cells_0[row.ordinal][column], y_0, rowHeights[row.ordinal]);
  }
}

function $applyWidthToColumn(this$static, column, x_0, colWidths){
  var row;
  for (row = 0; row < ROWS; row++) {
    $applyHorizontalLayout(this$static.cells_0[row][column.ordinal], x_0, colWidths[column.ordinal]);
  }
}

function $applyWidthsToRow(this$static, row, colWidths){
  var cellPadding, cellRectangle, centerWidth, freeContentAreaWidth;
  cellRectangle = this$static.cellRectangle;
  cellPadding = this$static.padding;
  $applyWidthToColumn(this$static, ($clinit_ContainerArea() , BEGIN), cellRectangle.x_0 + cellPadding.left, colWidths);
  $applyWidthToColumn(this$static, END, cellRectangle.x_0 + cellRectangle.width_0 - cellPadding.right - colWidths[2], colWidths);
  freeContentAreaWidth = cellRectangle.width_0 - cellPadding.left - cellPadding.right;
  if (colWidths[0] > 0) {
    colWidths[0] += this$static.gap;
    freeContentAreaWidth -= colWidths[0];
  }
  if (colWidths[2] > 0) {
    colWidths[2] += this$static.gap;
    freeContentAreaWidth -= colWidths[2];
  }
  centerWidth = $wnd.Math.max(0, freeContentAreaWidth);
  colWidths[1] = $wnd.Math.max(colWidths[1], freeContentAreaWidth);
  $applyWidthToColumn(this$static, CENTER, cellRectangle.x_0 + cellPadding.left + colWidths[0] - (colWidths[1] - freeContentAreaWidth) / 2, colWidths);
  if (row == CENTER) {
    this$static.centerCellRect.width_0 = centerWidth;
    this$static.centerCellRect.x_0 = cellRectangle.x_0 + cellPadding.left + (centerWidth - freeContentAreaWidth) / 2;
  }
}

function $getCell(this$static, row, col){
  return this$static.cells_0[row.ordinal][col.ordinal];
}

function $minColumnWidths(this$static, row, respectContributionFlag){
  var colWidths;
  colWidths = stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [$minWidthOfColumn(this$static, ($clinit_ContainerArea() , BEGIN), row, respectContributionFlag), $minWidthOfColumn(this$static, CENTER, row, respectContributionFlag), $minWidthOfColumn(this$static, END, row, respectContributionFlag)]);
  if (this$static.symmetrical) {
    colWidths[0] = $wnd.Math.max(colWidths[0], colWidths[2]);
    colWidths[2] = colWidths[0];
  }
  return colWidths;
}

function $minHeightOfRow(this$static, row, respectContributionFlag){
  var column, maxMinHeight;
  maxMinHeight = 0;
  for (column = 0; column < COLUMNS; column++) {
    maxMinHeight = $wnd.Math.max(maxMinHeight, minHeightOfCell(this$static.cells_0[row.ordinal][column], respectContributionFlag));
  }
  row == ($clinit_ContainerArea() , CENTER) && !!this$static.centerCellMinimumSize && (maxMinHeight = $wnd.Math.max(maxMinHeight, this$static.centerCellMinimumSize.y_0));
  return maxMinHeight;
}

function $minRowHeights(this$static, respectContributionFlag){
  var rowHeights;
  rowHeights = stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [$minHeightOfRow(this$static, ($clinit_ContainerArea() , BEGIN), respectContributionFlag), $minHeightOfRow(this$static, CENTER, respectContributionFlag), $minHeightOfRow(this$static, END, respectContributionFlag)]);
  if (this$static.symmetrical) {
    rowHeights[0] = $wnd.Math.max(rowHeights[0], rowHeights[2]);
    rowHeights[2] = rowHeights[0];
  }
  return rowHeights;
}

function $minWidthOfColumn(this$static, column, row, respectContributionFlag){
  var maxMinWidth, rowIndex;
  maxMinWidth = 0;
  if (!row) {
    for (rowIndex = 0; rowIndex < ROWS; rowIndex++) {
      maxMinWidth = $wnd.Math.max(maxMinWidth, minWidthOfCell(this$static.cells_0[rowIndex][column.ordinal], respectContributionFlag));
    }
  }
   else {
    maxMinWidth = minWidthOfCell(this$static.cells_0[row.ordinal][column.ordinal], respectContributionFlag);
  }
  column == ($clinit_ContainerArea() , CENTER) && !!this$static.centerCellMinimumSize && (maxMinWidth = $wnd.Math.max(maxMinWidth, this$static.centerCellMinimumSize.x_0));
  return maxMinWidth;
}

function $setCell(this$static, row, col, cell){
  setCheck(this$static.cells_0[row.ordinal], col.ordinal, cell);
}

function $setCenterCellMinimumSize(this$static, minimumSize){
  this$static.centerCellMinimumSize = new KVector_2(minimumSize);
}

function $sumWithGaps(this$static, values){
  var activeComponents, sum, val, val$index, val$max;
  sum = 0;
  activeComponents = 0;
  for (val$index = 0 , val$max = values.length; val$index < val$max; ++val$index) {
    val = values[val$index];
    if (val > 0) {
      sum += val;
      ++activeComponents;
    }
  }
  activeComponents > 1 && (sum += this$static.gap * (activeComponents - 1));
  return sum;
}

function GridContainerCell(tabular, symmetrical, gap){
  $clinit_GridContainerCell();
  ContainerCell.call(this);
  this.cells_0 = initMultidimensionalArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_Cell_2_classLit, [$intern_33, $intern_95], [562, 175], 0, [ROWS, COLUMNS], 2);
  this.centerCellRect = new ElkRectangle;
  this.tabular = tabular;
  this.symmetrical = symmetrical;
  this.gap = gap;
}

defineClass(1351, 314, $intern_94, GridContainerCell);
_.getMinimumHeight = function getMinimumHeight_0(){
  var height;
  height = 0;
  this.onlyCenterCellContributesToMinimumSize?this.centerCellMinimumSize?(height = this.centerCellMinimumSize.y_0):!!this.cells_0[1][1] && (height = this.cells_0[1][1].getMinimumHeight()):(height = $sumWithGaps(this, $minRowHeights(this, true)));
  return height > 0?height + this.padding.top_0 + this.padding.bottom:0;
}
;
_.getMinimumWidth = function getMinimumWidth_0(){
  var area, area$array, area$index, area$max, width_0;
  width_0 = 0;
  if (this.onlyCenterCellContributesToMinimumSize) {
    this.centerCellMinimumSize?(width_0 = this.centerCellMinimumSize.x_0):!!this.cells_0[1][1] && (width_0 = this.cells_0[1][1].getMinimumWidth());
  }
   else if (this.tabular) {
    width_0 = $sumWithGaps(this, $minColumnWidths(this, null, true));
  }
   else {
    for (area$array = ($clinit_ContainerArea() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END])) , area$index = 0 , area$max = area$array.length; area$index < area$max; ++area$index) {
      area = area$array[area$index];
      width_0 = $wnd.Math.max(width_0, $sumWithGaps(this, $minColumnWidths(this, area, true)));
    }
  }
  return width_0 > 0?width_0 + this.padding.left + this.padding.right:0;
}
;
_.layoutChildrenHorizontally = function layoutChildrenHorizontally(){
  var colWidths, row, row$array, row$index, row$max;
  if (this.tabular) {
    colWidths = $minColumnWidths(this, null, false);
    for (row$array = ($clinit_ContainerArea() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END])) , row$index = 0 , row$max = row$array.length; row$index < row$max; ++row$index) {
      row = row$array[row$index];
      $applyWidthsToRow(this, row, colWidths);
    }
  }
   else {
    for (row$array = ($clinit_ContainerArea() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END])) , row$index = 0 , row$max = row$array.length; row$index < row$max; ++row$index) {
      row = row$array[row$index];
      colWidths = $minColumnWidths(this, row, false);
      $applyWidthsToRow(this, row, colWidths);
    }
  }
}
;
_.layoutChildrenVertically = function layoutChildrenVertically(){
  var cellPadding, cellRectangle, freeContentAreaHeight, rowHeights;
  cellRectangle = this.cellRectangle;
  cellPadding = this.padding;
  rowHeights = $minRowHeights(this, false);
  $applyHeightToRow(this, ($clinit_ContainerArea() , BEGIN), cellRectangle.y_0 + cellPadding.top_0, rowHeights);
  $applyHeightToRow(this, END, cellRectangle.y_0 + cellRectangle.height - cellPadding.bottom - rowHeights[2], rowHeights);
  freeContentAreaHeight = cellRectangle.height - cellPadding.top_0 - cellPadding.bottom;
  if (rowHeights[0] > 0) {
    rowHeights[0] += this.gap;
    freeContentAreaHeight -= rowHeights[0];
  }
  if (rowHeights[2] > 0) {
    rowHeights[2] += this.gap;
    freeContentAreaHeight -= rowHeights[2];
  }
  this.centerCellRect.height = $wnd.Math.max(0, freeContentAreaHeight);
  this.centerCellRect.y_0 = cellRectangle.y_0 + cellPadding.top_0 + (this.centerCellRect.height - freeContentAreaHeight) / 2;
  rowHeights[1] = $wnd.Math.max(rowHeights[1], freeContentAreaHeight);
  $applyHeightToRow(this, CENTER, cellRectangle.y_0 + cellPadding.top_0 + rowHeights[0] - (rowHeights[1] - freeContentAreaHeight) / 2, rowHeights);
}
;
_.centerCellMinimumSize = null;
_.gap = 0;
_.onlyCenterCellContributesToMinimumSize = false;
_.symmetrical = false;
_.tabular = false;
var COLUMNS = 0, ROWS = 0;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_GridContainerCell_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'GridContainerCell', 1351);
function $clinit_HorizontalLabelAlignment(){
  $clinit_HorizontalLabelAlignment = emptyMethod;
  LEFT = new HorizontalLabelAlignment('LEFT', 0);
  CENTER_0 = new HorizontalLabelAlignment('CENTER', 1);
  RIGHT = new HorizontalLabelAlignment('RIGHT', 2);
}

function HorizontalLabelAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_18(name_0){
  $clinit_HorizontalLabelAlignment();
  return valueOf(($clinit_HorizontalLabelAlignment$Map() , $MAP_6), name_0);
}

function values_14(){
  $clinit_HorizontalLabelAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_HorizontalLabelAlignment_2_classLit, 1), $intern_38, 437, 0, [LEFT, CENTER_0, RIGHT]);
}

defineClass(437, 22, {3:1, 34:1, 22:1, 437:1}, HorizontalLabelAlignment);
var CENTER_0, LEFT, RIGHT;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_HorizontalLabelAlignment_2_classLit = createForEnum('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'HorizontalLabelAlignment', 437, Ljava_lang_Enum_2_classLit, values_14, valueOf_18);
function $clinit_HorizontalLabelAlignment$Map(){
  $clinit_HorizontalLabelAlignment$Map = emptyMethod;
  $MAP_6 = createValueOfMap(($clinit_HorizontalLabelAlignment() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_HorizontalLabelAlignment_2_classLit, 1), $intern_38, 437, 0, [LEFT, CENTER_0, RIGHT])));
}

var $MAP_6;
function $$init_5(this$static){
  this$static.horizontalAlignment = ($clinit_HorizontalLabelAlignment() , CENTER_0);
  this$static.verticalAlignment = ($clinit_VerticalLabelAlignment() , CENTER_1);
  this$static.labels = (checkNonnegative(2, 'initialArraySize') , new ArrayList_0(2));
  this$static.minimumContentAreaSize = new KVector;
}

function $addLabel(this$static, label_0){
  var labelSize;
  $add_4(this$static.labels, label_0);
  labelSize = label_0.getSize();
  if (this$static.horizontalLayoutMode) {
    this$static.minimumContentAreaSize.x_0 = $wnd.Math.max(this$static.minimumContentAreaSize.x_0, labelSize.x_0);
    this$static.minimumContentAreaSize.y_0 += labelSize.y_0;
    this$static.labels.array.length > 1 && (this$static.minimumContentAreaSize.y_0 += this$static.gap);
  }
   else {
    this$static.minimumContentAreaSize.x_0 += labelSize.x_0;
    this$static.minimumContentAreaSize.y_0 = $wnd.Math.max(this$static.minimumContentAreaSize.y_0, labelSize.y_0);
    this$static.labels.array.length > 1 && (this$static.minimumContentAreaSize.x_0 += this$static.gap);
  }
}

function $applyHorizontalModeLabelLayout(this$static){
  var cellPadding, cellRect, label_0, label$iterator, labelPos, labelSize, yPos;
  cellRect = this$static.cellRectangle;
  cellPadding = this$static.padding;
  yPos = cellRect.y_0;
  this$static.verticalAlignment == ($clinit_VerticalLabelAlignment() , CENTER_1)?(yPos += (cellRect.height - this$static.minimumContentAreaSize.y_0) / 2):this$static.verticalAlignment == BOTTOM && (yPos += cellRect.height - this$static.minimumContentAreaSize.y_0);
  for (label$iterator = new ArrayList$1(this$static.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 281);
    labelSize = label_0.getSize();
    labelPos = new KVector;
    labelPos.y_0 = yPos;
    yPos += labelSize.y_0 + this$static.gap;
    switch (this$static.horizontalAlignment.ordinal) {
      case 0:
        labelPos.x_0 = cellRect.x_0 + cellPadding.left;
        break;
      case 1:
        labelPos.x_0 = cellRect.x_0 + cellPadding.left + (cellRect.width_0 - labelSize.x_0) / 2;
        break;
      case 2:
        labelPos.x_0 = cellRect.x_0 + cellRect.width_0 - cellPadding.right - labelSize.x_0;
    }
    label_0.setPosition(labelPos);
  }
}

function $applyLabelLayout(this$static){
  this$static.horizontalLayoutMode?$applyHorizontalModeLabelLayout(this$static):$applyVerticalModeLabelLayout(this$static);
}

function $applyVerticalModeLabelLayout(this$static){
  var cellPadding, cellRect, label_0, label$iterator, labelPos, labelSize, xPos;
  cellRect = this$static.cellRectangle;
  cellPadding = this$static.padding;
  xPos = cellRect.x_0;
  this$static.horizontalAlignment == ($clinit_HorizontalLabelAlignment() , CENTER_0)?(xPos += (cellRect.width_0 - this$static.minimumContentAreaSize.x_0) / 2):this$static.horizontalAlignment == RIGHT && (xPos += cellRect.width_0 - this$static.minimumContentAreaSize.x_0);
  for (label$iterator = new ArrayList$1(this$static.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 281);
    labelSize = label_0.getSize();
    labelPos = new KVector;
    labelPos.x_0 = xPos;
    xPos += labelSize.x_0 + this$static.gap;
    switch (this$static.verticalAlignment.ordinal) {
      case 0:
        labelPos.y_0 = cellRect.y_0 + cellPadding.top_0;
        break;
      case 1:
        labelPos.y_0 = cellRect.y_0 + cellPadding.top_0 + (cellRect.height - labelSize.y_0) / 2;
        break;
      case 2:
        labelPos.y_0 = cellRect.y_0 + cellRect.height - cellPadding.bottom - labelSize.y_0;
    }
    label_0.setPosition(labelPos);
  }
}

function $getMinimumHeight_0(this$static){
  var padding;
  padding = this$static.padding;
  return this$static.minimumContentAreaSize.y_0 + padding.top_0 + padding.bottom;
}

function $getMinimumWidth(this$static){
  var padding;
  padding = this$static.padding;
  return this$static.minimumContentAreaSize.x_0 + padding.left + padding.right;
}

function $setHorizontalAlignment(this$static, newHorizontalAlignment){
  requireNonNull(newHorizontalAlignment, 'Horizontal alignment cannot be null');
  this$static.horizontalAlignment = newHorizontalAlignment;
  return this$static;
}

function $setVerticalAlignment(this$static, newVerticalAlignment){
  requireNonNull(newVerticalAlignment, 'Vertical alignment cannot be null');
  this$static.verticalAlignment = newVerticalAlignment;
  return this$static;
}

function LabelCell(gap){
  Cell.call(this);
  $$init_5(this);
  this.gap = gap;
  this.horizontalLayoutMode = true;
}

function LabelCell_0(gap, nodeLabelLocation){
  Cell.call(this);
  $$init_5(this);
  this.gap = gap;
  this.horizontalLayoutMode = true;
  this.horizontalAlignment = nodeLabelLocation.horizontalAlignment;
  this.verticalAlignment = nodeLabelLocation.verticalAlignment;
}

function LabelCell_1(gap, horizontalLayoutMode){
  Cell.call(this);
  $$init_5(this);
  this.gap = gap;
  this.horizontalLayoutMode = horizontalLayoutMode;
}

defineClass(279, 175, {175:1, 279:1}, LabelCell, LabelCell_0, LabelCell_1);
_.getMinimumHeight = function getMinimumHeight_1(){
  return $getMinimumHeight_0(this);
}
;
_.getMinimumWidth = function getMinimumWidth_1(){
  return $getMinimumWidth(this);
}
;
_.gap = 0;
_.horizontalLayoutMode = false;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_LabelCell_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'LabelCell', 279);
function $getMinimumHeight_1(this$static){
  var activeCells, cellHeight, cellHeight$index, cellHeight$max, cellHeights, height;
  height = 0;
  if (this$static.containerMode == 0) {
    cellHeights = $minCellHeights(this$static, true);
    activeCells = 0;
    for (cellHeight$index = 0 , cellHeight$max = cellHeights.length; cellHeight$index < cellHeight$max; ++cellHeight$index) {
      cellHeight = cellHeights[cellHeight$index];
      if (cellHeight > 0) {
        height += cellHeight;
        ++activeCells;
      }
    }
    activeCells > 1 && (height += this$static.gap * (activeCells - 1));
  }
   else {
    height = $orElse($max($mapToDouble($filter(stream_1(this$static.cells_0), new StripContainerCell$lambda$2$Type), new StripContainerCell$lambda$3$Type)));
  }
  return height > 0?height + this$static.padding.top_0 + this$static.padding.bottom:0;
}

function $getMinimumWidth_0(this$static){
  var activeCells, cellWidth, cellWidth$index, cellWidth$max, cellWidths, width_0;
  width_0 = 0;
  if (this$static.containerMode == 0) {
    width_0 = $orElse($max($mapToDouble($filter(stream_1(this$static.cells_0), new StripContainerCell$lambda$0$Type), new StripContainerCell$lambda$1$Type)));
  }
   else {
    cellWidths = $minCellWidths(this$static, true);
    activeCells = 0;
    for (cellWidth$index = 0 , cellWidth$max = cellWidths.length; cellWidth$index < cellWidth$max; ++cellWidth$index) {
      cellWidth = cellWidths[cellWidth$index];
      if (cellWidth > 0) {
        width_0 += cellWidth;
        ++activeCells;
      }
    }
    activeCells > 1 && (width_0 += this$static.gap * (activeCells - 1));
  }
  return width_0 > 0?width_0 + this$static.padding.left + this$static.padding.right:0;
}

function $layoutChildrenHorizontally(this$static){
  var cellPadding, cellRectangle, cellWidths, childCell, childCell$array, childCell$array0, childCell$index, childCell$index0, childCell$max, childCell$max0, freeContentAreaWidth, width_0, xPos;
  cellRectangle = this$static.cellRectangle;
  cellPadding = this$static.padding;
  if (this$static.containerMode == 0) {
    xPos = cellRectangle.x_0 + cellPadding.left;
    width_0 = cellRectangle.width_0 - cellPadding.left - cellPadding.right;
    for (childCell$array0 = this$static.cells_0 , childCell$index0 = 0 , childCell$max0 = childCell$array0.length; childCell$index0 < childCell$max0; ++childCell$index0) {
      childCell = childCell$array0[childCell$index0];
      $applyHorizontalLayout(childCell, xPos, width_0);
    }
  }
   else {
    cellWidths = $minCellWidths(this$static, false);
    $applyHorizontalLayout(this$static.cells_0[0], cellRectangle.x_0 + cellPadding.left, cellWidths[0]);
    $applyHorizontalLayout(this$static.cells_0[2], cellRectangle.x_0 + cellRectangle.width_0 - cellPadding.right - cellWidths[2], cellWidths[2]);
    freeContentAreaWidth = cellRectangle.width_0 - cellPadding.left - cellPadding.right;
    if (cellWidths[0] > 0) {
      freeContentAreaWidth -= cellWidths[0] + this$static.gap;
      cellWidths[0] += this$static.gap;
    }
    cellWidths[2] > 0 && (freeContentAreaWidth -= cellWidths[2] + this$static.gap);
    cellWidths[1] = $wnd.Math.max(cellWidths[1], freeContentAreaWidth);
    $applyHorizontalLayout(this$static.cells_0[1], cellRectangle.x_0 + cellPadding.left + cellWidths[0] - (cellWidths[1] - freeContentAreaWidth) / 2, cellWidths[1]);
  }
  for (childCell$array = this$static.cells_0 , childCell$index = 0 , childCell$max = childCell$array.length; childCell$index < childCell$max; ++childCell$index) {
    childCell = childCell$array[childCell$index];
    instanceOf(childCell, 314) && castTo(childCell, 314).layoutChildrenHorizontally();
  }
}

function $layoutChildrenVertically(this$static){
  var cellHeights, cellPadding, cellRectangle, childCell, childCell$array, childCell$array0, childCell$index, childCell$index0, childCell$max, childCell$max0, contentAreaFreeHeight, contentAreaHeight, height, yPos;
  cellRectangle = this$static.cellRectangle;
  cellPadding = this$static.padding;
  if (this$static.containerMode == 0) {
    cellHeights = $minCellHeights(this$static, false);
    $applyVerticalLayout(this$static.cells_0[0], cellRectangle.y_0 + cellPadding.top_0, cellHeights[0]);
    $applyVerticalLayout(this$static.cells_0[2], cellRectangle.y_0 + cellRectangle.height - cellPadding.bottom - cellHeights[2], cellHeights[2]);
    contentAreaHeight = cellRectangle.height - cellPadding.top_0 - cellPadding.bottom;
    contentAreaFreeHeight = contentAreaHeight;
    if (cellHeights[0] > 0) {
      cellHeights[0] += this$static.gap;
      contentAreaFreeHeight -= cellHeights[0];
    }
    cellHeights[2] > 0 && (contentAreaFreeHeight -= cellHeights[2] + this$static.gap);
    cellHeights[1] = $wnd.Math.max(cellHeights[1], contentAreaFreeHeight);
    $applyVerticalLayout(this$static.cells_0[1], cellRectangle.y_0 + cellPadding.top_0 + cellHeights[0] - (cellHeights[1] - contentAreaFreeHeight) / 2, cellHeights[1]);
  }
   else {
    yPos = cellRectangle.y_0 + cellPadding.top_0;
    height = cellRectangle.height - cellPadding.top_0 - cellPadding.bottom;
    for (childCell$array0 = this$static.cells_0 , childCell$index0 = 0 , childCell$max0 = childCell$array0.length; childCell$index0 < childCell$max0; ++childCell$index0) {
      childCell = childCell$array0[childCell$index0];
      $applyVerticalLayout(childCell, yPos, height);
    }
  }
  for (childCell$array = this$static.cells_0 , childCell$index = 0 , childCell$max = childCell$array.length; childCell$index < childCell$max; ++childCell$index) {
    childCell = childCell$array[childCell$index];
    instanceOf(childCell, 314) && castTo(childCell, 314).layoutChildrenVertically();
  }
}

function $minCellHeights(this$static, respectContributionFlag){
  var cellHeights;
  cellHeights = stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [minHeightOfCell(this$static.cells_0[0], respectContributionFlag), minHeightOfCell(this$static.cells_0[1], respectContributionFlag), minHeightOfCell(this$static.cells_0[2], respectContributionFlag)]);
  if (this$static.symmetrical) {
    cellHeights[0] = $wnd.Math.max(cellHeights[0], cellHeights[2]);
    cellHeights[2] = cellHeights[0];
  }
  return cellHeights;
}

function $minCellWidths(this$static, respectContributionFlag){
  var cellWidths;
  cellWidths = stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [minWidthOfCell(this$static.cells_0[0], respectContributionFlag), minWidthOfCell(this$static.cells_0[1], respectContributionFlag), minWidthOfCell(this$static.cells_0[2], respectContributionFlag)]);
  if (this$static.symmetrical) {
    cellWidths[0] = $wnd.Math.max(cellWidths[0], cellWidths[2]);
    cellWidths[2] = cellWidths[0];
  }
  return cellWidths;
}

function $setCell_0(this$static, area, cell){
  this$static.cells_0[area.ordinal] = cell;
}

function StripContainerCell(mode, symmetrical, gap){
  ContainerCell.call(this);
  this.cells_0 = initUnidimensionalArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_Cell_2_classLit, $intern_95, 175, ($clinit_ContainerArea() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_ContainerArea_2_classLit, 1), $intern_38, 211, 0, [BEGIN, CENTER, END])).length, 0, 1);
  this.containerMode = mode;
  this.symmetrical = symmetrical;
  this.gap = gap;
}

defineClass(226, 314, {175:1, 314:1, 226:1}, StripContainerCell);
_.getMinimumHeight = function getMinimumHeight_2(){
  return $getMinimumHeight_1(this);
}
;
_.getMinimumWidth = function getMinimumWidth_2(){
  return $getMinimumWidth_0(this);
}
;
_.layoutChildrenHorizontally = function layoutChildrenHorizontally_0(){
  $layoutChildrenHorizontally(this);
}
;
_.layoutChildrenVertically = function layoutChildrenVertically_0(){
  $layoutChildrenVertically(this);
}
;
_.containerMode = 0;
_.gap = 0;
_.symmetrical = false;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_StripContainerCell_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'StripContainerCell', 226);
function StripContainerCell$lambda$0$Type(){
}

defineClass(1473, 1, $intern_90, StripContainerCell$lambda$0$Type);
_.test_0 = function test_5(arg0){
  return !!castTo(arg0, 175) && castTo(arg0, 175).contributesToMinimumWidth;
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_StripContainerCell$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'StripContainerCell/lambda$0$Type', 1473);
function StripContainerCell$lambda$1$Type(){
}

defineClass(1474, 1, {}, StripContainerCell$lambda$1$Type);
_.applyAsDouble = function applyAsDouble(arg0){
  return castTo(arg0, 175).getMinimumWidth();
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_StripContainerCell$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'StripContainerCell/lambda$1$Type', 1474);
function StripContainerCell$lambda$2$Type(){
}

defineClass(1475, 1, $intern_90, StripContainerCell$lambda$2$Type);
_.test_0 = function test_6(arg0){
  return !!castTo(arg0, 175) && castTo(arg0, 175).contributesToMinimumHeight;
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_StripContainerCell$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'StripContainerCell/lambda$2$Type', 1475);
function StripContainerCell$lambda$3$Type(){
}

defineClass(1476, 1, {}, StripContainerCell$lambda$3$Type);
_.applyAsDouble = function applyAsDouble_0(arg0){
  return castTo(arg0, 175).getMinimumHeight();
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_StripContainerCell$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'StripContainerCell/lambda$3$Type', 1476);
function $clinit_VerticalLabelAlignment(){
  $clinit_VerticalLabelAlignment = emptyMethod;
  TOP = new VerticalLabelAlignment('TOP', 0);
  CENTER_1 = new VerticalLabelAlignment('CENTER', 1);
  BOTTOM = new VerticalLabelAlignment('BOTTOM', 2);
}

function VerticalLabelAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_19(name_0){
  $clinit_VerticalLabelAlignment();
  return valueOf(($clinit_VerticalLabelAlignment$Map() , $MAP_7), name_0);
}

function values_15(){
  $clinit_VerticalLabelAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_VerticalLabelAlignment_2_classLit, 1), $intern_38, 438, 0, [TOP, CENTER_1, BOTTOM]);
}

defineClass(438, 22, {3:1, 34:1, 22:1, 438:1}, VerticalLabelAlignment);
var BOTTOM, CENTER_1, TOP;
var Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_VerticalLabelAlignment_2_classLit = createForEnum('org.eclipse.elk.alg.common.nodespacing.cellsystem', 'VerticalLabelAlignment', 438, Ljava_lang_Enum_2_classLit, values_15, valueOf_19);
function $clinit_VerticalLabelAlignment$Map(){
  $clinit_VerticalLabelAlignment$Map = emptyMethod;
  $MAP_7 = createValueOfMap(($clinit_VerticalLabelAlignment() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_VerticalLabelAlignment_2_classLit, 1), $intern_38, 438, 0, [TOP, CENTER_1, BOTTOM])));
}

var $MAP_7;
function $getPortAlignment(this$static, portSide){
  var alignment;
  alignment = null;
  switch (portSide.ordinal) {
    case 1:
      this$static.node.hasProperty(($clinit_CoreOptions() , PORT_ALIGNMENT_NORTH_0)) && (alignment = castTo(this$static.node.getProperty(PORT_ALIGNMENT_NORTH_0), 235));
      break;
    case 3:
      this$static.node.hasProperty(($clinit_CoreOptions() , PORT_ALIGNMENT_SOUTH_0)) && (alignment = castTo(this$static.node.getProperty(PORT_ALIGNMENT_SOUTH_0), 235));
      break;
    case 2:
      this$static.node.hasProperty(($clinit_CoreOptions() , PORT_ALIGNMENT_EAST_0)) && (alignment = castTo(this$static.node.getProperty(PORT_ALIGNMENT_EAST_0), 235));
      break;
    case 4:
      this$static.node.hasProperty(($clinit_CoreOptions() , PORT_ALIGNMENT_WEST_0)) && (alignment = castTo(this$static.node.getProperty(PORT_ALIGNMENT_WEST_0), 235));
  }
  !alignment && (alignment = castTo(this$static.node.getProperty(($clinit_CoreOptions() , PORT_ALIGNMENT_DEFAULT)), 235));
  return alignment;
}

function NodeContext(node){
  var symmetry;
  this.portContexts = create_0(new NodeContext$0methodref$comparePortSides$Type, new NodeContext$1methodref$comparePortContexts$Type);
  this.insidePortLabelCells = ($clinit_Maps() , new EnumMap(castTo(checkNotNull(Lorg_eclipse_elk_core_options_PortSide_2_classLit), 283)));
  this.outsideNodeLabelContainers = new EnumMap(castTo(checkNotNull(Lorg_eclipse_elk_core_options_PortSide_2_classLit), 283));
  this.nodeLabelCells = new EnumMap(castTo(checkNotNull(Lorg_eclipse_elk_alg_common_nodespacing_internal_NodeLabelLocation_2_classLit), 283));
  this.node = node;
  this.nodeSize = new KVector_2(node.getSize());
  this.treatAsCompoundNode = node.isCompoundNode() || checkNotNull_1(castToBoolean(node.getProperty(($clinit_CoreOptions() , INSIDE_SELF_LOOPS_ACTIVATE_0))));
  this.sizeConstraints = castTo(node.getProperty(($clinit_CoreOptions() , NODE_SIZE_CONSTRAINTS_1)), 19);
  this.sizeOptions = castTo(node.getProperty(NODE_SIZE_OPTIONS_1), 19);
  this.portConstraints = castTo(node.getProperty(PORT_CONSTRAINTS_1), 83);
  this.portLabelsPlacement = castTo(node.getProperty(PORT_LABELS_PLACEMENT_0), 284);
  this.nodeLabelPlacement = castTo(node.getProperty(NODE_LABELS_PLACEMENT_0), 19);
  this.nodeLabelsPadding = castTo(getIndividualOrInherited(node, NODE_LABELS_PADDING), 116);
  this.nodeLabelSpacing = checkNotNull_1(castToDouble(getIndividualOrInherited(node, SPACING_LABEL_NODE_0)));
  this.labelLabelSpacing = checkNotNull_1(castToDouble(getIndividualOrInherited(node, SPACING_LABEL_LABEL_0)));
  this.portPortSpacing = checkNotNull_1(castToDouble(getIndividualOrInherited(node, SPACING_PORT_PORT_0)));
  this.portLabelSpacing = checkNotNull_1(castToDouble(getIndividualOrInherited(node, SPACING_LABEL_PORT_0)));
  this.surroundingPortMargins = castTo(getIndividualOrInherited(node, SPACING_PORTS_SURROUNDING_0), 137);
  this.labelCellSpacing = 2 * this.labelLabelSpacing;
  symmetry = !this.sizeOptions.contains(($clinit_SizeOptions() , ASYMMETRICAL));
  this.nodeContainer = new StripContainerCell(0, symmetry, 0);
  this.nodeContainerMiddleRow = new StripContainerCell(1, symmetry, 0);
  $setCell_0(this.nodeContainer, ($clinit_ContainerArea() , CENTER), this.nodeContainerMiddleRow);
}

function comparePortContexts(portContext1, portContext2){
  var portSideComparison;
  portSideComparison = comparePortSides(portContext1.port.getSide(), portContext2.port.getSide());
  if (portSideComparison != 0) {
    return portSideComparison;
  }
  switch (portContext1.port.getSide().ordinal) {
    case 1:
    case 2:
      return compare_6(portContext1.port.getVolatileId(), portContext2.port.getVolatileId());
    case 3:
    case 4:
      return compare_6(portContext2.port.getVolatileId(), portContext1.port.getVolatileId());
  }
  return 0;
}

function comparePortSides(portSide1, portSide2){
  return compare_6(portSide1.ordinal, portSide2.ordinal);
}

defineClass(731, 1, {}, NodeContext);
_.labelCellSpacing = 0;
_.labelLabelSpacing = 0;
_.nodeLabelSpacing = 0;
_.portLabelSpacing = 0;
_.portPortSpacing = 0;
_.treatAsCompoundNode = false;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_NodeContext_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal', 'NodeContext', 731);
function NodeContext$0methodref$comparePortSides$Type(){
}

defineClass(1349, 1, $intern_40, NodeContext$0methodref$comparePortSides$Type);
_.equals_0 = function equals_66(other){
  return this === other;
}
;
_.reversed = function reversed_8(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_16(arg0, arg1){
  return comparePortSides(castTo(arg0, 71), castTo(arg1, 71));
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_NodeContext$0methodref$comparePortSides$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal', 'NodeContext/0methodref$comparePortSides$Type', 1349);
function NodeContext$1methodref$comparePortContexts$Type(){
}

defineClass(1350, 1, $intern_40, NodeContext$1methodref$comparePortContexts$Type);
_.equals_0 = function equals_67(other){
  return this === other;
}
;
_.reversed = function reversed_9(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_17(arg0, arg1){
  return comparePortContexts(castTo(arg0, 112), castTo(arg1, 112));
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_NodeContext$1methodref$comparePortContexts$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal', 'NodeContext/1methodref$comparePortContexts$Type', 1350);
function $clinit_NodeLabelLocation(){
  $clinit_NodeLabelLocation = emptyMethod;
  OUT_T_L = new NodeLabelLocation('OUT_T_L', 0, ($clinit_HorizontalLabelAlignment() , LEFT), ($clinit_VerticalLabelAlignment() , BOTTOM), ($clinit_ContainerArea() , BEGIN), BEGIN, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(($clinit_NodeLabelPlacement() , OUTSIDE), stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_LEFT_0]))]));
  OUT_T_C = new NodeLabelLocation('OUT_T_C', 1, CENTER_0, BOTTOM, BEGIN, CENTER, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_CENTER_0])), of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_CENTER_0, H_PRIORITY]))]));
  OUT_T_R = new NodeLabelLocation('OUT_T_R', 2, RIGHT, BOTTOM, BEGIN, END, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_RIGHT_0]))]));
  OUT_B_L = new NodeLabelLocation('OUT_B_L', 3, LEFT, TOP, END, BEGIN, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_LEFT_0]))]));
  OUT_B_C = new NodeLabelLocation('OUT_B_C', 4, CENTER_0, TOP, END, CENTER, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_CENTER_0])), of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_CENTER_0, H_PRIORITY]))]));
  OUT_B_R = new NodeLabelLocation('OUT_B_R', 5, RIGHT, TOP, END, END, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_RIGHT_0]))]));
  OUT_L_T = new NodeLabelLocation('OUT_L_T', 6, RIGHT, TOP, BEGIN, BEGIN, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_LEFT_0, V_TOP_0, H_PRIORITY]))]));
  OUT_L_C = new NodeLabelLocation('OUT_L_C', 7, RIGHT, CENTER_1, CENTER, BEGIN, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_LEFT_0, V_CENTER_0])), of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_LEFT_0, V_CENTER_0, H_PRIORITY]))]));
  OUT_L_B = new NodeLabelLocation('OUT_L_B', 8, RIGHT, BOTTOM, END, BEGIN, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_LEFT_0, V_BOTTOM_0, H_PRIORITY]))]));
  OUT_R_T = new NodeLabelLocation('OUT_R_T', 9, LEFT, TOP, BEGIN, END, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_RIGHT_0, V_TOP_0, H_PRIORITY]))]));
  OUT_R_C = new NodeLabelLocation('OUT_R_C', 10, LEFT, CENTER_1, CENTER, END, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_RIGHT_0, V_CENTER_0])), of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_RIGHT_0, V_CENTER_0, H_PRIORITY]))]));
  OUT_R_B = new NodeLabelLocation('OUT_R_B', 11, LEFT, BOTTOM, END, END, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_RIGHT_0, V_BOTTOM_0, H_PRIORITY]))]));
  IN_T_L = new NodeLabelLocation('IN_T_L', 12, LEFT, TOP, BEGIN, BEGIN, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_LEFT_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_LEFT_0, H_PRIORITY]))]));
  IN_T_C = new NodeLabelLocation('IN_T_C', 13, CENTER_0, TOP, BEGIN, CENTER, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_CENTER_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_CENTER_0, H_PRIORITY]))]));
  IN_T_R = new NodeLabelLocation('IN_T_R', 14, RIGHT, TOP, BEGIN, END, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_RIGHT_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_TOP_0, H_RIGHT_0, H_PRIORITY]))]));
  IN_C_L = new NodeLabelLocation('IN_C_L', 15, LEFT, CENTER_1, CENTER, BEGIN, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_CENTER_0, H_LEFT_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_CENTER_0, H_LEFT_0, H_PRIORITY]))]));
  IN_C_C = new NodeLabelLocation('IN_C_C', 16, CENTER_0, CENTER_1, CENTER, CENTER, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_CENTER_0, H_CENTER_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_CENTER_0, H_CENTER_0, H_PRIORITY]))]));
  IN_C_R = new NodeLabelLocation('IN_C_R', 17, RIGHT, CENTER_1, CENTER, END, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_CENTER_0, H_RIGHT_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_CENTER_0, H_RIGHT_0, H_PRIORITY]))]));
  IN_B_L = new NodeLabelLocation('IN_B_L', 18, LEFT, BOTTOM, END, BEGIN, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_LEFT_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_LEFT_0, H_PRIORITY]))]));
  IN_B_C = new NodeLabelLocation('IN_B_C', 19, CENTER_0, BOTTOM, END, CENTER, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_CENTER_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_CENTER_0, H_PRIORITY]))]));
  IN_B_R = new NodeLabelLocation('IN_B_R', 20, RIGHT, BOTTOM, END, END, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, [of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_RIGHT_0])), of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_BOTTOM_0, H_RIGHT_0, H_PRIORITY]))]));
  UNDEFINED = new NodeLabelLocation('UNDEFINED', 21, null, null, null, null, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_Set_2_classLit, 1), $intern_1, 19, 0, []));
}

function $getOutsideSide(this$static){
  switch (this$static.ordinal) {
    case 0:
    case 1:
    case 2:
      return $clinit_PortSide() , NORTH_1;
    case 3:
    case 4:
    case 5:
      return $clinit_PortSide() , SOUTH_1;
    case 6:
    case 7:
    case 8:
      return $clinit_PortSide() , WEST_1;
    case 9:
    case 10:
    case 11:
      return $clinit_PortSide() , EAST_1;
    default:return $clinit_PortSide() , UNDEFINED_7;
  }
}

function $isInsideLocation(this$static){
  switch (this$static.ordinal) {
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      return true;
    default:return false;
  }
}

function NodeLabelLocation(enum$name, enum$ordinal, horizontalAlignment, verticalAlignment, row, column, assignedPlacements){
  Enum.call(this, enum$name, enum$ordinal);
  this.horizontalAlignment = horizontalAlignment;
  this.verticalAlignment = verticalAlignment;
  this.containerRow = row;
  this.containerColumn = column;
  this.assignedPlacements = newArrayList_1(assignedPlacements);
}

function fromNodeLabelPlacement(labelPlacement){
  $clinit_NodeLabelLocation();
  var location_0, location$array, location$index, location$max;
  for (location$array = values_16() , location$index = 0 , location$max = location$array.length; location$index < location$max; ++location$index) {
    location_0 = location$array[location$index];
    if ($indexOf_3(location_0.assignedPlacements, labelPlacement, 0) != -1) {
      return location_0;
    }
  }
  return UNDEFINED;
}

function valueOf_20(name_0){
  $clinit_NodeLabelLocation();
  return valueOf(($clinit_NodeLabelLocation$Map() , $MAP_8), name_0);
}

function values_16(){
  $clinit_NodeLabelLocation();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_nodespacing_internal_NodeLabelLocation_2_classLit, 1), $intern_38, 150, 0, [OUT_T_L, OUT_T_C, OUT_T_R, OUT_B_L, OUT_B_C, OUT_B_R, OUT_L_T, OUT_L_C, OUT_L_B, OUT_R_T, OUT_R_C, OUT_R_B, IN_T_L, IN_T_C, IN_T_R, IN_C_L, IN_C_C, IN_C_R, IN_B_L, IN_B_C, IN_B_R, UNDEFINED]);
}

defineClass(150, 22, {3:1, 34:1, 22:1, 150:1}, NodeLabelLocation);
var IN_B_C, IN_B_L, IN_B_R, IN_C_C, IN_C_L, IN_C_R, IN_T_C, IN_T_L, IN_T_R, OUT_B_C, OUT_B_L, OUT_B_R, OUT_L_B, OUT_L_C, OUT_L_T, OUT_R_B, OUT_R_C, OUT_R_T, OUT_T_C, OUT_T_L, OUT_T_R, UNDEFINED;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_NodeLabelLocation_2_classLit = createForEnum('org.eclipse.elk.alg.common.nodespacing.internal', 'NodeLabelLocation', 150, Ljava_lang_Enum_2_classLit, values_16, valueOf_20);
function $clinit_NodeLabelLocation$Map(){
  $clinit_NodeLabelLocation$Map = emptyMethod;
  $MAP_8 = createValueOfMap(values_16());
}

var $MAP_8;
function $applyPortPosition(this$static){
  this$static.port.setPosition(this$static.portPosition);
}

function PortContext(parentNodeContext, port){
  this.portMargin = new ElkMargin;
  this.parentNodeContext = parentNodeContext;
  this.port = port;
  this.portPosition = new KVector_2(port.getPosition());
}

defineClass(112, 1, {112:1}, PortContext);
var Lorg_eclipse_elk_alg_common_nodespacing_internal_PortContext_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal', 'PortContext', 112);
function configureCellSystemSizeContributions(nodeContext){
  var freePortPlacement, labelCell, location_0, location$array, location$index, location$max, overhang;
  if (nodeContext.sizeConstraints.isEmpty()) {
    return;
  }
  if (nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , PORTS_0))) {
    castTo($get_10(nodeContext.insidePortLabelCells, ($clinit_PortSide() , NORTH_1)), 117).contributesToMinimumWidth = true;
    castTo($get_10(nodeContext.insidePortLabelCells, SOUTH_1), 117).contributesToMinimumWidth = true;
    freePortPlacement = nodeContext.portConstraints != ($clinit_PortConstraints() , FIXED_RATIO) && nodeContext.portConstraints != FIXED_POS;
    $setContributesToMinimumHeight(castTo($get_10(nodeContext.insidePortLabelCells, EAST_1), 117), freePortPlacement);
    $setContributesToMinimumHeight(castTo($get_10(nodeContext.insidePortLabelCells, WEST_1), 117), freePortPlacement);
    $setContributesToMinimumHeight(nodeContext.nodeContainerMiddleRow, freePortPlacement);
    if (nodeContext.sizeConstraints.contains(PORT_LABELS)) {
      castTo($get_10(nodeContext.insidePortLabelCells, NORTH_1), 117).contributesToMinimumHeight = true;
      castTo($get_10(nodeContext.insidePortLabelCells, SOUTH_1), 117).contributesToMinimumHeight = true;
      castTo($get_10(nodeContext.insidePortLabelCells, EAST_1), 117).contributesToMinimumWidth = true;
      castTo($get_10(nodeContext.insidePortLabelCells, WEST_1), 117).contributesToMinimumWidth = true;
      nodeContext.nodeContainerMiddleRow.contributesToMinimumWidth = true;
    }
  }
  if (nodeContext.sizeConstraints.contains(NODE_LABELS)) {
    nodeContext.insideNodeLabelContainer.contributesToMinimumHeight = true;
    nodeContext.insideNodeLabelContainer.contributesToMinimumWidth = true;
    nodeContext.nodeContainerMiddleRow.contributesToMinimumHeight = true;
    nodeContext.nodeContainerMiddleRow.contributesToMinimumWidth = true;
    overhang = nodeContext.sizeOptions.contains(($clinit_SizeOptions() , OUTSIDE_NODE_LABELS_OVERHANG));
    for (location$array = values_16() , location$index = 0 , location$max = location$array.length; location$index < location$max; ++location$index) {
      location_0 = location$array[location$index];
      labelCell = castTo($get_10(nodeContext.nodeLabelCells, location_0), 279);
      if (labelCell) {
        if ($isInsideLocation(location_0)) {
          labelCell.contributesToMinimumHeight = true;
          labelCell.contributesToMinimumWidth = true;
        }
         else {
          labelCell.contributesToMinimumHeight = !overhang;
          labelCell.contributesToMinimumWidth = !overhang;
        }
      }
    }
  }
  if (nodeContext.sizeConstraints.contains(MINIMUM_SIZE) && nodeContext.sizeOptions.contains(($clinit_SizeOptions() , MINIMUM_SIZE_ACCOUNTS_FOR_PADDING))) {
    nodeContext.nodeContainerMiddleRow.contributesToMinimumHeight = true;
    nodeContext.nodeContainerMiddleRow.contributesToMinimumHeight = true;
    if (!nodeContext.insideNodeLabelContainer.contributesToMinimumHeight) {
      nodeContext.insideNodeLabelContainer.contributesToMinimumHeight = true;
      nodeContext.insideNodeLabelContainer.contributesToMinimumWidth = true;
      nodeContext.insideNodeLabelContainer.onlyCenterCellContributesToMinimumSize = true;
    }
  }
}

function updateVerticalInsidePortLabelCellPadding(nodeContext){
  var bottomBorderOffset, bottomPadding, eastCell, topBorderOffset, topPadding, westCell;
  if (nodeContext.portConstraints == ($clinit_PortConstraints() , FIXED_RATIO) || nodeContext.portConstraints == FIXED_POS) {
    return;
  }
  topBorderOffset = nodeContext.nodeContainer.padding.top_0 + $getMinimumHeight(castTo($get_10(nodeContext.insidePortLabelCells, ($clinit_PortSide() , NORTH_1)), 117)) + nodeContext.labelCellSpacing;
  bottomBorderOffset = nodeContext.nodeContainer.padding.bottom + $getMinimumHeight(castTo($get_10(nodeContext.insidePortLabelCells, SOUTH_1), 117)) + nodeContext.labelCellSpacing;
  eastCell = castTo($get_10(nodeContext.insidePortLabelCells, EAST_1), 117);
  westCell = castTo($get_10(nodeContext.insidePortLabelCells, WEST_1), 117);
  topPadding = $wnd.Math.max(0, eastCell.padding.top_0 - topBorderOffset);
  topPadding = $wnd.Math.max(topPadding, westCell.padding.top_0 - topBorderOffset);
  bottomPadding = $wnd.Math.max(0, eastCell.padding.bottom - bottomBorderOffset);
  bottomPadding = $wnd.Math.max(bottomPadding, westCell.padding.bottom - bottomBorderOffset);
  eastCell.padding.top_0 = topPadding;
  westCell.padding.top_0 = topPadding;
  eastCell.padding.bottom = bottomPadding;
  westCell.padding.bottom = bottomPadding;
}

function calculateHorizontalNodeSizeRequiredByFixedPosPorts(nodeContext, portSide){
  var cell, portContext, portContext$iterator, rightmostPortBorder;
  rightmostPortBorder = 0;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    rightmostPortBorder = $wnd.Math.max(rightmostPortBorder, portContext.portPosition.x_0 + portContext.port.getSize().x_0);
  }
  cell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  cell.padding.left = 0;
  cell.minimumContentAreaSize.x_0 = rightmostPortBorder;
}

function calculateHorizontalNodeSizeRequiredByFixedRatioPorts(nodeContext, portSide){
  var cell, currentPortContext, currentPortRatio, currentPortWidth, includePortLabels, minWidth, portContextIterator, portContexts, portLabelsInside, previousPortContext, previousPortRatio, previousPortWidth, requiredSpace, spaceEfficientPortLabels;
  cell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  portContexts = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62);
  if (portContexts.isEmpty()) {
    cell.padding.left = 0;
    cell.padding.right = 0;
    return;
  }
  includePortLabels = nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , PORT_LABELS));
  spaceEfficientPortLabels = nodeContext.sizeOptions.contains(($clinit_SizeOptions() , SPACE_EFFICIENT_PORT_LABELS));
  portLabelsInside = nodeContext.portLabelsPlacement == ($clinit_PortLabelPlacement() , INSIDE_0);
  minWidth = 0;
  portContextIterator = portContexts.iterator_0();
  previousPortContext = null;
  previousPortRatio = 0;
  previousPortWidth = 0;
  while (portContextIterator.hasNext_0()) {
    currentPortContext = castTo(portContextIterator.next_1(), 112);
    currentPortRatio = checkNotNull_1(castToDouble(currentPortContext.port.getProperty(($clinit_PortPlacementCalculator() , PORT_RATIO_OR_POSITION))));
    currentPortWidth = currentPortContext.port.getSize().x_0;
    includePortLabels && setHorizontalPortMargins(nodeContext, portSide, portLabelsInside, !portLabelsInside && spaceEfficientPortLabels, 0);
    if (!previousPortContext) {
      !!nodeContext.surroundingPortMargins && nodeContext.surroundingPortMargins.left > 0 && (minWidth = $wnd.Math.max(minWidth, minSizeRequiredToRespectSpacing(nodeContext.surroundingPortMargins.left + currentPortContext.portMargin.left, currentPortRatio)));
    }
     else {
      requiredSpace = previousPortWidth + previousPortContext.portMargin.right + nodeContext.portPortSpacing + currentPortContext.portMargin.left;
      minWidth = $wnd.Math.max(minWidth, ($clinit_DoubleMath() , checkNonNegative($intern_96) , $wnd.Math.abs(previousPortRatio - currentPortRatio) <= $intern_96 || previousPortRatio == currentPortRatio || isNaN(previousPortRatio) && isNaN(currentPortRatio)?0:requiredSpace / (currentPortRatio - previousPortRatio)));
    }
    previousPortContext = currentPortContext;
    previousPortRatio = currentPortRatio;
    previousPortWidth = currentPortWidth;
  }
  if (!!nodeContext.surroundingPortMargins && nodeContext.surroundingPortMargins.right > 0) {
    requiredSpace = previousPortWidth + nodeContext.surroundingPortMargins.right;
    portLabelsInside && (requiredSpace += previousPortContext.portMargin.right);
    minWidth = $wnd.Math.max(minWidth, ($clinit_DoubleMath() , checkNonNegative($intern_96) , $wnd.Math.abs(previousPortRatio - 1) <= $intern_96 || previousPortRatio == 1 || isNaN(previousPortRatio) && isNaN(1)?0:requiredSpace / (1 - previousPortRatio)));
  }
  cell.padding.left = 0;
  cell.minimumContentAreaSize.x_0 = minWidth;
}

function calculateHorizontalNodeSizeRequiredByFreePorts(nodeContext, portSide){
  var cell, includePortLabels, maxLabelWidth, maxPortOrLabelWidth, portLabelsOutside, ports, spaceEfficientPortLabels, twoPorts, uniformPortSpacing, width_0;
  cell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  if (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).isEmpty()) {
    cell.padding.left = 0;
    cell.padding.right = 0;
    return;
  }
  cell.padding.left = nodeContext.surroundingPortMargins.left;
  cell.padding.right = nodeContext.surroundingPortMargins.right;
  includePortLabels = nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , PORT_LABELS));
  twoPorts = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() == 2;
  portLabelsOutside = nodeContext.portLabelsPlacement == ($clinit_PortLabelPlacement() , OUTSIDE_0);
  spaceEfficientPortLabels = nodeContext.sizeOptions.contains(($clinit_SizeOptions() , SPACE_EFFICIENT_PORT_LABELS));
  uniformPortSpacing = nodeContext.sizeOptions.contains(UNIFORM_PORT_SPACING);
  width_0 = 0;
  if (!includePortLabels || twoPorts && portLabelsOutside) {
    width_0 = portWidthPlusPortPortSpacing(nodeContext, portSide, false, false);
  }
   else if (portLabelsOutside) {
    if (uniformPortSpacing) {
      maxLabelWidth = maximumPortLabelWidth(nodeContext, portSide, spaceEfficientPortLabels);
      maxLabelWidth > 0 && setHorizontalPortMargins(nodeContext, portSide, false, false, maxLabelWidth);
      width_0 = portWidthPlusPortPortSpacing(nodeContext, portSide, true, false);
    }
     else {
      setHorizontalPortMargins(nodeContext, portSide, false, spaceEfficientPortLabels, 0);
      width_0 = portWidthPlusPortPortSpacing(nodeContext, portSide, true, false);
    }
  }
   else {
    if (uniformPortSpacing) {
      ports = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1();
      maxPortOrLabelWidth = maximumPortOrLabelWidth(nodeContext, portSide);
      width_0 = maxPortOrLabelWidth * ports + nodeContext.portPortSpacing * (ports - 1);
      maxPortOrLabelWidth > 0 && setHorizontalPortMargins(nodeContext, portSide, true, false, maxPortOrLabelWidth);
    }
     else {
      setHorizontalPortMargins(nodeContext, portSide, true, false, 0);
      width_0 = portWidthPlusPortPortSpacing(nodeContext, portSide, true, true);
    }
  }
  $getPortAlignment(nodeContext, portSide) == ($clinit_PortAlignment() , DISTRIBUTED) && (width_0 += 2 * nodeContext.portPortSpacing);
  cell.minimumContentAreaSize.x_0 = width_0;
}

function calculateHorizontalPortPlacementSize(nodeContext){
  switch (nodeContext.portConstraints.ordinal) {
    case 5:
      calculateHorizontalNodeSizeRequiredByFixedPosPorts(nodeContext, ($clinit_PortSide() , NORTH_1));
      calculateHorizontalNodeSizeRequiredByFixedPosPorts(nodeContext, SOUTH_1);
      break;
    case 4:
      calculateHorizontalNodeSizeRequiredByFixedRatioPorts(nodeContext, ($clinit_PortSide() , NORTH_1));
      calculateHorizontalNodeSizeRequiredByFixedRatioPorts(nodeContext, SOUTH_1);
      break;
    default:calculateHorizontalNodeSizeRequiredByFreePorts(nodeContext, ($clinit_PortSide() , NORTH_1));
      calculateHorizontalNodeSizeRequiredByFreePorts(nodeContext, SOUTH_1);
  }
}

function maximumPortLabelWidth(nodeContext, portSide, ignoreFirstPort){
  var currLabelWidth, ignore, labelCellWidths, maxLabelWidth;
  ignore = ignoreFirstPort;
  labelCellWidths = $iterator_3($mapToDouble(castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).stream(), new HorizontalPortPlacementSizeCalculator$lambda$0$Type));
  maxLabelWidth = 0;
  while (labelCellWidths.hasElement || (labelCellWidths.hasElement = $tryAdvance_1(labelCellWidths.spliterator, labelCellWidths)) , labelCellWidths.hasElement) {
    if (ignore) {
      checkCriticalElement((labelCellWidths.hasElement || (labelCellWidths.hasElement = $tryAdvance_1(labelCellWidths.spliterator, labelCellWidths)) , labelCellWidths.hasElement));
      labelCellWidths.hasElement = false;
      ignore = false;
      continue;
    }
     else {
      currLabelWidth = $nextDouble_0(labelCellWidths);
      labelCellWidths.hasElement || (labelCellWidths.hasElement = $tryAdvance_1(labelCellWidths.spliterator, labelCellWidths));
      labelCellWidths.hasElement && (maxLabelWidth = $wnd.Math.max(maxLabelWidth, currLabelWidth));
    }
  }
  return maxLabelWidth;
}

function maximumPortOrLabelWidth(nodeContext, portSide){
  var labelWidth, maxResult, portContext, portContext$iterator;
  maxResult = 0;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    if (portContext.portLabelCell) {
      labelWidth = $getMinimumWidth(portContext.portLabelCell);
      maxResult = $wnd.Math.max(maxResult, labelWidth);
    }
    maxResult = $wnd.Math.max(maxResult, portContext.port.getSize().x_0);
  }
  return maxResult;
}

function minSizeRequiredToRespectSpacing(spacing, secondRatio){
  return $clinit_DoubleMath() , checkNonNegative($intern_96) , $wnd.Math.abs(0 - secondRatio) <= $intern_96 || 0 == secondRatio || isNaN(0) && isNaN(secondRatio)?0:spacing / secondRatio;
}

function portWidthPlusPortPortSpacing(nodeContext, portSide, includeMargins, includeMarginsOfLastPort){
  var portContext, portContextIterator, result;
  result = 0;
  portContextIterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0();
  while (portContextIterator.hasNext_0()) {
    portContext = castTo(portContextIterator.next_1(), 112);
    result += portContext.port.getSize().x_0;
    includeMargins && (portContextIterator.hasNext_0() || includeMarginsOfLastPort) && (result += portContext.portMargin.left + portContext.portMargin.right);
    portContextIterator.hasNext_0() && (result += nodeContext.portPortSpacing);
  }
  return result;
}

function setHorizontalPortMargins(nodeContext, portSide, centered, excludeFirstPort, uniformLabelWidth){
  var exclude, labelWidth, overhang, portContext, portContext$iterator, portWidth;
  exclude = excludeFirstPort;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    if (exclude) {
      exclude = false;
      continue;
    }
    labelWidth = 0;
    uniformLabelWidth > 0?(labelWidth = uniformLabelWidth):!!portContext.portLabelCell && (labelWidth = $getMinimumWidth(portContext.portLabelCell));
    if (labelWidth > 0) {
      if (centered) {
        portWidth = portContext.port.getSize().x_0;
        if (labelWidth > portWidth) {
          overhang = (labelWidth - portWidth) / 2;
          portContext.portMargin.left = overhang;
          portContext.portMargin.right = overhang;
        }
      }
       else {
        portContext.portMargin.right = nodeContext.portLabelSpacing + labelWidth;
      }
    }
  }
}

function HorizontalPortPlacementSizeCalculator$lambda$0$Type(){
}

defineClass(1354, 1, {}, HorizontalPortPlacementSizeCalculator$lambda$0$Type);
_.applyAsDouble = function applyAsDouble_1(arg0){
  return !castTo(arg0, 112).portLabelCell?0:$getMinimumWidth(castTo(arg0, 112).portLabelCell);
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_algorithm_HorizontalPortPlacementSizeCalculator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal.algorithm', 'HorizontalPortPlacementSizeCalculator/lambda$0$Type', 1354);
function calculateWidthDueToLabels(nodeContext, portSide){
  var minCellSize, portContext, portContext$iterator, theAppropriateCell;
  theAppropriateCell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  minCellSize = theAppropriateCell.minimumContentAreaSize;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    !!portContext.portLabelCell && (minCellSize.x_0 = $wnd.Math.max(minCellSize.x_0, $getMinimumWidth(portContext.portLabelCell)));
  }
  if (minCellSize.x_0 > 0) {
    switch (portSide.ordinal) {
      case 2:
        theAppropriateCell.padding.right = nodeContext.portLabelSpacing;
        break;
      case 4:
        theAppropriateCell.padding.left = nodeContext.portLabelSpacing;
    }
  }
}

function createInsidePortLabelCell(nodeContext, container, containerArea, portSide){
  var portLabelCell;
  portLabelCell = new AtomicCell;
  container.cells_0[containerArea.ordinal] = portLabelCell;
  $put_2(nodeContext.insidePortLabelCells, portSide, portLabelCell);
}

function setupEastOrWestPortLabelCell(nodeContext, portSide){
  nodeContext.portLabelsPlacement == ($clinit_PortLabelPlacement() , INSIDE_0) && calculateWidthDueToLabels(nodeContext, portSide);
  setupTopAndBottomPadding(nodeContext, portSide);
}

function setupNorthOrSouthPortLabelCell(nodeContext, portSide){
  var padding;
  padding = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117).padding;
  switch (portSide.ordinal) {
    case 1:
      padding.top_0 = nodeContext.portLabelSpacing;
      break;
    case 3:
      padding.bottom = nodeContext.portLabelSpacing;
  }
  if (nodeContext.surroundingPortMargins) {
    padding.left = nodeContext.surroundingPortMargins.left;
    padding.right = nodeContext.surroundingPortMargins.right;
  }
}

function setupTopAndBottomPadding(nodeContext, portSide){
  var padding;
  if (nodeContext.surroundingPortMargins) {
    padding = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117).padding;
    padding.top_0 = nodeContext.surroundingPortMargins.top_0;
    padding.bottom = nodeContext.surroundingPortMargins.bottom;
  }
}

function placeHorizontalOuterNodeLabelContainer(nodeContext, outerNodeLabelsOverhang, portSide){
  var nodeLabelContainer, nodeLabelContainerRect, nodeSize;
  nodeSize = nodeContext.nodeSize;
  nodeLabelContainer = castTo($get_10(nodeContext.outsideNodeLabelContainers, portSide), 226);
  nodeLabelContainerRect = nodeLabelContainer.cellRectangle;
  nodeLabelContainerRect.width_0 = $getMinimumWidth_0(nodeLabelContainer);
  nodeLabelContainerRect.height = $getMinimumHeight_1(nodeLabelContainer);
  nodeLabelContainerRect.width_0 = $wnd.Math.max(nodeLabelContainerRect.width_0, nodeSize.x_0);
  nodeLabelContainerRect.width_0 > nodeSize.x_0 && !outerNodeLabelsOverhang && (nodeLabelContainerRect.width_0 = nodeSize.x_0);
  nodeLabelContainerRect.x_0 = -(nodeLabelContainerRect.width_0 - nodeSize.x_0) / 2;
  switch (portSide.ordinal) {
    case 1:
      nodeLabelContainerRect.y_0 = -nodeLabelContainerRect.height;
      break;
    case 3:
      nodeLabelContainerRect.y_0 = nodeSize.y_0;
  }
  $layoutChildrenHorizontally(nodeLabelContainer);
  $layoutChildrenVertically(nodeLabelContainer);
}

function placeVerticalOuterNodeLabelContainer(nodeContext, outerNodeLabelsOverhang, portSide){
  var nodeLabelContainer, nodeLabelContainerRect, nodeSize;
  nodeSize = nodeContext.nodeSize;
  nodeLabelContainer = castTo($get_10(nodeContext.outsideNodeLabelContainers, portSide), 226);
  nodeLabelContainerRect = nodeLabelContainer.cellRectangle;
  nodeLabelContainerRect.width_0 = $getMinimumWidth_0(nodeLabelContainer);
  nodeLabelContainerRect.height = $getMinimumHeight_1(nodeLabelContainer);
  nodeLabelContainerRect.height = $wnd.Math.max(nodeLabelContainerRect.height, nodeSize.y_0);
  nodeLabelContainerRect.height > nodeSize.y_0 && !outerNodeLabelsOverhang && (nodeLabelContainerRect.height = nodeSize.y_0);
  nodeLabelContainerRect.y_0 = -(nodeLabelContainerRect.height - nodeSize.y_0) / 2;
  switch (portSide.ordinal) {
    case 4:
      nodeLabelContainerRect.x_0 = -nodeLabelContainerRect.width_0;
      break;
    case 2:
      nodeLabelContainerRect.x_0 = nodeSize.x_0;
  }
  $layoutChildrenHorizontally(nodeLabelContainer);
  $layoutChildrenVertically(nodeLabelContainer);
}

function LabelPlacer$lambda$0$Type(){
}

defineClass(1356, 1, {}, LabelPlacer$lambda$0$Type);
_.accept = function accept_39(arg0){
  $applyLabelLayout(castTo(arg0, 279));
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_algorithm_LabelPlacer$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal.algorithm', 'LabelPlacer/lambda$0$Type', 1356);
function LabelPlacer$lambda$1$Type(){
}

defineClass(1357, 1, $intern_90, LabelPlacer$lambda$1$Type);
_.test_0 = function test_7(arg0){
  return !!castTo(arg0, 112).portLabelCell;
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_algorithm_LabelPlacer$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal.algorithm', 'LabelPlacer/lambda$1$Type', 1357);
function LabelPlacer$lambda$2$Type(){
}

defineClass(1358, 1, {}, LabelPlacer$lambda$2$Type);
_.accept = function accept_40(arg0){
  $applyLabelLayout(castTo(arg0, 112).portLabelCell);
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_algorithm_LabelPlacer$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal.algorithm', 'LabelPlacer/lambda$2$Type', 1358);
function $clinit_NodeLabelAndSizeUtilities(){
  $clinit_NodeLabelAndSizeUtilities = emptyMethod;
  EFFECTIVELY_FIXED_SIZE_CONSTRAINTS = of_0(($clinit_SizeConstraint() , PORT_LABELS));
}

function getMinimumNodeOrClientAreaSize(nodeContext){
  $clinit_NodeLabelAndSizeUtilities();
  var minSize;
  minSize = new KVector_2(castTo(nodeContext.node.getProperty(($clinit_CoreOptions() , NODE_SIZE_MINIMUM_1)), 8));
  if (nodeContext.sizeOptions.contains(($clinit_SizeOptions() , DEFAULT_MINIMUM_SIZE))) {
    minSize.x_0 <= 0 && (minSize.x_0 = 20);
    minSize.y_0 <= 0 && (minSize.y_0 = 20);
  }
  return minSize;
}

function getMinimumNodeSize(nodeContext){
  $clinit_NodeLabelAndSizeUtilities();
  if (nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , MINIMUM_SIZE))) {
    if (!nodeContext.sizeOptions.contains(($clinit_SizeOptions() , MINIMUM_SIZE_ACCOUNTS_FOR_PADDING))) {
      return getMinimumNodeOrClientAreaSize(nodeContext);
    }
  }
  return null;
}

function offsetSouthernPortsByNodeSize(nodeContext){
  $clinit_NodeLabelAndSizeUtilities();
  var nodeHeight, portContext, portContext$iterator, portPosition;
  nodeHeight = nodeContext.nodeSize.y_0;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, ($clinit_PortSide() , SOUTH_1)), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    portPosition = portContext.portPosition;
    portPosition.y_0 += nodeHeight;
  }
}

function setNodePadding(nodeContext){
  $clinit_NodeLabelAndSizeUtilities();
  var clientArea, nodePadding, nodeRect;
  if (!nodeContext.sizeOptions.contains(($clinit_SizeOptions() , COMPUTE_PADDING))) {
    return;
  }
  nodeRect = nodeContext.nodeContainer.cellRectangle;
  clientArea = new ElkRectangle_1(nodeContext.insideNodeLabelContainer.centerCellRect);
  nodePadding = new ElkPadding;
  nodePadding.left = clientArea.x_0 - nodeRect.x_0;
  nodePadding.top_0 = clientArea.y_0 - nodeRect.y_0;
  nodePadding.right = nodeRect.x_0 + nodeRect.width_0 - (clientArea.x_0 + clientArea.width_0);
  nodePadding.bottom = nodeRect.y_0 + nodeRect.height - (clientArea.y_0 + clientArea.height);
  nodeContext.node.setPadding(nodePadding);
}

function setupNodePaddingForPortsWithOffset(nodeContext){
  $clinit_NodeLabelAndSizeUtilities();
  var nodeCellPadding, portBorderOffset, portContext, portContext$iterator;
  nodeCellPadding = nodeContext.nodeContainer.padding;
  for (portContext$iterator = $values_0(nodeContext.portContexts).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    if (portContext.port.hasProperty(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))) {
      portBorderOffset = checkNotNull_1(castToDouble(portContext.port.getProperty(PORT_BORDER_OFFSET_0)));
      if (portBorderOffset < 0) {
        switch (portContext.port.getSide().ordinal) {
          case 1:
            nodeCellPadding.top_0 = $wnd.Math.max(nodeCellPadding.top_0, -portBorderOffset);
            break;
          case 3:
            nodeCellPadding.bottom = $wnd.Math.max(nodeCellPadding.bottom, -portBorderOffset);
            break;
          case 2:
            nodeCellPadding.right = $wnd.Math.max(nodeCellPadding.right, -portBorderOffset);
            break;
          case 4:
            nodeCellPadding.left = $wnd.Math.max(nodeCellPadding.left, -portBorderOffset);
        }
      }
    }
  }
}

var EFFECTIVELY_FIXED_SIZE_CONSTRAINTS;
function NodeLabelAndSizeUtilities$lambda$0$Type(){
}

defineClass(1353, 1, {}, NodeLabelAndSizeUtilities$lambda$0$Type);
_.accept = function accept_41(arg0){
  $clinit_NodeLabelAndSizeUtilities();
  $applyPortPosition(castTo(arg0, 112));
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_algorithm_NodeLabelAndSizeUtilities$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal.algorithm', 'NodeLabelAndSizeUtilities/lambda$0$Type', 1353);
function createNodeLabelCellContainers(nodeContext, onlyInside){
  var eastContainer, northContainer, southContainer, symmetry, tabularNodeLabels, westContainer;
  symmetry = !nodeContext.sizeOptions.contains(($clinit_SizeOptions() , ASYMMETRICAL));
  tabularNodeLabels = nodeContext.sizeOptions.contains(FORCE_TABULAR_NODE_LABELS);
  nodeContext.insideNodeLabelContainer = new GridContainerCell(tabularNodeLabels, symmetry, nodeContext.labelCellSpacing);
  !!nodeContext.nodeLabelsPadding && $copy(nodeContext.insideNodeLabelContainer.padding, nodeContext.nodeLabelsPadding);
  $setCell_0(nodeContext.nodeContainerMiddleRow, ($clinit_ContainerArea() , CENTER), nodeContext.insideNodeLabelContainer);
  if (!onlyInside) {
    northContainer = new StripContainerCell(1, symmetry, nodeContext.labelCellSpacing);
    northContainer.padding.bottom = nodeContext.nodeLabelSpacing;
    $put_2(nodeContext.outsideNodeLabelContainers, ($clinit_PortSide() , NORTH_1), northContainer);
    southContainer = new StripContainerCell(1, symmetry, nodeContext.labelCellSpacing);
    southContainer.padding.top_0 = nodeContext.nodeLabelSpacing;
    $put_2(nodeContext.outsideNodeLabelContainers, SOUTH_1, southContainer);
    westContainer = new StripContainerCell(0, symmetry, nodeContext.labelCellSpacing);
    westContainer.padding.right = nodeContext.nodeLabelSpacing;
    $put_2(nodeContext.outsideNodeLabelContainers, WEST_1, westContainer);
    eastContainer = new StripContainerCell(0, symmetry, nodeContext.labelCellSpacing);
    eastContainer.padding.left = nodeContext.nodeLabelSpacing;
    $put_2(nodeContext.outsideNodeLabelContainers, EAST_1, eastContainer);
  }
}

function handleNodeLabel(nodeContext, label_0, onlyInside){
  var labelLocation, labelPlacement;
  labelPlacement = label_0.hasProperty(($clinit_CoreOptions() , NODE_LABELS_PLACEMENT_0))?castTo(label_0.getProperty(NODE_LABELS_PLACEMENT_0), 19):nodeContext.nodeLabelPlacement;
  labelLocation = fromNodeLabelPlacement(labelPlacement);
  if (labelLocation == ($clinit_NodeLabelLocation() , UNDEFINED)) {
    return;
  }
  if (onlyInside && !$isInsideLocation(labelLocation)) {
    return;
  }
  $addLabel(retrieveNodeLabelCell(nodeContext, labelLocation), label_0);
}

function lambda$0_3(nodeContext_0, onlyInside_1, label_2){
  handleNodeLabel(nodeContext_0, label_2, onlyInside_1);
}

function retrieveNodeLabelCell(nodeContext, nodeLabelLocation){
  var containerCell, nodeLabelCell, outsideSide;
  nodeLabelCell = castTo($get_10(nodeContext.nodeLabelCells, nodeLabelLocation), 279);
  if (!nodeLabelCell) {
    nodeLabelCell = new LabelCell_0(nodeContext.labelLabelSpacing, nodeLabelLocation);
    $put_2(nodeContext.nodeLabelCells, nodeLabelLocation, nodeLabelCell);
    if ($isInsideLocation(nodeLabelLocation)) {
      $setCell(nodeContext.insideNodeLabelContainer, nodeLabelLocation.containerRow, nodeLabelLocation.containerColumn, nodeLabelCell);
    }
     else {
      outsideSide = $getOutsideSide(nodeLabelLocation);
      containerCell = castTo($get_10(nodeContext.outsideNodeLabelContainers, outsideSide), 226);
      switch (outsideSide.ordinal) {
        case 1:
        case 3:
          nodeLabelCell.contributesToMinimumHeight = true;
          $setCell_0(containerCell, nodeLabelLocation.containerColumn, nodeLabelCell);
          break;
        case 4:
        case 2:
          nodeLabelCell.contributesToMinimumWidth = true;
          $setCell_0(containerCell, nodeLabelLocation.containerRow, nodeLabelCell);
      }
    }
  }
  return nodeLabelCell;
}

function NodeLabelCellCreator$lambda$0$Type(nodeContext_0, onlyInside_1){
  this.nodeContext_0 = nodeContext_0;
  this.onlyInside_1 = onlyInside_1;
}

defineClass(732, 1, {}, NodeLabelCellCreator$lambda$0$Type);
_.accept = function accept_42(arg0){
  lambda$0_3(this.nodeContext_0, this.onlyInside_1, arg0);
}
;
_.onlyInside_1 = false;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_algorithm_NodeLabelCellCreator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal.algorithm', 'NodeLabelCellCreator/lambda$0$Type', 732);
function setNodeHeight(nodeContext){
  var height, minNodeSize, nodeCellRectangle, nodeSize;
  nodeSize = nodeContext.nodeSize;
  $clinit_NodeLabelAndSizeUtilities();
  if (nodeContext.sizeConstraints.isEmpty() || equals_Ljava_lang_Object__Z__devirtual$(nodeContext.sizeConstraints, EFFECTIVELY_FIXED_SIZE_CONSTRAINTS)) {
    height = nodeSize.y_0;
  }
   else {
    height = $getMinimumHeight_1(nodeContext.nodeContainer);
    if (nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , NODE_LABELS)) && !nodeContext.sizeOptions.contains(($clinit_SizeOptions() , OUTSIDE_NODE_LABELS_OVERHANG))) {
      height = $wnd.Math.max(height, $getMinimumHeight_1(castTo($get_10(nodeContext.outsideNodeLabelContainers, ($clinit_PortSide() , EAST_1)), 226)));
      height = $wnd.Math.max(height, $getMinimumHeight_1(castTo($get_10(nodeContext.outsideNodeLabelContainers, WEST_1), 226)));
    }
    minNodeSize = getMinimumNodeSize(nodeContext);
    !!minNodeSize && (height = $wnd.Math.max(height, minNodeSize.y_0));
    if (nodeContext.sizeConstraints.contains(PORTS_0)) {
      if (nodeContext.portConstraints == ($clinit_PortConstraints() , FIXED_RATIO) || nodeContext.portConstraints == FIXED_POS) {
        height = $wnd.Math.max(height, $getMinimumHeight(castTo($get_10(nodeContext.insidePortLabelCells, ($clinit_PortSide() , EAST_1)), 117)));
        height = $wnd.Math.max(height, $getMinimumHeight(castTo($get_10(nodeContext.insidePortLabelCells, WEST_1), 117)));
      }
    }
  }
  nodeSize.y_0 = height;
  nodeCellRectangle = nodeContext.nodeContainer.cellRectangle;
  nodeCellRectangle.y_0 = 0;
  nodeCellRectangle.height = height;
  $layoutChildrenVertically(nodeContext.nodeContainer);
}

function setNodeWidth(nodeContext){
  var minNodeSize, nodeCellRectangle, nodeSize, width_0;
  nodeSize = nodeContext.nodeSize;
  $clinit_NodeLabelAndSizeUtilities();
  if (nodeContext.sizeConstraints.isEmpty() || equals_Ljava_lang_Object__Z__devirtual$(nodeContext.sizeConstraints, EFFECTIVELY_FIXED_SIZE_CONSTRAINTS)) {
    width_0 = nodeSize.x_0;
  }
   else {
    width_0 = $getMinimumWidth_0(nodeContext.nodeContainer);
    if (nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , NODE_LABELS)) && !nodeContext.sizeOptions.contains(($clinit_SizeOptions() , OUTSIDE_NODE_LABELS_OVERHANG))) {
      width_0 = $wnd.Math.max(width_0, $getMinimumWidth_0(castTo($get_10(nodeContext.outsideNodeLabelContainers, ($clinit_PortSide() , NORTH_1)), 226)));
      width_0 = $wnd.Math.max(width_0, $getMinimumWidth_0(castTo($get_10(nodeContext.outsideNodeLabelContainers, SOUTH_1), 226)));
    }
    minNodeSize = getMinimumNodeSize(nodeContext);
    !!minNodeSize && (width_0 = $wnd.Math.max(width_0, minNodeSize.x_0));
  }
  nodeSize.x_0 = width_0;
  nodeCellRectangle = nodeContext.nodeContainer.cellRectangle;
  nodeCellRectangle.x_0 = 0;
  nodeCellRectangle.width_0 = width_0;
  $layoutChildrenHorizontally(nodeContext.nodeContainer);
}

function createPortContext(nodeContext, port, imPortLabels){
  var portContext;
  portContext = new PortContext(nodeContext, port);
  $put(nodeContext.portContexts, port.getSide(), portContext);
  if (imPortLabels && nodeContext.portLabelsPlacement != ($clinit_PortLabelPlacement() , FIXED_2)) {
    portContext.portLabelCell = new LabelCell(nodeContext.labelLabelSpacing);
    $forEach_0(port.getLabels(), new PortContextCreator$lambda$0$Type(portContext));
  }
}

function createPortContexts(nodeContext, ignoreInsidePortLabels){
  var imPortLabels, port, port$iterator, volatileId;
  imPortLabels = !ignoreInsidePortLabels || nodeContext.portLabelsPlacement != ($clinit_PortLabelPlacement() , INSIDE_0);
  volatileId = 0;
  for (port$iterator = new ArrayList$1(nodeContext.node.getPorts()); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 770);
    if (port.getSide() == ($clinit_PortSide() , UNDEFINED_7)) {
      throw toJs(new IllegalArgumentException_0('Label and node size calculator can only be used with ports that have port sides assigned.'));
    }
    port.setVolatileId(volatileId++);
    createPortContext(nodeContext, port, imPortLabels);
  }
}

function lambda$0_4(portContext_0, label_1){
  $addLabel(portContext_0.portLabelCell, label_1);
}

function PortContextCreator$lambda$0$Type(portContext_0){
  this.portContext_0 = portContext_0;
}

defineClass(1352, 1, {}, PortContextCreator$lambda$0$Type);
_.accept = function accept_43(arg0){
  lambda$0_4(this.portContext_0, arg0);
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_algorithm_PortContextCreator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal.algorithm', 'PortContextCreator/lambda$0$Type', 1352);
function constrainedInsidePortLabelPlacement(nodeContext, portSide){
  var insidePortLabelContainer, labelContainerRect, leftBorder, overlapRemovalDirection, overlapRemover, padding, padding0, portContext, portContext$iterator, portContext$iterator0, portContexts, portLabelCell, portLabelCellRect, portPosition, portSize, rightBorder, startCoordinate, stripHeight, verticalLabelAlignment, actualMinX, actualMaxX;
  portContexts = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62);
  if (portSide == ($clinit_PortSide() , EAST_1) || portSide == WEST_1) {
    simpleInsidePortLabelPlacement(nodeContext, portSide);
    return;
  }
  overlapRemovalDirection = portSide == NORTH_1?($clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , DOWN):($clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , UP);
  verticalLabelAlignment = portSide == NORTH_1?($clinit_VerticalLabelAlignment() , TOP):($clinit_VerticalLabelAlignment() , BOTTOM);
  insidePortLabelContainer = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  labelContainerRect = insidePortLabelContainer.cellRectangle;
  leftBorder = labelContainerRect.x_0 + maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [insidePortLabelContainer.padding.left, nodeContext.surroundingPortMargins.left, nodeContext.nodeLabelSpacing]));
  rightBorder = labelContainerRect.x_0 + labelContainerRect.width_0 - maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [insidePortLabelContainer.padding.right, nodeContext.surroundingPortMargins.right, nodeContext.nodeLabelSpacing]));
  overlapRemover = $withGap(createForDirection(overlapRemovalDirection), nodeContext.portLabelSpacing);
  startCoordinate = portSide == NORTH_1?$intern_97:$intern_98;
  for (portContext$iterator0 = portContexts.iterator_0(); portContext$iterator0.hasNext_0();) {
    portContext = castTo(portContext$iterator0.next_1(), 112);
    if (!portContext.portLabelCell || portContext.portLabelCell.labels.array.length <= 0) {
      continue;
    }
    portSize = portContext.port.getSize();
    portPosition = portContext.portPosition;
    portLabelCell = portContext.portLabelCell;
    portLabelCellRect = portLabelCell.cellRectangle;
    portLabelCellRect.width_0 = (padding0 = portLabelCell.padding , portLabelCell.minimumContentAreaSize.x_0 + padding0.left + padding0.right);
    portLabelCellRect.height = (padding = portLabelCell.padding , portLabelCell.minimumContentAreaSize.y_0 + padding.top_0 + padding.bottom);
    requireNonNull(verticalLabelAlignment, 'Vertical alignment cannot be null');
    portLabelCell.verticalAlignment = verticalLabelAlignment;
    $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
    portLabelCellRect.x_0 = portPosition.x_0 - (portLabelCellRect.width_0 - portSize.x_0) / 2;
    actualMinX = $wnd.Math.min(leftBorder, portPosition.x_0);
    actualMaxX = $wnd.Math.max(rightBorder, portPosition.x_0 + portSize.x_0);
    portLabelCellRect.x_0 < actualMinX?(portLabelCellRect.x_0 = actualMinX):portLabelCellRect.x_0 + portLabelCellRect.width_0 > actualMaxX && (portLabelCellRect.x_0 = actualMaxX - portLabelCellRect.width_0);
    $add_4(overlapRemover.rectangleNodes, new RectangleStripOverlapRemover$RectangleNode(portLabelCellRect, $importRectangle(overlapRemover, portLabelCellRect)));
    startCoordinate = portSide == NORTH_1?$wnd.Math.max(startCoordinate, portPosition.y_0 + portContext.port.getSize().y_0):$wnd.Math.min(startCoordinate, portPosition.y_0);
  }
  startCoordinate += portSide == NORTH_1?nodeContext.portLabelSpacing:-nodeContext.portLabelSpacing;
  stripHeight = $removeOverlaps_0((overlapRemover.startCoordinate = startCoordinate , overlapRemover));
  stripHeight > 0 && (castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117).minimumContentAreaSize.y_0 = stripHeight);
  for (portContext$iterator = portContexts.iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    if (!portContext.portLabelCell || portContext.portLabelCell.labels.array.length <= 0) {
      continue;
    }
    portLabelCellRect = portContext.portLabelCell.cellRectangle;
    portLabelCellRect.x_0 -= portContext.portPosition.x_0;
    portLabelCellRect.y_0 -= portContext.portPosition.y_0;
  }
}

function constrainedOutsidePortLabelPlacement(nodeContext, portSide){
  var overlapRemovalDirection, overlapRemover, padding, padding0, padding1, portContext, portContext$iterator, portContext$iterator0, portContexts, portLabelCell, portLabelCellRect, portPosition, portSize, portWithSpecialNeeds, startCoordinate, verticalLabelAlignment;
  portContexts = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62);
  if (portContexts.size_1() <= 2 || portSide == ($clinit_PortSide() , EAST_1) || portSide == ($clinit_PortSide() , WEST_1)) {
    simpleOutsidePortLabelPlacement(nodeContext, portSide);
    return;
  }
  portWithSpecialNeeds = nodeContext.sizeOptions.contains(($clinit_SizeOptions() , SPACE_EFFICIENT_PORT_LABELS));
  overlapRemovalDirection = portSide == ($clinit_PortSide() , NORTH_1)?($clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , UP):($clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , DOWN);
  verticalLabelAlignment = portSide == NORTH_1?($clinit_VerticalLabelAlignment() , BOTTOM):($clinit_VerticalLabelAlignment() , TOP);
  overlapRemover = $withGap(createForDirection(overlapRemovalDirection), nodeContext.portLabelSpacing);
  startCoordinate = portSide == NORTH_1?$intern_98:$intern_97;
  for (portContext$iterator0 = portContexts.iterator_0(); portContext$iterator0.hasNext_0();) {
    portContext = castTo(portContext$iterator0.next_1(), 112);
    if (!portContext.portLabelCell || portContext.portLabelCell.labels.array.length <= 0) {
      continue;
    }
    portSize = portContext.port.getSize();
    portPosition = portContext.portPosition;
    portLabelCell = portContext.portLabelCell;
    portLabelCellRect = portLabelCell.cellRectangle;
    portLabelCellRect.width_0 = (padding0 = portLabelCell.padding , portLabelCell.minimumContentAreaSize.x_0 + padding0.left + padding0.right);
    portLabelCellRect.height = (padding1 = portLabelCell.padding , portLabelCell.minimumContentAreaSize.y_0 + padding1.top_0 + padding1.bottom);
    if (portWithSpecialNeeds) {
      portLabelCellRect.x_0 = portPosition.x_0 - (padding = portLabelCell.padding , portLabelCell.minimumContentAreaSize.x_0 + padding.left + padding.right) - nodeContext.portLabelSpacing;
      portWithSpecialNeeds = false;
    }
     else {
      portLabelCellRect.x_0 = portPosition.x_0 + portSize.x_0 + nodeContext.portLabelSpacing;
    }
    requireNonNull(verticalLabelAlignment, 'Vertical alignment cannot be null');
    portLabelCell.verticalAlignment = verticalLabelAlignment;
    $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
    $add_4(overlapRemover.rectangleNodes, new RectangleStripOverlapRemover$RectangleNode(portLabelCellRect, $importRectangle(overlapRemover, portLabelCellRect)));
    startCoordinate = portSide == NORTH_1?$wnd.Math.min(startCoordinate, portPosition.y_0):$wnd.Math.max(startCoordinate, portPosition.y_0 + portContext.port.getSize().y_0);
  }
  startCoordinate += portSide == NORTH_1?-nodeContext.portLabelSpacing:nodeContext.portLabelSpacing;
  $removeOverlaps_0((overlapRemover.startCoordinate = startCoordinate , overlapRemover));
  for (portContext$iterator = portContexts.iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    if (!portContext.portLabelCell || portContext.portLabelCell.labels.array.length <= 0) {
      continue;
    }
    portLabelCellRect = portContext.portLabelCell.cellRectangle;
    portLabelCellRect.x_0 -= portContext.portPosition.x_0;
    portLabelCellRect.y_0 -= portContext.portPosition.y_0;
  }
}

function placePortLabels(nodeContext, portSide){
  var constrainedPlacement;
  constrainedPlacement = !nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , PORT_LABELS)) || nodeContext.portConstraints == ($clinit_PortConstraints() , FIXED_POS);
  switch (nodeContext.portLabelsPlacement.ordinal) {
    case 1:
      constrainedPlacement?constrainedInsidePortLabelPlacement(nodeContext, portSide):simpleInsidePortLabelPlacement(nodeContext, portSide);
      break;
    case 0:
      constrainedPlacement?constrainedOutsidePortLabelPlacement(nodeContext, portSide):simpleOutsidePortLabelPlacement(nodeContext, portSide);
  }
}

function portLabelBorderOffsetForPortSide(nodeContext, portSide){
  switch (portSide.ordinal) {
    case 1:
      return nodeContext.nodeContainer.padding.top_0 + nodeContext.portLabelSpacing;
    case 3:
      return nodeContext.nodeContainer.padding.bottom + nodeContext.portLabelSpacing;
    case 2:
      return nodeContext.nodeContainer.padding.right + nodeContext.portLabelSpacing;
    case 4:
      return nodeContext.nodeContainer.padding.left + nodeContext.portLabelSpacing;
    default:return 0;
  }
}

function simpleInsidePortLabelPlacement(nodeContext, portSide){
  var insideNorthOrSouthPortLabelAreaHeight, labelBorderOffset, padding, padding0, portBorderOffset, portContext, portContext$iterator, portLabelCell, portLabelCellRect, portLabelSpacing, portSize;
  insideNorthOrSouthPortLabelAreaHeight = 0;
  labelBorderOffset = portLabelBorderOffsetForPortSide(nodeContext, portSide);
  portLabelSpacing = nodeContext.portLabelSpacing;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    if (!portContext.portLabelCell || portContext.portLabelCell.labels.array.length <= 0) {
      continue;
    }
    portSize = portContext.port.getSize();
    portBorderOffset = portContext.port.hasProperty(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))?checkNotNull_1(castToDouble(portContext.port.getProperty(PORT_BORDER_OFFSET_0))):0;
    portLabelCell = portContext.portLabelCell;
    portLabelCellRect = portLabelCell.cellRectangle;
    portLabelCellRect.width_0 = (padding0 = portLabelCell.padding , portLabelCell.minimumContentAreaSize.x_0 + padding0.left + padding0.right);
    portLabelCellRect.height = (padding = portLabelCell.padding , portLabelCell.minimumContentAreaSize.y_0 + padding.top_0 + padding.bottom);
    switch (portSide.ordinal) {
      case 1:
        portLabelCellRect.x_0 = (portSize.x_0 - portLabelCellRect.width_0) / 2;
        portLabelCellRect.y_0 = portSize.y_0 + portBorderOffset + labelBorderOffset;
        $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , CENTER_0));
        $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , TOP));
        break;
      case 3:
        portLabelCellRect.x_0 = (portSize.x_0 - portLabelCellRect.width_0) / 2;
        portLabelCellRect.y_0 = -portBorderOffset - labelBorderOffset - portLabelCellRect.height;
        $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , CENTER_0));
        $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , BOTTOM));
        break;
      case 2:
        portLabelCellRect.x_0 = -portBorderOffset - labelBorderOffset - portLabelCellRect.width_0;
        portLabelCellRect.y_0 = ($clinit_NodeLabelAndSizeUtilities() , portContext.parentNodeContext.treatAsCompoundNode && (!checkNotNull_1(castToBoolean(portContext.parentNodeContext.node.getProperty(PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE_0))) || portContext.port.hasCompoundConnections())?portSize.y_0 + portLabelSpacing:(portSize.y_0 - portLabelCellRect.height) / 2);
        $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
        $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , CENTER_1));
        break;
      case 4:
        portLabelCellRect.x_0 = portSize.x_0 + portBorderOffset + labelBorderOffset;
        portLabelCellRect.y_0 = ($clinit_NodeLabelAndSizeUtilities() , portContext.parentNodeContext.treatAsCompoundNode && (!checkNotNull_1(castToBoolean(portContext.parentNodeContext.node.getProperty(PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE_0))) || portContext.port.hasCompoundConnections())?portSize.y_0 + portLabelSpacing:(portSize.y_0 - portLabelCellRect.height) / 2);
        $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , LEFT));
        $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , CENTER_1));
    }
    (portSide == ($clinit_PortSide() , NORTH_1) || portSide == SOUTH_1) && (insideNorthOrSouthPortLabelAreaHeight = $wnd.Math.max(insideNorthOrSouthPortLabelAreaHeight, portLabelCellRect.height));
  }
  insideNorthOrSouthPortLabelAreaHeight > 0 && (castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117).minimumContentAreaSize.y_0 = insideNorthOrSouthPortLabelAreaHeight);
}

function simpleOutsidePortLabelPlacement(nodeContext, portSide){
  var padding, padding0, portContext, portContext$iterator, portContexts, portLabelCell, portLabelCellRect, portSize, portWithSpecialNeeds;
  portContexts = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62);
  portWithSpecialNeeds = portContexts.size_1() == 2 || portContexts.size_1() > 2 && nodeContext.sizeOptions.contains(($clinit_SizeOptions() , SPACE_EFFICIENT_PORT_LABELS));
  for (portContext$iterator = portContexts.iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    if (!portContext.portLabelCell || portContext.portLabelCell.labels.array.length <= 0) {
      continue;
    }
    portSize = portContext.port.getSize();
    portLabelCell = portContext.portLabelCell;
    portLabelCellRect = portLabelCell.cellRectangle;
    portLabelCellRect.width_0 = (padding0 = portLabelCell.padding , portLabelCell.minimumContentAreaSize.x_0 + padding0.left + padding0.right);
    portLabelCellRect.height = (padding = portLabelCell.padding , portLabelCell.minimumContentAreaSize.y_0 + padding.top_0 + padding.bottom);
    switch (portSide.ordinal) {
      case 1:
        if (portWithSpecialNeeds) {
          portLabelCellRect.x_0 = -portLabelCellRect.width_0 - nodeContext.portLabelSpacing;
          $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
        }
         else {
          portLabelCellRect.x_0 = portSize.x_0 + nodeContext.portLabelSpacing;
          $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , LEFT));
        }

        portLabelCellRect.y_0 = -portLabelCellRect.height - nodeContext.portLabelSpacing;
        $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , BOTTOM));
        break;
      case 3:
        if (portWithSpecialNeeds) {
          portLabelCellRect.x_0 = -portLabelCellRect.width_0 - nodeContext.portLabelSpacing;
          $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
        }
         else {
          portLabelCellRect.x_0 = portSize.x_0 + nodeContext.portLabelSpacing;
          $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , LEFT));
        }

        portLabelCellRect.y_0 = portSize.y_0 + nodeContext.portLabelSpacing;
        $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , TOP));
        break;
      case 2:
        portLabelCellRect.x_0 = portSize.x_0 + nodeContext.portLabelSpacing;
        if (portWithSpecialNeeds) {
          portLabelCellRect.y_0 = -portLabelCellRect.height - nodeContext.portLabelSpacing;
          $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , BOTTOM));
        }
         else {
          portLabelCellRect.y_0 = portSize.y_0 + nodeContext.portLabelSpacing;
          $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , TOP));
        }

        $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , LEFT));
        break;
      case 4:
        portLabelCellRect.x_0 = -portLabelCellRect.width_0 - nodeContext.portLabelSpacing;
        if (portWithSpecialNeeds) {
          portLabelCellRect.y_0 = -portLabelCellRect.height - nodeContext.portLabelSpacing;
          $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , BOTTOM));
        }
         else {
          portLabelCellRect.y_0 = portSize.y_0 + nodeContext.portLabelSpacing;
          $setVerticalAlignment(portLabelCell, ($clinit_VerticalLabelAlignment() , TOP));
        }

        $setHorizontalAlignment(portLabelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
    }
    portWithSpecialNeeds = false;
  }
}

function $clinit_PortPlacementCalculator(){
  $clinit_PortPlacementCalculator = emptyMethod;
  PORT_RATIO_OR_POSITION = new Property_0('portRatioOrPosition', 0);
}

function calculateVerticalPortXCoordinate(portContext, nodeWidth){
  var port;
  port = portContext.port;
  return port.hasProperty(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))?port.getSide() == ($clinit_PortSide() , WEST_1)?-port.getSize().x_0 - checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):nodeWidth + checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):port.getSide() == ($clinit_PortSide() , WEST_1)?-port.getSize().x_0:nodeWidth;
}

function placeHorizontalFixedPosPorts(nodeContext, portSide){
  var port, portContext, portContext$iterator;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    portContext.portPosition.y_0 = (port = portContext.port , port.hasProperty(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))?port.getSide() == ($clinit_PortSide() , NORTH_1)?-port.getSize().y_0 - checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):port.getSide() == ($clinit_PortSide() , NORTH_1)?-port.getSize().y_0:0);
  }
}

function placeHorizontalFixedRatioPorts(nodeContext, portSide){
  var nodeWidth, port, portContext, portContext$iterator;
  nodeWidth = nodeContext.nodeSize.x_0;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    portContext.portPosition.x_0 = nodeWidth * checkNotNull_1(castToDouble(portContext.port.getProperty(PORT_RATIO_OR_POSITION)));
    portContext.portPosition.y_0 = (port = portContext.port , port.hasProperty(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))?port.getSide() == ($clinit_PortSide() , NORTH_1)?-port.getSize().y_0 - checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):port.getSide() == ($clinit_PortSide() , NORTH_1)?-port.getSize().y_0:0);
  }
}

function placeHorizontalFreePorts(nodeContext, portSide){
  var additionalSpaceBetweenPorts, availableSpace, calculatedPortPlacementWidth, currentXPos, insidePortLabelCell, insidePortLabelCellPadding, insidePortLabelCellRectangle, port, portAlignment, portContext, portContext$iterator, spaceBetweenPorts;
  if (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).isEmpty()) {
    return;
  }
  insidePortLabelCell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  insidePortLabelCellRectangle = insidePortLabelCell.cellRectangle;
  insidePortLabelCellPadding = insidePortLabelCell.padding;
  portAlignment = $getPortAlignment(nodeContext, portSide);
  availableSpace = insidePortLabelCellRectangle.width_0 - insidePortLabelCellPadding.left - insidePortLabelCellPadding.right;
  calculatedPortPlacementWidth = insidePortLabelCell.minimumContentAreaSize.x_0;
  currentXPos = insidePortLabelCellRectangle.x_0 + insidePortLabelCellPadding.left;
  spaceBetweenPorts = nodeContext.portPortSpacing;
  if ((portAlignment == ($clinit_PortAlignment() , DISTRIBUTED) || portAlignment == JUSTIFIED) && castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() == 1) {
    calculatedPortPlacementWidth = portAlignment == DISTRIBUTED?calculatedPortPlacementWidth - 2 * nodeContext.portPortSpacing:calculatedPortPlacementWidth;
    portAlignment = CENTER_5;
  }
  if (availableSpace < calculatedPortPlacementWidth && !nodeContext.sizeOptions.contains(($clinit_SizeOptions() , PORTS_OVERHANG))) {
    if (portAlignment == DISTRIBUTED) {
      spaceBetweenPorts += (availableSpace - calculatedPortPlacementWidth) / (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() + 1);
      currentXPos += spaceBetweenPorts;
    }
     else {
      spaceBetweenPorts += (availableSpace - calculatedPortPlacementWidth) / (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() - 1);
    }
  }
   else {
    if (availableSpace < calculatedPortPlacementWidth) {
      calculatedPortPlacementWidth = portAlignment == DISTRIBUTED?calculatedPortPlacementWidth - 2 * nodeContext.portPortSpacing:calculatedPortPlacementWidth;
      portAlignment = CENTER_5;
    }
    switch (portAlignment.ordinal) {
      case 3:
        currentXPos += (availableSpace - calculatedPortPlacementWidth) / 2;
        break;
      case 4:
        currentXPos += availableSpace - calculatedPortPlacementWidth;
        break;
      case 0:
        additionalSpaceBetweenPorts = (availableSpace - calculatedPortPlacementWidth) / (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() + 1);
        spaceBetweenPorts += $wnd.Math.max(0, additionalSpaceBetweenPorts);
        currentXPos += spaceBetweenPorts;
        break;
      case 1:
        additionalSpaceBetweenPorts = (availableSpace - calculatedPortPlacementWidth) / (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() - 1);
        spaceBetweenPorts += $wnd.Math.max(0, additionalSpaceBetweenPorts);
    }
  }
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    portContext.portPosition.x_0 = currentXPos + portContext.portMargin.left;
    portContext.portPosition.y_0 = (port = portContext.port , port.hasProperty(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))?port.getSide() == ($clinit_PortSide() , NORTH_1)?-port.getSize().y_0 - checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):port.getSide() == ($clinit_PortSide() , NORTH_1)?-port.getSize().y_0:0);
    currentXPos += portContext.portMargin.left + portContext.port.getSize().x_0 + portContext.portMargin.right + spaceBetweenPorts;
  }
}

function placeHorizontalPorts(nodeContext){
  $clinit_PortPlacementCalculator();
  switch (nodeContext.portConstraints.ordinal) {
    case 5:
      placeHorizontalFixedPosPorts(nodeContext, ($clinit_PortSide() , NORTH_1));
      placeHorizontalFixedPosPorts(nodeContext, SOUTH_1);
      break;
    case 4:
      placeHorizontalFixedRatioPorts(nodeContext, ($clinit_PortSide() , NORTH_1));
      placeHorizontalFixedRatioPorts(nodeContext, SOUTH_1);
      break;
    default:placeHorizontalFreePorts(nodeContext, ($clinit_PortSide() , NORTH_1));
      placeHorizontalFreePorts(nodeContext, SOUTH_1);
  }
}

function placeVerticalFixedPosPorts(nodeContext, portSide){
  var nodeWidth, port, portContext, portContext$iterator;
  nodeWidth = nodeContext.nodeSize.x_0;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    portContext.portPosition.x_0 = (port = portContext.port , port.hasProperty(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))?port.getSide() == ($clinit_PortSide() , WEST_1)?-port.getSize().x_0 - checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):nodeWidth + checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):port.getSide() == ($clinit_PortSide() , WEST_1)?-port.getSize().x_0:nodeWidth);
  }
}

function placeVerticalFixedRatioPorts(nodeContext, portSide){
  var nodeSize, portContext, portContext$iterator;
  nodeSize = nodeContext.nodeSize;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    portContext.portPosition.x_0 = calculateVerticalPortXCoordinate(portContext, nodeSize.x_0);
    portContext.portPosition.y_0 = nodeSize.y_0 * checkNotNull_1(castToDouble(portContext.port.getProperty(PORT_RATIO_OR_POSITION)));
  }
}

function placeVerticalFreePorts(nodeContext, portSide){
  var additionalSpaceBetweenPorts, availableSpace, calculatedPortPlacementHeight, currentYPos, insidePortLabelCell, insidePortLabelCellPadding, insidePortLabelCellRectangle, nodeWidth, port, portAlignment, portContext, portContext$iterator, spaceBetweenPorts;
  if (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).isEmpty()) {
    return;
  }
  insidePortLabelCell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  insidePortLabelCellRectangle = insidePortLabelCell.cellRectangle;
  insidePortLabelCellPadding = insidePortLabelCell.padding;
  portAlignment = $getPortAlignment(nodeContext, portSide);
  availableSpace = insidePortLabelCellRectangle.height - insidePortLabelCellPadding.top_0 - insidePortLabelCellPadding.bottom;
  calculatedPortPlacementHeight = insidePortLabelCell.minimumContentAreaSize.y_0;
  currentYPos = insidePortLabelCellRectangle.y_0 + insidePortLabelCellPadding.top_0;
  spaceBetweenPorts = nodeContext.portPortSpacing;
  nodeWidth = nodeContext.nodeSize.x_0;
  if ((portAlignment == ($clinit_PortAlignment() , DISTRIBUTED) || portAlignment == JUSTIFIED) && castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() == 1) {
    calculatedPortPlacementHeight = portAlignment == DISTRIBUTED?calculatedPortPlacementHeight - 2 * nodeContext.portPortSpacing:calculatedPortPlacementHeight;
    portAlignment = CENTER_5;
  }
  if (availableSpace < calculatedPortPlacementHeight && !nodeContext.sizeOptions.contains(($clinit_SizeOptions() , PORTS_OVERHANG))) {
    if (portAlignment == DISTRIBUTED) {
      spaceBetweenPorts += (availableSpace - calculatedPortPlacementHeight) / (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() + 1);
      currentYPos += spaceBetweenPorts;
    }
     else {
      spaceBetweenPorts += (availableSpace - calculatedPortPlacementHeight) / (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() - 1);
    }
  }
   else {
    if (availableSpace < calculatedPortPlacementHeight) {
      calculatedPortPlacementHeight = portAlignment == DISTRIBUTED?calculatedPortPlacementHeight - 2 * nodeContext.portPortSpacing:calculatedPortPlacementHeight;
      portAlignment = CENTER_5;
    }
    switch (portAlignment.ordinal) {
      case 3:
        currentYPos += (availableSpace - calculatedPortPlacementHeight) / 2;
        break;
      case 4:
        currentYPos += availableSpace - calculatedPortPlacementHeight;
        break;
      case 0:
        additionalSpaceBetweenPorts = (availableSpace - calculatedPortPlacementHeight) / (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() + 1);
        spaceBetweenPorts += $wnd.Math.max(0, additionalSpaceBetweenPorts);
        currentYPos += spaceBetweenPorts;
        break;
      case 1:
        additionalSpaceBetweenPorts = (availableSpace - calculatedPortPlacementHeight) / (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() - 1);
        spaceBetweenPorts += $wnd.Math.max(0, additionalSpaceBetweenPorts);
    }
  }
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    portContext.portPosition.x_0 = (port = portContext.port , port.hasProperty(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))?port.getSide() == ($clinit_PortSide() , WEST_1)?-port.getSize().x_0 - checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):nodeWidth + checkNotNull_1(castToDouble(port.getProperty(PORT_BORDER_OFFSET_0))):port.getSide() == ($clinit_PortSide() , WEST_1)?-port.getSize().x_0:nodeWidth);
    portContext.portPosition.y_0 = currentYPos + portContext.portMargin.top_0;
    currentYPos += portContext.portMargin.top_0 + portContext.port.getSize().y_0 + portContext.portMargin.bottom + spaceBetweenPorts;
  }
}

function placeVerticalPorts(nodeContext){
  $clinit_PortPlacementCalculator();
  switch (nodeContext.portConstraints.ordinal) {
    case 5:
      placeVerticalFixedPosPorts(nodeContext, ($clinit_PortSide() , EAST_1));
      placeVerticalFixedPosPorts(nodeContext, WEST_1);
      break;
    case 4:
      placeVerticalFixedRatioPorts(nodeContext, ($clinit_PortSide() , EAST_1));
      placeVerticalFixedRatioPorts(nodeContext, WEST_1);
      break;
    default:placeVerticalFreePorts(nodeContext, ($clinit_PortSide() , EAST_1));
      placeVerticalFreePorts(nodeContext, WEST_1);
  }
}

var PORT_RATIO_OR_POSITION;
function calculateVerticalNodeSizeRequiredByFixedPosPorts(nodeContext, portSide){
  var bottommostPortBorder, cell, portContext, portContext$iterator;
  bottommostPortBorder = 0;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    bottommostPortBorder = $wnd.Math.max(bottommostPortBorder, portContext.portPosition.y_0 + portContext.port.getSize().y_0);
  }
  cell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  cell.padding.top_0 = 0;
  cell.minimumContentAreaSize.y_0 = bottommostPortBorder;
}

function calculateVerticalNodeSizeRequiredByFixedRatioPorts(nodeContext, portSide){
  var cell, currentPortContext, currentPortHeight, currentPortRatio, includePortLabels, minHeight, portContextIterator, portContexts, portLabelsInside, previousPortContext, previousPortHeight, previousPortRatio, requiredSpace, spaceEfficientPortLabels;
  cell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  portContexts = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62);
  if (portContexts.isEmpty()) {
    cell.padding.top_0 = 0;
    cell.padding.bottom = 0;
    return;
  }
  includePortLabels = nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , PORT_LABELS));
  spaceEfficientPortLabels = nodeContext.sizeOptions.contains(($clinit_SizeOptions() , SPACE_EFFICIENT_PORT_LABELS));
  portLabelsInside = nodeContext.portLabelsPlacement == ($clinit_PortLabelPlacement() , INSIDE_0);
  minHeight = 0;
  portContextIterator = portContexts.iterator_0();
  previousPortContext = null;
  previousPortRatio = 0;
  previousPortHeight = 0;
  while (portContextIterator.hasNext_0()) {
    currentPortContext = castTo(portContextIterator.next_1(), 112);
    currentPortRatio = checkNotNull_1(castToDouble(currentPortContext.port.getProperty(($clinit_PortPlacementCalculator() , PORT_RATIO_OR_POSITION))));
    currentPortHeight = currentPortContext.port.getSize().y_0;
    includePortLabels && setVerticalPortMargins(nodeContext, portSide, 0, portLabelsInside, !portLabelsInside && spaceEfficientPortLabels);
    if (!previousPortContext) {
      !!nodeContext.surroundingPortMargins && nodeContext.surroundingPortMargins.top_0 > 0 && (minHeight = $wnd.Math.max(minHeight, minSizeRequiredToRespectSpacing(nodeContext.surroundingPortMargins.top_0 + currentPortContext.portMargin.top_0, currentPortRatio)));
    }
     else {
      requiredSpace = previousPortHeight + previousPortContext.portMargin.bottom + nodeContext.portPortSpacing + currentPortContext.portMargin.top_0;
      minHeight = $wnd.Math.max(minHeight, ($clinit_DoubleMath() , checkNonNegative($intern_96) , $wnd.Math.abs(previousPortRatio - currentPortRatio) <= $intern_96 || previousPortRatio == currentPortRatio || isNaN(previousPortRatio) && isNaN(currentPortRatio)?0:requiredSpace / (currentPortRatio - previousPortRatio)));
    }
    previousPortContext = currentPortContext;
    previousPortRatio = currentPortRatio;
    previousPortHeight = currentPortHeight;
  }
  if (!!nodeContext.surroundingPortMargins && nodeContext.surroundingPortMargins.bottom > 0) {
    requiredSpace = previousPortHeight + nodeContext.surroundingPortMargins.bottom;
    portLabelsInside && (requiredSpace += previousPortContext.portMargin.bottom);
    minHeight = $wnd.Math.max(minHeight, ($clinit_DoubleMath() , checkNonNegative($intern_96) , $wnd.Math.abs(previousPortRatio - 1) <= $intern_96 || previousPortRatio == 1 || isNaN(previousPortRatio) && isNaN(1)?0:requiredSpace / (1 - previousPortRatio)));
  }
  cell.padding.top_0 = 0;
  cell.minimumContentAreaSize.y_0 = minHeight;
}

function calculateVerticalNodeSizeRequiredByFreePorts(nodeContext, portSide){
  var cell, height, includePortLabels, maxLabelHeight, maxPortAndLabelHeight, portLabelsOutside, ports, spaceEfficientPortLabels, twoPorts, uniformPortSpacing;
  cell = castTo($get_10(nodeContext.insidePortLabelCells, portSide), 117);
  if (castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).isEmpty()) {
    cell.padding.top_0 = 0;
    cell.padding.bottom = 0;
    return;
  }
  cell.padding.top_0 = nodeContext.surroundingPortMargins.top_0;
  cell.padding.bottom = nodeContext.surroundingPortMargins.bottom;
  includePortLabels = nodeContext.sizeConstraints.contains(($clinit_SizeConstraint() , PORT_LABELS));
  twoPorts = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1() == 2;
  portLabelsOutside = nodeContext.portLabelsPlacement == ($clinit_PortLabelPlacement() , OUTSIDE_0);
  spaceEfficientPortLabels = nodeContext.sizeOptions.contains(($clinit_SizeOptions() , SPACE_EFFICIENT_PORT_LABELS));
  uniformPortSpacing = nodeContext.sizeOptions.contains(UNIFORM_PORT_SPACING);
  height = 0;
  if (!includePortLabels || twoPorts && portLabelsOutside) {
    height = portHeightPlusPortPortSpacing(nodeContext, portSide, false, false);
  }
   else if (portLabelsOutside) {
    if (uniformPortSpacing) {
      maxLabelHeight = maximumPortLabelHeight(nodeContext, portSide, spaceEfficientPortLabels);
      maxLabelHeight > 0 && setVerticalPortMargins(nodeContext, portSide, maxLabelHeight, false, false);
      height = portHeightPlusPortPortSpacing(nodeContext, portSide, true, false);
    }
     else {
      setVerticalPortMargins(nodeContext, portSide, 0, false, spaceEfficientPortLabels);
      height = portHeightPlusPortPortSpacing(nodeContext, portSide, true, false);
    }
  }
   else {
    if (uniformPortSpacing) {
      ports = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).size_1();
      maxPortAndLabelHeight = maximumPortAndLabelHeight(nodeContext, portSide);
      height = maxPortAndLabelHeight * ports + nodeContext.portPortSpacing * (ports - 1);
      maxPortAndLabelHeight > 0 && setVerticalPortMargins(nodeContext, portSide, maxPortAndLabelHeight, true, false);
    }
     else {
      setVerticalPortMargins(nodeContext, portSide, 0, true, false);
      height = portHeightPlusPortPortSpacing(nodeContext, portSide, true, true);
    }
  }
  $getPortAlignment(nodeContext, portSide) == ($clinit_PortAlignment() , DISTRIBUTED) && (height += 2 * nodeContext.portPortSpacing);
  cell.minimumContentAreaSize.y_0 = height;
}

function calculateVerticalPortPlacementSize(nodeContext){
  switch (nodeContext.portConstraints.ordinal) {
    case 5:
      calculateVerticalNodeSizeRequiredByFixedPosPorts(nodeContext, ($clinit_PortSide() , EAST_1));
      calculateVerticalNodeSizeRequiredByFixedPosPorts(nodeContext, WEST_1);
      break;
    case 4:
      calculateVerticalNodeSizeRequiredByFixedRatioPorts(nodeContext, ($clinit_PortSide() , EAST_1));
      calculateVerticalNodeSizeRequiredByFixedRatioPorts(nodeContext, WEST_1);
      break;
    default:calculateVerticalNodeSizeRequiredByFreePorts(nodeContext, ($clinit_PortSide() , EAST_1));
      calculateVerticalNodeSizeRequiredByFreePorts(nodeContext, WEST_1);
  }
}

function maximumPortAndLabelHeight(nodeContext, portSide){
  var labelHeight, labelPlusPortHeight, maxResult, portContext, portContext$iterator;
  maxResult = 0;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    labelHeight = $getMinimumHeight_0(portContext.portLabelCell);
    $clinit_NodeLabelAndSizeUtilities();
    if (portContext.parentNodeContext.treatAsCompoundNode && (!checkNotNull_1(castToBoolean(portContext.parentNodeContext.node.getProperty(($clinit_CoreOptions() , PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE_0)))) || portContext.port.hasCompoundConnections())) {
      maxResult = $wnd.Math.max(maxResult, labelHeight);
      maxResult = $wnd.Math.max(maxResult, portContext.port.getSize().y_0);
    }
     else {
      labelPlusPortHeight = portContext.port.getSize().y_0 + nodeContext.portLabelSpacing + labelHeight;
      maxResult = $wnd.Math.max(maxResult, labelPlusPortHeight);
    }
  }
  return maxResult;
}

function maximumPortLabelHeight(nodeContext, portSide, ignoreFirstPort){
  var currLabelHeight, ignore, labelCellHeights, maxLabelHeight;
  ignore = ignoreFirstPort;
  labelCellHeights = $iterator_3($mapToDouble(castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).stream(), new VerticalPortPlacementSizeCalculator$lambda$0$Type));
  maxLabelHeight = 0;
  while (labelCellHeights.hasElement || (labelCellHeights.hasElement = $tryAdvance_1(labelCellHeights.spliterator, labelCellHeights)) , labelCellHeights.hasElement) {
    if (ignore) {
      $nextDouble_0(labelCellHeights);
      ignore = false;
      continue;
    }
     else {
      currLabelHeight = $nextDouble_0(labelCellHeights);
      labelCellHeights.hasElement || (labelCellHeights.hasElement = $tryAdvance_1(labelCellHeights.spliterator, labelCellHeights));
      labelCellHeights.hasElement && (maxLabelHeight = $wnd.Math.max(maxLabelHeight, currLabelHeight));
    }
  }
  return maxLabelHeight;
}

function portHeightPlusPortPortSpacing(nodeContext, portSide, includeMargins, includeMarginsOfLastPort){
  var portContext, portContextIterator, result;
  result = 0;
  portContextIterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0();
  while (portContextIterator.hasNext_0()) {
    portContext = castTo(portContextIterator.next_1(), 112);
    result += portContext.port.getSize().y_0;
    includeMargins && (portContextIterator.hasNext_0() || includeMarginsOfLastPort) && (result += portContext.portMargin.top_0 + portContext.portMargin.bottom);
    portContextIterator.hasNext_0() && (result += nodeContext.portPortSpacing);
  }
  return result;
}

function setVerticalPortMargins(nodeContext, portSide, uniformLabelHeight, insidePortLabels, excludeFirstPort){
  var exclude, labelHeight, overhang, portContext, portContext$iterator, portHeight;
  exclude = excludeFirstPort;
  for (portContext$iterator = castTo(castTo($get_0(nodeContext.portContexts, portSide), 19), 62).iterator_0(); portContext$iterator.hasNext_0();) {
    portContext = castTo(portContext$iterator.next_1(), 112);
    if (exclude) {
      exclude = false;
      continue;
    }
    labelHeight = 0;
    uniformLabelHeight > 0?(labelHeight = uniformLabelHeight):!!portContext.portLabelCell && (labelHeight = $getMinimumHeight_0(portContext.portLabelCell));
    if (labelHeight > 0) {
      if (!insidePortLabels || ($clinit_NodeLabelAndSizeUtilities() , portContext.parentNodeContext.treatAsCompoundNode && (!checkNotNull_1(castToBoolean(portContext.parentNodeContext.node.getProperty(($clinit_CoreOptions() , PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE_0)))) || portContext.port.hasCompoundConnections()))) {
        portContext.portMargin.bottom = nodeContext.portLabelSpacing + labelHeight;
      }
       else {
        portHeight = portContext.port.getSize().y_0;
        if (labelHeight > portHeight) {
          overhang = (labelHeight - portHeight) / 2;
          portContext.portMargin.top_0 = overhang;
          portContext.portMargin.bottom = overhang;
        }
      }
    }
  }
}

function VerticalPortPlacementSizeCalculator$lambda$0$Type(){
}

defineClass(1355, 1, {}, VerticalPortPlacementSizeCalculator$lambda$0$Type);
_.applyAsDouble = function applyAsDouble_2(arg0){
  return !castTo(arg0, 112).portLabelCell?0:$getMinimumHeight_0(castTo(arg0, 112).portLabelCell);
}
;
var Lorg_eclipse_elk_alg_common_nodespacing_internal_algorithm_VerticalPortPlacementSizeCalculator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.nodespacing.internal.algorithm', 'VerticalPortPlacementSizeCalculator/lambda$0$Type', 1355);
function $removeOverlaps(overlapRemover){
  var alreadyPlacedNodes, currNode, currNode$iterator, currRect, gap, overlapNode, overlapNode$iterator, overlapRect, stripSize, yPos;
  gap = overlapRemover.gap;
  alreadyPlacedNodes = new HashSet;
  stripSize = 0;
  for (currNode$iterator = new ArrayList$1(overlapRemover.rectangleNodes); currNode$iterator.i < currNode$iterator.this$01.array.length;) {
    currNode = castTo($next_10(currNode$iterator), 198);
    yPos = 0;
    $sort_0(currNode.overlappingNodes, new GreedyRectangleStripOverlapRemover$0methodref$compareByYCoordinate$Type);
    for (overlapNode$iterator = $listIterator_1(currNode.overlappingNodes, 0); overlapNode$iterator.currentNode != overlapNode$iterator.this$01.tail;) {
      overlapNode = castTo($next_13(overlapNode$iterator), 198);
      if (alreadyPlacedNodes.map_0.containsKey(overlapNode)) {
        currRect = currNode.rectangle;
        overlapRect = overlapNode.rectangle;
        yPos < overlapRect.y_0 + overlapRect.height + gap && yPos + currRect.height + gap > overlapRect.y_0 && (yPos = overlapRect.y_0 + overlapRect.height + gap);
      }
    }
    currNode.rectangle.y_0 = yPos;
    alreadyPlacedNodes.map_0.put(currNode, alreadyPlacedNodes);
    stripSize = $wnd.Math.max(stripSize, currNode.rectangle.y_0 + currNode.rectangle.height);
  }
  return stripSize;
}

function GreedyRectangleStripOverlapRemover(){
}

function compareByYCoordinate(node1, node2){
  return compare_5(node1.rectangle.y_0, node2.rectangle.y_0);
}

defineClass(1618, 1, {}, GreedyRectangleStripOverlapRemover);
var Lorg_eclipse_elk_alg_common_overlaps_GreedyRectangleStripOverlapRemover_2_classLit = createForClass('org.eclipse.elk.alg.common.overlaps', 'GreedyRectangleStripOverlapRemover', 1618);
function GreedyRectangleStripOverlapRemover$0methodref$compareByYCoordinate$Type(){
}

defineClass(1619, 1, $intern_40, GreedyRectangleStripOverlapRemover$0methodref$compareByYCoordinate$Type);
_.equals_0 = function equals_68(other){
  return this === other;
}
;
_.reversed = function reversed_10(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_18(arg0, arg1){
  return compareByYCoordinate(castTo(arg0, 198), castTo(arg1, 198));
}
;
var Lorg_eclipse_elk_alg_common_overlaps_GreedyRectangleStripOverlapRemover$0methodref$compareByYCoordinate$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.overlaps', 'GreedyRectangleStripOverlapRemover/0methodref$compareByYCoordinate$Type', 1619);
function $computeOverlaps(this$static){
  var currNode, currNode$iterator, entry, entryIterator, intersectingNode, intersectingNode$iterator, intersectingNodes, intersectingRectangle, scanlinePos;
  intersectingNodes = new TreeSet_0(castTo(checkNotNull(new RectangleStripOverlapRemover$1methodref$compareRightRectangleBorders$Type), 59));
  for (currNode$iterator = new ArrayList$1(this$static.rectangleNodes); currNode$iterator.i < currNode$iterator.this$01.array.length;) {
    currNode = castTo($next_10(currNode$iterator), 198);
    scanlinePos = currNode.rectangle.x_0;
    while (intersectingNodes.map_0.size_0 != 0) {
      intersectingRectangle = castTo(getKeyOrNSE($getFirstEntry(intersectingNodes.map_0)), 198);
      if (intersectingRectangle.rectangle.x_0 + intersectingRectangle.rectangle.width_0 < scanlinePos) {
        $remove_26(intersectingNodes.map_0, intersectingRectangle) != null;
      }
       else {
        break;
      }
    }
    for (intersectingNode$iterator = (entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet((new AbstractNavigableMap$NavigableKeySet(intersectingNodes.map_0)).map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator)); $hasNext_1(intersectingNode$iterator.val$entryIterator2.iter);) {
      intersectingNode = (entry = $next_14(intersectingNode$iterator.val$entryIterator2) , castTo(entry.getKey(), 198));
      $add_7(intersectingNode.overlappingNodes, currNode);
      $add_7(currNode.overlappingNodes, intersectingNode);
    }
    $put_7(intersectingNodes.map_0, currNode, ($clinit_Boolean() , FALSE_0)) == null;
  }
}

function $exportRectangle(this$static, rectangleNode){
  var originalRectangle, rectangle;
  rectangle = rectangleNode.rectangle;
  originalRectangle = rectangleNode.originalRectangle;
  switch (this$static.overlapRemovalDirection.ordinal) {
    case 0:
      originalRectangle.y_0 = this$static.startCoordinate - rectangle.height - rectangle.y_0;
      break;
    case 1:
      originalRectangle.y_0 += this$static.startCoordinate;
      break;
    case 2:
      originalRectangle.x_0 = this$static.startCoordinate - rectangle.height - rectangle.y_0;
      break;
    case 3:
      originalRectangle.x_0 = this$static.startCoordinate + rectangle.y_0;
  }
}

function $importRectangle(this$static, rectangle){
  switch (this$static.overlapRemovalDirection.ordinal) {
    case 0:
    case 1:
      return rectangle;
    case 2:
    case 3:
      return new ElkRectangle_0(rectangle.y_0, 0, rectangle.height, rectangle.width_0);
    default:return null;
  }
}

function $removeOverlaps_0(this$static){
  var stripSize;
  !this$static.overlapRemovalStrategy && (this$static.overlapRemovalStrategy = new GreedyRectangleStripOverlapRemover);
  $sort(this$static.rectangleNodes, new RectangleStripOverlapRemover$0methodref$compareLeftRectangleBorders$Type);
  $computeOverlaps(this$static);
  stripSize = $removeOverlaps(this$static);
  $forEach_2(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.rectangleNodes, 16)), new RectangleStripOverlapRemover$lambda$0$Type(this$static));
  return stripSize;
}

function $withGap(this$static, theGap){
  this$static.gap = theGap;
  return this$static;
}

function $withStartCoordinate(this$static, coordinate){
  this$static.startCoordinate = coordinate;
  return this$static;
}

function RectangleStripOverlapRemover(){
  this.rectangleNodes = new ArrayList;
}

function compareLeftRectangleBorders(rn1, rn2){
  return compare_5(rn1.rectangle.x_0, rn2.rectangle.x_0);
}

function compareRightRectangleBorders(rn1, rn2){
  return compare_5(rn1.rectangle.x_0 + rn1.rectangle.width_0, rn2.rectangle.x_0 + rn2.rectangle.width_0);
}

function createForDirection(direction){
  var remover;
  remover = new RectangleStripOverlapRemover;
  remover.overlapRemovalDirection = direction;
  return remover;
}

defineClass(1595, 1, {}, RectangleStripOverlapRemover);
_.gap = 5;
_.startCoordinate = 0;
var Lorg_eclipse_elk_alg_common_overlaps_RectangleStripOverlapRemover_2_classLit = createForClass('org.eclipse.elk.alg.common.overlaps', 'RectangleStripOverlapRemover', 1595);
function RectangleStripOverlapRemover$0methodref$compareLeftRectangleBorders$Type(){
}

defineClass(1596, 1, $intern_40, RectangleStripOverlapRemover$0methodref$compareLeftRectangleBorders$Type);
_.equals_0 = function equals_69(other){
  return this === other;
}
;
_.reversed = function reversed_11(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_19(arg0, arg1){
  return compareLeftRectangleBorders(castTo(arg0, 198), castTo(arg1, 198));
}
;
var Lorg_eclipse_elk_alg_common_overlaps_RectangleStripOverlapRemover$0methodref$compareLeftRectangleBorders$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.overlaps', 'RectangleStripOverlapRemover/0methodref$compareLeftRectangleBorders$Type', 1596);
function RectangleStripOverlapRemover$1methodref$compareRightRectangleBorders$Type(){
}

defineClass(1598, 1, $intern_40, RectangleStripOverlapRemover$1methodref$compareRightRectangleBorders$Type);
_.equals_0 = function equals_70(other){
  return this === other;
}
;
_.reversed = function reversed_12(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_20(arg0, arg1){
  return compareRightRectangleBorders(castTo(arg0, 198), castTo(arg1, 198));
}
;
var Lorg_eclipse_elk_alg_common_overlaps_RectangleStripOverlapRemover$1methodref$compareRightRectangleBorders$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.overlaps', 'RectangleStripOverlapRemover/1methodref$compareRightRectangleBorders$Type', 1598);
function $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection(){
  $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection = emptyMethod;
  UP = new RectangleStripOverlapRemover$OverlapRemovalDirection('UP', 0);
  DOWN = new RectangleStripOverlapRemover$OverlapRemovalDirection('DOWN', 1);
  LEFT_0 = new RectangleStripOverlapRemover$OverlapRemovalDirection('LEFT', 2);
  RIGHT_0 = new RectangleStripOverlapRemover$OverlapRemovalDirection('RIGHT', 3);
}

function RectangleStripOverlapRemover$OverlapRemovalDirection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_21(name_0){
  $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection();
  return valueOf(($clinit_RectangleStripOverlapRemover$OverlapRemovalDirection$Map() , $MAP_9), name_0);
}

function values_17(){
  $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_overlaps_RectangleStripOverlapRemover$OverlapRemovalDirection_2_classLit, 1), $intern_38, 389, 0, [UP, DOWN, LEFT_0, RIGHT_0]);
}

defineClass(389, 22, {3:1, 34:1, 22:1, 389:1}, RectangleStripOverlapRemover$OverlapRemovalDirection);
var DOWN, LEFT_0, RIGHT_0, UP;
var Lorg_eclipse_elk_alg_common_overlaps_RectangleStripOverlapRemover$OverlapRemovalDirection_2_classLit = createForEnum('org.eclipse.elk.alg.common.overlaps', 'RectangleStripOverlapRemover/OverlapRemovalDirection', 389, Ljava_lang_Enum_2_classLit, values_17, valueOf_21);
function $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection$Map(){
  $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection$Map = emptyMethod;
  $MAP_9 = createValueOfMap(($clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_overlaps_RectangleStripOverlapRemover$OverlapRemovalDirection_2_classLit, 1), $intern_38, 389, 0, [UP, DOWN, LEFT_0, RIGHT_0])));
}

var $MAP_9;
function RectangleStripOverlapRemover$RectangleNode(originalRectangle, rectangle){
  this.overlappingNodes = new LinkedList;
  this.originalRectangle = originalRectangle;
  this.rectangle = rectangle;
}

defineClass(198, 1, {198:1}, RectangleStripOverlapRemover$RectangleNode);
var Lorg_eclipse_elk_alg_common_overlaps_RectangleStripOverlapRemover$RectangleNode_2_classLit = createForClass('org.eclipse.elk.alg.common.overlaps', 'RectangleStripOverlapRemover/RectangleNode', 198);
function RectangleStripOverlapRemover$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1597, 1, {}, RectangleStripOverlapRemover$lambda$0$Type);
_.accept = function accept_44(arg0){
  $exportRectangle(this.$$outer_0, castTo(arg0, 198));
}
;
var Lorg_eclipse_elk_alg_common_overlaps_RectangleStripOverlapRemover$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.overlaps', 'RectangleStripOverlapRemover/lambda$0$Type', 1597);
function $packPolyominoes(polyHolder){
  var grid, next, offX, offY, poly, poly$iterator, polys, successorBasedOnCost;
  polys = polyHolder.polys;
  grid = polyHolder.grid;
  switch (castTo($getProperty(polyHolder, ($clinit_PolyominoOptions() , POLYOMINO_LOW_LEVEL_SORT)), 406).ordinal) {
    case 0:
      $sort(polys, new Comparators$ReversedComparator(new PolyominoCompactor$MinPerimeterComparator));
      break;
    case 1:
    default:$sort(polys, new Comparators$ReversedComparator(new PolyominoCompactor$MinPerimeterComparatorWithShape));
  }
  switch (castTo($getProperty(polyHolder, POLYOMINO_HIGH_LEVEL_SORT), 407).ordinal) {
    case 1:
      $sort(polys, new PolyominoCompactor$MinNumOfExtensionsComparator);
      $sort(polys, new PolyominoCompactor$SingleExtensionSideGreaterThanRestComparator);
      $sort(polys, new PolyominoCompactor$CornerCasesGreaterThanRestComparator);
      break;
    case 0:
    default:$sort(polys, new PolyominoCompactor$MinNumOfExtensionsComparator);
      $sort(polys, new PolyominoCompactor$MinNumOfExtensionDirectionsComparator);
  }
  switch (castTo($getProperty(polyHolder, POLYOMINO_TRAVERSAL_STRATEGY), 237).ordinal) {
    case 0:
      successorBasedOnCost = new SuccessorMaxNormWindingInMathPosSense;
      break;
    case 1:
      successorBasedOnCost = new SuccessorLineByLine;
      break;
    case 2:
      successorBasedOnCost = new SuccessorManhattan;
      break;
    case 3:
      successorBasedOnCost = new SuccessorJitter;
      break;
    case 5:
      successorBasedOnCost = new SuccessorQuadrantsGeneric(new SuccessorManhattan);
      break;
    case 4:
      successorBasedOnCost = new SuccessorQuadrantsGeneric(new SuccessorLineByLine);
      break;
    case 7:
      successorBasedOnCost = new SuccessorCombination(new SuccessorQuadrantsGeneric(new SuccessorLineByLine), new SuccessorQuadrantsGeneric(new SuccessorManhattan));
      break;
    case 8:
      successorBasedOnCost = new SuccessorCombination(new SuccessorQuadrantsGeneric(new SuccessorJitter), new SuccessorQuadrantsGeneric(new SuccessorManhattan));
      break;
    case 6:
    default:successorBasedOnCost = new SuccessorQuadrantsGeneric(new SuccessorJitter);
  }
  for (poly$iterator = new ArrayList$1(polys); poly$iterator.i < poly$iterator.this$01.array.length;) {
    poly = castTo($next_10(poly$iterator), 158);
    offX = 0;
    offY = 0;
    next = new Pair(valueOf_4(0), valueOf_4(0));
    while ($intersectsWithCenterBased_0(grid, poly, offX, offY)) {
      next = castTo(successorBasedOnCost.apply_2(next, poly), 37);
      offX = castTo(next.first, 21).value_0;
      offY = castTo(next.second, 21).value_0;
    }
    $addFilledCellsFrom_0(grid, poly, offX, offY);
  }
}

function $compare_2(o1, o2){
  var detectDirections, dirSet, numDir1, numDir2;
  detectDirections = new PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$0$Type;
  dirSet = castTo($collect_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(o1.polyominoExtensions, 16)), detectDirections), of_2(new Collectors$23methodref$ctor$Type, new Collectors$24methodref$add$Type, new Collectors$lambda$25$Type, new Collectors$lambda$26$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , UNORDERED), IDENTITY_FINISH]))), 19);
  numDir1 = dirSet.size_1();
  numDir1 = numDir1 == 2?1:0;
  numDir1 == 1 && eq(mod(castTo($collect_0($filter(dirSet.parallelStream(), new PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$1$Type), reducing(valueOf_5(0), new Collectors$lambda$1$Type)), 152).value_0, 2), 0) && (numDir1 = 0);
  dirSet = castTo($collect_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(o2.polyominoExtensions, 16)), detectDirections), of_2(new Collectors$23methodref$ctor$Type, new Collectors$24methodref$add$Type, new Collectors$lambda$25$Type, new Collectors$lambda$26$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [UNORDERED, IDENTITY_FINISH]))), 19);
  numDir2 = dirSet.size_1();
  numDir2 = numDir2 == 2?1:0;
  numDir2 == 1 && eq(mod(castTo($collect_0($filter(dirSet.parallelStream(), new PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$2$Type), reducing(valueOf_5(0), new Collectors$lambda$1$Type)), 152).value_0, 2), 0) && (numDir2 = 0);
  if (numDir1 < numDir2) {
    return -1;
  }
  if (numDir1 == numDir2) {
    return 0;
  }
  return 1;
}

function PolyominoCompactor$CornerCasesGreaterThanRestComparator(){
}

defineClass(1188, 1, $intern_40, PolyominoCompactor$CornerCasesGreaterThanRestComparator);
_.compare_0 = function compare_21(o1, o2){
  return $compare_2(castTo(o1, 158), castTo(o2, 158));
}
;
_.equals_0 = function equals_71(other){
  return this === other;
}
;
_.reversed = function reversed_13(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$CornerCasesGreaterThanRestComparator_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/CornerCasesGreaterThanRestComparator', 1188);
function PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$0$Type(){
}

defineClass(1191, 1, $intern_11, PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$0$Type);
_.apply_0 = function apply_33(arg0){
  return castTo(arg0, 313).first;
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/CornerCasesGreaterThanRestComparator/lambda$0$Type', 1191);
function PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$1$Type(){
}

defineClass(1192, 1, $intern_90, PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$1$Type);
_.test_0 = function test_8(arg0){
  return castTo(arg0, 311).horizontal;
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/CornerCasesGreaterThanRestComparator/lambda$1$Type', 1192);
function PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$2$Type(){
}

defineClass(1193, 1, $intern_90, PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$2$Type);
_.test_0 = function test_9(arg0){
  return castTo(arg0, 311).horizontal;
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$CornerCasesGreaterThanRestComparator$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/CornerCasesGreaterThanRestComparator/lambda$2$Type', 1193);
function $compare_3(o1, o2){
  var detectDirections, dirSet, numDir1, numDir2;
  detectDirections = new PolyominoCompactor$MinNumOfExtensionDirectionsComparator$lambda$0$Type;
  dirSet = castTo($collect_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(o1.polyominoExtensions, 16)), detectDirections), of_2(new Collectors$23methodref$ctor$Type, new Collectors$24methodref$add$Type, new Collectors$lambda$25$Type, new Collectors$lambda$26$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , UNORDERED), IDENTITY_FINISH]))), 19);
  numDir1 = dirSet.size_1();
  dirSet = castTo($collect_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(o2.polyominoExtensions, 16)), detectDirections), of_2(new Collectors$23methodref$ctor$Type, new Collectors$24methodref$add$Type, new Collectors$lambda$25$Type, new Collectors$lambda$26$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [UNORDERED, IDENTITY_FINISH]))), 19);
  numDir2 = dirSet.size_1();
  if (numDir1 < numDir2) {
    return -1;
  }
  if (numDir1 == numDir2) {
    return 0;
  }
  return 1;
}

function PolyominoCompactor$MinNumOfExtensionDirectionsComparator(){
}

defineClass(1186, 1, $intern_40, PolyominoCompactor$MinNumOfExtensionDirectionsComparator);
_.compare_0 = function compare_22(o1, o2){
  return $compare_3(castTo(o1, 158), castTo(o2, 158));
}
;
_.equals_0 = function equals_72(other){
  return this === other;
}
;
_.reversed = function reversed_14(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$MinNumOfExtensionDirectionsComparator_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/MinNumOfExtensionDirectionsComparator', 1186);
function PolyominoCompactor$MinNumOfExtensionDirectionsComparator$lambda$0$Type(){
}

defineClass(1189, 1, $intern_11, PolyominoCompactor$MinNumOfExtensionDirectionsComparator$lambda$0$Type);
_.apply_0 = function apply_34(arg0){
  return castTo(arg0, 313).first;
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$MinNumOfExtensionDirectionsComparator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/MinNumOfExtensionDirectionsComparator/lambda$0$Type', 1189);
function $compare_4(o1, o2){
  var numExt1, numExt2;
  numExt1 = o1.polyominoExtensions.array.length;
  numExt2 = o2.polyominoExtensions.array.length;
  if (numExt1 < numExt2) {
    return -1;
  }
  if (numExt1 == numExt2) {
    return 0;
  }
  return 1;
}

function PolyominoCompactor$MinNumOfExtensionsComparator(){
}

defineClass(713, 1, $intern_40, PolyominoCompactor$MinNumOfExtensionsComparator);
_.compare_0 = function compare_23(o1, o2){
  return $compare_4(castTo(o1, 158), castTo(o2, 158));
}
;
_.equals_0 = function equals_73(other){
  return this === other;
}
;
_.reversed = function reversed_15(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$MinNumOfExtensionsComparator_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/MinNumOfExtensionsComparator', 713);
function $compare_5(o1, o2){
  var halfPeri1, halfPeri2;
  halfPeri1 = o1.xSize + o1.ySize;
  halfPeri2 = o2.xSize + o2.ySize;
  if (halfPeri1 < halfPeri2) {
    return -1;
  }
  if (halfPeri1 == halfPeri2) {
    return 0;
  }
  return 1;
}

function PolyominoCompactor$MinPerimeterComparator(){
}

defineClass(1184, 1, $intern_40, PolyominoCompactor$MinPerimeterComparator);
_.compare_0 = function compare_24(o1, o2){
  return $compare_5(castTo(o1, 310), castTo(o2, 310));
}
;
_.equals_0 = function equals_74(other){
  return this === other;
}
;
_.reversed = function reversed_16(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$MinPerimeterComparator_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/MinPerimeterComparator', 1184);
function $compare_6(o1, o2){
  var height, val1, val2, width_0;
  width_0 = o1.xSize;
  height = o1.ySize;
  width_0 < height?(width_0 *= width_0):(height *= height);
  val1 = width_0 + height;
  width_0 = o2.xSize;
  height = o2.ySize;
  width_0 < height?(width_0 *= width_0):(height *= height);
  val2 = width_0 + height;
  if (val1 < val2) {
    return -1;
  }
  if (val1 == val2) {
    return 0;
  }
  return 1;
}

function PolyominoCompactor$MinPerimeterComparatorWithShape(){
}

defineClass(1185, 1, $intern_40, PolyominoCompactor$MinPerimeterComparatorWithShape);
_.compare_0 = function compare_25(o1, o2){
  return $compare_6(castTo(o1, 310), castTo(o2, 310));
}
;
_.equals_0 = function equals_75(other){
  return this === other;
}
;
_.reversed = function reversed_17(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$MinPerimeterComparatorWithShape_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/MinPerimeterComparatorWithShape', 1185);
function $compare_7(o1, o2){
  var detectDirections, dirSet, numDir1, numDir2;
  detectDirections = new PolyominoCompactor$SingleExtensionSideGreaterThanRestComparator$lambda$0$Type;
  dirSet = castTo($collect_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(o1.polyominoExtensions, 16)), detectDirections), of_2(new Collectors$23methodref$ctor$Type, new Collectors$24methodref$add$Type, new Collectors$lambda$25$Type, new Collectors$lambda$26$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , UNORDERED), IDENTITY_FINISH]))), 19);
  numDir1 = dirSet.size_1();
  dirSet = castTo($collect_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(o2.polyominoExtensions, 16)), detectDirections), of_2(new Collectors$23methodref$ctor$Type, new Collectors$24methodref$add$Type, new Collectors$lambda$25$Type, new Collectors$lambda$26$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [UNORDERED, IDENTITY_FINISH]))), 19);
  numDir2 = dirSet.size_1();
  numDir1 = numDir1 == 1?1:0;
  numDir2 = numDir2 == 1?1:0;
  if (numDir1 < numDir2) {
    return -1;
  }
  if (numDir1 == numDir2) {
    return 0;
  }
  return 1;
}

function PolyominoCompactor$SingleExtensionSideGreaterThanRestComparator(){
}

defineClass(1187, 1, $intern_40, PolyominoCompactor$SingleExtensionSideGreaterThanRestComparator);
_.compare_0 = function compare_26(o1, o2){
  return $compare_7(castTo(o1, 158), castTo(o2, 158));
}
;
_.equals_0 = function equals_76(other){
  return this === other;
}
;
_.reversed = function reversed_18(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$SingleExtensionSideGreaterThanRestComparator_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/SingleExtensionSideGreaterThanRestComparator', 1187);
function PolyominoCompactor$SingleExtensionSideGreaterThanRestComparator$lambda$0$Type(){
}

defineClass(1190, 1, $intern_11, PolyominoCompactor$SingleExtensionSideGreaterThanRestComparator$lambda$0$Type);
_.apply_0 = function apply_35(arg0){
  return castTo(arg0, 313).first;
}
;
var Lorg_eclipse_elk_alg_common_polyomino_PolyominoCompactor$SingleExtensionSideGreaterThanRestComparator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'PolyominoCompactor/SingleExtensionSideGreaterThanRestComparator/lambda$0$Type', 1190);
function fillPolyomino(poly){
  var eastProfile, height, northProfile, southProfile, westProfile, width_0, x_0, xi, xi0, xi1, y_0, yi, yi0, yi1;
  width_0 = poly.xSize;
  northProfile = initUnidimensionalArray(I_classLit, $intern_49, 23, width_0, 15, 1);
  southProfile = initUnidimensionalArray(I_classLit, $intern_49, 23, width_0, 15, 1);
  height = poly.ySize;
  eastProfile = initUnidimensionalArray(I_classLit, $intern_49, 23, height, 15, 1);
  westProfile = initUnidimensionalArray(I_classLit, $intern_49, 23, height, 15, 1);
  for (xi0 = 0; xi0 < width_0; xi0++) {
    y_0 = 0;
    while (y_0 < height && !$isBlocked(poly, xi0, y_0)) {
      ++y_0;
    }
    northProfile[xi0] = y_0;
  }
  for (xi1 = 0; xi1 < width_0; xi1++) {
    y_0 = height - 1;
    while (y_0 >= 0 && !$isBlocked(poly, xi1, y_0)) {
      --y_0;
    }
    southProfile[xi1] = y_0;
  }
  for (yi0 = 0; yi0 < height; yi0++) {
    x_0 = 0;
    while (x_0 < width_0 && !$isBlocked(poly, x_0, yi0)) {
      ++x_0;
    }
    eastProfile[yi0] = x_0;
  }
  for (yi1 = 0; yi1 < height; yi1++) {
    x_0 = width_0 - 1;
    while (x_0 >= 0 && !$isBlocked(poly, x_0, yi1)) {
      --x_0;
    }
    westProfile[yi1] = x_0;
  }
  for (xi = 0; xi < width_0; xi++) {
    for (yi = 0; yi < height; yi++) {
      xi < westProfile[yi] && xi > eastProfile[yi] && yi < southProfile[xi] && yi > northProfile[xi] && $set_5(poly, xi, yi, false, true);
    }
  }
}

function $apply_3(this$static, coords, poly){
  return poly.polyominoExtensions.array.length > 0?$apply_8(this$static.externalFun, coords, poly):$apply_8(this$static.normalFun, coords, poly);
}

function SuccessorCombination(normalFun, externalFun){
  this.normalFun = normalFun;
  this.externalFun = externalFun;
}

defineClass(714, 1, {}, SuccessorCombination);
_.apply_2 = function apply_36(coords, poly){
  return $apply_3(this, castTo(coords, 37), castTo(poly, 158));
}
;
var Lorg_eclipse_elk_alg_common_polyomino_SuccessorCombination_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'SuccessorCombination', 714);
function $apply_4(coords){
  var cost, newX, newY, x_0, y_0;
  x_0 = castTo(coords.first, 21).value_0;
  y_0 = castTo(coords.second, 21).value_0;
  cost = (x_0 < 0?-x_0:x_0) > (y_0 < 0?-y_0:y_0)?x_0 < 0?-x_0:x_0:y_0 < 0?-y_0:y_0;
  if (x_0 <= 0 && x_0 == y_0) {
    newX = 0;
    newY = y_0 - 1;
  }
   else {
    if (x_0 == -cost && y_0 != cost) {
      newX = y_0;
      newY = x_0;
      y_0 >= 0 && ++newX;
    }
     else {
      newX = -y_0;
      newY = x_0;
    }
  }
  return new Pair(valueOf_4(newX), valueOf_4(newY));
}

function SuccessorJitter(){
}

defineClass(603, 1, {}, SuccessorJitter);
_.apply_2 = function apply_37(coords, poly){
  var lastArg;
  return $apply_4((lastArg = castTo(coords, 37) , castTo(poly, 158) , lastArg));
}
;
var Lorg_eclipse_elk_alg_common_polyomino_SuccessorJitter_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'SuccessorJitter', 603);
function $apply_5(coords){
  var x_0, y_0;
  x_0 = castTo(coords.first, 21).value_0;
  y_0 = castTo(coords.second, 21).value_0;
  if (x_0 >= 0) {
    if (x_0 == y_0) {
      return new Pair(valueOf_4(-x_0 - 1), valueOf_4(-x_0 - 1));
    }
    if (x_0 == -y_0) {
      return new Pair(valueOf_4(-x_0), valueOf_4(y_0 + 1));
    }
  }
  if ((x_0 < 0?-x_0:x_0) > (y_0 < 0?-y_0:y_0)) {
    if (x_0 < 0) {
      return new Pair(valueOf_4(-x_0), valueOf_4(y_0));
    }
    return new Pair(valueOf_4(-x_0), valueOf_4(y_0 + 1));
  }
  return new Pair(valueOf_4(x_0 + 1), valueOf_4(y_0));
}

function SuccessorLineByLine(){
}

defineClass(602, 1, {}, SuccessorLineByLine);
_.apply_2 = function apply_38(coords, poly){
  var lastArg;
  return $apply_5((lastArg = castTo(coords, 37) , castTo(poly, 158) , lastArg));
}
;
var Lorg_eclipse_elk_alg_common_polyomino_SuccessorLineByLine_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'SuccessorLineByLine', 602);
function $apply_6(coords){
  var newX, newY, x_0, y_0;
  x_0 = castTo(coords.first, 21).value_0;
  y_0 = castTo(coords.second, 21).value_0;
  newX = x_0;
  newY = y_0;
  if (x_0 == 0 && y_0 == 0) {
    newY -= 1;
  }
   else {
    if (x_0 == -1 && y_0 <= 0) {
      newX = 0;
      newY -= 2;
    }
     else {
      if (x_0 <= 0 && y_0 > 0) {
        newX -= 1;
        newY -= 1;
      }
       else {
        if (x_0 >= 0 && y_0 < 0) {
          newX += 1;
          newY += 1;
        }
         else {
          if (x_0 > 0 && y_0 >= 0) {
            newX -= 1;
            newY += 1;
          }
           else {
            newX += 1;
            newY -= 1;
          }
        }
      }
    }
  }
  return new Pair(valueOf_4(newX), valueOf_4(newY));
}

function SuccessorManhattan(){
}

defineClass(532, 1, {}, SuccessorManhattan);
_.apply_2 = function apply_39(coords, poly){
  var lastArg;
  return $apply_6((lastArg = castTo(coords, 37) , castTo(poly, 158) , lastArg));
}
;
var Lorg_eclipse_elk_alg_common_polyomino_SuccessorManhattan_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'SuccessorManhattan', 532);
function $apply_7(coords){
  var cost, x_0, y_0;
  x_0 = castTo(coords.first, 21).value_0;
  y_0 = castTo(coords.second, 21).value_0;
  cost = (x_0 < 0?-x_0:x_0) > (y_0 < 0?-y_0:y_0)?x_0 < 0?-x_0:x_0:y_0 < 0?-y_0:y_0;
  if (x_0 < cost && y_0 == -cost) {
    return new Pair(valueOf_4(x_0 + 1), valueOf_4(y_0));
  }
  if (x_0 == cost && y_0 < cost) {
    return new Pair(valueOf_4(x_0), valueOf_4(y_0 + 1));
  }
  if (x_0 >= -cost && y_0 == cost) {
    return new Pair(valueOf_4(x_0 - 1), valueOf_4(y_0));
  }
  return new Pair(valueOf_4(x_0), valueOf_4(y_0 - 1));
}

function SuccessorMaxNormWindingInMathPosSense(){
}

defineClass(1214, 1, {}, SuccessorMaxNormWindingInMathPosSense);
_.apply_2 = function apply_40(coords, poly){
  var lastArg;
  return $apply_7((lastArg = castTo(coords, 37) , castTo(poly, 158) , lastArg));
}
;
var Lorg_eclipse_elk_alg_common_polyomino_SuccessorMaxNormWindingInMathPosSense_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'SuccessorMaxNormWindingInMathPosSense', 1214);
function $apply_8(this$static, coords, poly){
  return $apply_9(this$static, castTo(coords, 37), castTo(poly, 158));
}

function $apply_9(this$static, coords, poly){
  var containsNeg, containsPos, detectDirections, dirSet, invalid, newX, newY, nextCoords;
  if (!equals_Ljava_lang_Object__Z__devirtual$(poly, this$static.lastPoly)) {
    this$static.lastPoly = poly;
    detectDirections = new SuccessorQuadrantsGeneric$lambda$0$Type;
    dirSet = castTo($collect_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(poly.polyominoExtensions, 16)), detectDirections), of_2(new Collectors$23methodref$ctor$Type, new Collectors$24methodref$add$Type, new Collectors$lambda$25$Type, new Collectors$lambda$26$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , UNORDERED), IDENTITY_FINISH]))), 19);
    this$static.posX = true;
    this$static.posY = true;
    this$static.negX = true;
    this$static.negY = true;
    containsPos = dirSet.contains(($clinit_Direction() , NORTH));
    containsNeg = dirSet.contains(SOUTH);
    containsPos && !containsNeg && (this$static.posY = false);
    !containsPos && containsNeg && (this$static.negY = false);
    containsPos = dirSet.contains(EAST);
    containsNeg = dirSet.contains(WEST);
    containsPos && !containsNeg && (this$static.negX = false);
    !containsPos && containsNeg && (this$static.posX = false);
  }
  nextCoords = castTo(this$static.costFun.apply_2(coords, poly), 37);
  newX = castTo(nextCoords.first, 21).value_0;
  newY = castTo(nextCoords.second, 21).value_0;
  invalid = false;
  newX < 0?this$static.negX || (invalid = true):this$static.posX || (invalid = true);
  newY < 0?this$static.negY || (invalid = true):this$static.posY || (invalid = true);
  return invalid?$apply_9(this$static, nextCoords, poly):nextCoords;
}

function SuccessorQuadrantsGeneric(costFun){
  this.costFun = costFun;
}

defineClass(383, 1, {}, SuccessorQuadrantsGeneric);
_.apply_2 = function apply_41(coords, poly){
  return $apply_8(this, coords, poly);
}
;
_.negX = false;
_.negY = false;
_.posX = false;
_.posY = false;
var Lorg_eclipse_elk_alg_common_polyomino_SuccessorQuadrantsGeneric_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'SuccessorQuadrantsGeneric', 383);
function SuccessorQuadrantsGeneric$lambda$0$Type(){
}

defineClass(1215, 1, $intern_11, SuccessorQuadrantsGeneric$lambda$0$Type);
_.apply_0 = function apply_42(arg0){
  return castTo(arg0, 313).first;
}
;
var Lorg_eclipse_elk_alg_common_polyomino_SuccessorQuadrantsGeneric$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino', 'SuccessorQuadrantsGeneric/lambda$0$Type', 1215);
function $clinit_Direction(){
  $clinit_Direction = emptyMethod;
  NORTH = new Direction('NORTH', 0);
  EAST = new Direction('EAST', 1);
  SOUTH = new Direction('SOUTH', 2);
  WEST = new Direction('WEST', 3);
  NORTH.horizontal = false;
  EAST.horizontal = true;
  SOUTH.horizontal = false;
  WEST.horizontal = true;
}

function Direction(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_22(name_0){
  $clinit_Direction();
  return valueOf(($clinit_Direction$Map() , $MAP_10), name_0);
}

function values_18(){
  $clinit_Direction();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_polyomino_structures_Direction_2_classLit, 1), $intern_38, 311, 0, [NORTH, EAST, SOUTH, WEST]);
}

defineClass(311, 22, {3:1, 34:1, 22:1, 311:1}, Direction);
_.horizontal = false;
var EAST, NORTH, SOUTH, WEST;
var Lorg_eclipse_elk_alg_common_polyomino_structures_Direction_2_classLit = createForEnum('org.eclipse.elk.alg.common.polyomino.structures', 'Direction', 311, Ljava_lang_Enum_2_classLit, values_18, valueOf_22);
function $clinit_Direction$Map(){
  $clinit_Direction$Map = emptyMethod;
  $MAP_10 = createValueOfMap(($clinit_Direction() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_polyomino_structures_Direction_2_classLit, 1), $intern_38, 311, 0, [NORTH, EAST, SOUTH, WEST])));
}

var $MAP_10;
function $incModTen(num){
  if (num > 8) {
    return 0;
  }
  return num + 1;
}

function $isBlocked(this$static, x_0, y_0){
  try {
    return eq($retrieve(this$static, x_0, y_0), 1);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 312)) {
      throw toJs(new IndexOutOfBoundsException_0('Grid is only of size ' + this$static.xSize + '*' + this$static.ySize + '. Requested point (' + x_0 + ', ' + y_0 + ') is out of bounds.'));
    }
     else 
      throw toJs($e0);
  }
}

function $isEmpty_0(this$static, x_0, y_0){
  try {
    return eq($retrieve(this$static, x_0, y_0), 0);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 312)) {
      throw toJs(new IndexOutOfBoundsException_0('Grid is only of size ' + this$static.xSize + '*' + this$static.ySize + '. Requested point (' + x_0 + ', ' + y_0 + ') is out of bounds.'));
    }
     else 
      throw toJs($e0);
  }
}

function $isWeaklyBlocked(this$static, x_0, y_0){
  try {
    return eq($retrieve(this$static, x_0, y_0), 2);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 312)) {
      throw toJs(new IndexOutOfBoundsException_0('Grid is only of size ' + this$static.xSize + '*' + this$static.ySize + '. Requested point (' + x_0 + ', ' + y_0 + ') is out of bounds.'));
    }
     else 
      throw toJs($e0);
  }
}

function $retrieve(this$static, x_0, y_0){
  var value_0, xRest, xWord;
  xWord = x_0 >> 5;
  xRest = x_0 & 31;
  value_0 = and_0(shru_0(this$static.grid[y_0][xWord], toInt_0(shl_0(xRest, 1))), 3);
  return value_0;
}

function $set_5(this$static, x_0, y_0, msb, lsb){
  var mask, xRest, xWord;
  try {
    if (x_0 >= this$static.xSize) {
      throw toJs(new ArrayIndexOutOfBoundsException);
    }
    xWord = x_0 >> 5;
    xRest = x_0 & 31;
    mask = shl_0(1, toInt_0(shl_0(xRest, 1)));
    lsb?(this$static.grid[y_0][xWord] = or_0(this$static.grid[y_0][xWord], mask)):(this$static.grid[y_0][xWord] = and_0(this$static.grid[y_0][xWord], not_0(mask)));
    mask = shl_0(mask, 1);
    msb?(this$static.grid[y_0][xWord] = or_0(this$static.grid[y_0][xWord], mask)):(this$static.grid[y_0][xWord] = and_0(this$static.grid[y_0][xWord], not_0(mask)));
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 312)) {
      throw toJs(new IndexOutOfBoundsException_0('Grid is only of size ' + this$static.xSize + '*' + this$static.ySize + '. Requested point (' + x_0 + ', ' + y_0 + ') is out of bounds.'));
    }
     else 
      throw toJs($e0);
  }
}

defineClass(1182, 1, {});
_.toString_0 = function toString_76(){
  var count, item_0, output, x_0, x0, y_0;
  output = ' ';
  count = valueOf_4(0);
  for (x0 = 0; x0 < this.xSize; x0++) {
    output += '' + count.value_0;
    count = valueOf_4($incModTen(count.value_0));
  }
  output += '\n';
  count = valueOf_4(0);
  for (y_0 = 0; y_0 < this.ySize; y_0++) {
    output += '' + count.value_0;
    count = valueOf_4($incModTen(count.value_0));
    for (x_0 = 0; x_0 < this.xSize; x_0++) {
      item_0 = $retrieve(this, x_0, y_0);
      compare_3(item_0, 0) == 0?(output += '_'):compare_3(item_0, 1) == 0?(output += 'X'):(output += '0');
    }
    output += '\n';
  }
  return $substring_1(output, 0, output.length - 1);
}
;
_.xSize = 0;
_.ySize = 0;
var Lorg_eclipse_elk_alg_common_polyomino_structures_TwoBitGrid_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino.structures', 'TwoBitGrid', 1182);
function $addFilledCellsFrom(this$static, other, xOffset, yOffset){
  var x_0, xTranslated, y_0, yTranslated;
  for (x_0 = 0; x_0 < other.xSize; x_0++) {
    xTranslated = x_0 - other.xCenter + xOffset;
    for (y_0 = 0; y_0 < other.ySize; y_0++) {
      yTranslated = y_0 - other.yCenter + yOffset;
      $isBlocked(other, x_0, y_0)?$isWeaklyBlockedCenterBased(this$static, xTranslated, yTranslated) || $setBlockedCenterBased(this$static, xTranslated, yTranslated):$isWeaklyBlocked(other, x_0, y_0) && ($isBlockedCenterBased(this$static, xTranslated, yTranslated) || $setWeaklyBlockedCenterBased(this$static, xTranslated, yTranslated));
    }
  }
}

function $addFilledCellsFrom_0(this$static, other, xOffset, yOffset){
  var ext, ext$iterator;
  $addFilledCellsFrom(this$static, other, xOffset, yOffset);
  $setX(other, this$static.xCenter - other.xCenter + xOffset);
  $setY(other, this$static.yCenter - other.yCenter + yOffset);
  for (ext$iterator = new ArrayList$1(other.polyominoExtensions); ext$iterator.i < ext$iterator.this$01.array.length;) {
    ext = castTo($next_10(ext$iterator), 313);
    switch (ext.first.ordinal) {
      case 0:
        $weaklyBlockArea(this$static, other.x_0 + ext.second.value_0, 0, other.x_0 + ext.third.value_0, other.y_0 - 1);
        break;
      case 1:
        $weaklyBlockArea(this$static, other.x_0 + other.xSize, other.y_0 + ext.second.value_0, this$static.xSize - 1, other.y_0 + ext.third.value_0);
        break;
      case 2:
        $weaklyBlockArea(this$static, other.x_0 + ext.second.value_0, other.y_0 + other.ySize, other.x_0 + ext.third.value_0, this$static.ySize - 1);
        break;
      default:$weaklyBlockArea(this$static, 0, other.y_0 + ext.second.value_0, other.x_0 - 1, other.y_0 + ext.third.value_0);
    }
  }
}

function $getFilledBounds(this$static){
  var gridHeight, gridWidth, height, maxX, maxY, minX, minY, width_0, xi, yi;
  gridWidth = this$static.xSize;
  gridHeight = this$static.ySize;
  minX = $intern_0;
  maxX = $intern_43;
  minY = $intern_0;
  maxY = $intern_43;
  for (xi = 0; xi < gridWidth; ++xi) {
    for (yi = 0; yi < gridHeight; ++yi) {
      if ($isBlocked(this$static, xi, yi)) {
        minX = minX < xi?minX:xi;
        maxX = maxX > xi?maxX:xi;
        minY = minY < yi?minY:yi;
        maxY = maxY > yi?maxY:yi;
      }
    }
  }
  width_0 = maxX - minX + 1;
  height = maxY - minY + 1;
  return new Quadruple(valueOf_4(minX), valueOf_4(minY), valueOf_4(width_0), valueOf_4(height));
}

function $intersectsWithCenterBased(this$static, other, xOffset, yOffset){
  var x_0, xTranslated, y_0, yTranslated, xt, yt;
  for (x_0 = 0; x_0 < other.xSize; x_0++) {
    xTranslated = x_0 - other.xCenter + xOffset;
    for (y_0 = 0; y_0 < other.ySize; y_0++) {
      yTranslated = y_0 - other.yCenter + yOffset;
      if ((xt = xTranslated , yt = yTranslated , xt += this$static.xCenter , yt += this$static.yCenter , xt >= 0 && yt >= 0 && xt < this$static.xSize && yt < this$static.ySize) && (!$isEmpty_0(other, x_0, y_0) && $isBlockedCenterBased(this$static, xTranslated, yTranslated) || $isBlocked(other, x_0, y_0) && !$isEmptyCenterBased(this$static, xTranslated, yTranslated))) {
        return true;
      }
    }
  }
  return false;
}

function $intersectsWithCenterBased_0(this$static, other, xOffset, yOffset){
  var bottomY, ext, ext$iterator, intersects, leftX, rightX, topY;
  if ($intersectsWithCenterBased(this$static, other, xOffset, yOffset)) {
    return true;
  }
   else {
    for (ext$iterator = new ArrayList$1(other.polyominoExtensions); ext$iterator.i < ext$iterator.this$01.array.length;) {
      ext = castTo($next_10(ext$iterator), 313);
      leftX = this$static.xCenter - other.xCenter + xOffset;
      rightX = leftX + other.xSize;
      topY = this$static.yCenter - other.yCenter + yOffset;
      bottomY = topY + other.ySize;
      switch (ext.first.ordinal) {
        case 0:
          intersects = $weaklyIntersectsArea(this$static, leftX + ext.second.value_0, 0, leftX + ext.third.value_0, topY - 1);
          break;
        case 1:
          intersects = $weaklyIntersectsArea(this$static, rightX, topY + ext.second.value_0, this$static.xSize - 1, topY + ext.third.value_0);
          break;
        case 2:
          intersects = $weaklyIntersectsArea(this$static, leftX + ext.second.value_0, bottomY, leftX + ext.third.value_0, this$static.ySize - 1);
          break;
        default:intersects = $weaklyIntersectsArea(this$static, 0, topY + ext.second.value_0, leftX - 1, topY + ext.third.value_0);
      }
      if (intersects) {
        return true;
      }
    }
  }
  return false;
}

function $isBlockedCenterBased(this$static, x_0, y_0){
  var e;
  try {
    return $isBlocked(this$static, x_0 + this$static.xCenter, y_0 + this$static.yCenter);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      e = $e0;
      throw toJs(new IndexOutOfBoundsException_0(e.detailMessage + ' Given center based coordinates were (' + x_0 + ', ' + y_0 + ').'));
    }
     else 
      throw toJs($e0);
  }
}

function $isEmptyCenterBased(this$static, x_0, y_0){
  var e;
  try {
    return $isEmpty_0(this$static, x_0 + this$static.xCenter, y_0 + this$static.yCenter);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      e = $e0;
      throw toJs(new IndexOutOfBoundsException_0(e.detailMessage + ' Given center based coordinates were (' + x_0 + ', ' + y_0 + ').'));
    }
     else 
      throw toJs($e0);
  }
}

function $isWeaklyBlockedCenterBased(this$static, x_0, y_0){
  var e;
  try {
    return $isWeaklyBlocked(this$static, x_0 + this$static.xCenter, y_0 + this$static.yCenter);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      e = $e0;
      throw toJs(new IndexOutOfBoundsException_0(e.detailMessage + ' Given center based coordinates were (' + x_0 + ', ' + y_0 + ').'));
    }
     else 
      throw toJs($e0);
  }
}

function $reinitialize(this$static, width_0, height){
  this$static.grid = initMultidimensionalArray(J_classLit, [$intern_33, $intern_65], [350, 23], 14, [height, round_int($wnd.Math.ceil(width_0 / 32))], 2);
  this$static.xSize = width_0;
  this$static.ySize = height;
  this$static.xCenter = width_0 - 1 >> 1;
  this$static.yCenter = height - 1 >> 1;
}

function $setBlockedCenterBased(this$static, x_0, y_0){
  var e;
  try {
    $set_5(this$static, x_0 + this$static.xCenter, y_0 + this$static.yCenter, false, true);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      e = $e0;
      throw toJs(new IndexOutOfBoundsException_0(e.detailMessage + ' Given center based coordinates were (' + x_0 + ', ' + y_0 + ').'));
    }
     else 
      throw toJs($e0);
  }
}

function $setWeaklyBlockedCenterBased(this$static, x_0, y_0){
  var e;
  try {
    $set_5(this$static, x_0 + this$static.xCenter, y_0 + this$static.yCenter, true, false);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      e = $e0;
      throw toJs(new IndexOutOfBoundsException_0(e.detailMessage + ' Given center based coordinates were (' + x_0 + ', ' + y_0 + ').'));
    }
     else 
      throw toJs($e0);
  }
}

function $weaklyBlockArea(this$static, xUpperLeft, yUpperleft, xBottomRight, yBottomRight){
  var xi, yi;
  for (yi = yUpperleft; yi <= yBottomRight; yi++) {
    for (xi = xUpperLeft; xi <= xBottomRight; xi++) {
      $isBlocked(this$static, xi, yi) || $set_5(this$static, xi, yi, true, false);
    }
  }
}

function $weaklyIntersectsArea(this$static, xUpperLeft, yUpperleft, xBottomRight, yBottomRight){
  var xi, yi;
  for (yi = yUpperleft; yi <= yBottomRight; yi++) {
    for (xi = xUpperLeft; xi <= xBottomRight; xi++) {
      if ($isBlocked(this$static, xi, yi)) {
        return true;
      }
    }
  }
  return false;
}

function PlanarGrid(width_0, height){
  this.grid = initMultidimensionalArray(J_classLit, [$intern_33, $intern_65], [350, 23], 14, [height, round_int($wnd.Math.ceil(width_0 / 32))], 2);
  this.xSize = width_0;
  this.ySize = height;
  this.xCenter = width_0 - 1 >> 1;
  this.yCenter = height - 1 >> 1;
}

defineClass(310, 1182, {310:1}, PlanarGrid);
_.xCenter = 0;
_.yCenter = 0;
var Lorg_eclipse_elk_alg_common_polyomino_structures_PlanarGrid_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino.structures', 'PlanarGrid', 310);
function $setX(this$static, val){
  this$static.x_0 = val;
}

function $setY(this$static, val){
  this$static.y_0 = val;
}

function Polyomino(extensions){
  PlanarGrid.call(this, 0, 0);
  this.polyominoExtensions = extensions;
}

defineClass(158, 310, {310:1, 158:1});
_.x_0 = 0;
_.y_0 = 0;
var Lorg_eclipse_elk_alg_common_polyomino_structures_Polyomino_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino.structures', 'Polyomino', 158);
var Lorg_eclipse_elk_graph_properties_IPropertyHolder_2_classLit = createForInterface('org.eclipse.elk.graph.properties', 'IPropertyHolder');
function $copyProperties(this$static, other){
  var otherMap;
  if (!other) {
    return this$static;
  }
  otherMap = other.getAllProperties();
  otherMap.isEmpty() || (!this$static.propertyMap?(this$static.propertyMap = new HashMap_1(otherMap)):$putAll(this$static.propertyMap, otherMap));
  return this$static;
}

function $getAllProperties(this$static){
  return !this$static.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):this$static.propertyMap;
}

function $getProperty(this$static, property){
  var defaultValue, value_0;
  value_0 = (!this$static.propertyMap && (this$static.propertyMap = ($clinit_Maps() , new HashMap)) , $get_6(this$static.propertyMap, property));
  if (value_0 != null) {
    return value_0;
  }
  defaultValue = property.getDefault();
  instanceOf(defaultValue, 4) && (defaultValue == null?(!this$static.propertyMap && (this$static.propertyMap = ($clinit_Maps() , new HashMap)) , $remove_7(this$static.propertyMap, property)):(!this$static.propertyMap && (this$static.propertyMap = ($clinit_Maps() , new HashMap)) , $put_1(this$static.propertyMap, property, defaultValue)) , this$static);
  return defaultValue;
}

function $hasProperty(this$static, property){
  return !!this$static.propertyMap && $containsKey_2(this$static.propertyMap, property);
}

function $setProperty(this$static, property, value_0){
  return value_0 == null?(!this$static.propertyMap && (this$static.propertyMap = ($clinit_Maps() , new HashMap)) , $remove_7(this$static.propertyMap, property)):(!this$static.propertyMap && (this$static.propertyMap = ($clinit_Maps() , new HashMap)) , $put_1(this$static.propertyMap, property, value_0)) , this$static;
}

function $setProperty_0(this$static, property, value_0){
  value_0 == null?(!this$static.propertyMap && (this$static.propertyMap = ($clinit_Maps() , new HashMap)) , $remove_7(this$static.propertyMap, property)):(!this$static.propertyMap && (this$static.propertyMap = ($clinit_Maps() , new HashMap)) , $put_1(this$static.propertyMap, property, value_0));
  return this$static;
}

function MapPropertyHolder(){
}

defineClass(130, 1, $intern_99, MapPropertyHolder);
_.copyProperties = function copyProperties(other){
  return $copyProperties(this, other);
}
;
_.setProperty = function setProperty(property, value_0){
  return $setProperty(this, property, value_0);
}
;
_.getAllProperties = function getAllProperties(){
  return $getAllProperties(this);
}
;
_.getProperty = function getProperty(property){
  return $getProperty(this, property);
}
;
_.hasProperty = function hasProperty(property){
  return $hasProperty(this, property);
}
;
var Lorg_eclipse_elk_graph_properties_MapPropertyHolder_2_classLit = createForClass('org.eclipse.elk.graph.properties', 'MapPropertyHolder', 130);
function Polyominoes(polys, aspectRatio, fill){
  var gridHeight, gridWidth, poly, poly$iterator;
  this.polys = new ArrayList;
  gridWidth = 0;
  gridHeight = 0;
  for (poly$iterator = new ArrayList$1(polys); poly$iterator.i < poly$iterator.this$01.array.length;) {
    poly = castTo($next_10(poly$iterator), 158);
    fill && fillPolyomino(poly);
    $add_4(this.polys, poly);
    gridWidth += poly.xSize;
    gridHeight += poly.ySize;
  }
  if (this.polys.array.length > 0) {
    poly = castTo($get_7(this.polys, 0), 158);
    gridWidth += poly.xSize;
    gridHeight += poly.ySize;
  }
  gridWidth *= 2;
  gridHeight *= 2;
  aspectRatio > 1?(gridWidth = round_int($wnd.Math.ceil(gridWidth * aspectRatio))):(gridHeight = round_int($wnd.Math.ceil(gridHeight / aspectRatio)));
  this.grid = new PlanarGrid(gridWidth, gridHeight);
}

defineClass(1183, 130, $intern_99, Polyominoes);
var Lorg_eclipse_elk_alg_common_polyomino_structures_Polyominoes_2_classLit = createForClass('org.eclipse.elk.alg.common.polyomino.structures', 'Polyominoes', 1183);
function compact_0(tree, orthogonal){
  svg_0 = new SVGImage;
  orthogonalCompaction = orthogonal;
  root_0 = tree;
  castTo(root_0.node, 58);
  drawTree(root_0, svg_0, null);
  compactTree(root_0);
}

function compactTree(tree){
  var child, child$iterator, compactionVector, minUnderlap, rc, rt;
  $forEach_0(tree.children, new DepthFirstCompaction$0methodref$compactTree$Type);
  for (child$iterator = new ArrayList$1(tree.children); child$iterator.i < child$iterator.this$01.array.length;) {
    child = castTo($next_10(child$iterator), 257);
    compactionVector = $sub_0($clone_0(castTo(tree.node, 58).vertex), castTo(child.node, 58).vertex);
    if (orthogonalCompaction) {
      rt = castTo(tree.node, 58).rect;
      rc = castTo(child.node, 58).rect;
      if ($wnd.Math.abs(compactionVector.x_0) >= $wnd.Math.abs(compactionVector.y_0)) {
        compactionVector.y_0 = 0;
        rc.y_0 + rc.height > rt.y_0 && rc.y_0 < rt.y_0 + rt.height && $scaleToLength(compactionVector, $wnd.Math.max(rt.x_0 - (rc.x_0 + rc.width_0), rc.x_0 - (rt.x_0 + rt.width_0)));
      }
       else {
        compactionVector.x_0 = 0;
        rc.x_0 + rc.width_0 > rt.x_0 && rc.x_0 < rt.x_0 + rt.width_0 && $scaleToLength(compactionVector, $wnd.Math.max(rt.y_0 - (rc.y_0 + rc.height), rc.y_0 - (rt.y_0 + rt.height)));
      }
    }
     else {
      $scaleToLength(compactionVector, $underlap(castTo(tree.node, 58), castTo(child.node, 58)));
    }
    minUnderlap = $wnd.Math.sqrt(compactionVector.x_0 * compactionVector.x_0 + compactionVector.y_0 * compactionVector.y_0);
    minUnderlap = getMinUnderlap(root_0, child, minUnderlap, compactionVector);
    $scaleToLength(compactionVector, minUnderlap);
    $translate(castTo(child.node, 58), compactionVector);
    $forEach_0(child.children, new DepthFirstCompaction$lambda$0$Type(compactionVector));
    castTo(root_0.node, 58);
    drawTree(root_0, svg_0, child);
  }
}

function drawTree(t, svgImage, mark){
  castTo(t.node, 58);
  castTo(t.node, 58);
  castTo(t.node, 58);
  $forEach_0(t.children, new DepthFirstCompaction$lambda$1$Type(mark, svgImage, t));
}

function getMinUnderlap(tree, child, currentMinUnderlap, compactionVector){
  var c, c$iterator, minUnderlap;
  minUnderlap = $wnd.Math.min(currentMinUnderlap, minUnderlapWithSubtree(castTo(tree.node, 58), child, currentMinUnderlap, compactionVector));
  for (c$iterator = new ArrayList$1(tree.children); c$iterator.i < c$iterator.this$01.array.length;) {
    c = castTo($next_10(c$iterator), 257);
    c != child && (minUnderlap = $wnd.Math.min(minUnderlap, getMinUnderlap(c, child, minUnderlap, compactionVector)));
  }
  return minUnderlap;
}

function lambda$0_5(compactionVector_0, c_1){
  $translate(castTo(c_1.node, 58), compactionVector_0);
  $forEach_0(c_1.children, new DepthFirstCompaction$lambda$0$Type(compactionVector_0));
}

function lambda$1_1(mark_0, svgImage_1, t_2, c_3){
  c_3 == mark_0?(castTo(t_2.node, 58) , castTo(t_2.node, 58) , castTo(c_3.node, 58) , castTo(c_3.node, 58).vertex.y_0):(castTo(t_2.node, 58) , castTo(t_2.node, 58) , castTo(c_3.node, 58) , castTo(c_3.node, 58).vertex.y_0);
  drawTree(c_3, svgImage_1, mark_0);
}

function minUnderlapWithSubtree(r, tree, currentMinUnderlap, compactionVector){
  var c, child, child$iterator, minUnderlap;
  minUnderlap = currentMinUnderlap;
  for (child$iterator = new ArrayList$1(tree.children); child$iterator.i < child$iterator.this$01.array.length;) {
    child = castTo($next_10(child$iterator), 257);
    c = castTo(child.node, 58);
    if (fuzzyCompare(r.rect.x_0, c.rect.x_0 + c.rect.width_0) <= 0 && fuzzyCompare(c.rect.x_0, r.rect.x_0 + r.rect.width_0) <= 0 && fuzzyCompare(r.rect.y_0, c.rect.y_0 + c.rect.height) <= 0 && fuzzyCompare(c.rect.y_0, r.rect.y_0 + r.rect.height) <= 0) {
      if (fuzzyCompare(c.rect.x_0, r.rect.x_0 + r.rect.width_0) == 0 && compactionVector.x_0 < 0 || fuzzyCompare(c.rect.x_0 + c.rect.width_0, r.rect.x_0) == 0 && compactionVector.x_0 > 0 || fuzzyCompare(c.rect.y_0, r.rect.y_0 + r.rect.height) == 0 && compactionVector.y_0 < 0 || fuzzyCompare(c.rect.y_0 + c.rect.height, r.rect.y_0) == 0 && compactionVector.y_0 > 0) {
        minUnderlap = 0;
        break;
      }
    }
     else {
      minUnderlap = $wnd.Math.min(minUnderlap, $distance(r, c, compactionVector));
    }
    minUnderlap = $wnd.Math.min(minUnderlap, minUnderlapWithSubtree(r, child, minUnderlap, compactionVector));
  }
  return minUnderlap;
}

var orthogonalCompaction = false, root_0, svg_0;
function DepthFirstCompaction$0methodref$compactTree$Type(){
}

defineClass(1580, 1, {}, DepthFirstCompaction$0methodref$compactTree$Type);
_.accept = function accept_45(arg0){
  compactTree(castTo(arg0, 257));
}
;
var Lorg_eclipse_elk_alg_common_spore_DepthFirstCompaction$0methodref$compactTree$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'DepthFirstCompaction/0methodref$compactTree$Type', 1580);
function DepthFirstCompaction$lambda$0$Type(compactionVector_0){
  this.compactionVector_0 = compactionVector_0;
}

defineClass(750, 1, {}, DepthFirstCompaction$lambda$0$Type);
_.accept = function accept_46(arg0){
  lambda$0_5(this.compactionVector_0, arg0);
}
;
var Lorg_eclipse_elk_alg_common_spore_DepthFirstCompaction$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'DepthFirstCompaction/lambda$0$Type', 750);
function DepthFirstCompaction$lambda$1$Type(mark_0, svgImage_1, t_2){
  this.mark_0 = mark_0;
  this.svgImage_1 = svgImage_1;
  this.t_2 = t_2;
}

defineClass(1581, 1, {}, DepthFirstCompaction$lambda$1$Type);
_.accept = function accept_47(arg0){
  lambda$1_1(this.mark_0, this.svgImage_1, this.t_2, arg0);
}
;
var Lorg_eclipse_elk_alg_common_spore_DepthFirstCompaction$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'DepthFirstCompaction/lambda$1$Type', 1581);
function $clinit_InternalProperties(){
  $clinit_InternalProperties = emptyMethod;
  DEBUG_SVG = new Property_0('debugSVG', ($clinit_Boolean() , $clinit_Boolean() , false));
  OVERLAPS_EXISTED = new Property_0('overlapsExisted', (null , true));
}

var DEBUG_SVG, OVERLAPS_EXISTED;
function $distance(this$static, other, v){
  var distance, e1, e1$iterator, e2, e2$iterator, result;
  result = $intern_62;
  for (e1$iterator = new ArrayList$1(getRectEdges(this$static.rect)); e1$iterator.i < e1$iterator.this$01.array.length;) {
    e1 = castTo($next_10(e1$iterator), 177);
    for (e2$iterator = new ArrayList$1(getRectEdges(other.rect)); e2$iterator.i < e2$iterator.this$01.array.length;) {
      e2 = castTo($next_10(e2$iterator), 177);
      distance = distance_0(e1.u, e1.v, e2.u, e2.v, v);
      result = $wnd.Math.min(result, distance);
    }
  }
  return result;
}

function $setCenterPosition(this$static, p){
  $translate(this$static, $sub_0(new KVector_1(p.x_0, p.y_0), this$static.vertex));
}

function $translate(this$static, v){
  $add_19(this$static.vertex, v);
  this$static.rect.x_0 += v.x_0;
  this$static.rect.y_0 += v.y_0;
}

function $underlap(this$static, other){
  var hScale, horizontalCenterDistance, horizontalUnderlap, scale, vScale, verticalCenterDistance, verticalUnderlap;
  horizontalCenterDistance = $wnd.Math.abs($getCenter(this$static.rect).x_0 - $getCenter(other.rect).x_0);
  verticalCenterDistance = $wnd.Math.abs($getCenter(this$static.rect).y_0 - $getCenter(other.rect).y_0);
  hScale = 1;
  vScale = 1;
  if (horizontalCenterDistance > this$static.rect.width_0 / 2 + other.rect.width_0 / 2) {
    horizontalUnderlap = $wnd.Math.min($wnd.Math.abs(this$static.rect.x_0 - (other.rect.x_0 + other.rect.width_0)), $wnd.Math.abs(this$static.rect.x_0 + this$static.rect.width_0 - other.rect.x_0));
    hScale = 1 - horizontalUnderlap / horizontalCenterDistance;
  }
  if (verticalCenterDistance > this$static.rect.height / 2 + other.rect.height / 2) {
    verticalUnderlap = $wnd.Math.min($wnd.Math.abs(this$static.rect.y_0 - (other.rect.y_0 + other.rect.height)), $wnd.Math.abs(this$static.rect.y_0 + this$static.rect.height - other.rect.y_0));
    vScale = 1 - verticalUnderlap / verticalCenterDistance;
  }
  scale = $wnd.Math.min(hScale, vScale);
  return (1 - scale) * $wnd.Math.sqrt(horizontalCenterDistance * horizontalCenterDistance + verticalCenterDistance * verticalCenterDistance);
}

function Node_0(v, r){
  this.originalVertex = v;
  this.vertex = $clone_0(this.originalVertex);
  this.rect = new ElkRectangle_1(r);
}

defineClass(58, 1, {58:1}, Node_0);
var Lorg_eclipse_elk_alg_common_spore_Node_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'Node', 58);
function $overlap_0(n1, n2){
  if (!n1 || !n2 || n1 == n2) {
    return false;
  }
  return fuzzyCompare(n1.rect.x_0, n2.rect.x_0 + n2.rect.width_0) < 0 && fuzzyCompare(n2.rect.x_0, n1.rect.x_0 + n1.rect.width_0) < 0;
}

function $sweep_0(this$static, nodes){
  var n, n$iterator, overlapsScanlineHandler, points;
  points = new ArrayList;
  for (n$iterator = new ArrayList$1(nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 58);
    $add_4(points, new ScanlineOverlapCheck$Timestamp(n, true));
    $add_4(points, new ScanlineOverlapCheck$Timestamp(n, false));
  }
  overlapsScanlineHandler = new ScanlineOverlapCheck$OverlapsScanlineHandler(this$static);
  $clear_6(overlapsScanlineHandler.intervalsSortLeft.map_0);
  execute(points, this$static.overlapsScanlineComparator, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_Scanline$EventHandler_2_classLit, 1), $intern_1, 635, 0, [overlapsScanlineHandler])));
}

function ScanlineOverlapCheck(oh){
  this.overlapsScanlineComparator = new ScanlineOverlapCheck$lambda$0$Type;
  this.overlapHandler = oh;
}

function lambda$0_6(p1_0, p2_1){
  var cmp, y1, y2;
  y1 = p1_0.node.rect.y_0;
  p1_0.low || (y1 += p1_0.node.rect.height);
  y2 = p2_1.node.rect.y_0;
  p2_1.low || (y2 += p2_1.node.rect.height);
  cmp = compare_5(y1, y2);
  if (cmp == 0) {
    if (!p1_0.low && p2_1.low) {
      return -1;
    }
     else if (!p2_1.low && p1_0.low) {
      return 1;
    }
  }
  return cmp;
}

defineClass(1078, 1, {}, ScanlineOverlapCheck);
var Lorg_eclipse_elk_alg_common_spore_ScanlineOverlapCheck_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'ScanlineOverlapCheck', 1078);
function $handle_0(this$static, p){
  p.low?$insert_2(this$static, p):$remove_28(this$static.intervalsSortLeft, p.node);
}

function $insert_2(this$static, p){
  var entry, entryIterator, other, other$iterator, overlapsFound, success;
  success = $add_10(this$static.intervalsSortLeft, p.node);
  if (!success) {
    throw toJs(new IllegalStateException_0('Invalid hitboxes for scanline overlap calculation.'));
  }
  overlapsFound = false;
  for (other$iterator = (entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet((new AbstractNavigableMap$NavigableKeySet(this$static.intervalsSortLeft.map_0)).map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator)); $hasNext_1(other$iterator.val$entryIterator2.iter);) {
    other = (entry = $next_14(other$iterator.val$entryIterator2) , castTo(entry.getKey(), 58));
    if ($overlap_0(p.node, other)) {
      $handle_4(this$static.this$01.overlapHandler, p.node, other);
      overlapsFound = true;
    }
     else {
      if (overlapsFound) {
        break;
      }
    }
  }
}

function ScanlineOverlapCheck$OverlapsScanlineHandler(this$0){
  this.this$01 = this$0;
  this.intervalsSortLeft = new TreeSet_0(castTo(checkNotNull(new ScanlineOverlapCheck$OverlapsScanlineHandler$lambda$0$Type), 59));
}

function lambda$0_7(n1_0, n2_1){
  var cmp;
  cmp = compare_5(n1_0.rect.x_0, n2_1.rect.x_0);
  if (cmp != 0) {
    return cmp;
  }
  cmp = compare_5(n1_0.originalVertex.x_0, n2_1.originalVertex.x_0);
  if (cmp != 0) {
    return cmp;
  }
  return compare_5(n1_0.originalVertex.y_0, n2_1.originalVertex.y_0);
}

defineClass(1079, 1, {635:1}, ScanlineOverlapCheck$OverlapsScanlineHandler);
_.handle = function handle_0(p){
  $handle_0(this, castTo(p, 515));
}
;
var Lorg_eclipse_elk_alg_common_spore_ScanlineOverlapCheck$OverlapsScanlineHandler_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'ScanlineOverlapCheck/OverlapsScanlineHandler', 1079);
function ScanlineOverlapCheck$OverlapsScanlineHandler$lambda$0$Type(){
}

defineClass(1080, 1, $intern_40, ScanlineOverlapCheck$OverlapsScanlineHandler$lambda$0$Type);
_.equals_0 = function equals_77(other){
  return this === other;
}
;
_.reversed = function reversed_19(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_27(arg0, arg1){
  return lambda$0_7(arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_common_spore_ScanlineOverlapCheck$OverlapsScanlineHandler$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'ScanlineOverlapCheck/OverlapsScanlineHandler/lambda$0$Type', 1080);
function ScanlineOverlapCheck$Timestamp(node, low){
  this.node = node;
  this.low = low;
}

defineClass(515, 1, {515:1}, ScanlineOverlapCheck$Timestamp);
_.low = false;
var Lorg_eclipse_elk_alg_common_spore_ScanlineOverlapCheck$Timestamp_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'ScanlineOverlapCheck/Timestamp', 515);
function ScanlineOverlapCheck$lambda$0$Type(){
}

defineClass(1081, 1, $intern_40, ScanlineOverlapCheck$lambda$0$Type);
_.equals_0 = function equals_78(other){
  return this === other;
}
;
_.reversed = function reversed_20(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_28(arg0, arg1){
  return lambda$0_6(arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_common_spore_ScanlineOverlapCheck$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.common.spore', 'ScanlineOverlapCheck/lambda$0$Type', 1081);
function SVGImage(){
}

defineClass(514, 1, {}, SVGImage);
var Lorg_eclipse_elk_alg_common_utils_SVGImage_2_classLit = createForClass('org.eclipse.elk.alg.common.utils', 'SVGImage', 514);
function UniqueTriple(f, s, t){
  this.first = f;
  this.second = s;
  this.third = t;
}

defineClass(313, 1, {313:1}, UniqueTriple);
_.toString_0 = function toString_77(){
  return '(' + this.first + ', ' + this.second + ', ' + this.third + ')';
}
;
var Lorg_eclipse_elk_alg_common_utils_UniqueTriple_2_classLit = createForClass('org.eclipse.elk.alg.common.utils', 'UniqueTriple', 313);
function getRectEdges(r){
  var rectEdegs;
  rectEdegs = new ArrayList;
  $add_4(rectEdegs, new TEdge(new KVector_1(r.x_0, r.y_0), new KVector_1(r.x_0 + r.width_0, r.y_0)));
  $add_4(rectEdegs, new TEdge(new KVector_1(r.x_0, r.y_0), new KVector_1(r.x_0, r.y_0 + r.height)));
  $add_4(rectEdegs, new TEdge(new KVector_1(r.x_0 + r.width_0, r.y_0 + r.height), new KVector_1(r.x_0 + r.width_0, r.y_0)));
  $add_4(rectEdegs, new TEdge(new KVector_1(r.x_0 + r.width_0, r.y_0 + r.height), new KVector_1(r.x_0, r.y_0 + r.height)));
  return rectEdegs;
}

function overlap(r1, r2){
  var horizontalCenterDistance, horizontalOverlap, verticalCenterDistance, verticalOverlap;
  horizontalOverlap = $wnd.Math.min($wnd.Math.abs(r1.x_0 - (r2.x_0 + r2.width_0)), $wnd.Math.abs(r1.x_0 + r1.width_0 - r2.x_0));
  verticalOverlap = $wnd.Math.min($wnd.Math.abs(r1.y_0 - (r2.y_0 + r2.height)), $wnd.Math.abs(r1.y_0 + r1.height - r2.y_0));
  horizontalCenterDistance = $wnd.Math.abs(r1.x_0 + r1.width_0 / 2 - (r2.x_0 + r2.width_0 / 2));
  if (horizontalCenterDistance > r1.width_0 / 2 + r2.width_0 / 2) {
    return 1;
  }
  verticalCenterDistance = $wnd.Math.abs(r1.y_0 + r1.height / 2 - (r2.y_0 + r2.height / 2));
  if (verticalCenterDistance > r1.height / 2 + r2.height / 2) {
    return 1;
  }
  if (horizontalCenterDistance == 0 && verticalCenterDistance == 0) {
    return 0;
  }
  if (horizontalCenterDistance == 0) {
    return verticalOverlap / verticalCenterDistance + 1;
  }
  if (verticalCenterDistance == 0) {
    return horizontalOverlap / horizontalCenterDistance + 1;
  }
  return $wnd.Math.min(horizontalOverlap / horizontalCenterDistance, verticalOverlap / verticalCenterDistance) + 1;
}

defineClass(197, 1, $intern_100);
var Lorg_eclipse_elk_core_AbstractLayoutProvider_2_classLit = createForClass('org.eclipse.elk.core', 'AbstractLayoutProvider', 197);
function DisCoLayoutProvider(){
}

defineClass($intern_46, 197, $intern_100, DisCoLayoutProvider);
_.layout = function layout(layoutGraph, progressMonitor){
  var lad, layoutProvider, requestedAlgorithm, transformer;
  $begin(progressMonitor, 'Connected Components Compaction', 1);
  this.componentSpacing = checkNotNull_1(castToDouble($getProperty_0(layoutGraph, ($clinit_DisCoOptions() , SPACING_COMPONENT_COMPONENT))));
  if ($hasProperty_0(layoutGraph, COMPONENT_COMPACTION_COMPONENT_LAYOUT_ALGORITHM_0)) {
    requestedAlgorithm = castToString($getProperty_0(layoutGraph, COMPONENT_COMPACTION_COMPONENT_LAYOUT_ALGORITHM_0));
    lad = $getAlgorithmDataBySuffix(getInstance(), requestedAlgorithm);
    if (lad) {
      layoutProvider = castTo($fetch(lad.providerPool), 197);
      layoutProvider.layout(layoutGraph, $subTask(progressMonitor, 1));
    }
  }
  transformer = new ElkGraphTransformer(this.componentSpacing);
  this.result = $importGraph(transformer, layoutGraph);
  switch (castTo($getProperty_0(layoutGraph, ($clinit_DisCoMetaDataProvider() , COMPONENT_COMPACTION_STRATEGY)), 454).ordinal) {
    case 0:
      $compact_0(new DisCoPolyominoCompactor, this.result);
      $setProperty_1(layoutGraph, DEBUG_DISCO_POLYS_0, $getProperty(this.result, DEBUG_DISCO_POLYS_0));
      break;
    default:$clinit_System();
  }
  $applyLayout(transformer);
  $setProperty_1(layoutGraph, DEBUG_DISCO_GRAPH_0, this.result);
  $done_0(progressMonitor);
}
;
_.componentSpacing = 0;
var Lorg_eclipse_elk_alg_disco_DisCoLayoutProvider_2_classLit = createForClass('org.eclipse.elk.alg.disco', 'DisCoLayoutProvider', $intern_46);
function $applyToDCGraph(this$static){
  var absoluteIntPositionX, absoluteIntPositionY, absolutePositionOnCanvas, gridCrop, originalCoordinates, padding, paddingHori, paddingVert, parentHeight, parentWidth, poly, poly$iterator;
  gridCrop = $getFilledBounds(this$static.grid);
  padding = castTo($getProperty(this$static.cmpGraph, ($clinit_DisCoOptions() , PADDING)), 116);
  paddingHori = padding.left + padding.right;
  paddingVert = padding.top_0 + padding.bottom;
  parentWidth = gridCrop.third.value_0 * this$static.gridCellSizeX + paddingHori;
  parentHeight = gridCrop.fourth.value_0 * this$static.gridCellSizeY + paddingVert;
  $setDimensions(this$static.cmpGraph, new KVector_1(parentWidth, parentHeight));
  for (poly$iterator = new ArrayList$1(this$static.polys); poly$iterator.i < poly$iterator.this$01.array.length;) {
    poly = castTo($next_10(poly$iterator), 527);
    absoluteIntPositionX = poly.x_0 - gridCrop.first.value_0;
    absoluteIntPositionY = poly.y_0 - gridCrop.second.value_0;
    absolutePositionOnCanvas = $add_19($scale_0(new KVector_1(absoluteIntPositionX, absoluteIntPositionY), poly.cellSizeX, poly.cellSizeY), $scale($sub($clone_0($getDimensionsOfBoundingRectangle(poly.representee)), poly.pWidth * poly.cellSizeX, poly.pHeight * poly.cellSizeY), -0.5));
    originalCoordinates = $getMinCorner(poly.representee);
    $setOffset(poly.representee, $sub_0(absolutePositionOnCanvas, originalCoordinates));
  }
}

function $compact_0(this$static, graph){
  var gridCellRecommendation;
  this$static.cmpGraph = graph;
  this$static.polys = new ArrayList;
  gridCellRecommendation = $computeCellSize(this$static.cmpGraph);
  this$static.gridCellSizeX = gridCellRecommendation;
  this$static.gridCellSizeY = gridCellRecommendation;
  this$static.fill = checkNotNull_1(castToBoolean($getProperty(this$static.cmpGraph, ($clinit_PolyominoOptions() , POLYOMINO_FILL))));
  this$static.aspectRatio = castToDouble($getProperty(this$static.cmpGraph, ($clinit_CoreOptions() , ASPECT_RATIO_4)));
  this$static.aspectRatio == null && (this$static.aspectRatio = 1);
  checkNotNull_1(this$static.aspectRatio) > 1?(this$static.gridCellSizeX *= checkNotNull_1(this$static.aspectRatio)):(this$static.gridCellSizeY /= checkNotNull_1(this$static.aspectRatio));
  $createPolyominoes(this$static);
  $packPolyominoes_0(this$static);
  $applyToDCGraph(this$static);
  $setProperty_0(this$static.cmpGraph, ($clinit_DisCoOptions() , DEBUG_DISCO_POLYS_0), this$static.polys);
}

function $computeCellSize(graph){
  var bounds, comp, comp$iterator, comps, denominator, height, numOfComps, numerator, prodTerm, sumTerm, width_0;
  sumTerm = 0;
  prodTerm = 0;
  comps = graph.components;
  numOfComps = comps.map_0.size_1();
  for (comp$iterator = comps.map_0.keySet_0().iterator_0(); comp$iterator.hasNext_0();) {
    comp = castTo(comp$iterator.next_1(), 526);
    bounds = (comp.changed && $update(comp) , comp.bounds);
    width_0 = bounds.x_0;
    height = bounds.y_0;
    sumTerm += width_0 + height;
    prodTerm += width_0 * height;
  }
  numerator = $wnd.Math.sqrt(400 * numOfComps * prodTerm - 4 * prodTerm + sumTerm * sumTerm) + sumTerm;
  denominator = 2 * (100 * numOfComps - 1);
  if (denominator == 0) {
    return numerator;
  }
  return numerator / denominator;
}

function $createPolyominoes(this$static){
  var comp, comp$iterator, comps, poly;
  comps = this$static.cmpGraph.components;
  for (comp$iterator = comps.map_0.keySet_0().iterator_0(); comp$iterator.hasNext_0();) {
    comp = castTo(comp$iterator.next_1(), 526);
    poly = new DCPolyomino(comp, this$static.gridCellSizeX, this$static.gridCellSizeY);
    $add_4(this$static.polys, poly);
  }
}

function $packPolyominoes_0(this$static){
  var id_0, poly$iterator, polyHolder;
  id_0 = 0;
  for (poly$iterator = new ArrayList$1(this$static.polys); poly$iterator.i < poly$iterator.this$01.array.length;) {
    castTo($next_10(poly$iterator), 527);
    ++id_0;
  }
  polyHolder = new Polyominoes(this$static.polys, checkNotNull_1(this$static.aspectRatio), this$static.fill);
  $packPolyominoes(polyHolder);
  this$static.polys = polyHolder.polys;
  this$static.grid = polyHolder.grid;
}

function DisCoPolyominoCompactor(){
}

defineClass(1072, 1, {}, DisCoPolyominoCompactor);
_.fill = false;
_.gridCellSizeX = 0;
_.gridCellSizeY = 0;
var Lorg_eclipse_elk_alg_disco_DisCoPolyominoCompactor_2_classLit = createForClass('org.eclipse.elk.alg.disco', 'DisCoPolyominoCompactor', 1072);
function $addElements(this$static, elements){
  var elem, elem$iterator;
  for (elem$iterator = elements.iterator_0(); elem$iterator.hasNext_0();) {
    elem = castTo(elem$iterator.next_1(), 256);
    this$static.changed = true;
    $add_6(this$static.shapes, elem);
    elem.cp = this$static;
  }
}

function $getDimensionsOfBoundingRectangle(this$static){
  this$static.changed && $update(this$static);
  return this$static.bounds;
}

function $getMinCorner(this$static){
  this$static.changed && $update(this$static);
  return this$static.minCornerOfBoundingRectangle;
}

function $intersects(this$static, rect){
  var elem, elem$iterator;
  for (elem$iterator = this$static.shapes.map_0.keySet_0().iterator_0(); elem$iterator.hasNext_0();) {
    elem = castTo(elem$iterator.next_1(), 256);
    if (intersects_1(rect, elem.shape_0) || contains_45(rect, elem.shape_0)) {
      return true;
    }
  }
  return false;
}

function $setOffset(this$static, offset){
  this$static.changed = true;
  this$static.offset = offset;
}

function $update(this$static){
  var dir_0, elem, elem$iterator, elemBounds, ext, ext$iterator, maxPos, maxX, maxY, minPos, minX, minY;
  this$static.changed = false;
  minX = $intern_62;
  maxX = $intern_63;
  minY = $intern_62;
  maxY = $intern_63;
  for (elem$iterator = this$static.shapes.map_0.keySet_0().iterator_0(); elem$iterator.hasNext_0();) {
    elem = castTo(elem$iterator.next_1(), 256);
    elemBounds = elem.bounds;
    minX = $wnd.Math.min(minX, elemBounds.x_0);
    maxX = $wnd.Math.max(maxX, elemBounds.x_0 + elemBounds.width_0);
    minY = $wnd.Math.min(minY, elemBounds.y_0);
    maxY = $wnd.Math.max(maxY, elemBounds.y_0 + elemBounds.height);
    for (ext$iterator = new ArrayList$1(elem.extensions); ext$iterator.i < ext$iterator.this$01.array.length;) {
      ext = castTo($next_10(ext$iterator), 380);
      dir_0 = ext.direction;
      if (dir_0.horizontal) {
        minPos = elemBounds.y_0 + ext.offset.y_0;
        maxPos = minPos + ext.width_0;
        minY = $wnd.Math.min(minY, minPos);
        maxY = $wnd.Math.max(maxY, maxPos);
      }
       else {
        minPos = elemBounds.x_0 + ext.offset.x_0;
        maxPos = minPos + ext.width_0;
        minX = $wnd.Math.min(minX, minPos);
        maxX = $wnd.Math.max(maxX, maxPos);
      }
    }
  }
  this$static.bounds = new KVector_1(maxX - minX, maxY - minY);
  this$static.minCornerOfBoundingRectangle = new KVector_1(minX + this$static.offset.x_0, minY + this$static.offset.y_0);
}

function DCComponent(){
  this.offset = new KVector_1(0, 0);
  this.shapes = new HashSet;
}

defineClass(526, 1, {526:1}, DCComponent);
_.changed = true;
var Lorg_eclipse_elk_alg_disco_graph_DCComponent_2_classLit = createForClass('org.eclipse.elk.alg.disco.graph', 'DCComponent', 526);
function $clinit_DCDirection(){
  $clinit_DCDirection = emptyMethod;
  NORTH_0 = new DCDirection('NORTH', 0);
  EAST_0 = new DCDirection('EAST', 1);
  SOUTH_0 = new DCDirection('SOUTH', 2);
  WEST_0 = new DCDirection('WEST', 3);
  NORTH_0.horizontal = false;
  EAST_0.horizontal = true;
  SOUTH_0.horizontal = false;
  WEST_0.horizontal = true;
}

function DCDirection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_23(name_0){
  $clinit_DCDirection();
  return valueOf(($clinit_DCDirection$Map() , $MAP_11), name_0);
}

function values_19(){
  $clinit_DCDirection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_disco_graph_DCDirection_2_classLit, 1), $intern_38, 379, 0, [NORTH_0, EAST_0, SOUTH_0, WEST_0]);
}

defineClass(379, 22, {3:1, 34:1, 22:1, 379:1}, DCDirection);
_.horizontal = false;
var EAST_0, NORTH_0, SOUTH_0, WEST_0;
var Lorg_eclipse_elk_alg_disco_graph_DCDirection_2_classLit = createForEnum('org.eclipse.elk.alg.disco.graph', 'DCDirection', 379, Ljava_lang_Enum_2_classLit, values_19, valueOf_23);
function $clinit_DCDirection$Map(){
  $clinit_DCDirection$Map = emptyMethod;
  $MAP_11 = createValueOfMap(($clinit_DCDirection() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_disco_graph_DCDirection_2_classLit, 1), $intern_38, 379, 0, [NORTH_0, EAST_0, SOUTH_0, WEST_0])));
}

var $MAP_11;
function DCElement(polyPath){
  var maxX, maxY, minX, minY, v, v$iterator;
  this.extensions = new ArrayList;
  this.shape_0 = polyPath;
  minX = $intern_62;
  minY = $intern_62;
  maxX = $intern_63;
  maxY = $intern_63;
  for (v$iterator = $listIterator_1(polyPath, 0); v$iterator.currentNode != v$iterator.this$01.tail;) {
    v = castTo($next_13(v$iterator), 8);
    minX = $wnd.Math.min(minX, v.x_0);
    minY = $wnd.Math.min(minY, v.y_0);
    maxX = $wnd.Math.max(maxX, v.x_0);
    maxY = $wnd.Math.max(maxY, v.y_0);
  }
  this.bounds = new ElkRectangle_0(minX, minY, maxX - minX, maxY - minY);
}

defineClass(256, 130, {3:1, 256:1, 94:1, 130:1}, DCElement);
var Lorg_eclipse_elk_alg_disco_graph_DCElement_2_classLit = createForClass('org.eclipse.elk.alg.disco.graph', 'DCElement', 256);
function $setOffset_0(this$static, offset){
  this$static.offset = offset;
}

function DCExtension(parent_0, direction, middlePos, width_0){
  var bounds, halfWidth;
  this.direction = direction;
  this.width_0 = width_0;
  bounds = parent_0.bounds;
  $setOffset_0(this, new KVector_1(-bounds.x_0, -bounds.y_0));
  $add_19(this.offset, middlePos);
  halfWidth = width_0 / 2;
  direction.horizontal?$sub(this.offset, 0, halfWidth):$sub(this.offset, halfWidth, 0);
  $add_4(parent_0.extensions, this);
}

defineClass(380, 1, {380:1}, DCExtension);
_.width_0 = 0;
var Lorg_eclipse_elk_alg_disco_graph_DCExtension_2_classLit = createForClass('org.eclipse.elk.alg.disco.graph', 'DCExtension', 380);
function $setDimensions(this$static, dimensions){
  this$static.dimensions = dimensions;
}

function DCGraph(components){
  var component, elements, elements$iterator;
  this.components = new LinkedHashSet;
  for (elements$iterator = new ArrayList$1(components); elements$iterator.i < elements$iterator.this$01.array.length;) {
    elements = castTo($next_10(elements$iterator), 13);
    component = new DCComponent;
    $addElements(component, elements);
    $add_6(this.components, component);
  }
}

function DCGraph_0(components){
  DCGraph.call(this, components);
}

defineClass(695, 130, $intern_99, DCGraph_0);
var Lorg_eclipse_elk_alg_disco_graph_DCGraph_2_classLit = createForClass('org.eclipse.elk.alg.disco.graph', 'DCGraph', 695);
function $clinit_CompactionStrategy(){
  $clinit_CompactionStrategy = emptyMethod;
  POLYOMINO = new CompactionStrategy;
}

function CompactionStrategy(){
  Enum.call(this, 'POLYOMINO', 0);
}

function valueOf_24(name_0){
  $clinit_CompactionStrategy();
  return valueOf(($clinit_CompactionStrategy$Map() , $MAP_12), name_0);
}

function values_20(){
  $clinit_CompactionStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_disco_options_CompactionStrategy_2_classLit, 1), $intern_38, 454, 0, [POLYOMINO]);
}

defineClass(454, 22, {3:1, 34:1, 22:1, 454:1}, CompactionStrategy);
var POLYOMINO;
var Lorg_eclipse_elk_alg_disco_options_CompactionStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.disco.options', 'CompactionStrategy', 454, Ljava_lang_Enum_2_classLit, values_20, valueOf_24);
function $clinit_CompactionStrategy$Map(){
  $clinit_CompactionStrategy$Map = emptyMethod;
  $MAP_12 = createValueOfMap(($clinit_CompactionStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_disco_options_CompactionStrategy_2_classLit, 1), $intern_38, 454, 0, [POLYOMINO])));
}

var $MAP_12;
function $clinit_DisCoMetaDataProvider(){
  $clinit_DisCoMetaDataProvider = emptyMethod;
  COMPONENT_COMPACTION_STRATEGY_DEFAULT = ($clinit_CompactionStrategy() , POLYOMINO);
  COMPONENT_COMPACTION_STRATEGY = new Property_1('org.eclipse.elk.disco.componentCompaction.strategy', COMPONENT_COMPACTION_STRATEGY_DEFAULT);
  COMPONENT_COMPACTION_COMPONENT_LAYOUT_ALGORITHM = new Property('org.eclipse.elk.disco.componentCompaction.componentLayoutAlgorithm');
  DEBUG_DISCO_GRAPH = new Property('org.eclipse.elk.disco.debug.discoGraph');
  DEBUG_DISCO_POLYS = new Property('org.eclipse.elk.disco.debug.discoPolys');
}

function DisCoMetaDataProvider(){
  $clinit_DisCoMetaDataProvider();
}

defineClass(784, 1, $intern_92, DisCoMetaDataProvider);
_.apply_3 = function apply_43(registry){
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.disco.componentCompaction.strategy'), 'componentCompaction'), 'Connected Components Compaction Strategy'), 'Strategy for packing different connected components in order to save space and enhance readability of a graph.'), COMPONENT_COMPACTION_STRATEGY_DEFAULT), ($clinit_LayoutOptionData$Type() , ENUM)), Lorg_eclipse_elk_alg_disco_options_CompactionStrategy_2_classLit), of_0(($clinit_LayoutOptionData$Target() , PARENTS)))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.disco.componentCompaction.componentLayoutAlgorithm'), 'componentCompaction'), 'Connected Components Layout Algorithm'), "A layout algorithm that is to be applied to each connected component before the components themselves are compacted. If unspecified, the positions of the components' nodes are not altered."), STRING), Ljava_lang_String_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.disco.debug.discoGraph'), 'debug'), 'DCGraph'), 'Access to the DCGraph is intended for the debug view,'), OBJECT), Ljava_lang_Object_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.disco.debug.discoPolys'), 'debug'), 'List of Polyominoes'), 'Access to the polyominoes is intended for the debug view,'), OBJECT), Ljava_lang_Object_2_classLit), of_0(PARENTS))));
  $apply_10((new DisCoOptions , registry));
}
;
var COMPONENT_COMPACTION_COMPONENT_LAYOUT_ALGORITHM, COMPONENT_COMPACTION_STRATEGY, COMPONENT_COMPACTION_STRATEGY_DEFAULT, DEBUG_DISCO_GRAPH, DEBUG_DISCO_POLYS;
var Lorg_eclipse_elk_alg_disco_options_DisCoMetaDataProvider_2_classLit = createForClass('org.eclipse.elk.alg.disco.options', 'DisCoMetaDataProvider', 784);
function $clinit_DisCoOptions(){
  $clinit_DisCoOptions = emptyMethod;
  SPACING_COMPONENT_COMPONENT = ($clinit_CoreOptions() , SPACING_COMPONENT_COMPONENT_1);
  EDGE_THICKNESS = EDGE_THICKNESS_1;
  ASPECT_RATIO = ASPECT_RATIO_4;
  PADDING = PADDING_5;
  POLYOMINO_LOW_LEVEL_SORT_0 = ($clinit_PolyominoOptions() , POLYOMINO_LOW_LEVEL_SORT);
  POLYOMINO_HIGH_LEVEL_SORT_0 = POLYOMINO_HIGH_LEVEL_SORT;
  POLYOMINO_TRAVERSAL_STRATEGY_0 = POLYOMINO_TRAVERSAL_STRATEGY;
  POLYOMINO_FILL_0 = POLYOMINO_FILL;
  COMPONENT_COMPACTION_STRATEGY_0 = ($clinit_DisCoMetaDataProvider() , COMPONENT_COMPACTION_STRATEGY);
  COMPONENT_COMPACTION_COMPONENT_LAYOUT_ALGORITHM_0 = COMPONENT_COMPACTION_COMPONENT_LAYOUT_ALGORITHM;
  DEBUG_DISCO_GRAPH_0 = DEBUG_DISCO_GRAPH;
  DEBUG_DISCO_POLYS_0 = DEBUG_DISCO_POLYS;
}

function $apply_10(registry){
  $register(registry, new LayoutAlgorithmData($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.disco'), 'ELK DisCo'), 'Layouter for arranging unconnected subgraphs. The subgraphs themselves are, by default, not laid out.'), new DisCoOptions$DiscoFactory)));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.spacing.componentComponent', $getDefault(SPACING_COMPONENT_COMPONENT));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.edge.thickness', $getDefault(EDGE_THICKNESS));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.aspectRatio', $getDefault(ASPECT_RATIO));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.padding', $getDefault(PADDING));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.polyomino.lowLevelSort', $getDefault(POLYOMINO_LOW_LEVEL_SORT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.polyomino.highLevelSort', $getDefault(POLYOMINO_HIGH_LEVEL_SORT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.polyomino.traversalStrategy', $getDefault(POLYOMINO_TRAVERSAL_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.polyomino.fill', $getDefault(POLYOMINO_FILL_0));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.disco.componentCompaction.strategy', $getDefault(COMPONENT_COMPACTION_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.disco.componentCompaction.componentLayoutAlgorithm', $getDefault(COMPONENT_COMPACTION_COMPONENT_LAYOUT_ALGORITHM_0));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.disco.debug.discoGraph', $getDefault(DEBUG_DISCO_GRAPH_0));
  $addOptionSupport(registry, 'org.eclipse.elk.disco', 'org.eclipse.elk.disco.debug.discoPolys', $getDefault(DEBUG_DISCO_POLYS_0));
}

function DisCoOptions(){
  $clinit_DisCoOptions();
}

defineClass(924, 1, $intern_92, DisCoOptions);
_.apply_3 = function apply_44(registry){
  $apply_10(registry);
}
;
var ASPECT_RATIO, COMPONENT_COMPACTION_COMPONENT_LAYOUT_ALGORITHM_0, COMPONENT_COMPACTION_STRATEGY_0, DEBUG_DISCO_GRAPH_0, DEBUG_DISCO_POLYS_0, EDGE_THICKNESS, PADDING, POLYOMINO_FILL_0, POLYOMINO_HIGH_LEVEL_SORT_0, POLYOMINO_LOW_LEVEL_SORT_0, POLYOMINO_TRAVERSAL_STRATEGY_0, SPACING_COMPONENT_COMPONENT;
var Lorg_eclipse_elk_alg_disco_options_DisCoOptions_2_classLit = createForClass('org.eclipse.elk.alg.disco.options', 'DisCoOptions', 924);
function DisCoOptions$DiscoFactory(){
}

defineClass(925, 1, {}, DisCoOptions$DiscoFactory);
_.create_0 = function create_3(){
  var provider;
  return provider = new DisCoLayoutProvider , provider;
}
;
_.destroy = function destroy(obj){
}
;
var Lorg_eclipse_elk_alg_disco_options_DisCoOptions$DiscoFactory_2_classLit = createForClass('org.eclipse.elk.alg.disco.options', 'DisCoOptions/DiscoFactory', 925);
function $addExtensionsToPoly(this$static, elem){
  var baseX, baseY, compCorner, dir_0, elemPos, extension, extension$iterator, extensions, polyDir, polyoOffset, pos, xe, xp, xpPlusWidth, ye, yp, ypPlusWidth;
  extensions = elem.extensions;
  compCorner = $getMinCorner(this$static.representee);
  polyoOffset = $scale($sub($clone_0($getDimensionsOfBoundingRectangle(this$static.representee)), this$static.pWidth * this$static.cellSizeX, this$static.pHeight * this$static.cellSizeY), -0.5);
  baseX = compCorner.x_0 - polyoOffset.x_0;
  baseY = compCorner.y_0 - polyoOffset.y_0;
  elemPos = elem.bounds;
  baseX = elemPos.x_0 - baseX;
  baseY = elemPos.y_0 - baseY;
  for (extension$iterator = new ArrayList$1(extensions); extension$iterator.i < extension$iterator.this$01.array.length;) {
    extension = castTo($next_10(extension$iterator), 380);
    pos = extension.offset;
    xe = baseX + pos.x_0;
    ye = baseY + pos.y_0;
    xp = round_int(xe / this$static.cellSizeX);
    yp = round_int(ye / this$static.cellSizeY);
    dir_0 = extension.direction;
    switch (dir_0.ordinal) {
      case 0:
        polyDir = ($clinit_Direction() , NORTH);
        break;
      case 1:
        polyDir = ($clinit_Direction() , EAST);
        break;
      case 2:
        polyDir = ($clinit_Direction() , SOUTH);
        break;
      default:polyDir = ($clinit_Direction() , WEST);
    }
    if (dir_0.horizontal) {
      ypPlusWidth = round_int((ye + extension.width_0) / this$static.cellSizeY);
      $add_4(this$static.polyominoExtensions, new UniqueTriple(polyDir, valueOf_4(yp), valueOf_4(ypPlusWidth)));
      dir_0 == ($clinit_DCDirection() , WEST_0)?$weaklyBlockArea(this$static, 0, yp, xp, ypPlusWidth):$weaklyBlockArea(this$static, xp, yp, this$static.pWidth - 1, ypPlusWidth);
    }
     else {
      xpPlusWidth = round_int((xe + extension.width_0) / this$static.cellSizeX);
      $add_4(this$static.polyominoExtensions, new UniqueTriple(polyDir, valueOf_4(xp), valueOf_4(xpPlusWidth)));
      dir_0 == ($clinit_DCDirection() , NORTH_0)?$weaklyBlockArea(this$static, xp, 0, xpPlusWidth, yp):$weaklyBlockArea(this$static, xp, yp, xpPlusWidth, this$static.pHeight - 1);
    }
  }
}

function $computeLowResDimension(dim, cellSize){
  var cellFit, fitTruncated;
  cellFit = dim / cellSize;
  fitTruncated = round_int(cellFit);
  cellFit > fitTruncated && ++fitTruncated;
  return fitTruncated;
}

function $fillCells(this$static){
  var baseX, compCorner, curX, curY, polyoOffset, x_0, y_0;
  compCorner = $getMinCorner(this$static.representee);
  polyoOffset = $scale($sub($clone_0($getDimensionsOfBoundingRectangle(this$static.representee)), this$static.pWidth * this$static.cellSizeX, this$static.pHeight * this$static.cellSizeY), -0.5);
  baseX = compCorner.x_0 - polyoOffset.x_0;
  curY = compCorner.y_0 - polyoOffset.y_0;
  for (y_0 = 0; y_0 < this$static.pHeight; y_0++) {
    curX = baseX;
    for (x_0 = 0; x_0 < this$static.pWidth; x_0++) {
      $intersects(this$static.representee, new ElkRectangle_0(curX, curY, this$static.cellSizeX, this$static.cellSizeY)) && $set_5(this$static, x_0, y_0, false, true);
      curX += this$static.cellSizeX;
    }
    curY += this$static.cellSizeY;
  }
}

function DCPolyomino(comp, csX, csY){
  var compDims, elem, elem$iterator;
  Polyomino.call(this, new ArrayList);
  this.cellSizeX = csX;
  this.cellSizeY = csY;
  this.representee = comp;
  compDims = (comp.changed && $update(comp) , comp.bounds);
  this.pWidth = $computeLowResDimension(compDims.x_0, this.cellSizeX);
  this.pHeight = $computeLowResDimension(compDims.y_0, this.cellSizeY);
  $reinitialize(this, this.pWidth, this.pHeight);
  $fillCells(this);
  for (elem$iterator = this.representee.shapes.map_0.keySet_0().iterator_0(); elem$iterator.hasNext_0();) {
    elem = castTo(elem$iterator.next_1(), 256);
    elem.extensions.array.length > 0 && $addExtensionsToPoly(this, elem);
  }
}

defineClass(527, 158, {310:1, 158:1, 527:1}, DCPolyomino);
_.cellSizeX = 0;
_.cellSizeY = 0;
_.pHeight = 0;
_.pWidth = 0;
var Lorg_eclipse_elk_alg_disco_structures_DCPolyomino_2_classLit = createForClass('org.eclipse.elk.alg.disco.structures', 'DCPolyomino', 527);
function $clinit_ElkGraphComponentsProcessor(){
  $clinit_ElkGraphComponentsProcessor = emptyMethod;
  visited_0 = new ArrayList;
  incidenceMap = ($clinit_Maps() , new HashMap);
  components_0 = new ArrayList;
}

function addNodesToIncidenceSet(incidentNodes, edges, chooseNode){
  var edge, edge$iterator;
  for (edge$iterator = edges.iterator_0(); edge$iterator.hasNext_0();) {
    edge = castTo(edge$iterator.next_1(), 100);
    $add_6(incidentNodes, castTo(chooseNode.apply_0(edge), 35));
  }
}

function computeIncidences(nodes){
  var adjacentAndInsideParent, adjacentNodes, connectedToParentPort, edges, incomingEdge, incomingEdge$iterator, node, node$iterator, nodesAtPort, outgoingEdge, outgoingEdge$iterator, port, sameHierarchyLevel;
  adjacentAndInsideParent = ($clinit_Maps() , new HashMap);
  for (node$iterator = new AbstractEList$EIterator(nodes); node$iterator.cursor != node$iterator.this$01_2.size_1();) {
    node = castTo($doNext(node$iterator), 35);
    adjacentNodes = new HashSet;
    $put_1(incidenceMap, node, adjacentNodes);
    sameHierarchyLevel = new ElkGraphComponentsProcessor$lambda$0$Type;
    edges = castTo($collect_0(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator_0($iterator(allIncomingEdges(node)))), partitioningBy(sameHierarchyLevel, of_3(new Collectors$21methodref$ctor$Type, new Collectors$20methodref$add$Type, new Collectors$lambda$21$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , IDENTITY_FINISH)])))), 111);
    addNodesToIncidenceSet(adjacentNodes, castTo(edges.get_0(($clinit_Boolean() , $clinit_Boolean() , true)), 13), new ElkGraphComponentsProcessor$lambda$1$Type);
    connectedToParentPort = castTo($collect_0($filter(castTo(edges.get_0((null , false)), 15).parallelStream(), new ElkGraphComponentsProcessor$lambda$2$Type), of_3(new Collectors$21methodref$ctor$Type, new Collectors$20methodref$add$Type, new Collectors$lambda$21$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [IDENTITY_FINISH]))), 15);
    for (incomingEdge$iterator = connectedToParentPort.iterator_0(); incomingEdge$iterator.hasNext_0();) {
      incomingEdge = castTo(incomingEdge$iterator.next_1(), 100);
      port = getSourcePort(incomingEdge);
      if (port) {
        nodesAtPort = castTo(getEntryValueOrNull($getEntry(adjacentAndInsideParent.hashCodeMap, port)), 19);
        if (!nodesAtPort) {
          nodesAtPort = getInnerNeighborsOfPort(port);
          $put_4(adjacentAndInsideParent.hashCodeMap, port, nodesAtPort);
        }
        $addAll(adjacentNodes, nodesAtPort);
      }
    }
    edges = castTo($collect_0(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator_0($iterator(allOutgoingEdges(node)))), partitioningBy(sameHierarchyLevel, of_3(new Collectors$21methodref$ctor$Type, new Collectors$20methodref$add$Type, new Collectors$lambda$21$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [IDENTITY_FINISH])))), 111);
    addNodesToIncidenceSet(adjacentNodes, castTo(edges.get_0((null , true)), 13), new ElkGraphComponentsProcessor$lambda$3$Type);
    connectedToParentPort = castTo($collect_0($filter(castTo(edges.get_0((null , false)), 15).parallelStream(), new ElkGraphComponentsProcessor$lambda$4$Type), of_3(new Collectors$21methodref$ctor$Type, new Collectors$20methodref$add$Type, new Collectors$lambda$21$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [IDENTITY_FINISH]))), 15);
    for (outgoingEdge$iterator = connectedToParentPort.iterator_0(); outgoingEdge$iterator.hasNext_0();) {
      outgoingEdge = castTo(outgoingEdge$iterator.next_1(), 100);
      port = getTargetPort(outgoingEdge);
      if (port) {
        nodesAtPort = castTo(getEntryValueOrNull($getEntry(adjacentAndInsideParent.hashCodeMap, port)), 19);
        if (!nodesAtPort) {
          nodesAtPort = getInnerNeighborsOfPort(port);
          $put_4(adjacentAndInsideParent.hashCodeMap, port, nodesAtPort);
        }
        $addAll(adjacentNodes, nodesAtPort);
      }
    }
  }
}

function dfs(start_0, component){
  var adjacentNodes, node, node$iterator;
  $add_4(visited_0, start_0);
  component.add_1(start_0);
  adjacentNodes = castTo($get_6(incidenceMap, start_0), 19);
  if (adjacentNodes) {
    for (node$iterator = adjacentNodes.iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 35);
      $indexOf_3(visited_0, node, 0) != -1 || dfs(node, component);
    }
  }
}

function getInnerNeighborsOfPort(port){
  var allEdges, inwardsPredicate, nodeMapper, portParent;
  portParent = $getParent_3(port);
  inwardsPredicate = new ElkGraphComponentsProcessor$lambda$5$Type(portParent);
  nodeMapper = new ElkGraphComponentsProcessor$lambda$6$Type(portParent);
  allEdges = new ArrayList;
  $addAll_2(allEdges, (!port.incomingEdges && (port.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, port, 8, 5)) , port.incomingEdges));
  $addAll_2(allEdges, (!port.outgoingEdges && (port.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, port, 7, 4)) , port.outgoingEdges));
  return castTo($collect_0($map($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(allEdges, 16)), inwardsPredicate), nodeMapper), of_2(new Collectors$23methodref$ctor$Type, new Collectors$24methodref$add$Type, new Collectors$lambda$25$Type, new Collectors$lambda$26$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , UNORDERED), IDENTITY_FINISH]))), 19);
}

function lambda$5_0(portParent_0, edge_1){
  $clinit_ElkGraphComponentsProcessor();
  return portParent_0 == $getParent_2(getSourceNode(edge_1)) || portParent_0 == $getParent_2(getTargetNode(edge_1));
}

function lambda$6(portParent_0, edge_1){
  $clinit_ElkGraphComponentsProcessor();
  return portParent_0 == getSourceNode(edge_1)?getTargetNode(edge_1):getSourceNode(edge_1);
}

function split_1(graph){
  $clinit_ElkGraphComponentsProcessor();
  var children, component, node, node$iterator;
  visited_0 = new ArrayList;
  incidenceMap = ($clinit_Maps() , new HashMap);
  components_0 = new ArrayList;
  children = (!graph.children && (graph.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, graph, 10, 11)) , graph.children);
  computeIncidences(children);
  for (node$iterator = new AbstractEList$EIterator(children); node$iterator.cursor != node$iterator.this$01_2.size_1();) {
    node = castTo($doNext(node$iterator), 35);
    if ($indexOf_3(visited_0, node, 0) == -1) {
      component = new ArrayList;
      $add_4(components_0, component);
      dfs(node, component);
    }
  }
  return components_0;
}

var components_0, incidenceMap, visited_0;
function $test(arg0){
  return $clinit_ElkGraphComponentsProcessor() , $getParent_2(getSourceNode(castTo(arg0, 173))) == $getParent_2(getTargetNode(castTo(arg0, 173)));
}

function ElkGraphComponentsProcessor$lambda$0$Type(){
}

defineClass(1152, 1, $intern_90, ElkGraphComponentsProcessor$lambda$0$Type);
_.test_0 = function test_10(arg0){
  return $test(arg0);
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphComponentsProcessor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphComponentsProcessor/lambda$0$Type', 1152);
function ElkGraphComponentsProcessor$lambda$1$Type(){
}

defineClass(1153, 1, $intern_11, ElkGraphComponentsProcessor$lambda$1$Type);
_.apply_0 = function apply_45(arg0){
  return $clinit_ElkGraphComponentsProcessor() , getSourceNode(castTo(arg0, 173));
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphComponentsProcessor$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphComponentsProcessor/lambda$1$Type', 1153);
function ElkGraphComponentsProcessor$lambda$2$Type(){
}

defineClass(1154, 1, $intern_90, ElkGraphComponentsProcessor$lambda$2$Type);
_.test_0 = function test_11(arg0){
  return $clinit_ElkGraphComponentsProcessor() , getSourceNode(castTo(arg0, 173)) == $getParent_2(getTargetNode(castTo(arg0, 173)));
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphComponentsProcessor$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphComponentsProcessor/lambda$2$Type', 1154);
function ElkGraphComponentsProcessor$lambda$3$Type(){
}

defineClass(1155, 1, $intern_11, ElkGraphComponentsProcessor$lambda$3$Type);
_.apply_0 = function apply_46(arg0){
  return $clinit_ElkGraphComponentsProcessor() , getTargetNode(castTo(arg0, 173));
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphComponentsProcessor$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphComponentsProcessor/lambda$3$Type', 1155);
function ElkGraphComponentsProcessor$lambda$4$Type(){
}

defineClass(1156, 1, $intern_90, ElkGraphComponentsProcessor$lambda$4$Type);
_.test_0 = function test_12(arg0){
  return $clinit_ElkGraphComponentsProcessor() , getTargetNode(castTo(arg0, 173)) == $getParent_2(getSourceNode(castTo(arg0, 173)));
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphComponentsProcessor$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphComponentsProcessor/lambda$4$Type', 1156);
function ElkGraphComponentsProcessor$lambda$5$Type(portParent_0){
  this.portParent_0 = portParent_0;
}

defineClass(1157, 1, $intern_90, ElkGraphComponentsProcessor$lambda$5$Type);
_.test_0 = function test_13(arg0){
  return lambda$5_0(this.portParent_0, arg0);
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphComponentsProcessor$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphComponentsProcessor/lambda$5$Type', 1157);
function ElkGraphComponentsProcessor$lambda$6$Type(portParent_0){
  this.portParent_0 = portParent_0;
}

defineClass(1158, 1, $intern_11, ElkGraphComponentsProcessor$lambda$6$Type);
_.apply_0 = function apply_47(arg0){
  return lambda$6(this.portParent_0, arg0);
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphComponentsProcessor$lambda$6$Type_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphComponentsProcessor/lambda$6$Type', 1158);
function $adjustFirstSegment(source, chain, dir_0){
  var firstPoint, iter;
  firstPoint = (checkCriticalElement(chain.size_0 != 0) , castTo($removeNode_0(chain, chain.header.next_0), 8));
  switch (dir_0.ordinal) {
    case 0:
      firstPoint.y_0 = 0;
      break;
    case 2:
      firstPoint.y_0 = source.height;
      break;
    case 3:
      firstPoint.x_0 = 0;
      break;
    default:firstPoint.x_0 = source.width_0;
  }
  iter = $listIterator_1(chain, 0);
  $add_8(iter, firstPoint);
  return chain;
}

function $adjustRelatedPort(port, edgePoint, dir_0){
  dir_0.horizontal?$setY_1(port, edgePoint.y_0 - port.height / 2):$setX_1(port, edgePoint.x_0 - port.width_0 / 2);
}

function $applyLayout(this$static){
  var adjustedPorts, dir_0, edge, edgeSection, graphDimensions, inEntry, inEntry$iterator, label_0, label$iterator, newHeight, newPoints, newWidth, oldHeight, oldWidth, outEntry, outEntry$iterator, port, port$iterator, portToAdjust, px, py, xFactor, yFactor;
  graphDimensions = this$static.transformedGraph.dimensions;
  newWidth = graphDimensions.x_0;
  newHeight = graphDimensions.y_0;
  oldWidth = this$static.parent_0.width_0;
  oldHeight = this$static.parent_0.height;
  $setDimensions_0(this$static.parent_0, graphDimensions.x_0, graphDimensions.y_0);
  xFactor = newWidth / oldWidth;
  yFactor = newHeight / oldHeight;
  for (label$iterator = new AbstractEList$EIterator($getLabels_1(this$static.parent_0)); label$iterator.cursor != label$iterator.this$01_2.size_1();) {
    label_0 = castTo($doNext(label$iterator), 135);
    $setX_1(label_0, label_0.x_0 * xFactor);
    $setY_1(label_0, label_0.y_0 * yFactor);
  }
  for (port$iterator = new AbstractEList$EIterator($getPorts_3(this$static.parent_0)); port$iterator.cursor != port$iterator.this$01_2.size_1();) {
    port = castTo($doNext(port$iterator), 123);
    px = port.x_0;
    py = port.y_0;
    px > 0 && $setX_1(port, px * xFactor);
    py > 0 && $setY_1(port, py * yFactor);
  }
  $forEach_1(this$static.elementMapping, new ElkGraphTransformer$OffsetApplier);
  adjustedPorts = new ArrayList;
  for (inEntry$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.incomingExtensionsMapping)).this$01); inEntry$iterator.hasNext;) {
    inEntry = $next_7(inEntry$iterator);
    edge = castTo(inEntry.getKey(), 100);
    dir_0 = castTo(inEntry.getValue(), 380).direction;
    edgeSection = firstEdgeSection(edge, false, false);
    newPoints = $adjustFirstSegment(getSourceNode(edge), createVectorChain(edgeSection), dir_0);
    applyVectorChain(newPoints, edgeSection);
    portToAdjust = getSourcePort(edge);
    if (!!portToAdjust && $indexOf_3(adjustedPorts, portToAdjust, 0) == -1) {
      adjustedPorts.array[adjustedPorts.array.length] = portToAdjust;
      $adjustRelatedPort(portToAdjust, (checkCriticalElement(newPoints.size_0 != 0) , castTo(newPoints.header.next_0.value_0, 8)), dir_0);
    }
  }
  for (outEntry$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.outgoingExtensionsMapping)).this$01); outEntry$iterator.hasNext;) {
    outEntry = $next_7(outEntry$iterator);
    edge = castTo(outEntry.getKey(), 100);
    dir_0 = castTo(outEntry.getValue(), 380).direction;
    edgeSection = firstEdgeSection(edge, false, false);
    newPoints = $adjustFirstSegment(getTargetNode(edge), reverse_3(createVectorChain(edgeSection)), dir_0);
    newPoints = reverse_3(newPoints);
    applyVectorChain(newPoints, edgeSection);
    portToAdjust = getTargetPort(edge);
    if (!!portToAdjust && $indexOf_3(adjustedPorts, portToAdjust, 0) == -1) {
      adjustedPorts.array[adjustedPorts.array.length] = portToAdjust;
      $adjustRelatedPort(portToAdjust, (checkCriticalElement(newPoints.size_0 != 0) , castTo(newPoints.tail.prev.value_0, 8)), dir_0);
    }
  }
}

function $computeIntersection(p1, p2, p3, p4){
  var denominator, factor1, factor2, x_0, x1, x2, x3, x4, y_0, y1, y2, y3, y4;
  x1 = p1.x_0;
  y1 = p1.y_0;
  x2 = p2.x_0;
  y2 = p2.y_0;
  x3 = p3.x_0;
  y3 = p3.y_0;
  x4 = p4.x_0;
  y4 = p4.y_0;
  factor1 = x1 * y2 - y1 * x2;
  factor2 = x3 * y4 - y3 * x4;
  denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  x_0 = (factor1 * (x3 - x4) - factor2 * (x1 - x2)) / denominator;
  y_0 = (factor1 * (y3 - y4) - factor2 * (y1 - y2)) / denominator;
  return new KVector_1(x_0, y_0);
}

function $getContour(edgePoints, thickness){
  var ccwMerged, ccwPoints, current, currentPoint, cwMerged, cwPoints, i, i0, i1, i2, intersectionPoint, numberOfPoints, orthPoints, predecessor, radius, successor;
  ccwPoints = new ArrayList;
  cwPoints = new ArrayList;
  radius = thickness / 2;
  numberOfPoints = edgePoints.size_1();
  current = castTo(edgePoints.get_3(0), 8);
  successor = castTo(edgePoints.get_3(1), 8);
  orthPoints = $getOrthogonalPoints(current.x_0, current.y_0, successor.x_0, successor.y_0, radius);
  $add_4(ccwPoints, (checkCriticalElementIndex(0, orthPoints.array.length) , castTo(orthPoints.array[0], 8)));
  $add_4(cwPoints, (checkCriticalElementIndex(1, orthPoints.array.length) , castTo(orthPoints.array[1], 8)));
  for (i0 = 2; i0 < numberOfPoints; i0++) {
    predecessor = current;
    current = successor;
    successor = castTo(edgePoints.get_3(i0), 8);
    orthPoints = $getOrthogonalPoints(current.x_0, current.y_0, predecessor.x_0, predecessor.y_0, radius);
    $add_4(ccwPoints, (checkCriticalElementIndex(1, orthPoints.array.length) , castTo(orthPoints.array[1], 8)));
    $add_4(cwPoints, (checkCriticalElementIndex(0, orthPoints.array.length) , castTo(orthPoints.array[0], 8)));
    orthPoints = $getOrthogonalPoints(current.x_0, current.y_0, successor.x_0, successor.y_0, radius);
    $add_4(ccwPoints, (checkCriticalElementIndex(0, orthPoints.array.length) , castTo(orthPoints.array[0], 8)));
    $add_4(cwPoints, (checkCriticalElementIndex(1, orthPoints.array.length) , castTo(orthPoints.array[1], 8)));
  }
  orthPoints = $getOrthogonalPoints(successor.x_0, successor.y_0, current.x_0, current.y_0, radius);
  $add_4(ccwPoints, (checkCriticalElementIndex(1, orthPoints.array.length) , castTo(orthPoints.array[1], 8)));
  $add_4(cwPoints, (checkCriticalElementIndex(0, orthPoints.array.length) , castTo(orthPoints.array[0], 8)));
  ccwMerged = new KVectorChain;
  cwMerged = new ArrayList;
  $add_7(ccwMerged, (checkCriticalElementIndex(0, ccwPoints.array.length) , castTo(ccwPoints.array[0], 8)));
  for (i1 = 1; i1 < ccwPoints.array.length - 2; i1 += 2) {
    currentPoint = (checkCriticalElementIndex(i1, ccwPoints.array.length) , castTo(ccwPoints.array[i1], 8));
    intersectionPoint = $computeIntersection((checkCriticalElementIndex(i1 - 1, ccwPoints.array.length) , castTo(ccwPoints.array[i1 - 1], 8)), currentPoint, (checkCriticalElementIndex(i1 + 1, ccwPoints.array.length) , castTo(ccwPoints.array[i1 + 1], 8)), (checkCriticalElementIndex(i1 + 2, ccwPoints.array.length) , castTo(ccwPoints.array[i1 + 2], 8)));
    !isFinite_0(intersectionPoint.x_0) || !isFinite_0(intersectionPoint.y_0)?($addNode_0(ccwMerged, currentPoint, ccwMerged.tail.prev, ccwMerged.tail) , true):($addNode_0(ccwMerged, intersectionPoint, ccwMerged.tail.prev, ccwMerged.tail) , true);
  }
  $add_7(ccwMerged, castTo($get_7(ccwPoints, ccwPoints.array.length - 1), 8));
  $add_4(cwMerged, (checkCriticalElementIndex(0, cwPoints.array.length) , castTo(cwPoints.array[0], 8)));
  for (i2 = 1; i2 < cwPoints.array.length - 2; i2 += 2) {
    currentPoint = (checkCriticalElementIndex(i2, cwPoints.array.length) , castTo(cwPoints.array[i2], 8));
    intersectionPoint = $computeIntersection((checkCriticalElementIndex(i2 - 1, cwPoints.array.length) , castTo(cwPoints.array[i2 - 1], 8)), currentPoint, (checkCriticalElementIndex(i2 + 1, cwPoints.array.length) , castTo(cwPoints.array[i2 + 1], 8)), (checkCriticalElementIndex(i2 + 2, cwPoints.array.length) , castTo(cwPoints.array[i2 + 2], 8)));
    !isFinite_0(intersectionPoint.x_0) || !isFinite_0(intersectionPoint.y_0)?(cwMerged.array[cwMerged.array.length] = currentPoint , true):(cwMerged.array[cwMerged.array.length] = intersectionPoint , true);
  }
  $add_4(cwMerged, castTo($get_7(cwPoints, cwPoints.array.length - 1), 8));
  for (i = cwMerged.array.length - 1; i >= 0; i--) {
    $add_7(ccwMerged, (checkCriticalElementIndex(i, cwMerged.array.length) , castTo(cwMerged.array[i], 8)));
  }
  return ccwMerged;
}

function $getOrthogonalPoints(curX, curY, nxtX, nxtY, radius){
  var angleRadians, difX, difY, orthAngleCCW, orthAngleCW, xCCW, xCW, yCCW, yCW;
  difX = nxtX - curX;
  difY = nxtY - curY;
  angleRadians = $wnd.Math.atan2(difX, difY);
  orthAngleCCW = angleRadians + $intern_101;
  orthAngleCW = angleRadians - $intern_101;
  xCCW = radius * $wnd.Math.sin(orthAngleCCW) + curX;
  yCCW = radius * $wnd.Math.cos(orthAngleCCW) + curY;
  xCW = radius * $wnd.Math.sin(orthAngleCW) + curX;
  yCW = radius * $wnd.Math.cos(orthAngleCW) + curY;
  return newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [new KVector_1(xCCW, yCCW), new KVector_1(xCW, yCW)]));
}

function $importElkEdge(this$static, edge, newComponent){
  var componentLabel, contour, edgeSection, label_0, label$iterator, labels, points, shape_0, thickness;
  edgeSection = firstEdgeSection(edge, false, false);
  points = createVectorChain(edgeSection);
  thickness = checkNotNull_1(castToDouble($getProperty_0(edge, ($clinit_DisCoOptions() , EDGE_THICKNESS))));
  contour = $getContour(points, thickness + this$static.componentSpacing);
  shape_0 = new DCElement(contour);
  $copyProperties(shape_0, edge);
  $put_1(this$static.elementMapping, edge, shape_0);
  newComponent.array[newComponent.array.length] = shape_0;
  labels = (!edge.labels && (edge.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, edge, 1, 7)) , edge.labels);
  for (label$iterator = new AbstractEList$EIterator(labels); label$iterator.cursor != label$iterator.this$01_2.size_1();) {
    label_0 = castTo($doNext(label$iterator), 135);
    componentLabel = $importElkShape(this$static, label_0, true, 0, 0);
    newComponent.array[newComponent.array.length] = componentLabel;
  }
  return shape_0;
}

function $importElkEdges(this$static, edges, newComponent){
  var componentEdge, edge, edge$iterator;
  for (edge$iterator = edges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
    edge = castTo(edge$iterator.next_1(), 100);
    componentEdge = castTo($get_6(this$static.elementMapping, edge), 256);
    !componentEdge && ($getParent_2(getSourceNode(edge)) == $getParent_2(getTargetNode(edge))?$importElkEdge(this$static, edge, newComponent):getSourceNode(edge) == $getParent_2(getTargetNode(edge))?$get_6(this$static.incomingExtensionsMapping, edge) == null && $get_6(this$static.elementMapping, getTargetNode(edge)) != null && $importExtension(this$static, edge, newComponent, false):$get_6(this$static.outgoingExtensionsMapping, edge) == null && $get_6(this$static.elementMapping, getSourceNode(edge)) != null && $importExtension(this$static, edge, newComponent, true));
  }
}

function $importElkShape(this$static, element, considerWhenApplyingOffset, offsetX, offsetY){
  var coords, halfComponentSpacing, shape_0, x0, x1, y0, y1;
  if (!(instanceOf(element, 240) || instanceOf(element, 241) || instanceOf(element, 187))) {
    throw toJs(new IllegalArgumentException_0('Method only works for ElkNode-, ElkLabel and ElkPort-objects.'));
  }
  halfComponentSpacing = this$static.componentSpacing / 2;
  x0 = element.x_0 + offsetX - halfComponentSpacing;
  y0 = element.y_0 + offsetY - halfComponentSpacing;
  x1 = x0 + element.width_0 + this$static.componentSpacing;
  y1 = y0 + element.height + this$static.componentSpacing;
  coords = new KVectorChain;
  $add_7(coords, new KVector_1(x0, y0));
  $add_7(coords, new KVector_1(x0, y1));
  $add_7(coords, new KVector_1(x1, y1));
  $add_7(coords, new KVector_1(x1, y0));
  shape_0 = new DCElement(coords);
  $copyProperties(shape_0, element);
  considerWhenApplyingOffset && $put_1(this$static.elementMapping, element, shape_0);
  return shape_0;
}

function $importExtension(this$static, edge, newComponent, outgoingExtension){
  var componentLabel, contour, dir_0, edgeSection, extParent, extensionWidth, fixedEdgePoints, innerPoint, label_0, label$iterator, labels, middlePos, outerPoint, points, shape_0, thickness;
  edgeSection = firstEdgeSection(edge, false, false);
  points = createVectorChain(edgeSection);
  outgoingExtension && (points = reverse_3(points));
  thickness = checkNotNull_1(castToDouble($getProperty_0(edge, ($clinit_DisCoOptions() , EDGE_THICKNESS))));
  outerPoint = (checkCriticalElement(points.size_0 != 0) , castTo(points.header.next_0.value_0, 8));
  innerPoint = castTo($get_3(points, 1), 8);
  if (points.size_0 > 2) {
    fixedEdgePoints = new ArrayList;
    $addAll_2(fixedEdgePoints, new AbstractList$SubList(points, 1, points.size_0));
    contour = $getContour(fixedEdgePoints, thickness + this$static.componentSpacing);
    shape_0 = new DCElement(contour);
    $copyProperties(shape_0, edge);
    newComponent.array[newComponent.array.length] = shape_0;
  }
   else {
    outgoingExtension?(shape_0 = castTo($get_6(this$static.elementMapping, getSourceNode(edge)), 256)):(shape_0 = castTo($get_6(this$static.elementMapping, getTargetNode(edge)), 256));
  }
  extParent = getSourceNode(edge);
  outgoingExtension && (extParent = getTargetNode(edge));
  dir_0 = $nearestSide(outerPoint, extParent);
  extensionWidth = thickness + this$static.componentSpacing;
  if (dir_0.horizontal) {
    extensionWidth += $wnd.Math.abs(outerPoint.y_0 - innerPoint.y_0);
    middlePos = new KVector_1(innerPoint.x_0, (innerPoint.y_0 + outerPoint.y_0) / 2);
  }
   else {
    extensionWidth += $wnd.Math.abs(outerPoint.x_0 - innerPoint.x_0);
    middlePos = new KVector_1((innerPoint.x_0 + outerPoint.x_0) / 2, innerPoint.y_0);
  }
  outgoingExtension?$put_1(this$static.outgoingExtensionsMapping, edge, new DCExtension(shape_0, dir_0, middlePos, extensionWidth)):$put_1(this$static.incomingExtensionsMapping, edge, new DCExtension(shape_0, dir_0, middlePos, extensionWidth));
  $put_1(this$static.elementMapping, edge, shape_0);
  labels = (!edge.labels && (edge.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, edge, 1, 7)) , edge.labels);
  for (label$iterator = new AbstractEList$EIterator(labels); label$iterator.cursor != label$iterator.this$01_2.size_1();) {
    label_0 = castTo($doNext(label$iterator), 135);
    componentLabel = $importElkShape(this$static, label_0, true, 0, 0);
    newComponent.array[newComponent.array.length] = componentLabel;
  }
}

function $importGraph(this$static, graph){
  var component, component$iterator, componentLabel, componentNode, componentPort, components, edgeSet, label_0, label$iterator, label$iterator0, labels, node, node$iterator, nodeX, nodeY, port, port$iterator, portX, portY, ports, result, subResult;
  this$static.parent_0 = graph;
  components = split_1(graph);
  result = new ArrayList;
  for (component$iterator = new ArrayList$1(components); component$iterator.i < component$iterator.this$01.array.length;) {
    component = castTo($next_10(component$iterator), 15);
    subResult = new ArrayList;
    result.array[result.array.length] = subResult;
    edgeSet = new HashSet;
    for (node$iterator = component.iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 35);
      componentNode = $importElkShape(this$static, node, true, 0, 0);
      subResult.array[subResult.array.length] = componentNode;
      nodeX = node.x_0;
      nodeY = node.y_0;
      new KVector_1(nodeX, nodeY);
      labels = (!node.labels && (node.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, node, 1, 7)) , node.labels);
      for (label$iterator0 = new AbstractEList$EIterator(labels); label$iterator0.cursor != label$iterator0.this$01_2.size_1();) {
        label_0 = castTo($doNext(label$iterator0), 135);
        componentLabel = $importElkShape(this$static, label_0, false, nodeX, nodeY);
        subResult.array[subResult.array.length] = componentLabel;
      }
      ports = (!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports);
      for (port$iterator = new AbstractEList$EIterator(ports); port$iterator.cursor != port$iterator.this$01_2.size_1();) {
        port = castTo($doNext(port$iterator), 123);
        componentPort = $importElkShape(this$static, port, false, nodeX, nodeY);
        subResult.array[subResult.array.length] = componentPort;
        portX = port.x_0 + nodeX;
        portY = port.y_0 + nodeY;
        labels = (!port.labels && (port.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, port, 1, 7)) , port.labels);
        for (label$iterator = new AbstractEList$EIterator(labels); label$iterator.cursor != label$iterator.this$01_2.size_1();) {
          label_0 = castTo($doNext(label$iterator), 135);
          componentLabel = $importElkShape(this$static, label_0, false, portX, portY);
          subResult.array[subResult.array.length] = componentLabel;
        }
      }
      $addAll(edgeSet, newHashSet(concat_1(allOutgoingEdges(node), allIncomingEdges(node))));
    }
    $importElkEdges(this$static, edgeSet, subResult);
  }
  this$static.transformedGraph = new DCGraph_0(result);
  $copyProperties(this$static.transformedGraph, graph);
  return this$static.transformedGraph;
}

function $nearestSide(point, node){
  var distance, result, shortestDistance;
  result = ($clinit_DCDirection() , NORTH_0);
  shortestDistance = $wnd.Math.abs(point.y_0);
  distance = $wnd.Math.abs(node.height - point.y_0);
  if (distance < shortestDistance) {
    shortestDistance = distance;
    result = SOUTH_0;
  }
  distance = $wnd.Math.abs(point.x_0);
  if (distance < shortestDistance) {
    shortestDistance = distance;
    result = WEST_0;
  }
  distance = $wnd.Math.abs(node.width_0 - point.x_0);
  distance < shortestDistance && (result = EAST_0);
  return result;
}

function ElkGraphTransformer(componentSpacing){
  this.elementMapping = ($clinit_Maps() , new HashMap);
  this.incomingExtensionsMapping = new HashMap;
  this.outgoingExtensionsMapping = new HashMap;
  this.componentSpacing = componentSpacing;
}

defineClass(1069, 1, {}, ElkGraphTransformer);
_.componentSpacing = 0;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphTransformer_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphTransformer', 1069);
function $accept_2(this$static, elem, poly){
  var applier, edgeSection, points, shape_0;
  this$static.offset = poly.cp.offset;
  if (instanceOf(elem, 173)) {
    edgeSection = firstEdgeSection(castTo(elem, 100), false, false);
    points = createVectorChain(edgeSection);
    applier = new ElkGraphTransformer$OffsetApplier$OffSetToChainApplier(this$static);
    $forEach(points, applier);
    applyVectorChain(points, edgeSection);
    elem.getProperty(($clinit_CoreOptions() , JUNCTION_POINTS_0)) != null && $forEach(castTo(elem.getProperty(JUNCTION_POINTS_0), 74), applier);
  }
   else {
    shape_0 = castTo(elem, 444);
    shape_0.setX(shape_0.getX() + this$static.offset.x_0);
    shape_0.setY(shape_0.getY() + this$static.offset.y_0);
  }
}

function ElkGraphTransformer$OffsetApplier(){
}

defineClass(1070, 1, {}, ElkGraphTransformer$OffsetApplier);
_.accept_0 = function accept_48(elem, poly){
  $accept_2(this, castTo(elem, 202), castTo(poly, 256));
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphTransformer$OffsetApplier_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphTransformer/OffsetApplier', 1070);
function $accept_3(this$static, point){
  $add_18(point, this$static.this$11.offset.x_0, this$static.this$11.offset.y_0);
}

function ElkGraphTransformer$OffsetApplier$OffSetToChainApplier(this$1){
  this.this$11 = this$1;
}

defineClass(1071, 1, {}, ElkGraphTransformer$OffsetApplier$OffSetToChainApplier);
_.accept = function accept_49(point){
  $accept_3(this, castTo(point, 8));
}
;
var Lorg_eclipse_elk_alg_disco_transform_ElkGraphTransformer$OffsetApplier$OffSetToChainApplier_2_classLit = createForClass('org.eclipse.elk.alg.disco.transform', 'ElkGraphTransformer/OffsetApplier/OffSetToChainApplier', 1071);
function $buildIncidenceLists(graph){
  var edge, edge$iterator, incidence, n, node, node$iterator;
  n = graph.nodes.array.length;
  incidence = initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, n, 0, 1);
  for (node$iterator = new ArrayList$1(graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 149);
    incidence[node.id_0] = new LinkedList;
  }
  for (edge$iterator = new ArrayList$1(graph.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 274);
    incidence[edge.source.id_0].add_1(edge);
    incidence[edge.target.id_0].add_1(edge);
  }
  return incidence;
}

function $dfs_0(this$static, node, graph, visited, incidence){
  var component, edge, edge$iterator;
  if (!visited[node.id_0]) {
    visited[node.id_0] = true;
    component = graph;
    !graph && (component = new FGraph);
    $add_4(component.nodes, node);
    for (edge$iterator = incidence[node.id_0].iterator_0(); edge$iterator.hasNext_0();) {
      edge = castTo(edge$iterator.next_1(), 274);
      edge.source != node && $dfs_0(this$static, edge.source, component, visited, incidence);
      edge.target != node && $dfs_0(this$static, edge.target, component, visited, incidence);
      $add_4(component.edges, edge);
      $addAll_2(component.labels, edge.labels);
    }
    return component;
  }
  return null;
}

function $moveGraph(destGraph, sourceGraph, offsetx, offsety){
  var bendpoint, bendpoint$iterator, edge, edge$iterator, graphOffset, label_0, label$iterator, node, node$iterator;
  graphOffset = new KVector_1(offsetx, offsety);
  $sub_0(graphOffset, castTo($getProperty(sourceGraph, ($clinit_InternalProperties_0() , BB_UPLEFT)), 8));
  for (node$iterator = new ArrayList$1(sourceGraph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 149);
    $add_19(node.position, graphOffset);
    $add_4(destGraph.nodes, node);
  }
  for (edge$iterator = new ArrayList$1(sourceGraph.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 274);
    for (bendpoint$iterator = new ArrayList$1(edge.bendpoints); bendpoint$iterator.i < bendpoint$iterator.this$01.array.length;) {
      bendpoint = castTo($next_10(bendpoint$iterator), 524);
      $add_19(bendpoint.position, graphOffset);
    }
    $add_4(destGraph.edges, edge);
  }
  for (label$iterator = new ArrayList$1(sourceGraph.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 473);
    $add_19(label_0.position, graphOffset);
    $add_4(destGraph.labels, label_0);
  }
}

function $recombine(components){
  var broadestRow, graph, graph$iterator, graph$iterator0, graph$iterator1, highestBox, maxRowWidth, maxx, maxy, minx, miny, node, node$iterator, priority, result, size_0, spacing, totalArea, xpos, ypos;
  if (components.size_1() == 1) {
    return castTo(components.get_3(0), 210);
  }
   else if (components.size_1() <= 0) {
    return new FGraph;
  }
  for (graph$iterator0 = components.iterator_0(); graph$iterator0.hasNext_0();) {
    graph = castTo(graph$iterator0.next_1(), 210);
    priority = 0;
    minx = $intern_0;
    miny = $intern_0;
    maxx = $intern_43;
    maxy = $intern_43;
    for (node$iterator = new ArrayList$1(graph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 149);
      priority += castTo($getProperty(node, ($clinit_ForceOptions() , PRIORITY)), 21).value_0;
      minx = $wnd.Math.min(minx, node.position.x_0 - node.size_0.x_0 / 2);
      miny = $wnd.Math.min(miny, node.position.y_0 - node.size_0.y_0 / 2);
      maxx = $wnd.Math.max(maxx, node.position.x_0 + node.size_0.x_0 / 2);
      maxy = $wnd.Math.max(maxy, node.position.y_0 + node.size_0.y_0 / 2);
    }
    $setProperty_0(graph, ($clinit_ForceOptions() , PRIORITY), valueOf_4(priority));
    $setProperty_0(graph, ($clinit_InternalProperties_0() , BB_UPLEFT), new KVector_1(minx, miny));
    $setProperty_0(graph, BB_LOWRIGHT, new KVector_1(maxx, maxy));
  }
  $clinit_Collections();
  components.sort_0(new ComponentsProcessor$1);
  result = new FGraph;
  $copyProperties(result, castTo(components.get_3(0), 94));
  maxRowWidth = 0;
  totalArea = 0;
  for (graph$iterator1 = components.iterator_0(); graph$iterator1.hasNext_0();) {
    graph = castTo(graph$iterator1.next_1(), 210);
    size_0 = $sub_0($clone_0(castTo($getProperty(graph, ($clinit_InternalProperties_0() , BB_LOWRIGHT)), 8)), castTo($getProperty(graph, BB_UPLEFT), 8));
    maxRowWidth = $wnd.Math.max(maxRowWidth, size_0.x_0);
    totalArea += size_0.x_0 * size_0.y_0;
  }
  maxRowWidth = $wnd.Math.max(maxRowWidth, $wnd.Math.sqrt(totalArea) * checkNotNull_1(castToDouble($getProperty(result, ($clinit_ForceOptions() , ASPECT_RATIO_0)))));
  spacing = checkNotNull_1(castToDouble($getProperty(result, SPACING_NODE_NODE)));
  xpos = 0;
  ypos = 0;
  highestBox = 0;
  broadestRow = spacing;
  for (graph$iterator = components.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 210);
    size_0 = $sub_0($clone_0(castTo($getProperty(graph, ($clinit_InternalProperties_0() , BB_LOWRIGHT)), 8)), castTo($getProperty(graph, BB_UPLEFT), 8));
    if (xpos + size_0.x_0 > maxRowWidth) {
      xpos = 0;
      ypos += highestBox + spacing;
      highestBox = 0;
    }
    $moveGraph(result, graph, xpos, ypos);
    broadestRow = $wnd.Math.max(broadestRow, xpos + size_0.x_0);
    highestBox = $wnd.Math.max(highestBox, size_0.y_0);
    xpos += size_0.x_0 + spacing;
  }
  return result;
}

function $split_1(this$static, graph){
  var comp, comp$iterator, components, id_0, incidence, node, node$iterator, node$iterator0, separate, visited;
  separate = castToBoolean($getProperty(graph, ($clinit_ForceOptions() , SEPARATE_CONNECTED_COMPONENTS)));
  if (separate == null || (checkCriticalNotNull(separate) , separate)) {
    visited = initUnidimensionalArray(Z_classLit, $intern_93, 23, graph.nodes.array.length, 16, 1);
    incidence = $buildIncidenceLists(graph);
    components = new LinkedList;
    for (node$iterator0 = new ArrayList$1(graph.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 149);
      comp = $dfs_0(this$static, node, null, visited, incidence);
      if (comp) {
        $copyProperties(comp, graph);
        $addNode_0(components, comp, components.tail.prev, components.tail);
      }
    }
    if (components.size_0 > 1) {
      for (comp$iterator = $listIterator_1(components, 0); comp$iterator.currentNode != comp$iterator.this$01.tail;) {
        comp = castTo($next_13(comp$iterator), 210);
        id_0 = 0;
        for (node$iterator = new ArrayList$1(comp.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
          node = castTo($next_10(node$iterator), 149);
          node.id_0 = id_0++;
        }
      }
    }
    return components;
  }
  return newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_force_graph_FGraph_2_classLit, 1), $intern_103, 210, 0, [graph]));
}

function ComponentsProcessor(){
}

defineClass(693, 1, {}, ComponentsProcessor);
var Lorg_eclipse_elk_alg_force_ComponentsProcessor_2_classLit = createForClass('org.eclipse.elk.alg.force', 'ComponentsProcessor', 693);
function $compare_8(graph1, graph2){
  var prio, size1, size2;
  prio = castTo($getProperty(graph2, ($clinit_ForceOptions() , PRIORITY)), 21).value_0 - castTo($getProperty(graph1, PRIORITY), 21).value_0;
  if (prio == 0) {
    size1 = $sub_0($clone_0(castTo($getProperty(graph1, ($clinit_InternalProperties_0() , BB_LOWRIGHT)), 8)), castTo($getProperty(graph1, BB_UPLEFT), 8));
    size2 = $sub_0($clone_0(castTo($getProperty(graph2, BB_LOWRIGHT), 8)), castTo($getProperty(graph2, BB_UPLEFT), 8));
    return compare_5(size1.x_0 * size1.y_0, size2.x_0 * size2.y_0);
  }
  return prio;
}

function ComponentsProcessor$1(){
}

defineClass(1059, 1, $intern_40, ComponentsProcessor$1);
_.compare_0 = function compare_29(graph1, graph2){
  return $compare_8(castTo(graph1, 210), castTo(graph2, 210));
}
;
_.equals_0 = function equals_79(other){
  return this === other;
}
;
_.reversed = function reversed_21(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_force_ComponentsProcessor$1_2_classLit = createForClass('org.eclipse.elk.alg.force', 'ComponentsProcessor/1', 1059);
function $applyLayout_0(fgraph){
  var endLocation, fedge, fedge$iterator, flabel, flabel$iterator, fnode, fnode$iterator, height, kedge, kedgeSection, kgraph, klabel, knode, labelPos, maxXPos, maxYPos, minXPos, minYPos, node, node$iterator, nodePos, object, offset, padding, pos, size_0, startLocation, width_0, v, v_0;
  kgraph = castTo($getProperty(fgraph, ($clinit_InternalProperties_0() , ORIGIN)), 35);
  minXPos = $intern_0;
  minYPos = $intern_0;
  maxXPos = $intern_43;
  maxYPos = $intern_43;
  for (node$iterator = new ArrayList$1(fgraph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 149);
    pos = node.position;
    size_0 = node.size_0;
    minXPos = $wnd.Math.min(minXPos, pos.x_0 - size_0.x_0 / 2);
    minYPos = $wnd.Math.min(minYPos, pos.y_0 - size_0.y_0 / 2);
    maxXPos = $wnd.Math.max(maxXPos, pos.x_0 + size_0.x_0 / 2);
    maxYPos = $wnd.Math.max(maxYPos, pos.y_0 + size_0.y_0 / 2);
  }
  padding = castTo($getProperty_0(kgraph, ($clinit_ForceOptions() , PADDING_0)), 116);
  offset = new KVector_1(padding.left - minXPos, padding.top_0 - minYPos);
  for (fnode$iterator = new ArrayList$1(fgraph.nodes); fnode$iterator.i < fnode$iterator.this$01.array.length;) {
    fnode = castTo($next_10(fnode$iterator), 149);
    object = $getProperty(fnode, ORIGIN);
    if (instanceOf(object, 240)) {
      knode = castTo(object, 35);
      nodePos = $add_19(fnode.position, offset);
      $setLocation(knode, nodePos.x_0 - knode.width_0 / 2, nodePos.y_0 - knode.height / 2);
    }
  }
  for (fedge$iterator = new ArrayList$1(fgraph.edges); fedge$iterator.i < fedge$iterator.this$01.array.length;) {
    fedge = castTo($next_10(fedge$iterator), 274);
    kedge = castTo($getProperty(fedge, ORIGIN), 100);
    kedgeSection = firstEdgeSection(kedge, true, true);
    startLocation = (v = $sub_0($clone_0(fedge.target.position), fedge.source.position) , clipVector(v, fedge.source.size_0.x_0, fedge.source.size_0.y_0) , $add_19(v, fedge.source.position));
    $setStartLocation(kedgeSection, startLocation.x_0, startLocation.y_0);
    endLocation = (v_0 = $sub_0($clone_0(fedge.source.position), fedge.target.position) , clipVector(v_0, fedge.target.size_0.x_0, fedge.target.size_0.y_0) , $add_19(v_0, fedge.target.position));
    $setEndLocation(kedgeSection, endLocation.x_0, endLocation.y_0);
  }
  for (flabel$iterator = new ArrayList$1(fgraph.labels); flabel$iterator.i < flabel$iterator.this$01.array.length;) {
    flabel = castTo($next_10(flabel$iterator), 473);
    klabel = castTo($getProperty(flabel, ORIGIN), 135);
    labelPos = $add_19(flabel.position, offset);
    $setLocation(klabel, labelPos.x_0, labelPos.y_0);
  }
  width_0 = maxXPos - minXPos + (padding.left + padding.right);
  height = maxYPos - minYPos + (padding.top_0 + padding.bottom);
  resizeNode_1(kgraph, width_0, height, false, true);
}

function $importGraph_0(kgraph){
  var elemMap, fgraph;
  fgraph = new FGraph;
  $copyProperties(fgraph, kgraph);
  $setProperty_0(fgraph, ($clinit_InternalProperties_0() , ORIGIN), kgraph);
  elemMap = new HashMap;
  $transformNodes(kgraph, fgraph, elemMap);
  $transformEdges(kgraph, fgraph, elemMap);
  return fgraph;
}

function $transformEdges(parentNode, fgraph, elemMap){
  var kedge, kedge$iterator, klabel, klabel$iterator, knode, knode$iterator, newEdge, newLabel;
  for (knode$iterator = new AbstractEList$EIterator((!parentNode.children && (parentNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parentNode, 10, 11)) , parentNode.children)); knode$iterator.cursor != knode$iterator.this$01_2.size_1();) {
    knode = castTo($doNext(knode$iterator), 35);
    for (kedge$iterator = $iterator(allOutgoingEdges(knode)); $hasNext_0(kedge$iterator);) {
      kedge = castTo($next_2(kedge$iterator), 100);
      !kedge.sources && (kedge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, kedge, 4, 7));
      if (!(kedge.sources.size_0 <= 1 && (!kedge.targets && (kedge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, kedge, 5, 8)) , kedge.targets.size_0 <= 1))) {
        throw toJs(new UnsupportedGraphException('Graph must not contain hyperedges.'));
      }
      if (!$isHierarchical(kedge) && knode != connectableShapeToNode(castTo($get_16((!kedge.targets && (kedge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, kedge, 5, 8)) , kedge.targets), 0), 97))) {
        newEdge = new FEdge;
        $copyProperties(newEdge, kedge);
        $setProperty_0(newEdge, ($clinit_InternalProperties_0() , ORIGIN), kedge);
        $setSource(newEdge, castTo(getEntryValueOrNull($getEntry(elemMap.hashCodeMap, knode)), 149));
        $setTarget(newEdge, castTo($get_6(elemMap, connectableShapeToNode(castTo($get_16((!kedge.targets && (kedge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, kedge, 5, 8)) , kedge.targets), 0), 97))), 149));
        $add_4(fgraph.edges, newEdge);
        for (klabel$iterator = new AbstractEList$EIterator((!kedge.labels && (kedge.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, kedge, 1, 7)) , kedge.labels)); klabel$iterator.cursor != klabel$iterator.this$01_2.size_1();) {
          klabel = castTo($doNext(klabel$iterator), 135);
          newLabel = new FLabel(newEdge, klabel.text_0);
          $setProperty_0(newLabel, ORIGIN, klabel);
          newLabel.size_0.x_0 = $wnd.Math.max(klabel.width_0, 1);
          newLabel.size_0.y_0 = $wnd.Math.max(klabel.height, 1);
          $refreshPosition(newLabel);
          $add_4(fgraph.labels, newLabel);
        }
      }
    }
  }
}

function $transformNodes(parentNode, fgraph, elemMap){
  var index_0, knode, knode$iterator, label_0, newNode, portConstraints;
  index_0 = 0;
  for (knode$iterator = new AbstractEList$EIterator((!parentNode.children && (parentNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parentNode, 10, 11)) , parentNode.children)); knode$iterator.cursor != knode$iterator.this$01_2.size_1();) {
    knode = castTo($doNext(knode$iterator), 35);
    label_0 = '';
    (!knode.labels && (knode.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, knode, 1, 7)) , knode.labels).size_0 == 0 || (label_0 = castTo(castTo($get_16((!knode.labels && (knode.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, knode, 1, 7)) , knode.labels), 0), 135), 241).text_0);
    newNode = new FNode(label_0);
    $copyProperties(newNode, knode);
    $setProperty_0(newNode, ($clinit_InternalProperties_0() , ORIGIN), knode);
    newNode.id_0 = index_0++;
    newNode.position.x_0 = knode.x_0 + knode.width_0 / 2;
    newNode.position.y_0 = knode.y_0 + knode.height / 2;
    newNode.size_0.x_0 = $wnd.Math.max(knode.width_0, 1);
    newNode.size_0.y_0 = $wnd.Math.max(knode.height, 1);
    $add_4(fgraph.nodes, newNode);
    $put_4(elemMap.hashCodeMap, knode, newNode);
    portConstraints = castTo($getProperty_0(knode, ($clinit_ForceOptions() , PORT_CONSTRAINTS)), 83);
    portConstraints == ($clinit_PortConstraints() , UNDEFINED_6) && FREE;
  }
}

function $layout(this$static, kgraph, progressMonitor){
  var comp, comp$iterator, components, fgraph;
  $begin(progressMonitor, 'ELK Force', 1);
  fgraph = $importGraph_0(kgraph);
  $setOptions(fgraph);
  $updateModel(this$static, castTo($getProperty(fgraph, ($clinit_ForceOptions() , MODEL_0)), 403));
  components = $split_1(this$static.componentsProcessor, fgraph);
  for (comp$iterator = components.iterator_0(); comp$iterator.hasNext_0();) {
    comp = castTo(comp$iterator.next_1(), 210);
    $layout_0(this$static.forceModel, comp, $subTask(progressMonitor, 1 / components.size_1()));
  }
  fgraph = $recombine(components);
  $applyLayout_0(fgraph);
  $done_0(progressMonitor);
}

function $setOptions(fgraph){
  var randomSeed, val;
  randomSeed = castTo($getProperty(fgraph, ($clinit_ForceOptions() , RANDOM_SEED)), 21);
  if (randomSeed) {
    val = randomSeed.value_0;
    val == 0?$setProperty_0(fgraph, ($clinit_InternalProperties_0() , RANDOM), new Random):$setProperty_0(fgraph, ($clinit_InternalProperties_0() , RANDOM), new Random_0(val));
  }
   else {
    $setProperty_0(fgraph, ($clinit_InternalProperties_0() , RANDOM), new Random_0(1));
  }
}

function $updateModel(this$static, strategy){
  switch (strategy.ordinal) {
    case 0:
      instanceOf(this$static.forceModel, 595) || (this$static.forceModel = new EadesModel);
      break;
    case 1:
      instanceOf(this$static.forceModel, 596) || (this$static.forceModel = new FruchtermanReingoldModel);
  }
}

function ForceLayoutProvider(){
  this.componentsProcessor = new ComponentsProcessor;
}

defineClass(669, 197, $intern_100, ForceLayoutProvider);
_.layout = function layout_0(kgraph, progressMonitor){
  $layout(this, kgraph, progressMonitor);
}
;
var Lorg_eclipse_elk_alg_force_ForceLayoutProvider_2_classLit = createForClass('org.eclipse.elk.alg.force', 'ForceLayoutProvider', 669);
function FParticle(){
  this.position = new KVector;
  this.size_0 = new KVector;
}

defineClass(344, 130, {3:1, 344:1, 94:1, 130:1});
var Lorg_eclipse_elk_alg_force_graph_FParticle_2_classLit = createForClass('org.eclipse.elk.alg.force.graph', 'FParticle', 344);
function FBendpoint(edge){
  FParticle.call(this);
  this.edge = edge;
  $add_4(edge.bendpoints, this);
}

defineClass(524, 344, {3:1, 524:1, 344:1, 94:1, 130:1}, FBendpoint);
_.toString_0 = function toString_78(){
  var index_0;
  if (this.edge) {
    index_0 = $indexOf_3(this.edge.bendpoints, this, 0);
    return index_0 >= 0?'b' + index_0 + '[' + $toString_6(this.edge) + ']':'b[' + $toString_6(this.edge) + ']';
  }
  return 'b_' + getHashCode_0(this);
}
;
var Lorg_eclipse_elk_alg_force_graph_FBendpoint_2_classLit = createForClass('org.eclipse.elk.alg.force.graph', 'FBendpoint', 524);
function $distributeBendpoints(this$static){
  var bendPoint, bendPoint$iterator, count, incr, pos, sourcePos, targetPos;
  count = this$static.bendpoints.array.length;
  if (count > 0) {
    sourcePos = this$static.source.position;
    targetPos = this$static.target.position;
    incr = $scale($sub_0(new KVector_1(targetPos.x_0, targetPos.y_0), sourcePos), 1 / (count + 1));
    pos = new KVector_1(sourcePos.x_0, sourcePos.y_0);
    for (bendPoint$iterator = new ArrayList$1(this$static.bendpoints); bendPoint$iterator.i < bendPoint$iterator.this$01.array.length;) {
      bendPoint = castTo($next_10(bendPoint$iterator), 524);
      bendPoint.position.x_0 = pos.x_0;
      bendPoint.position.y_0 = pos.y_0;
      $add_19(pos, incr);
    }
  }
}

function $setSource(this$static, theSource){
  this$static.source = theSource;
}

function $setTarget(this$static, theTarget){
  this$static.target = theTarget;
}

function $toString_6(this$static){
  return !!this$static.source && !!this$static.target?$toString_7(this$static.source) + '->' + $toString_7(this$static.target):'e_' + getHashCode_0(this$static);
}

function FEdge(){
  this.bendpoints = new ArrayList;
  this.labels = new ArrayList;
}

defineClass(274, 130, {3:1, 274:1, 94:1, 130:1}, FEdge);
_.toString_0 = function toString_79(){
  return $toString_6(this);
}
;
var Lorg_eclipse_elk_alg_force_graph_FEdge_2_classLit = createForClass('org.eclipse.elk.alg.force.graph', 'FEdge', 274);
function $calcAdjacency(this$static){
  var edge, edge$iterator, n;
  n = this$static.nodes.array.length;
  this$static.adjacency = initMultidimensionalArray(I_classLit, [$intern_33, $intern_49], [40, 23], 15, [n, n], 2);
  for (edge$iterator = new ArrayList$1(this$static.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 274);
    this$static.adjacency[edge.source.id_0][edge.target.id_0] += castTo($getProperty(edge, ($clinit_ForceOptions() , PRIORITY)), 21).value_0;
  }
}

function $getConnection(this$static, particle1, particle2){
  var node1;
  if (instanceOf(particle1, 149) && !!particle2) {
    node1 = castTo(particle1, 149);
    return this$static.adjacency[node1.id_0][particle2.id_0] + this$static.adjacency[particle2.id_0][node1.id_0];
  }
  return 0;
}

function FGraph(){
  this.nodes = new ArrayList;
  this.edges = new ArrayList;
  this.labels = new ArrayList;
  this.bendPoints = new ArrayList;
}

defineClass(210, 130, {3:1, 210:1, 94:1, 130:1}, FGraph);
var Lorg_eclipse_elk_alg_force_graph_FGraph_2_classLit = createForClass('org.eclipse.elk.alg.force.graph', 'FGraph', 210);
function $refreshPosition(this$static){
  var pos, spacing, src_0, tgt;
  spacing = checkNotNull_1(castToDouble($getProperty(this$static.edge, ($clinit_ForceOptions() , SPACING_EDGE_LABEL))));
  src_0 = this$static.edge.source.position;
  tgt = this$static.edge.target.position;
  pos = this$static.position;
  if (src_0.x_0 >= tgt.x_0) {
    if (src_0.y_0 >= tgt.y_0) {
      pos.x_0 = tgt.x_0 + (src_0.x_0 - tgt.x_0) / 2 + spacing;
      pos.y_0 = tgt.y_0 + (src_0.y_0 - tgt.y_0) / 2 - spacing;
    }
     else {
      pos.x_0 = tgt.x_0 + (src_0.x_0 - tgt.x_0) / 2 + spacing;
      pos.y_0 = src_0.y_0 + (tgt.y_0 - src_0.y_0) / 2 + spacing;
    }
  }
   else {
    if (src_0.y_0 >= tgt.y_0) {
      pos.x_0 = src_0.x_0 + (tgt.x_0 - src_0.x_0) / 2 + spacing;
      pos.y_0 = tgt.y_0 + (src_0.y_0 - tgt.y_0) / 2 + spacing;
    }
     else {
      pos.x_0 = src_0.x_0 + (tgt.x_0 - src_0.x_0) / 2 + spacing;
      pos.y_0 = src_0.y_0 + (tgt.y_0 - src_0.y_0) / 2 - spacing;
    }
  }
}

function FLabel(fedge, text_0){
  FParticle.call(this);
  this.edge = fedge;
  this.text_0 = text_0;
  $add_4(this.edge.labels, this);
}

defineClass(473, 344, {3:1, 473:1, 344:1, 94:1, 130:1}, FLabel);
_.toString_0 = function toString_80(){
  return this.text_0 == null || this.text_0.length == 0?'l[' + $toString_6(this.edge) + ']':'l_' + this.text_0;
}
;
var Lorg_eclipse_elk_alg_force_graph_FLabel_2_classLit = createForClass('org.eclipse.elk.alg.force.graph', 'FLabel', 473);
function $toString_7(this$static){
  return this$static.label_0 == null || this$static.label_0.length == 0?'n_' + this$static.id_0:'n_' + this$static.label_0;
}

function FNode(label_0){
  FParticle.call(this);
  this.displacement = new KVector;
  this.label_0 = label_0;
}

defineClass(149, 344, {3:1, 149:1, 344:1, 94:1, 130:1}, FNode);
_.toString_0 = function toString_81(){
  return $toString_7(this);
}
;
_.id_0 = 0;
var Lorg_eclipse_elk_alg_force_graph_FNode_2_classLit = createForClass('org.eclipse.elk.alg.force.graph', 'FNode', 149);
function $initialize_0(this$static, fgraph){
  var bends, count, edge, edge$iterator, i, node, node$iterator, pos, posScale;
  this$static.graph_0 = fgraph;
  this$static.random_0 = castTo($getProperty(fgraph, ($clinit_InternalProperties_0() , RANDOM)), 221);
  $calcAdjacency(fgraph);
  this$static.dispBound = $wnd.Math.max(fgraph.nodes.array.length * 16 + fgraph.edges.array.length, 256);
  if (!checkNotNull_1(castToBoolean($getProperty(fgraph, ($clinit_ForceOptions() , INTERACTIVE))))) {
    posScale = this$static.graph_0.nodes.array.length;
    for (node$iterator = new ArrayList$1(fgraph.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 149);
      pos = node.position;
      pos.x_0 = $nextDouble(this$static.random_0) * posScale;
      pos.y_0 = $nextDouble(this$static.random_0) * posScale;
    }
  }
  bends = fgraph.bendPoints;
  for (edge$iterator = new ArrayList$1(fgraph.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 274);
    count = castTo($getProperty(edge, REPULSIVE_POWER_0), 21).value_0;
    if (count > 0) {
      for (i = 0; i < count; i++) {
        $add_4(bends, new FBendpoint(edge));
      }
      $distributeBendpoints(edge);
    }
  }
}

function $iterationDone(this$static){
  var edge, edge$iterator, label_0, label$iterator;
  for (edge$iterator = new ArrayList$1(this$static.graph_0.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 274);
    for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 473);
      $refreshPosition(label_0);
    }
    $distributeBendpoints(edge);
  }
}

function $layout_0(this$static, fgraph, monitor){
  var d, displacement, iterations, u, u$iterator, v, v$iterator, v$iterator0;
  $begin(monitor, 'Component Layout', 1);
  this$static.initialize(fgraph);
  iterations = 0;
  while (this$static.moreIterations(iterations)) {
    for (v$iterator0 = new ArrayList$1(fgraph.nodes); v$iterator0.i < v$iterator0.this$01.array.length;) {
      v = castTo($next_10(v$iterator0), 149);
      for (u$iterator = $iterator(concat_2(fgraph.nodes, fgraph.labels, fgraph.bendPoints)); $hasNext_0(u$iterator);) {
        u = castTo($next_2(u$iterator), 344);
        if (u != v) {
          displacement = this$static.calcDisplacement(u, v);
          $add_19(v.displacement, displacement);
        }
      }
    }
    for (v$iterator = new ArrayList$1(fgraph.nodes); v$iterator.i < v$iterator.this$01.array.length;) {
      v = castTo($next_10(v$iterator), 149);
      d = v.displacement;
      $bound(d, -this$static.dispBound, -this$static.dispBound, this$static.dispBound, this$static.dispBound);
      $add_19(v.position, d);
      $reset_5(d);
    }
    this$static.iterationDone();
    ++iterations;
  }
  $done_0(monitor);
}

function avoidSamePosition(random, u, v){
  var pu, pv;
  pu = u.position;
  pv = v.position;
  while (pu.x_0 - pv.x_0 == 0 && pu.y_0 - pv.y_0 == 0) {
    pu.x_0 += $nextInternal(random, 26) * $intern_81 + $nextInternal(random, 27) * $intern_82 - 0.5;
    pu.y_0 += $nextInternal(random, 26) * $intern_81 + $nextInternal(random, 27) * $intern_82 - 0.5;
    pv.x_0 += $nextInternal(random, 26) * $intern_81 + $nextInternal(random, 27) * $intern_82 - 0.5;
    pv.y_0 += $nextInternal(random, 26) * $intern_81 + $nextInternal(random, 27) * $intern_82 - 0.5;
  }
}

defineClass(1776, 1, {});
_.initialize = function initialize(fgraph){
  $initialize_0(this, fgraph);
}
;
_.iterationDone = function iterationDone(){
  $iterationDone(this);
}
;
_.dispBound = 0;
var Lorg_eclipse_elk_alg_force_model_AbstractForceModel_2_classLit = createForClass('org.eclipse.elk.alg.force.model', 'AbstractForceModel', 1776);
function EadesModel(){
  this.maxIterations = castTo($getDefault(($clinit_ForceOptions() , ITERATIONS_0)), 21).value_0;
  this.springLength = checkNotNull_1(castToDouble($getDefault(SPACING_NODE_NODE)));
  this.repulsionFactor = checkNotNull_1(castToDouble($getDefault(REPULSION_0)));
}

function attractive(d, s){
  return d > 0?$wnd.Math.log(d / s):-100;
}

function repulsive(d, r){
  return d > 0?r / (d * d):r * 100;
}

defineClass(595, 1776, {595:1}, EadesModel);
_.calcDisplacement = function calcDisplacement(forcer, forcee){
  var connection, d, displacement, force, length_0;
  avoidSamePosition(this.random_0, forcer, forcee);
  displacement = $sub_0($clone_0(forcee.position), forcer.position);
  length_0 = $wnd.Math.sqrt(displacement.x_0 * displacement.x_0 + displacement.y_0 * displacement.y_0);
  d = $wnd.Math.max(0, length_0 - $length(forcer.size_0) / 2 - $length(forcee.size_0) / 2);
  connection = $getConnection(this.graph_0, forcer, forcee);
  connection > 0?(force = -attractive(d, this.springLength) * connection):(force = repulsive(d, this.repulsionFactor) * castTo($getProperty(forcer, ($clinit_ForceOptions() , PRIORITY)), 21).value_0);
  $scale(displacement, force / length_0);
  return displacement;
}
;
_.initialize = function initialize_0(graph){
  $initialize_0(this, graph);
  this.maxIterations = castTo($getProperty(graph, ($clinit_ForceOptions() , ITERATIONS_0)), 21).value_0;
  this.springLength = checkNotNull_1(castToDouble($getProperty(graph, SPACING_NODE_NODE)));
  this.repulsionFactor = checkNotNull_1(castToDouble($getProperty(graph, REPULSION_0)));
}
;
_.moreIterations = function moreIterations(count){
  return count < this.maxIterations;
}
;
_.maxIterations = 0;
_.repulsionFactor = 0;
_.springLength = 0;
var Lorg_eclipse_elk_alg_force_model_EadesModel_2_classLit = createForClass('org.eclipse.elk.alg.force.model', 'EadesModel', 595);
function FruchtermanReingoldModel(){
  this.temperature = checkNotNull_1(castToDouble($getDefault(($clinit_ForceOptions() , TEMPERATURE_0))));
}

function attractive_0(d, k){
  return d * d / k;
}

function repulsive_0(d, k){
  return d > 0?k * k / d:k * k * 100;
}

defineClass(596, 1776, {596:1}, FruchtermanReingoldModel);
_.calcDisplacement = function calcDisplacement_0(forcer, forcee){
  var connection, d, displacement, force, length_0;
  avoidSamePosition(this.random_0, forcer, forcee);
  displacement = $sub_0($clone_0(forcee.position), forcer.position);
  length_0 = $wnd.Math.sqrt(displacement.x_0 * displacement.x_0 + displacement.y_0 * displacement.y_0);
  d = $wnd.Math.max(0, length_0 - $length(forcer.size_0) / 2 - $length(forcee.size_0) / 2);
  force = repulsive_0(d, this.k) * castTo($getProperty(forcer, ($clinit_ForceOptions() , PRIORITY)), 21).value_0;
  connection = $getConnection(this.graph_0, forcer, forcee);
  connection > 0 && (force -= attractive_0(d, this.k) * connection);
  $scale(displacement, force * this.temperature / length_0);
  return displacement;
}
;
_.initialize = function initialize_1(graph){
  var area, c, n, totalHeight, totalWidth, v, v$iterator;
  $initialize_0(this, graph);
  this.temperature = checkNotNull_1(castToDouble($getProperty(graph, ($clinit_ForceOptions() , TEMPERATURE_0))));
  this.threshold = this.temperature / castTo($getProperty(graph, ITERATIONS_0), 21).value_0;
  n = graph.nodes.array.length;
  totalWidth = 0;
  totalHeight = 0;
  for (v$iterator = new ArrayList$1(graph.nodes); v$iterator.i < v$iterator.this$01.array.length;) {
    v = castTo($next_10(v$iterator), 149);
    totalWidth += v.size_0.x_0;
    totalHeight += v.size_0.y_0;
  }
  area = totalWidth * totalHeight;
  c = checkNotNull_1(castToDouble($getProperty(graph, SPACING_NODE_NODE))) * $intern_96;
  this.k = $wnd.Math.sqrt(area / (2 * n)) * c;
}
;
_.iterationDone = function iterationDone_0(){
  $iterationDone(this);
  this.temperature -= this.threshold;
}
;
_.moreIterations = function moreIterations_0(count){
  return this.temperature > 0;
}
;
_.k = 0;
_.temperature = 0;
_.threshold = 0;
var Lorg_eclipse_elk_alg_force_model_FruchtermanReingoldModel_2_classLit = createForClass('org.eclipse.elk.alg.force.model', 'FruchtermanReingoldModel', 596);
function $clinit_ForceMetaDataProvider(){
  $clinit_ForceMetaDataProvider = emptyMethod;
  MODEL_DEFAULT = ($clinit_ForceModelStrategy() , FRUCHTERMAN_REINGOLD);
  MODEL = new Property_1('org.eclipse.elk.force.model', MODEL_DEFAULT);
  valueOf_4(1);
  ITERATIONS = new Property_1('org.eclipse.elk.force.iterations', valueOf_4(300));
  valueOf_4(0);
  REPULSIVE_POWER = new Property_1('org.eclipse.elk.force.repulsivePower', valueOf_4(0));
  new ExclusiveBounds$ExclusiveLowerBound;
  TEMPERATURE = new Property_1('org.eclipse.elk.force.temperature', $intern_104);
  new ExclusiveBounds$ExclusiveLowerBound;
  REPULSION = new Property_1('org.eclipse.elk.force.repulsion', 5);
  TEMPERATURE_DEP_MODEL_0 = FRUCHTERMAN_REINGOLD;
  REPULSION_DEP_MODEL_0 = EADES;
}

function ForceMetaDataProvider(){
  $clinit_ForceMetaDataProvider();
}

defineClass(779, 1, $intern_92, ForceMetaDataProvider);
_.apply_3 = function apply_48(registry){
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.force.model'), ''), 'Force Model'), 'Determines the model for force calculation.'), MODEL_DEFAULT), ($clinit_LayoutOptionData$Type() , ENUM)), Lorg_eclipse_elk_alg_force_options_ForceModelStrategy_2_classLit), of_0(($clinit_LayoutOptionData$Target() , PARENTS)))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.force.iterations'), ''), 'Iterations'), 'The number of iterations on the force model.'), valueOf_4(300)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.force.repulsivePower'), ''), 'Repulsive Power'), 'Determines how many bend points are added to the edge; such bend points are regarded as repelling particles in the force model'), valueOf_4(0)), INT), Ljava_lang_Integer_2_classLit), of_0(EDGES))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.force.temperature'), ''), 'FR Temperature'), 'The temperature is used as a scaling factor for particle displacements.'), $intern_104), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.force.temperature', 'org.eclipse.elk.force.model', TEMPERATURE_DEP_MODEL_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.force.repulsion'), ''), 'Eades Repulsion'), "Factor for repulsive forces in Eades' model."), 5), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.force.repulsion', 'org.eclipse.elk.force.model', REPULSION_DEP_MODEL_0);
  $apply_11((new ForceOptions , registry));
}
;
var ITERATIONS, MODEL, MODEL_DEFAULT, REPULSION, REPULSION_DEP_MODEL_0, REPULSIVE_POWER, TEMPERATURE, TEMPERATURE_DEP_MODEL_0;
var Lorg_eclipse_elk_alg_force_options_ForceMetaDataProvider_2_classLit = createForClass('org.eclipse.elk.alg.force.options', 'ForceMetaDataProvider', 779);
function $clinit_ForceModelStrategy(){
  $clinit_ForceModelStrategy = emptyMethod;
  EADES = new ForceModelStrategy('EADES', 0);
  FRUCHTERMAN_REINGOLD = new ForceModelStrategy('FRUCHTERMAN_REINGOLD', 1);
}

function ForceModelStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_25(name_0){
  $clinit_ForceModelStrategy();
  return valueOf(($clinit_ForceModelStrategy$Map() , $MAP_13), name_0);
}

function values_21(){
  $clinit_ForceModelStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_force_options_ForceModelStrategy_2_classLit, 1), $intern_38, 403, 0, [EADES, FRUCHTERMAN_REINGOLD]);
}

defineClass(403, 22, {3:1, 34:1, 22:1, 403:1}, ForceModelStrategy);
var EADES, FRUCHTERMAN_REINGOLD;
var Lorg_eclipse_elk_alg_force_options_ForceModelStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.force.options', 'ForceModelStrategy', 403, Ljava_lang_Enum_2_classLit, values_21, valueOf_25);
function $clinit_ForceModelStrategy$Map(){
  $clinit_ForceModelStrategy$Map = emptyMethod;
  $MAP_13 = createValueOfMap(($clinit_ForceModelStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_force_options_ForceModelStrategy_2_classLit, 1), $intern_38, 403, 0, [EADES, FRUCHTERMAN_REINGOLD])));
}

var $MAP_13;
function $clinit_ForceOptions(){
  $clinit_ForceOptions = emptyMethod;
  PRIORITY = new Property_2(($clinit_CoreOptions() , PRIORITY_3), valueOf_4(1));
  SPACING_NODE_NODE = new Property_2(SPACING_NODE_NODE_5, 80);
  SPACING_EDGE_LABEL = new Property_2(SPACING_EDGE_LABEL_1, 5);
  ASPECT_RATIO_0 = new Property_2(ASPECT_RATIO_4, $intern_105);
  RANDOM_SEED = new Property_2(RANDOM_SEED_1, valueOf_4(1));
  SEPARATE_CONNECTED_COMPONENTS = new Property_2(SEPARATE_CONNECTED_COMPONENTS_2, ($clinit_Boolean() , $clinit_Boolean() , true));
  PADDING_DEFAULT = new ElkPadding_0(50);
  PADDING_0 = new Property_2(PADDING_5, PADDING_DEFAULT);
  INTERACTIVE = INTERACTIVE_6;
  PORT_CONSTRAINTS = PORT_CONSTRAINTS_1;
  MODEL_0 = ($clinit_ForceMetaDataProvider() , MODEL);
  TEMPERATURE_0 = TEMPERATURE;
  ITERATIONS_0 = ITERATIONS;
  REPULSION_0 = REPULSION;
  REPULSIVE_POWER_0 = REPULSIVE_POWER;
}

function $apply_11(registry){
  $register(registry, new LayoutAlgorithmData($supportedFeatures($category($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.force'), 'ELK Force'), 'Force-based algorithm provided by the Eclipse Layout Kernel. Implements methods that follow physical analogies by simulating forces that move the nodes into a balanced distribution. Currently the original Eades model and the Fruchterman - Reingold model are supported.'), new ForceOptions$ForceFactory), 'org.eclipse.elk.force'), of_1(($clinit_GraphFeature() , MULTI_EDGES), stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_graph_properties_GraphFeature_2_classLit, 1), $intern_38, 238, 0, [EDGE_LABELS])))));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.priority', valueOf_4(1));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.spacing.nodeNode', 80);
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.spacing.edgeLabel', 5);
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.aspectRatio', $intern_105);
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.randomSeed', valueOf_4(1));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.separateConnectedComponents', ($clinit_Boolean() , $clinit_Boolean() , true));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.padding', PADDING_DEFAULT);
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.interactive', $getDefault(INTERACTIVE));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.portConstraints', $getDefault(PORT_CONSTRAINTS));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.force.model', $getDefault(MODEL_0));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.force.temperature', $getDefault(TEMPERATURE_0));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.force.iterations', $getDefault(ITERATIONS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.force.repulsion', $getDefault(REPULSION_0));
  $addOptionSupport(registry, 'org.eclipse.elk.force', 'org.eclipse.elk.force.repulsivePower', $getDefault(REPULSIVE_POWER_0));
}

function ForceOptions(){
  $clinit_ForceOptions();
}

defineClass(914, 1, $intern_92, ForceOptions);
_.apply_3 = function apply_49(registry){
  $apply_11(registry);
}
;
var ASPECT_RATIO_0, INTERACTIVE, ITERATIONS_0, MODEL_0, PADDING_0, PADDING_DEFAULT, PORT_CONSTRAINTS, PRIORITY, RANDOM_SEED, REPULSION_0, REPULSIVE_POWER_0, SEPARATE_CONNECTED_COMPONENTS, SPACING_EDGE_LABEL, SPACING_NODE_NODE, TEMPERATURE_0;
var Lorg_eclipse_elk_alg_force_options_ForceOptions_2_classLit = createForClass('org.eclipse.elk.alg.force.options', 'ForceOptions', 914);
function ForceOptions$ForceFactory(){
}

defineClass(915, 1, {}, ForceOptions$ForceFactory);
_.create_0 = function create_4(){
  var provider;
  return provider = new ForceLayoutProvider , provider;
}
;
_.destroy = function destroy_0(obj){
}
;
var Lorg_eclipse_elk_alg_force_options_ForceOptions$ForceFactory_2_classLit = createForClass('org.eclipse.elk.alg.force.options', 'ForceOptions/ForceFactory', 915);
function $clinit_InternalProperties_0(){
  $clinit_InternalProperties_0 = emptyMethod;
  ORIGIN = new Property('origin');
  RANDOM = new Property('random');
  BB_UPLEFT = new Property('boundingBox.upLeft');
  BB_LOWRIGHT = new Property('boundingBox.lowRight');
}

var BB_LOWRIGHT, BB_UPLEFT, ORIGIN, RANDOM;
function $clinit_StressMetaDataProvider(){
  $clinit_StressMetaDataProvider = emptyMethod;
  FIXED = new Property_1('org.eclipse.elk.stress.fixed', ($clinit_Boolean() , $clinit_Boolean() , false));
  DESIRED_EDGE_LENGTH = new Property_1('org.eclipse.elk.stress.desiredEdgeLength', 100);
  DIMENSION_DEFAULT = ($clinit_StressMajorization$Dimension() , XY);
  DIMENSION = new Property_1('org.eclipse.elk.stress.dimension', DIMENSION_DEFAULT);
  EPSILON = new Property_1('org.eclipse.elk.stress.epsilon', $intern_104);
  ITERATION_LIMIT = new Property_1('org.eclipse.elk.stress.iterationLimit', valueOf_4($intern_0));
}

function StressMetaDataProvider(){
  $clinit_StressMetaDataProvider();
}

defineClass(780, 1, $intern_92, StressMetaDataProvider);
_.apply_3 = function apply_50(registry){
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.stress.fixed'), ''), 'Fixed Position'), 'Prevent that the node is moved by the layout algorithm.'), ($clinit_Boolean() , $clinit_Boolean() , false)), ($clinit_LayoutOptionData$Type() , BOOLEAN)), Ljava_lang_Boolean_2_classLit), of_0(($clinit_LayoutOptionData$Target() , NODES)))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.stress.desiredEdgeLength'), ''), 'Desired Edge Length'), 'Either specified for parent nodes or for individual edges, where the latter takes higher precedence.'), 100), DOUBLE), Ljava_lang_Double_2_classLit), of_1(PARENTS, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [EDGES])))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.stress.dimension'), ''), 'Layout Dimension'), 'Dimensions that are permitted to be altered during layout.'), DIMENSION_DEFAULT), ENUM), Lorg_eclipse_elk_alg_force_stress_StressMajorization$Dimension_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.stress.epsilon'), ''), 'Stress Epsilon'), 'Termination criterion for the iterative process.'), $intern_104), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.stress.iterationLimit'), ''), 'Iteration Limit'), "Maximum number of performed iterations. Takes higher precedence than 'epsilon'."), valueOf_4($intern_0)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS))));
  $apply_12((new StressOptions , registry));
}
;
var DESIRED_EDGE_LENGTH, DIMENSION, DIMENSION_DEFAULT, EPSILON, FIXED, ITERATION_LIMIT;
var Lorg_eclipse_elk_alg_force_options_StressMetaDataProvider_2_classLit = createForClass('org.eclipse.elk.alg.force.options', 'StressMetaDataProvider', 780);
function $clinit_StressOptions(){
  $clinit_StressOptions = emptyMethod;
  INTERACTIVE_0 = ($clinit_CoreOptions() , INTERACTIVE_6);
  FIXED_0 = ($clinit_StressMetaDataProvider() , FIXED);
  DIMENSION_0 = DIMENSION;
  EPSILON_0 = EPSILON;
  ITERATION_LIMIT_0 = ITERATION_LIMIT;
  DESIRED_EDGE_LENGTH_0 = DESIRED_EDGE_LENGTH;
}

function $apply_12(registry){
  $register(registry, new LayoutAlgorithmData($category($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.stress'), 'ELK Stress'), "Minimizes the stress within a layout using stress majorization. Stress exists if the euclidean distance between a pair of nodes doesn't match their graph theoretic distance, that is, the shortest path between the two nodes. The method allows to specify individual edge lengths."), new StressOptions$StressFactory), 'org.eclipse.elk.force')));
  $addOptionSupport(registry, 'org.eclipse.elk.stress', 'org.eclipse.elk.interactive', $getDefault(INTERACTIVE_0));
  $addOptionSupport(registry, 'org.eclipse.elk.stress', 'org.eclipse.elk.stress.fixed', $getDefault(FIXED_0));
  $addOptionSupport(registry, 'org.eclipse.elk.stress', 'org.eclipse.elk.stress.dimension', $getDefault(DIMENSION_0));
  $addOptionSupport(registry, 'org.eclipse.elk.stress', 'org.eclipse.elk.stress.epsilon', $getDefault(EPSILON_0));
  $addOptionSupport(registry, 'org.eclipse.elk.stress', 'org.eclipse.elk.stress.iterationLimit', $getDefault(ITERATION_LIMIT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.stress', 'org.eclipse.elk.stress.desiredEdgeLength', $getDefault(DESIRED_EDGE_LENGTH_0));
}

function StressOptions(){
  $clinit_StressOptions();
}

defineClass(918, 1, $intern_92, StressOptions);
_.apply_3 = function apply_51(registry){
  $apply_12(registry);
}
;
var DESIRED_EDGE_LENGTH_0, DIMENSION_0, EPSILON_0, FIXED_0, INTERACTIVE_0, ITERATION_LIMIT_0;
var Lorg_eclipse_elk_alg_force_options_StressOptions_2_classLit = createForClass('org.eclipse.elk.alg.force.options', 'StressOptions', 918);
function StressOptions$StressFactory(){
}

defineClass(919, 1, {}, StressOptions$StressFactory);
_.create_0 = function create_5(){
  var provider;
  return provider = new StressLayoutProvider , provider;
}
;
_.destroy = function destroy_1(obj){
}
;
var Lorg_eclipse_elk_alg_force_options_StressOptions$StressFactory_2_classLit = createForClass('org.eclipse.elk.alg.force.options', 'StressOptions/StressFactory', 919);
function StressLayoutProvider(){
  this.componentsProcessor = new ComponentsProcessor;
  this.stressMajorization = new StressMajorization;
}

defineClass(997, 197, $intern_100, StressLayoutProvider);
_.layout = function layout_1(layoutGraph, progressMonitor){
  var components, fgraph, subGraph, subGraph$iterator;
  $begin(progressMonitor, 'ELK Stress', 1);
  checkNotNull_1(castToBoolean($getProperty_0(layoutGraph, ($clinit_StressOptions() , INTERACTIVE_0)))) || $layout(new ForceLayoutProvider, layoutGraph, $subTask(progressMonitor, 1));
  fgraph = $importGraph_0(layoutGraph);
  components = $split_1(this.componentsProcessor, fgraph);
  for (subGraph$iterator = components.iterator_0(); subGraph$iterator.hasNext_0();) {
    subGraph = castTo(subGraph$iterator.next_1(), 210);
    if (subGraph.nodes.array.length <= 1) {
      continue;
    }
    $initialize_1(this.stressMajorization, subGraph);
    $execute_0(this.stressMajorization);
  }
  fgraph = $recombine(components);
  $applyLayout_0(fgraph);
  $done_0(progressMonitor);
}
;
var Lorg_eclipse_elk_alg_force_stress_StressLayoutProvider_2_classLit = createForClass('org.eclipse.elk.alg.force.stress', 'StressLayoutProvider', 997);
function $computeNewPosition(this$static, u){
  var eucDist, v, v$iterator, weightSum, wij, xDisp, yDisp;
  weightSum = 0;
  xDisp = 0;
  yDisp = 0;
  for (v$iterator = new ArrayList$1(this$static.graph_0.nodes); v$iterator.i < v$iterator.this$01.array.length;) {
    v = castTo($next_10(v$iterator), 149);
    if (u == v) {
      continue;
    }
    wij = this$static.w[u.id_0][v.id_0];
    weightSum += wij;
    eucDist = $distance_0(u.position, v.position);
    eucDist > 0 && this$static.dim != ($clinit_StressMajorization$Dimension() , Y) && (xDisp += wij * (v.position.x_0 + this$static.apsp[u.id_0][v.id_0] * (u.position.x_0 - v.position.x_0) / eucDist));
    eucDist > 0 && this$static.dim != ($clinit_StressMajorization$Dimension() , X) && (yDisp += wij * (v.position.y_0 + this$static.apsp[u.id_0][v.id_0] * (u.position.y_0 - v.position.y_0) / eucDist));
  }
  switch (this$static.dim.ordinal) {
    case 1:
      return new KVector_1(xDisp / weightSum, u.position.y_0);
    case 2:
      return new KVector_1(u.position.x_0, yDisp / weightSum);
    default:return new KVector_1(xDisp / weightSum, yDisp / weightSum);
  }
}

function $computeStress(this$static){
  var eucDisplacement, eucDist, i, j, nodes, stress, u, v;
  stress = 0;
  nodes = this$static.graph_0.nodes;
  for (i = 0; i < nodes.array.length; ++i) {
    u = (checkCriticalElementIndex(i, nodes.array.length) , castTo(nodes.array[i], 149));
    for (j = i + 1; j < nodes.array.length; ++j) {
      v = (checkCriticalElementIndex(j, nodes.array.length) , castTo(nodes.array[j], 149));
      eucDist = $distance_0(u.position, v.position);
      eucDisplacement = eucDist - this$static.apsp[u.id_0][v.id_0];
      stress += this$static.w[u.id_0][v.id_0] * eucDisplacement * eucDisplacement;
    }
  }
  return stress;
}

function $dijkstra(this$static, source, dist){
  var d, e, e$iterator, el, mark, n, n$iterator, nodes, u, v;
  nodes = new PriorityQueue(new StressMajorization$lambda$0$Type(dist));
  mark = initUnidimensionalArray(Z_classLit, $intern_93, 23, this$static.graph_0.nodes.array.length, 16, 1);
  fill0_3(mark, mark.length);
  dist[source.id_0] = 0;
  for (n$iterator = new ArrayList$1(this$static.graph_0.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 149);
    n.id_0 != source.id_0 && (dist[n.id_0] = $intern_0);
    checkCriticalState_0($offer(nodes, n));
  }
  while (nodes.heap.array.length != 0) {
    u = castTo($poll_0(nodes), 149);
    mark[u.id_0] = true;
    for (e$iterator = $listIterator(new LinkedListMultimap$1(this$static.connectedEdges, u), 0); e$iterator.next_0;) {
      e = castTo($next_5(e$iterator), 274);
      v = $getOther_0(e, u);
      if (mark[v.id_0]) {
        continue;
      }
      $hasProperty(e, ($clinit_StressOptions() , DESIRED_EDGE_LENGTH_0))?(el = checkNotNull_1(castToDouble($getProperty(e, DESIRED_EDGE_LENGTH_0)))):(el = this$static.desiredEdgeLength);
      d = dist[u.id_0] + el;
      if (d < dist[v.id_0]) {
        dist[v.id_0] = d;
        $remove_25(nodes, v);
        checkCriticalState_0($offer(nodes, v));
      }
    }
  }
}

function $done(this$static, count, prevStress, curStress){
  return prevStress == 0 || (prevStress - curStress) / prevStress < this$static.epsilon || count >= this$static.iterationLimit;
}

function $execute_0(this$static){
  var count, curStress, newPos, prevStress, u, u$iterator;
  if (this$static.graph_0.nodes.array.length <= 1) {
    return;
  }
  count = 0;
  prevStress = $computeStress(this$static);
  curStress = $intern_62;
  do {
    count > 0 && (prevStress = curStress);
    for (u$iterator = new ArrayList$1(this$static.graph_0.nodes); u$iterator.i < u$iterator.this$01.array.length;) {
      u = castTo($next_10(u$iterator), 149);
      if (checkNotNull_1(castToBoolean($getProperty(u, ($clinit_StressOptions() , FIXED_0))))) {
        continue;
      }
      newPos = $computeNewPosition(this$static, u);
      $add_19($reset_5(u.position), newPos);
    }
    curStress = $computeStress(this$static);
  }
   while (!$done(this$static, count++, prevStress, curStress));
}

function $getOther_0(edge, one){
  if (edge.source == one) {
    return edge.target;
  }
   else if (edge.target == one) {
    return edge.source;
  }
   else {
    throw toJs(new IllegalArgumentException_0("Node 'one' must be either source or target of edge 'edge'."));
  }
}

function $initialize_1(this$static, fgraph){
  var dij, edge, edge$iterator, i, j, n, source, source$iterator, wij;
  if (fgraph.nodes.array.length <= 1) {
    return;
  }
  this$static.graph_0 = fgraph;
  this$static.dim = castTo($getProperty(this$static.graph_0, ($clinit_StressOptions() , DIMENSION_0)), 360);
  this$static.iterationLimit = castTo($getProperty(this$static.graph_0, ITERATION_LIMIT_0), 21).value_0;
  this$static.epsilon = checkNotNull_1(castToDouble($getProperty(this$static.graph_0, EPSILON_0)));
  this$static.desiredEdgeLength = checkNotNull_1(castToDouble($getProperty(this$static.graph_0, DESIRED_EDGE_LENGTH_0)));
  $clear_2(this$static.connectedEdges);
  for (edge$iterator = new ArrayList$1(this$static.graph_0.edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 274);
    $addNode(this$static.connectedEdges, edge.source, edge, null);
    $addNode(this$static.connectedEdges, edge.target, edge, null);
  }
  n = this$static.graph_0.nodes.array.length;
  this$static.apsp = initMultidimensionalArray(D_classLit, [$intern_33, $intern_69], [108, 23], 15, [n, n], 2);
  for (source$iterator = new ArrayList$1(this$static.graph_0.nodes); source$iterator.i < source$iterator.this$01.array.length;) {
    source = castTo($next_10(source$iterator), 149);
    $dijkstra(this$static, source, this$static.apsp[source.id_0]);
  }
  this$static.w = initMultidimensionalArray(D_classLit, [$intern_33, $intern_69], [108, 23], 15, [n, n], 2);
  for (i = 0; i < n; ++i) {
    for (j = 0; j < n; ++j) {
      dij = this$static.apsp[i][j];
      wij = 1 / (dij * dij);
      this$static.w[i][j] = wij;
    }
  }
}

function StressMajorization(){
  this.connectedEdges = new LinkedListMultimap;
}

function lambda$0_8(dist_0, n1_1, n2_2){
  return compare_5(dist_0[n1_1.id_0], dist_0[n2_2.id_0]);
}

defineClass(916, 1, {}, StressMajorization);
_.desiredEdgeLength = 0;
_.epsilon = 0;
_.iterationLimit = 0;
var Lorg_eclipse_elk_alg_force_stress_StressMajorization_2_classLit = createForClass('org.eclipse.elk.alg.force.stress', 'StressMajorization', 916);
function $clinit_StressMajorization$Dimension(){
  $clinit_StressMajorization$Dimension = emptyMethod;
  XY = new StressMajorization$Dimension('XY', 0);
  X = new StressMajorization$Dimension('X', 1);
  Y = new StressMajorization$Dimension('Y', 2);
}

function StressMajorization$Dimension(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_26(name_0){
  $clinit_StressMajorization$Dimension();
  return valueOf(($clinit_StressMajorization$Dimension$Map() , $MAP_14), name_0);
}

function values_22(){
  $clinit_StressMajorization$Dimension();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_force_stress_StressMajorization$Dimension_2_classLit, 1), $intern_38, 360, 0, [XY, X, Y]);
}

defineClass(360, 22, {3:1, 34:1, 22:1, 360:1}, StressMajorization$Dimension);
var X, XY, Y;
var Lorg_eclipse_elk_alg_force_stress_StressMajorization$Dimension_2_classLit = createForEnum('org.eclipse.elk.alg.force.stress', 'StressMajorization/Dimension', 360, Ljava_lang_Enum_2_classLit, values_22, valueOf_26);
function $clinit_StressMajorization$Dimension$Map(){
  $clinit_StressMajorization$Dimension$Map = emptyMethod;
  $MAP_14 = createValueOfMap(($clinit_StressMajorization$Dimension() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_force_stress_StressMajorization$Dimension_2_classLit, 1), $intern_38, 360, 0, [XY, X, Y])));
}

var $MAP_14;
function StressMajorization$lambda$0$Type(dist_0){
  this.dist_0 = dist_0;
}

defineClass(917, 1, $intern_40, StressMajorization$lambda$0$Type);
_.equals_0 = function equals_80(other){
  return this === other;
}
;
_.reversed = function reversed_22(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_30(arg0, arg1){
  return lambda$0_8(this.dist_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_force_stress_StressMajorization$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.force.stress', 'StressMajorization/lambda$0$Type', 917);
function $collectAllGraphsBottomUp(root){
  var collectedGraphs, continueSearchingTheseGraphs, nestedGraph, nextGraph, node, node$iterator;
  collectedGraphs = new ArrayDeque;
  continueSearchingTheseGraphs = new ArrayDeque;
  $addFirst(collectedGraphs, root);
  $addFirst(continueSearchingTheseGraphs, root);
  while (continueSearchingTheseGraphs.head != continueSearchingTheseGraphs.tail) {
    nextGraph = castTo($removeFirst(continueSearchingTheseGraphs), 32);
    for (node$iterator = new ArrayList$1(nextGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (castTo($getProperty(node, ($clinit_InternalProperties_1() , NESTED_LGRAPH)), 32)) {
        nestedGraph = castTo($getProperty(node, NESTED_LGRAPH), 32);
        $addFirst(collectedGraphs, nestedGraph);
        $addFirst(continueSearchingTheseGraphs, nestedGraph);
      }
    }
  }
  return collectedGraphs;
}

function $doCompoundLayout(this$static, lgraph, monitor){
  var theMonitor;
  theMonitor = monitor;
  !monitor && (theMonitor = new BasicProgressMonitor_0);
  $begin(theMonitor, 'Layered layout', 2);
  $process_1(this$static.compoundGraphPreprocessor, lgraph, $subTask(theMonitor, 1));
  $hierarchicalLayout(this$static, lgraph, $subTask(theMonitor, 1));
  $process_0(lgraph, $subTask(theMonitor, 1));
  $done_0(theMonitor);
}

function $doLayout(this$static, lgraph, monitor){
  var comp, comp$iterator, compWork, components, theMonitor;
  theMonitor = monitor;
  !monitor && (theMonitor = new BasicProgressMonitor_0);
  $begin(theMonitor, 'Layered layout', 1);
  $prepareGraphForLayout(this$static.graphConfigurator, lgraph);
  components = $split_2(this$static.componentsProcessor, lgraph);
  if (components.size_1() == 1) {
    $layout_1(castTo(components.get_3(0), 32), theMonitor);
  }
   else {
    compWork = 1 / components.size_1();
    for (comp$iterator = components.iterator_0(); comp$iterator.hasNext_0();) {
      comp = castTo(comp$iterator.next_1(), 32);
      $layout_1(comp, $subTask(theMonitor, compWork));
    }
  }
  $combine(this$static.componentsProcessor, components, lgraph);
  $resizeGraph(lgraph);
  $done_0(theMonitor);
}

function $hierarchicalLayout(this$static, lgraph, monitor){
  var algorithm, g, g$iterator, graph, graphAndAlgorithm, graphAndAlgorithm$iterator, graphs, graphsAndAlgorithms, processor, processors, rootProcessors, work, parentCms;
  graphs = $collectAllGraphsBottomUp(lgraph);
  parentCms = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , CROSSING_MINIMIZATION_STRATEGY_0)), 325);
  parentCms != ($clinit_CrossingMinimizationStrategy() , LAYER_SWEEP) && $forEach(graphs, new ElkLayered$lambda$0$Type(parentCms));
  activateGreedySwitchFor(lgraph) || $forEach(graphs, new ElkLayered$lambda$1$Type);
  work = 0;
  graphsAndAlgorithms = new ArrayList;
  for (g$iterator = new ArrayDeque$IteratorImpl(graphs); g$iterator.currentIndex != g$iterator.fence;) {
    g = castTo($next_9(g$iterator), 32);
    $prepareGraphForLayout(this$static.graphConfigurator, g);
    processors = castTo($getProperty(g, ($clinit_InternalProperties_1() , PROCESSORS)), 15);
    work += processors.size_1();
    algorithm = processors.iterator_0();
    $add_4(graphsAndAlgorithms, new Pair(g, algorithm));
  }
  $begin(monitor, 'Recursive hierarchical layout', work);
  rootProcessors = castTo(castTo($get_7(graphsAndAlgorithms, graphsAndAlgorithms.array.length - 1), 37).second, 47);
  while (rootProcessors.hasNext_0()) {
    for (graphAndAlgorithm$iterator = new ArrayList$1(graphsAndAlgorithms); graphAndAlgorithm$iterator.i < graphAndAlgorithm$iterator.this$01.array.length;) {
      graphAndAlgorithm = castTo($next_10(graphAndAlgorithm$iterator), 37);
      processors = castTo(graphAndAlgorithm.second, 47);
      graph = castTo(graphAndAlgorithm.first, 32);
      while (processors.hasNext_0()) {
        processor = castTo(processors.next_1(), 45);
        if (instanceOf(processor, 477)) {
          if (!castTo($getProperty(graph, ($clinit_InternalProperties_1() , PARENT_LNODE)), 9)) {
            processor.process(graph, $subTask(monitor, 1));
            break;
          }
           else {
            break;
          }
        }
         else {
          processor.process(graph, $subTask(monitor, 1));
        }
      }
    }
  }
  $done_0(monitor);
}

function $layout_1(lgraph, monitor){
  var algorithm, gwtDoesntSupportPrintf, layer, layer$iterator, monitorProgress, monitorStarted, node, node$iterator, processor, processor$iterator, processor$iterator0, slot;
  monitorStarted = monitor.taskName != null && !monitor.closed_0;
  monitorStarted || $begin(monitor, 'Component Layout', 1);
  algorithm = castTo($getProperty(lgraph, ($clinit_InternalProperties_1() , PROCESSORS)), 15);
  monitorProgress = 1 / algorithm.size_1();
  if (checkNotNull_1(castToBoolean($getProperty(lgraph, ($clinit_LayeredOptions() , DEBUG_MODE))))) {
    $clinit_System();
    'ELK Layered uses the following ' + algorithm.size_1() + ' modules:';
    slot = 0;
    for (processor$iterator0 = algorithm.iterator_0(); processor$iterator0.hasNext_0();) {
      processor = castTo(processor$iterator0.next_1(), 45);
      gwtDoesntSupportPrintf = (slot < 10?'0':'') + slot++;
      '   Slot ' + gwtDoesntSupportPrintf + ': ' + $getName(getClass__Ljava_lang_Class___devirtual$(processor));
    }
    for (processor$iterator = algorithm.iterator_0(); processor$iterator.hasNext_0();) {
      processor = castTo(processor$iterator.next_1(), 45);
      processor.process(lgraph, $subTask(monitor, monitorProgress));
    }
  }
   else {
    for (processor$iterator = algorithm.iterator_0(); processor$iterator.hasNext_0();) {
      processor = castTo(processor$iterator.next_1(), 45);
      processor.process(lgraph, $subTask(monitor, monitorProgress));
    }
  }
  for (layer$iterator = new ArrayList$1(lgraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    $addAll_2(lgraph.layerlessNodes, layer.nodes);
    layer.nodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  }
  for (node$iterator = new ArrayList$1(lgraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $setLayer_0(node, null);
  }
  lgraph.layers.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  monitorStarted || $done_0(monitor);
}

function $resizeGraph(lgraph){
  var adjustedSize, calculatedSize, minSize, sizeConstraint, sizeOptions;
  sizeConstraint = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , NODE_SIZE_CONSTRAINTS)), 19);
  sizeOptions = castTo($getProperty(lgraph, NODE_SIZE_OPTIONS), 19);
  calculatedSize = new KVector_1(lgraph.size_0.x_0 + lgraph.padding.left + lgraph.padding.right, lgraph.size_0.y_0 + lgraph.padding.top_0 + lgraph.padding.bottom);
  adjustedSize = new KVector_2(calculatedSize);
  if (sizeConstraint.contains(($clinit_SizeConstraint() , MINIMUM_SIZE))) {
    minSize = castTo($getProperty(lgraph, NODE_SIZE_MINIMUM), 8);
    if (sizeOptions.contains(($clinit_SizeOptions() , DEFAULT_MINIMUM_SIZE))) {
      minSize.x_0 <= 0 && (minSize.x_0 = 20);
      minSize.y_0 <= 0 && (minSize.y_0 = 20);
    }
    adjustedSize.x_0 = $wnd.Math.max(calculatedSize.x_0, minSize.x_0);
    adjustedSize.y_0 = $wnd.Math.max(calculatedSize.y_0, minSize.y_0);
  }
  $resizeGraphNoReallyIMeanIt(lgraph, calculatedSize, adjustedSize);
}

function $resizeGraphNoReallyIMeanIt(lgraph, oldSize, newSize){
  var contentAlignment, extPortSide, lPadding, node, node$iterator;
  contentAlignment = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , CONTENT_ALIGNMENT_0)), 19);
  newSize.x_0 > oldSize.x_0 && (contentAlignment.contains(($clinit_ContentAlignment() , H_CENTER))?(lgraph.offset.x_0 += (newSize.x_0 - oldSize.x_0) / 2):contentAlignment.contains(H_RIGHT) && (lgraph.offset.x_0 += newSize.x_0 - oldSize.x_0));
  newSize.y_0 > oldSize.y_0 && (contentAlignment.contains(($clinit_ContentAlignment() , V_CENTER))?(lgraph.offset.y_0 += (newSize.y_0 - oldSize.y_0) / 2):contentAlignment.contains(V_BOTTOM) && (lgraph.offset.y_0 += newSize.y_0 - oldSize.y_0));
  if (castTo($getProperty(lgraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS)) && (newSize.x_0 > oldSize.x_0 || newSize.y_0 > oldSize.y_0)) {
    for (node$iterator = new ArrayList$1(lgraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        extPortSide = castTo($getProperty(node, EXT_PORT_SIDE), 71);
        extPortSide == ($clinit_PortSide() , EAST_1)?(node.pos.x_0 += newSize.x_0 - oldSize.x_0):extPortSide == SOUTH_1 && (node.pos.y_0 += newSize.y_0 - oldSize.y_0);
      }
    }
  }
  lPadding = lgraph.padding;
  lgraph.size_0.x_0 = newSize.x_0 - lPadding.left - lPadding.right;
  lgraph.size_0.y_0 = newSize.y_0 - lPadding.top_0 - lPadding.bottom;
}

function ElkLayered(){
  this.graphConfigurator = new GraphConfigurator;
  this.componentsProcessor = new ComponentsProcessor_0;
  this.compoundGraphPreprocessor = new CompoundGraphPreprocessor;
  $clinit_CompoundGraphPostprocessor();
}

function lambda$0_9(parentCms_0, child_1){
  var childCms;
  childCms = castTo($getProperty(child_1, ($clinit_LayeredOptions() , CROSSING_MINIMIZATION_STRATEGY_0)), 325);
  childCms == ($clinit_CrossingMinimizationStrategy() , LAYER_SWEEP) && $setProperty_0(child_1, CROSSING_MINIMIZATION_STRATEGY_0, parentCms_0);
}

defineClass(1056, 1, {}, ElkLayered);
var Lorg_eclipse_elk_alg_layered_ElkLayered_2_classLit = createForClass('org.eclipse.elk.alg.layered', 'ElkLayered', 1056);
function ElkLayered$lambda$0$Type(parentCms_0){
  this.parentCms_0 = parentCms_0;
}

defineClass(1057, 1, {}, ElkLayered$lambda$0$Type);
_.accept = function accept_50(arg0){
  lambda$0_9(this.parentCms_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_ElkLayered$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered', 'ElkLayered/lambda$0$Type', 1057);
function ElkLayered$lambda$1$Type(){
}

defineClass(1058, 1, {}, ElkLayered$lambda$1$Type);
_.accept = function accept_51(arg0){
  $setProperty_0(castTo(arg0, 32), ($clinit_LayeredOptions() , CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_0), ($clinit_GreedySwitchType() , OFF));
}
;
var Lorg_eclipse_elk_alg_layered_ElkLayered$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered', 'ElkLayered/lambda$1$Type', 1058);
function $clinit_GraphConfigurator(){
  $clinit_GraphConfigurator = emptyMethod;
  BASELINE_PROCESSING_CONFIGURATION = $addBefore($addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P4_NODE_PLACEMENT), ($clinit_IntermediateProcessorStrategy() , NODE_MARGIN_CALCULATOR)), P4_NODE_PLACEMENT, LABEL_AND_NODE_SIZE_PROCESSOR), P5_EDGE_ROUTING, LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR);
  LABEL_MANAGEMENT_ADDITIONS = $addBefore($addBefore(new LayoutProcessorConfiguration, P4_NODE_PLACEMENT, CENTER_LABEL_MANAGEMENT_PROCESSOR), P4_NODE_PLACEMENT, END_NODE_PORT_LABEL_MANAGEMENT_PROCESSOR);
  HIERARCHICAL_ADDITIONS = $addAfter(new LayoutProcessorConfiguration, P5_EDGE_ROUTING, HIERARCHICAL_NODE_RESIZER);
}

function $getPhaseIndependentLayoutProcessorConfiguration(lgraph){
  var configuration, graphProperties, greedySwitchType, hierarchyHandling, internalGreedyType;
  graphProperties = castTo($getProperty(lgraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19);
  configuration = createFrom_0(BASELINE_PROCESSING_CONFIGURATION);
  hierarchyHandling = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , HIERARCHY_HANDLING)), 324);
  hierarchyHandling == ($clinit_HierarchyHandling() , INCLUDE_CHILDREN) && $addAll_4(configuration, HIERARCHICAL_ADDITIONS);
  checkNotNull_1(castToBoolean($getProperty(lgraph, FEEDBACK_EDGES_0)))?$addBefore(configuration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , PORT_SIDE_PROCESSOR)):$addBefore(configuration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , PORT_SIDE_PROCESSOR));
  $getProperty(lgraph, ($clinit_LabelManagementOptions() , LABEL_MANAGER)) != null && $addAll_4(configuration, LABEL_MANAGEMENT_ADDITIONS);
  switch (castTo($getProperty(lgraph, DIRECTION), 107).ordinal) {
    case 2:
    case 3:
    case 4:
      $addAfter($addBefore(configuration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , DIRECTION_PREPROCESSOR)), P5_EDGE_ROUTING, DIRECTION_POSTPROCESSOR);
  }
  graphProperties.contains(($clinit_GraphProperties() , COMMENTS)) && $addAfter($addBefore(configuration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , COMMENT_PREPROCESSOR)), P5_EDGE_ROUTING, COMMENT_POSTPROCESSOR);
  maskUndefined($getProperty(lgraph, LAYERING_NODE_PROMOTION_STRATEGY_0)) !== maskUndefined(($clinit_NodePromotionStrategy() , NONE_6)) && $addBefore(configuration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , NODE_PROMOTION));
  if (graphProperties.contains(PARTITIONS)) {
    $addBefore(configuration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , PARTITION_PREPROCESSOR));
    $addBefore(configuration, P3_NODE_ORDERING, PARTITION_POSTPROCESSOR);
  }
  maskUndefined($getProperty(lgraph, COMPACTION_POST_COMPACTION_STRATEGY_0)) !== maskUndefined(($clinit_GraphCompactionStrategy() , NONE_2)) && maskUndefined($getProperty(lgraph, EDGE_ROUTING)) !== maskUndefined(($clinit_EdgeRouting() , POLYLINE)) && $addAfter(configuration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , HORIZONTAL_COMPACTOR));
  checkNotNull_1(castToBoolean($getProperty(lgraph, HIGH_DEGREE_NODES_TREATMENT_0))) && $addBefore(configuration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , HIGH_DEGREE_NODE_LAYER_PROCESSOR));
  checkNotNull_1(castToBoolean($getProperty(lgraph, CROSSING_MINIMIZATION_SEMI_INTERACTIVE_0))) && $addBefore(configuration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , SEMI_INTERACTIVE_CROSSMIN_PROCESSOR));
  if (activateGreedySwitchFor(lgraph)) {
    greedySwitchType = castTo($getProperty(lgraph, CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_0), 326);
    internalGreedyType = greedySwitchType == ($clinit_GreedySwitchType() , ONE_SIDED)?($clinit_IntermediateProcessorStrategy() , ONE_SIDED_GREEDY_SWITCH):($clinit_IntermediateProcessorStrategy() , TWO_SIDED_GREEDY_SWITCH);
    $addBefore(configuration, ($clinit_LayeredPhases() , P4_NODE_PLACEMENT), internalGreedyType);
  }
  switch (castTo($getProperty(lgraph, WRAPPING_STRATEGY_0), 359).ordinal) {
    case 1:
      $addBefore(configuration, ($clinit_LayeredPhases() , P4_NODE_PLACEMENT), ($clinit_IntermediateProcessorStrategy() , SINGLE_EDGE_GRAPH_WRAPPER));
      break;
    case 2:
      $addAfter($addBefore($addBefore(configuration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , BREAKING_POINT_INSERTER)), P4_NODE_PLACEMENT, BREAKING_POINT_PROCESSOR), P5_EDGE_ROUTING, BREAKING_POINT_REMOVER);
  }
  return configuration;
}

function $prepareGraphForLayout(this$static, lgraph){
  var edgeSpacing, direction, randomSeed, favorStraightness, spacings;
  edgeSpacing = checkNotNull_1(castToDouble($getProperty(lgraph, ($clinit_LayeredOptions() , SPACING_EDGE_EDGE))));
  edgeSpacing < 2 && $setProperty_0(lgraph, SPACING_EDGE_EDGE, 2);
  direction = castTo($getProperty(lgraph, DIRECTION), 107);
  direction == ($clinit_Direction_0() , UNDEFINED_3) && $setProperty_0(lgraph, DIRECTION, getDirection_1(lgraph));
  randomSeed = castTo($getProperty(lgraph, RANDOM_SEED_0), 21);
  randomSeed.value_0 == 0?$setProperty_0(lgraph, ($clinit_InternalProperties_1() , RANDOM_0), new Random):$setProperty_0(lgraph, ($clinit_InternalProperties_1() , RANDOM_0), new Random_0(randomSeed.value_0));
  favorStraightness = castToBoolean($getProperty(lgraph, NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_0));
  favorStraightness == null && $setProperty_0(lgraph, NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_0, ($clinit_Boolean() , maskUndefined($getProperty(lgraph, EDGE_ROUTING)) === maskUndefined(($clinit_EdgeRouting() , ORTHOGONAL))?true:false));
  spacings = new Spacings(lgraph);
  $setProperty_0(lgraph, ($clinit_InternalProperties_1() , SPACINGS), spacings);
  $reset_4(this$static.algorithmAssembler);
  $setPhase(this$static.algorithmAssembler, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), castTo($getProperty(lgraph, CYCLE_BREAKING_STRATEGY_0), 230));
  $setPhase(this$static.algorithmAssembler, P2_LAYERING, castTo($getProperty(lgraph, LAYERING_STRATEGY_0), 230));
  $setPhase(this$static.algorithmAssembler, P3_NODE_ORDERING, castTo($getProperty(lgraph, CROSSING_MINIMIZATION_STRATEGY_0), 230));
  $setPhase(this$static.algorithmAssembler, P4_NODE_PLACEMENT, castTo($getProperty(lgraph, NODE_PLACEMENT_STRATEGY_0), 230));
  $setPhase(this$static.algorithmAssembler, P5_EDGE_ROUTING, factoryFor(castTo($getProperty(lgraph, EDGE_ROUTING), 204)));
  $addProcessorConfiguration(this$static.algorithmAssembler, $getPhaseIndependentLayoutProcessorConfiguration(lgraph));
  $setProperty_0(lgraph, PROCESSORS, $build(this$static.algorithmAssembler, lgraph));
}

function GraphConfigurator(){
  $clinit_GraphConfigurator();
  this.algorithmAssembler = new AlgorithmAssembler(Lorg_eclipse_elk_alg_layered_LayeredPhases_2_classLit);
}

function activateGreedySwitchFor(lgraph){
  $clinit_GraphConfigurator();
  var activationThreshold, graphSize, greedySwitchType, interactiveCrossMin;
  greedySwitchType = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_0)), 326);
  interactiveCrossMin = checkNotNull_1(castToBoolean($getProperty(lgraph, CROSSING_MINIMIZATION_SEMI_INTERACTIVE_0))) || maskUndefined($getProperty(lgraph, CROSSING_MINIMIZATION_STRATEGY_0)) === maskUndefined(($clinit_CrossingMinimizationStrategy() , INTERACTIVE_1));
  activationThreshold = castTo($getProperty(lgraph, CROSSING_MINIMIZATION_GREEDY_SWITCH_ACTIVATION_THRESHOLD_0), 21).value_0;
  graphSize = lgraph.layerlessNodes.array.length;
  return !interactiveCrossMin && greedySwitchType != ($clinit_GreedySwitchType() , OFF) && (activationThreshold == 0 || activationThreshold > graphSize);
}

defineClass(1150, 1, {}, GraphConfigurator);
var BASELINE_PROCESSING_CONFIGURATION, HIERARCHICAL_ADDITIONS, LABEL_MANAGEMENT_ADDITIONS;
var Lorg_eclipse_elk_alg_layered_GraphConfigurator_2_classLit = createForClass('org.eclipse.elk.alg.layered', 'GraphConfigurator', 1150);
function LayeredLayoutProvider(){
  this.elkLayered = new ElkLayered;
}

defineClass(996, 197, $intern_100, LayeredLayoutProvider);
_.layout = function layout_2(elkgraph, progressMonitor){
  var layeredGraph;
  layeredGraph = $importGraph_1(new ElkGraphImporter, elkgraph);
  maskUndefined($getProperty_0(elkgraph, ($clinit_LayeredOptions() , HIERARCHY_HANDLING))) === maskUndefined(($clinit_HierarchyHandling() , INCLUDE_CHILDREN))?$doCompoundLayout(this.elkLayered, layeredGraph, progressMonitor):$doLayout(this.elkLayered, layeredGraph, progressMonitor);
  $applyLayout_2(new ElkGraphLayoutTransferrer, layeredGraph);
}
;
var Lorg_eclipse_elk_alg_layered_LayeredLayoutProvider_2_classLit = createForClass('org.eclipse.elk.alg.layered', 'LayeredLayoutProvider', 996);
function $clinit_LayeredPhases(){
  $clinit_LayeredPhases = emptyMethod;
  P1_CYCLE_BREAKING = new LayeredPhases('P1_CYCLE_BREAKING', 0);
  P2_LAYERING = new LayeredPhases('P2_LAYERING', 1);
  P3_NODE_ORDERING = new LayeredPhases('P3_NODE_ORDERING', 2);
  P4_NODE_PLACEMENT = new LayeredPhases('P4_NODE_PLACEMENT', 3);
  P5_EDGE_ROUTING = new LayeredPhases('P5_EDGE_ROUTING', 4);
}

function LayeredPhases(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_27(name_0){
  $clinit_LayeredPhases();
  return valueOf(($clinit_LayeredPhases$Map() , $MAP_15), name_0);
}

function values_23(){
  $clinit_LayeredPhases();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_LayeredPhases_2_classLit, 1), $intern_38, 343, 0, [P1_CYCLE_BREAKING, P2_LAYERING, P3_NODE_ORDERING, P4_NODE_PLACEMENT, P5_EDGE_ROUTING]);
}

defineClass(343, 22, {3:1, 34:1, 22:1, 343:1}, LayeredPhases);
var P1_CYCLE_BREAKING, P2_LAYERING, P3_NODE_ORDERING, P4_NODE_PLACEMENT, P5_EDGE_ROUTING;
var Lorg_eclipse_elk_alg_layered_LayeredPhases_2_classLit = createForEnum('org.eclipse.elk.alg.layered', 'LayeredPhases', 343, Ljava_lang_Enum_2_classLit, values_23, valueOf_27);
function $clinit_LayeredPhases$Map(){
  $clinit_LayeredPhases$Map = emptyMethod;
  $MAP_15 = createValueOfMap(($clinit_LayeredPhases() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_LayeredPhases_2_classLit, 1), $intern_38, 343, 0, [P1_CYCLE_BREAKING, P2_LAYERING, P3_NODE_ORDERING, P4_NODE_PLACEMENT, P5_EDGE_ROUTING])));
}

var $MAP_15;
function $clinit_ComponentsToCGraphTransformer(){
  $clinit_ComponentsToCGraphTransformer = emptyMethod;
  SPACING_HANDLER = new ComponentsToCGraphTransformer$1;
}

function $applyLayout_1(this$static){
  var bottomRight, cNode, cNode$iterator, n, n$iterator, placeholder, placeholder$iterator, topLeft;
  for (n$iterator = new ArrayList$1(this$static.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 81);
    n.rect.x_0 = n.hitbox.x_0;
    n.rect.y_0 = n.hitbox.y_0;
  }
  topLeft = new KVector_1($intern_62, $intern_62);
  bottomRight = new KVector_1($intern_63, $intern_63);
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 81);
    topLeft.x_0 = $wnd.Math.min(topLeft.x_0, cNode.hitbox.x_0);
    topLeft.y_0 = $wnd.Math.min(topLeft.y_0, cNode.hitbox.y_0);
    bottomRight.x_0 = $wnd.Math.max(bottomRight.x_0, cNode.hitbox.x_0 + cNode.hitbox.width_0);
    bottomRight.y_0 = $wnd.Math.max(bottomRight.y_0, cNode.hitbox.y_0 + cNode.hitbox.height);
  }
  for (placeholder$iterator = $values(this$static.externalPlaceholder).iterator_0(); placeholder$iterator.hasNext_0();) {
    placeholder = castTo(placeholder$iterator.next_1(), 37);
    cNode = castTo(placeholder.second, 81);
    topLeft.x_0 = $wnd.Math.min(topLeft.x_0, cNode.hitbox.x_0);
    topLeft.y_0 = $wnd.Math.min(topLeft.y_0, cNode.hitbox.y_0);
    bottomRight.x_0 = $wnd.Math.max(bottomRight.x_0, cNode.hitbox.x_0 + cNode.hitbox.width_0);
    bottomRight.y_0 = $wnd.Math.max(bottomRight.y_0, cNode.hitbox.y_0 + cNode.hitbox.height);
  }
  this$static.globalOffset = $negate(new KVector_1(topLeft.x_0, topLeft.y_0));
  this$static.graphSize = $sub_0(new KVector_1(bottomRight.x_0, bottomRight.y_0), topLeft);
  this$static.cGraph.cGroups.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.cGraph.cNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}

function $getOffset(this$static, c){
  var cOffset;
  cOffset = $sub_0($clone_0(castTo($get_6(this$static.oldPosition, c), 8)), $getPosition(castTo($get_6(this$static.offsets, c), 293).rect));
  return cOffset;
}

function $setLock(cNode, portSides){
  portSides.isEmpty() && $set_6(cNode.lock, true, true, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, ($clinit_PortSide() , SIDES_NORTH)) && $set_6(cNode.lock, true, true, true, false);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_EAST) && $set_6(cNode.lock, false, true, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_SOUTH) && $set_6(cNode.lock, true, true, false, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_WEST) && $set_6(cNode.lock, true, false, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_NORTH_EAST) && $set_6(cNode.lock, false, true, true, false);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_EAST_SOUTH) && $set_6(cNode.lock, false, true, false, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_SOUTH_WEST) && $set_6(cNode.lock, true, false, false, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_NORTH_WEST) && $set_6(cNode.lock, true, false, true, false);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_NORTH_SOUTH) && $set_6(cNode.lock, true, true, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_EAST_WEST) && $set_6(cNode.lock, true, true, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_NORTH_SOUTH) && $set_6(cNode.lock, true, true, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_EAST_SOUTH_WEST) && $set_6(cNode.lock, true, true, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_NORTH_SOUTH_WEST) && $set_6(cNode.lock, true, true, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_NORTH_EAST_WEST) && $set_6(cNode.lock, true, true, true, true);
  equals_Ljava_lang_Object__Z__devirtual$(portSides, SIDES_NORTH_EAST_SOUTH_WEST) && $set_6(cNode.lock, true, true, true, true);
}

function $transform_0(this$static, ccs){
  var comp, comp$iterator, dummyGroup, ee, ee$iterator, group, rect, rect$iterator, rectNode, rectPlaceholder;
  this$static.cGraph = new CGraph_0(allOf(Lorg_eclipse_elk_core_options_Direction_2_classLit));
  for (comp$iterator = new ArrayList$1(ccs.components); comp$iterator.i < comp$iterator.this$01.array.length;) {
    comp = castTo($next_10(comp$iterator), 775);
    group = new CGroup_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_oned_CNode_2_classLit, 1), $intern_1, 81, 0, []));
    $add_4(this$static.cGraph.cGroups, group);
    for (rect$iterator = new ArrayList$1(comp.rectilinearConvexHull); rect$iterator.i < rect$iterator.this$01.array.length;) {
      rect = castTo($next_10(rect$iterator), 114);
      rectNode = new ComponentsToCGraphTransformer$CRectNode(this$static, rect);
      $setLock(rectNode, castTo($getProperty(comp.graph_0, ($clinit_InternalProperties_1() , EXT_PORT_CONNECTIONS)), 19));
      if (!$containsKey_2(this$static.oldPosition, comp)) {
        $put_1(this$static.oldPosition, comp, new KVector_1(rect.x_0, rect.y_0));
        $put_1(this$static.offsets, comp, rectNode);
      }
      $add_4(this$static.cGraph.cNodes, rectNode);
      $addCNode_0(group, rectNode);
    }
    for (ee$iterator = new ArrayList$1(comp.externalExtensions); ee$iterator.i < ee$iterator.this$01.array.length;) {
      ee = castTo($next_10(ee$iterator), 561);
      rectNode = new ComponentsToCGraphTransformer$CRectNode(this$static, ee.getRepresentor());
      $put_1(this$static.externalExtensions, ee, new Pair(group, rectNode));
      $setLock(rectNode, castTo($getProperty(comp.graph_0, ($clinit_InternalProperties_1() , EXT_PORT_CONNECTIONS)), 19));
      if (ee.getPlaceholder()) {
        rectPlaceholder = new ComponentsToCGraphTransformer$CRectNode_0(this$static, ee.getPlaceholder(), 1);
        $setLock(rectPlaceholder, castTo($getProperty(comp.graph_0, EXT_PORT_CONNECTIONS), 19));
        dummyGroup = new CGroup_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_oned_CNode_2_classLit, 1), $intern_1, 81, 0, []));
        $addCNode_0(dummyGroup, rectPlaceholder);
        $put(this$static.externalPlaceholder, ee.getDirection(), new Pair(group, rectPlaceholder));
      }
    }
  }
  return this$static.cGraph;
}

function ComponentsToCGraphTransformer(spacing){
  $clinit_ComponentsToCGraphTransformer();
  this.oldPosition = ($clinit_Maps() , new HashMap);
  this.offsets = new HashMap;
  this.externalExtensions = new HashMap;
  this.externalPlaceholder = new HashMultimap;
  this.spacing = spacing;
}

defineClass(1499, 1, {}, ComponentsToCGraphTransformer);
_.spacing = 0;
var SPACING_HANDLER;
var Lorg_eclipse_elk_alg_layered_compaction_components_ComponentsToCGraphTransformer_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.components', 'ComponentsToCGraphTransformer', 1499);
function $clinit_ISpacingsHandler_0(){
  $clinit_ISpacingsHandler_0 = emptyMethod;
  DEFAULT_SPACING_HANDLER_0 = new ISpacingsHandler$1_0;
}

var DEFAULT_SPACING_HANDLER_0;
function ComponentsToCGraphTransformer$1(){
}

defineClass(1500, 1, {}, ComponentsToCGraphTransformer$1);
_.getHorizontalSpacing_0 = function getHorizontalSpacing_0(cNode1, cNode2){
  return $wnd.Math.min(cNode1.individualSpacing != null?checkNotNull_1(cNode1.individualSpacing):cNode1.this$01.spacing, cNode2.individualSpacing != null?checkNotNull_1(cNode2.individualSpacing):cNode2.this$01.spacing);
}
;
_.getVerticalSpacing_0 = function getVerticalSpacing_0(cNode1, cNode2){
  return $wnd.Math.min(cNode1.individualSpacing != null?checkNotNull_1(cNode1.individualSpacing):cNode1.this$01.spacing, cNode2.individualSpacing != null?checkNotNull_1(cNode2.individualSpacing):cNode2.this$01.spacing);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_components_ComponentsToCGraphTransformer$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.components', 'ComponentsToCGraphTransformer/1', 1500);
defineClass(81, 1, {81:1});
_.id_0 = 0;
_.reposition = true;
_.startPos = $intern_63;
var Lorg_eclipse_elk_alg_layered_compaction_oned_CNode_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned', 'CNode', 81);
function ComponentsToCGraphTransformer$CRectNode(this$0, rect){
  ComponentsToCGraphTransformer$CRectNode_0.call(this, this$0, rect, null);
}

function ComponentsToCGraphTransformer$CRectNode_0(this$0, rect, spacing){
  this.this$01 = this$0;
  this.constraints = new ArrayList;
  this.cGroupOffset = new KVector;
  this.lock = new Quadruplet_0;
  this.spacingIgnore = new Quadruplet_0;
  this.rect = rect;
  this.hitbox = new ElkRectangle_0(rect.x_0, rect.y_0, rect.width_0, rect.height);
  this.individualSpacing = spacing;
}

defineClass(293, 81, {293:1, 81:1}, ComponentsToCGraphTransformer$CRectNode, ComponentsToCGraphTransformer$CRectNode_0);
_.toString_0 = function toString_82(){
  return '';
}
;
var Lorg_eclipse_elk_alg_layered_compaction_components_ComponentsToCGraphTransformer$CRectNode_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.components', 'ComponentsToCGraphTransformer/CRectNode', 293);
function $clinit_OneDimensionalComponentsCompaction(){
  $clinit_OneDimensionalComponentsCompaction = emptyMethod;
  LEFT_RIGHT = newHashSet_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_Direction_2_classLit, 1), $intern_38, 107, 0, [($clinit_Direction_0() , LEFT_5), RIGHT_5]));
  UP_DOWN = newHashSet_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_Direction_2_classLit, 1), $intern_38, 107, 0, [UP_1, DOWN_1]));
}

function $addExternalEdgeRepresentations(this$static, ees){
  var p, p$iterator;
  for (p$iterator = new ArrayList$1(ees); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_10(p$iterator), 37);
    $add_4(this$static.compactionGraph.cNodes, castTo(p.second, 81));
    $addCNode_0(castTo(p.first, 176), castTo(p.second, 81));
  }
}

function $addPlaceholders(this$static, dir_0){
  var d, d$iterator, dirs, pair, pair$iterator;
  dirs = dir_0 == 1?UP_DOWN:LEFT_RIGHT;
  for (d$iterator = dirs.map_0.keySet_0().iterator_0(); d$iterator.hasNext_0();) {
    d = castTo(d$iterator.next_1(), 107);
    for (pair$iterator = castTo($get_0(this$static.transformer.externalPlaceholder, d), 19).iterator_0(); pair$iterator.hasNext_0();) {
      pair = castTo(pair$iterator.next_1(), 37);
      $add_4(this$static.compactionGraph.cNodes, castTo(pair.second, 81));
      $add_4(this$static.compactionGraph.cGroups, castTo(pair.second, 81).cGroup);
    }
  }
}

function $compact_1(this$static){
  var delta, direction, g, g$iterator, g$iterator0, g$iterator1, g$iterator2;
  delta = 0;
  for (g$iterator0 = new ArrayList$1(this$static.compactionGraph.cGroups); g$iterator0.i < g$iterator0.this$01.array.length;) {
    g = castTo($next_10(g$iterator0), 176);
    g.delta = 0;
    g.deltaNormalized = 0;
  }
  $addPlaceholders(this$static, 0);
  $addExternalEdgeRepresentations(this$static, this$static.verticalExternalExtensions);
  $calculateGroupOffsets_0(this$static.compactor);
  $forceConstraintsRecalculation(this$static.compactor);
  direction = ($clinit_Direction_0() , LEFT_5);
  $compact_3($applyLockingStrategy($changeDirection_0($compact_3($applyLockingStrategy($changeDirection_0($compact_3($changeDirection_0(this$static.compactor, direction)), $opposite_0(direction)))), direction)));
  $changeDirection_0(this$static.compactor, LEFT_5);
  $removeExternalEdgeRepresentations(this$static, this$static.verticalExternalExtensions);
  $removePlaceholders(this$static, 0);
  $updateExternalExtensionDimensions(this$static, 0);
  $updatePlaceholders(this$static, 1);
  $addPlaceholders(this$static, 1);
  $addExternalEdgeRepresentations(this$static, this$static.horizontalExternalExtensions);
  $calculateGroupOffsets_0(this$static.compactor);
  for (g$iterator1 = new ArrayList$1(this$static.compactionGraph.cGroups); g$iterator1.i < g$iterator1.this$01.array.length;) {
    g = castTo($next_10(g$iterator1), 176);
    delta += $wnd.Math.abs(g.deltaNormalized);
  }
  for (g$iterator2 = new ArrayList$1(this$static.compactionGraph.cGroups); g$iterator2.i < g$iterator2.this$01.array.length;) {
    g = castTo($next_10(g$iterator2), 176);
    g.delta = 0;
    g.deltaNormalized = 0;
  }
  direction = UP_1;
  $compact_3($applyLockingStrategy($changeDirection_0($compact_3($applyLockingStrategy($changeDirection_0($compact_3($forceConstraintsRecalculation($changeDirection_0(this$static.compactor, direction))), $opposite_0(direction)))), direction)));
  $changeDirection_0(this$static.compactor, LEFT_5);
  $removeExternalEdgeRepresentations(this$static, this$static.horizontalExternalExtensions);
  $removePlaceholders(this$static, 1);
  $updateExternalExtensionDimensions(this$static, 1);
  $updatePlaceholders(this$static, 0);
  $forceConstraintsRecalculation(this$static.compactor);
  for (g$iterator = new ArrayList$1(this$static.compactionGraph.cGroups); g$iterator.i < g$iterator.this$01.array.length;) {
    g = castTo($next_10(g$iterator), 176);
    delta += $wnd.Math.abs(g.deltaNormalized);
  }
  return delta;
}

function $compact_2(this$static){
  var allNodes, cNode, cNode$iterator, delta, entry, entry$iterator, run;
  allNodes = new ArrayList;
  this$static.verticalExternalExtensions = new ArrayList;
  this$static.horizontalExternalExtensions = new ArrayList;
  for (entry$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.transformer.externalExtensions)).this$01); entry$iterator.hasNext;) {
    entry = $next_7(entry$iterator);
    $add_4(allNodes, castTo(castTo(entry.getValue(), 37).second, 81));
    $isHorizontal(castTo(entry.getKey(), 561).getDirection())?$add_4(this$static.horizontalExternalExtensions, castTo(entry.getValue(), 37)):$add_4(this$static.verticalExternalExtensions, castTo(entry.getValue(), 37));
  }
  $addExternalEdgeRepresentations(this$static, this$static.horizontalExternalExtensions);
  $addExternalEdgeRepresentations(this$static, this$static.verticalExternalExtensions);
  this$static.compactor = new OneDimensionalCompactor_0(this$static.compactionGraph);
  $setSpacingsHandler_0(this$static.compactor, ($clinit_ComponentsToCGraphTransformer() , SPACING_HANDLER));
  $removeExternalEdgeRepresentations(this$static, this$static.horizontalExternalExtensions);
  $removeExternalEdgeRepresentations(this$static, this$static.verticalExternalExtensions);
  $addAll_2(allNodes, this$static.compactor.cGraph.cNodes);
  this$static.topLeft = new KVector_1($intern_62, $intern_62);
  this$static.bottomRight = new KVector_1($intern_63, $intern_63);
  for (cNode$iterator = new ArrayList$1(allNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 81);
    this$static.topLeft.x_0 = $wnd.Math.min(this$static.topLeft.x_0, cNode.hitbox.x_0);
    this$static.topLeft.y_0 = $wnd.Math.min(this$static.topLeft.y_0, cNode.hitbox.y_0);
    this$static.bottomRight.x_0 = $wnd.Math.max(this$static.bottomRight.x_0, cNode.hitbox.x_0 + cNode.hitbox.width_0);
    this$static.bottomRight.y_0 = $wnd.Math.max(this$static.bottomRight.y_0, cNode.hitbox.y_0 + cNode.hitbox.height);
  }
  $setLockingStrategy(this$static.compactor, new OneDimensionalComponentsCompaction$lambda$0$Type);
  run = 0;
  do {
    delta = $compact_1(this$static);
    ++run;
  }
   while ((run < 2 || delta > $intern_42) && run < 10);
  $setLockingStrategy(this$static.compactor, new OneDimensionalComponentsCompaction$lambda$1$Type);
  $compact_1(this$static);
  $finish(this$static.compactor);
  $applyLayout_1(this$static.transformer);
}

function $getOffset_0(this$static, c){
  var individual;
  individual = $getOffset(this$static.transformer, c);
  return $add_19($negate(individual), this$static.transformer.globalOffset);
}

function $removeExternalEdgeRepresentations(this$static, ees){
  var p, p$iterator;
  for (p$iterator = new ArrayList$1(ees); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_10(p$iterator), 37);
    $remove_13(this$static.compactionGraph.cNodes, p.second);
    $removeCNode(castTo(p.first, 176), castTo(p.second, 81));
  }
}

function $removePlaceholders(this$static, dir_0){
  var d, d$iterator, dirs, pair, pair$iterator;
  dirs = dir_0 == 1?UP_DOWN:LEFT_RIGHT;
  for (d$iterator = dirs.map_0.keySet_0().iterator_0(); d$iterator.hasNext_0();) {
    d = castTo(d$iterator.next_1(), 107);
    for (pair$iterator = castTo($get_0(this$static.transformer.externalPlaceholder, d), 19).iterator_0(); pair$iterator.hasNext_0();) {
      pair = castTo(pair$iterator.next_1(), 37);
      $remove_13(this$static.compactionGraph.cNodes, pair.second);
      $remove_13(this$static.compactionGraph.cGroups, castTo(pair.second, 81).cGroup);
    }
  }
}

function $updateExternalExtensionDimensions(this$static, dir_0){
  var adelta, cNode, ee, entry, entry$iterator, group;
  for (entry$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.transformer.externalExtensions)).this$01); entry$iterator.hasNext;) {
    entry = $next_7(entry$iterator);
    ee = castTo(entry.getKey(), 561);
    if (dir_0 == 1) {
      if (ee.getDirection() != ($clinit_Direction_0() , UP_1) && ee.getDirection() != DOWN_1) {
        continue;
      }
    }
     else {
      if (ee.getDirection() != ($clinit_Direction_0() , LEFT_5) && ee.getDirection() != RIGHT_5) {
        continue;
      }
    }
    cNode = castTo(castTo(entry.getValue(), 37).second, 81);
    group = castTo(castTo(entry.getValue(), 37).first, 176);
    adelta = group.deltaNormalized;
    switch (ee.getDirection().ordinal) {
      case 2:
        cNode.hitbox.x_0 = this$static.topLeft.x_0;
        cNode.hitbox.width_0 = $wnd.Math.max(1, cNode.hitbox.width_0 + adelta);
        break;
      case 1:
        cNode.hitbox.x_0 = cNode.hitbox.x_0 + adelta;
        cNode.hitbox.width_0 = $wnd.Math.max(1, cNode.hitbox.width_0 - adelta);
        break;
      case 4:
        cNode.hitbox.y_0 = this$static.topLeft.y_0;
        cNode.hitbox.height = $wnd.Math.max(1, cNode.hitbox.height + adelta);
        break;
      case 3:
        cNode.hitbox.y_0 = cNode.hitbox.y_0 + adelta;
        cNode.hitbox.height = $wnd.Math.max(1, cNode.hitbox.height - adelta);
    }
  }
}

function $updatePlaceholders(this$static, dir_0){
  var adelta, cNode, d, d$iterator, dirs, pair, pair$iterator, parentComponentGroup;
  dirs = dir_0 == 1?UP_DOWN:LEFT_RIGHT;
  for (d$iterator = dirs.map_0.keySet_0().iterator_0(); d$iterator.hasNext_0();) {
    d = castTo(d$iterator.next_1(), 107);
    for (pair$iterator = castTo($get_0(this$static.transformer.externalPlaceholder, d), 19).iterator_0(); pair$iterator.hasNext_0();) {
      pair = castTo(pair$iterator.next_1(), 37);
      cNode = castTo(pair.second, 81);
      parentComponentGroup = castTo(pair.first, 176);
      adelta = parentComponentGroup.deltaNormalized;
      switch (d.ordinal) {
        case 2:
        case 1:
          cNode.hitbox.y_0 += adelta;
          break;
        case 4:
        case 3:
          cNode.hitbox.x_0 += adelta;
      }
    }
  }
}

function OneDimensionalComponentsCompaction(){
}

defineClass(1470, 1, {}, OneDimensionalComponentsCompaction);
var LEFT_RIGHT, UP_DOWN;
var Lorg_eclipse_elk_alg_layered_compaction_components_OneDimensionalComponentsCompaction_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.components', 'OneDimensionalComponentsCompaction', 1470);
function OneDimensionalComponentsCompaction$lambda$0$Type(){
}

defineClass(1471, 1, $intern_25, OneDimensionalComponentsCompaction$lambda$0$Type);
_.equals_0 = function equals_81(other){
  return this === other;
}
;
_.apply_0 = function apply_52(arg0){
  return $clinit_OneDimensionalComponentsCompaction() , $clinit_Boolean() , castTo(castTo(arg0, 37).first, 81).cGroup.outDegree != 0?true:false;
}
;
var Lorg_eclipse_elk_alg_layered_compaction_components_OneDimensionalComponentsCompaction$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.components', 'OneDimensionalComponentsCompaction/lambda$0$Type', 1471);
function OneDimensionalComponentsCompaction$lambda$1$Type(){
}

defineClass(1472, 1, $intern_25, OneDimensionalComponentsCompaction$lambda$1$Type);
_.equals_0 = function equals_82(other){
  return this === other;
}
;
_.apply_0 = function apply_53(arg0){
  return $clinit_OneDimensionalComponentsCompaction() , $clinit_Boolean() , $get_15(castTo(castTo(arg0, 37).first, 81).lock, castTo(castTo(arg0, 37).second, 107)) || castTo(castTo(arg0, 37).first, 81).cGroup.outDegree != 0 && $get_15(castTo(castTo(arg0, 37).first, 81).lock, castTo(castTo(arg0, 37).second, 107))?true:false;
}
;
var Lorg_eclipse_elk_alg_layered_compaction_components_OneDimensionalComponentsCompaction$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.components', 'OneDimensionalComponentsCompaction/lambda$1$Type', 1472);
function $supports_0(this$static, direction){
  return $containsEnum(this$static.supportedDirections, direction);
}

function CGraph_0(supportedDirections){
  this.cNodes = new ArrayList;
  this.cGroups = new ArrayList;
  this.supportedDirections = supportedDirections;
}

defineClass(1502, 1, {}, CGraph_0);
var Lorg_eclipse_elk_alg_layered_compaction_oned_CGraph_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned', 'CGraph', 1502);
function $addCNode_0(this$static, cNode){
  $add_6(this$static.cNodes, cNode);
  if (cNode.cGroup) {
    throw toJs(new RuntimeException_0('CNode belongs to another CGroup.'));
  }
  cNode.cGroup = this$static;
}

function $removeCNode(this$static, cNode){
  var removed;
  removed = $remove_18(this$static.cNodes, cNode);
  removed && (cNode.cGroup = null);
  return removed;
}

function CGroup_0(inputCNodes){
  var cNode, cNode$index, cNode$max;
  this.cNodes = new LinkedHashSet;
  this.incomingConstraints = new HashSet;
  this.outDegree = 0;
  for (cNode$index = 0 , cNode$max = inputCNodes.length; cNode$index < cNode$max; ++cNode$index) {
    cNode = inputCNodes[cNode$index];
    !this.reference && (this.reference = cNode);
    $addCNode_0(this, cNode);
  }
}

defineClass(176, 1, {176:1}, CGroup_0);
_.delta = 0;
_.deltaNormalized = 0;
_.outDegree = 0;
_.reposition = true;
_.startPos = $intern_63;
var Lorg_eclipse_elk_alg_layered_compaction_oned_CGroup_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned', 'CGroup', 176);
function ISpacingsHandler$1_0(){
}

defineClass(1501, 1, {}, ISpacingsHandler$1_0);
_.getHorizontalSpacing_0 = function getHorizontalSpacing_1(cNode1, cNode2){
  return $wnd.Math.max(cNode1.individualSpacing != null?checkNotNull_1(cNode1.individualSpacing):cNode1.this$01.spacing, cNode2.individualSpacing != null?checkNotNull_1(cNode2.individualSpacing):cNode2.this$01.spacing);
}
;
_.getVerticalSpacing_0 = function getVerticalSpacing_1(cNode1, cNode2){
  return $wnd.Math.max(cNode1.individualSpacing != null?checkNotNull_1(cNode1.individualSpacing):cNode1.this$01.spacing, cNode2.individualSpacing != null?checkNotNull_1(cNode2.individualSpacing):cNode2.this$01.spacing);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_oned_ISpacingsHandler$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned', 'ISpacingsHandler/1', 1501);
function $clinit_OneDimensionalCompactor_0(){
  $clinit_OneDimensionalCompactor_0 = emptyMethod;
  SCANLINE_CONSTRAINTS_0 = new ScanlineConstraintCalculator_0;
}

function $applyLockingStrategy(this$static){
  $applyLockingStrategy_0(this$static, this$static.direction);
  return this$static;
}

function $applyLockingStrategy_0(this$static, dir_0){
  var cGroup, cGroup$iterator, cNode, cNode$iterator;
  for (cGroup$iterator = new ArrayList$1(this$static.cGraph.cGroups); cGroup$iterator.i < cGroup$iterator.this$01.array.length;) {
    cGroup = castTo($next_10(cGroup$iterator), 176);
    cGroup.reposition = true;
  }
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 81);
    cNode.reposition = checkNotNull_1(castToBoolean(this$static.lockingStrategy.apply_0(new Pair(cNode, dir_0))));
    cNode.cGroup.reposition = cNode.cGroup.reposition & checkNotNull_1(castToBoolean(this$static.lockingStrategy.apply_0(new Pair(cNode, dir_0))));
  }
  return this$static;
}

function $calculateConstraints_0(this$static){
  var cNode, cNode$iterator;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 81);
    cNode.constraints.clear_0();
  }
  $calculateConstraints_1(this$static.constraintAlgorithm, this$static);
  $calculateConstraintsForCGroups_0(this$static);
}

function $calculateConstraintsForCGroups_0(this$static){
  var cNode, cNode$iterator, group, group$iterator, group$iterator0, inc, inc$iterator;
  for (group$iterator0 = new ArrayList$1(this$static.cGraph.cGroups); group$iterator0.i < group$iterator0.this$01.array.length;) {
    group = castTo($next_10(group$iterator0), 176);
    group.outDegree = 0;
    group.incomingConstraints.map_0.clear_0();
  }
  for (group$iterator = new ArrayList$1(this$static.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 176);
    for (cNode$iterator = group.cNodes.map_0.keySet_0().iterator_0(); cNode$iterator.hasNext_0();) {
      cNode = castTo(cNode$iterator.next_1(), 81);
      for (inc$iterator = cNode.constraints.iterator_0(); inc$iterator.hasNext_0();) {
        inc = castTo(inc$iterator.next_1(), 81);
        if (inc.cGroup != group) {
          $add_6(group.incomingConstraints, inc);
          ++inc.cGroup.outDegree;
        }
      }
    }
  }
}

function $calculateGroupOffsets_0(this$static){
  var group, group$iterator, n, n$iterator, n$iterator0;
  for (group$iterator = new ArrayList$1(this$static.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 176);
    group.reference = null;
    for (n$iterator0 = group.cNodes.map_0.keySet_0().iterator_0(); n$iterator0.hasNext_0();) {
      n = castTo(n$iterator0.next_1(), 81);
      $reset_5(n.cGroupOffset);
      (!group.reference || n.hitbox.x_0 < group.reference.hitbox.x_0) && (group.reference = n);
    }
    for (n$iterator = group.cNodes.map_0.keySet_0().iterator_0(); n$iterator.hasNext_0();) {
      n = castTo(n$iterator.next_1(), 81);
      n.cGroupOffset.x_0 = n.hitbox.x_0 - group.reference.hitbox.x_0;
      n.cGroupOffset.y_0 = n.hitbox.y_0 - group.reference.hitbox.y_0;
    }
  }
  return this$static;
}

function $changeDirection_0(this$static, dir_0){
  var oldDirection;
  if (this$static.finished) {
    throw toJs(new IllegalStateException_0(($ensureNamesAreInitialized(Lorg_eclipse_elk_alg_layered_compaction_oned_OneDimensionalCompactor_2_classLit) , 'The ' + Lorg_eclipse_elk_alg_layered_compaction_oned_OneDimensionalCompactor_2_classLit.simpleName + ' instance has been finished already.')));
  }
  if (!$supports_0(this$static.cGraph, dir_0)) {
    throw toJs(new RuntimeException_0('The direction ' + dir_0 + ' is not supported by the CGraph instance.'));
  }
  if (dir_0 == this$static.direction) {
    return this$static;
  }
  oldDirection = this$static.direction;
  this$static.direction = dir_0;
  switch (oldDirection.ordinal) {
    case 0:
      switch (dir_0.ordinal) {
        case 2:
          $calculateConstraints_0(this$static);
          break;
        case 1:
          $mirrorHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
          break;
        case 4:
          $transposeHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
          break;
        case 3:
          $transposeHitboxes_0(this$static);
          $mirrorHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
      }

      break;
    case 2:
      switch (dir_0.ordinal) {
        case 1:
          $mirrorHitboxes_0(this$static);
          $reverseConstraints_0(this$static);
          break;
        case 4:
          $transposeHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
          break;
        case 3:
          $transposeHitboxes_0(this$static);
          $mirrorHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
      }

      break;
    case 1:
      switch (dir_0.ordinal) {
        case 2:
          $mirrorHitboxes_0(this$static);
          $reverseConstraints_0(this$static);
          break;
        case 4:
          $mirrorHitboxes_0(this$static);
          $transposeHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
          break;
        case 3:
          $mirrorHitboxes_0(this$static);
          $transposeHitboxes_0(this$static);
          $mirrorHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
      }

      break;
    case 4:
      switch (dir_0.ordinal) {
        case 2:
          $transposeHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
          break;
        case 1:
          $transposeHitboxes_0(this$static);
          $mirrorHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
          break;
        case 3:
          $mirrorHitboxes_0(this$static);
          $reverseConstraints_0(this$static);
      }

      break;
    case 3:
      switch (dir_0.ordinal) {
        case 2:
          $mirrorHitboxes_0(this$static);
          $transposeHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
          break;
        case 1:
          $mirrorHitboxes_0(this$static);
          $transposeHitboxes_0(this$static);
          $mirrorHitboxes_0(this$static);
          $calculateConstraints_0(this$static);
          break;
        case 4:
          $mirrorHitboxes_0(this$static);
          $reverseConstraints_0(this$static);
      }

  }
  return this$static;
}

function $compact_3(this$static){
  var g, g$iterator, incN, incN$iterator, n, n$iterator, node, node$iterator;
  if (this$static.finished) {
    throw toJs(new IllegalStateException_0(($ensureNamesAreInitialized(Lorg_eclipse_elk_alg_layered_compaction_oned_OneDimensionalCompactor_2_classLit) , 'The ' + Lorg_eclipse_elk_alg_layered_compaction_oned_OneDimensionalCompactor_2_classLit.simpleName + ' instance has been finished already.')));
  }
  this$static.direction == ($clinit_Direction_0() , UNDEFINED_3) && $changeDirection_0(this$static, LEFT_5);
  for (g$iterator = new ArrayList$1(this$static.cGraph.cGroups); g$iterator.i < g$iterator.this$01.array.length;) {
    g = castTo($next_10(g$iterator), 176);
    g.outDegree = 0;
  }
  for (n$iterator = new ArrayList$1(this$static.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 81);
    n.startPos = $intern_63;
    for (incN$iterator = n.constraints.iterator_0(); incN$iterator.hasNext_0();) {
      incN = castTo(incN$iterator.next_1(), 81);
      ++incN.cGroup.outDegree;
    }
  }
  $compact_4(this$static);
  for (node$iterator = new ArrayList$1(this$static.cGraph.cNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 81);
    node.reposition = true;
  }
  return this$static;
}

function $finish(this$static){
  $changeDirection_0(this$static, ($clinit_Direction_0() , LEFT_5));
  this$static.finished = true;
  return this$static;
}

function $forceConstraintsRecalculation(this$static){
  $calculateConstraints_0(this$static);
  return this$static;
}

function $mirrorHitboxes_0(this$static){
  var cNode, cNode$iterator;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 81);
    cNode.hitbox.x_0 = -cNode.hitbox.x_0 - cNode.hitbox.width_0;
  }
  $calculateGroupOffsets_0(this$static);
}

function $reverseConstraints_0(this$static){
  var cNode, cNode$iterator, cNode$iterator0, cNode$iterator1, inc, inc$iterator, incMap;
  incMap = ($clinit_Maps() , new HashMap);
  for (cNode$iterator0 = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator0), 81);
    $put_1(incMap, cNode, new ArrayList);
  }
  for (cNode$iterator1 = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator1.i < cNode$iterator1.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator1), 81);
    cNode.startPos = $intern_63;
    for (inc$iterator = cNode.constraints.iterator_0(); inc$iterator.hasNext_0();) {
      inc = castTo(inc$iterator.next_1(), 81);
      castTo(getEntryValueOrNull($getEntry(incMap.hashCodeMap, inc)), 15).add_1(cNode);
    }
  }
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 81);
    cNode.constraints.clear_0();
    cNode.constraints = castTo(getEntryValueOrNull($getEntry(incMap.hashCodeMap, cNode)), 15);
  }
  $calculateConstraintsForCGroups_0(this$static);
}

function $setLockingStrategy(this$static, strategy){
  this$static.lockingStrategy = strategy;
  return this$static;
}

function $setSpacingsHandler_0(this$static, handler){
  this$static.spacingsHandler = handler;
  return this$static;
}

function $transposeHitboxes_0(this$static){
  var cNode, cNode$iterator, tmp;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 81);
    tmp = cNode.hitbox.x_0;
    cNode.hitbox.x_0 = cNode.hitbox.y_0;
    cNode.hitbox.y_0 = tmp;
    tmp = cNode.hitbox.width_0;
    cNode.hitbox.width_0 = cNode.hitbox.height;
    cNode.hitbox.height = tmp;
    tmp = cNode.cGroupOffset.x_0;
    cNode.cGroupOffset.x_0 = cNode.cGroupOffset.y_0;
    cNode.cGroupOffset.y_0 = tmp;
  }
  $calculateGroupOffsets_0(this$static);
}

function OneDimensionalCompactor_0(cGraph){
  $clinit_OneDimensionalCompactor_0();
  var group, n, n$iterator;
  this.constraintAlgorithm = SCANLINE_CONSTRAINTS_0;
  this.direction = ($clinit_Direction_0() , UNDEFINED_3);
  this.spacingsHandler = ($clinit_ISpacingsHandler_0() , DEFAULT_SPACING_HANDLER_0);
  this.cGraph = cGraph;
  $setLockingStrategy(this, new OneDimensionalCompactor$lambda$0$Type_0);
  $calculateGroupOffsets_0(this);
  for (n$iterator = new ArrayList$1(cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 81);
    if (!n.cGroup) {
      group = new CGroup_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_oned_CNode_2_classLit, 1), $intern_1, 81, 0, [n]));
      $add_4(cGraph.cGroups, group);
    }
  }
}

defineClass(1503, 1, {}, OneDimensionalCompactor_0);
_.finished = false;
var SCANLINE_CONSTRAINTS_0;
var Lorg_eclipse_elk_alg_layered_compaction_oned_OneDimensionalCompactor_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned', 'OneDimensionalCompactor', 1503);
function OneDimensionalCompactor$lambda$0$Type_0(){
}

defineClass(1504, 1, $intern_25, OneDimensionalCompactor$lambda$0$Type_0);
_.equals_0 = function equals_83(other){
  return this === other;
}
;
_.apply_0 = function apply_54(arg0){
  return $clinit_OneDimensionalCompactor_0() , $clinit_Boolean() , castTo(castTo(arg0, 37).first, 81).cGroup.outDegree != 0?true:false;
}
;
var Lorg_eclipse_elk_alg_layered_compaction_oned_OneDimensionalCompactor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned', 'OneDimensionalCompactor/lambda$0$Type', 1504);
function $get_15(this$static, direction){
  switch (direction.ordinal) {
    case 2:
      return this$static.left;
    case 1:
      return this$static.right;
    case 4:
      return this$static.up;
    case 3:
      return this$static.down;
    default:return false;
  }
}

function $set_6(this$static, l, r, u, d){
  this$static.left = l;
  this$static.right = r;
  this$static.up = u;
  this$static.down = d;
}

function Quadruplet_0(){
  $set_6(this, false, false, false, false);
}

defineClass(756, 1, {}, Quadruplet_0);
_.down = false;
_.left = false;
_.right = false;
_.up = false;
var Lorg_eclipse_elk_alg_layered_compaction_oned_Quadruplet_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned', 'Quadruplet', 756);
function $compact_4(compactor){
  var cNode, cNode$iterator, cNode$iterator0, diff, group, group$iterator, incNode, incNode$iterator, minStartPos, node, node$iterator, node$iterator0, sinks, spacing, suggestedX;
  minStartPos = $intern_62;
  for (cNode$iterator0 = new ArrayList$1(compactor.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator0), 81);
    minStartPos = $wnd.Math.min(minStartPos, cNode.cGroup.reference.hitbox.x_0 + cNode.cGroupOffset.x_0);
  }
  sinks = new LinkedList;
  for (group$iterator = new ArrayList$1(compactor.cGraph.cGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 176);
    group.startPos = minStartPos;
    group.outDegree == 0 && ($addNode_0(sinks, group, sinks.tail.prev, sinks.tail) , true);
  }
  while (sinks.size_0 != 0) {
    group = castTo(sinks.size_0 == 0?null:(checkCriticalElement(sinks.size_0 != 0) , $removeNode_0(sinks, sinks.header.next_0)), 176);
    diff = group.reference.hitbox.x_0;
    for (node$iterator0 = group.cNodes.map_0.keySet_0().iterator_0(); node$iterator0.hasNext_0();) {
      node = castTo(node$iterator0.next_1(), 81);
      suggestedX = group.startPos + node.cGroupOffset.x_0;
      node.cGroup.reposition || node.hitbox.x_0 < suggestedX?(node.startPos = suggestedX):(node.startPos = node.hitbox.x_0);
    }
    diff -= group.reference.startPos;
    group.delta += diff;
    compactor.direction == ($clinit_Direction_0() , RIGHT_5) || compactor.direction == DOWN_1?(group.deltaNormalized += diff):(group.deltaNormalized -= diff);
    for (node$iterator = group.cNodes.map_0.keySet_0().iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 81);
      for (incNode$iterator = node.constraints.iterator_0(); incNode$iterator.hasNext_0();) {
        incNode = castTo(incNode$iterator.next_1(), 81);
        $isHorizontal(compactor.direction)?(spacing = compactor.spacingsHandler.getHorizontalSpacing_0(node, incNode)):(spacing = compactor.spacingsHandler.getVerticalSpacing_0(node, incNode));
        incNode.cGroup.startPos = $wnd.Math.max(incNode.cGroup.startPos, node.startPos + node.hitbox.width_0 + spacing - incNode.cGroupOffset.x_0);
        incNode.reposition || (incNode.cGroup.startPos = $wnd.Math.max(incNode.cGroup.startPos, incNode.hitbox.x_0 - incNode.cGroupOffset.x_0));
        --incNode.cGroup.outDegree;
        incNode.cGroup.outDegree == 0 && $add_7(sinks, incNode.cGroup);
      }
    }
  }
  for (cNode$iterator = new ArrayList$1(compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 81);
    cNode.hitbox.x_0 = cNode.startPos;
  }
}

function $blowUpHitboxes(this$static){
  var n, n$iterator, spacing;
  for (n$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 81);
    spacing = (checkCriticalNotNull(0) , 0);
    if (spacing > 0) {
      !($isHorizontal(this$static.compactor.direction) && n.spacingIgnore.up) && !($isVertical(this$static.compactor.direction) && n.spacingIgnore.left) && (n.hitbox.y_0 -= $wnd.Math.max(0, spacing / 2 - 0.5));
      !($isHorizontal(this$static.compactor.direction) && n.spacingIgnore.down) && !($isVertical(this$static.compactor.direction) && n.spacingIgnore.right) && (n.hitbox.height += $wnd.Math.max(0, spacing - 1));
    }
  }
}

function $calculateConstraints_1(this$static, theCompactor){
  this$static.compactor = theCompactor;
  $sweep_1(this$static);
}

function $normalizeHitboxes(this$static){
  var n, n$iterator, spacing;
  for (n$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 81);
    spacing = (checkCriticalNotNull(0) , 0);
    if (spacing > 0) {
      !($isHorizontal(this$static.compactor.direction) && n.spacingIgnore.up) && !($isVertical(this$static.compactor.direction) && n.spacingIgnore.left) && (n.hitbox.y_0 += $wnd.Math.max(0, spacing / 2 - 0.5));
      !($isHorizontal(this$static.compactor.direction) && n.spacingIgnore.down) && !($isVertical(this$static.compactor.direction) && n.spacingIgnore.right) && (n.hitbox.height -= spacing - 1);
    }
  }
}

function $sweep_1(this$static){
  var n, n$iterator, points;
  $blowUpHitboxes(this$static);
  points = new ArrayList;
  for (n$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 81);
    $add_4(points, new ScanlineConstraintCalculator$Timestamp_0(n, true));
    $add_4(points, new ScanlineConstraintCalculator$Timestamp_0(n, false));
  }
  $reset_2(this$static.constraintsScanlineHandler);
  execute_0(points, this$static.constraintsScanlineComparator, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_1, 355, 0, [this$static.constraintsScanlineHandler])));
  $normalizeHitboxes(this$static);
}

function ScanlineConstraintCalculator_0(){
  this.constraintsScanlineComparator = new ScanlineConstraintCalculator$lambda$0$Type_0;
  this.constraintsScanlineHandler = new ScanlineConstraintCalculator$ConstraintsScanlineHandler_0(this);
}

function lambda$0_10(p1_0, p2_1){
  var cmp, y1, y2;
  y1 = p1_0.node.hitbox.y_0;
  p1_0.low || (y1 += p1_0.node.hitbox.height);
  y2 = p2_1.node.hitbox.y_0;
  p2_1.low || (y2 += p2_1.node.hitbox.height);
  cmp = compare_5(y1, y2);
  if (cmp == 0) {
    if (!p1_0.low && p2_1.low) {
      return -1;
    }
     else if (!p2_1.low && p1_0.low) {
      return 1;
    }
  }
  return cmp;
}

defineClass(1614, 1, {}, ScanlineConstraintCalculator_0);
var Lorg_eclipse_elk_alg_layered_compaction_oned_algs_ScanlineConstraintCalculator_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned.algs', 'ScanlineConstraintCalculator', 1614);
var Lorg_eclipse_elk_alg_layered_compaction_recthull_Scanline$EventHandler_2_classLit = createForInterface('org.eclipse.elk.alg.layered.compaction.recthull', 'Scanline/EventHandler');
function $handle_1(this$static, p){
  var right, left, right_0;
  p.low?($add_10(this$static.intervals, p.node) , this$static.cand[p.node.id_0] = castTo($lower(this$static.intervals, p.node), 81) , right = castTo($higher(this$static.intervals, p.node), 81) , !!right && (this$static.cand[right.id_0] = p.node) , undefined):(left = castTo($lower(this$static.intervals, p.node), 81) , !!left && left == this$static.cand[p.node.id_0] && !!left.cGroup && left.cGroup != p.node.cGroup && left.constraints.add_1(p.node) , right_0 = castTo($higher(this$static.intervals, p.node), 81) , !!right_0 && this$static.cand[right_0.id_0] == p.node && !!right_0.cGroup && right_0.cGroup != p.node.cGroup && p.node.constraints.add_1(right_0) , $remove_28(this$static.intervals, p.node) , undefined);
}

function $reset_2(this$static){
  var index_0, n, n$iterator;
  $clear_6(this$static.intervals.map_0);
  this$static.cand = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_compaction_oned_CNode_2_classLit, $intern_1, 81, this$static.this$01.compactor.cGraph.cNodes.array.length, 0, 1);
  index_0 = 0;
  for (n$iterator = new ArrayList$1(this$static.this$01.compactor.cGraph.cNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 81);
    n.id_0 = index_0++;
  }
}

function ScanlineConstraintCalculator$ConstraintsScanlineHandler_0(this$0){
  this.this$01 = this$0;
  this.intervals = new TreeSet_0(castTo(checkNotNull(new ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type_0), 59));
}

defineClass(1615, 1, {355:1}, ScanlineConstraintCalculator$ConstraintsScanlineHandler_0);
_.handle = function handle_1(p){
  $handle_1(this, castTo(p, 550));
}
;
var Lorg_eclipse_elk_alg_layered_compaction_oned_algs_ScanlineConstraintCalculator$ConstraintsScanlineHandler_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/ConstraintsScanlineHandler', 1615);
function ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type_0(){
}

defineClass(1616, 1, $intern_40, ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type_0);
_.equals_0 = function equals_84(other){
  return this === other;
}
;
_.reversed = function reversed_23(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_31(arg0, arg1){
  return compare_5(castTo(arg0, 293).hitbox.x_0 + castTo(arg0, 293).hitbox.width_0 / 2, castTo(arg1, 293).hitbox.x_0 + castTo(arg1, 293).hitbox.width_0 / 2);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_oned_algs_ScanlineConstraintCalculator$ConstraintsScanlineHandler$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/ConstraintsScanlineHandler/lambda$0$Type', 1616);
function ScanlineConstraintCalculator$Timestamp_0(node, low){
  this.node = node;
  this.low = low;
}

defineClass(550, 1, {550:1}, ScanlineConstraintCalculator$Timestamp_0);
_.low = false;
var Lorg_eclipse_elk_alg_layered_compaction_oned_algs_ScanlineConstraintCalculator$Timestamp_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/Timestamp', 550);
function ScanlineConstraintCalculator$lambda$0$Type_0(){
}

defineClass(1617, 1, $intern_40, ScanlineConstraintCalculator$lambda$0$Type_0);
_.equals_0 = function equals_85(other){
  return this === other;
}
;
_.reversed = function reversed_24(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_32(arg0, arg1){
  return lambda$0_10(arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_oned_algs_ScanlineConstraintCalculator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.oned.algs', 'ScanlineConstraintCalculator/lambda$0$Type', 1617);
function Point(x_0, y_0){
  this.x_0 = x_0;
  this.y_0 = y_0;
}

function Point_0(x_0, y_0, quadrant){
  Point.call(this, x_0, y_0);
  this.quadrant = quadrant;
}

defineClass(105, 1, {105:1}, Point, Point_0);
_.equals_0 = function equals_86(obj){
  var p2;
  if (obj == null) {
    return false;
  }
  if (Lorg_eclipse_elk_alg_layered_compaction_recthull_Point_2_classLit != getClass__Ljava_lang_Class___devirtual$(obj)) {
    return false;
  }
  p2 = castTo(obj, 105);
  return equals_56(this.x_0, p2.x_0) && equals_56(this.y_0, p2.y_0);
}
;
_.hashCode_1 = function hashCode_55(){
  return hashCode_43(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [this.x_0, this.y_0]));
}
;
_.toString_0 = function toString_83(){
  return '(' + this.x_0 + ', ' + this.y_0 + (this.convex?'cx':'') + this.quadrant + ')';
}
;
_.convex = true;
_.x_0 = 0;
_.y_0 = 0;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_Point_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'Point', 105);
function $clinit_Point$Quadrant(){
  $clinit_Point$Quadrant = emptyMethod;
  Q1 = new Point$Quadrant('Q1', 0);
  Q4 = new Point$Quadrant('Q4', 1);
  Q2 = new Point$Quadrant('Q2', 2);
  Q3 = new Point$Quadrant('Q3', 3);
}

function $isLeft(this$static){
  return this$static == Q1 || this$static == Q4;
}

function $isUpper(this$static){
  return this$static == Q1 || this$static == Q2;
}

function Point$Quadrant(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function isBothLeftOrBothRight(q1, q2){
  $clinit_Point$Quadrant();
  return q1 == Q1 && q2 == Q4 || q1 == Q4 && q2 == Q1 || q1 == Q3 && q2 == Q2 || q1 == Q2 && q2 == Q3;
}

function isOneLeftOneRight(q1, q2){
  $clinit_Point$Quadrant();
  return q1 == Q1 && q2 == Q2 || q1 == Q1 && q2 == Q3 || q1 == Q4 && q2 == Q3 || q1 == Q4 && q2 == Q2;
}

function valueOf_28(name_0){
  $clinit_Point$Quadrant();
  return valueOf(($clinit_Point$Quadrant$Map() , $MAP_16), name_0);
}

function values_24(){
  $clinit_Point$Quadrant();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_recthull_Point$Quadrant_2_classLit, 1), $intern_38, 388, 0, [Q1, Q4, Q2, Q3]);
}

defineClass(388, 22, {3:1, 34:1, 22:1, 388:1}, Point$Quadrant);
var Q1, Q2, Q3, Q4;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_Point$Quadrant_2_classLit = createForEnum('org.eclipse.elk.alg.layered.compaction.recthull', 'Point/Quadrant', 388, Ljava_lang_Enum_2_classLit, values_24, valueOf_28);
function $clinit_Point$Quadrant$Map(){
  $clinit_Point$Quadrant$Map = emptyMethod;
  $MAP_16 = createValueOfMap(($clinit_Point$Quadrant() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_recthull_Point$Quadrant_2_classLit, 1), $intern_38, 388, 0, [Q1, Q4, Q2, Q3])));
}

var $MAP_16;
function $clinit_RectilinearConvexHull(){
  $clinit_RectilinearConvexHull = emptyMethod;
  RIGHT_HIGH_FIRST = new RectilinearConvexHull$lambda$0$Type;
  RIGHT_LOW_FIRST = new RectilinearConvexHull$lambda$1$Type;
  LEFT_HIGH_FIRST = new RectilinearConvexHull$lambda$2$Type;
  LEFT_LOW_FIRST = new RectilinearConvexHull$lambda$3$Type;
  RIGHT_SPECIAL_ORDER = new RectilinearConvexHull$lambda$4$Type;
}

function $splitIntoRectangles(this$static){
  var handler;
  handler = new RectilinearConvexHull$RectangleEventHandler(this$static);
  execute_0(this$static.hull, RIGHT_SPECIAL_ORDER, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_1, 355, 0, [handler])));
  !!handler.queued && $add_4(handler.rects, handler.queued);
  return handler.rects;
}

function RectilinearConvexHull(){
  this.hull = new ArrayList;
}

function addConcaveCorners(pts, q){
  var last, next, p, pIt;
  pIt = new AbstractList$ListIteratorImpl(pts, 0);
  last = (checkCriticalElement(pIt.i < pIt.this$01_0.size_1()) , castTo(pIt.this$01_0.get_3(pIt.last = pIt.i++), 105));
  while (pIt.i < pIt.this$01_0.size_1()) {
    next = (checkCriticalElement(pIt.i < pIt.this$01_0.size_1()) , castTo(pIt.this$01_0.get_3(pIt.last = pIt.i++), 105));
    p = new Point_0(next.x_0, last.y_0, q);
    checkCriticalElement(pIt.i > 0);
    pIt.this$01.get_3(pIt.last = --pIt.i);
    $add_2(pIt, p);
    checkCriticalElement(pIt.i < pIt.this$01_0.size_1());
    pIt.this$01_0.get_3(pIt.last = pIt.i++);
    p.convex = false;
    last = next;
  }
}

function lambda$4_0(p1_0, p2_1){
  $clinit_RectilinearConvexHull();
  var val;
  if (p1_0.x_0 == p2_1.x_0) {
    if (p1_0.quadrant == p2_1.quadrant || isBothLeftOrBothRight(p1_0.quadrant, p2_1.quadrant)) {
      val = $isLeft(p1_0.quadrant)?1:-1;
      if (p1_0.convex && !p2_1.convex) {
        return val;
      }
       else if (!p1_0.convex && p2_1.convex) {
        return -val;
      }
    }
    return compare_6(p1_0.quadrant.ordinal, p2_1.quadrant.ordinal);
  }
   else {
    return compare_5(p1_0.x_0, p2_1.x_0);
  }
}

function of_4(points){
  $clinit_RectilinearConvexHull();
  var p, p$iterator, q1, q2, q3, q4, rch;
  rch = new RectilinearConvexHull;
  for (p$iterator = new ArrayList$1(points); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_10(p$iterator), 105);
    (!rch.xMax1 || p.x_0 >= rch.xMax1.x_0) && (rch.xMax1 = p);
    if (!rch.xMin1 || p.x_0 <= rch.xMin1.x_0) {
      rch.xMin2 = rch.xMin1;
      rch.xMin1 = p;
    }
    (!rch.yMax1 || p.y_0 >= rch.yMax1.y_0) && (rch.yMax1 = p);
    (!rch.yMin1 || p.y_0 <= rch.yMin1.y_0) && (rch.yMin1 = p);
  }
  q1 = new RectilinearConvexHull$MaximalElementsEventHandler(($clinit_Point$Quadrant() , Q1));
  execute_0(points, RIGHT_LOW_FIRST, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_1, 355, 0, [q1])));
  q4 = new RectilinearConvexHull$MaximalElementsEventHandler(Q4);
  execute_0(points, RIGHT_HIGH_FIRST, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_1, 355, 0, [q4])));
  q2 = new RectilinearConvexHull$MaximalElementsEventHandler(Q2);
  execute_0(points, LEFT_LOW_FIRST, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_1, 355, 0, [q2])));
  q3 = new RectilinearConvexHull$MaximalElementsEventHandler(Q3);
  execute_0(points, LEFT_HIGH_FIRST, new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_compaction_recthull_Scanline$EventHandler_2_classLit, 1), $intern_1, 355, 0, [q3])));
  addConcaveCorners(q1.points, Q1);
  addConcaveCorners(q2.points, Q2);
  addConcaveCorners(q3.points, Q3);
  addConcaveCorners(q4.points, Q4);
  rch.hull.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $addAll_2(rch.hull, q1.points);
  $addAll_2(rch.hull, reverse_0(q2.points));
  $addAll_2(rch.hull, q3.points);
  $addAll_2(rch.hull, reverse_0(q4.points));
  return rch;
}

defineClass(1490, 1, {}, RectilinearConvexHull);
_.xMax1 = null;
_.xMin1 = null;
_.xMin2 = null;
_.yMax1 = null;
_.yMin1 = null;
var LEFT_HIGH_FIRST, LEFT_LOW_FIRST, RIGHT_HIGH_FIRST, RIGHT_LOW_FIRST, RIGHT_SPECIAL_ORDER;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull', 1490);
function $clinit_RectilinearConvexHull$MaximalElementsEventHandler(){
  $clinit_RectilinearConvexHull$MaximalElementsEventHandler = emptyMethod;
  DBL_CMP = new RectilinearConvexHull$MaximalElementsEventHandler$lambda$0$Type;
}

function $handle_2(this$static, p){
  if (this$static.compare.compare_0(p.y_0, this$static.maximalY) > 0) {
    $add_4(this$static.points, new Point_0(p.x_0, p.y_0, this$static.quadrant));
    this$static.maximalY = p.y_0;
  }
}

function RectilinearConvexHull$MaximalElementsEventHandler(quadrant){
  $clinit_RectilinearConvexHull$MaximalElementsEventHandler();
  this.points = new ArrayList;
  this.quadrant = quadrant;
  switch (quadrant.ordinal) {
    case 0:
    case 2:
      this.compare = reverseOrder(DBL_CMP);
      this.maximalY = $intern_62;
      break;
    case 3:
    case 1:
      this.compare = DBL_CMP;
      this.maximalY = $intern_63;
  }
}

defineClass(542, 1, {355:1}, RectilinearConvexHull$MaximalElementsEventHandler);
_.handle = function handle_2(p){
  $handle_2(this, castTo(p, 105));
}
;
_.maximalY = 0;
var DBL_CMP;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull$MaximalElementsEventHandler_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull/MaximalElementsEventHandler', 542);
function RectilinearConvexHull$MaximalElementsEventHandler$lambda$0$Type(){
}

defineClass(1492, 1, $intern_40, RectilinearConvexHull$MaximalElementsEventHandler$lambda$0$Type);
_.equals_0 = function equals_87(other){
  return this === other;
}
;
_.reversed = function reversed_25(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_33(arg0, arg1){
  return $clinit_RectilinearConvexHull$MaximalElementsEventHandler() , compare_5(checkNotNull_1(castToDouble(arg0)), checkNotNull_1(castToDouble(arg1)));
}
;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull$MaximalElementsEventHandler$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull/MaximalElementsEventHandler/lambda$0$Type', 1492);
function $handle_3(this$static, p){
  var r;
  if (!!this$static.queued && (p.x_0 != this$static.queuedPnt.x_0 || isOneLeftOneRight(this$static.queuedPnt.quadrant, p.quadrant))) {
    $add_4(this$static.rects, this$static.queued);
    this$static.lastX = this$static.queued.x_0 + this$static.queued.width_0;
    this$static.queued = null;
    this$static.queuedPnt = null;
  }
  $isUpper(p.quadrant)?(this$static.minY = p):(this$static.maxY = p);
  if (p.quadrant == ($clinit_Point$Quadrant() , Q1) && !p.convex || p.quadrant == Q2 && p.convex || p.quadrant == Q3 && p.convex || p.quadrant == Q4 && !p.convex) {
    if (!!this$static.minY && !!this$static.maxY) {
      r = new ElkRectangle_0(this$static.lastX, this$static.minY.y_0, p.x_0 - this$static.lastX, this$static.maxY.y_0 - this$static.minY.y_0);
      this$static.queued = r;
      this$static.queuedPnt = p;
    }
  }
}

function RectilinearConvexHull$RectangleEventHandler(this$0){
  this.this$01 = this$0;
  this.rects = new ArrayList;
  this.lastX = $wnd.Math.min(this.this$01.xMin1.x_0, this.this$01.xMin2.x_0);
}

defineClass(1491, 1, {355:1}, RectilinearConvexHull$RectangleEventHandler);
_.handle = function handle_3(p){
  $handle_3(this, castTo(p, 105));
}
;
_.lastX = 0;
_.maxY = null;
_.minY = null;
_.queued = null;
_.queuedPnt = null;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull$RectangleEventHandler_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull/RectangleEventHandler', 1491);
function RectilinearConvexHull$lambda$0$Type(){
}

defineClass(1493, 1, $intern_40, RectilinearConvexHull$lambda$0$Type);
_.equals_0 = function equals_88(other){
  return this === other;
}
;
_.reversed = function reversed_26(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_34(arg0, arg1){
  return $clinit_RectilinearConvexHull() , castTo(arg0, 105).x_0 == castTo(arg1, 105).x_0?compare_5(castTo(arg1, 105).y_0, castTo(arg0, 105).y_0):compare_5(castTo(arg0, 105).x_0, castTo(arg1, 105).x_0);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull/lambda$0$Type', 1493);
function RectilinearConvexHull$lambda$1$Type(){
}

defineClass(1494, 1, $intern_40, RectilinearConvexHull$lambda$1$Type);
_.equals_0 = function equals_89(other){
  return this === other;
}
;
_.reversed = function reversed_27(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_35(arg0, arg1){
  return $clinit_RectilinearConvexHull() , castTo(arg0, 105).x_0 == castTo(arg1, 105).x_0?compare_5(castTo(arg0, 105).y_0, castTo(arg1, 105).y_0):compare_5(castTo(arg0, 105).x_0, castTo(arg1, 105).x_0);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull/lambda$1$Type', 1494);
function RectilinearConvexHull$lambda$2$Type(){
}

defineClass(1495, 1, $intern_40, RectilinearConvexHull$lambda$2$Type);
_.equals_0 = function equals_90(other){
  return this === other;
}
;
_.reversed = function reversed_28(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_36(arg0, arg1){
  return $clinit_RectilinearConvexHull() , castTo(arg0, 105).x_0 == castTo(arg1, 105).x_0?compare_5(castTo(arg1, 105).y_0, castTo(arg0, 105).y_0):compare_5(castTo(arg1, 105).x_0, castTo(arg0, 105).x_0);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull/lambda$2$Type', 1495);
function RectilinearConvexHull$lambda$3$Type(){
}

defineClass(1496, 1, $intern_40, RectilinearConvexHull$lambda$3$Type);
_.equals_0 = function equals_91(other){
  return this === other;
}
;
_.reversed = function reversed_29(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_37(arg0, arg1){
  return $clinit_RectilinearConvexHull() , castTo(arg0, 105).x_0 == castTo(arg1, 105).x_0?compare_5(castTo(arg0, 105).y_0, castTo(arg1, 105).y_0):compare_5(castTo(arg1, 105).x_0, castTo(arg0, 105).x_0);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull/lambda$3$Type', 1496);
function RectilinearConvexHull$lambda$4$Type(){
}

defineClass(1497, 1, $intern_40, RectilinearConvexHull$lambda$4$Type);
_.equals_0 = function equals_92(other){
  return this === other;
}
;
_.reversed = function reversed_30(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_38(arg0, arg1){
  return lambda$4_0(arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_compaction_recthull_RectilinearConvexHull$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'RectilinearConvexHull/lambda$4$Type', 1497);
function $go_0(this$static){
  var h, h$iterator, p, p$iterator;
  $clinit_Collections();
  $sort(this$static.points, this$static.comparator);
  for (p$iterator = new ArrayList$1(this$static.points); p$iterator.i < p$iterator.this$01.array.length;) {
    p = $next_10(p$iterator);
    for (h$iterator = new ArrayList$1(this$static.eventHandlers); h$iterator.i < h$iterator.this$01.array.length;) {
      h = castTo($next_10(h$iterator), 355);
      h.handle(p);
    }
  }
}

function Scanline_0(points, comparator, eventHandlers){
  this.comparator = comparator;
  this.points = points;
  this.eventHandlers = (checkNotNull(eventHandlers) , new ArrayList_1(($clinit_Collections2() , eventHandlers)));
}

function execute_0(points, comparator, eventHandlers){
  var copy;
  copy = (checkNotNull(points) , new ArrayList_1(($clinit_Collections2() , points)));
  $go_0(new Scanline_0(copy, comparator, eventHandlers));
}

defineClass(1498, 1, {}, Scanline_0);
var Lorg_eclipse_elk_alg_layered_compaction_recthull_Scanline_2_classLit = createForClass('org.eclipse.elk.alg.layered.compaction.recthull', 'Scanline', 1498);
function $moveGraph_0(destGraph, sourceGraph, offsetx, offsety){
  var edge, edge$iterator, graphOffset, junctionPoints, label_0, label$iterator, node, node$iterator, port, port$iterator;
  graphOffset = $add_18(sourceGraph.offset, offsetx, offsety);
  for (node$iterator = new ArrayList$1(sourceGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $add_19(node.pos, graphOffset);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        $offset_2(edge.bendPoints, graphOffset);
        junctionPoints = castTo($getProperty(edge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
        !!junctionPoints && $offset_2(junctionPoints, graphOffset);
        for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_10(label$iterator), 70);
          $add_19(label_0.pos, graphOffset);
        }
      }
    }
    $add_4(destGraph.layerlessNodes, node);
    node.graph_0 = destGraph;
  }
}

function $moveGraphs(destGraph, sourceGraphs){
  var sourceGraph, sourceGraph$iterator;
  for (sourceGraph$iterator = sourceGraphs.iterator_0(); sourceGraph$iterator.hasNext_0();) {
    sourceGraph = castTo(sourceGraph$iterator.next_1(), 32);
    $moveGraph_0(destGraph, sourceGraph, 0, 0);
  }
}

function $offsetGraph(graph, offsetx, offsety){
  var edge, edge$iterator, graphOffset, junctionPoints, label_0, label$iterator, node, node$iterator, port, port$iterator;
  graphOffset = new KVector_1(offsetx, offsety);
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $add_19(node.pos, graphOffset);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        $offset_2(edge.bendPoints, graphOffset);
        junctionPoints = castTo($getProperty(edge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
        !!junctionPoints && $offset_2(junctionPoints, graphOffset);
        for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_10(label$iterator), 70);
          $add_19(label_0.pos, graphOffset);
        }
      }
    }
  }
}

function $offsetGraphs(graphs, offsetx, offsety){
  var graph, graph$iterator;
  for (graph$iterator = graphs.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 32);
    $offsetGraph(graph, offsetx, offsety);
  }
}

defineClass(1780, 1, {});
var Lorg_eclipse_elk_alg_layered_components_AbstractGraphPlacer_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'AbstractGraphPlacer', 1780);
function $clinit_ComponentGroup(){
  $clinit_ComponentGroup = emptyMethod;
  CONSTRAINTS = new HashMultimap;
  $put(CONSTRAINTS, ($clinit_PortSide() , SIDES_WEST), SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_SOUTH, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH, SIDES_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_WEST, SIDES_NORTH_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_WEST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_WEST, SIDES_NORTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_WEST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST, SIDES_NORTH_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_SOUTH_WEST, SIDES_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_SOUTH_WEST, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_SOUTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH, SIDES_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_WEST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_NORTH_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_EAST_SOUTH_WEST, SIDES_NORTH_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_EAST_SOUTH);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_EAST_SOUTH_WEST);
  $put(CONSTRAINTS, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST_SOUTH);
}

function $add_12(this$static, component){
  if ($canAdd(this$static, component)) {
    $put(this$static.components, castTo($getProperty(component, ($clinit_InternalProperties_1() , EXT_PORT_CONNECTIONS)), 19), component);
    return true;
  }
   else {
    return false;
  }
}

function $canAdd(this$static, component){
  var candidateSides, constraint, constraint$iterator, constraints;
  candidateSides = castTo($getProperty(component, ($clinit_InternalProperties_1() , EXT_PORT_CONNECTIONS)), 19);
  constraints = castTo($get_0(CONSTRAINTS, candidateSides), 19);
  for (constraint$iterator = constraints.iterator_0(); constraint$iterator.hasNext_0();) {
    constraint = castTo(constraint$iterator.next_1(), 19);
    if (!castTo($get_0(this$static.components, constraint), 15).isEmpty()) {
      return false;
    }
  }
  return true;
}

function $getComponents(this$static, connections){
  return castTo($get_0(this$static.components, connections), 15);
}

function ComponentGroup(component){
  $clinit_ComponentGroup();
  this.components = new ArrayListMultimap;
  $add_12(this, component);
}

defineClass(480, 1, {480:1}, ComponentGroup);
var CONSTRAINTS;
var Lorg_eclipse_elk_alg_layered_components_ComponentGroup_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentGroup', 480);
function $addComponent(this$static, component){
  var group, group$iterator;
  for (group$iterator = new ArrayList$1(this$static.componentGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 480);
    if ($add_12(group, component)) {
      return;
    }
  }
  $add_4(this$static.componentGroups, new ComponentGroup(component));
}

function $placeComponents(group, spacing){
  var colLeftWidth, colMidWidth, colNsWidth, colRightWidth, componentSize, rowBottomHeight, rowMidHeight, rowTopHeight, rowWeHeight, sizeC, sizeE, sizeENS, sizeN, sizeNE, sizeNESW, sizeNS, sizeNW, sizeNWE, sizeS, sizeSE, sizeSW, sizeSWE, sizeW, sizeWE, sizeWNS;
  sizeC = $placeComponentsInRows($getComponents(group, ($clinit_PortSide() , SIDES_NONE)), spacing);
  sizeN = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH), spacing);
  sizeS = $placeComponentsHorizontally($getComponents(group, SIDES_SOUTH), spacing);
  sizeW = $placeComponentsVertically($getComponents(group, SIDES_WEST), spacing);
  sizeE = $placeComponentsVertically($getComponents(group, SIDES_EAST), spacing);
  sizeNW = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_WEST), spacing);
  sizeNE = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_EAST), spacing);
  sizeSW = $placeComponentsHorizontally($getComponents(group, SIDES_SOUTH_WEST), spacing);
  sizeSE = $placeComponentsHorizontally($getComponents(group, SIDES_EAST_SOUTH), spacing);
  sizeWE = $placeComponentsVertically($getComponents(group, SIDES_EAST_WEST), spacing);
  sizeNS = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_SOUTH), spacing);
  sizeNWE = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_EAST_WEST), spacing);
  sizeSWE = $placeComponentsHorizontally($getComponents(group, SIDES_EAST_SOUTH_WEST), spacing);
  sizeWNS = $placeComponentsVertically($getComponents(group, SIDES_NORTH_SOUTH_WEST), spacing);
  sizeENS = $placeComponentsVertically($getComponents(group, SIDES_NORTH_EAST_SOUTH), spacing);
  sizeNESW = $placeComponentsHorizontally($getComponents(group, SIDES_NORTH_EAST_SOUTH_WEST), spacing);
  colLeftWidth = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [sizeNW.x_0, sizeW.x_0, sizeSW.x_0, sizeWNS.x_0]));
  colMidWidth = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [sizeN.x_0, sizeC.x_0, sizeS.x_0, sizeNESW.x_0]));
  colNsWidth = sizeNS.x_0;
  colRightWidth = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [sizeNE.x_0, sizeE.x_0, sizeSE.x_0, sizeENS.x_0]));
  rowTopHeight = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [sizeNW.y_0, sizeN.y_0, sizeNE.y_0, sizeNWE.y_0]));
  rowMidHeight = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [sizeW.y_0, sizeC.y_0, sizeE.y_0, sizeNESW.y_0]));
  rowWeHeight = sizeWE.y_0;
  rowBottomHeight = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [sizeSW.y_0, sizeS.y_0, sizeSE.y_0, sizeSWE.y_0]));
  $offsetGraphs($getComponents(group, SIDES_NONE), colLeftWidth + colNsWidth, rowTopHeight + rowWeHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH_EAST_SOUTH_WEST), colLeftWidth + colNsWidth, rowTopHeight + rowWeHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH), colLeftWidth + colNsWidth, 0);
  $offsetGraphs($getComponents(group, SIDES_SOUTH), colLeftWidth + colNsWidth, rowTopHeight + rowWeHeight + rowMidHeight);
  $offsetGraphs($getComponents(group, SIDES_WEST), 0, rowTopHeight + rowWeHeight);
  $offsetGraphs($getComponents(group, SIDES_EAST), colLeftWidth + colNsWidth + colMidWidth, rowTopHeight + rowWeHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH_EAST), colLeftWidth + colNsWidth + colMidWidth, 0);
  $offsetGraphs($getComponents(group, SIDES_SOUTH_WEST), 0, rowTopHeight + rowWeHeight + rowMidHeight);
  $offsetGraphs($getComponents(group, SIDES_EAST_SOUTH), colLeftWidth + colNsWidth + colMidWidth, rowTopHeight + rowWeHeight + rowMidHeight);
  $offsetGraphs($getComponents(group, SIDES_EAST_WEST), 0, rowTopHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH_SOUTH), colLeftWidth, 0);
  $offsetGraphs($getComponents(group, SIDES_EAST_SOUTH_WEST), 0, rowTopHeight + rowWeHeight + rowMidHeight);
  $offsetGraphs($getComponents(group, SIDES_NORTH_EAST_SOUTH), colLeftWidth + colNsWidth + colMidWidth, 0);
  componentSize = new KVector;
  componentSize.x_0 = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [colLeftWidth + colMidWidth + colNsWidth + colRightWidth, sizeWE.x_0, sizeNWE.x_0, sizeSWE.x_0]));
  componentSize.y_0 = maxd(stampJavaTypeInfo(getClassLiteralForArray(D_classLit, 1), $intern_69, 23, 15, [rowTopHeight + rowMidHeight + rowWeHeight + rowBottomHeight, sizeNS.y_0, sizeWNS.y_0, sizeENS.y_0]));
  return componentSize;
}

function $placeComponentsHorizontally(components, spacing){
  var component, component$iterator, size_0;
  size_0 = new KVector;
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 32);
    $offsetGraph(component, size_0.x_0, 0);
    size_0.x_0 += component.size_0.x_0 + spacing;
    size_0.y_0 = $wnd.Math.max(size_0.y_0, component.size_0.y_0);
  }
  size_0.y_0 > 0 && (size_0.y_0 += spacing);
  return size_0;
}

function $placeComponentsInRows(components, spacing){
  var broadestRow, component, component$iterator, componentSize, graph, graph$iterator, highestBox, maxRowWidth, size_0, totalArea, xpos, ypos;
  if (components.isEmpty()) {
    return new KVector;
  }
  maxRowWidth = 0;
  totalArea = 0;
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 32);
    componentSize = component.size_0;
    maxRowWidth = $wnd.Math.max(maxRowWidth, componentSize.x_0);
    totalArea += componentSize.x_0 * componentSize.y_0;
  }
  maxRowWidth = $wnd.Math.max(maxRowWidth, $wnd.Math.sqrt(totalArea) * checkNotNull_1(castToDouble($getProperty(castTo(components.iterator_0().next_1(), 32), ($clinit_LayeredOptions() , ASPECT_RATIO_1)))));
  xpos = 0;
  ypos = 0;
  highestBox = 0;
  broadestRow = spacing;
  for (graph$iterator = components.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 32);
    size_0 = graph.size_0;
    if (xpos + size_0.x_0 > maxRowWidth) {
      xpos = 0;
      ypos += highestBox + spacing;
      highestBox = 0;
    }
    $offsetGraph(graph, xpos, ypos);
    broadestRow = $wnd.Math.max(broadestRow, xpos + size_0.x_0);
    highestBox = $wnd.Math.max(highestBox, size_0.y_0);
    xpos += size_0.x_0 + spacing;
  }
  return new KVector_1(broadestRow + spacing, ypos + highestBox + spacing);
}

function $placeComponentsVertically(components, spacing){
  var component, component$iterator, size_0;
  size_0 = new KVector;
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 32);
    $offsetGraph(component, 0, size_0.y_0);
    size_0.y_0 += component.size_0.y_0 + spacing;
    size_0.x_0 = $wnd.Math.max(size_0.x_0, component.size_0.x_0);
  }
  size_0.x_0 > 0 && (size_0.x_0 += spacing);
  return size_0;
}

function ComponentGroupGraphPlacer(){
  this.componentGroups = new ArrayList;
}

defineClass(1177, 1780, {}, ComponentGroupGraphPlacer);
_.combine = function combine(components, target){
  var compactor, component, component$iterator, componentSpacing, firstComponent, group, group$iterator, group$iterator0, groupSize, h, h$iterator, h$iterator0, offset;
  this.componentGroups.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  target.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  if (components.isEmpty()) {
    target.size_0.x_0 = 0;
    target.size_0.y_0 = 0;
    return;
  }
  firstComponent = castTo(components.get_3(0), 32);
  $copyProperties(target, firstComponent);
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 32);
    $addComponent(this, component);
  }
  offset = new KVector;
  componentSpacing = checkNotNull_1(castToDouble($getProperty(firstComponent, ($clinit_LayeredOptions() , SPACING_COMPONENT_COMPONENT_0))));
  for (group$iterator0 = new ArrayList$1(this.componentGroups); group$iterator0.i < group$iterator0.this$01.array.length;) {
    group = castTo($next_10(group$iterator0), 480);
    groupSize = $placeComponents(group, componentSpacing);
    $offsetGraphs($values(group.components), offset.x_0, offset.y_0);
    offset.x_0 += groupSize.x_0;
    offset.y_0 += groupSize.y_0;
  }
  target.size_0.x_0 = offset.x_0 - componentSpacing;
  target.size_0.y_0 = offset.y_0 - componentSpacing;
  if (checkNotNull_1(castToBoolean($getProperty(firstComponent, COMPACTION_CONNECTED_COMPONENTS_0))) && maskUndefined($getProperty(firstComponent, EDGE_ROUTING)) === maskUndefined(($clinit_EdgeRouting() , ORTHOGONAL))) {
    for (h$iterator0 = components.iterator_0(); h$iterator0.hasNext_0();) {
      h = castTo(h$iterator0.next_1(), 32);
      $offsetGraph(h, h.offset.x_0, h.offset.y_0);
    }
    compactor = new ComponentsCompactor;
    $compact_5(compactor, components, componentSpacing);
    for (h$iterator = components.iterator_0(); h$iterator.hasNext_0();) {
      h = castTo(h$iterator.next_1(), 32);
      $add_19($reset_5(h.offset), compactor.yetAnotherOffset);
    }
    $add_19($reset_5(target.size_0), compactor.compactedGraphSize);
  }
  for (group$iterator = new ArrayList$1(this.componentGroups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 480);
    $moveGraphs(target, $values(group.components));
  }
}
;
var Lorg_eclipse_elk_alg_layered_components_ComponentGroupGraphPlacer_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentGroupGraphPlacer', 1177);
function $addLGraphElementBounds(pts, element, offset){
  var margins;
  margins = null;
  !!element && (margins = element.margin);
  $add_13(pts, new Point(element.pos.x_0 - margins.left + offset.x_0, element.pos.y_0 - margins.top_0 + offset.y_0));
  $add_13(pts, new Point(element.pos.x_0 - margins.left + offset.x_0, element.pos.y_0 + element.size_0.y_0 + margins.bottom + offset.y_0));
  $add_13(pts, new Point(element.pos.x_0 + element.size_0.x_0 + margins.right + offset.x_0, element.pos.y_0 - margins.top_0 + offset.y_0));
  $add_13(pts, new Point(element.pos.x_0 + element.size_0.x_0 + margins.right + offset.x_0, element.pos.y_0 + element.size_0.y_0 + margins.bottom + offset.y_0));
}

function $compact_5(this$static, graphs, spacing){
  var c, cc, cc$iterator, cc$iterator0, ccs, e, e$iterator, graph, graph$iterator, graph$iterator0, last, lastArg, n, n$iterator, newPos, node, node$iterator, offset, v, v$iterator, vc, compaction;
  this$static.graphTopLeft = new KVector_1($intern_62, $intern_62);
  this$static.graphBottomRight = new KVector_1($intern_63, $intern_63);
  for (graph$iterator0 = graphs.iterator_0(); graph$iterator0.hasNext_0();) {
    graph = castTo(graph$iterator0.next_1(), 32);
    for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      this$static.graphTopLeft.x_0 = $wnd.Math.min(this$static.graphTopLeft.x_0, node.pos.x_0 - node.margin.left);
      this$static.graphTopLeft.y_0 = $wnd.Math.min(this$static.graphTopLeft.y_0, node.pos.y_0 - node.margin.top_0);
      this$static.graphBottomRight.x_0 = $wnd.Math.max(this$static.graphBottomRight.x_0, node.pos.x_0 + node.size_0.x_0 + node.margin.right);
      this$static.graphBottomRight.y_0 = $wnd.Math.max(this$static.graphBottomRight.y_0, node.pos.y_0 + node.size_0.y_0 + node.margin.bottom);
    }
  }
  ccs = new ComponentsCompactor$InternalConnectedComponents;
  for (graph$iterator = graphs.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 32);
    c = $transformLGraph(this$static, graph);
    $add_4(ccs.components, c);
    c.containsRegularNodes = c.containsRegularNodes | !castTo($getProperty(c.graph_0, ($clinit_InternalProperties_1() , EXT_PORT_CONNECTIONS)), 19).isEmpty();
  }
  this$static.compactor = ($clinit_OneDimensionalComponentsCompaction() , compaction = new OneDimensionalComponentsCompaction , compaction.transformer = new ComponentsToCGraphTransformer(spacing) , compaction.compactionGraph = $transform_0(compaction.transformer, ccs) , compaction);
  $compact_2((lastArg = this$static.compactor , new BasicProgressMonitor , lastArg));
  this$static.yetAnotherOffset = new KVector;
  this$static.compactedGraphSize = this$static.compactor.transformer.graphSize;
  for (cc$iterator0 = new ArrayList$1(ccs.components); cc$iterator0.i < cc$iterator0.this$01.array.length;) {
    cc = castTo($next_10(cc$iterator0), 775);
    offset = $getOffset_0(this$static.compactor, cc);
    offsetGraph(cc.graph_0, offset.x_0, offset.y_0);
    for (n$iterator = new ArrayList$1(cc.graph_0.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      if (n.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        newPos = $getExternalPortPosition(this$static, n.pos, castTo($getProperty(n, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71));
        $add_19($reset_5(n.pos), newPos);
      }
    }
  }
  for (cc$iterator = new ArrayList$1(ccs.components); cc$iterator.i < cc$iterator.this$01.array.length;) {
    cc = castTo($next_10(cc$iterator), 775);
    for (e$iterator = new ArrayList$1($getExternalEdges(cc)); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_10(e$iterator), 16);
      vc = new KVectorChain_0(e.bendPoints);
      $add_0(vc, 0, $getAbsoluteAnchor(e.source));
      $add_7(vc, $getAbsoluteAnchor(e.target));
      last = null;
      for (v$iterator = $listIterator_1(vc, 0); v$iterator.currentNode != v$iterator.this$01.tail;) {
        v = castTo($next_13(v$iterator), 8);
        if (!last) {
          last = v;
          continue;
        }
        if (fuzzyEquals(last.x_0, v.x_0)) {
          this$static.yetAnotherOffset.x_0 = $wnd.Math.min(this$static.yetAnotherOffset.x_0, last.x_0);
          this$static.compactedGraphSize.x_0 = $wnd.Math.max(this$static.compactedGraphSize.x_0, last.x_0);
        }
         else if (fuzzyEquals(last.y_0, v.y_0)) {
          this$static.yetAnotherOffset.y_0 = $wnd.Math.min(this$static.yetAnotherOffset.y_0, last.y_0);
          this$static.compactedGraphSize.y_0 = $wnd.Math.max(this$static.compactedGraphSize.y_0, last.y_0);
        }
        last = v;
      }
    }
  }
  $negate(this$static.yetAnotherOffset);
  $add_19(this$static.compactedGraphSize, this$static.yetAnotherOffset);
}

function $componentHullPoints(graph){
  var bp, bp$iterator, edge, edge$iterator, n, n$iterator, pts;
  pts = new ComponentsCompactor$Hullpoints;
  for (n$iterator = new ArrayList$1(graph.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 9);
    if (n.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    $addLGraphElementBounds(pts, n, new KVector);
    for (edge$iterator = $iterator($getOutgoingEdges(n)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 16);
      if (edge.source.owner.type_0 == EXTERNAL_PORT || edge.target.owner.type_0 == EXTERNAL_PORT) {
        continue;
      }
      for (bp$iterator = $listIterator_1(edge.bendPoints, 0); bp$iterator.currentNode != bp$iterator.this$01.tail;) {
        bp = castTo($next_13(bp$iterator), 8);
        $add_13(pts, new Point(bp.x_0, bp.y_0));
      }
    }
  }
  return pts;
}

function $createDummyNode(graph){
  var dummy, dummyEdge, dummyPort, extPortDummy, extPortDummyPort;
  extPortDummy = castTo($get_7(graph.layerlessNodes, 0), 9);
  dummy = new LNode(graph);
  $add_4(graph.layerlessNodes, dummy);
  dummy.size_0.x_0 = $wnd.Math.max(1, extPortDummy.size_0.x_0);
  dummy.size_0.y_0 = $wnd.Math.max(1, extPortDummy.size_0.y_0);
  dummy.pos.x_0 = extPortDummy.pos.x_0;
  dummy.pos.y_0 = extPortDummy.pos.y_0;
  switch (castTo($getProperty(extPortDummy, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71).ordinal) {
    case 4:
      dummy.pos.x_0 += 2;
      break;
    case 1:
      dummy.pos.y_0 += 2;
      break;
    case 2:
      dummy.pos.x_0 -= 2;
      break;
    case 3:
      dummy.pos.y_0 -= 2;
  }
  dummyPort = new LPort;
  $setNode(dummyPort, dummy);
  dummyEdge = new LEdge;
  extPortDummyPort = castTo($get_7(extPortDummy.ports, 0), 11);
  $setSource_0(dummyEdge, extPortDummyPort);
  $setTarget_0(dummyEdge, dummyPort);
  $add_19($reset_5(dummyPort.pos), extPortDummyPort.pos);
  $add_19($reset_5(dummyPort.anchor), extPortDummyPort.anchor);
  return dummy;
}

function $edgeToSegments(this$static, edge, externalExtension){
  var externalPort, externalPortSide, i, outerSegmentIsFirst, p1, p2, points, segment, segments;
  externalPort = externalExtension.externalPort;
  externalPortSide = externalExtension.externalPortSide;
  p1 = $getAbsoluteAnchor(edge.source);
  p2 = $getAbsoluteAnchor(edge.target);
  if (externalPort == edge.source) {
    p1 = $getExternalPortPosition(this$static, p1, externalPortSide);
    p2 = $getPortPositionOnMargin(edge.target);
  }
   else {
    p1 = $getPortPositionOnMargin(edge.source);
    p2 = $getExternalPortPosition(this$static, p2, externalPortSide);
  }
  points = new KVectorChain_0(edge.bendPoints);
  $addNode_0(points, p1, points.header, points.header.next_0);
  $addNode_0(points, p2, points.tail.prev, points.tail);
  outerSegmentIsFirst = edge.source == externalPort;
  segments = new ComponentsCompactor$Segments;
  for (i = 0; i < points.size_0 - 1; ++i) {
    segment = new Pair(castTo($get_3(points, i), 8), castTo($get_3(points, i + 1), 8));
    outerSegmentIsFirst && i == 0 || !outerSegmentIsFirst && i == points.size_0 - 2?(segments.outerSegment = segment):$add_4(segments.innerSegments, segment);
  }
  return segments;
}

function $getExternalPortPosition(this$static, pos, ps){
  switch (ps.ordinal) {
    case 1:
      return new KVector_1(pos.x_0, $wnd.Math.min(this$static.graphTopLeft.y_0, pos.y_0));
    case 2:
      return new KVector_1($wnd.Math.max(this$static.graphBottomRight.x_0, pos.x_0), pos.y_0);
    case 3:
      return new KVector_1(pos.x_0, $wnd.Math.max(this$static.graphBottomRight.y_0, pos.y_0));
    case 4:
      return new KVector_1($wnd.Math.min(pos.x_0, this$static.graphTopLeft.x_0), pos.y_0);
  }
  return new KVector_1(pos.x_0, pos.y_0);
}

function $getPortPositionOnMargin(port){
  var margins, pos;
  pos = $clone_0(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor])));
  margins = port.owner.margin;
  switch (port.side.ordinal) {
    case 1:
      pos.y_0 -= margins.top_0;
      break;
    case 2:
      pos.x_0 += margins.right;
      break;
    case 3:
      pos.y_0 += margins.bottom;
      break;
    case 4:
      pos.x_0 -= margins.left;
  }
  return pos;
}

function $portSideToDirection(side){
  switch (side.ordinal) {
    case 1:
      return $clinit_Direction_0() , UP_1;
    case 4:
      return $clinit_Direction_0() , LEFT_5;
    case 2:
      return $clinit_Direction_0() , RIGHT_5;
    case 3:
      return $clinit_Direction_0() , DOWN_1;
  }
  return $clinit_Direction_0() , UNDEFINED_3;
}

function $segmentToRectangle(p1, p2, extent){
  return new ElkRectangle_0($wnd.Math.min(p1.x_0, p2.x_0) - extent / 2, $wnd.Math.min(p1.y_0, p2.y_0) - extent / 2, $wnd.Math.abs(p1.x_0 - p2.x_0) + extent, $wnd.Math.abs(p1.y_0 - p2.y_0) + extent);
}

function $transformLEdge(this$static, externalEdge, hullPoints, outerSegments){
  var extent, externalExtension, margins, outerSegmentRect, rect, segment, segment$iterator, segments, side, thickness;
  externalExtension = new ComponentsCompactor$InternalExternalExtension(externalEdge);
  segments = $edgeToSegments(this$static, externalEdge, externalExtension);
  thickness = $wnd.Math.max(checkNotNull_1(castToDouble($getProperty(externalEdge, ($clinit_LayeredOptions() , EDGE_THICKNESS_0)))), 1);
  for (segment$iterator = new ArrayList$1(segments.innerSegments); segment$iterator.i < segment$iterator.this$01.array.length;) {
    segment = castTo($next_10(segment$iterator), 37);
    rect = $segmentToRectangle(castTo(segment.first, 8), castTo(segment.second, 8), thickness);
    returnVal = true;
    returnVal = returnVal & $add_14(hullPoints, new KVector_1(rect.x_0, rect.y_0));
    returnVal = returnVal & $add_14(hullPoints, $add_18(new KVector_1(rect.x_0, rect.y_0), rect.width_0, 0));
    returnVal = returnVal & $add_14(hullPoints, $add_18(new KVector_1(rect.x_0, rect.y_0), 0, rect.height));
    returnVal & $add_14(hullPoints, $add_18(new KVector_1(rect.x_0, rect.y_0), rect.width_0, rect.height));
  }
  side = externalExtension.externalPortSide;
  outerSegmentRect = $segmentToRectangle(castTo(segments.outerSegment.first, 8), castTo(segments.outerSegment.second, 8), thickness);
  if (side == ($clinit_PortSide() , WEST_1) || side == EAST_1) {
    outerSegments.min_0[side.ordinal] = $wnd.Math.min(outerSegments.min_0[side.ordinal], outerSegmentRect.y_0);
    outerSegments.max_0[side.ordinal] = $wnd.Math.max(outerSegments.max_0[side.ordinal], outerSegmentRect.y_0 + outerSegmentRect.height);
  }
   else {
    outerSegments.min_0[side.ordinal] = $wnd.Math.min(outerSegments.min_0[side.ordinal], outerSegmentRect.x_0);
    outerSegments.max_0[side.ordinal] = $wnd.Math.max(outerSegments.max_0[side.ordinal], outerSegmentRect.x_0 + outerSegmentRect.width_0);
  }
  extent = $intern_63;
  margins = externalExtension.externalPort.owner.margin;
  switch (side.ordinal) {
    case 4:
      extent = margins.right;
      break;
    case 2:
      extent = margins.left;
      break;
    case 1:
      extent = margins.bottom;
      break;
    case 3:
      extent = margins.top_0;
  }
  outerSegments.extent[side.ordinal] = $wnd.Math.max(outerSegments.extent[side.ordinal], extent);
  return externalExtension;
}

function $transformLGraph(this$static, graph){
  var component, edge, edge$iterator, extension, extensions, extent, externalExtensions, hullPoints, iee, iuee, max_0, min_0, node, node$iterator, outerSegments, placeholder, ps, ps$iterator;
  component = new ComponentsCompactor$InternalComponent(graph);
  component.containsRegularNodes || $createDummyNode(graph);
  hullPoints = $componentHullPoints(graph);
  externalExtensions = new HashMultimap;
  outerSegments = new ComponentsCompactor$OuterSegments;
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 16);
      if (edge.source.owner.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) || edge.target.owner.type_0 == EXTERNAL_PORT) {
        iee = $transformLEdge(this$static, edge, hullPoints, outerSegments);
        $put(externalExtensions, $portSideToDirection(iee.externalPortSide), iee.edge);
      }
    }
  }
  extensions = new ArrayList;
  for (ps$iterator = castTo($getProperty(component.graph_0, ($clinit_InternalProperties_1() , EXT_PORT_CONNECTIONS)), 19).iterator_0(); ps$iterator.hasNext_0();) {
    ps = castTo(ps$iterator.next_1(), 71);
    min_0 = outerSegments.min_0[ps.ordinal];
    max_0 = outerSegments.max_0[ps.ordinal];
    extent = outerSegments.extent[ps.ordinal];
    extension = null;
    placeholder = null;
    switch (ps.ordinal) {
      case 4:
        extension = new ElkRectangle_0(this$static.graphTopLeft.x_0, min_0, hullPoints.topLeft.x_0 - this$static.graphTopLeft.x_0, max_0 - min_0);
        placeholder = new ElkRectangle_0(this$static.graphTopLeft.x_0, min_0, extent, max_0 - min_0);
        $add_14(hullPoints, new KVector_1(extension.x_0 + extension.width_0, extension.y_0));
        $add_14(hullPoints, new KVector_1(extension.x_0 + extension.width_0, extension.y_0 + extension.height));
        break;
      case 2:
        extension = new ElkRectangle_0(hullPoints.bottomRight.x_0, min_0, this$static.graphBottomRight.x_0 - hullPoints.bottomRight.x_0, max_0 - min_0);
        placeholder = new ElkRectangle_0(this$static.graphBottomRight.x_0 - extent, min_0, extent, max_0 - min_0);
        $add_14(hullPoints, new KVector_1(extension.x_0, extension.y_0));
        $add_14(hullPoints, new KVector_1(extension.x_0, extension.y_0 + extension.height));
        break;
      case 1:
        extension = new ElkRectangle_0(min_0, this$static.graphTopLeft.y_0, max_0 - min_0, hullPoints.topLeft.y_0 - this$static.graphTopLeft.y_0);
        placeholder = new ElkRectangle_0(min_0, this$static.graphTopLeft.y_0, max_0 - min_0, extent);
        $add_14(hullPoints, new KVector_1(extension.x_0, extension.y_0 + extension.height));
        $add_14(hullPoints, new KVector_1(extension.x_0 + extension.width_0, extension.y_0 + extension.height));
        break;
      case 3:
        extension = new ElkRectangle_0(min_0, hullPoints.bottomRight.y_0, max_0 - min_0, this$static.graphBottomRight.y_0 - hullPoints.bottomRight.y_0);
        placeholder = new ElkRectangle_0(min_0, this$static.graphBottomRight.y_0 - extent, max_0 - min_0, extent);
        $add_14(hullPoints, new KVector_1(extension.x_0, extension.y_0));
        $add_14(hullPoints, new KVector_1(extension.x_0 + extension.width_0, extension.y_0));
    }
    if (extension) {
      iuee = new ComponentsCompactor$InternalUnionExternalExtension;
      iuee.side = ps;
      iuee.extension = extension;
      iuee.placeholder = placeholder;
      iuee.edges = newHashSet(castTo($get_0(externalExtensions, $portSideToDirection(ps)), 19));
      extensions.array[extensions.array.length] = iuee;
    }
  }
  $addAll_2(component.externalExtensions, extensions);
  component.rectilinearConvexHull = $splitIntoRectangles(of_4(hullPoints));
  return component;
}

function ComponentsCompactor(){
}

defineClass(730, 1, {}, ComponentsCompactor);
var Lorg_eclipse_elk_alg_layered_components_ComponentsCompactor_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsCompactor', 730);
function $add_13(this$static, e){
  this$static.topLeft.x_0 = $wnd.Math.min(this$static.topLeft.x_0, e.x_0);
  this$static.topLeft.y_0 = $wnd.Math.min(this$static.topLeft.y_0, e.y_0);
  this$static.bottomRight.x_0 = $wnd.Math.max(this$static.bottomRight.x_0, e.x_0);
  this$static.bottomRight.y_0 = $wnd.Math.max(this$static.bottomRight.y_0, e.y_0);
  return this$static.array[this$static.array.length] = e , true;
}

function $add_14(this$static, e){
  return $add_13(this$static, new Point(e.x_0, e.y_0));
}

function ComponentsCompactor$Hullpoints(){
  $$init_2(this);
  this.topLeft = new KVector_1($intern_62, $intern_62);
  this.bottomRight = new KVector_1($intern_63, $intern_63);
}

defineClass(1346, 12, $intern_74, ComponentsCompactor$Hullpoints);
_.add_1 = function add_43(e){
  return $add_13(this, castTo(e, 105));
}
;
var Lorg_eclipse_elk_alg_layered_components_ComponentsCompactor$Hullpoints_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsCompactor/Hullpoints', 1346);
function $getExternalEdges(this$static){
  var edges, ee, ee$iterator;
  edges = new ArrayList;
  for (ee$iterator = new ArrayList$1(this$static.externalExtensions); ee$iterator.i < ee$iterator.this$01.array.length;) {
    ee = castTo($next_10(ee$iterator), 561);
    $addAll_2(edges, castTo(ee.getRepresentative(), 13));
  }
  return edges;
}

function ComponentsCompactor$InternalComponent(graph){
  var n, n$iterator;
  this.externalExtensions = new ArrayList;
  this.graph_0 = graph;
  this.containsRegularNodes = false;
  for (n$iterator = new ArrayList$1(graph.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 9);
    this.containsRegularNodes = this.containsRegularNodes | n.type_0 == ($clinit_LNode$NodeType() , NORMAL);
  }
}

defineClass(1343, 1, {775:1}, ComponentsCompactor$InternalComponent);
_.containsRegularNodes = false;
var Lorg_eclipse_elk_alg_layered_components_ComponentsCompactor$InternalComponent_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsCompactor/InternalComponent', 1343);
function ComponentsCompactor$InternalConnectedComponents(){
  this.components = new ArrayList;
}

defineClass(1342, 1, $intern_27, ComponentsCompactor$InternalConnectedComponents);
_.forEach_0 = function forEach_19(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_59(){
  return new ArrayList$1(this.components);
}
;
var Lorg_eclipse_elk_alg_layered_components_ComponentsCompactor$InternalConnectedComponents_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsCompactor/InternalConnectedComponents', 1342);
function ComponentsCompactor$InternalExternalExtension(edge){
  this.edge = edge;
  if (edge.source.owner.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    this.externalPort = edge.source;
    this.externalPortSide = castTo($getProperty(edge.source.owner, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
  }
   else if (edge.target.owner.type_0 == EXTERNAL_PORT) {
    this.externalPort = edge.target;
    this.externalPortSide = castTo($getProperty(edge.target.owner, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
  }
   else {
    throw toJs(new IllegalArgumentException_0('Edge ' + edge + ' is not an external edge.'));
  }
}

defineClass(1345, 1, {561:1}, ComponentsCompactor$InternalExternalExtension);
_.getPlaceholder = function getPlaceholder(){
  return null;
}
;
_.getRepresentative = function getRepresentative(){
  return this.edge;
}
;
_.getDirection = function getDirection(){
  return $portSideToDirection(this.externalPortSide);
}
;
_.getRepresentor = function getRepresentor(){
  return this.externalExtension;
}
;
var Lorg_eclipse_elk_alg_layered_components_ComponentsCompactor$InternalExternalExtension_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsCompactor/InternalExternalExtension', 1345);
function ComponentsCompactor$InternalUnionExternalExtension(){
  this.edges = new HashSet;
}

defineClass(1344, 1, {561:1}, ComponentsCompactor$InternalUnionExternalExtension);
_.getRepresentative = function getRepresentative_0(){
  return this.edges;
}
;
_.getDirection = function getDirection_0(){
  return $portSideToDirection(this.side);
}
;
_.getPlaceholder = function getPlaceholder_0(){
  return this.placeholder;
}
;
_.getRepresentor = function getRepresentor_0(){
  return this.extension;
}
;
var Lorg_eclipse_elk_alg_layered_components_ComponentsCompactor$InternalUnionExternalExtension_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsCompactor/InternalUnionExternalExtension', 1344);
function ComponentsCompactor$OuterSegments(){
  this.min_0 = initUnidimensionalArray(D_classLit, $intern_69, 23, ($clinit_PortSide() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [UNDEFINED_7, NORTH_1, EAST_1, SOUTH_1, WEST_1])).length, 15, 1);
  this.max_0 = initUnidimensionalArray(D_classLit, $intern_69, 23, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [UNDEFINED_7, NORTH_1, EAST_1, SOUTH_1, WEST_1]).length, 15, 1);
  this.extent = initUnidimensionalArray(D_classLit, $intern_69, 23, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [UNDEFINED_7, NORTH_1, EAST_1, SOUTH_1, WEST_1]).length, 15, 1);
  fill_1(this.min_0, $intern_62);
  fill_1(this.max_0, $intern_63);
  fill_1(this.extent, $intern_63);
}

defineClass(1348, 1, {}, ComponentsCompactor$OuterSegments);
var Lorg_eclipse_elk_alg_layered_components_ComponentsCompactor$OuterSegments_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsCompactor/OuterSegments', 1348);
function ComponentsCompactor$Segments(){
  this.innerSegments = new ArrayList;
}

defineClass(1347, 1, {}, ComponentsCompactor$Segments);
var Lorg_eclipse_elk_alg_layered_components_ComponentsCompactor$Segments_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsCompactor/Segments', 1347);
function $combine(this$static, components, target){
  this$static.graphPlacer.combine(components, target);
}

function $dfs_1(this$static, node, data_0){
  var all, component, extPortSides, mutableData, port1, port1$iterator, port2, port2$iterator;
  if (node.id_0 == 0) {
    node.id_0 = 1;
    mutableData = data_0;
    if (!data_0) {
      component = new ArrayList;
      extPortSides = (all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_PortSide_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
      mutableData = new Pair(component, extPortSides);
    }
    castTo(mutableData.first, 15).add_1(node);
    node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) && castTo(mutableData.second, 19).add_1(castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71));
    for (port1$iterator = new ArrayList$1(node.ports); port1$iterator.i < port1$iterator.this$01.array.length;) {
      port1 = castTo($next_10(port1$iterator), 11);
      for (port2$iterator = $iterator(concat_1(new LPort$7(port1), new LPort$8(port1))); $hasNext_0(port2$iterator);) {
        port2 = castTo($next_2(port2$iterator), 11);
        $dfs_1(this$static, port2.owner, mutableData);
      }
    }
    return mutableData;
  }
  return null;
}

function $split_2(this$static, graph){
  var compatiblePortConstraints, componentData, extPortConstraints, extPorts, n, n$iterator, newGraph, node, node$iterator, node$iterator0, result, separate, separateProperty;
  this$static.graphPlacer = this$static.simpleRowGraphPlacer;
  separateProperty = castToBoolean($getProperty(graph, ($clinit_LayeredOptions() , SEPARATE_CONNECTED_COMPONENTS_0)));
  separate = separateProperty == null || (checkCriticalNotNull(separateProperty) , separateProperty);
  extPorts = castTo($getProperty(graph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS));
  extPortConstraints = castTo($getProperty(graph, PORT_CONSTRAINTS_0), 83);
  compatiblePortConstraints = !(extPortConstraints == ($clinit_PortConstraints() , FIXED_ORDER) || extPortConstraints == FIXED_RATIO || extPortConstraints == FIXED_POS);
  if (separate && (compatiblePortConstraints || !extPorts)) {
    for (node$iterator0 = new ArrayList$1(graph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      node.id_0 = 0;
    }
    result = new ArrayList;
    for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      componentData = $dfs_1(this$static, node, null);
      if (componentData) {
        newGraph = new LGraph;
        $copyProperties(newGraph, graph);
        $setProperty_0(newGraph, EXT_PORT_CONNECTIONS, castTo(componentData.second, 19));
        $copy(newGraph.padding, graph.padding);
        $setProperty_0(newGraph, NODE_SIZE_MINIMUM, null);
        for (n$iterator = castTo(componentData.first, 15).iterator_0(); n$iterator.hasNext_0();) {
          n = castTo(n$iterator.next_1(), 9);
          $add_4(newGraph.layerlessNodes, n);
          n.graph_0 = newGraph;
        }
        result.add_1(newGraph);
      }
    }
    extPorts && (this$static.graphPlacer = this$static.componentGroupGraphPlacer);
  }
   else {
    result = new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_graph_LGraph_2_classLit, 1), $intern_106, 32, 0, [graph]));
  }
  return result;
}

function ComponentsProcessor_0(){
  this.componentGroupGraphPlacer = new ComponentGroupGraphPlacer;
  this.simpleRowGraphPlacer = new SimpleRowGraphPlacer;
}

defineClass(1151, 1, {}, ComponentsProcessor_0);
var Lorg_eclipse_elk_alg_layered_components_ComponentsProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'ComponentsProcessor', 1151);
function SimpleRowGraphPlacer(){
}

defineClass(1175, 1780, {}, SimpleRowGraphPlacer);
_.combine = function combine_0(components, target){
  var broadestRow, compactor, componentSpacing, firstComponent, graph, graph$iterator, graph$iterator0, graph$iterator1, h, h$iterator, highestBox, maxRowWidth, node, node$iterator, offset, priority, size_0, source, totalArea, xpos, ypos;
  if (components.size_1() == 1) {
    source = castTo(components.get_3(0), 32);
    if (source != target) {
      target.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      $moveGraph_0(target, source, 0, 0);
      $copyProperties(target, source);
      $copy(target.padding, source.padding);
      target.size_0.x_0 = source.size_0.x_0;
      target.size_0.y_0 = source.size_0.y_0;
    }
    return;
  }
   else if (components.isEmpty()) {
    target.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    target.size_0.x_0 = 0;
    target.size_0.y_0 = 0;
    return;
  }
  for (graph$iterator0 = components.iterator_0(); graph$iterator0.hasNext_0();) {
    graph = castTo(graph$iterator0.next_1(), 32);
    priority = 0;
    for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      priority += castTo($getProperty(node, ($clinit_LayeredOptions() , PRIORITY_0)), 21).value_0;
    }
    graph.id_0 = priority;
  }
  $clinit_Collections();
  components.sort_0(new SimpleRowGraphPlacer$1);
  firstComponent = castTo(components.get_3(0), 32);
  target.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $copyProperties(target, firstComponent);
  maxRowWidth = 0;
  totalArea = 0;
  for (graph$iterator1 = components.iterator_0(); graph$iterator1.hasNext_0();) {
    graph = castTo(graph$iterator1.next_1(), 32);
    size_0 = graph.size_0;
    maxRowWidth = $wnd.Math.max(maxRowWidth, size_0.x_0);
    totalArea += size_0.x_0 * size_0.y_0;
  }
  maxRowWidth = $wnd.Math.max(maxRowWidth, $wnd.Math.sqrt(totalArea) * checkNotNull_1(castToDouble($getProperty(target, ($clinit_LayeredOptions() , ASPECT_RATIO_1)))));
  componentSpacing = checkNotNull_1(castToDouble($getProperty(target, SPACING_COMPONENT_COMPONENT_0)));
  xpos = 0;
  ypos = 0;
  highestBox = 0;
  broadestRow = componentSpacing;
  for (graph$iterator = components.iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 32);
    size_0 = graph.size_0;
    if (xpos + size_0.x_0 > maxRowWidth) {
      xpos = 0;
      ypos += highestBox + componentSpacing;
      highestBox = 0;
    }
    offset = graph.offset;
    $offsetGraph(graph, xpos + offset.x_0, ypos + offset.y_0);
    $reset_5(offset);
    broadestRow = $wnd.Math.max(broadestRow, xpos + size_0.x_0);
    highestBox = $wnd.Math.max(highestBox, size_0.y_0);
    xpos += size_0.x_0 + componentSpacing;
  }
  target.size_0.x_0 = broadestRow;
  target.size_0.y_0 = ypos + highestBox;
  if (checkNotNull_1(castToBoolean($getProperty(firstComponent, COMPACTION_CONNECTED_COMPONENTS_0)))) {
    compactor = new ComponentsCompactor;
    $compact_5(compactor, components, componentSpacing);
    for (h$iterator = components.iterator_0(); h$iterator.hasNext_0();) {
      h = castTo(h$iterator.next_1(), 32);
      $add_19($reset_5(h.offset), compactor.yetAnotherOffset);
    }
    $add_19($reset_5(target.size_0), compactor.compactedGraphSize);
  }
  $moveGraphs(target, components);
}
;
var Lorg_eclipse_elk_alg_layered_components_SimpleRowGraphPlacer_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'SimpleRowGraphPlacer', 1175);
function $compare_9(graph1, graph2){
  var prio, size1, size2;
  prio = graph2.id_0 - graph1.id_0;
  if (prio == 0) {
    size1 = graph1.size_0.x_0 * graph1.size_0.y_0;
    size2 = graph2.size_0.x_0 * graph2.size_0.y_0;
    return compare_5(size1, size2);
  }
  return prio;
}

function SimpleRowGraphPlacer$1(){
}

defineClass(1176, 1, $intern_40, SimpleRowGraphPlacer$1);
_.compare_0 = function compare_39(graph1, graph2){
  return $compare_9(castTo(graph1, 32), castTo(graph2, 32));
}
;
_.equals_0 = function equals_93(other){
  return this === other;
}
;
_.reversed = function reversed_31(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_components_SimpleRowGraphPlacer$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.components', 'SimpleRowGraphPlacer/1', 1176);
function $clinit_CompoundGraphPostprocessor(){
  $clinit_CompoundGraphPostprocessor = emptyMethod;
  HAS_JUNCTION_POINTS_PREDICATE = new CompoundGraphPostprocessor$1;
}

function $process_0(graph, monitor){
  var addUnnecessaryBendpoints, bendPoints, chEdge, chEdge$iterator, crossHierarchyEdges, crossHierarchyMap, dummyEdge, dummyEdge$iterator, dummyEdges, junctionPoints, lastPoint, ledge, nextPoint, offset, origEdge, origEdge$iterator, referenceGraph, referenceNode, sourcePoint, sourcePort, targetPoint, targetPort, xDiffEnough, yDiffEnough;
  $begin(monitor, 'Compound graph postprocessor', 1);
  addUnnecessaryBendpoints = checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_LayeredOptions() , UNNECESSARY_BENDPOINTS_0))));
  crossHierarchyMap = castTo($getProperty(graph, ($clinit_InternalProperties_1() , CROSS_HIERARCHY_MAP)), 249);
  dummyEdges = new HashSet;
  for (origEdge$iterator = crossHierarchyMap.keySet_0().iterator_0(); origEdge$iterator.hasNext_0();) {
    origEdge = castTo(origEdge$iterator.next_1(), 16);
    crossHierarchyEdges = new ArrayList_1(crossHierarchyMap.get_1(origEdge));
    $clinit_Collections();
    $sort(crossHierarchyEdges, new CrossHierarchyEdgeComparator(graph));
    sourcePort = $getActualSource((checkCriticalElementIndex(0, crossHierarchyEdges.array.length) , castTo(crossHierarchyEdges.array[0], 245)));
    targetPort = $getActualTarget(castTo($get_7(crossHierarchyEdges, crossHierarchyEdges.array.length - 1), 245));
    referenceNode = sourcePort.owner;
    isDescendant(targetPort.owner, referenceNode)?(referenceGraph = castTo($getProperty(referenceNode, NESTED_LGRAPH), 32)):(referenceGraph = $getGraph(referenceNode));
    junctionPoints = clearJunctionPoints(origEdge, crossHierarchyEdges);
    $reset_0(origEdge.bendPoints);
    lastPoint = null;
    for (chEdge$iterator = new ArrayList$1(crossHierarchyEdges); chEdge$iterator.i < chEdge$iterator.this$01.array.length;) {
      chEdge = castTo($next_10(chEdge$iterator), 245);
      offset = new KVector;
      changeCoordSystem(offset, chEdge.graph_0, referenceGraph);
      ledge = chEdge.newEdge;
      bendPoints = new KVectorChain;
      $addAllAsCopies(bendPoints, 0, ledge.bendPoints);
      $offset_2(bendPoints, offset);
      sourcePoint = new KVector_2($getAbsoluteAnchor(ledge.source));
      targetPoint = new KVector_2($getAbsoluteAnchor(ledge.target));
      $add_19(sourcePoint, offset);
      $add_19(targetPoint, offset);
      if (lastPoint) {
        bendPoints.size_0 == 0?(nextPoint = targetPoint):(nextPoint = (checkCriticalElement(bendPoints.size_0 != 0) , castTo(bendPoints.header.next_0.value_0, 8)));
        xDiffEnough = $wnd.Math.abs(lastPoint.x_0 - nextPoint.x_0) > $intern_104;
        yDiffEnough = $wnd.Math.abs(lastPoint.y_0 - nextPoint.y_0) > $intern_104;
        (!addUnnecessaryBendpoints && xDiffEnough && yDiffEnough || addUnnecessaryBendpoints && (xDiffEnough || yDiffEnough)) && $add_7(origEdge.bendPoints, sourcePoint);
      }
      $addAll(origEdge.bendPoints, bendPoints);
      bendPoints.size_0 == 0?(lastPoint = sourcePoint):(lastPoint = (checkCriticalElement(bendPoints.size_0 != 0) , castTo(bendPoints.tail.prev.value_0, 8)));
      copyJunctionPoints(ledge, junctionPoints, offset);
      if ($getActualTarget(chEdge) == targetPort) {
        if ($getGraph(targetPort.owner) != chEdge.graph_0) {
          offset = new KVector;
          changeCoordSystem(offset, $getGraph(targetPort.owner), referenceGraph);
        }
        $setProperty_0(origEdge, TARGET_OFFSET, offset);
      }
      copyLabelsBack(ledge, origEdge, referenceGraph);
      dummyEdges.map_0.put(ledge, dummyEdges);
    }
    $setSource_0(origEdge, sourcePort);
    $setTarget_0(origEdge, targetPort);
  }
  for (dummyEdge$iterator = dummyEdges.map_0.keySet_0().iterator_0(); dummyEdge$iterator.hasNext_0();) {
    dummyEdge = castTo(dummyEdge$iterator.next_1(), 16);
    $setSource_0(dummyEdge, null);
    $setTarget_0(dummyEdge, null);
  }
  $done_0(monitor);
}

function clearJunctionPoints(origEdge, crossHierarchyEdges){
  var junctionPoints;
  junctionPoints = castTo($getProperty(origEdge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
  if (any_0(crossHierarchyEdges, HAS_JUNCTION_POINTS_PREDICATE)) {
    if (!junctionPoints) {
      junctionPoints = new KVectorChain;
      $setProperty_0(origEdge, JUNCTION_POINTS, junctionPoints);
    }
     else {
      $reset_0(junctionPoints);
    }
  }
   else 
    !!junctionPoints && $setProperty_0(origEdge, JUNCTION_POINTS, null);
  return junctionPoints;
}

function copyJunctionPoints(source, target, offset){
  var jpCopies, ledgeJPs;
  ledgeJPs = castTo($getProperty(source, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
  if (ledgeJPs) {
    jpCopies = new KVectorChain;
    $addAllAsCopies(jpCopies, 0, ledgeJPs);
    $offset_2(jpCopies, offset);
    $addAll(target, jpCopies);
  }
}

function copyLabelsBack(hierarchySegment, origEdge, referenceGraph){
  var currLabel, labelIterator;
  labelIterator = new AbstractList$ListIteratorImpl(hierarchySegment.labels, 0);
  while (labelIterator.i < labelIterator.this$01_0.size_1()) {
    currLabel = (checkCriticalElement(labelIterator.i < labelIterator.this$01_0.size_1()) , castTo(labelIterator.this$01_0.get_3(labelIterator.last = labelIterator.i++), 70));
    if (maskUndefined($getProperty(currLabel, ($clinit_InternalProperties_1() , ORIGINAL_LABEL_EDGE))) !== maskUndefined(origEdge)) {
      continue;
    }
    changeCoordSystem(currLabel.pos, $getGraph(hierarchySegment.source.owner), referenceGraph);
    $remove_9(labelIterator);
    $add_4(origEdge.labels, currLabel);
  }
}

var HAS_JUNCTION_POINTS_PREDICATE;
function CompoundGraphPostprocessor$1(){
}

defineClass(1149, 1, $intern_91, CompoundGraphPostprocessor$1);
_.apply_1 = function apply_55(chEdge){
  var jps;
  return jps = castTo($getProperty(castTo(chEdge, 245).newEdge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74) , !!jps && jps.size_0 != 0;
}
;
_.equals_0 = function equals_94(other){
  return this === other;
}
;
_.test_0 = function test_14(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_compound_CompoundGraphPostprocessor$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.compound', 'CompoundGraphPostprocessor/1', 1149);
function $connectChild(this$static, graph, externalPort, origEdge, sourcePort, targetPort){
  var dummyEdge;
  dummyEdge = $createDummyEdge(origEdge);
  $setSource_0(dummyEdge, sourcePort);
  $setTarget_0(dummyEdge, targetPort);
  $put(this$static.crossHierarchyMap, origEdge, new CrossHierarchyEdge(dummyEdge, graph, externalPort.type_0));
}

function $connectSiblings(this$static, graph, externalOutputPort, containedExternalPorts, origEdge){
  var dummyEdge, externalPort2, externalPort2$iterator, targetExternalPort;
  targetExternalPort = null;
  for (externalPort2$iterator = new ArrayList$1(containedExternalPorts); externalPort2$iterator.i < externalPort2$iterator.this$01.array.length;) {
    externalPort2 = castTo($next_10(externalPort2$iterator), 420);
    if (externalPort2 != externalOutputPort && $indexOf_3(externalPort2.origEdges, origEdge, 0) != -1) {
      targetExternalPort = externalPort2;
      break;
    }
  }
  dummyEdge = $createDummyEdge(origEdge);
  $setSource_0(dummyEdge, externalOutputPort.dummyPort);
  $setTarget_0(dummyEdge, targetExternalPort.dummyPort);
  $put(this$static.crossHierarchyMap, origEdge, new CrossHierarchyEdge(dummyEdge, graph, externalOutputPort.type_0));
}

function $createDummyEdge(origEdge){
  var dummyEdge;
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, origEdge);
  $setProperty_0(dummyEdge, ($clinit_LayeredOptions() , JUNCTION_POINTS), null);
  return dummyEdge;
}

function $createExternalPortDummy(this$static, graph, parentNode, portType, portSide, edge){
  var dummyNode, dummyPort, layoutDirection, outsidePort, thickness, propertyHolder, offset;
  outsidePort = portType == ($clinit_PortType() , INPUT)?edge.source:edge.target;
  layoutDirection = getDirection_1(graph);
  if (outsidePort.owner == parentNode) {
    dummyNode = castTo($get_6(this$static.dummyNodeMap, outsidePort), 9);
    if (!dummyNode) {
      dummyNode = createExternalPortDummy(outsidePort, castTo($getProperty(parentNode, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83), portSide, portType == INPUT?-1:1, null, outsidePort.pos, outsidePort.size_0, layoutDirection, graph);
      $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0), outsidePort);
      $put_1(this$static.dummyNodeMap, outsidePort, dummyNode);
    }
  }
   else {
    thickness = checkNotNull_1(castToDouble($getProperty(edge, ($clinit_LayeredOptions() , EDGE_THICKNESS_0))));
    dummyNode = createExternalPortDummy((propertyHolder = new MapPropertyHolder , offset = checkNotNull_1(castToDouble($getProperty(graph, SPACING_EDGE_EDGE))) / 2 , $setProperty(propertyHolder, PORT_BORDER_OFFSET, offset) , propertyHolder), castTo($getProperty(parentNode, PORT_CONSTRAINTS_0), 83), portSide, portType == INPUT?-1:1, null, new KVector, new KVector_1(thickness, thickness), layoutDirection, graph);
    dummyPort = $createPortForDummy(this$static, dummyNode, parentNode, portType);
    $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0), dummyPort);
    $put_1(this$static.dummyNodeMap, dummyPort, dummyNode);
  }
  castTo($getProperty(graph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).add_1(($clinit_GraphProperties() , EXTERNAL_PORTS));
  $isSideFixed(castTo($getProperty(graph, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))?$setProperty_0(graph, PORT_CONSTRAINTS_0, ($clinit_PortConstraints() , FIXED_SIDE)):$setProperty_0(graph, PORT_CONSTRAINTS_0, ($clinit_PortConstraints() , FREE));
  return dummyNode;
}

function $createPortForDummy(this$static, dummyNode, parentNode, type_0){
  var graph, layoutDirection, port;
  graph = $getGraph(parentNode);
  layoutDirection = getDirection_1(graph);
  port = new LPort;
  $setNode(port, parentNode);
  switch (type_0.ordinal) {
    case 1:
      $setSide(port, $opposed(fromDirection(layoutDirection)));
      break;
    case 2:
      $setSide(port, fromDirection(layoutDirection));
  }
  $setProperty_0(port, ($clinit_LayeredOptions() , PORT_BORDER_OFFSET), castToDouble($getProperty(dummyNode, PORT_BORDER_OFFSET)));
  $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0), port);
  $put_1(this$static.dummyNodeMap, port, dummyNode);
  return port;
}

function $getShallowestEdgeSegment(edgeSegments){
  var crossHierarchyEdge, crossHierarchyEdge$iterator, index_0, result;
  result = -1;
  index_0 = 0;
  for (crossHierarchyEdge$iterator = new ArrayList$1(edgeSegments); crossHierarchyEdge$iterator.i < crossHierarchyEdge$iterator.this$01.array.length;) {
    crossHierarchyEdge = castTo($next_10(crossHierarchyEdge$iterator), 245);
    if (crossHierarchyEdge.type_0 == ($clinit_PortType() , INPUT)) {
      result = index_0 == 0?0:index_0 - 1;
      break;
    }
     else 
      index_0 == edgeSegments.array.length - 1 && (result = index_0);
    index_0 += 1;
  }
  return result;
}

function $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, origEdge, oppositePort, portType, defaultExternalPort){
  var dummyEdge, dummyNode, externalPort, externalPortSide, mergeExternalPorts, parentEndPort, thickness;
  mergeExternalPorts = checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_LayeredOptions() , MERGE_HIERARCHY_EDGES_0))));
  parentEndPort = null;
  portType == ($clinit_PortType() , INPUT) && origEdge.source.owner == parentNode?(parentEndPort = origEdge.source):portType == OUTPUT && origEdge.target.owner == parentNode && (parentEndPort = origEdge.target);
  externalPort = defaultExternalPort;
  if (!defaultExternalPort || !mergeExternalPorts || !!parentEndPort) {
    externalPortSide = ($clinit_PortSide() , UNDEFINED_7);
    parentEndPort?(externalPortSide = parentEndPort.side):$isSideFixed(castTo($getProperty(parentNode, PORT_CONSTRAINTS_0), 83)) && (externalPortSide = portType == INPUT?WEST_1:EAST_1);
    dummyNode = $createExternalPortDummy(this$static, graph, parentNode, portType, externalPortSide, origEdge);
    dummyEdge = $createDummyEdge(($getGraph(parentNode) , origEdge));
    if (portType == INPUT) {
      $setSource_0(dummyEdge, castTo($get_7(dummyNode.ports, 0), 11));
      $setTarget_0(dummyEdge, oppositePort);
    }
     else {
      $setSource_0(dummyEdge, oppositePort);
      $setTarget_0(dummyEdge, castTo($get_7(dummyNode.ports, 0), 11));
    }
    externalPort = new CompoundGraphPreprocessor$ExternalPort(origEdge, dummyEdge, dummyNode, castTo($getProperty(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0)), 11), portType, !parentEndPort);
  }
   else {
    $add_4(defaultExternalPort.origEdges, origEdge);
    thickness = $wnd.Math.max(checkNotNull_1(castToDouble($getProperty(defaultExternalPort.newEdge, EDGE_THICKNESS_0))), checkNotNull_1(castToDouble($getProperty(origEdge, EDGE_THICKNESS_0))));
    $setProperty_0(defaultExternalPort.newEdge, EDGE_THICKNESS_0, thickness);
  }
  $put(this$static.crossHierarchyMap, origEdge, new CrossHierarchyEdge(externalPort.newEdge, graph, portType));
  return externalPort;
}

function $moveLabelsAndRemoveOriginalEdges(this$static, graph){
  var currLabel, edgeSegments, labelIterator, origEdge, origEdge$iterator, targetDummyEdgeIndex, targetSegment;
  for (origEdge$iterator = $keySet_0(this$static.crossHierarchyMap).iterator_0(); origEdge$iterator.hasNext_0();) {
    origEdge = castTo(origEdge$iterator.next_1(), 16);
    if (origEdge.labels.array.length > 0) {
      edgeSegments = new ArrayList_1(castTo($get_0(this$static.crossHierarchyMap, origEdge), 19));
      $clinit_Collections();
      $sort(edgeSegments, new CrossHierarchyEdgeComparator(graph));
      labelIterator = new AbstractList$ListIteratorImpl(origEdge.labels, 0);
      while (labelIterator.i < labelIterator.this$01_0.size_1()) {
        currLabel = (checkCriticalElement(labelIterator.i < labelIterator.this$01_0.size_1()) , castTo(labelIterator.this$01_0.get_3(labelIterator.last = labelIterator.i++), 70));
        targetDummyEdgeIndex = -1;
        switch (castTo($getProperty(currLabel, ($clinit_LayeredOptions() , EDGE_LABELS_PLACEMENT)), 236).ordinal) {
          case 2:
            targetDummyEdgeIndex = edgeSegments.array.length - 1;
            break;
          case 1:
            targetDummyEdgeIndex = $getShallowestEdgeSegment(edgeSegments);
            break;
          case 3:
            targetDummyEdgeIndex = 0;
        }
        if (targetDummyEdgeIndex != -1) {
          targetSegment = (checkCriticalElementIndex(targetDummyEdgeIndex, edgeSegments.array.length) , castTo(edgeSegments.array[targetDummyEdgeIndex], 245));
          $add_4(targetSegment.newEdge.labels, currLabel);
          castTo($getProperty($getGraph(targetSegment.newEdge.source.owner), ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).add_1(($clinit_GraphProperties() , END_LABELS));
          castTo($getProperty($getGraph(targetSegment.newEdge.source.owner), GRAPH_PROPERTIES), 19).add_1(CENTER_LABELS);
          $remove_9(labelIterator);
          $setProperty_0(currLabel, ORIGINAL_LABEL_EDGE, origEdge);
        }
      }
    }
    $setSource_0(origEdge, null);
    $setTarget_0(origEdge, null);
  }
}

function $process_1(this$static, graph, monitor){
  $begin(monitor, 'Compound graph preprocessor', 1);
  this$static.crossHierarchyMap = new HashMultimap;
  $transformHierarchyEdges(this$static, graph, null);
  $moveLabelsAndRemoveOriginalEdges(this$static, graph);
  $setSidesOfPortsToSidesOfDummyNodes(this$static);
  $setProperty_0(graph, ($clinit_InternalProperties_1() , CROSS_HIERARCHY_MAP), this$static.crossHierarchyMap);
  this$static.crossHierarchyMap = null;
  $reset(this$static.dummyNodeMap);
  $done_0(monitor);
}

function $processInnerHierarchicalEdgeSegments(this$static, graph, parentNode, containedExternalPorts, exportedExternalPorts){
  var createdExternalPorts, currentExternalPort, externalPort, externalPort$iterator, externalPort$iterator0, inEdge, inEdge$iterator, newExternalPort, outEdge, outEdge$iterator, sourceNode, targetNode;
  createdExternalPorts = new ArrayList;
  for (externalPort$iterator0 = new ArrayList$1(containedExternalPorts); externalPort$iterator0.i < externalPort$iterator0.this$01.array.length;) {
    externalPort = castTo($next_10(externalPort$iterator0), 420);
    currentExternalPort = null;
    if (externalPort.type_0 == ($clinit_PortType() , OUTPUT)) {
      for (outEdge$iterator = new ArrayList$1(externalPort.origEdges); outEdge$iterator.i < outEdge$iterator.this$01.array.length;) {
        outEdge = castTo($next_10(outEdge$iterator), 16);
        targetNode = outEdge.target.owner;
        if ($getGraph(targetNode) == graph) {
          $connectChild(this$static, graph, externalPort, outEdge, externalPort.dummyPort, outEdge.target);
        }
         else if (!parentNode || isDescendant(targetNode, parentNode)) {
          $connectSiblings(this$static, graph, externalPort, containedExternalPorts, outEdge);
        }
         else {
          newExternalPort = $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, outEdge, externalPort.dummyPort, OUTPUT, currentExternalPort);
          newExternalPort != currentExternalPort && (createdExternalPorts.array[createdExternalPorts.array.length] = newExternalPort , true);
          newExternalPort.exported && (currentExternalPort = newExternalPort);
        }
      }
    }
     else {
      for (inEdge$iterator = new ArrayList$1(externalPort.origEdges); inEdge$iterator.i < inEdge$iterator.this$01.array.length;) {
        inEdge = castTo($next_10(inEdge$iterator), 16);
        sourceNode = inEdge.source.owner;
        if ($getGraph(sourceNode) == graph) {
          $connectChild(this$static, graph, externalPort, inEdge, inEdge.source, externalPort.dummyPort);
        }
         else if (!parentNode || isDescendant(sourceNode, parentNode)) {
          continue;
        }
         else {
          newExternalPort = $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, inEdge, externalPort.dummyPort, INPUT, currentExternalPort);
          newExternalPort != currentExternalPort && (createdExternalPorts.array[createdExternalPorts.array.length] = newExternalPort , true);
          newExternalPort.exported && (currentExternalPort = newExternalPort);
        }
      }
    }
  }
  for (externalPort$iterator = new ArrayList$1(createdExternalPorts); externalPort$iterator.i < externalPort$iterator.this$01.array.length;) {
    externalPort = castTo($next_10(externalPort$iterator), 420);
    $indexOf_3(graph.layerlessNodes, externalPort.dummyNode, 0) != -1 || $add_4(graph.layerlessNodes, externalPort.dummyNode);
    externalPort.exported && (exportedExternalPorts.array[exportedExternalPorts.array.length] = externalPort , true);
  }
}

function $processInsideSelfLoops(this$static, nestedGraph, node){
  var dummyEdge, isInsideSelfLoop, isSelfLoop, lport, lport$iterator, outEdge, outEdge$index, outEdge$max, outEdges, sourceExtPortDummy, sourcePort, targetExtPortDummy, targetPort;
  if (!checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayeredOptions() , INSIDE_SELF_LOOPS_ACTIVATE))))) {
    return;
  }
  for (lport$iterator = new ArrayList$1(node.ports); lport$iterator.i < lport$iterator.this$01.array.length;) {
    lport = castTo($next_10(lport$iterator), 11);
    outEdges = castTo($toArray_2(lport.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, lport.outgoingEdges.array.length, 0, 1)), 101);
    for (outEdge$index = 0 , outEdge$max = outEdges.length; outEdge$index < outEdge$max; ++outEdge$index) {
      outEdge = outEdges[outEdge$index];
      isSelfLoop = outEdge.target.owner == node;
      isInsideSelfLoop = isSelfLoop && checkNotNull_1(castToBoolean($getProperty(outEdge, INSIDE_SELF_LOOPS_YO)));
      if (isInsideSelfLoop) {
        sourcePort = outEdge.source;
        sourceExtPortDummy = castTo($get_6(this$static.dummyNodeMap, sourcePort), 9);
        if (!sourceExtPortDummy) {
          sourceExtPortDummy = createExternalPortDummy(sourcePort, ($clinit_PortConstraints() , FREE), sourcePort.side, -1, null, null, sourcePort.size_0, castTo($getProperty(nestedGraph, DIRECTION), 107), nestedGraph);
          $setProperty_0(sourceExtPortDummy, ($clinit_InternalProperties_1() , ORIGIN_0), sourcePort);
          $put_1(this$static.dummyNodeMap, sourcePort, sourceExtPortDummy);
          $add_4(nestedGraph.layerlessNodes, sourceExtPortDummy);
        }
        targetPort = outEdge.target;
        targetExtPortDummy = castTo($get_6(this$static.dummyNodeMap, targetPort), 9);
        if (!targetExtPortDummy) {
          targetExtPortDummy = createExternalPortDummy(targetPort, ($clinit_PortConstraints() , FREE), targetPort.side, 1, null, null, targetPort.size_0, castTo($getProperty(nestedGraph, DIRECTION), 107), nestedGraph);
          $setProperty_0(targetExtPortDummy, ($clinit_InternalProperties_1() , ORIGIN_0), targetPort);
          $put_1(this$static.dummyNodeMap, targetPort, targetExtPortDummy);
          $add_4(nestedGraph.layerlessNodes, targetExtPortDummy);
        }
        dummyEdge = $createDummyEdge(outEdge);
        $setSource_0(dummyEdge, castTo($get_7(sourceExtPortDummy.ports, 0), 11));
        $setTarget_0(dummyEdge, castTo($get_7(targetExtPortDummy.ports, 0), 11));
        $put(this$static.crossHierarchyMap, outEdge, new CrossHierarchyEdge(dummyEdge, nestedGraph, ($clinit_PortType() , OUTPUT)));
        castTo($getProperty(nestedGraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).add_1(($clinit_GraphProperties() , EXTERNAL_PORTS));
      }
    }
  }
}

function $processOuterHierarchicalEdgeSegments(this$static, graph, parentNode, exportedExternalPorts){
  var childNode, childNode$iterator, childPort, childPort$iterator, createdExternalPorts, currentExternalInputPort, currentExternalOutputPort, externalPort, externalPort$iterator, inEdge, inEdge$array, inEdge$index, inEdge$max, newExternalPort, outEdge, outEdge$array, outEdge$index, outEdge$max;
  createdExternalPorts = new ArrayList;
  for (childNode$iterator = new ArrayList$1(graph.layerlessNodes); childNode$iterator.i < childNode$iterator.this$01.array.length;) {
    childNode = castTo($next_10(childNode$iterator), 9);
    for (childPort$iterator = new ArrayList$1(childNode.ports); childPort$iterator.i < childPort$iterator.this$01.array.length;) {
      childPort = castTo($next_10(childPort$iterator), 11);
      currentExternalOutputPort = null;
      for (outEdge$array = castTo($toArray_2(childPort.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, 0, 0, 1)), 101) , outEdge$index = 0 , outEdge$max = outEdge$array.length; outEdge$index < outEdge$max; ++outEdge$index) {
        outEdge = outEdge$array[outEdge$index];
        if (!isDescendant(outEdge.target.owner, parentNode)) {
          newExternalPort = $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, outEdge, outEdge.source, ($clinit_PortType() , OUTPUT), currentExternalOutputPort);
          newExternalPort != currentExternalOutputPort && (createdExternalPorts.array[createdExternalPorts.array.length] = newExternalPort , true);
          newExternalPort.exported && (currentExternalOutputPort = newExternalPort);
        }
      }
      currentExternalInputPort = null;
      for (inEdge$array = castTo($toArray_2(childPort.incomingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, 0, 0, 1)), 101) , inEdge$index = 0 , inEdge$max = inEdge$array.length; inEdge$index < inEdge$max; ++inEdge$index) {
        inEdge = inEdge$array[inEdge$index];
        if (!isDescendant(inEdge.source.owner, parentNode)) {
          newExternalPort = $introduceHierarchicalEdgeSegment(this$static, graph, parentNode, inEdge, inEdge.target, ($clinit_PortType() , INPUT), currentExternalInputPort);
          newExternalPort != currentExternalInputPort && (createdExternalPorts.array[createdExternalPorts.array.length] = newExternalPort , true);
          newExternalPort.exported && (currentExternalInputPort = newExternalPort);
        }
      }
    }
  }
  for (externalPort$iterator = new ArrayList$1(createdExternalPorts); externalPort$iterator.i < externalPort$iterator.this$01.array.length;) {
    externalPort = castTo($next_10(externalPort$iterator), 420);
    $indexOf_3(graph.layerlessNodes, externalPort.dummyNode, 0) != -1 || $add_4(graph.layerlessNodes, externalPort.dummyNode);
    externalPort.exported && (exportedExternalPorts.array[exportedExternalPorts.array.length] = externalPort , true);
  }
}

function $setSidesOfPortsToSidesOfDummyNodes(this$static){
  var dummyNode, e, e$iterator, externalPort;
  for (e$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.dummyNodeMap)).this$01); e$iterator.hasNext;) {
    e = $next_7(e$iterator);
    externalPort = castTo(e.getKey(), 11);
    dummyNode = castTo(e.getValue(), 9);
    $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0), externalPort);
    $setProperty_0(externalPort, PORT_DUMMY, dummyNode);
    $setProperty_0(externalPort, INSIDE_CONNECTIONS, ($clinit_Boolean() , $clinit_Boolean() , true));
    $setSide(externalPort, castTo($getProperty(dummyNode, EXT_PORT_SIDE), 71));
    $getProperty(dummyNode, EXT_PORT_SIDE);
    $setProperty_0(externalPort.owner, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_SIDE));
    castTo($getProperty($getGraph(externalPort.owner), GRAPH_PROPERTIES), 19).add_1(($clinit_GraphProperties() , NON_FREE_PORTS));
  }
}

function $transformHierarchyEdges(this$static, graph, parentNode){
  var childPorts, containedExternalPorts, dummyNode, dummyNodePort, dummyPortLabel, exportedExternalPorts, extPortLabel, extPortLabel$iterator, insidePortLabels, nestedGraph, node, node$iterator, port, port$iterator, portConstraints;
  containedExternalPorts = new ArrayList;
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    nestedGraph = castTo($getProperty(node, ($clinit_InternalProperties_1() , NESTED_LGRAPH)), 32);
    if (nestedGraph) {
      childPorts = $transformHierarchyEdges(this$static, nestedGraph, node);
      $addAll_2(containedExternalPorts, childPorts);
      $processInsideSelfLoops(this$static, nestedGraph, node);
      if (castTo($getProperty(nestedGraph, GRAPH_PROPERTIES), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
        portConstraints = castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
        insidePortLabels = maskUndefined($getProperty(node, PORT_LABELS_PLACEMENT)) === maskUndefined(($clinit_PortLabelPlacement() , INSIDE_0));
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_10(port$iterator), 11);
          dummyNode = castTo($get_6(this$static.dummyNodeMap, port), 9);
          if (!dummyNode) {
            dummyNode = createExternalPortDummy(port, portConstraints, port.side, -(port.incomingEdges.array.length - port.outgoingEdges.array.length), null, null, port.size_0, castTo($getProperty(nestedGraph, DIRECTION), 107), nestedGraph);
            $setProperty_0(dummyNode, ORIGIN_0, port);
            $put_1(this$static.dummyNodeMap, port, dummyNode);
            $add_4(nestedGraph.layerlessNodes, dummyNode);
          }
          dummyNodePort = castTo($get_7(dummyNode.ports, 0), 11);
          for (extPortLabel$iterator = new ArrayList$1(port.labels); extPortLabel$iterator.i < extPortLabel$iterator.this$01.array.length;) {
            extPortLabel = castTo($next_10(extPortLabel$iterator), 70);
            dummyPortLabel = new LLabel;
            dummyPortLabel.size_0.x_0 = extPortLabel.size_0.x_0;
            dummyPortLabel.size_0.y_0 = extPortLabel.size_0.y_0;
            $add_4(dummyNodePort.labels, dummyPortLabel);
            if (!insidePortLabels) {
              switch (port.side.ordinal) {
                case 2:
                case 4:
                  dummyPortLabel.size_0.x_0 = 0;
                  dummyPortLabel.size_0.y_0 = extPortLabel.size_0.y_0;
                  break;
                case 1:
                case 3:
                  dummyPortLabel.size_0.x_0 = extPortLabel.size_0.x_0;
                  dummyPortLabel.size_0.y_0 = 0;
              }
            }
          }
        }
      }
    }
  }
  exportedExternalPorts = new ArrayList;
  $processInnerHierarchicalEdgeSegments(this$static, graph, parentNode, containedExternalPorts, exportedExternalPorts);
  !!parentNode && $processOuterHierarchicalEdgeSegments(this$static, graph, parentNode, exportedExternalPorts);
  return exportedExternalPorts;
}

function CompoundGraphPreprocessor(){
  this.dummyNodeMap = ($clinit_Maps() , new HashMap);
}

defineClass(1148, 1, $intern_108, CompoundGraphPreprocessor);
_.process = function process_0(graph, monitor){
  $process_1(this, castTo(graph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_compound_CompoundGraphPreprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.compound', 'CompoundGraphPreprocessor', 1148);
function CompoundGraphPreprocessor$ExternalPort(origEdge, newEdge, dummyNode, dummyPort, portType, exported){
  this.origEdges = new ArrayList;
  this.type_0 = ($clinit_PortType() , UNDEFINED_0);
  $add_4(this.origEdges, origEdge);
  this.newEdge = newEdge;
  this.dummyNode = dummyNode;
  this.dummyPort = dummyPort;
  this.type_0 = portType;
  this.exported = exported;
}

defineClass(420, 1, {420:1}, CompoundGraphPreprocessor$ExternalPort);
_.exported = false;
var Lorg_eclipse_elk_alg_layered_compound_CompoundGraphPreprocessor$ExternalPort_2_classLit = createForClass('org.eclipse.elk.alg.layered.compound', 'CompoundGraphPreprocessor/ExternalPort', 420);
function $getActualSource(this$static){
  if (this$static.newEdge.source.owner.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return castTo($getProperty(this$static.newEdge.source.owner, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
  }
  return this$static.newEdge.source;
}

function $getActualTarget(this$static){
  if (this$static.newEdge.target.owner.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return castTo($getProperty(this$static.newEdge.target.owner, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
  }
  return this$static.newEdge.target;
}

function CrossHierarchyEdge(newEdge, graph, type_0){
  this.newEdge = newEdge;
  this.graph_0 = graph;
  this.type_0 = type_0;
}

defineClass(245, 1, {245:1}, CrossHierarchyEdge);
_.toString_0 = function toString_84(){
  return $toString_2(this.type_0) + ':' + $toString_8(this.newEdge);
}
;
var Lorg_eclipse_elk_alg_layered_compound_CrossHierarchyEdge_2_classLit = createForClass('org.eclipse.elk.alg.layered.compound', 'CrossHierarchyEdge', 245);
function $compare_10(this$static, edge1, edge2){
  var level1, level2;
  if (edge1.type_0 == ($clinit_PortType() , OUTPUT) && edge2.type_0 == INPUT) {
    return -1;
  }
   else if (edge1.type_0 == INPUT && edge2.type_0 == OUTPUT) {
    return 1;
  }
  level1 = hierarchyLevel(edge1.graph_0, this$static.graph_0);
  level2 = hierarchyLevel(edge2.graph_0, this$static.graph_0);
  return edge1.type_0 == OUTPUT?level2 - level1:level1 - level2;
}

function CrossHierarchyEdgeComparator(graph){
  this.graph_0 = graph;
}

function hierarchyLevel(nestedGraph, topLevelGraph){
  var currentGraph, currentNode, level;
  currentGraph = nestedGraph;
  level = 0;
  do {
    if (currentGraph == topLevelGraph) {
      return level;
    }
    currentNode = castTo($getProperty(currentGraph, ($clinit_InternalProperties_1() , PARENT_LNODE)), 9);
    if (!currentNode) {
      throw toJs(new IllegalArgumentException);
    }
    currentGraph = $getGraph(currentNode);
    ++level;
  }
   while (true);
}

defineClass(709, 1, $intern_40, CrossHierarchyEdgeComparator);
_.compare_0 = function compare_40(edge1, edge2){
  return $compare_10(this, castTo(edge1, 245), castTo(edge2, 245));
}
;
_.equals_0 = function equals_95(other){
  return this === other;
}
;
_.reversed = function reversed_32(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_compound_CrossHierarchyEdgeComparator_2_classLit = createForClass('org.eclipse.elk.alg.layered.compound', 'CrossHierarchyEdgeComparator', 709);
defineClass(288, 130, {3:1, 288:1, 94:1, 130:1});
_.id_0 = 0;
var Lorg_eclipse_elk_alg_layered_graph_LGraphElement_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraphElement', 288);
function $getOther_1(this$static, node){
  if (node == this$static.source.owner) {
    return this$static.target.owner;
  }
   else if (node == this$static.target.owner) {
    return this$static.source.owner;
  }
   else {
    throw toJs(new IllegalArgumentException_0("'node' must either be the source node or target node of the edge."));
  }
}

function $getOther_2(this$static, port){
  if (port == this$static.source) {
    return this$static.target;
  }
   else if (port == this$static.target) {
    return this$static.source;
  }
   else {
    throw toJs(new IllegalArgumentException_0("'port' must be either the source port or target port of the edge."));
  }
}

function $isInLayerEdge(this$static){
  return !$isSelfLoop(this$static) && this$static.source.owner.layer == this$static.target.owner.layer;
}

function $isSelfLoop(this$static){
  if (!this$static.source || !this$static.target) {
    return false;
  }
  return !!this$static.source.owner && this$static.source.owner == this$static.target.owner;
}

function $reverse_0(this$static, adaptPorts){
  var label_0, label$iterator, labelPlacement, oldSource, oldTarget, reversed;
  oldSource = this$static.source;
  oldTarget = this$static.target;
  $setSource_0(this$static, null);
  $setTarget_0(this$static, null);
  adaptPorts && checkNotNull_1(castToBoolean($getProperty(oldTarget, ($clinit_InternalProperties_1() , INPUT_COLLECT))))?$setSource_0(this$static, provideCollectorPort(oldTarget.owner, ($clinit_PortType() , OUTPUT), ($clinit_PortSide() , EAST_1))):$setSource_0(this$static, oldTarget);
  adaptPorts && checkNotNull_1(castToBoolean($getProperty(oldSource, ($clinit_InternalProperties_1() , OUTPUT_COLLECT))))?$setTarget_0(this$static, provideCollectorPort(oldSource.owner, ($clinit_PortType() , INPUT), ($clinit_PortSide() , WEST_1))):$setTarget_0(this$static, oldSource);
  for (label$iterator = new ArrayList$1(this$static.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 70);
    labelPlacement = castTo($getProperty(label_0, ($clinit_LayeredOptions() , EDGE_LABELS_PLACEMENT)), 236);
    labelPlacement == ($clinit_EdgeLabelPlacement() , TAIL)?$setProperty_0(label_0, EDGE_LABELS_PLACEMENT, HEAD):labelPlacement == HEAD && $setProperty_0(label_0, EDGE_LABELS_PLACEMENT, TAIL);
  }
  reversed = checkNotNull_1(castToBoolean($getProperty(this$static, ($clinit_InternalProperties_1() , REVERSED))));
  $setProperty_0(this$static, REVERSED, ($clinit_Boolean() , reversed?false:true));
  this$static.bendPoints = reverse_3(this$static.bendPoints);
}

function $setSource_0(this$static, source){
  !!this$static.source && $remove_13(this$static.source.outgoingEdges, this$static);
  this$static.source = source;
  !!this$static.source && $add_4(this$static.source.outgoingEdges, this$static);
}

function $setTarget_0(this$static, target){
  !!this$static.target && $remove_13(this$static.target.incomingEdges, this$static);
  this$static.target = target;
  !!this$static.target && $add_4(this$static.target.incomingEdges, this$static);
}

function $setTargetAndInsertAtIndex(this$static, targetPort, index_0){
  !!this$static.target && $remove_13(this$static.target.incomingEdges, this$static);
  this$static.target = targetPort;
  !!this$static.target && $add_3(this$static.target.incomingEdges, index_0, this$static);
}

function $toString_8(this$static){
  return !!this$static.source && !!this$static.target?this$static.source.owner + '(' + this$static.source + ')->' + this$static.target.owner + '(' + this$static.target + ')':'e_' + getHashCode_0(this$static);
}

function LEdge(){
  this.bendPoints = new KVectorChain;
  this.labels = (checkNonnegative(3, 'initialArraySize') , new ArrayList_0(3));
}

defineClass(16, 288, {3:1, 16:1, 288:1, 94:1, 130:1}, LEdge);
_.toString_0 = function toString_85(){
  return $toString_8(this);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LEdge', 16);
function $toNodeArray(this$static){
  var layer, layerIndex, layerIter, lgraphArray;
  lgraphArray = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_33, 125, this$static.layers.array.length, 0, 2);
  layerIter = new AbstractList$ListIteratorImpl(this$static.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_3(layerIter.last = layerIter.i++), 25));
    layerIndex = layerIter.i - 1;
    lgraphArray[layerIndex] = castTo($toArray_2(layer.nodes, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, layer.nodes.array.length, 0, 1)), 125);
  }
  return lgraphArray;
}

function LGraph(){
  this.size_0 = new KVector;
  this.padding = new LPadding;
  this.offset = new KVector;
  this.layerlessNodes = new ArrayList;
  this.layers = new ArrayList;
}

defineClass(32, 288, {3:1, 20:1, 32:1, 288:1, 94:1, 130:1}, LGraph);
_.forEach_0 = function forEach_20(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_60(){
  return new ArrayList$1(this.layers);
}
;
_.toString_0 = function toString_86(){
  if (this.layers.array.length == 0) {
    return 'G-unlayered' + $toString_1(this.layerlessNodes);
  }
   else if (this.layerlessNodes.array.length == 0) {
    return 'G-layered' + $toString_1(this.layers);
  }
  return 'G[layerless' + $toString_1(this.layerlessNodes) + ', layers' + $toString_1(this.layers) + ']';
}
;
var Lorg_eclipse_elk_alg_layered_graph_LGraph_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraph', 32);
defineClass(617, 1, {});
_.getPosition = function getPosition(){
  return this.element.pos;
}
;
_.getProperty = function getProperty_0(prop){
  return $getProperty(this.element, prop);
}
;
_.getSize = function getSize(){
  return this.element.size_0;
}
;
_.getVolatileId = function getVolatileId(){
  return this.element.id_0;
}
;
_.hasProperty = function hasProperty_0(prop){
  return $hasProperty(this.element, prop);
}
;
_.setPosition = function setPosition(pos){
  this.element.pos.x_0 = pos.x_0;
  this.element.pos.y_0 = pos.y_0;
}
;
_.setSize = function setSize(size_0){
  this.element.size_0.x_0 = size_0.x_0;
  this.element.size_0.y_0 = size_0.y_0;
}
;
_.setVolatileId = function setVolatileId(volatileId){
  this.element.id_0 = volatileId;
}
;
var Lorg_eclipse_elk_alg_layered_graph_LGraphAdapters$AbstractLShapeAdapter_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraphAdapters/AbstractLShapeAdapter', 617);
function LGraphAdapters$LEdgeAdapter(edge){
  this.element = edge;
}

defineClass(546, 1, {771:1}, LGraphAdapters$LEdgeAdapter);
_.getLabels = function getLabels(){
  var l, l$iterator;
  if (!this.labelAdapters) {
    this.labelAdapters = newArrayListWithCapacity(this.element.labels.array.length);
    for (l$iterator = new ArrayList$1(this.element.labels); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_10(l$iterator), 70);
      $add_4(this.labelAdapters, new LGraphAdapters$LLabelAdapter(l));
    }
  }
  return this.labelAdapters;
}
;
_.labelAdapters = null;
var Lorg_eclipse_elk_alg_layered_graph_LGraphAdapters$LEdgeAdapter_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraphAdapters/LEdgeAdapter', 546);
function $getNodes(this$static){
  var comment, comment$iterator, l, l$iterator, n, n$iterator;
  if (!this$static.nodeAdapters) {
    this$static.nodeAdapters = new ArrayList;
    for (l$iterator = new ArrayList$1(this$static.element.layers); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_10(l$iterator), 25);
      for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
        n = castTo($next_10(n$iterator), 9);
        if (this$static.nodeFilter.test_0(n)) {
          $add_4(this$static.nodeAdapters, new LGraphAdapters$LNodeAdapter(this$static, n, this$static.transparentNorthSouthEdges));
          if (this$static.transparentCommentNodes) {
            if ($hasProperty(n, ($clinit_InternalProperties_1() , TOP_COMMENTS))) {
              for (comment$iterator = castTo($getProperty(n, TOP_COMMENTS), 15).iterator_0(); comment$iterator.hasNext_0();) {
                comment = castTo(comment$iterator.next_1(), 9);
                $add_4(this$static.nodeAdapters, new LGraphAdapters$LNodeAdapter(this$static, comment, false));
              }
            }
            if ($hasProperty(n, BOTTOM_COMMENTS)) {
              for (comment$iterator = castTo($getProperty(n, BOTTOM_COMMENTS), 15).iterator_0(); comment$iterator.hasNext_0();) {
                comment = castTo(comment$iterator.next_1(), 9);
                $add_4(this$static.nodeAdapters, new LGraphAdapters$LNodeAdapter(this$static, comment, false));
              }
            }
          }
        }
      }
    }
  }
  return this$static.nodeAdapters;
}

function LGraphAdapters$LGraphAdapter(element, transparentCommentNodes, nodeFilter){
  this.element = element;
  this.transparentNorthSouthEdges = false;
  this.transparentCommentNodes = transparentCommentNodes;
  this.nodeFilter = nodeFilter;
}

defineClass(616, 1, {}, LGraphAdapters$LGraphAdapter);
_.getNodes = function getNodes(){
  return $getNodes(this);
}
;
_.getPosition = function getPosition_0(){
  throw toJs(new UnsupportedOperationException_0('Not supported by LGraph'));
}
;
_.getProperty = function getProperty_1(prop){
  return $getProperty(this.element, prop);
}
;
_.getSize = function getSize_0(){
  return this.element.size_0;
}
;
_.getVolatileId = function getVolatileId_0(){
  return this.element.id_0;
}
;
_.hasProperty = function hasProperty_1(prop){
  return $hasProperty(this.element, prop);
}
;
_.setPosition = function setPosition_0(pos){
  throw toJs(new UnsupportedOperationException_0('Not supported by LGraph'));
}
;
_.setSize = function setSize_0(size_0){
  this.element.size_0.x_0 = size_0.x_0;
  this.element.size_0.y_0 = size_0.y_0;
}
;
_.setVolatileId = function setVolatileId_0(volatileId){
  this.element.id_0 = volatileId;
}
;
_.nodeAdapters = null;
_.transparentCommentNodes = false;
_.transparentNorthSouthEdges = false;
var Lorg_eclipse_elk_alg_layered_graph_LGraphAdapters$LGraphAdapter_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraphAdapters/LGraphAdapter', 616);
function LGraphAdapters$LLabelAdapter(element){
  this.element = element;
}

defineClass(545, 617, {281:1}, LGraphAdapters$LLabelAdapter);
var Lorg_eclipse_elk_alg_layered_graph_LGraphAdapters$LLabelAdapter_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraphAdapters/LLabelAdapter', 545);
function LGraphAdapters$LNodeAdapter(parent_0, element, transparentNorthSouthEdges){
  this.element = element;
  this.parentGraphAdapter = parent_0;
  this.transparentNorthSouthEdges = transparentNorthSouthEdges;
}

defineClass(544, 617, {769:1}, LGraphAdapters$LNodeAdapter);
_.getGraph = function getGraph(){
  return this.parentGraphAdapter;
}
;
_.getIncomingEdges = function getIncomingEdges(){
  return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
}
;
_.getLabels = function getLabels_0(){
  var l, l$iterator;
  if (!this.labelAdapters) {
    this.labelAdapters = newArrayListWithCapacity(castTo(this.element, 9).labels.array.length);
    for (l$iterator = new ArrayList$1(castTo(this.element, 9).labels); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_10(l$iterator), 70);
      $add_4(this.labelAdapters, new LGraphAdapters$LLabelAdapter(l));
    }
  }
  return this.labelAdapters;
}
;
_.getMargin = function getMargin(){
  var lmargins;
  lmargins = castTo(this.element, 9).margin;
  return new ElkMargin_1(lmargins.top_0, lmargins.right, lmargins.bottom, lmargins.left);
}
;
_.getOutgoingEdges = function getOutgoingEdges(){
  return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
}
;
_.getPorts = function getPorts(){
  var p, p$iterator;
  if (!this.portAdapters) {
    this.portAdapters = newArrayListWithCapacity(castTo(this.element, 9).ports.array.length);
    for (p$iterator = new ArrayList$1(castTo(this.element, 9).ports); p$iterator.i < p$iterator.this$01.array.length;) {
      p = castTo($next_10(p$iterator), 11);
      $add_4(this.portAdapters, new LGraphAdapters$LPortAdapter(p, this.transparentNorthSouthEdges));
    }
  }
  return this.portAdapters;
}
;
_.isCompoundNode = function isCompoundNode(){
  return checkNotNull_1(castToBoolean($getProperty(castTo(this.element, 9), ($clinit_InternalProperties_1() , COMPOUND_NODE))));
}
;
_.setMargin = function setMargin(margin){
  castTo(this.element, 9).margin.left = margin.left;
  castTo(this.element, 9).margin.top_0 = margin.top_0;
  castTo(this.element, 9).margin.right = margin.right;
  castTo(this.element, 9).margin.bottom = margin.bottom;
}
;
_.setPadding = function setPadding(padding){
  castTo(this.element, 9).padding.left = padding.left;
  castTo(this.element, 9).padding.top_0 = padding.top_0;
  castTo(this.element, 9).padding.right = padding.right;
  castTo(this.element, 9).padding.bottom = padding.bottom;
}
;
_.labelAdapters = null;
_.parentGraphAdapter = null;
_.portAdapters = null;
_.transparentNorthSouthEdges = false;
var Lorg_eclipse_elk_alg_layered_graph_LGraphAdapters$LNodeAdapter_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraphAdapters/LNodeAdapter', 544);
function LGraphAdapters$LPortAdapter(element, transparentNorthSouthEdges){
  this.element = element;
  this.transparentNorthSouthEdges = transparentNorthSouthEdges;
}

defineClass(1573, 617, {770:1}, LGraphAdapters$LPortAdapter);
_.getIncomingEdges = function getIncomingEdges_0(){
  var e, e$iterator, e$iterator0, portDummy;
  if (this.transparentNorthSouthEdges && castTo(this.element, 11).owner.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
   else if (!this.incomingEdgeAdapters) {
    this.incomingEdgeAdapters = new ArrayList;
    for (e$iterator0 = new ArrayList$1(castTo(this.element, 11).incomingEdges); e$iterator0.i < e$iterator0.this$01.array.length;) {
      e = castTo($next_10(e$iterator0), 16);
      $add_4(this.incomingEdgeAdapters, new LGraphAdapters$LEdgeAdapter(e));
    }
    if (this.transparentNorthSouthEdges) {
      portDummy = castTo($getProperty(castTo(this.element, 11), ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
      if (portDummy) {
        for (e$iterator = $iterator($getIncomingEdges(portDummy)); $hasNext_0(e$iterator);) {
          e = castTo($next_2(e$iterator), 16);
          $add_4(this.incomingEdgeAdapters, new LGraphAdapters$LEdgeAdapter(e));
        }
      }
    }
  }
  return this.incomingEdgeAdapters;
}
;
_.getLabels = function getLabels_1(){
  var l, l$iterator;
  if (!this.labelAdapters) {
    this.labelAdapters = newArrayListWithCapacity(castTo(this.element, 11).labels.array.length);
    for (l$iterator = new ArrayList$1(castTo(this.element, 11).labels); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_10(l$iterator), 70);
      $add_4(this.labelAdapters, new LGraphAdapters$LLabelAdapter(l));
    }
  }
  return this.labelAdapters;
}
;
_.getOutgoingEdges = function getOutgoingEdges_0(){
  var e, e$iterator, e$iterator0, portDummy;
  if (this.transparentNorthSouthEdges && castTo(this.element, 11).owner.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
   else if (!this.outgoingEdgeAdapters) {
    this.outgoingEdgeAdapters = new ArrayList;
    for (e$iterator0 = new ArrayList$1(castTo(this.element, 11).outgoingEdges); e$iterator0.i < e$iterator0.this$01.array.length;) {
      e = castTo($next_10(e$iterator0), 16);
      $add_4(this.outgoingEdgeAdapters, new LGraphAdapters$LEdgeAdapter(e));
    }
    if (this.transparentNorthSouthEdges) {
      portDummy = castTo($getProperty(castTo(this.element, 11), ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
      if (portDummy) {
        for (e$iterator = $iterator($getOutgoingEdges(portDummy)); $hasNext_0(e$iterator);) {
          e = castTo($next_2(e$iterator), 16);
          $add_4(this.outgoingEdgeAdapters, new LGraphAdapters$LEdgeAdapter(e));
        }
      }
    }
  }
  return this.outgoingEdgeAdapters;
}
;
_.getSide = function getSide(){
  return castTo(this.element, 11).side;
}
;
_.hasCompoundConnections = function hasCompoundConnections(){
  return checkNotNull_1(castToBoolean($getProperty(castTo(this.element, 11), ($clinit_InternalProperties_1() , INSIDE_CONNECTIONS))));
}
;
_.incomingEdgeAdapters = null;
_.labelAdapters = null;
_.outgoingEdgeAdapters = null;
_.transparentNorthSouthEdges = false;
var Lorg_eclipse_elk_alg_layered_graph_LGraphAdapters$LPortAdapter_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraphAdapters/LPortAdapter', 1573);
function LGraphAdapters$lambda$0$Type(){
}

defineClass(746, 1, $intern_90, LGraphAdapters$lambda$0$Type);
_.test_0 = function test_15(arg0){
  return true;
}
;
var Lorg_eclipse_elk_alg_layered_graph_LGraphAdapters$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LGraphAdapters/lambda$0$Type', 746);
function calcPortOffset(port, side){
  var node;
  node = port.owner;
  switch (side.ordinal) {
    case 1:
      return -(port.pos.y_0 + port.size_0.y_0);
    case 2:
      return port.pos.x_0 - node.size_0.x_0;
    case 3:
      return port.pos.y_0 - node.size_0.y_0;
    case 4:
      return -(port.pos.x_0 + port.size_0.x_0);
  }
  return 0;
}

function calcPortSide(port, direction){
  var height, heightPercent, node, nodeHeight, nodeWidth, width_0, widthPercent, xpos, ypos;
  node = port.owner;
  nodeWidth = node.size_0.x_0;
  nodeHeight = node.size_0.y_0;
  if (nodeWidth <= 0 && nodeHeight <= 0) {
    return $clinit_PortSide() , UNDEFINED_7;
  }
  xpos = port.pos.x_0;
  ypos = port.pos.y_0;
  width_0 = port.size_0.x_0;
  height = port.size_0.y_0;
  switch (direction.ordinal) {
    case 2:
    case 1:
      if (xpos < 0) {
        return $clinit_PortSide() , WEST_1;
      }
       else if (xpos + width_0 > nodeWidth) {
        return $clinit_PortSide() , EAST_1;
      }

      break;
    case 4:
    case 3:
      if (ypos < 0) {
        return $clinit_PortSide() , NORTH_1;
      }
       else if (ypos + height > nodeHeight) {
        return $clinit_PortSide() , SOUTH_1;
      }

  }
  widthPercent = (xpos + width_0 / 2) / nodeWidth;
  heightPercent = (ypos + height / 2) / nodeHeight;
  return widthPercent + heightPercent <= 1 && widthPercent - heightPercent <= 0?($clinit_PortSide() , WEST_1):widthPercent + heightPercent >= 1 && widthPercent - heightPercent >= 0?($clinit_PortSide() , EAST_1):heightPercent < 0.5?($clinit_PortSide() , NORTH_1):($clinit_PortSide() , SOUTH_1);
}

function centerPoint(point, boundary, side){
  switch (side.ordinal) {
    case 1:
      point.x_0 = boundary.x_0 / 2;
      point.y_0 = 0;
      break;
    case 2:
      point.x_0 = boundary.x_0;
      point.y_0 = boundary.y_0 / 2;
      break;
    case 3:
      point.x_0 = boundary.x_0 / 2;
      point.y_0 = boundary.y_0;
      break;
    case 4:
      point.x_0 = 0;
      point.y_0 = boundary.y_0 / 2;
  }
}

function changeCoordSystem(point, oldGraph, newGraph){
  var graph, node, padding;
  if (oldGraph == newGraph) {
    return;
  }
  graph = oldGraph;
  do {
    $add_19(point, graph.offset);
    node = castTo($getProperty(graph, ($clinit_InternalProperties_1() , PARENT_LNODE)), 9);
    if (node) {
      padding = graph.padding;
      $add_18(point, padding.left, padding.top_0);
      $add_19(point, node.pos);
      graph = $getGraph(node);
    }
  }
   while (node);
  graph = newGraph;
  do {
    $sub_0(point, graph.offset);
    node = castTo($getProperty(graph, ($clinit_InternalProperties_1() , PARENT_LNODE)), 9);
    if (node) {
      padding = graph.padding;
      $sub(point, padding.left, padding.top_0);
      $sub_0(point, node.pos);
      graph = $getGraph(node);
    }
  }
   while (node);
}

function createExternalPortDummy(propertyHolder, portConstraints, portSide, netFlow, portNodeSize, portPosition, portSize, layoutDirection, layeredGraph){
  var anchor, dummy, dummyPort, finalExternalPortSide, informationAboutIt;
  finalExternalPortSide = portSide;
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , EXTERNAL_PORT));
  $setProperty_0(dummy, ($clinit_InternalProperties_1() , EXT_PORT_SIZE), portSize);
  $setProperty_0(dummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty_0(dummy, PORT_BORDER_OFFSET, castToDouble(propertyHolder.getProperty(PORT_BORDER_OFFSET)));
  anchor = castTo(propertyHolder.getProperty(PORT_ANCHOR), 8);
  !anchor && (anchor = new KVector_1(portSize.x_0 / 2, portSize.y_0 / 2));
  $setProperty_0(dummy, PORT_ANCHOR, anchor);
  dummyPort = new LPort;
  $setNode(dummyPort, dummy);
  if (!(portConstraints != FREE && portConstraints != UNDEFINED_6)) {
    netFlow > 0?(finalExternalPortSide = fromDirection(layoutDirection)):(finalExternalPortSide = $opposed(fromDirection(layoutDirection)));
    propertyHolder.setProperty(PORT_SIDE, finalExternalPortSide);
  }
  switch (finalExternalPortSide.ordinal) {
    case 4:
      $setProperty_0(dummy, LAYERING_LAYER_CONSTRAINT_0, ($clinit_LayerConstraint() , FIRST_SEPARATE));
      $setProperty_0(dummy, EDGE_CONSTRAINT, ($clinit_EdgeConstraint() , OUTGOING_ONLY));
      dummy.size_0.y_0 = portSize.y_0;
      $setSide(dummyPort, ($clinit_PortSide() , EAST_1));
      dummyPort.pos.y_0 = anchor.y_0;
      break;
    case 2:
      $setProperty_0(dummy, LAYERING_LAYER_CONSTRAINT_0, ($clinit_LayerConstraint() , LAST_SEPARATE));
      $setProperty_0(dummy, EDGE_CONSTRAINT, ($clinit_EdgeConstraint() , INCOMING_ONLY));
      dummy.size_0.y_0 = portSize.y_0;
      $setSide(dummyPort, ($clinit_PortSide() , WEST_1));
      dummyPort.pos.y_0 = anchor.y_0;
      break;
    case 1:
      $setProperty_0(dummy, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , TOP_0));
      dummy.size_0.x_0 = portSize.x_0;
      $setSide(dummyPort, ($clinit_PortSide() , SOUTH_1));
      dummyPort.pos.x_0 = anchor.x_0;
      break;
    case 3:
      $setProperty_0(dummy, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , BOTTOM_0));
      dummy.size_0.x_0 = portSize.x_0;
      $setSide(dummyPort, ($clinit_PortSide() , NORTH_1));
      dummyPort.pos.x_0 = anchor.x_0;
  }
  if (portConstraints == FIXED_ORDER || portConstraints == FIXED_RATIO || portConstraints == FIXED_POS) {
    informationAboutIt = 0;
    if (portConstraints == FIXED_ORDER && propertyHolder.hasProperty(PORT_INDEX)) {
      switch (finalExternalPortSide.ordinal) {
        case 1:
        case 2:
          informationAboutIt = castTo(propertyHolder.getProperty(PORT_INDEX), 21).value_0;
          break;
        case 3:
        case 4:
          informationAboutIt = -castTo(propertyHolder.getProperty(PORT_INDEX), 21).value_0;
      }
    }
     else {
      switch (finalExternalPortSide.ordinal) {
        case 4:
        case 2:
          informationAboutIt = portPosition.y_0;
          portConstraints == FIXED_RATIO && (informationAboutIt /= portNodeSize.y_0);
          break;
        case 1:
        case 3:
          informationAboutIt = portPosition.x_0;
          portConstraints == FIXED_RATIO && (informationAboutIt /= portNodeSize.x_0);
      }
    }
    $setProperty_0(dummy, PORT_RATIO_OR_POSITION_0, informationAboutIt);
  }
  $setProperty_0(dummy, EXT_PORT_SIDE, finalExternalPortSide);
  return dummy;
}

function createPort(node, endPoint, type_0, layeredGraph){
  var defaultSide, direction, graphProperties, mergePorts, port, portSide, pos;
  direction = getDirection_1(layeredGraph);
  mergePorts = checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_LayeredOptions() , MERGE_EDGES_0))));
  if ((mergePorts || checkNotNull_1(castToBoolean($getProperty(node, HYPERNODE)))) && !$isSideFixed(castTo($getProperty(node, PORT_CONSTRAINTS_0), 83))) {
    defaultSide = fromDirection(direction);
    port = provideCollectorPort(node, type_0, type_0 == ($clinit_PortType() , OUTPUT)?defaultSide:$opposed(defaultSide));
  }
   else {
    port = new LPort;
    $setNode(port, node);
    if (endPoint) {
      pos = port.pos;
      pos.x_0 = endPoint.x_0 - node.pos.x_0;
      pos.y_0 = endPoint.y_0 - node.pos.y_0;
      $bound(pos, 0, 0, node.size_0.x_0, node.size_0.y_0);
      $setSide(port, calcPortSide(port, direction));
    }
     else {
      defaultSide = fromDirection(direction);
      $setSide(port, type_0 == ($clinit_PortType() , OUTPUT)?defaultSide:$opposed(defaultSide));
    }
    graphProperties = castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19);
    portSide = port.side;
    switch (direction.ordinal) {
      case 2:
      case 1:
        (portSide == ($clinit_PortSide() , NORTH_1) || portSide == SOUTH_1) && graphProperties.add_1(($clinit_GraphProperties() , NORTH_SOUTH_PORTS));
        break;
      case 4:
      case 3:
        (portSide == ($clinit_PortSide() , EAST_1) || portSide == WEST_1) && graphProperties.add_1(($clinit_GraphProperties() , NORTH_SOUTH_PORTS));
    }
  }
  return port;
}

function findMaxNonDummyNodeWidth(layer){
  var maxWidth, node, node$iterator, width_0;
  if ($isVertical(castTo($getProperty(layer.owner, ($clinit_LayeredOptions() , DIRECTION)), 107))) {
    return 0;
  }
  maxWidth = 0;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL)) {
      width_0 = node.size_0.x_0;
      maxWidth = $wnd.Math.max(maxWidth, width_0);
    }
  }
  return maxWidth;
}

function getDirection_1(graph){
  var aspectRatio, direction;
  direction = castTo($getProperty(graph, ($clinit_LayeredOptions() , DIRECTION)), 107);
  if (direction == ($clinit_Direction_0() , UNDEFINED_3)) {
    aspectRatio = checkNotNull_1(castToDouble($getProperty(graph, ASPECT_RATIO_1)));
    return aspectRatio >= 1?RIGHT_5:DOWN_1;
  }
  return direction;
}

function getExternalPortPosition(graph, portDummy, portWidth, portHeight){
  var graphOffset, graphSize, padding, portOffset, portPosition;
  portPosition = new KVector_2(portDummy.pos);
  portPosition.x_0 += portDummy.size_0.x_0 / 2;
  portPosition.y_0 += portDummy.size_0.y_0 / 2;
  portOffset = checkNotNull_1(castToDouble($getProperty(portDummy, ($clinit_LayeredOptions() , PORT_BORDER_OFFSET))));
  graphSize = graph.size_0;
  padding = graph.padding;
  graphOffset = graph.offset;
  switch (castTo($getProperty(portDummy, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71).ordinal) {
    case 1:
      portPosition.x_0 += padding.left + graphOffset.x_0 - portWidth / 2;
      portPosition.y_0 = -portHeight - portOffset;
      portDummy.pos.y_0 = -(padding.top_0 + portOffset + graphOffset.y_0);
      break;
    case 2:
      portPosition.x_0 = graphSize.x_0 + padding.left + padding.right + portOffset;
      portPosition.y_0 += padding.top_0 + graphOffset.y_0 - portHeight / 2;
      portDummy.pos.x_0 = graphSize.x_0 + padding.right + portOffset - graphOffset.x_0;
      break;
    case 3:
      portPosition.x_0 += padding.left + graphOffset.x_0 - portWidth / 2;
      portPosition.y_0 = graphSize.y_0 + padding.top_0 + padding.bottom + portOffset;
      portDummy.pos.y_0 = graphSize.y_0 + padding.bottom + portOffset - graphOffset.y_0;
      break;
    case 4:
      portPosition.x_0 = -portWidth - portOffset;
      portPosition.y_0 += padding.top_0 + graphOffset.y_0 - portHeight / 2;
      portDummy.pos.x_0 = -(padding.left + portOffset + graphOffset.x_0);
  }
  return portPosition;
}

function initializePort(port, portConstraints, direction, anchorPos){
  var nodeHeight, nodeWidth, portAnchor, portSide, portSize, ratio;
  portSide = port.side;
  if (portSide == ($clinit_PortSide() , UNDEFINED_7) && portConstraints != ($clinit_PortConstraints() , FREE) && portConstraints != ($clinit_PortConstraints() , UNDEFINED_6)) {
    portSide = calcPortSide(port, direction);
    $setSide(port, portSide);
    !(!port.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):port.propertyMap).containsKey(($clinit_LayeredOptions() , PORT_BORDER_OFFSET)) && portSide != UNDEFINED_7 && (port.pos.x_0 != 0 || port.pos.y_0 != 0) && $setProperty_0(port, PORT_BORDER_OFFSET, calcPortOffset(port, portSide));
  }
  if (portConstraints == ($clinit_PortConstraints() , FIXED_RATIO)) {
    ratio = 0;
    switch (portSide.ordinal) {
      case 1:
      case 3:
        nodeWidth = port.owner.size_0.x_0;
        nodeWidth > 0 && (ratio = port.pos.x_0 / nodeWidth);
        break;
      case 2:
      case 4:
        nodeHeight = port.owner.size_0.y_0;
        nodeHeight > 0 && (ratio = port.pos.y_0 / nodeHeight);
    }
    $setProperty_0(port, ($clinit_InternalProperties_1() , PORT_RATIO_OR_POSITION_0), ratio);
  }
  portSize = port.size_0;
  portAnchor = port.anchor;
  if (anchorPos) {
    portAnchor.x_0 = anchorPos.x_0;
    portAnchor.y_0 = anchorPos.y_0;
    port.anchorFixed = true;
  }
   else if (portConstraints != FREE && portConstraints != UNDEFINED_6 && portSide != UNDEFINED_7) {
    switch (portSide.ordinal) {
      case 1:
        portAnchor.x_0 = portSize.x_0 / 2;
        break;
      case 2:
        portAnchor.x_0 = portSize.x_0;
        portAnchor.y_0 = portSize.y_0 / 2;
        break;
      case 3:
        portAnchor.x_0 = portSize.x_0 / 2;
        portAnchor.y_0 = portSize.y_0;
        break;
      case 4:
        portAnchor.y_0 = portSize.y_0 / 2;
    }
  }
   else {
    portAnchor.x_0 = portSize.x_0 / 2;
    portAnchor.y_0 = portSize.y_0 / 2;
  }
}

function isDescendant(child, parent_0){
  var next;
  next = castTo($getProperty($getGraph(child), ($clinit_InternalProperties_1() , PARENT_LNODE)), 9);
  while (next) {
    if (next == parent_0) {
      return true;
    }
    next = castTo($getProperty($getGraph(next), PARENT_LNODE), 9);
  }
  return false;
}

function offsetGraph(graph, offsetx, offsety){
  var edge, edge$iterator, graphOffset, junctionPoints, label_0, label$iterator, node, node$iterator, port, port$iterator;
  graphOffset = new KVector_1(offsetx, offsety);
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $add_19(node.pos, graphOffset);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        $offset_2(edge.bendPoints, graphOffset);
        junctionPoints = castTo($getProperty(edge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
        !!junctionPoints && $offset_2(junctionPoints, graphOffset);
        for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_10(label$iterator), 70);
          $add_19(label_0.pos, graphOffset);
        }
      }
    }
  }
}

function placeNodesHorizontally(layer, xoffset){
  var alignment, inports, leftMargin, maxLeftMargin, maxRightMargin, node, node$iterator, node$iterator0, nodeSize, outports, port, port$iterator, ratio, rightMargin, size_0, xpos;
  maxLeftMargin = 0;
  maxRightMargin = 0;
  for (node$iterator0 = new ArrayList$1(layer.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    maxLeftMargin = $wnd.Math.max(maxLeftMargin, node.margin.left);
    maxRightMargin = $wnd.Math.max(maxRightMargin, node.margin.right);
  }
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    alignment = castTo($getProperty(node, ($clinit_LayeredOptions() , ALIGNMENT)), 234);
    switch (alignment.ordinal) {
      case 1:
        ratio = 0;
        break;
      case 2:
        ratio = 1;
        break;
      case 5:
        ratio = 0.5;
        break;
      default:inports = 0;
        outports = 0;
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_10(port$iterator), 11);
          port.incomingEdges.array.length == 0 || ++inports;
          port.outgoingEdges.array.length == 0 || ++outports;
        }

        inports + outports == 0?(ratio = 0.5):(ratio = outports / (inports + outports));
    }
    size_0 = layer.size_0;
    nodeSize = node.size_0.x_0;
    xpos = (size_0.x_0 - nodeSize) * ratio;
    ratio > 0.5?(xpos -= maxRightMargin * 2 * (ratio - 0.5)):ratio < 0.5 && (xpos += maxLeftMargin * 2 * (0.5 - ratio));
    leftMargin = node.margin.left;
    xpos < leftMargin && (xpos = leftMargin);
    rightMargin = node.margin.right;
    xpos > size_0.x_0 - rightMargin - nodeSize && (xpos = size_0.x_0 - rightMargin - nodeSize);
    node.pos.x_0 = xoffset + xpos;
  }
}

function provideCollectorPort(node, type_0, side){
  var inport, inport$iterator, outport, outport$iterator, port;
  port = null;
  switch (type_0.ordinal) {
    case 1:
      for (inport$iterator = new ArrayList$1(node.ports); inport$iterator.i < inport$iterator.this$01.array.length;) {
        inport = castTo($next_10(inport$iterator), 11);
        if (checkNotNull_1(castToBoolean($getProperty(inport, ($clinit_InternalProperties_1() , INPUT_COLLECT))))) {
          return inport;
        }
      }

      port = new LPort;
      $setProperty_0(port, ($clinit_InternalProperties_1() , INPUT_COLLECT), ($clinit_Boolean() , $clinit_Boolean() , true));
      break;
    case 2:
      for (outport$iterator = new ArrayList$1(node.ports); outport$iterator.i < outport$iterator.this$01.array.length;) {
        outport = castTo($next_10(outport$iterator), 11);
        if (checkNotNull_1(castToBoolean($getProperty(outport, ($clinit_InternalProperties_1() , OUTPUT_COLLECT))))) {
          return outport;
        }
      }

      port = new LPort;
      $setProperty_0(port, ($clinit_InternalProperties_1() , OUTPUT_COLLECT), ($clinit_Boolean() , $clinit_Boolean() , true));
  }
  if (port) {
    $setNode(port, node);
    $setSide(port, side);
    centerPoint(port.pos, node.size_0, side);
  }
  return port;
}

function resizeNode(node, newSize, movePorts){
  var all, fixedPorts, heightDiff, heightPercent, heightRatio, label_0, label$iterator, midx, midy, oldSize, port, port$iterator, widthDiff, widthPercent, widthRatio;
  oldSize = new KVector_2(node.size_0);
  widthRatio = newSize.x_0 / oldSize.x_0;
  heightRatio = newSize.y_0 / oldSize.y_0;
  widthDiff = newSize.x_0 - oldSize.x_0;
  heightDiff = newSize.y_0 - oldSize.y_0;
  if (movePorts) {
    fixedPorts = maskUndefined($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0))) === maskUndefined(($clinit_PortConstraints() , FIXED_POS));
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      switch (port.side.ordinal) {
        case 1:
          fixedPorts || (port.pos.x_0 *= widthRatio);
          break;
        case 2:
          port.pos.x_0 += widthDiff;
          fixedPorts || (port.pos.y_0 *= heightRatio);
          break;
        case 3:
          fixedPorts || (port.pos.x_0 *= widthRatio);
          port.pos.y_0 += heightDiff;
          break;
        case 4:
          fixedPorts || (port.pos.y_0 *= heightRatio);
      }
    }
  }
  for (label$iterator = new ArrayList$1(node.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 70);
    midx = label_0.pos.x_0 + label_0.size_0.x_0 / 2;
    midy = label_0.pos.y_0 + label_0.size_0.y_0 / 2;
    widthPercent = midx / oldSize.x_0;
    heightPercent = midy / oldSize.y_0;
    if (widthPercent + heightPercent >= 1) {
      if (widthPercent - heightPercent > 0 && midy >= 0) {
        label_0.pos.x_0 += widthDiff;
        label_0.pos.y_0 += heightDiff * heightPercent;
      }
       else if (widthPercent - heightPercent < 0 && midx >= 0) {
        label_0.pos.x_0 += widthDiff * widthPercent;
        label_0.pos.y_0 += heightDiff;
      }
    }
  }
  node.size_0.x_0 = newSize.x_0;
  node.size_0.y_0 = newSize.y_0;
  $setProperty_0(node, ($clinit_LayeredOptions() , NODE_SIZE_CONSTRAINTS), ($clinit_SizeConstraint() , all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_SizeConstraint_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0)));
}

function LShape(){
  this.pos = new KVector;
  this.size_0 = new KVector;
}

defineClass(373, 288, {3:1, 288:1, 373:1, 94:1, 130:1});
var Lorg_eclipse_elk_alg_layered_graph_LShape_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LShape', 373);
function LLabel(){
  LLabel_0.call(this, '');
}

function LLabel_0(thetext){
  LShape.call(this);
  this.text_0 = thetext;
}

defineClass(70, 373, {3:1, 288:1, 70:1, 373:1, 94:1, 130:1}, LLabel, LLabel_0);
_.toString_0 = function toString_87(){
  return this.text_0 == null?'l_' + this.id_0:'l_' + this.text_0;
}
;
var Lorg_eclipse_elk_alg_layered_graph_LLabel_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LLabel', 70);
function $add_15(this$static, other){
  this$static.left += other.left;
  this$static.right += other.right;
  this$static.top_0 += other.top_0;
  this$static.bottom += other.bottom;
  return this$static;
}

function $copy(this$static, other){
  this$static.left = other.left;
  this$static.right = other.right;
  this$static.top_0 = other.top_0;
  this$static.bottom = other.bottom;
  return this$static;
}

function $setBottom(this$static, bottom){
  this$static.bottom = bottom;
}

function $setLeft(this$static, left){
  this$static.left = left;
}

function $setRight(this$static, right){
  this$static.right = right;
}

function $setTop(this$static, top_0){
  this$static.top_0 = top_0;
}

function Spacing(){
}

function Spacing_0(top_0, right, bottom, left){
  this.top_0 = top_0;
  this.right = right;
  this.bottom = bottom;
  this.left = left;
}

function isdelim(c, delims){
  var i;
  for (i = 0; i < delims.length; i++) {
    if (c == delims.charCodeAt(i)) {
      return true;
    }
  }
  return false;
}

defineClass(218, 1, {3:1, 4:1, 218:1, 443:1});
_.equals_0 = function equals_96(obj){
  var other;
  if (instanceOf(obj, 218)) {
    other = castTo(obj, 218);
    return this.top_0 == other.top_0 && this.bottom == other.bottom && this.left == other.left && this.right == other.right;
  }
   else {
    return false;
  }
}
;
_.hashCode_1 = function hashCode_56(){
  var code1, code2;
  code1 = round_int(checkNotNull_1(this.left)) << 16;
  code1 |= round_int(checkNotNull_1(this.bottom)) & $intern_47;
  code2 = round_int(checkNotNull_1(this.right)) << 16;
  code2 |= round_int(checkNotNull_1(this.top_0)) & $intern_47;
  return code1 ^ code2;
}
;
_.parse_0 = function parse_0(string){
  var end, exception, key, keyandvalue, start_0, token, token$index, token$max, tokens, value_0;
  start_0 = 0;
  while (start_0 < string.length && isdelim(string.charCodeAt(start_0), '([{"\' \t\r\n')) {
    ++start_0;
  }
  end = string.length;
  while (end > 0 && isdelim(string.charCodeAt(end - 1), ')]}"\' \t\r\n')) {
    --end;
  }
  if (start_0 < end) {
    tokens = $split_0(string.substr(start_0, end - start_0), ',|;');
    try {
      for (token$index = 0 , token$max = tokens.length; token$index < token$max; ++token$index) {
        token = tokens[token$index];
        keyandvalue = $split_0(token, '=');
        if (keyandvalue.length != 2) {
          throw toJs(new IllegalArgumentException_0('Expecting a list of key-value pairs.'));
        }
        key = $trim(keyandvalue[0]);
        value_0 = __parseAndValidateDouble($trim(keyandvalue[1]));
        $equals_4(key, 'top')?(this.top_0 = value_0):$equals_4(key, 'left')?(this.left = value_0):$equals_4(key, 'bottom')?(this.bottom = value_0):$equals_4(key, 'right') && (this.right = value_0);
      }
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (instanceOf($e0, 120)) {
        exception = $e0;
        throw toJs(new IllegalArgumentException_0('The given string contains parts that cannot be parsed as numbers.' + exception));
      }
       else 
        throw toJs($e0);
    }
  }
}
;
_.toString_0 = function toString_88(){
  return '[top=' + this.top_0 + ',left=' + this.left + ',bottom=' + this.bottom + ',right=' + this.right + ']';
}
;
_.bottom = 0;
_.left = 0;
_.right = 0;
_.top_0 = 0;
var Lorg_eclipse_elk_core_math_Spacing_2_classLit = createForClass('org.eclipse.elk.core.math', 'Spacing', 218);
function ElkMargin(){
  Spacing.call(this);
}

function ElkMargin_0(){
  Spacing_0.call(this, 0, 0, 0, 0);
}

function ElkMargin_1(top_0, right, bottom, left){
  Spacing_0.call(this, top_0, right, bottom, left);
}

function ElkMargin_2(other){
  Spacing_0.call(this, other.top_0, other.right, other.bottom, other.left);
}

defineClass(137, 218, $intern_110, ElkMargin, ElkMargin_0, ElkMargin_1, ElkMargin_2);
var Lorg_eclipse_elk_core_math_ElkMargin_2_classLit = createForClass('org.eclipse.elk.core.math', 'ElkMargin', 137);
function LMargin(){
  ElkMargin.call(this);
}

defineClass(733, 137, $intern_110, LMargin);
var Lorg_eclipse_elk_alg_layered_graph_LMargin_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LMargin', 733);
function $borderToContentAreaCoordinates(this$static, horizontal, vertical){
  var graphPadding, offset, pos, thegraph;
  thegraph = $getGraph(this$static);
  graphPadding = thegraph.padding;
  offset = thegraph.offset;
  pos = this$static.pos;
  horizontal && (pos.x_0 = pos.x_0 - graphPadding.left - offset.x_0);
  vertical && (pos.y_0 = pos.y_0 - graphPadding.top_0 - offset.y_0);
}

function $findPortIndices(this$static){
  var currentIndex, currentSide, firstIndexForCurrentSide, port;
  this$static.portSideIndices = ($clinit_Maps() , new EnumMap(castTo(checkNotNull(Lorg_eclipse_elk_core_options_PortSide_2_classLit), 283)));
  firstIndexForCurrentSide = 0;
  currentSide = ($clinit_PortSide() , NORTH_1);
  currentIndex = 0;
  for (; currentIndex < this$static.ports.array.length; currentIndex++) {
    port = castTo($get_7(this$static.ports, currentIndex), 11);
    if (port.side != currentSide) {
      firstIndexForCurrentSide != currentIndex && $put_2(this$static.portSideIndices, currentSide, new Pair(valueOf_4(firstIndexForCurrentSide), valueOf_4(currentIndex)));
      currentSide = port.side;
      firstIndexForCurrentSide = currentIndex;
    }
  }
  $put_2(this$static.portSideIndices, currentSide, new Pair(valueOf_4(firstIndexForCurrentSide), valueOf_4(currentIndex)));
}

function $getConnectedEdges_0(this$static){
  var iterables, port, port$iterator;
  iterables = new ArrayList;
  for (port$iterator = new ArrayList$1(this$static.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $add_4(iterables, port.connectedEdges);
  }
  return checkNotNull(iterables) , new FluentIterable$2(iterables);
}

function $getGraph(this$static){
  if (!this$static.graph_0 && !!this$static.layer) {
    return this$static.layer.owner;
  }
  return this$static.graph_0;
}

function $getIncomingEdges(this$static){
  var iterables, port, port$iterator;
  iterables = new ArrayList;
  for (port$iterator = new ArrayList$1(this$static.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $add_4(iterables, port.incomingEdges);
  }
  return checkNotNull(iterables) , new FluentIterable$2(iterables);
}

function $getIndex(this$static){
  return !this$static.layer?-1:$indexOf_3(this$static.layer.nodes, this$static, 0);
}

function $getInteractiveReferencePoint(this$static){
  var nodePos, nodeSize;
  switch (castTo($getProperty($getGraph(this$static), ($clinit_LayeredOptions() , INTERACTIVE_REFERENCE_POINT_0)), 398).ordinal) {
    case 0:
      nodePos = this$static.pos;
      nodeSize = this$static.size_0;
      return new KVector_1(nodePos.x_0 + nodeSize.x_0 / 2, nodePos.y_0 + nodeSize.y_0 / 2);
    case 1:
      return new KVector_2(this$static.pos);
    default:return null;
  }
}

function $getName_0(this$static){
  if (this$static.labels.array.length != 0) {
    return castTo($get_7(this$static.labels, 0), 70).text_0;
  }
  return null;
}

function $getOutgoingEdges(this$static){
  var iterables, port, port$iterator;
  iterables = new ArrayList;
  for (port$iterator = new ArrayList$1(this$static.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $add_4(iterables, port.outgoingEdges);
  }
  return checkNotNull(iterables) , new FluentIterable$2(iterables);
}

function $getPortSideView(this$static, side){
  var indices;
  this$static.portSidesCached || $findPortIndices(this$static);
  indices = castTo($get_10(this$static.portSideIndices, side), 37);
  return !indices?($clinit_Collections() , $clinit_Collections() , EMPTY_LIST):new AbstractList$SubList(this$static.ports, castTo(indices.first, 21).value_0, castTo(indices.second, 21).value_0);
}

function $getPorts(this$static, portType){
  switch (portType.ordinal) {
    case 1:
      return filter_0(this$static.ports, ($clinit_LPort() , INPUT_PREDICATE));
    case 2:
      return filter_0(this$static.ports, ($clinit_LPort() , OUTPUT_PREDICATE));
    default:return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
}

function $getPorts_0(this$static, portType, side){
  var sidePredicate, typePredicate;
  typePredicate = null;
  switch (portType.ordinal) {
    case 1:
      typePredicate = ($clinit_LPort() , INPUT_PREDICATE);
      break;
    case 2:
      typePredicate = ($clinit_LPort() , OUTPUT_PREDICATE);
  }
  sidePredicate = null;
  switch (side.ordinal) {
    case 1:
      sidePredicate = ($clinit_LPort() , NORTH_PREDICATE);
      break;
    case 2:
      sidePredicate = ($clinit_LPort() , EAST_PREDICATE);
      break;
    case 3:
      sidePredicate = ($clinit_LPort() , SOUTH_PREDICATE);
      break;
    case 4:
      sidePredicate = ($clinit_LPort() , WEST_PREDICATE);
  }
  return !!typePredicate && !!sidePredicate?filter_0(this$static.ports, ($clinit_Predicates() , new Predicates$AndPredicate(new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lcom_google_common_base_Predicate_2_classLit, 1), $intern_1, 139, 0, [castTo(checkNotNull(typePredicate), 139), castTo(checkNotNull(sidePredicate), 139)]))))):($clinit_Collections() , $clinit_Collections() , EMPTY_LIST);
}

function $getPorts_1(this$static, side){
  switch (side.ordinal) {
    case 1:
      return filter_0(this$static.ports, ($clinit_LPort() , NORTH_PREDICATE));
    case 2:
      return filter_0(this$static.ports, ($clinit_LPort() , EAST_PREDICATE));
    case 3:
      return filter_0(this$static.ports, ($clinit_LPort() , SOUTH_PREDICATE));
    case 4:
      return filter_0(this$static.ports, ($clinit_LPort() , WEST_PREDICATE));
    default:return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
}

function $setLayer(this$static, index_0, newlayer){
  if (!!newlayer && (index_0 < 0 || index_0 > newlayer.nodes.array.length)) {
    throw toJs(new IllegalArgumentException_0('index must be >= 0 and <= layer node count'));
  }
  !!this$static.layer && $remove_13(this$static.layer.nodes, this$static);
  this$static.layer = newlayer;
  !!newlayer && $add_3(newlayer.nodes, index_0, this$static);
}

function $setLayer_0(this$static, thelayer){
  !!this$static.layer && $remove_13(this$static.layer.nodes, this$static);
  this$static.layer = thelayer;
  !!this$static.layer && $add_4(this$static.layer.nodes, this$static);
}

function $setType(this$static, type_0){
  this$static.type_0 = type_0;
}

function $toString_9(this$static){
  var name_0;
  return name_0 = $getName_0(this$static) , 'n_' + (name_0 == null?'' + this$static.id_0:name_0);
}

function LNode(graph){
  LShape.call(this);
  this.type_0 = ($clinit_LNode$NodeType() , NORMAL);
  this.ports = (checkNonnegative(6, 'initialArraySize') , new ArrayList_0(6));
  this.labels = (checkNonnegative(2, 'initialArraySize') , new ArrayList_0(2));
  this.margin = new LMargin;
  this.padding = new LPadding;
  this.graph_0 = graph;
}

defineClass(9, 373, {3:1, 288:1, 9:1, 373:1, 94:1, 130:1}, LNode);
_.toString_0 = function toString_89(){
  return $toString_9(this);
}
;
_.portSidesCached = false;
var Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LNode', 9);
function $clinit_LNode$NodeType(){
  $clinit_LNode$NodeType = emptyMethod;
  NORMAL = new LNode$NodeType('NORMAL', 0);
  LONG_EDGE = new LNode$NodeType('LONG_EDGE', 1);
  EXTERNAL_PORT = new LNode$NodeType('EXTERNAL_PORT', 2);
  NORTH_SOUTH_PORT = new LNode$NodeType('NORTH_SOUTH_PORT', 3);
  LABEL = new LNode$NodeType('LABEL', 4);
  BIG_NODE = new LNode$NodeType('BIG_NODE', 5);
  BREAKING_POINT = new LNode$NodeType('BREAKING_POINT', 6);
}

function LNode$NodeType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_29(name_0){
  $clinit_LNode$NodeType();
  return valueOf(($clinit_LNode$NodeType$Map() , $MAP_17), name_0);
}

function values_25(){
  $clinit_LNode$NodeType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_graph_LNode$NodeType_2_classLit, 1), $intern_38, 243, 0, [NORMAL, LONG_EDGE, EXTERNAL_PORT, NORTH_SOUTH_PORT, LABEL, BIG_NODE, BREAKING_POINT]);
}

defineClass(243, 22, {3:1, 34:1, 22:1, 243:1}, LNode$NodeType);
var BIG_NODE, BREAKING_POINT, EXTERNAL_PORT, LABEL, LONG_EDGE, NORMAL, NORTH_SOUTH_PORT;
var Lorg_eclipse_elk_alg_layered_graph_LNode$NodeType_2_classLit = createForEnum('org.eclipse.elk.alg.layered.graph', 'LNode/NodeType', 243, Ljava_lang_Enum_2_classLit, values_25, valueOf_29);
function $clinit_LNode$NodeType$Map(){
  $clinit_LNode$NodeType$Map = emptyMethod;
  $MAP_17 = createValueOfMap(($clinit_LNode$NodeType() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_graph_LNode$NodeType_2_classLit, 1), $intern_38, 243, 0, [NORMAL, LONG_EDGE, EXTERNAL_PORT, NORTH_SOUTH_PORT, LABEL, BIG_NODE, BREAKING_POINT])));
}

var $MAP_17;
function ElkPadding(){
  Spacing.call(this);
}

function ElkPadding_0(any){
  Spacing_0.call(this, any, any, any, any);
}

function ElkPadding_1(other){
  Spacing_0.call(this, other.top_0, other.right, other.bottom, other.left);
}

defineClass(116, 218, $intern_111, ElkPadding, ElkPadding_0, ElkPadding_1);
var Lorg_eclipse_elk_core_math_ElkPadding_2_classLit = createForClass('org.eclipse.elk.core.math', 'ElkPadding', 116);
function LPadding(){
  ElkPadding.call(this);
}

defineClass(710, 116, $intern_111, LPadding);
var Lorg_eclipse_elk_alg_layered_graph_LPadding_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPadding', 710);
function $clinit_LPort(){
  $clinit_LPort = emptyMethod;
  OUTPUT_PREDICATE = new LPort$1;
  INPUT_PREDICATE = new LPort$2;
  NORTH_PREDICATE = new LPort$3;
  EAST_PREDICATE = new LPort$4;
  SOUTH_PREDICATE = new LPort$5;
  WEST_PREDICATE = new LPort$6;
}

function $getAbsoluteAnchor(this$static){
  return sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [this$static.owner.pos, this$static.pos, this$static.anchor]));
}

function $getDegree(this$static){
  return this$static.incomingEdges.array.length + this$static.outgoingEdges.array.length;
}

function $getName_1(this$static){
  if (this$static.labels.array.length != 0) {
    return castTo($get_7(this$static.labels, 0), 70).text_0;
  }
  return null;
}

function $setNode(this$static, node){
  !!this$static.owner && $remove_13(this$static.owner.ports, this$static);
  this$static.owner = node;
  !!this$static.owner && $add_4(this$static.owner.ports, this$static);
}

function $setSide(this$static, theside){
  if (!theside) {
    throw toJs(new NullPointerException);
  }
  this$static.side = theside;
}

function LPort(){
  $clinit_LPort();
  LShape.call(this);
  this.side = ($clinit_PortSide() , UNDEFINED_7);
  this.anchor = new KVector;
  new LMargin;
  this.labels = (checkNonnegative(2, 'initialArraySize') , new ArrayList_0(2));
  this.incomingEdges = (checkNonnegative(4, 'initialArraySize') , new ArrayList_0(4));
  this.outgoingEdges = (checkNonnegative(4, 'initialArraySize') , new ArrayList_0(4));
  this.connectedEdges = new LPort$CombineIter(this.incomingEdges, this.outgoingEdges);
}

defineClass(11, 373, {3:1, 288:1, 11:1, 373:1, 94:1, 130:1}, LPort);
_.toString_0 = function toString_90(){
  var text_0;
  return text_0 = $getName_1(this) , text_0 == null?'p_' + this.id_0:'p_' + text_0;
}
;
_.anchorFixed = false;
var EAST_PREDICATE, INPUT_PREDICATE, NORTH_PREDICATE, OUTPUT_PREDICATE, SOUTH_PREDICATE, WEST_PREDICATE;
var Lorg_eclipse_elk_alg_layered_graph_LPort_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort', 11);
function $apply_13(port){
  return castTo(port, 11).outgoingEdges.array.length != 0;
}

function LPort$1(){
}

defineClass(1168, 1, $intern_91, LPort$1);
_.apply_1 = function apply_56(port){
  return $apply_13(port);
}
;
_.equals_0 = function equals_97(other){
  return this === other;
}
;
_.test_0 = function test_16(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/1', 1168);
function $apply_14(port){
  return castTo(port, 11).incomingEdges.array.length != 0;
}

function LPort$2(){
}

defineClass(1169, 1, $intern_91, LPort$2);
_.apply_1 = function apply_57(port){
  return $apply_14(port);
}
;
_.equals_0 = function equals_98(other){
  return this === other;
}
;
_.test_0 = function test_17(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$2_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/2', 1169);
function LPort$3(){
}

defineClass(1170, 1, $intern_91, LPort$3);
_.apply_1 = function apply_58(port){
  return castTo(port, 11).side == ($clinit_PortSide() , NORTH_1);
}
;
_.equals_0 = function equals_99(other){
  return this === other;
}
;
_.test_0 = function test_18(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$3_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/3', 1170);
function LPort$4(){
}

defineClass(1171, 1, $intern_91, LPort$4);
_.apply_1 = function apply_59(port){
  return castTo(port, 11).side == ($clinit_PortSide() , EAST_1);
}
;
_.equals_0 = function equals_100(other){
  return this === other;
}
;
_.test_0 = function test_19(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$4_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/4', 1171);
function LPort$5(){
}

defineClass(1172, 1, $intern_91, LPort$5);
_.apply_1 = function apply_60(port){
  return castTo(port, 11).side == ($clinit_PortSide() , SOUTH_1);
}
;
_.equals_0 = function equals_101(other){
  return this === other;
}
;
_.test_0 = function test_20(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$5_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/5', 1172);
function LPort$6(){
}

defineClass(1173, 1, $intern_91, LPort$6);
_.apply_1 = function apply_61(port){
  return castTo(port, 11).side == ($clinit_PortSide() , WEST_1);
}
;
_.equals_0 = function equals_102(other){
  return this === other;
}
;
_.test_0 = function test_21(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$6_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/6', 1173);
function LPort$7(this$0){
  this.this$01 = this$0;
}

defineClass(381, 1, $intern_27, LPort$7);
_.forEach_0 = function forEach_21(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_61(){
  var edgesIter;
  edgesIter = new ArrayList$1(this.this$01.incomingEdges);
  return new LPort$7$1(edgesIter);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$7_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/7', 381);
function LPort$7$1(val$edgesIter){
  this.val$edgesIter2 = val$edgesIter;
}

defineClass(1174, 1, $intern_4, LPort$7$1);
_.forEachRemaining = function forEachRemaining_41(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_38(){
  return castTo($next_10(this.val$edgesIter2), 16).source;
}
;
_.hasNext_0 = function hasNext_37(){
  return $hasNext_2(this.val$edgesIter2);
}
;
_.remove_0 = function remove_90(){
  $remove_14(this.val$edgesIter2);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$7$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/7/1', 1174);
function LPort$8(this$0){
  this.this$01 = this$0;
}

defineClass(346, 1, $intern_27, LPort$8);
_.forEach_0 = function forEach_22(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_62(){
  var edgesIter;
  return edgesIter = new ArrayList$1(this.this$01.outgoingEdges) , new LPort$8$1(edgesIter);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$8_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/8', 346);
function LPort$8$1(val$edgesIter){
  this.val$edgesIter2 = val$edgesIter;
}

defineClass(708, 1, $intern_4, LPort$8$1);
_.forEachRemaining = function forEachRemaining_42(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_39(){
  return castTo($next_10(this.val$edgesIter2), 16).target;
}
;
_.hasNext_0 = function hasNext_38(){
  return $hasNext_2(this.val$edgesIter2);
}
;
_.remove_0 = function remove_91(){
  $remove_14(this.val$edgesIter2);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$8$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/8/1', 708);
function LPort$CombineIter(firstIterable, secondIterable){
  this.firstIterable = firstIterable;
  this.secondIterable = secondIterable;
}

defineClass(1167, 1, $intern_27, LPort$CombineIter);
_.forEach_0 = function forEach_23(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_63(){
  return new LPort$CombineIter$1(this);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$CombineIter_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/CombineIter', 1167);
function $hasNext_5(this$static){
  return $hasNext_2(this$static.firstIterator) || $hasNext_2(this$static.secondIterator);
}

function LPort$CombineIter$1(this$1){
  this.this$11 = this$1;
  this.firstIterator = new ArrayList$1(this.this$11.firstIterable);
  this.secondIterator = new ArrayList$1(this.this$11.secondIterable);
}

defineClass(224, 1, $intern_4, LPort$CombineIter$1);
_.forEachRemaining = function forEachRemaining_43(consumer){
  $forEachRemaining(this, consumer);
}
;
_.remove_0 = function remove_92(){
  $remove_21();
}
;
_.hasNext_0 = function hasNext_39(){
  return $hasNext_5(this);
}
;
_.next_1 = function next_40(){
  return $hasNext_2(this.firstIterator)?$next_10(this.firstIterator):$next_10(this.secondIterator);
}
;
var Lorg_eclipse_elk_alg_layered_graph_LPort$CombineIter$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'LPort/CombineIter/1', 224);
function $getIndex_0(this$static){
  return $indexOf_3(this$static.owner.layers, this$static, 0);
}

function Layer(graph){
  this.size_0 = new KVector;
  this.nodes = new ArrayList;
  this.owner = graph;
}

defineClass(25, 288, {3:1, 20:1, 288:1, 25:1, 94:1, 130:1}, Layer);
_.forEach_0 = function forEach_24(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_64(){
  return new ArrayList$1(this.nodes);
}
;
_.toString_0 = function toString_91(){
  return 'L_' + $indexOf_3(this.owner.layers, this, 0) + $toString_1(this.nodes);
}
;
var Lorg_eclipse_elk_alg_layered_graph_Layer_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph', 'Layer', 25);
function $calculateMinimumGraphSize(elkgraph, lgraph){
  var configuredMinSize, minSize, nodeAdapter, sizeConstraints;
  if (!$getParent_2(elkgraph)) {
    return;
  }
  sizeConstraints = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , NODE_SIZE_CONSTRAINTS)), 190);
  if (sizeConstraints.size_0 == 0) {
    return;
  }
  maskUndefined($getProperty_0(elkgraph, PORT_CONSTRAINTS_0)) === maskUndefined(($clinit_PortConstraints() , UNDEFINED_6)) && $setProperty_1(elkgraph, PORT_CONSTRAINTS_0, FREE);
  new ElkGraphAdapters$ElkGraphAdapter($getParent_2(elkgraph));
  nodeAdapter = new ElkGraphAdapters$ElkNodeAdapter(null, elkgraph);
  minSize = process(nodeAdapter, false, true);
  $add_5(sizeConstraints, ($clinit_SizeConstraint() , MINIMUM_SIZE));
  configuredMinSize = castTo($getProperty(lgraph, NODE_SIZE_MINIMUM), 8);
  configuredMinSize.x_0 = $wnd.Math.max(minSize.x_0, configuredMinSize.x_0);
  configuredMinSize.y_0 = $wnd.Math.max(minSize.y_0, configuredMinSize.y_0);
}

function $calculateNetFlow(elkport){
  var elkgraph, incomingEdge, incomingEdge$iterator, inputPortVote, insideSelfLoopsEnabled, isInsideSelfLoop, isSelfLoop, outgoingEdge, outgoingEdge$iterator, outputPortVote, sourceNode, targetNode;
  elkgraph = $getParent_3(elkport);
  insideSelfLoopsEnabled = checkNotNull_1(castToBoolean($getProperty_0(elkgraph, ($clinit_LayeredOptions() , INSIDE_SELF_LOOPS_ACTIVATE))));
  outputPortVote = 0;
  inputPortVote = 0;
  for (outgoingEdge$iterator = new AbstractEList$EIterator((!elkport.outgoingEdges && (elkport.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 7, 4)) , elkport.outgoingEdges)); outgoingEdge$iterator.cursor != outgoingEdge$iterator.this$01_2.size_1();) {
    outgoingEdge = castTo($doNext(outgoingEdge$iterator), 100);
    isSelfLoop = $isSelfloop(outgoingEdge);
    isInsideSelfLoop = isSelfLoop && insideSelfLoopsEnabled && checkNotNull_1(castToBoolean($getProperty_0(outgoingEdge, INSIDE_SELF_LOOPS_YO)));
    targetNode = connectableShapeToNode(castTo($get_16((!outgoingEdge.targets && (outgoingEdge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, outgoingEdge, 5, 8)) , outgoingEdge.targets), 0), 97));
    isSelfLoop && isInsideSelfLoop?++inputPortVote:isSelfLoop && !isInsideSelfLoop?++outputPortVote:$getParent_2(targetNode) == elkgraph || targetNode == elkgraph?++inputPortVote:++outputPortVote;
  }
  for (incomingEdge$iterator = new AbstractEList$EIterator((!elkport.incomingEdges && (elkport.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 8, 5)) , elkport.incomingEdges)); incomingEdge$iterator.cursor != incomingEdge$iterator.this$01_2.size_1();) {
    incomingEdge = castTo($doNext(incomingEdge$iterator), 100);
    isSelfLoop = $isSelfloop(incomingEdge);
    isInsideSelfLoop = isSelfLoop && insideSelfLoopsEnabled && checkNotNull_1(castToBoolean($getProperty_0(incomingEdge, INSIDE_SELF_LOOPS_YO)));
    sourceNode = connectableShapeToNode(castTo($get_16((!incomingEdge.sources && (incomingEdge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, incomingEdge, 4, 7)) , incomingEdge.sources), 0), 97));
    isSelfLoop && isInsideSelfLoop?++outputPortVote:isSelfLoop && !isInsideSelfLoop?++inputPortVote:$getParent_2(sourceNode) == elkgraph || sourceNode == elkgraph?++outputPortVote:++inputPortVote;
  }
  return outputPortVote - inputPortVote;
}

function $checkEdgeValidity(edge){
  if ((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources).size_0 == 0) {
    throw toJs(new UnsupportedGraphException('Edges must have a source.'));
  }
   else if ((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets).size_0 == 0) {
    throw toJs(new UnsupportedGraphException('Edges must have a target.'));
  }
   else {
    !edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7));
    if (!(edge.sources.size_0 <= 1 && (!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets.size_0 <= 1))) {
      throw toJs(new UnsupportedGraphException('Hyperedges are not supported.'));
    }
  }
}

function $checkExternalPorts(elkgraph, graphProperties){
  var connectsToChild, elkedge, elkedge$iterator, elkport, enableSelfLoops, externalPortEdges, hasExternalPorts, hasHyperedges, isInsideSelfLoop, portIterator, portLabelPlacement;
  enableSelfLoops = checkNotNull_1(castToBoolean($getProperty_0(elkgraph, ($clinit_LayeredOptions() , INSIDE_SELF_LOOPS_ACTIVATE))));
  portLabelPlacement = castTo($getProperty_0(elkgraph, PORT_LABELS_PLACEMENT), 284);
  hasExternalPorts = false;
  hasHyperedges = false;
  portIterator = new AbstractEList$EIterator((!elkgraph.ports && (elkgraph.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, elkgraph, 9, 9)) , elkgraph.ports));
  while (portIterator.cursor != portIterator.this$01_2.size_1() && (!hasExternalPorts || !hasHyperedges)) {
    elkport = castTo($doNext(portIterator), 123);
    externalPortEdges = 0;
    for (elkedge$iterator = $iterator(concat_1((!elkport.incomingEdges && (elkport.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 8, 5)) , elkport.incomingEdges), (!elkport.outgoingEdges && (elkport.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 7, 4)) , elkport.outgoingEdges))); $hasNext_0(elkedge$iterator);) {
      elkedge = castTo($next_2(elkedge$iterator), 100);
      isInsideSelfLoop = enableSelfLoops && $isSelfloop(elkedge) && checkNotNull_1(castToBoolean($getProperty_0(elkedge, INSIDE_SELF_LOOPS_YO)));
      connectsToChild = $contains_11((!elkedge.sources && (elkedge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 4, 7)) , elkedge.sources), elkport)?elkgraph == $getParent_2(connectableShapeToNode(castTo($get_16((!elkedge.targets && (elkedge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 5, 8)) , elkedge.targets), 0), 97))):elkgraph == $getParent_2(connectableShapeToNode(castTo($get_16((!elkedge.sources && (elkedge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 4, 7)) , elkedge.sources), 0), 97)));
      if (isInsideSelfLoop || connectsToChild) {
        ++externalPortEdges;
        if (externalPortEdges > 1) {
          break;
        }
      }
    }
    externalPortEdges > 0?(hasExternalPorts = true):portLabelPlacement == ($clinit_PortLabelPlacement() , INSIDE_0) && (!elkport.labels && (elkport.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, elkport, 1, 7)) , elkport.labels).size_0 > 0 && (hasExternalPorts = true);
    externalPortEdges > 1 && (hasHyperedges = true);
  }
  hasExternalPorts && graphProperties.add_1(($clinit_GraphProperties() , EXTERNAL_PORTS));
  hasHyperedges && graphProperties.add_1(($clinit_GraphProperties() , HYPEREDGES));
}

function $createLGraph(elkgraph){
  var all, lPadding, lgraph, nodeLabelpadding, nodePadding, root;
  lgraph = new LGraph;
  $copyProperties(lgraph, elkgraph);
  maskUndefined($getProperty(lgraph, ($clinit_LayeredOptions() , DIRECTION))) === maskUndefined(($clinit_Direction_0() , UNDEFINED_3)) && $setProperty_0(lgraph, DIRECTION, getDirection_1(lgraph));
  if ($getProperty(lgraph, ($clinit_LabelManagementOptions() , LABEL_MANAGER)) == null) {
    root = castTo(getRootContainer(elkgraph), 202);
    $setProperty_0(lgraph, LABEL_MANAGER, throwClassCastExceptionUnlessNull(root.getProperty(LABEL_MANAGER)));
  }
  $setProperty_0(lgraph, ($clinit_InternalProperties_1() , ORIGIN_0), elkgraph);
  $setProperty_0(lgraph, GRAPH_PROPERTIES, (all = castTo($getEnumConstants(Lorg_eclipse_elk_alg_layered_options_GraphProperties_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0)));
  nodeLabelpadding = computeInsideNodeLabelPadding((!$getParent_2(elkgraph)?null:new ElkGraphAdapters$ElkGraphAdapter($getParent_2(elkgraph)) , new ElkGraphAdapters$ElkNodeAdapter(null, elkgraph)));
  nodePadding = castTo($getProperty(lgraph, PADDING_1), 116);
  lPadding = lgraph.padding;
  $add_15(lPadding, nodePadding);
  $add_15(lPadding, nodeLabelpadding);
  return lgraph;
}

function $ensureDefinedPortSide(lgraph, elkport){
  var layoutDirection, netFlow, portConstraints, portSide;
  layoutDirection = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , DIRECTION)), 107);
  portSide = castTo($getProperty_0(elkport, PORT_SIDE), 71);
  portConstraints = castTo($getProperty(lgraph, PORT_CONSTRAINTS_0), 83);
  if (portConstraints != ($clinit_PortConstraints() , FREE) && portConstraints != UNDEFINED_6) {
    if (portSide == ($clinit_PortSide() , UNDEFINED_7)) {
      portSide = calcPortSide_0(elkport, layoutDirection);
      portSide == UNDEFINED_7 && (portSide = fromDirection(layoutDirection));
    }
  }
   else {
    netFlow = $calculateNetFlow(elkport);
    netFlow > 0?(portSide = fromDirection(layoutDirection)):(portSide = $opposed(fromDirection(layoutDirection)));
  }
  $setProperty_1(elkport, PORT_SIDE, portSide);
}

function $findCoordinateSystemOrigin(this$static, elkedge, topLevelElkGraph, topLevelLGraph){
  var lgraph, lnode, origin, source, target;
  source = connectableShapeToNode(castTo($get_16((!elkedge.sources && (elkedge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 4, 7)) , elkedge.sources), 0), 97));
  target = connectableShapeToNode(castTo($get_16((!elkedge.targets && (elkedge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 5, 8)) , elkedge.targets), 0), 97));
  if ($getParent_2(source) == $getParent_2(target)) {
    return null;
  }
  if (isDescendant_0(target, source)) {
    return null;
  }
  origin = $getContainingNode(elkedge);
  if (origin == topLevelElkGraph) {
    return topLevelLGraph;
  }
   else {
    lnode = castTo($get_6(this$static.nodeAndPortMap, origin), 9);
    if (lnode) {
      lgraph = castTo($getProperty(lnode, ($clinit_InternalProperties_1() , NESTED_LGRAPH)), 32);
      if (lgraph) {
        return lgraph;
      }
    }
  }
  return null;
}

function $hasInsideSelfLoops(elknode){
  var edge, edge$iterator;
  if (checkNotNull_1(castToBoolean($getProperty_0(elknode, ($clinit_LayeredOptions() , INSIDE_SELF_LOOPS_ACTIVATE))))) {
    for (edge$iterator = $iterator(allOutgoingEdges(elknode)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 100);
      if ($isSelfloop(edge)) {
        if (checkNotNull_1(castToBoolean($getProperty_0(edge, INSIDE_SELF_LOOPS_YO)))) {
          return true;
        }
      }
    }
  }
  return false;
}

function $importFlatGraph(this$static, elkgraph, lgraph){
  var child, child$iterator, connectsSiblings, connectsToGraph, elkedge, elkedge$iterator, elkedge$iterator0, enableInsideSelfLoops, isInsideSelfLoop, isToBeLaidOut, source, target;
  for (child$iterator = new AbstractEList$EIterator((!elkgraph.children && (elkgraph.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, elkgraph, 10, 11)) , elkgraph.children)); child$iterator.cursor != child$iterator.this$01_2.size_1();) {
    child = castTo($doNext(child$iterator), 35);
    checkNotNull_1(castToBoolean($getProperty_0(child, ($clinit_LayeredOptions() , NO_LAYOUT)))) || $transformNode(this$static, child, lgraph);
  }
  for (elkedge$iterator0 = new AbstractEList$EIterator((!elkgraph.containedEdges && (elkgraph.containedEdges = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkgraph, 12, 3)) , elkgraph.containedEdges)); elkedge$iterator0.cursor != elkedge$iterator0.this$01_2.size_1();) {
    elkedge = castTo($doNext(elkedge$iterator0), 100);
    source = getSourceNode(elkedge);
    target = getTargetNode(elkedge);
    enableInsideSelfLoops = checkNotNull_1(castToBoolean($getProperty_0(source, ($clinit_LayeredOptions() , INSIDE_SELF_LOOPS_ACTIVATE))));
    isToBeLaidOut = !checkNotNull_1(castToBoolean($getProperty_0(elkedge, NO_LAYOUT)));
    isInsideSelfLoop = enableInsideSelfLoops && $isSelfloop(elkedge) && checkNotNull_1(castToBoolean($getProperty_0(elkedge, INSIDE_SELF_LOOPS_YO)));
    connectsSiblings = $getParent_2(source) == elkgraph && $getParent_2(source) == $getParent_2(target);
    connectsToGraph = ($getParent_2(source) == elkgraph && target == elkgraph) ^ ($getParent_2(target) == elkgraph && source == elkgraph);
    isToBeLaidOut && !isInsideSelfLoop && (connectsToGraph || connectsSiblings) && $transformEdge(this$static, elkedge, elkgraph, lgraph);
  }
  if ($getParent_2(elkgraph)) {
    for (elkedge$iterator = new AbstractEList$EIterator($getContainedEdges($getParent_2(elkgraph))); elkedge$iterator.cursor != elkedge$iterator.this$01_2.size_1();) {
      elkedge = castTo($doNext(elkedge$iterator), 100);
      source = getSourceNode(elkedge);
      if (source == elkgraph && $isSelfloop(elkedge)) {
        isInsideSelfLoop = checkNotNull_1(castToBoolean($getProperty_0(source, ($clinit_LayeredOptions() , INSIDE_SELF_LOOPS_ACTIVATE)))) && checkNotNull_1(castToBoolean($getProperty_0(elkedge, INSIDE_SELF_LOOPS_YO)));
        isInsideSelfLoop && $transformEdge(this$static, elkedge, elkgraph, lgraph);
      }
    }
  }
}

function $importGraph_1(this$static, elkgraph){
  var elkport, elkport$iterator, graphProperties, topLevelGraph;
  topLevelGraph = $createLGraph(elkgraph);
  $forEach_2(new Stream$StreamSource(null, (!elkgraph.ports && (elkgraph.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, elkgraph, 9, 9)) , new Spliterators$IteratorSpliterator(elkgraph.ports, 16))), new ElkGraphImporter$lambda$0$Type(topLevelGraph));
  graphProperties = castTo($getProperty(topLevelGraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19);
  $checkExternalPorts(elkgraph, graphProperties);
  if (graphProperties.contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
    for (elkport$iterator = new AbstractEList$EIterator((!elkgraph.ports && (elkgraph.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, elkgraph, 9, 9)) , elkgraph.ports)); elkport$iterator.cursor != elkport$iterator.this$01_2.size_1();) {
      elkport = castTo($doNext(elkport$iterator), 123);
      $transformExternalPort(this$static, elkgraph, topLevelGraph, elkport);
    }
  }
  $calculateMinimumGraphSize(elkgraph, topLevelGraph);
  checkNotNull_1(castToBoolean($getProperty(topLevelGraph, ($clinit_LayeredOptions() , PARTITIONING_ACTIVATE)))) && graphProperties.add_1(PARTITIONS);
  maskUndefined($getProperty_0(elkgraph, HIERARCHY_HANDLING)) === maskUndefined(($clinit_HierarchyHandling() , INCLUDE_CHILDREN))?$importHierarchicalGraph(this$static, elkgraph, topLevelGraph):$importFlatGraph(this$static, elkgraph, topLevelGraph);
  return topLevelGraph;
}

function $importHierarchicalGraph(this$static, elkgraph, lgraph){
  var coordinateSystemOrigin, edgeTargetNode, elkedge, elkedge$iterator, elknode, elknodeQueue, enableInsideSelfLoops, hasChildren, hasHierarchyHandlingEnabled, hasInsideSelfLoops, isInsideSelfLoop, isNodeToBeLaidOut, ledge, lnode, nestedGraph, parentGraphDirection, parentKGraph, parentLGraph, parentLNode;
  elknodeQueue = new LinkedList;
  parentGraphDirection = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , DIRECTION)), 107);
  $addAll(elknodeQueue, (!elkgraph.children && (elkgraph.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, elkgraph, 10, 11)) , elkgraph.children));
  while (elknodeQueue.size_0 != 0) {
    elknode = castTo(elknodeQueue.size_0 == 0?null:(checkCriticalElement(elknodeQueue.size_0 != 0) , $removeNode_0(elknodeQueue, elknodeQueue.header.next_0)), 35);
    isNodeToBeLaidOut = !checkNotNull_1(castToBoolean($getProperty_0(elknode, NO_LAYOUT)));
    if (isNodeToBeLaidOut) {
      parentLGraph = lgraph;
      parentLNode = castTo($get_6(this$static.nodeAndPortMap, $getParent_2(elknode)), 9);
      !!parentLNode && (parentLGraph = castTo($getProperty(parentLNode, ($clinit_InternalProperties_1() , NESTED_LGRAPH)), 32));
      lnode = $transformNode(this$static, elknode, parentLGraph);
      hasChildren = (!elknode.children && (elknode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, elknode, 10, 11)) , elknode.children).size_0 != 0;
      hasInsideSelfLoops = $hasInsideSelfLoops(elknode);
      hasHierarchyHandlingEnabled = maskUndefined($getProperty_0(elknode, HIERARCHY_HANDLING)) === maskUndefined(($clinit_HierarchyHandling() , INCLUDE_CHILDREN));
      if (hasHierarchyHandlingEnabled && (hasChildren || hasInsideSelfLoops)) {
        nestedGraph = $createLGraph(elknode);
        $setProperty_0(nestedGraph, DIRECTION, parentGraphDirection);
        $setProperty_0(lnode, ($clinit_InternalProperties_1() , NESTED_LGRAPH), nestedGraph);
        $setProperty_0(nestedGraph, PARENT_LNODE, lnode);
        $addAll(elknodeQueue, (!elknode.children && (elknode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, elknode, 10, 11)) , elknode.children));
      }
    }
  }
  $addNode_0(elknodeQueue, elkgraph, elknodeQueue.tail.prev, elknodeQueue.tail);
  while (elknodeQueue.size_0 != 0) {
    elknode = castTo(elknodeQueue.size_0 == 0?null:(checkCriticalElement(elknodeQueue.size_0 != 0) , $removeNode_0(elknodeQueue, elknodeQueue.header.next_0)), 35);
    enableInsideSelfLoops = checkNotNull_1(castToBoolean($getProperty_0(elknode, INSIDE_SELF_LOOPS_ACTIVATE)));
    if (!checkNotNull_1(castToBoolean($getProperty_0(elknode, NO_LAYOUT)))) {
      for (elkedge$iterator = $iterator(allOutgoingEdges(elknode)); $hasNext_0(elkedge$iterator);) {
        elkedge = castTo($next_2(elkedge$iterator), 100);
        if (!checkNotNull_1(castToBoolean($getProperty_0(elkedge, NO_LAYOUT)))) {
          $checkEdgeValidity(elkedge);
          isInsideSelfLoop = enableInsideSelfLoops && $isSelfloop(elkedge) && checkNotNull_1(castToBoolean($getProperty_0(elkedge, INSIDE_SELF_LOOPS_YO)));
          parentKGraph = $getParent_2(elknode);
          edgeTargetNode = connectableShapeToNode(castTo($get_16((!elkedge.targets && (elkedge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 5, 8)) , elkedge.targets), 0), 97));
          (isDescendant_0(edgeTargetNode, elknode) || isInsideSelfLoop) && (parentKGraph = elknode);
          parentLGraph = lgraph;
          parentLNode = castTo($get_6(this$static.nodeAndPortMap, parentKGraph), 9);
          !!parentLNode && (parentLGraph = castTo($getProperty(parentLNode, ($clinit_InternalProperties_1() , NESTED_LGRAPH)), 32));
          ledge = $transformEdge(this$static, elkedge, parentKGraph, parentLGraph);
          coordinateSystemOrigin = $findCoordinateSystemOrigin(this$static, elkedge, elkgraph, lgraph);
          !!coordinateSystemOrigin && $setProperty_0(ledge, ($clinit_InternalProperties_1() , COORDINATE_SYSTEM_ORIGIN), coordinateSystemOrigin);
        }
      }
      $addAll(elknodeQueue, (!elknode.children && (elknode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, elknode, 10, 11)) , elknode.children));
    }
  }
}

function $transformEdge(this$static, elkedge, elkparent, lgraph){
  var bendPointsRequired, crossMinStrat, edgeSection, elkSourceNode, elkSourceShape, elkTargetNode, elkTargetShape, elklabel, elklabel$iterator, graphProperties, importedBendpoints, ledge, llabel, nodePlaceStrat, originalBendpoints, point, point$iterator, portType, sourceElem, sourceLNode, sourceLPort, sourcePoint, targetElem, targetLNode, targetLPort, targetPoint;
  $checkEdgeValidity(elkedge);
  elkSourceShape = castTo($get_16((!elkedge.sources && (elkedge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 4, 7)) , elkedge.sources), 0), 97);
  elkTargetShape = castTo($get_16((!elkedge.targets && (elkedge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 5, 8)) , elkedge.targets), 0), 97);
  elkSourceNode = connectableShapeToNode(elkSourceShape);
  elkTargetNode = connectableShapeToNode(elkTargetShape);
  edgeSection = (!elkedge.sections && (elkedge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, elkedge, 6, 6)) , elkedge.sections).size_0 == 0?null:castTo($get_16((!elkedge.sections && (elkedge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, elkedge, 6, 6)) , elkedge.sections), 0), 228);
  sourceLNode = castTo($get_6(this$static.nodeAndPortMap, elkSourceNode), 9);
  targetLNode = castTo($get_6(this$static.nodeAndPortMap, elkTargetNode), 9);
  sourceLPort = null;
  targetLPort = null;
  if (instanceOf(elkSourceShape, 187)) {
    sourceElem = castTo($get_6(this$static.nodeAndPortMap, elkSourceShape), 288);
    if (instanceOf(sourceElem, 11)) {
      sourceLPort = castTo(sourceElem, 11);
    }
     else if (instanceOf(sourceElem, 9)) {
      sourceLNode = castTo(sourceElem, 9);
      sourceLPort = castTo($get_7(sourceLNode.ports, 0), 11);
    }
  }
  if (instanceOf(elkTargetShape, 187)) {
    targetElem = castTo($get_6(this$static.nodeAndPortMap, elkTargetShape), 288);
    if (instanceOf(targetElem, 11)) {
      targetLPort = castTo(targetElem, 11);
    }
     else if (instanceOf(targetElem, 9)) {
      targetLNode = castTo(targetElem, 9);
      targetLPort = castTo($get_7(targetLNode.ports, 0), 11);
    }
  }
  if (!sourceLNode || !targetLNode) {
    return null;
  }
  ledge = new LEdge;
  $copyProperties(ledge, elkedge);
  $setProperty_0(ledge, ($clinit_InternalProperties_1() , ORIGIN_0), elkedge);
  $setProperty_0(ledge, ($clinit_LayeredOptions() , JUNCTION_POINTS), null);
  graphProperties = castTo($getProperty(lgraph, GRAPH_PROPERTIES), 19);
  sourceLNode == targetLNode && graphProperties.add_1(($clinit_GraphProperties() , SELF_LOOPS));
  if (!sourceLPort) {
    portType = ($clinit_PortType() , OUTPUT);
    sourcePoint = null;
    if (!!edgeSection && $isSideFixed(castTo($getProperty(sourceLNode, PORT_CONSTRAINTS_0), 83))) {
      sourcePoint = new KVector_1(edgeSection.startX, edgeSection.startY);
      toAbsolute(sourcePoint, $getContainingNode(elkedge));
      toRelative(sourcePoint, elkparent);
      if (isDescendant_0(elkTargetNode, elkSourceNode)) {
        portType = INPUT;
        $add_19(sourcePoint, sourceLNode.pos);
      }
    }
    sourceLPort = createPort(sourceLNode, sourcePoint, portType, lgraph);
  }
  if (!targetLPort) {
    portType = ($clinit_PortType() , INPUT);
    targetPoint = null;
    if (!!edgeSection && $isSideFixed(castTo($getProperty(targetLNode, PORT_CONSTRAINTS_0), 83))) {
      targetPoint = new KVector_1(edgeSection.endX, edgeSection.endY);
      toAbsolute(targetPoint, $getContainingNode(elkedge));
      toRelative(targetPoint, elkparent);
    }
    targetLPort = createPort(targetLNode, targetPoint, portType, $getGraph(targetLNode));
  }
  $setSource_0(ledge, sourceLPort);
  $setTarget_0(ledge, targetLPort);
  for (elklabel$iterator = new AbstractEList$EIterator((!elkedge.labels && (elkedge.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, elkedge, 1, 7)) , elkedge.labels)); elklabel$iterator.cursor != elklabel$iterator.this$01_2.size_1();) {
    elklabel = castTo($doNext(elklabel$iterator), 135);
    if (!checkNotNull_1(castToBoolean($getProperty_0(elklabel, NO_LAYOUT))) && !!elklabel.text_0) {
      llabel = $transformLabel(elklabel);
      $add_4(ledge.labels, llabel);
      switch (castTo($getProperty(llabel, EDGE_LABELS_PLACEMENT), 236).ordinal) {
        case 2:
        case 3:
          graphProperties.add_1(($clinit_GraphProperties() , END_LABELS));
          break;
        case 1:
        case 0:
          graphProperties.add_1(($clinit_GraphProperties() , CENTER_LABELS));
          $setProperty_0(llabel, EDGE_LABELS_PLACEMENT, ($clinit_EdgeLabelPlacement() , CENTER_4));
      }
    }
  }
  crossMinStrat = castTo($getProperty(lgraph, CROSSING_MINIMIZATION_STRATEGY_0), 325);
  nodePlaceStrat = castTo($getProperty(lgraph, NODE_PLACEMENT_STRATEGY_0), 301);
  bendPointsRequired = crossMinStrat == ($clinit_CrossingMinimizationStrategy() , INTERACTIVE_1) || nodePlaceStrat == ($clinit_NodePlacementStrategy() , INTERACTIVE_4);
  if (!!edgeSection && (!edgeSection.bendPoints && (edgeSection.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, edgeSection, 5)) , edgeSection.bendPoints).size_0 != 0 && bendPointsRequired) {
    originalBendpoints = createVectorChain(edgeSection);
    importedBendpoints = new KVectorChain;
    for (point$iterator = $listIterator_1(originalBendpoints, 0); point$iterator.currentNode != point$iterator.this$01.tail;) {
      point = castTo($next_13(point$iterator), 8);
      $add_7(importedBendpoints, new KVector_2(point));
    }
    $setProperty_0(ledge, ORIGINAL_BENDPOINTS, importedBendpoints);
  }
  return ledge;
}

function $transformExternalPort(this$static, elkgraph, lgraph, elkport){
  var dummy, dummyPort, elklabel, elklabel$iterator, elkportPosition, graphSize, insidePortLabels, llabel, netFlow, portConstraints, portOffset, portSide;
  elkportPosition = new KVector_1(elkport.x_0 + elkport.width_0 / 2, elkport.y_0 + elkport.height / 2);
  netFlow = $calculateNetFlow(elkport);
  portConstraints = castTo($getProperty_0(elkgraph, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
  portSide = castTo($getProperty_0(elkport, PORT_SIDE), 71);
  if (!$containsKey_6($getAllProperties_0(elkport), PORT_BORDER_OFFSET)) {
    elkport.x_0 == 0 && elkport.y_0 == 0?(portOffset = 0):(portOffset = calcPortOffset_0(elkport, portSide));
    $setProperty_1(elkport, PORT_BORDER_OFFSET, portOffset);
  }
  graphSize = new KVector_1(elkgraph.width_0, elkgraph.height);
  dummy = createExternalPortDummy(elkport, portConstraints, portSide, netFlow, graphSize, elkportPosition, new KVector_1(elkport.width_0, elkport.height), castTo($getProperty(lgraph, DIRECTION), 107), lgraph);
  $setProperty_0(dummy, ($clinit_InternalProperties_1() , ORIGIN_0), elkport);
  dummyPort = castTo($get_7(dummy.ports, 0), 11);
  $setProperty_0(dummy, PORT_LABELS_PLACEMENT, ($clinit_PortLabelPlacement() , OUTSIDE_0));
  insidePortLabels = maskUndefined($getProperty_0(elkgraph, PORT_LABELS_PLACEMENT)) === maskUndefined(INSIDE_0);
  for (elklabel$iterator = new AbstractEList$EIterator((!elkport.labels && (elkport.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, elkport, 1, 7)) , elkport.labels)); elklabel$iterator.cursor != elklabel$iterator.this$01_2.size_1();) {
    elklabel = castTo($doNext(elklabel$iterator), 135);
    if (!checkNotNull_1(castToBoolean($getProperty_0(elklabel, NO_LAYOUT))) && !!elklabel.text_0) {
      llabel = $transformLabel(elklabel);
      $add_4(dummyPort.labels, llabel);
      if (!insidePortLabels) {
        switch (portSide.ordinal) {
          case 2:
          case 4:
            llabel.size_0.x_0 = 0;
            break;
          case 1:
          case 3:
            llabel.size_0.y_0 = 0;
        }
      }
    }
  }
  $setProperty_0(dummy, SPACING_LABEL_PORT, castToDouble($getProperty_0($getParent_2(elkgraph), SPACING_LABEL_PORT)));
  $setProperty_0(dummy, SPACING_LABEL_LABEL, castToDouble($getProperty_0($getParent_2(elkgraph), SPACING_LABEL_LABEL)));
  $add_4(lgraph.layerlessNodes, dummy);
  $put_1(this$static.nodeAndPortMap, elkport, dummy);
}

function $transformLabel(elklabel){
  var newLabel;
  newLabel = new LLabel_0(elklabel.text_0);
  $copyProperties(newLabel, elklabel);
  $setProperty_0(newLabel, ($clinit_InternalProperties_1() , ORIGIN_0), elklabel);
  newLabel.size_0.x_0 = elklabel.width_0;
  newLabel.size_0.y_0 = elklabel.height;
  newLabel.pos.x_0 = elklabel.x_0;
  newLabel.pos.y_0 = elklabel.y_0;
  return newLabel;
}

function $transformNode(this$static, elknode, lgraph){
  var direction, elklabel, elklabel$iterator, elkport, elkport$iterator, graphProperties, lnode, portConstraints;
  lnode = new LNode(lgraph);
  $copyProperties(lnode, elknode);
  $setProperty_0(lnode, ($clinit_InternalProperties_1() , ORIGIN_0), elknode);
  lnode.size_0.x_0 = elknode.width_0;
  lnode.size_0.y_0 = elknode.height;
  lnode.pos.x_0 = elknode.x_0;
  lnode.pos.y_0 = elknode.y_0;
  $add_4(lgraph.layerlessNodes, lnode);
  $put_1(this$static.nodeAndPortMap, elknode, lnode);
  ((!elknode.children && (elknode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, elknode, 10, 11)) , elknode.children).size_0 != 0 || checkNotNull_1(castToBoolean($getProperty_0(elknode, ($clinit_LayeredOptions() , INSIDE_SELF_LOOPS_ACTIVATE))))) && $setProperty_0(lnode, COMPOUND_NODE, ($clinit_Boolean() , $clinit_Boolean() , true));
  graphProperties = castTo($getProperty(lgraph, GRAPH_PROPERTIES), 19);
  portConstraints = castTo($getProperty(lnode, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
  portConstraints == ($clinit_PortConstraints() , UNDEFINED_6)?$setProperty_0(lnode, PORT_CONSTRAINTS_0, FREE):portConstraints != FREE && graphProperties.add_1(($clinit_GraphProperties() , NON_FREE_PORTS));
  direction = castTo($getProperty(lgraph, DIRECTION), 107);
  for (elkport$iterator = new AbstractEList$EIterator((!elknode.ports && (elknode.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, elknode, 9, 9)) , elknode.ports)); elkport$iterator.cursor != elkport$iterator.this$01_2.size_1();) {
    elkport = castTo($doNext(elkport$iterator), 123);
    checkNotNull_1(castToBoolean($getProperty_0(elkport, NO_LAYOUT))) || $transformPort(this$static, elkport, lnode, graphProperties, direction, portConstraints);
  }
  for (elklabel$iterator = new AbstractEList$EIterator((!elknode.labels && (elknode.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, elknode, 1, 7)) , elknode.labels)); elklabel$iterator.cursor != elklabel$iterator.this$01_2.size_1();) {
    elklabel = castTo($doNext(elklabel$iterator), 135);
    !checkNotNull_1(castToBoolean($getProperty_0(elklabel, NO_LAYOUT))) && !!elklabel.text_0 && $add_4(lnode.labels, $transformLabel(elklabel));
  }
  checkNotNull_1(castToBoolean($getProperty(lnode, COMMENT_BOX))) && graphProperties.add_1(($clinit_GraphProperties() , COMMENTS));
  if (checkNotNull_1(castToBoolean($getProperty(lnode, HYPERNODE)))) {
    graphProperties.add_1(($clinit_GraphProperties() , HYPERNODES));
    graphProperties.add_1(HYPEREDGES);
    $setProperty_0(lnode, PORT_CONSTRAINTS_0, FREE);
  }
  return lnode;
}

function $transformPort(this$static, elkport, parentLNode, graphProperties, layoutDirection, portConstraints){
  var connectionsToDescendants, elklabel, elklabel$iterator, lport, portPos, portSize;
  lport = new LPort;
  $copyProperties(lport, elkport);
  $setSide(lport, castTo($getProperty_0(elkport, ($clinit_LayeredOptions() , PORT_SIDE)), 71));
  $setProperty_0(lport, ($clinit_InternalProperties_1() , ORIGIN_0), elkport);
  $setNode(lport, parentLNode);
  portSize = lport.size_0;
  portSize.x_0 = elkport.width_0;
  portSize.y_0 = elkport.height;
  portPos = lport.pos;
  portPos.x_0 = elkport.x_0;
  portPos.y_0 = elkport.y_0;
  $put_1(this$static.nodeAndPortMap, elkport, lport);
  connectionsToDescendants = $anyMatch($map($flatMap(new Stream$StreamSource(null, (!elkport.outgoingEdges && (elkport.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 7, 4)) , new Spliterators$IteratorSpliterator(elkport.outgoingEdges, 16))), new ElkGraphImporter$lambda$1$Type), new ElkGraphImporter$0methodref$connectableShapeToNode$Type), new ElkGraphImporter$lambda$2$Type(elkport));
  connectionsToDescendants || (connectionsToDescendants = $anyMatch($map($flatMap(new Stream$StreamSource(null, (!elkport.incomingEdges && (elkport.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 8, 5)) , new Spliterators$IteratorSpliterator(elkport.incomingEdges, 16))), new ElkGraphImporter$lambda$3$Type), new ElkGraphImporter$1methodref$connectableShapeToNode$Type), new ElkGraphImporter$lambda$4$Type(elkport)));
  connectionsToDescendants || (connectionsToDescendants = $anyMatch(new Stream$StreamSource(null, (!elkport.outgoingEdges && (elkport.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 7, 4)) , new Spliterators$IteratorSpliterator(elkport.outgoingEdges, 16))), new ElkGraphImporter$lambda$5$Type));
  $setProperty_0(lport, INSIDE_CONNECTIONS, ($clinit_Boolean() , connectionsToDescendants?true:false));
  initializePort(lport, portConstraints, layoutDirection, castTo($getProperty_0(elkport, PORT_ANCHOR), 8));
  for (elklabel$iterator = new AbstractEList$EIterator((!elkport.labels && (elkport.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, elkport, 1, 7)) , elkport.labels)); elklabel$iterator.cursor != elklabel$iterator.this$01_2.size_1();) {
    elklabel = castTo($doNext(elklabel$iterator), 135);
    !checkNotNull_1(castToBoolean($getProperty_0(elklabel, NO_LAYOUT))) && !!elklabel.text_0 && $add_4(lport.labels, $transformLabel(elklabel));
  }
  (!elkport.incomingEdges && (elkport.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 8, 5)) , elkport.incomingEdges).size_0 + (!elkport.outgoingEdges && (elkport.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, elkport, 7, 4)) , elkport.outgoingEdges).size_0 > 1 && graphProperties.add_1(($clinit_GraphProperties() , HYPEREDGES));
  switch (layoutDirection.ordinal) {
    case 2:
    case 1:
      (lport.side == ($clinit_PortSide() , NORTH_1) || lport.side == SOUTH_1) && graphProperties.add_1(($clinit_GraphProperties() , NORTH_SOUTH_PORTS));
      break;
    case 4:
    case 3:
      (lport.side == ($clinit_PortSide() , EAST_1) || lport.side == WEST_1) && graphProperties.add_1(($clinit_GraphProperties() , NORTH_SOUTH_PORTS));
  }
  return lport;
}

function ElkGraphImporter(){
  this.nodeAndPortMap = ($clinit_Maps() , new HashMap);
}

function lambda$2_0(elkport_0, targetNode_1){
  return isDescendant_0(targetNode_1, $getParent_3(elkport_0));
}

function lambda$4_1(elkport_0, sourceNode_1){
  return isDescendant_0(sourceNode_1, $getParent_3(elkport_0));
}

defineClass(1201, 1, {}, ElkGraphImporter);
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter', 1201);
function ElkGraphImporter$0methodref$connectableShapeToNode$Type(){
}

defineClass(1204, 1, $intern_11, ElkGraphImporter$0methodref$connectableShapeToNode$Type);
_.apply_0 = function apply_62(arg0){
  return connectableShapeToNode(castTo(arg0, 97));
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter$0methodref$connectableShapeToNode$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter/0methodref$connectableShapeToNode$Type', 1204);
function ElkGraphImporter$1methodref$connectableShapeToNode$Type(){
}

defineClass(1207, 1, $intern_11, ElkGraphImporter$1methodref$connectableShapeToNode$Type);
_.apply_0 = function apply_63(arg0){
  return connectableShapeToNode(castTo(arg0, 97));
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter$1methodref$connectableShapeToNode$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter/1methodref$connectableShapeToNode$Type', 1207);
function ElkGraphImporter$lambda$0$Type(topLevelGraph_1){
  this.topLevelGraph_1 = topLevelGraph_1;
}

defineClass(1202, 1, {}, ElkGraphImporter$lambda$0$Type);
_.accept = function accept_52(arg0){
  $ensureDefinedPortSide(this.topLevelGraph_1, castTo(arg0, 187));
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter/lambda$0$Type', 1202);
function ElkGraphImporter$lambda$1$Type(){
}

defineClass(1203, 1, $intern_11, ElkGraphImporter$lambda$1$Type);
_.apply_0 = function apply_64(arg0){
  return new Stream$StreamSource(null, new Spliterators$IteratorSpliterator($getTargets(castTo(arg0, 173)), 16));
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter/lambda$1$Type', 1203);
function ElkGraphImporter$lambda$2$Type(elkport_0){
  this.elkport_0 = elkport_0;
}

defineClass(1205, 1, $intern_90, ElkGraphImporter$lambda$2$Type);
_.test_0 = function test_22(arg0){
  return lambda$2_0(this.elkport_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter/lambda$2$Type', 1205);
function ElkGraphImporter$lambda$3$Type(){
}

defineClass(1206, 1, $intern_11, ElkGraphImporter$lambda$3$Type);
_.apply_0 = function apply_65(arg0){
  return new Stream$StreamSource(null, new Spliterators$IteratorSpliterator($getSources(castTo(arg0, 173)), 16));
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter/lambda$3$Type', 1206);
function ElkGraphImporter$lambda$4$Type(elkport_0){
  this.elkport_0 = elkport_0;
}

defineClass(1208, 1, $intern_90, ElkGraphImporter$lambda$4$Type);
_.test_0 = function test_23(arg0){
  return lambda$4_1(this.elkport_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter/lambda$4$Type', 1208);
function ElkGraphImporter$lambda$5$Type(){
}

defineClass(1209, 1, $intern_90, ElkGraphImporter$lambda$5$Type);
_.test_0 = function test_24(arg0){
  return $isSelfloop(castTo(arg0, 173)) && checkNotNull_1(castToBoolean($getProperty_0(castTo(arg0, 173), ($clinit_LayeredOptions() , INSIDE_SELF_LOOPS_YO))));
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphImporter$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphImporter/lambda$5$Type', 1209);
function $clinit_ElkGraphLayoutTransferrer(){
  $clinit_ElkGraphLayoutTransferrer = emptyMethod;
  ZERO_OFFSET = new KVector;
}

function $applyEdgeLayout(ledge, routing, offset){
  var bendPoints, edgeOffset, elkedge, elkedgeSection, elklabel, junctionPoints, llabel, llabel$iterator, sourcePoint, sourcePort, targetPoint;
  elkedge = castTo($getProperty(ledge, ($clinit_InternalProperties_1() , ORIGIN_0)), 100);
  if (!elkedge) {
    return;
  }
   else if ($isSelfLoop(ledge) && routing != ($clinit_EdgeRouting() , ORTHOGONAL) && routing != ($clinit_EdgeRouting() , SPLINES)) {
    return;
  }
  bendPoints = ledge.bendPoints;
  edgeOffset = new KVector_2(offset);
  $add_19(edgeOffset, $calculateHierarchicalOffset(ledge));
  if (isDescendant(ledge.target.owner, ledge.source.owner)) {
    sourcePort = ledge.source;
    sourcePoint = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourcePort.pos, sourcePort.anchor]));
    $sub_0(sourcePoint, offset);
  }
   else {
    sourcePoint = $getAbsoluteAnchor(ledge.source);
  }
  $addNode_0(bendPoints, sourcePoint, bendPoints.header, bendPoints.header.next_0);
  targetPoint = $getAbsoluteAnchor(ledge.target);
  $getProperty(ledge, TARGET_OFFSET) != null && $add_19(targetPoint, castTo($getProperty(ledge, TARGET_OFFSET), 8));
  $addNode_0(bendPoints, targetPoint, bendPoints.tail.prev, bendPoints.tail);
  $offset_2(bendPoints, edgeOffset);
  elkedgeSection = firstEdgeSection(elkedge, true, true);
  applyVectorChain(bendPoints, elkedgeSection);
  for (llabel$iterator = new ArrayList$1(ledge.labels); llabel$iterator.i < llabel$iterator.this$01.array.length;) {
    llabel = castTo($next_10(llabel$iterator), 70);
    elklabel = castTo($getProperty(llabel, ORIGIN_0), 135);
    $setWidth_0(elklabel, llabel.size_0.x_0);
    $setHeight_0(elklabel, llabel.size_0.y_0);
    $setLocation(elklabel, llabel.pos.x_0 + edgeOffset.x_0, llabel.pos.y_0 + edgeOffset.y_0);
    $setProperty_1(elklabel, ($clinit_LabelDummySwitcher() , INCLUDE_LABEL), castToBoolean($getProperty(llabel, INCLUDE_LABEL)));
  }
  junctionPoints = castTo($getProperty(ledge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
  if (junctionPoints) {
    $offset_2(junctionPoints, edgeOffset);
    $setProperty_1(elkedge, JUNCTION_POINTS, junctionPoints);
  }
   else {
    $setProperty_1(elkedge, JUNCTION_POINTS, null);
  }
  routing == ($clinit_EdgeRouting() , SPLINES)?$setProperty_1(elkedge, EDGE_ROUTING, SPLINES):$setProperty_1(elkedge, EDGE_ROUTING, null);
}

function $applyLayout_2(this$static, lgraph){
  var edgeList, elkport, graphOrigin, lPadding, ledge, ledge$iterator, lnode, lnode$iterator, lnode$iterator0, nestedGraph, offset, padding, parentElkNode, parentLNode, port, port$iterator, portPosition, routing, sizeOptions;
  graphOrigin = $getProperty(lgraph, ($clinit_InternalProperties_1() , ORIGIN_0));
  if (!instanceOf(graphOrigin, 240)) {
    return;
  }
  parentElkNode = castTo(graphOrigin, 35);
  parentLNode = castTo($getProperty(lgraph, PARENT_LNODE), 9);
  offset = new KVector_2(lgraph.offset);
  lPadding = lgraph.padding;
  offset.x_0 += lPadding.left;
  offset.y_0 += lPadding.top_0;
  sizeOptions = castTo($getProperty_0(parentElkNode, ($clinit_LayeredOptions() , NODE_SIZE_OPTIONS)), 190);
  if ($containsEnum(sizeOptions, ($clinit_SizeOptions() , COMPUTE_PADDING))) {
    padding = castTo($getProperty_0(parentElkNode, PADDING_1), 116);
    $setBottom(padding, lPadding.bottom);
    $setTop(padding, lPadding.top_0);
    $setLeft(padding, lPadding.left);
    $setRight(padding, lPadding.right);
  }
  edgeList = new ArrayList;
  for (lnode$iterator0 = new ArrayList$1(lgraph.layerlessNodes); lnode$iterator0.i < lnode$iterator0.this$01.array.length;) {
    lnode = castTo($next_10(lnode$iterator0), 9);
    if (instanceOf($getProperty(lnode, ORIGIN_0), 240)) {
      $applyNodeLayout(lnode, offset);
    }
     else if (instanceOf($getProperty(lnode, ORIGIN_0), 187) && !parentLNode) {
      elkport = castTo($getProperty(lnode, ORIGIN_0), 123);
      portPosition = getExternalPortPosition(lgraph, lnode, elkport.width_0, elkport.height);
      $setLocation(elkport, portPosition.x_0, portPosition.y_0);
    }
    for (port$iterator = new ArrayList$1(lnode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(port.outgoingEdges, 16)), new ElkGraphLayoutTransferrer$lambda$0$Type(lnode)), new ElkGraphLayoutTransferrer$lambda$1$Type(edgeList));
    }
  }
  if (parentLNode) {
    for (port$iterator = new ArrayList$1(parentLNode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(port.outgoingEdges, 16)), new ElkGraphLayoutTransferrer$lambda$2$Type(parentLNode)), new ElkGraphLayoutTransferrer$lambda$3$Type(edgeList));
    }
  }
  routing = castTo($getProperty_0(parentElkNode, EDGE_ROUTING), 204);
  for (ledge$iterator = new ArrayList$1(edgeList); ledge$iterator.i < ledge$iterator.this$01.array.length;) {
    ledge = castTo($next_10(ledge$iterator), 16);
    $applyEdgeLayout(ledge, routing, offset);
  }
  $applyParentNodeLayout(lgraph);
  for (lnode$iterator = new ArrayList$1(lgraph.layerlessNodes); lnode$iterator.i < lnode$iterator.this$01.array.length;) {
    lnode = castTo($next_10(lnode$iterator), 9);
    nestedGraph = castTo($getProperty(lnode, NESTED_LGRAPH), 32);
    !!nestedGraph && $applyLayout_2(this$static, nestedGraph);
  }
}

function $applyNodeLayout(lnode, offset){
  var elklabel, elknode, elkport, llabel, llabel$iterator, llabel$iterator0, lport, lport$iterator, lport$iterator0, nf, nodeHasLabelPlacement, origin;
  elknode = castTo($getProperty(lnode, ($clinit_InternalProperties_1() , ORIGIN_0)), 35);
  $setX_1(elknode, lnode.pos.x_0 + offset.x_0);
  $setY_1(elknode, lnode.pos.y_0 + offset.y_0);
  if (castTo($getProperty_0(elknode, ($clinit_LayeredOptions() , NODE_SIZE_CONSTRAINTS)), 190).size_1() != 0 || $getProperty(lnode, NESTED_LGRAPH) != null || maskUndefined($getProperty($getGraph(lnode), NODE_PLACEMENT_STRATEGY_0)) === maskUndefined(($clinit_NodePlacementStrategy() , NETWORK_SIMPLEX_0)) && $isFlexibleSizeWhereSpacePermits(($clinit_NodeFlexibility() , (!lnode.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):lnode.propertyMap).containsKey(NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0)?(nf = castTo($getProperty(lnode, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0), 184)):(nf = castTo($getProperty($getGraph(lnode), NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_0), 184)) , nf))) {
    $setWidth_0(elknode, lnode.size_0.x_0);
    $setHeight_0(elknode, lnode.size_0.y_0);
  }
  for (lport$iterator0 = new ArrayList$1(lnode.ports); lport$iterator0.i < lport$iterator0.this$01.array.length;) {
    lport = castTo($next_10(lport$iterator0), 11);
    origin = $getProperty(lport, ORIGIN_0);
    if (instanceOf(origin, 187)) {
      elkport = castTo(origin, 123);
      $setLocation(elkport, lport.pos.x_0, lport.pos.y_0);
      $setProperty_1(elkport, PORT_SIDE, lport.side);
    }
  }
  nodeHasLabelPlacement = castTo($getProperty(lnode, NODE_LABELS_PLACEMENT), 190).size_1() != 0;
  for (llabel$iterator0 = new ArrayList$1(lnode.labels); llabel$iterator0.i < llabel$iterator0.this$01.array.length;) {
    llabel = castTo($next_10(llabel$iterator0), 70);
    if (nodeHasLabelPlacement || castTo($getProperty(llabel, NODE_LABELS_PLACEMENT), 190).size_1() != 0) {
      elklabel = castTo($getProperty(llabel, ORIGIN_0), 135);
      $setDimensions_0(elklabel, llabel.size_0.x_0, llabel.size_0.y_0);
      $setLocation(elklabel, llabel.pos.x_0, llabel.pos.y_0);
    }
  }
  if (maskUndefined($getProperty(lnode, PORT_LABELS_PLACEMENT)) !== maskUndefined(($clinit_PortLabelPlacement() , FIXED_2))) {
    for (lport$iterator = new ArrayList$1(lnode.ports); lport$iterator.i < lport$iterator.this$01.array.length;) {
      lport = castTo($next_10(lport$iterator), 11);
      for (llabel$iterator = new ArrayList$1(lport.labels); llabel$iterator.i < llabel$iterator.this$01.array.length;) {
        llabel = castTo($next_10(llabel$iterator), 70);
        elklabel = castTo($getProperty(llabel, ORIGIN_0), 135);
        $setWidth_0(elklabel, llabel.size_0.x_0);
        $setHeight_0(elklabel, llabel.size_0.y_0);
        $setLocation(elklabel, llabel.pos.x_0, llabel.pos.y_0);
      }
    }
  }
}

function $applyParentNodeLayout(lgraph){
  var actualGraphSize, all, elknode, graphProps, sizeConstraintsIncludedPortLabels;
  elknode = castTo($getProperty(lgraph, ($clinit_InternalProperties_1() , ORIGIN_0)), 35);
  sizeConstraintsIncludedPortLabels = castTo($getProperty_0(elknode, ($clinit_LayeredOptions() , NODE_SIZE_CONSTRAINTS)), 190).contains(($clinit_SizeConstraint() , PORT_LABELS));
  if ($getProperty(lgraph, PARENT_LNODE) == null) {
    graphProps = castTo($getProperty(lgraph, GRAPH_PROPERTIES), 19);
    actualGraphSize = new KVector_1(lgraph.size_0.x_0 + lgraph.padding.left + lgraph.padding.right, lgraph.size_0.y_0 + lgraph.padding.top_0 + lgraph.padding.bottom);
    if (graphProps.contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
      $setProperty_1(elknode, PORT_CONSTRAINTS_0, ($clinit_PortConstraints() , FIXED_POS));
      resizeNode_1(elknode, actualGraphSize.x_0, actualGraphSize.y_0, false, true);
    }
     else {
      resizeNode_1(elknode, actualGraphSize.x_0, actualGraphSize.y_0, true, true);
    }
  }
  sizeConstraintsIncludedPortLabels?$setProperty_1(elknode, NODE_SIZE_CONSTRAINTS, of_0(PORT_LABELS)):$setProperty_1(elknode, NODE_SIZE_CONSTRAINTS, (all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_SizeConstraint_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0)));
}

function $calculateHierarchicalOffset(ledge){
  var currentGraph, representingNode, result, targetCoordinateSystem;
  targetCoordinateSystem = castTo($getProperty(ledge, ($clinit_InternalProperties_1() , COORDINATE_SYSTEM_ORIGIN)), 32);
  if (targetCoordinateSystem) {
    result = new KVector;
    currentGraph = $getGraph(ledge.source.owner);
    while (currentGraph != targetCoordinateSystem) {
      representingNode = castTo($getProperty(currentGraph, PARENT_LNODE), 9);
      currentGraph = $getGraph(representingNode);
      $add_18($add_19($add_19(result, representingNode.pos), currentGraph.offset), currentGraph.padding.left, currentGraph.padding.top_0);
    }
    return result;
  }
  return ZERO_OFFSET;
}

function ElkGraphLayoutTransferrer(){
  $clinit_ElkGraphLayoutTransferrer();
}

function lambda$0_11(lnode_0, edge_1){
  $clinit_ElkGraphLayoutTransferrer();
  return !isDescendant(edge_1.target.owner, lnode_0);
}

function lambda$2_1(parentLNode_0, edge_1){
  $clinit_ElkGraphLayoutTransferrer();
  return isDescendant(edge_1.target.owner, parentLNode_0);
}

defineClass(1162, 1, {}, ElkGraphLayoutTransferrer);
var ZERO_OFFSET;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphLayoutTransferrer_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphLayoutTransferrer', 1162);
function ElkGraphLayoutTransferrer$lambda$0$Type(lnode_0){
  this.lnode_0 = lnode_0;
}

defineClass(1163, 1, $intern_90, ElkGraphLayoutTransferrer$lambda$0$Type);
_.test_0 = function test_25(arg0){
  return lambda$0_11(this.lnode_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphLayoutTransferrer$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphLayoutTransferrer/lambda$0$Type', 1163);
function ElkGraphLayoutTransferrer$lambda$1$Type(edgeList_0){
  this.edgeList_0 = edgeList_0;
}

defineClass(1164, 1, {}, ElkGraphLayoutTransferrer$lambda$1$Type);
_.accept = function accept_53(arg0){
  $clinit_ElkGraphLayoutTransferrer();
  $add_4(this.edgeList_0, castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphLayoutTransferrer$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphLayoutTransferrer/lambda$1$Type', 1164);
function ElkGraphLayoutTransferrer$lambda$2$Type(parentLNode_0){
  this.parentLNode_0 = parentLNode_0;
}

defineClass(1165, 1, $intern_90, ElkGraphLayoutTransferrer$lambda$2$Type);
_.test_0 = function test_26(arg0){
  return lambda$2_1(this.parentLNode_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphLayoutTransferrer$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphLayoutTransferrer/lambda$2$Type', 1165);
function ElkGraphLayoutTransferrer$lambda$3$Type(edgeList_0){
  this.edgeList_0 = edgeList_0;
}

defineClass(1166, 1, {}, ElkGraphLayoutTransferrer$lambda$3$Type);
_.accept = function accept_54(arg0){
  $clinit_ElkGraphLayoutTransferrer();
  $add_4(this.edgeList_0, castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_graph_transform_ElkGraphLayoutTransferrer$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.graph.transform', 'ElkGraphLayoutTransferrer/lambda$3$Type', 1166);
function $condenseBigNodesChain(this$static, start_0, left){
  var edge, edge$iterator, gap, newIndex, newLayer, outs, target;
  outs = newLinkedList($getOutgoingEdges(start_0));
  for (edge$iterator = $listIterator_1(outs, 0); edge$iterator.currentNode != edge$iterator.this$01.tail;) {
    edge = castTo($next_13(edge$iterator), 16);
    target = edge.target.owner;
    if (!(checkNotNull_1(castToBoolean($getProperty(target, ($clinit_InternalProperties_1() , BIG_NODE_INITIAL)))) && $getProperty(target, ORIGIN_0) != null) && target.type_0 == ($clinit_LNode$NodeType() , BIG_NODE) && !checkNotNull_1(castToBoolean($getProperty(edge, REVERSED))) && edge.target.side == ($clinit_PortSide() , WEST_1)) {
      gap = $getIndex_0(target.layer) - $getIndex_0(start_0.layer);
      if (gap > 1) {
        left?(newIndex = $getIndex_0(start_0.layer) + 1):(newIndex = $getIndex_0(target.layer) - 1);
        newLayer = castTo($get_7(this$static.layeredGraph.layers, newIndex), 25);
        $setLayer_0(target, newLayer);
      }
      $condenseBigNodesChain(this$static, target, left);
    }
  }
  return start_0;
}

function $process_2(this$static, theLayeredGraph, monitor){
  var bigNodes, last, layer, layer$iterator, node, node$iterator, nodes;
  $begin(monitor, 'Big nodes intermediate-processing', 1);
  this$static.layeredGraph = theLayeredGraph;
  for (layer$iterator = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    nodes = newLinkedList(layer.nodes);
    bigNodes = filter_0(nodes, new BigNodesIntermediateProcessor$1);
    for (node$iterator = filter_1(bigNodes.val$unfiltered1.iterator_0(), bigNodes.val$retainIfTrue2); $hasNext(node$iterator);) {
      node = castTo($next(node$iterator), 9);
      if (maskUndefined($getProperty(node, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0))) === maskUndefined(($clinit_LayerConstraint() , LAST)) || maskUndefined($getProperty(node, LAYERING_LAYER_CONSTRAINT_0)) === maskUndefined(LAST_SEPARATE)) {
        last = $condenseBigNodesChain(this$static, node, false);
        $setProperty_0(last, LAYERING_LAYER_CONSTRAINT_0, castTo($getProperty(node, LAYERING_LAYER_CONSTRAINT_0), 183));
        $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, NONE_4);
      }
       else {
        $condenseBigNodesChain(this$static, node, true);
      }
    }
  }
  $done_0(monitor);
}

function BigNodesIntermediateProcessor(){
}

defineClass(1359, 1, $intern_108, BigNodesIntermediateProcessor);
_.process = function process_1(theLayeredGraph, monitor){
  $process_2(this, castTo(theLayeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesIntermediateProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesIntermediateProcessor', 1359);
function $apply_15(node){
  return checkNotNull_1(castToBoolean($getProperty(node, ($clinit_InternalProperties_1() , BIG_NODE_INITIAL)))) && $getProperty(node, ORIGIN_0) != null;
}

function BigNodesIntermediateProcessor$1(){
}

defineClass(1360, 1, $intern_91, BigNodesIntermediateProcessor$1);
_.apply_1 = function apply_66(node){
  return $apply_15(castTo(node, 9));
}
;
_.equals_0 = function equals_103(other){
  return this === other;
}
;
_.test_0 = function test_27(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesIntermediateProcessor$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesIntermediateProcessor/1', 1360);
function $apply_16(this$static){
  var f, f$array, f$index, f$max;
  for (f$array = this$static.funs , f$index = 0 , f$max = f$array.length; f$index < f$max; ++f$index) {
    f = f$array[f$index];
    f.apply_0(null);
  }
  return null;
}

function BigNodesLabelHandler$CompoundFunction(funs){
  this.funs = funs;
}

function of_5(funs){
  var f, f$iterator, funsArr, i;
  funsArr = initUnidimensionalArray(Lcom_google_common_base_Function_2_classLit, $intern_1, 147, funs.array.length, 0, 1);
  i = 0;
  for (f$iterator = new ArrayList$1(funs); f$iterator.i < f$iterator.this$01.array.length;) {
    f = castTo($next_10(f$iterator), 147);
    funsArr[i++] = f;
  }
  return new BigNodesLabelHandler$CompoundFunction(funsArr);
}

defineClass(1599, 1, $intern_25, BigNodesLabelHandler$CompoundFunction);
_.apply_0 = function apply_67(v){
  var lastArg;
  return $apply_16((lastArg = this , throwClassCastExceptionUnlessNull(v) , lastArg));
}
;
_.equals_0 = function equals_104(other){
  return this === other;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesLabelHandler$CompoundFunction_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesLabelHandler/CompoundFunction', 1599);
function $handleLabels(this$static){
  var i, l, l$iterator, placement, postProcess;
  $setProperty_0(this$static.node, ($clinit_InternalProperties_1() , BIGNODES_ORIG_LABELS), newLinkedList(this$static.node.labels));
  for (i = 1; i < this$static.dummies.array.length - 1; ++i) {
    $setProperty_0(castTo($get_7(this$static.dummies, i), 9), ($clinit_LayeredOptions() , NODE_LABELS_PLACEMENT), ($clinit_NodeLabelPlacement() , of_1(INSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [V_CENTER_0, H_CENTER_0]))));
  }
  for (l$iterator = $listIterator_1(newLinkedList(this$static.node.labels), 0); l$iterator.currentNode != l$iterator.this$01.tail;) {
    l = castTo($next_13(l$iterator), 70);
    placement = castTo($getProperty(this$static.node, ($clinit_LayeredOptions() , NODE_LABELS_PLACEMENT)), 190);
    if ($containsAll(placement, of_1(($clinit_NodeLabelPlacement() , OUTSIDE), stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_LEFT_0, V_CENTER_0]))))
    ;
    else if ($containsAll(placement, of_1(OUTSIDE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_RIGHT_0, V_CENTER_0])))) {
      $add_4(this$static.lastDummy.labels, l);
      $remove_13(this$static.node.labels, l);
      postProcess = new BigNodesLabelHandler$Handler$2(this$static, l);
      $setProperty_0(this$static.node, BIGNODES_POST_PROCESS, postProcess);
    }
     else {
      $splitAndDistributeLabel(this$static, l);
      $add_4(this$static.postProcs, this$static.funRemoveLabelDummies);
      $setProperty_0(this$static.node, BIGNODES_POST_PROCESS, of_5(this$static.postProcs));
    }
  }
}

function $splitAndDistributeLabel(this$static, lab){
  var dumLab, dummy, fun, i, lPos, labelChunkSize, length_0, rPos, subLabel, text_0;
  length_0 = lab.text_0.length;
  labelChunkSize = round_int($wnd.Math.ceil(length_0 / this$static.chunks));
  text_0 = lab.text_0;
  lPos = 0;
  rPos = labelChunkSize;
  for (i = 0; i < this$static.chunks; ++i) {
    subLabel = text_0.substr((0 > lPos?0:lPos) < length_0?0 > lPos?0:lPos:length_0, (0 > (rPos < length_0?rPos:length_0)?0:rPos < length_0?rPos:length_0) - ((0 > lPos?0:lPos) < length_0?0 > lPos?0:lPos:length_0));
    lPos = rPos;
    rPos += labelChunkSize;
    dummy = castTo($get_7(this$static.dummies, i), 9);
    dumLab = new LLabel_0(subLabel);
    dumLab.size_0.y_0 = lab.size_0.y_0;
    $put(this$static.dumLabs, lab, dumLab);
    $add_4(dummy.labels, dumLab);
  }
  $remove_13(this$static.node.labels, lab);
  $add_4(this$static.postProcs, (fun = new BigNodesLabelHandler$Handler$3(this$static, lab) , fun));
}

function BigNodesLabelHandler$Handler(node, dummies, chunkWidth){
  this.dumLabs = new ArrayListMultimap;
  this.postProcs = new ArrayList;
  this.funRemoveLabelDummies = new BigNodesLabelHandler$Handler$1(this);
  this.node = node;
  this.chunks = dummies.array.length;
  this.dummies = dummies;
  this.lastDummy = castTo($get_7(this.dummies, this.dummies.array.length - 1), 9);
  this.minWidth = chunkWidth;
  $handleLabels(this);
}

defineClass(752, 1, {}, BigNodesLabelHandler$Handler);
_.chunks = 0;
_.lastDummy = null;
_.minWidth = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesLabelHandler$Handler_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesLabelHandler/Handler', 752);
function $apply_17(this$static){
  var dummy, dummy$iterator, l, l$iterator;
  for (dummy$iterator = new ArrayList$1(this$static.this$11.dummies); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
    dummy = castTo($next_10(dummy$iterator), 9);
    for (l$iterator = $listIterator_1(newLinkedList(dummy.labels), 0); l$iterator.currentNode != l$iterator.this$01.tail;) {
      l = castTo($next_13(l$iterator), 70);
      $getProperty(l, ($clinit_InternalProperties_1() , ORIGIN_0)) == null && $remove_13(dummy.labels, l);
    }
  }
  return null;
}

function BigNodesLabelHandler$Handler$1(this$1){
  this.this$11 = this$1;
}

defineClass(1600, 1, $intern_25, BigNodesLabelHandler$Handler$1);
_.apply_0 = function apply_68(v){
  var lastArg;
  return $apply_17((lastArg = this , throwClassCastExceptionUnlessNull(v) , lastArg));
}
;
_.equals_0 = function equals_105(other){
  return this === other;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesLabelHandler$Handler$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesLabelHandler/Handler/1', 1600);
function $apply_18(this$static){
  this$static.val$l2.pos.x_0 += this$static.this$11.minWidth * (this$static.this$11.chunks - 1);
  return null;
}

function BigNodesLabelHandler$Handler$2(this$1, val$l){
  this.this$11 = this$1;
  this.val$l2 = val$l;
}

defineClass(1601, 1, $intern_25, BigNodesLabelHandler$Handler$2);
_.apply_0 = function apply_69(v){
  var lastArg;
  return $apply_18((lastArg = this , throwClassCastExceptionUnlessNull(v) , lastArg));
}
;
_.equals_0 = function equals_106(other){
  return this === other;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesLabelHandler$Handler$2_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesLabelHandler/Handler/2', 1601);
function $apply_19(this$static){
  var all, dumLab, placement, rightMostDum, rightMostLab, rightOffset;
  placement = castTo($getProperty(this$static.this$11.node, ($clinit_LayeredOptions() , NODE_LABELS_PLACEMENT)), 190);
  if ($equals_0(placement, ($clinit_NodeLabelPlacement() , all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0))))
  ;
  else if ($containsAll(placement, of_0(H_LEFT_0))) {
    dumLab = castTo(castTo($get_0(this$static.this$11.dumLabs, this$static.val$label2), 15).get_3(0), 70);
    this$static.val$label2.pos.x_0 = dumLab.pos.x_0;
    this$static.val$label2.pos.y_0 = dumLab.pos.y_0;
  }
   else if ($containsAll(placement, of_0(H_RIGHT_0))) {
    rightMostDum = castTo($get_7(this$static.this$11.dummies, this$static.this$11.dummies.array.length - 1), 9);
    rightMostLab = castTo(castTo($get_0(this$static.this$11.dumLabs, this$static.val$label2), 15).get_3(castTo($get_0(this$static.this$11.dumLabs, this$static.val$label2), 15).size_1() - 1), 70);
    rightOffset = rightMostDum.size_0.x_0 - (rightMostLab.pos.x_0 + rightMostLab.size_0.x_0);
    this$static.val$label2.pos.x_0 = this$static.this$11.node.size_0.x_0 - rightOffset - this$static.val$label2.size_0.x_0;
    this$static.val$label2.pos.y_0 = rightMostLab.pos.y_0;
  }
   else if ($containsAll(placement, of_1(V_CENTER_0, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_CENTER_0])))) {
    dumLab = castTo(castTo($get_0(this$static.this$11.dumLabs, this$static.val$label2), 15).get_3(0), 70);
    this$static.val$label2.pos.x_0 = (this$static.this$11.node.size_0.x_0 - this$static.val$label2.size_0.x_0) / 2;
    this$static.val$label2.pos.y_0 = dumLab.pos.y_0;
  }
   else if ($containsAll(placement, of_0(V_CENTER_0))) {
    dumLab = castTo(castTo($get_0(this$static.this$11.dumLabs, this$static.val$label2), 15).get_3(0), 70);
    this$static.val$label2.pos.y_0 = dumLab.pos.y_0;
  }
   else if ($containsAll(placement, of_0(H_CENTER_0))) {
    dumLab = castTo(castTo($get_0(this$static.this$11.dumLabs, this$static.val$label2), 15).get_3(0), 70);
    this$static.val$label2.pos.x_0 = (this$static.this$11.node.size_0.x_0 - this$static.val$label2.size_0.x_0) / 2;
    this$static.val$label2.pos.y_0 = dumLab.pos.y_0;
  }
  return null;
}

function BigNodesLabelHandler$Handler$3(this$1, val$label){
  this.this$11 = this$1;
  this.val$label2 = val$label;
}

defineClass(1602, 1, $intern_25, BigNodesLabelHandler$Handler$3);
_.apply_0 = function apply_70(v){
  var lastArg;
  return $apply_19((lastArg = this , throwClassCastExceptionUnlessNull(v) , lastArg));
}
;
_.equals_0 = function equals_107(other){
  return this === other;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesLabelHandler$Handler$3_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesLabelHandler/Handler/3', 1602);
function $process_3(this$static, theLayeredGraph, monitor){
  var bigNodes, f, labels, lastDummy, layer, layer$iterator, node, node$iterator, offset, originalSize, p, p$iterator, p$iterator0, toMove;
  $begin(monitor, 'Big nodes post-processing', 1);
  this$static.layeredGraph = theLayeredGraph;
  for (layer$iterator = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    bigNodes = filter_0(layer.nodes, new BigNodesPostProcessor$1);
    for (node$iterator = filter_1(bigNodes.val$unfiltered1.iterator_0(), bigNodes.val$retainIfTrue2); $hasNext(node$iterator);) {
      node = castTo($next(node$iterator), 9);
      originalSize = castTo($getProperty(node, ($clinit_InternalProperties_1() , BIG_NODE_ORIGINAL_SIZE)), 128);
      lastDummy = $removeBigNodeChain(this$static, node);
      toMove = new ArrayList;
      for (p$iterator0 = $getPorts_1(lastDummy, ($clinit_PortSide() , EAST_1)).iterator_0(); p$iterator0.hasNext_0();) {
        p = castTo(p$iterator0.next_1(), 11);
        toMove.array[toMove.array.length] = p;
        offset = p.pos.x_0 - lastDummy.size_0.x_0;
        p.pos.x_0 = originalSize.value_0 + offset;
      }
      node.size_0.x_0 = originalSize.value_0;
      for (p$iterator = new ArrayList$1(toMove); p$iterator.i < p$iterator.this$01.array.length;) {
        p = castTo($next_10(p$iterator), 11);
        $setNode(p, node);
      }
      this$static.layeredGraph.size_0.x_0 < node.pos.x_0 + node.size_0.x_0 && (this$static.layeredGraph.size_0.x_0 = node.pos.x_0 + node.size_0.x_0);
      labels = castTo($getProperty(node, BIGNODES_ORIG_LABELS), 15);
      $addAll_2(node.labels, labels);
      f = castTo($getProperty(node, BIGNODES_POST_PROCESS), 147);
      !!f && f.apply_0(null);
    }
  }
  $done_0(monitor);
}

function $removeBigNodeChain(this$static, start_0){
  var edge, edge$iterator, outs, target;
  outs = newLinkedList($getOutgoingEdges(start_0));
  for (edge$iterator = $listIterator_1(outs, 0); edge$iterator.currentNode != edge$iterator.this$01.tail;) {
    edge = castTo($next_13(edge$iterator), 16);
    target = edge.target.owner;
    if (target.type_0 == ($clinit_LNode$NodeType() , BIG_NODE) && !(checkNotNull_1(castToBoolean($getProperty(target, ($clinit_InternalProperties_1() , BIG_NODE_INITIAL)))) && $getProperty(target, ORIGIN_0) != null)) {
      $remove_13(target.layer.nodes, target);
      $setNode(edge.source, null);
      $setNode(edge.target, null);
      return $removeBigNodeChain(this$static, target);
    }
     else {
      return start_0;
    }
  }
  return start_0;
}

function BigNodesPostProcessor(){
}

defineClass(1361, 1, $intern_108, BigNodesPostProcessor);
_.process = function process_2(theLayeredGraph, monitor){
  $process_3(this, castTo(theLayeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesPostProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesPostProcessor', 1361);
function $apply_20(node){
  return checkNotNull_1(castToBoolean($getProperty(node, ($clinit_InternalProperties_1() , BIG_NODE_INITIAL)))) && $getProperty(node, ORIGIN_0) != null;
}

function BigNodesPostProcessor$1(){
}

defineClass(1362, 1, $intern_91, BigNodesPostProcessor$1);
_.apply_1 = function apply_71(node){
  return $apply_20(castTo(node, 9));
}
;
_.equals_0 = function equals_108(other){
  return this === other;
}
;
_.test_0 = function test_28(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesPostProcessor$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesPostProcessor/1', 1362);
function $isProcessorApplicable(node){
  var edge, edge$iterator, p, p$iterator, port, port$iterator;
  if (maskUndefined($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0))) === maskUndefined(($clinit_PortConstraints() , FIXED_RATIO)) || maskUndefined($getProperty(node, PORT_CONSTRAINTS_0)) === maskUndefined(FIXED_POS)) {
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      if (port.side == ($clinit_PortSide() , NORTH_1) || port.side == SOUTH_1) {
        return false;
      }
    }
  }
  if ($isSideFixed(castTo($getProperty(node, PORT_CONSTRAINTS_0), 83))) {
    for (p$iterator = $getPorts_1(node, ($clinit_PortSide() , EAST_1)).iterator_0(); p$iterator.hasNext_0();) {
      p = castTo(p$iterator.next_1(), 11);
      if (p.incomingEdges.array.length != 0) {
        return false;
      }
    }
  }
  for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 16);
    if (edge.source.owner == edge.target.owner) {
      return false;
    }
  }
  return true;
}

function $process_4(this$static, theLayeredGraph, monitor){
  var bigNodes, chunkWidth, counter, minWidth, node, node$iterator, node$iterator0, node$iterator1, node$iterator2, nodes, parts, threshold;
  $begin(monitor, 'Big nodes pre-processing', 1);
  this$static.layeredGraph = theLayeredGraph;
  nodes = this$static.layeredGraph.layerlessNodes;
  counter = 0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    node.id_0 = counter++;
  }
  this$static.spacing = checkNotNull_1(castToDouble($getProperty(this$static.layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
  this$static.direction = castTo($getProperty(this$static.layeredGraph, DIRECTION), 107);
  this$static.dummyID = nodes.array.length;
  minWidth = $intern_61;
  for (node$iterator1 = new ArrayList$1(nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
    node = castTo($next_10(node$iterator1), 9);
    node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && node.size_0.x_0 < minWidth && (minWidth = node.size_0.x_0);
  }
  minWidth = $wnd.Math.max(50, minWidth);
  bigNodes = new ArrayList;
  threshold = minWidth + this$static.spacing;
  for (node$iterator2 = new ArrayList$1(nodes); node$iterator2.i < node$iterator2.this$01.array.length;) {
    node = castTo($next_10(node$iterator2), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && node.size_0.x_0 > threshold) {
      parts = 1;
      chunkWidth = node.size_0.x_0;
      while (chunkWidth > minWidth) {
        ++parts;
        chunkWidth = (node.size_0.x_0 - (parts - 1) * this$static.spacing) / parts;
      }
      $add_4(bigNodes, new BigNodesPreProcessor$BigNode(this$static, node, parts, chunkWidth));
    }
  }
  for (node$iterator = new ArrayList$1(bigNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 610);
    $isProcessorApplicable(node.node) && $process_5(node);
  }
  $done_0(monitor);
}

function BigNodesPreProcessor(){
  this.direction = ($clinit_Direction_0() , UNDEFINED_3);
}

defineClass(1363, 1, $intern_108, BigNodesPreProcessor);
_.process = function process_3(theLayeredGraph, monitor){
  $process_4(this, castTo(theLayeredGraph, 32), monitor);
}
;
_.dummyID = 0;
_.spacing = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesPreProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesPreProcessor', 1363);
function $process_5(this$static){
  var dummyWidth, e, e$iterator, eastPorts, originalWidth, port, port$iterator, port$iterator0, start_0, tmpChunks, dummy, outPort, inPort, edge;
  eastPorts = new ArrayList;
  for (port$iterator0 = new ArrayList$1(this$static.node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
    port = castTo($next_10(port$iterator0), 11);
    port.side == ($clinit_PortSide() , EAST_1) && (eastPorts.array[eastPorts.array.length] = port , true);
  }
  if (this$static.this$01.direction == ($clinit_Direction_0() , RIGHT_5) && !$isSideFixed(castTo($getProperty(this$static.node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
    for (e$iterator = $iterator($getOutgoingEdges(this$static.node)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      $add_4(eastPorts, e.source);
    }
  }
  originalWidth = this$static.node.size_0.x_0;
  $setProperty_0(this$static.node, ($clinit_InternalProperties_1() , BIG_NODE_ORIGINAL_SIZE), new Float(this$static.node.size_0.x_0));
  this$static.node.size_0.x_0 = this$static.minWidth;
  $setProperty_0(this$static.node, BIG_NODE_INITIAL, ($clinit_Boolean() , $clinit_Boolean() , true));
  $add_4(this$static.dummies, this$static.node);
  start_0 = this$static.node;
  originalWidth -= this$static.minWidth;
  tmpChunks = this$static.chunks;
  while (tmpChunks > 1) {
    dummyWidth = $wnd.Math.min(originalWidth, this$static.minWidth);
    start_0 = (dummy = new LNode(this$static.this$01.layeredGraph) , $setType(dummy, ($clinit_LNode$NodeType() , BIG_NODE)) , $setProperty_0(dummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), castTo($getProperty(start_0, PORT_CONSTRAINTS_0), 83)) , $setProperty_0(dummy, NODE_LABELS_PLACEMENT, castTo($getProperty(start_0, NODE_LABELS_PLACEMENT), 190)) , dummy.id_0 = this$static.this$01.dummyID++ , $add_4(this$static.dummies, dummy) , dummy.size_0.y_0 = start_0.size_0.y_0 , dummy.size_0.x_0 = dummyWidth , outPort = new LPort , $setSide(outPort, ($clinit_PortSide() , EAST_1)) , $setNode(outPort, start_0) , outPort.pos.x_0 = dummy.size_0.x_0 , outPort.pos.y_0 = dummy.size_0.y_0 / 2 , inPort = new LPort , $setSide(inPort, WEST_1) , $setNode(inPort, dummy) , inPort.pos.y_0 = dummy.size_0.y_0 / 2 , inPort.pos.x_0 = -inPort.size_0.x_0 , edge = new LEdge , $setSource_0(edge, outPort) , $setTarget_0(edge, inPort) , dummy);
    $add_4(this$static.this$01.layeredGraph.layerlessNodes, start_0);
    --tmpChunks;
    originalWidth -= this$static.minWidth + this$static.this$01.spacing;
  }
  new BigNodesLabelHandler$Handler(this$static.node, this$static.dummies, this$static.minWidth);
  for (port$iterator = new ArrayList$1(eastPorts); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $remove_13(this$static.node.ports, port);
    $setNode(port, start_0);
  }
}

function BigNodesPreProcessor$BigNode(this$0, node, chunks, minWidth){
  this.this$01 = this$0;
  this.dummies = new ArrayList;
  this.node = node;
  this.chunks = chunks;
  this.minWidth = minWidth;
}

defineClass(610, 1, {610:1}, BigNodesPreProcessor$BigNode);
_.chunks = 0;
_.minWidth = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesPreProcessor$BigNode_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesPreProcessor/BigNode', 610);
function $isProcessorApplicable_0(node){
  var eastwardEdges, edge, edge$iterator, hasIncoming, hasOutgoing, p, p$iterator, p$iterator0, port, port$iterator, source, target, tmp, westwardEdges;
  if (maskUndefined($getProperty(node.node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0))) === maskUndefined(($clinit_PortConstraints() , FIXED_RATIO)) || maskUndefined($getProperty(node.node, PORT_CONSTRAINTS_0)) === maskUndefined(FIXED_POS)) {
    for (port$iterator = new ArrayList$1(node.node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      if (port.side == ($clinit_PortSide() , NORTH_1) || port.side == SOUTH_1) {
        return false;
      }
    }
  }
  for (edge$iterator = $iterator($getOutgoingEdges(node.node)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 16);
    if (edge.source.owner == edge.target.owner) {
      return false;
    }
  }
  if ($isSideFixed(castTo($getProperty(node.node, PORT_CONSTRAINTS_0), 83))) {
    tmp = new ArrayList;
    for (p$iterator0 = $getPorts_1(node.node, ($clinit_PortSide() , WEST_1)).iterator_0(); p$iterator0.hasNext_0();) {
      p = castTo(p$iterator0.next_1(), 11);
      $add_4(tmp, p.connectedEdges);
    }
    westwardEdges = (checkNotNull(tmp) , new FluentIterable$2(tmp));
    tmp = new ArrayList;
    for (p$iterator = $getPorts_1(node.node, EAST_1).iterator_0(); p$iterator.hasNext_0();) {
      p = castTo(p$iterator.next_1(), 11);
      $add_4(tmp, p.connectedEdges);
    }
    eastwardEdges = (checkNotNull(tmp) , new FluentIterable$2(tmp));
  }
   else {
    westwardEdges = $getIncomingEdges(node.node);
    eastwardEdges = $getOutgoingEdges(node.node);
  }
  hasOutgoing = !isEmpty_10($getOutgoingEdges(node.node));
  hasIncoming = !isEmpty_10($getIncomingEdges(node.node));
  if (!hasOutgoing && !hasIncoming) {
    return false;
  }
  if (!hasOutgoing) {
    node.type_0 = 1;
    return true;
  }
  if (!hasIncoming) {
    node.type_0 = 0;
    return true;
  }
  if (size_16(($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(westwardEdges.val$inputs1, new Iterables$12))))) == 1) {
    source = (checkNotNull(westwardEdges) , castTo(get_13(new Iterators$ConcatenatedIterator($iterator_1(transform_2(westwardEdges.val$inputs1, new Iterables$12)))), 16)).source.owner;
    if (source.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && castTo($getProperty(source, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE)), 11).owner != node.node) {
      node.type_0 = 2;
      return true;
    }
  }
  if (size_16(new Iterators$ConcatenatedIterator($iterator_1(transform_2(eastwardEdges.val$inputs1, new Iterables$12)))) == 1) {
    target = (checkNotNull(eastwardEdges) , castTo(get_13(new Iterators$ConcatenatedIterator($iterator_1(transform_2(eastwardEdges.val$inputs1, new Iterables$12)))), 16)).target.owner;
    if (target.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && castTo($getProperty(target, ($clinit_InternalProperties_1() , LONG_EDGE_TARGET)), 11).owner != node.node) {
      node.type_0 = 3;
      return true;
    }
  }
  return false;
}

function $process_6(this$static, theLayeredGraph, monitor){
  var bigNodes, chunkWidth, counter, l, l$iterator, minWidth, node, node$iterator, node$iterator0, node$iterator1, node$iterator2, nodes, parts, threshold;
  $begin(monitor, 'Big nodes pre-processing', 1);
  debug_0 = checkNotNull_1(castToBoolean($getProperty(theLayeredGraph, ($clinit_LayeredOptions() , DEBUG_MODE))));
  this$static.layeredGraph = theLayeredGraph;
  nodes = new ArrayList;
  for (l$iterator = new ArrayList$1(theLayeredGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    $addAll_2(nodes, l.nodes);
  }
  counter = 0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    node.id_0 = counter++;
  }
  this$static.spacing = checkNotNull_1(castToDouble($getProperty(this$static.layeredGraph, SPACING_NODE_NODE_0)));
  this$static.direction = castTo($getProperty(this$static.layeredGraph, DIRECTION), 107);
  this$static.dummyID = nodes.array.length;
  minWidth = $intern_61;
  for (node$iterator1 = new ArrayList$1(nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
    node = castTo($next_10(node$iterator1), 9);
    node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && node.size_0.x_0 < minWidth && (minWidth = node.size_0.x_0);
  }
  minWidth = $wnd.Math.max(50, minWidth);
  bigNodes = new ArrayList;
  threshold = minWidth + this$static.spacing;
  for (node$iterator2 = new ArrayList$1(nodes); node$iterator2.i < node$iterator2.this$01.array.length;) {
    node = castTo($next_10(node$iterator2), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && node.size_0.x_0 > threshold) {
      parts = 1;
      chunkWidth = node.size_0.x_0;
      while (chunkWidth > minWidth) {
        ++parts;
        chunkWidth = (node.size_0.x_0 - (parts - 1) * this$static.spacing) / parts;
      }
      $add_4(bigNodes, new BigNodesSplitter$BigNode(this$static, node, parts));
    }
  }
  for (node$iterator = new ArrayList$1(bigNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 611);
    $isProcessorApplicable_0(node) && $process_7(node);
  }
  $done_0(monitor);
}

function BigNodesSplitter(){
  this.direction = ($clinit_Direction_0() , UNDEFINED_3);
}

defineClass(1364, 1, $intern_108, BigNodesSplitter);
_.process = function process_4(theLayeredGraph, monitor){
  $process_6(this, castTo(theLayeredGraph, 32), monitor);
}
;
_.dummyID = 0;
_.spacing = 0;
var debug_0 = false;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesSplitter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesSplitter', 1364);
function $findPossibleDummyPositions(this$static, dir_0, inLayerPos, layerIndex, maxLayer, remainingChunks){
  var connectedEdges, currentLayer, e, e$iterator, e$iterator0, i, i0, lower, lowerPrime, maxUprime, minLprime, n, n$iterator, n$iterator0, n$iterator1, n$iterator2, n$iterator3, nextLayer, old, old0, rec, upper, upperPrime, upperStrokeMax;
  currentLayer = castTo($get_7(this$static.this$01.layeredGraph.layers, layerIndex), 25);
  upper = new HashSet;
  lower = new HashSet;
  for (i0 = 0; i0 < currentLayer.nodes.array.length; ++i0) {
    n = castTo($get_7(currentLayer.nodes, i0), 9);
    i0 < inLayerPos?(old0 = upper.map_0.put(n, upper) , old0 == null):i0 > inLayerPos && (old = lower.map_0.put(n, lower) , old == null);
  }
  upperPrime = new HashSet;
  lowerPrime = new HashSet;
  for (n$iterator0 = upper.map_0.keySet_0().iterator_0(); n$iterator0.hasNext_0();) {
    n = castTo(n$iterator0.next_1(), 9);
    connectedEdges = dir_0 == 1?$getOutgoingEdges(n):$getIncomingEdges(n);
    for (e$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(connectedEdges.val$inputs1, new Iterables$12)))); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      $getIndex_0(n.layer) != $getIndex_0(e.target.owner.layer) && $add_6(upperPrime, e.target.owner);
    }
  }
  for (n$iterator1 = lower.map_0.keySet_0().iterator_0(); n$iterator1.hasNext_0();) {
    n = castTo(n$iterator1.next_1(), 9);
    connectedEdges = dir_0 == 1?$getOutgoingEdges(n):$getIncomingEdges(n);
    for (e$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(connectedEdges.val$inputs1, new Iterables$12)))); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      $getIndex_0(n.layer) != $getIndex_0(e.target.owner.layer) && $add_6(lowerPrime, e.target.owner);
    }
  }
  if (debug_0) {
    $clinit_System();
  }
  nextLayer = castTo($get_7(this$static.this$01.layeredGraph.layers, layerIndex + (dir_0 == 1?1:-1)), 25);
  maxUprime = $intern_43;
  minLprime = $intern_0;
  for (i = 0; i < nextLayer.nodes.array.length; i++) {
    n = castTo($get_7(nextLayer.nodes, i), 9);
    upperPrime.map_0.containsKey(n)?(maxUprime = maxUprime > i?maxUprime:i):lowerPrime.map_0.containsKey(n) && (minLprime = minLprime < i?minLprime:i);
  }
  if (maxUprime < minLprime) {
    for (n$iterator2 = upperPrime.map_0.keySet_0().iterator_0(); n$iterator2.hasNext_0();) {
      n = castTo(n$iterator2.next_1(), 9);
      for (e$iterator0 = $iterator($getOutgoingEdges(n)); $hasNext_0(e$iterator0);) {
        e = castTo($next_2(e$iterator0), 16);
        if ($getIndex_0(n.layer) == $getIndex_0(e.target.owner.layer)) {
          return null;
        }
      }
      for (e$iterator = $iterator($getIncomingEdges(n)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 16);
        if ($getIndex_0(n.layer) == $getIndex_0(e.source.owner.layer)) {
          return null;
        }
      }
    }
    for (n$iterator3 = lowerPrime.map_0.keySet_0().iterator_0(); n$iterator3.hasNext_0();) {
      n = castTo(n$iterator3.next_1(), 9);
      for (e$iterator0 = $iterator($getOutgoingEdges(n)); $hasNext_0(e$iterator0);) {
        e = castTo($next_2(e$iterator0), 16);
        if ($getIndex_0(n.layer) == $getIndex_0(e.target.owner.layer)) {
          return null;
        }
      }
      for (e$iterator = $iterator($getIncomingEdges(n)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 16);
        if ($getIndex_0(n.layer) == $getIndex_0(e.source.owner.layer)) {
          return null;
        }
      }
    }
    upper.map_0.size_1() == 0?(upperStrokeMax = 0):lower.map_0.size_1() == 0?(upperStrokeMax = nextLayer.nodes.array.length):(upperStrokeMax = maxUprime + 1);
    for (n$iterator = new ArrayList$1(currentLayer.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      if (n.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
        return null;
      }
    }
    if (remainingChunks == 1) {
      return newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Integer_2_classLit, 1), $intern_33, 21, 0, [valueOf_4(upperStrokeMax)]));
    }
     else if (dir_0 == 1 && layerIndex == maxLayer - 2 || dir_0 == 0 && layerIndex == 1) {
      return newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Integer_2_classLit, 1), $intern_33, 21, 0, [valueOf_4(upperStrokeMax)]));
    }
     else {
      rec = $findPossibleDummyPositions(this$static, dir_0, upperStrokeMax, layerIndex + (dir_0 == 1?1:-1), maxLayer, remainingChunks - 1);
      !!rec && dir_0 == 1 && rec.add_3(0, valueOf_4(upperStrokeMax));
      return rec;
    }
  }
  return null;
}

function $introduceDummyNode(this$static, src_0){
  var dummy, edge, inPort, movePorts, outPort, p, p$iterator, portSide;
  dummy = new LNode(this$static.this$01.layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , BIG_NODE));
  $setProperty_0(dummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), castTo($getProperty(src_0, PORT_CONSTRAINTS_0), 83));
  $setProperty_0(dummy, NODE_LABELS_PLACEMENT, castTo($getProperty(src_0, NODE_LABELS_PLACEMENT), 190));
  dummy.id_0 = this$static.this$01.dummyID++;
  $add_4(this$static.dummies, dummy);
  dummy.size_0.y_0 = src_0.size_0.y_0;
  dummy.size_0.x_0 = 0;
  portSide = ($clinit_PortSide() , EAST_1);
  movePorts = newArrayList($getPorts_1(src_0, portSide));
  for (p$iterator = new ArrayList$1(movePorts); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_10(p$iterator), 11);
    $setNode(p, dummy);
  }
  outPort = new LPort;
  $setSide(outPort, portSide);
  $setNode(outPort, src_0);
  outPort.pos.x_0 = dummy.size_0.x_0;
  outPort.pos.y_0 = dummy.size_0.y_0 / 2;
  inPort = new LPort;
  $setSide(inPort, $opposed(portSide));
  $setNode(inPort, dummy);
  inPort.pos.y_0 = dummy.size_0.y_0 / 2;
  inPort.pos.x_0 = -inPort.size_0.x_0;
  edge = new LEdge;
  $setSource_0(edge, outPort);
  $setTarget_0(edge, inPort);
  return dummy;
}

function $process_7(this$static){
  var created, e, e$iterator, eastPorts, port, port$iterator;
  eastPorts = new ArrayList;
  for (port$iterator = new ArrayList$1(this$static.node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    port.side == ($clinit_PortSide() , EAST_1) && (eastPorts.array[eastPorts.array.length] = port , true);
  }
  if (this$static.this$01.direction == ($clinit_Direction_0() , RIGHT_5) && !$isSideFixed(castTo($getProperty(this$static.node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
    for (e$iterator = $iterator($getOutgoingEdges(this$static.node)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      $add_4(eastPorts, e.source);
    }
  }
  $setProperty_0(this$static.node, ($clinit_InternalProperties_1() , BIG_NODE_ORIGINAL_SIZE), new Float(this$static.node.size_0.x_0));
  $setProperty_0(this$static.node, BIG_NODE_INITIAL, ($clinit_Boolean() , $clinit_Boolean() , true));
  $add_4(this$static.dummies, this$static.node);
  created = null;
  this$static.type_0 == 1?(created = $processNoOutgoingEdge(this$static, this$static.node, $getIndex_0(this$static.node.layer), this$static.node.size_0.x_0)):this$static.type_0 == 0?(created = $processNoIncomingEdge(this$static, this$static.node, $getIndex_0(this$static.node.layer), this$static.node.size_0.x_0)):this$static.type_0 == 3?(created = $processOutLongEdge(this$static, this$static.node, this$static.node.size_0.x_0)):this$static.type_0 == 2 && (created = $processIncLongEdge(this$static, this$static.node, this$static.node.size_0.x_0));
  !!created && new BigNodesLabelHandler$Handler(this$static.node, this$static.dummies, checkNotNull_1(castToDouble(created.second)));
}

function $processIncLongEdge(this$static, bignode, originalWidth){
  var chainOfNodes, d, d$iterator, newWidth, replacedDummies, start_0;
  chainOfNodes = new ArrayList;
  chainOfNodes.array[chainOfNodes.array.length] = bignode;
  start_0 = bignode;
  replacedDummies = 0;
  do {
    start_0 = $swapIncLongEdgeDummy(this$static, start_0);
    !!start_0 && (chainOfNodes.array[chainOfNodes.array.length] = start_0 , true);
    ++replacedDummies;
  }
   while (start_0);
  newWidth = (originalWidth - (chainOfNodes.array.length - 1) * this$static.this$01.spacing) / chainOfNodes.array.length;
  for (d$iterator = new ArrayList$1(chainOfNodes); d$iterator.i < d$iterator.this$01.array.length;) {
    d = castTo($next_10(d$iterator), 9);
    d.size_0.x_0 = newWidth;
  }
  return new Pair(valueOf_4(replacedDummies), newWidth);
}

function $processNoIncomingEdge(this$static, bignode, startLayerIndex, originalWidth){
  var chainOfNodes, createdChunks, currentLayer, currentLayerLayer, d, d$iterator, dummy, dummyLayer, i, i0, inLayerPos, inLayerPositions, n, newInLayerPos, newWidth, prevInLayerPosition, start_0, tmpChunks, upperStrokeMax;
  if (startLayerIndex <= 0) {
    return null;
  }
  chainOfNodes = new ArrayList;
  chainOfNodes.array[chainOfNodes.array.length] = bignode;
  start_0 = bignode;
  currentLayer = startLayerIndex;
  inLayerPos = -1;
  currentLayerLayer = castTo($get_7(this$static.this$01.layeredGraph.layers, startLayerIndex), 25);
  for (i0 = 0; i0 < currentLayerLayer.nodes.array.length; ++i0) {
    n = castTo($get_7(currentLayerLayer.nodes, i0), 9);
    if (n == bignode) {
      inLayerPos = i0;
      break;
    }
  }
  inLayerPositions = $findPossibleDummyPositions(this$static, 0, inLayerPos, startLayerIndex, this$static.this$01.layeredGraph.layers.array.length, this$static.chunks);
  if (!inLayerPositions) {
    return null;
  }
  tmpChunks = this$static.chunks;
  i = 0;
  createdChunks = 0;
  prevInLayerPosition = inLayerPos;
  while (!!start_0 && tmpChunks > 1 && currentLayer > 1) {
    dummy = $introduceDummyNode(this$static, start_0);
    currentLayerLayer = castTo($get_7(this$static.this$01.layeredGraph.layers, currentLayer), 25);
    dummyLayer = castTo($get_7(this$static.this$01.layeredGraph.layers, currentLayer - 1), 25);
    upperStrokeMax = castTo(inLayerPositions.get_3(i++), 21).value_0;
    newInLayerPos = min_1(upperStrokeMax, dummyLayer.nodes.array.length);
    $setLayer(start_0, newInLayerPos, dummyLayer);
    $setLayer(dummy, prevInLayerPosition, currentLayerLayer);
    prevInLayerPosition = newInLayerPos;
    !!start_0 && (chainOfNodes.array[chainOfNodes.array.length] = start_0 , true);
    start_0 = dummy;
    --tmpChunks;
    ++createdChunks;
    --currentLayer;
  }
  newWidth = (originalWidth - (chainOfNodes.array.length - 1) * this$static.this$01.spacing) / chainOfNodes.array.length;
  for (d$iterator = new ArrayList$1(chainOfNodes); d$iterator.i < d$iterator.this$01.array.length;) {
    d = castTo($next_10(d$iterator), 9);
    d.size_0.x_0 = newWidth;
  }
  return new Pair(valueOf_4(createdChunks), newWidth);
}

function $processNoOutgoingEdge(this$static, bignode, startLayerIndex, originalWidth){
  var chainOfNodes, createdChunks, currentLayer, currentLayerLayer, d, d$iterator, dummy, dummyLayer, i, i0, inLayerPos, inLayerPositions, maxLayer, n, newInLayerPos, newWidth, start_0, tmpChunks, upperStrokeMax;
  maxLayer = this$static.this$01.layeredGraph.layers.array.length;
  if (startLayerIndex >= maxLayer - 1) {
    return null;
  }
  chainOfNodes = new ArrayList;
  chainOfNodes.array[chainOfNodes.array.length] = bignode;
  start_0 = bignode;
  currentLayer = startLayerIndex;
  inLayerPos = -1;
  currentLayerLayer = castTo($get_7(this$static.this$01.layeredGraph.layers, startLayerIndex), 25);
  for (i0 = 0; i0 < currentLayerLayer.nodes.array.length; ++i0) {
    n = castTo($get_7(currentLayerLayer.nodes, i0), 9);
    if (n == bignode) {
      inLayerPos = i0;
      break;
    }
  }
  inLayerPositions = $findPossibleDummyPositions(this$static, 1, inLayerPos, startLayerIndex, maxLayer, this$static.chunks);
  if (!inLayerPositions) {
    return null;
  }
  tmpChunks = this$static.chunks;
  i = 0;
  createdChunks = 0;
  while (!!start_0 && tmpChunks > 1 && currentLayer < maxLayer - 1) {
    dummy = $introduceDummyNode(this$static, start_0);
    dummyLayer = castTo($get_7(this$static.this$01.layeredGraph.layers, currentLayer + 1), 25);
    upperStrokeMax = castTo(inLayerPositions.get_3(i++), 21).value_0;
    newInLayerPos = min_1(upperStrokeMax, dummyLayer.nodes.array.length);
    $setLayer(dummy, newInLayerPos, dummyLayer);
    !!start_0 && (chainOfNodes.array[chainOfNodes.array.length] = start_0 , true);
    start_0 = dummy;
    --tmpChunks;
    ++createdChunks;
    ++currentLayer;
  }
  newWidth = (originalWidth - (chainOfNodes.array.length - 1) * this$static.this$01.spacing) / chainOfNodes.array.length;
  for (d$iterator = new ArrayList$1(chainOfNodes); d$iterator.i < d$iterator.this$01.array.length;) {
    d = castTo($next_10(d$iterator), 9);
    d.size_0.x_0 = newWidth;
  }
  return new Pair(valueOf_4(createdChunks), newWidth);
}

function $processOutLongEdge(this$static, bignode, originalWidth){
  var chainOfNodes, d, d$iterator, newWidth, replacedDummies, start_0;
  chainOfNodes = new ArrayList;
  chainOfNodes.array[chainOfNodes.array.length] = bignode;
  start_0 = bignode;
  replacedDummies = 0;
  do {
    start_0 = $replaceOutLongEdgeDummy(this$static, start_0);
    !!start_0 && (chainOfNodes.array[chainOfNodes.array.length] = start_0 , true);
    ++replacedDummies;
  }
   while (start_0);
  newWidth = (originalWidth - (chainOfNodes.array.length - 1) * this$static.this$01.spacing) / chainOfNodes.array.length;
  for (d$iterator = new ArrayList$1(chainOfNodes); d$iterator.i < d$iterator.this$01.array.length;) {
    d = castTo($next_10(d$iterator), 9);
    d.size_0.x_0 = newWidth;
  }
  return new Pair(valueOf_4(replacedDummies), newWidth);
}

function $replaceOutLongEdgeDummy(this$static, start_0){
  var longEdgeDummy, newPort, origin, outEdge, outPort, p, p$iterator, p$iterator0, src_0;
  if (size_15($getOutgoingEdges(start_0)) != 1 || castTo(get_12($getOutgoingEdges(start_0)), 16).target.owner.type_0 != ($clinit_LNode$NodeType() , LONG_EDGE)) {
    return null;
  }
  outEdge = castTo(get_12($getOutgoingEdges(start_0)), 16);
  longEdgeDummy = outEdge.target.owner;
  $setType(longEdgeDummy, ($clinit_LNode$NodeType() , BIG_NODE));
  $setProperty_0(longEdgeDummy, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), null);
  $setProperty_0(longEdgeDummy, LONG_EDGE_TARGET, null);
  $setProperty_0(longEdgeDummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), castTo($getProperty(start_0, PORT_CONSTRAINTS_0), 83));
  $setProperty_0(longEdgeDummy, NODE_LABELS_PLACEMENT, castTo($getProperty(start_0, NODE_LABELS_PLACEMENT), 190));
  origin = $getProperty(outEdge.source, ORIGIN_0);
  outPort = null;
  for (p$iterator0 = $getPorts_1(longEdgeDummy, ($clinit_PortSide() , EAST_1)).iterator_0(); p$iterator0.hasNext_0();) {
    p = castTo(p$iterator0.next_1(), 11);
    if (p.outgoingEdges.array.length != 0) {
      $setProperty_0(p, ORIGIN_0, origin);
      src_0 = outEdge.source;
      p.size_0.x_0 = src_0.size_0.x_0;
      p.size_0.y_0 = src_0.size_0.y_0;
      p.anchor.x_0 = src_0.anchor.x_0;
      p.anchor.y_0 = src_0.anchor.y_0;
      $addAll_2(p.labels, src_0.labels);
      src_0.labels.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      outPort = p;
      break;
    }
  }
  $setProperty_0(outEdge.source, ORIGIN_0, null);
  if (!isEmpty_10($getPorts_1(start_0, EAST_1))) {
    for (p$iterator = new ArrayList$1(newArrayList($getPorts_1(start_0, EAST_1))); p$iterator.i < p$iterator.this$01.array.length;) {
      p = castTo($next_10(p$iterator), 11);
      if (p.outgoingEdges.array.length == 0) {
        newPort = new LPort;
        $setSide(newPort, EAST_1);
        newPort.size_0.x_0 = p.size_0.x_0;
        newPort.size_0.y_0 = p.size_0.y_0;
        $setNode(newPort, longEdgeDummy);
        $setProperty_0(newPort, ORIGIN_0, $getProperty(p, ORIGIN_0));
        $setNode(p, null);
      }
       else {
        $setNode(outPort, longEdgeDummy);
      }
    }
  }
  longEdgeDummy.size_0.y_0 = start_0.size_0.y_0;
  $add_4(this$static.dummies, longEdgeDummy);
  return longEdgeDummy;
}

function $swapIncLongEdgeDummy(this$static, start_0){
  var incEdge, longEdgeDummy, newPort, origin, outPort, p, p$iterator, p$iterator0, tgt;
  if (size_15($getIncomingEdges(start_0)) != 1 || castTo(get_12($getIncomingEdges(start_0)), 16).source.owner.type_0 != ($clinit_LNode$NodeType() , LONG_EDGE)) {
    return null;
  }
  incEdge = castTo(get_12($getIncomingEdges(start_0)), 16);
  longEdgeDummy = incEdge.source.owner;
  $setType(longEdgeDummy, ($clinit_LNode$NodeType() , NORMAL));
  $setProperty_0(longEdgeDummy, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), null);
  $setProperty_0(longEdgeDummy, LONG_EDGE_TARGET, null);
  $setProperty_0(longEdgeDummy, BIG_NODE_ORIGINAL_SIZE, castTo($getProperty(start_0, BIG_NODE_ORIGINAL_SIZE), 128));
  $setProperty_0(longEdgeDummy, BIG_NODE_INITIAL, ($clinit_Boolean() , $clinit_Boolean() , true));
  $setProperty_0(longEdgeDummy, ORIGIN_0, $getProperty(start_0, ORIGIN_0));
  longEdgeDummy.size_0.y_0 = start_0.size_0.y_0;
  origin = $getProperty(incEdge.target, ORIGIN_0);
  outPort = null;
  for (p$iterator0 = $getPorts_1(longEdgeDummy, ($clinit_PortSide() , WEST_1)).iterator_0(); p$iterator0.hasNext_0();) {
    p = castTo(p$iterator0.next_1(), 11);
    if (p.incomingEdges.array.length != 0) {
      $setProperty_0(p, ORIGIN_0, origin);
      tgt = incEdge.target;
      p.size_0.x_0 = tgt.size_0.x_0;
      p.size_0.y_0 = tgt.size_0.y_0;
      p.anchor.x_0 = tgt.anchor.x_0;
      p.anchor.y_0 = tgt.anchor.y_0;
      $addAll_2(p.labels, tgt.labels);
      tgt.labels.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      outPort = p;
      break;
    }
  }
  $setProperty_0(incEdge.target, ORIGIN_0, null);
  if (size_15($getPorts_1(start_0, WEST_1)) > 1) {
    for (p$iterator = $listIterator_1(newLinkedList($getPorts_1(start_0, WEST_1)), 0); p$iterator.currentNode != p$iterator.this$01.tail;) {
      p = castTo($next_13(p$iterator), 11);
      if (p.incomingEdges.array.length == 0) {
        newPort = new LPort;
        $setSide(newPort, WEST_1);
        newPort.size_0.x_0 = p.size_0.x_0;
        newPort.size_0.y_0 = p.size_0.y_0;
        $setNode(newPort, longEdgeDummy);
        $setProperty_0(newPort, ORIGIN_0, $getProperty(p, ORIGIN_0));
        $setNode(p, null);
      }
       else {
        $setNode(outPort, longEdgeDummy);
      }
    }
  }
  $setProperty_0(start_0, ORIGIN_0, null);
  $setProperty_0(start_0, BIG_NODE_INITIAL, (null , false));
  $setType(start_0, BIG_NODE);
  $setProperty_0(longEdgeDummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), castTo($getProperty(start_0, PORT_CONSTRAINTS_0), 83));
  $setProperty_0(longEdgeDummy, NODE_LABELS_PLACEMENT, castTo($getProperty(start_0, NODE_LABELS_PLACEMENT), 190));
  $add_3(this$static.dummies, 0, longEdgeDummy);
  return longEdgeDummy;
}

function BigNodesSplitter$BigNode(this$0, node, chunks){
  this.this$01 = this$0;
  this.dummies = new ArrayList;
  this.node = node;
  this.chunks = chunks;
}

defineClass(611, 1, {611:1}, BigNodesSplitter$BigNode);
_.chunks = 0;
_.type_0 = 4;
var Lorg_eclipse_elk_alg_layered_intermediate_BigNodesSplitter$BigNode_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'BigNodesSplitter/BigNode', 611);
function $getBoxPort(commentBox){
  var edge, edge$iterator, edge$iterator0, nodePort, port, port$iterator;
  nodePort = castTo($getProperty(commentBox, ($clinit_InternalProperties_1() , COMMENT_CONN_PORT)), 11);
  for (port$iterator = new ArrayList$1(commentBox.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    for (edge$iterator0 = new ArrayList$1(port.outgoingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator0), 16);
      $setTarget_0(edge, nodePort);
      return port;
    }
    for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 16);
      $setSource_0(edge, nodePort);
      return port;
    }
  }
  return null;
}

function $process_8(layeredGraph, monitor){
  var bottomBoxes, boxes, layer, layer$iterator, node, node$iterator, spacing, topBoxes;
  $begin(monitor, 'Comment post-processing', 1);
  spacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    boxes = new ArrayList;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      topBoxes = castTo($getProperty(node, ($clinit_InternalProperties_1() , TOP_COMMENTS)), 15);
      bottomBoxes = castTo($getProperty(node, BOTTOM_COMMENTS), 15);
      if (!!topBoxes || !!bottomBoxes) {
        $process_9(node, topBoxes, bottomBoxes, spacing);
        !!topBoxes && $addAll_2(boxes, topBoxes);
        !!bottomBoxes && $addAll_2(boxes, bottomBoxes);
      }
    }
    $addAll_2(layer.nodes, boxes);
  }
  $done_0(monitor);
}

function $process_9(node, topBoxes, bottomBoxes, spacing){
  var anchorInc, anchorX, baseLine, box, box$iterator, box$iterator0, boxPort, boxesWidth, margin, maxHeight, nodePort, nodePos, nodeSize, x_0;
  nodePos = node.pos;
  nodeSize = node.size_0;
  margin = node.margin;
  if (topBoxes) {
    boxesWidth = spacing / 2 * (topBoxes.size_1() - 1);
    maxHeight = 0;
    for (box$iterator0 = topBoxes.iterator_0(); box$iterator0.hasNext_0();) {
      box = castTo(box$iterator0.next_1(), 9);
      boxesWidth += box.size_0.x_0;
      maxHeight = $wnd.Math.max(maxHeight, box.size_0.y_0);
    }
    x_0 = nodePos.x_0 - (boxesWidth - nodeSize.x_0) / 2;
    baseLine = nodePos.y_0 - margin.top_0 + maxHeight;
    anchorInc = nodeSize.x_0 / (topBoxes.size_1() + 1);
    anchorX = anchorInc;
    for (box$iterator = topBoxes.iterator_0(); box$iterator.hasNext_0();) {
      box = castTo(box$iterator.next_1(), 9);
      box.pos.x_0 = x_0;
      box.pos.y_0 = baseLine - box.size_0.y_0;
      x_0 += box.size_0.x_0 + spacing / 2;
      boxPort = $getBoxPort(box);
      boxPort.pos.x_0 = box.size_0.x_0 / 2 - boxPort.anchor.x_0;
      boxPort.pos.y_0 = box.size_0.y_0;
      nodePort = castTo($getProperty(box, ($clinit_InternalProperties_1() , COMMENT_CONN_PORT)), 11);
      if (nodePort.incomingEdges.array.length + nodePort.outgoingEdges.array.length == 1) {
        nodePort.pos.x_0 = anchorX - nodePort.anchor.x_0;
        nodePort.pos.y_0 = 0;
        $setNode(nodePort, node);
      }
      anchorX += anchorInc;
    }
  }
  if (bottomBoxes) {
    boxesWidth = spacing / 2 * (bottomBoxes.size_1() - 1);
    maxHeight = 0;
    for (box$iterator0 = bottomBoxes.iterator_0(); box$iterator0.hasNext_0();) {
      box = castTo(box$iterator0.next_1(), 9);
      boxesWidth += box.size_0.x_0;
      maxHeight = $wnd.Math.max(maxHeight, box.size_0.y_0);
    }
    x_0 = nodePos.x_0 - (boxesWidth - nodeSize.x_0) / 2;
    baseLine = nodePos.y_0 + nodeSize.y_0 + margin.bottom - maxHeight;
    anchorInc = nodeSize.x_0 / (bottomBoxes.size_1() + 1);
    anchorX = anchorInc;
    for (box$iterator = bottomBoxes.iterator_0(); box$iterator.hasNext_0();) {
      box = castTo(box$iterator.next_1(), 9);
      box.pos.x_0 = x_0;
      box.pos.y_0 = baseLine;
      x_0 += box.size_0.x_0 + spacing / 2;
      boxPort = $getBoxPort(box);
      boxPort.pos.x_0 = box.size_0.x_0 / 2 - boxPort.anchor.x_0;
      boxPort.pos.y_0 = 0;
      nodePort = castTo($getProperty(box, ($clinit_InternalProperties_1() , COMMENT_CONN_PORT)), 11);
      if (nodePort.incomingEdges.array.length + nodePort.outgoingEdges.array.length == 1) {
        nodePort.pos.x_0 = anchorX - nodePort.anchor.x_0;
        nodePort.pos.y_0 = nodeSize.y_0;
        $setNode(nodePort, node);
      }
      anchorX += anchorInc;
    }
  }
}

function CommentPostprocessor(){
}

defineClass(1371, 1, $intern_108, CommentPostprocessor);
_.process = function process_5(layeredGraph, monitor){
  $process_8(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_CommentPostprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'CommentPostprocessor', 1371);
function $process_10(layeredGraph, monitor){
  var edge, edgeCount, inedge, inedge$iterator, node, nodeIter, oppositePort, outedge, outedge$iterator, port, port$iterator, port$iterator0, re, re$iterator, revEdges;
  $begin(monitor, 'Comment pre-processing', 1);
  nodeIter = new ArrayList$1(layeredGraph.layerlessNodes);
  while (nodeIter.i < nodeIter.this$01.array.length) {
    node = castTo($next_10(nodeIter), 9);
    if (checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayeredOptions() , COMMENT_BOX))))) {
      edgeCount = 0;
      edge = null;
      oppositePort = null;
      for (port$iterator0 = new ArrayList$1(node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
        port = castTo($next_10(port$iterator0), 11);
        edgeCount += port.incomingEdges.array.length + port.outgoingEdges.array.length;
        if (port.incomingEdges.array.length == 1) {
          edge = castTo($get_7(port.incomingEdges, 0), 16);
          oppositePort = edge.source;
        }
        if (port.outgoingEdges.array.length == 1) {
          edge = castTo($get_7(port.outgoingEdges, 0), 16);
          oppositePort = edge.target;
        }
      }
      if (edgeCount == 1 && oppositePort.incomingEdges.array.length + oppositePort.outgoingEdges.array.length == 1 && !checkNotNull_1(castToBoolean($getProperty(oppositePort.owner, COMMENT_BOX)))) {
        $processBox(node, edge, oppositePort, oppositePort.owner);
        $remove_14(nodeIter);
      }
       else {
        revEdges = new ArrayList;
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_10(port$iterator), 11);
          for (outedge$iterator = new ArrayList$1(port.outgoingEdges); outedge$iterator.i < outedge$iterator.this$01.array.length;) {
            outedge = castTo($next_10(outedge$iterator), 16);
            outedge.target.outgoingEdges.array.length == 0 || (revEdges.array[revEdges.array.length] = outedge , true);
          }
          for (inedge$iterator = new ArrayList$1(port.incomingEdges); inedge$iterator.i < inedge$iterator.this$01.array.length;) {
            inedge = castTo($next_10(inedge$iterator), 16);
            inedge.source.incomingEdges.array.length == 0 || (revEdges.array[revEdges.array.length] = inedge , true);
          }
        }
        for (re$iterator = new ArrayList$1(revEdges); re$iterator.i < re$iterator.this$01.array.length;) {
          re = castTo($next_10(re$iterator), 16);
          $reverse_0(re, true);
        }
      }
    }
  }
  $done_0(monitor);
}

function $processBox(box, edge, oppositePort, realNode){
  var bottomBoxes, boxList, hasNorth, hasSouth, label_0, label$iterator, labelPos, onlyBottom, onlyTop, port1, port1$iterator, port2, port2$iterator, topBoxes, topFirst;
  onlyTop = false;
  onlyBottom = false;
  if ($isSideFixed(castTo($getProperty(realNode, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
    hasNorth = false;
    hasSouth = false;
    portLoop: for (port1$iterator = new ArrayList$1(realNode.ports); port1$iterator.i < port1$iterator.this$01.array.length;) {
      port1 = castTo($next_10(port1$iterator), 11);
      for (port2$iterator = $iterator(concat_1(new LPort$7(port1), new LPort$8(port1))); $hasNext_0(port2$iterator);) {
        port2 = castTo($next_2(port2$iterator), 11);
        if (!checkNotNull_1(castToBoolean($getProperty(port2.owner, COMMENT_BOX)))) {
          if (port1.side == ($clinit_PortSide() , NORTH_1)) {
            hasNorth = true;
            break portLoop;
          }
          if (port1.side == SOUTH_1) {
            hasSouth = true;
            break portLoop;
          }
        }
      }
    }
    onlyTop = hasSouth && !hasNorth;
    onlyBottom = hasNorth && !hasSouth;
  }
  if (!onlyTop && !onlyBottom && realNode.labels.array.length != 0) {
    labelPos = 0;
    for (label$iterator = new ArrayList$1(realNode.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 70);
      labelPos += label_0.pos.y_0 + label_0.size_0.y_0 / 2;
    }
    labelPos /= realNode.labels.array.length;
    topFirst = labelPos >= realNode.size_0.y_0 / 2;
  }
   else {
    topFirst = !onlyBottom;
  }
  if (topFirst) {
    topBoxes = castTo($getProperty(realNode, ($clinit_InternalProperties_1() , TOP_COMMENTS)), 15);
    if (!topBoxes) {
      boxList = new ArrayList;
      $setProperty_0(realNode, TOP_COMMENTS, boxList);
    }
     else if (onlyTop) {
      boxList = topBoxes;
    }
     else {
      bottomBoxes = castTo($getProperty(realNode, BOTTOM_COMMENTS), 15);
      if (!bottomBoxes) {
        boxList = new ArrayList;
        $setProperty_0(realNode, BOTTOM_COMMENTS, boxList);
      }
       else {
        topBoxes.size_1() <= bottomBoxes.size_1()?(boxList = topBoxes):(boxList = bottomBoxes);
      }
    }
  }
   else {
    bottomBoxes = castTo($getProperty(realNode, ($clinit_InternalProperties_1() , BOTTOM_COMMENTS)), 15);
    if (!bottomBoxes) {
      boxList = new ArrayList;
      $setProperty_0(realNode, BOTTOM_COMMENTS, boxList);
    }
     else if (onlyBottom) {
      boxList = bottomBoxes;
    }
     else {
      topBoxes = castTo($getProperty(realNode, TOP_COMMENTS), 15);
      if (!topBoxes) {
        boxList = new ArrayList;
        $setProperty_0(realNode, TOP_COMMENTS, boxList);
      }
       else {
        bottomBoxes.size_1() <= topBoxes.size_1()?(boxList = bottomBoxes):(boxList = topBoxes);
      }
    }
  }
  boxList.add_1(box);
  $setProperty_0(box, ($clinit_InternalProperties_1() , COMMENT_CONN_PORT), oppositePort);
  if (edge.target == oppositePort) {
    $setTarget_0(edge, null);
    oppositePort.incomingEdges.array.length + oppositePort.outgoingEdges.array.length == 0 && $setNode(oppositePort, null);
    $removeHierarchicalPortDummyNode(oppositePort);
  }
   else {
    $setSource_0(edge, null);
    oppositePort.incomingEdges.array.length + oppositePort.outgoingEdges.array.length == 0 && $setNode(oppositePort, null);
  }
  $reset_0(edge.bendPoints);
}

function $removeHierarchicalPortDummyNode(oppositePort){
  var dummy, layer;
  dummy = castTo($getProperty(oppositePort, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
  if (dummy) {
    layer = dummy.layer;
    $remove_13(layer.nodes, dummy);
    layer.nodes.array.length == 0 && $remove_13($getGraph(dummy).layers, layer);
  }
}

function CommentPreprocessor(){
}

defineClass(1372, 1, $intern_108, CommentPreprocessor);
_.process = function process_6(layeredGraph, monitor){
  $process_10(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_CommentPreprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'CommentPreprocessor', 1372);
function $canReverseIncomingEdge(nodeLayerConstraint, edge){
  var sourceLayerConstraint, sourceNode;
  if (checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties_1() , REVERSED))))) {
    return false;
  }
  if (nodeLayerConstraint == ($clinit_LayerConstraint() , FIRST)) {
    sourceNode = edge.source.owner;
    if (sourceNode.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
      return false;
    }
    sourceLayerConstraint = castTo($getProperty(sourceNode, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0)), 183);
    if (sourceLayerConstraint == FIRST_SEPARATE) {
      return false;
    }
  }
  return true;
}

function $canReverseOutgoingEdge(nodeLayerConstraint, edge){
  var targetLayerConstraint, targetNode;
  if (checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties_1() , REVERSED))))) {
    return false;
  }
  if (nodeLayerConstraint == ($clinit_LayerConstraint() , LAST)) {
    targetNode = edge.target.owner;
    if (targetNode.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
      return false;
    }
    targetLayerConstraint = castTo($getProperty(targetNode, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0)), 183);
    if (targetLayerConstraint == LAST_SEPARATE) {
      return false;
    }
  }
  return true;
}

function $process_11(layeredGraph, monitor){
  var allPortsReversed, e, e$iterator, edgeConstraint, layerConstraint, lc, node, node$iterator, port, port$iterator;
  $begin(monitor, 'Edge and layer constraint edge reversal', 1);
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    layerConstraint = castTo($getProperty(node, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0)), 183);
    edgeConstraint = null;
    switch (layerConstraint.ordinal) {
      case 1:
      case 2:
        edgeConstraint = ($clinit_EdgeConstraint() , OUTGOING_ONLY);
        break;
      case 3:
      case 4:
        edgeConstraint = ($clinit_EdgeConstraint() , INCOMING_ONLY);
    }
    if (edgeConstraint) {
      $setProperty_0(node, ($clinit_InternalProperties_1() , EDGE_CONSTRAINT), ($clinit_EdgeConstraint() , OUTGOING_ONLY));
      edgeConstraint == INCOMING_ONLY?$reverseEdges(node, layerConstraint, ($clinit_PortType() , OUTPUT)):edgeConstraint == OUTGOING_ONLY && $reverseEdges(node, layerConstraint, ($clinit_PortType() , INPUT));
    }
     else {
      if ($isSideFixed(castTo($getProperty(node, PORT_CONSTRAINTS_0), 83)) && node.ports.array.length != 0) {
        allPortsReversed = true;
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_10(port$iterator), 11);
          if (!(port.side == ($clinit_PortSide() , EAST_1) && port.incomingEdges.array.length - port.outgoingEdges.array.length > 0 || port.side == WEST_1 && port.incomingEdges.array.length - port.outgoingEdges.array.length < 0)) {
            allPortsReversed = false;
            break;
          }
          if (port.side == WEST_1) {
            for (e$iterator = new ArrayList$1(port.outgoingEdges); e$iterator.i < e$iterator.this$01.array.length;) {
              e = castTo($next_10(e$iterator), 16);
              lc = castTo($getProperty(e.target.owner, LAYERING_LAYER_CONSTRAINT_0), 183);
              if (lc == ($clinit_LayerConstraint() , LAST) || lc == LAST_SEPARATE) {
                allPortsReversed = false;
                break;
              }
            }
          }
          if (port.side == EAST_1) {
            for (e$iterator = new ArrayList$1(port.incomingEdges); e$iterator.i < e$iterator.this$01.array.length;) {
              e = castTo($next_10(e$iterator), 16);
              lc = castTo($getProperty(e.source.owner, LAYERING_LAYER_CONSTRAINT_0), 183);
              if (lc == ($clinit_LayerConstraint() , FIRST) || lc == FIRST_SEPARATE) {
                allPortsReversed = false;
                break;
              }
            }
          }
        }
        allPortsReversed && $reverseEdges(node, layerConstraint, ($clinit_PortType() , UNDEFINED_0));
      }
    }
  }
  $done_0(monitor);
}

function $reverseEdges(node, nodeLayerConstraint, type_0){
  var edge, edge$index, edge$max, incoming, outgoing, port, port$index, port$max, ports;
  ports = castTo($toArray_2(node.ports, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LPort_2_classLit, $intern_112, 11, node.ports.array.length, 0, 1)), 639);
  for (port$index = 0 , port$max = ports.length; port$index < port$max; ++port$index) {
    port = ports[port$index];
    if (type_0 != ($clinit_PortType() , INPUT)) {
      outgoing = castTo($toArray_2(port.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, port.outgoingEdges.array.length, 0, 1)), 101);
      for (edge$index = 0 , edge$max = outgoing.length; edge$index < edge$max; ++edge$index) {
        edge = outgoing[edge$index];
        $canReverseOutgoingEdge(nodeLayerConstraint, edge) && $reverse_0(edge, true);
      }
    }
    if (type_0 != OUTPUT) {
      incoming = castTo($toArray_2(port.incomingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, port.incomingEdges.array.length, 0, 1)), 101);
      for (edge$index = 0 , edge$max = incoming.length; edge$index < edge$max; ++edge$index) {
        edge = incoming[edge$index];
        $canReverseIncomingEdge(nodeLayerConstraint, edge) && $reverse_0(edge, true);
      }
    }
  }
}

function EdgeAndLayerConstraintEdgeReverser(){
}

defineClass(1373, 1, $intern_108, EdgeAndLayerConstraintEdgeReverser);
_.process = function process_7(layeredGraph, monitor){
  $process_11(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EdgeAndLayerConstraintEdgeReverser_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EdgeAndLayerConstraintEdgeReverser', 1373);
function $process_12(layeredGraph, monitor){
  $begin(monitor, 'End label post-processing', 1);
  $forEach_2($filter($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(layeredGraph.layers, 16)), new EndLabelPostprocessor$lambda$0$Type), new EndLabelPostprocessor$lambda$1$Type), new EndLabelPostprocessor$lambda$2$Type);
  $done_0(monitor);
}

function $processNode_1(node){
  var endLabelCells, labelCell, labelCell$iterator, labelCellRect, nodePos;
  endLabelCells = castTo($getProperty(node, ($clinit_InternalProperties_1() , END_LABELS_0)), 15);
  nodePos = node.pos;
  for (labelCell$iterator = endLabelCells.iterator_0(); labelCell$iterator.hasNext_0();) {
    labelCell = castTo(labelCell$iterator.next_1(), 279);
    labelCellRect = labelCell.cellRectangle;
    labelCellRect.x_0 += nodePos.x_0;
    labelCellRect.y_0 += nodePos.y_0;
    labelCell.horizontalLayoutMode?$applyHorizontalModeLabelLayout(labelCell):$applyVerticalModeLabelLayout(labelCell);
  }
  $setProperty_0(node, END_LABELS_0, null);
}

function EndLabelPostprocessor(){
}

defineClass(1374, 1, $intern_108, EndLabelPostprocessor);
_.process = function process_8(layeredGraph, monitor){
  $process_12(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPostprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPostprocessor', 1374);
function EndLabelPostprocessor$lambda$0$Type(){
}

defineClass(1375, 1, $intern_11, EndLabelPostprocessor$lambda$0$Type);
_.apply_0 = function apply_72(arg0){
  return new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPostprocessor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPostprocessor/lambda$0$Type', 1375);
function EndLabelPostprocessor$lambda$1$Type(){
}

defineClass(1376, 1, $intern_90, EndLabelPostprocessor$lambda$1$Type);
_.test_0 = function test_29(arg0){
  return castTo(arg0, 9).type_0 == ($clinit_LNode$NodeType() , NORMAL) && $hasProperty(castTo(arg0, 9), ($clinit_InternalProperties_1() , END_LABELS_0));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPostprocessor$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPostprocessor/lambda$1$Type', 1376);
function EndLabelPostprocessor$lambda$2$Type(){
}

defineClass(1377, 1, {}, EndLabelPostprocessor$lambda$2$Type);
_.accept = function accept_55(arg0){
  $processNode_1(castTo(arg0, 9));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPostprocessor$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPostprocessor/lambda$2$Type', 1377);
function $calculateOverlapStartCoordinate(node, portSide, edgeLabelSpacing){
  var nodeMargin, nodeSize;
  nodeSize = node.size_0;
  nodeMargin = node.margin;
  switch (portSide.ordinal) {
    case 1:
      return -nodeMargin.top_0 - edgeLabelSpacing;
    case 3:
      return nodeSize.y_0 + nodeMargin.bottom + edgeLabelSpacing;
    case 2:
      return nodeSize.x_0 + nodeMargin.right + edgeLabelSpacing;
    case 4:
      return -nodeMargin.left - edgeLabelSpacing;
    default:return 0;
  }
}

function $createConfiguredLabelCell(labels, labelLabelSpacing, verticalLayout){
  var label_0, label$iterator, labelCell, labelCellRect, padding, padding0;
  if (!labels || labels.array.length == 0) {
    return null;
  }
  labelCell = new LabelCell_1(labelLabelSpacing, !verticalLayout);
  for (label$iterator = new ArrayList$1(labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 70);
    $addLabel(labelCell, new LGraphAdapters$LLabelAdapter(label_0));
  }
  labelCellRect = labelCell.cellRectangle;
  labelCellRect.height = (padding0 = labelCell.padding , labelCell.minimumContentAreaSize.y_0 + padding0.top_0 + padding0.bottom);
  labelCellRect.width_0 = (padding = labelCell.padding , labelCell.minimumContentAreaSize.x_0 + padding.left + padding.right);
  return labelCell;
}

function $lambda$1(edgeLabelSpacing_1, labelLabelSpacing_3, verticalLayout_5, node_3){
  $processNode_2(node_3, edgeLabelSpacing_1, labelLabelSpacing_3, verticalLayout_5);
}

function $placeLabels(node, portLabelCells, labelLabelSpacing, edgeLabelSpacing, verticalLayout){
  var all, port, port$iterator, portSidesWithLabels;
  portSidesWithLabels = (all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_PortSide_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    if (portLabelCells[port.id_0]) {
      $placeLabels_0(port, portLabelCells[port.id_0], edgeLabelSpacing);
      $add_5(portSidesWithLabels, port.side);
    }
  }
  if (verticalLayout) {
    $removeLabelOverlaps(node, portLabelCells, ($clinit_PortSide() , EAST_1), 2 * labelLabelSpacing, edgeLabelSpacing);
    $removeLabelOverlaps(node, portLabelCells, WEST_1, 2 * labelLabelSpacing, edgeLabelSpacing);
  }
   else {
    $removeLabelOverlaps(node, portLabelCells, ($clinit_PortSide() , NORTH_1), 2 * labelLabelSpacing, edgeLabelSpacing);
    $removeLabelOverlaps(node, portLabelCells, SOUTH_1, 2 * labelLabelSpacing, edgeLabelSpacing);
  }
}

function $placeLabels_0(port, labelCell, edgeLabelSpacing){
  var labelCellRect, nodeMargin, nodeSize, portAnchor, portPos;
  labelCellRect = labelCell.cellRectangle;
  nodeSize = port.owner.size_0;
  nodeMargin = port.owner.margin;
  portPos = port.pos;
  portAnchor = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [portPos, port.anchor]));
  switch (port.side.ordinal) {
    case 1:
      $setVerticalAlignment(labelCell, ($clinit_VerticalLabelAlignment() , BOTTOM));
      labelCellRect.y_0 = -nodeMargin.top_0 - edgeLabelSpacing - labelCellRect.height;
      if (castTo(castTo(unmodifiableList(labelCell.labels).list.get_3(0), 281).getProperty(($clinit_InternalProperties_1() , LABEL_SIDE)), 276) == ($clinit_LabelSide() , ABOVE)) {
        $setHorizontalAlignment(labelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
        labelCellRect.x_0 = portAnchor.x_0 - checkNotNull_1(castToDouble($getProperty(port, MAX_EDGE_THICKNESS))) - edgeLabelSpacing - labelCellRect.width_0;
      }
       else {
        $setHorizontalAlignment(labelCell, ($clinit_HorizontalLabelAlignment() , LEFT));
        labelCellRect.x_0 = portAnchor.x_0 + checkNotNull_1(castToDouble($getProperty(port, MAX_EDGE_THICKNESS))) + edgeLabelSpacing;
      }

      break;
    case 2:
      $setHorizontalAlignment(labelCell, ($clinit_HorizontalLabelAlignment() , LEFT));
      labelCellRect.x_0 = nodeSize.x_0 + nodeMargin.right + edgeLabelSpacing;
      if (castTo(castTo(unmodifiableList(labelCell.labels).list.get_3(0), 281).getProperty(($clinit_InternalProperties_1() , LABEL_SIDE)), 276) == ($clinit_LabelSide() , ABOVE)) {
        $setVerticalAlignment(labelCell, ($clinit_VerticalLabelAlignment() , BOTTOM));
        labelCellRect.y_0 = portAnchor.y_0 - checkNotNull_1(castToDouble($getProperty(port, MAX_EDGE_THICKNESS))) - edgeLabelSpacing - labelCellRect.height;
      }
       else {
        $setVerticalAlignment(labelCell, ($clinit_VerticalLabelAlignment() , TOP));
        labelCellRect.y_0 = portAnchor.y_0 + checkNotNull_1(castToDouble($getProperty(port, MAX_EDGE_THICKNESS))) + edgeLabelSpacing;
      }

      break;
    case 3:
      $setVerticalAlignment(labelCell, ($clinit_VerticalLabelAlignment() , TOP));
      labelCellRect.y_0 = nodeSize.y_0 + nodeMargin.bottom + edgeLabelSpacing;
      if (castTo(castTo(unmodifiableList(labelCell.labels).list.get_3(0), 281).getProperty(($clinit_InternalProperties_1() , LABEL_SIDE)), 276) == ($clinit_LabelSide() , ABOVE)) {
        $setHorizontalAlignment(labelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
        labelCellRect.x_0 = portAnchor.x_0 - checkNotNull_1(castToDouble($getProperty(port, MAX_EDGE_THICKNESS))) - edgeLabelSpacing - labelCellRect.width_0;
      }
       else {
        $setHorizontalAlignment(labelCell, ($clinit_HorizontalLabelAlignment() , LEFT));
        labelCellRect.x_0 = portAnchor.x_0 + checkNotNull_1(castToDouble($getProperty(port, MAX_EDGE_THICKNESS))) + edgeLabelSpacing;
      }

      break;
    case 4:
      $setHorizontalAlignment(labelCell, ($clinit_HorizontalLabelAlignment() , RIGHT));
      labelCellRect.x_0 = -nodeMargin.left - edgeLabelSpacing - labelCellRect.width_0;
      if (castTo(castTo(unmodifiableList(labelCell.labels).list.get_3(0), 281).getProperty(($clinit_InternalProperties_1() , LABEL_SIDE)), 276) == ($clinit_LabelSide() , ABOVE)) {
        $setVerticalAlignment(labelCell, ($clinit_VerticalLabelAlignment() , BOTTOM));
        labelCellRect.y_0 = portAnchor.y_0 - checkNotNull_1(castToDouble($getProperty(port, MAX_EDGE_THICKNESS))) - edgeLabelSpacing - labelCellRect.height;
      }
       else {
        $setVerticalAlignment(labelCell, ($clinit_VerticalLabelAlignment() , TOP));
        labelCellRect.y_0 = portAnchor.y_0 + checkNotNull_1(castToDouble($getProperty(port, MAX_EDGE_THICKNESS))) + edgeLabelSpacing;
      }

  }
}

function $portSideToOverlapRemovalDirection(portSide){
  switch (portSide.ordinal) {
    case 1:
      return $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , UP;
    case 3:
      return $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , DOWN;
    case 2:
      return $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , RIGHT_0;
    case 4:
      return $clinit_RectangleStripOverlapRemover$OverlapRemovalDirection() , LEFT_0;
    default:return null;
  }
}

function $process_13(layeredGraph, monitor){
  var edgeLabelSpacing, labelLabelSpacing, verticalLayout;
  $begin(monitor, 'End label pre-processing', 1);
  edgeLabelSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_EDGE_LABEL_0))));
  labelLabelSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_LABEL_LABEL)));
  verticalLayout = $isVertical(castTo($getProperty(layeredGraph, DIRECTION), 107));
  $forEach_2($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(layeredGraph.layers, 16)), new EndLabelPreprocessor$lambda$0$Type), new EndLabelPreprocessor$lambda$1$Type(edgeLabelSpacing, labelLabelSpacing, verticalLayout));
  $done_0(monitor);
}

function $processNode_2(node, edgeLabelSpacing, labelLabelSpacing, verticalLayout){
  var port, portCount, portIndex, portLabelCellList, portLabelCells;
  portCount = node.ports.array.length;
  portLabelCells = initUnidimensionalArray(Lorg_eclipse_elk_alg_common_nodespacing_cellsystem_LabelCell_2_classLit, $intern_95, 279, portCount, 0, 1);
  for (portIndex = 0; portIndex < portCount; portIndex++) {
    port = castTo($get_7(node.ports, portIndex), 11);
    port.id_0 = portIndex;
    portLabelCells[portIndex] = $createConfiguredLabelCell(gatherLabels(port), labelLabelSpacing, verticalLayout);
  }
  $placeLabels(node, portLabelCells, labelLabelSpacing, edgeLabelSpacing, verticalLayout);
  portLabelCellList = castTo($collect_0($filter(new Stream$StreamSource(null, spliterator_23(portLabelCells, portLabelCells.length)), new EndLabelPreprocessor$lambda$2$Type), of_3(new Collectors$21methodref$ctor$Type, new Collectors$20methodref$add$Type, new Collectors$lambda$21$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , IDENTITY_FINISH)]))), 15);
  if (!portLabelCellList.isEmpty()) {
    $setProperty_0(node, ($clinit_InternalProperties_1() , END_LABELS_0), portLabelCellList);
    $updateNodeMargins(node, portLabelCellList);
  }
}

function $removeLabelOverlaps(node, portLabelCells, portSide, labelLabelSpacing, edgeLabelSpacing){
  var labelCellRect, overlapRemover, port, port$iterator;
  overlapRemover = $withStartCoordinate($withGap(createForDirection($portSideToOverlapRemovalDirection(portSide)), labelLabelSpacing), $calculateOverlapStartCoordinate(node, portSide, edgeLabelSpacing));
  for (port$iterator = $getPorts_1(node, portSide).iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    if (portLabelCells[port.id_0]) {
      labelCellRect = portLabelCells[port.id_0].cellRectangle;
      $add_4(overlapRemover.rectangleNodes, new RectangleStripOverlapRemover$RectangleNode(labelCellRect, $importRectangle(overlapRemover, labelCellRect)));
    }
  }
  $removeOverlaps_0(overlapRemover);
}

function $updateNodeMargins(node, labelCells){
  var labelCell, labelCell$iterator, nodeMargin, nodeMarginRectangle, nodeSize;
  nodeMargin = node.margin;
  nodeSize = node.size_0;
  nodeMarginRectangle = new ElkRectangle_0(-nodeMargin.left, -nodeMargin.top_0, nodeMargin.left + nodeSize.x_0 + nodeMargin.right, nodeMargin.top_0 + nodeSize.y_0 + nodeMargin.bottom);
  for (labelCell$iterator = labelCells.iterator_0(); labelCell$iterator.hasNext_0();) {
    labelCell = castTo(labelCell$iterator.next_1(), 279);
    $union_0(nodeMarginRectangle, labelCell.cellRectangle);
  }
  nodeMargin.left = -nodeMarginRectangle.x_0;
  nodeMargin.top_0 = -nodeMarginRectangle.y_0;
  nodeMargin.right = nodeMarginRectangle.width_0 - nodeMargin.left - nodeSize.x_0;
  nodeMargin.bottom = nodeMarginRectangle.height - nodeMargin.top_0 - nodeSize.y_0;
}

function EndLabelPreprocessor(){
}

function gatherLabels(port){
  var dummyNode, dummyPort, dummyPort$iterator, labels, maxEdgeThickness;
  labels = new ArrayList;
  maxEdgeThickness = gatherLabels_0(port, labels);
  dummyNode = castTo($getProperty(port, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
  if (dummyNode) {
    for (dummyPort$iterator = new ArrayList$1(dummyNode.ports); dummyPort$iterator.i < dummyPort$iterator.this$01.array.length;) {
      dummyPort = castTo($next_10(dummyPort$iterator), 11);
      maskUndefined($getProperty(dummyPort, ORIGIN_0)) === maskUndefined(port) && (maxEdgeThickness = $wnd.Math.max(maxEdgeThickness, gatherLabels_0(dummyPort, labels)));
    }
  }
  labels.array.length == 0 || $setProperty_0(port, MAX_EDGE_THICKNESS, maxEdgeThickness);
  return maxEdgeThickness != -1?labels:null;
}

function gatherLabels_0(port, targetList){
  var incidentEdge, incidentEdge$iterator, maxEdgeThickness;
  maxEdgeThickness = -1;
  for (incidentEdge$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(incidentEdge$iterator.firstIterator) || $hasNext_2(incidentEdge$iterator.secondIterator);) {
    incidentEdge = castTo($hasNext_2(incidentEdge$iterator.firstIterator)?$next_10(incidentEdge$iterator.firstIterator):$next_10(incidentEdge$iterator.secondIterator), 16);
    maxEdgeThickness = $wnd.Math.max(maxEdgeThickness, checkNotNull_1(castToDouble($getProperty(incidentEdge, ($clinit_LayeredOptions() , EDGE_THICKNESS_0)))));
    incidentEdge.source == port?$forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(incidentEdge.labels, 16)), new EndLabelPreprocessor$lambda$3$Type), new EndLabelPreprocessor$lambda$4$Type(targetList)):$forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(incidentEdge.labels, 16)), new EndLabelPreprocessor$lambda$5$Type), new EndLabelPreprocessor$lambda$6$Type(targetList));
  }
  return maxEdgeThickness;
}

defineClass(1378, 1, $intern_108, EndLabelPreprocessor);
_.process = function process_9(layeredGraph, monitor){
  $process_13(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPreprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPreprocessor', 1378);
function EndLabelPreprocessor$lambda$0$Type(){
}

defineClass(1379, 1, $intern_11, EndLabelPreprocessor$lambda$0$Type);
_.apply_0 = function apply_73(arg0){
  return new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPreprocessor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPreprocessor/lambda$0$Type', 1379);
function EndLabelPreprocessor$lambda$1$Type(edgeLabelSpacing_1, labelLabelSpacing_3, verticalLayout_5){
  this.edgeLabelSpacing_1 = edgeLabelSpacing_1;
  this.labelLabelSpacing_3 = labelLabelSpacing_3;
  this.verticalLayout_5 = verticalLayout_5;
}

defineClass(1380, 1, {}, EndLabelPreprocessor$lambda$1$Type);
_.accept = function accept_56(arg0){
  $lambda$1(this.edgeLabelSpacing_1, this.labelLabelSpacing_3, this.verticalLayout_5, arg0);
}
;
_.edgeLabelSpacing_1 = 0;
_.labelLabelSpacing_3 = 0;
_.verticalLayout_5 = false;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPreprocessor$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPreprocessor/lambda$1$Type', 1380);
function EndLabelPreprocessor$lambda$2$Type(){
}

defineClass(1381, 1, $intern_90, EndLabelPreprocessor$lambda$2$Type);
_.test_0 = function test_30(arg0){
  return !!castTo(arg0, 279);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPreprocessor$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPreprocessor/lambda$2$Type', 1381);
function EndLabelPreprocessor$lambda$3$Type(){
}

defineClass(1382, 1, $intern_90, EndLabelPreprocessor$lambda$3$Type);
_.test_0 = function test_31(arg0){
  return maskUndefined($getProperty(castTo(arg0, 70), ($clinit_LayeredOptions() , EDGE_LABELS_PLACEMENT))) === maskUndefined(($clinit_EdgeLabelPlacement() , TAIL));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPreprocessor$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPreprocessor/lambda$3$Type', 1382);
function EndLabelPreprocessor$lambda$4$Type(targetList_0){
  this.targetList_0 = targetList_0;
}

defineClass(1383, 1, {}, EndLabelPreprocessor$lambda$4$Type);
_.accept = function accept_57(arg0){
  $add_4(this.targetList_0, castTo(arg0, 70));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPreprocessor$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPreprocessor/lambda$4$Type', 1383);
function EndLabelPreprocessor$lambda$5$Type(){
}

defineClass(1384, 1, $intern_90, EndLabelPreprocessor$lambda$5$Type);
_.test_0 = function test_32(arg0){
  return maskUndefined($getProperty(castTo(arg0, 70), ($clinit_LayeredOptions() , EDGE_LABELS_PLACEMENT))) === maskUndefined(($clinit_EdgeLabelPlacement() , HEAD));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPreprocessor$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPreprocessor/lambda$5$Type', 1384);
function EndLabelPreprocessor$lambda$6$Type(targetList_0){
  this.targetList_0 = targetList_0;
}

defineClass(1385, 1, {}, EndLabelPreprocessor$lambda$6$Type);
_.accept = function accept_58(arg0){
  $add_4(this.targetList_0, castTo(arg0, 70));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_EndLabelPreprocessor$lambda$6$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'EndLabelPreprocessor/lambda$6$Type', 1385);
function $absMin(d1, d2){
  return $wnd.Math.abs(d1) < $wnd.Math.abs(d2)?d1:d2;
}

function $calculateBezierBendPoints(this$static, edgeChain, survivingEdge){
  var addMidPoint, allCP, currentBendPoints, currentEdge, edge, edgeIterator, halfway, lastCP, northSouthCP, nt, nubSpline, sourcePort, targetPort, y_0, first, second, v, v2, straightenBeginning, iter, last, secondLast, straightenEnding;
  if (edgeChain.isEmpty()) {
    return;
  }
  allCP = new KVectorChain;
  edge = survivingEdge?survivingEdge:castTo(edgeChain.get_3(0), 16);
  sourcePort = edge.source;
  $clinit_SplineEdgeRouter();
  nt = sourcePort.owner.type_0;
  if (!(nt == ($clinit_LNode$NodeType() , NORMAL) || nt == NORTH_SOUTH_PORT || nt == EXTERNAL_PORT || nt == BIG_NODE || nt == BREAKING_POINT)) {
    throw toJs(new IllegalArgumentException_0('The target node of the edge must be a normal node or a northSouthPort.'));
  }
  $addLast_0(allCP, sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor])));
  if (($clinit_PortSide() , SIDES_NORTH_SOUTH).contains(sourcePort.side)) {
    y_0 = checkNotNull_1(castToDouble($getProperty(sourcePort, ($clinit_InternalProperties_1() , SPLINE_NS_PORT_Y_COORD))));
    northSouthCP = new KVector_1(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor])).x_0, y_0);
    $addNode_0(allCP, northSouthCP, allCP.tail.prev, allCP.tail);
  }
  lastCP = null;
  addMidPoint = false;
  edgeIterator = edgeChain.iterator_0();
  while (edgeIterator.hasNext_0()) {
    currentEdge = castTo(edgeIterator.next_1(), 16);
    currentBendPoints = currentEdge.bendPoints;
    if (currentBendPoints.size_0 != 0) {
      if (addMidPoint) {
        halfway = $scale($add_19(lastCP, (checkCriticalElement(currentBendPoints.size_0 != 0) , castTo(currentBendPoints.header.next_0.value_0, 8))), 0.5);
        $addNode_0(allCP, halfway, allCP.tail.prev, allCP.tail);
        addMidPoint = false;
      }
       else {
        addMidPoint = true;
      }
      lastCP = $clone_0((checkCriticalElement(currentBendPoints.size_0 != 0) , castTo(currentBendPoints.tail.prev.value_0, 8)));
      $addAll(allCP, currentBendPoints);
      $reset_0(currentBendPoints);
    }
  }
  targetPort = edge.target;
  if (SIDES_NORTH_SOUTH.contains(targetPort.side)) {
    y_0 = checkNotNull_1(castToDouble($getProperty(targetPort, ($clinit_InternalProperties_1() , SPLINE_NS_PORT_Y_COORD))));
    northSouthCP = new KVector_1(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).x_0, y_0);
    $addNode_0(allCP, northSouthCP, allCP.tail.prev, allCP.tail);
  }
  $addLast_0(allCP, sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])));
  this$static.splineRoutingMode == ($clinit_SplineRoutingMode() , CONSERVATIVE) && (first = (checkCriticalElement(allCP.size_0 != 0) , castTo(allCP.header.next_0.value_0, 8)) , second = castTo($get_3(allCP, 1), 8) , v = new KVector_0(portSideToDirection(sourcePort.side)) , v.x_0 *= 5 , v.y_0 *= 5 , v2 = $sub_0(new KVector_1(second.x_0, second.y_0), first) , straightenBeginning = new KVector_1($absMin(v.x_0, v2.x_0), $absMin(v.y_0, v2.y_0)) , straightenBeginning.x_0 += first.x_0 , straightenBeginning.y_0 += first.y_0 , iter = $listIterator_1(allCP, 1) , $add_8(iter, straightenBeginning) , last = (checkCriticalElement(allCP.size_0 != 0) , castTo(allCP.tail.prev.value_0, 8)) , secondLast = castTo($get_3(allCP, allCP.size_0 - 2), 8) , v = new KVector_0(portSideToDirection(targetPort.side)) , v.x_0 *= 5 , v.y_0 *= 5 , v2 = $sub_0(new KVector_1(secondLast.x_0, secondLast.y_0), last) , straightenEnding = new KVector_1($absMin(v.x_0, v2.x_0), $absMin(v.y_0, v2.y_0)) , straightenEnding.x_0 += last.x_0 , straightenEnding.y_0 += last.y_0 , $add_0(allCP, allCP.size_0 - 1, straightenEnding) , undefined);
  nubSpline = new NubSpline_0(allCP);
  $addAll(edge.bendPoints, $getBezierCP(nubSpline));
}

function $calculateControlPoints(this$static, segment){
  var edge, edge$iterator, ei, sloppy, xStartPos, xEndPos, halfway;
  if (segment.handled) {
    return;
  }
  segment.handled = true;
  for (edge$iterator = segment.edges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
    edge = castTo(edge$iterator.next_1(), 16);
    if (segment.isStraight && segment.edges.map_0.size_1() <= 1) {
      xStartPos = segment.boundingBox.x_0;
      xEndPos = segment.boundingBox.x_0 + segment.boundingBox.width_0;
      halfway = new KVector_1(xStartPos + (xEndPos - xStartPos) / 2, segment.centerControlPointY);
      $add_7(castTo(segment.edges.map_0.keySet_0().iterator_0().next_1(), 16).bendPoints, halfway);
      continue;
    }
    ei = castTo($get_6(segment.edgeInformation, edge), 435);
    if (ei.invertedLeft || ei.invertedRight) {
      $calculateControlPointsInvertedEdge(this$static, edge, segment);
      continue;
    }
    sloppy = this$static.splineRoutingMode == ($clinit_SplineRoutingMode() , SLOPPY) && (ei.normalSourceNode || ei.normalTargetNode) && $segmentAllowsSloppyRouting(this$static, segment) && segment.edges.map_0.size_1() <= 1;
    sloppy?$calculateControlPointsSloppy(edge, segment):$calculateControlPointsConservative(this$static, edge, segment);
  }
  segment.inverseOrder && $forEach(segment.edges, new FinalSplineBendpointsCalculator$lambda$5$Type);
}

function $calculateControlPointsConservative(this$static, edge, containingSegment){
  var center, centerXPos, ei, endXPos, isHyperedge, sourceStraightCP, sourceVerticalCP, startXPos, targetStraightCP, targetVerticalCP, ySourceAnchor, yTargetAnchor;
  startXPos = containingSegment.boundingBox.x_0;
  endXPos = containingSegment.boundingBox.x_0 + containingSegment.boundingBox.width_0;
  ei = castTo($get_6(containingSegment.edgeInformation, edge), 435);
  ySourceAnchor = ei.startY;
  yTargetAnchor = ei.endY;
  sourceStraightCP = new KVector_1(startXPos, ySourceAnchor);
  targetStraightCP = new KVector_1(endXPos, yTargetAnchor);
  centerXPos = startXPos;
  containingSegment.isWestOfInitialLayer || (centerXPos += this$static.edgeNodeSpacing);
  centerXPos += containingSegment.xDelta + containingSegment.rank * this$static.edgeEdgeSpacing;
  sourceVerticalCP = new KVector_1(centerXPos, ySourceAnchor);
  targetVerticalCP = new KVector_1(centerXPos, yTargetAnchor);
  $addAll_5(edge.bendPoints, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourceStraightCP, sourceVerticalCP]));
  isHyperedge = containingSegment.edges.map_0.size_1() > 1;
  if (isHyperedge) {
    center = new KVector_1(centerXPos, containingSegment.centerControlPointY);
    $add_7(edge.bendPoints, center);
  }
  $addAll_5(edge.bendPoints, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [targetVerticalCP, targetStraightCP]));
}

function $calculateControlPointsInvertedEdge(this$static, edge, containingSegment){
  var center, centerXPos, ei, endXPos, isHyperedge, sourceStraightCP, sourceVerticalCP, startXPos, targetStraightCP, targetVerticalCP, ySourceAnchor, yTargetAnchor;
  startXPos = containingSegment.boundingBox.x_0;
  endXPos = containingSegment.boundingBox.x_0 + containingSegment.boundingBox.width_0;
  ei = castTo($get_6(containingSegment.edgeInformation, edge), 435);
  ySourceAnchor = ei.startY;
  yTargetAnchor = ei.endY;
  ei.invertedLeft?(sourceStraightCP = new KVector_1(endXPos, ySourceAnchor)):(sourceStraightCP = new KVector_1(startXPos, ySourceAnchor));
  ei.invertedRight?(targetStraightCP = new KVector_1(startXPos, yTargetAnchor)):(targetStraightCP = new KVector_1(endXPos, yTargetAnchor));
  centerXPos = startXPos;
  containingSegment.isWestOfInitialLayer || (centerXPos += this$static.edgeNodeSpacing);
  centerXPos += containingSegment.xDelta + containingSegment.rank * this$static.edgeEdgeSpacing;
  sourceVerticalCP = new KVector_1(centerXPos, ySourceAnchor);
  targetVerticalCP = new KVector_1(centerXPos, yTargetAnchor);
  $addAll_5(edge.bendPoints, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourceStraightCP, sourceVerticalCP]));
  isHyperedge = containingSegment.edges.map_0.size_1() > 1;
  if (isHyperedge) {
    center = new KVector_1(centerXPos, containingSegment.centerControlPointY);
    $add_7(edge.bendPoints, center);
  }
  $addAll_5(edge.bendPoints, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [targetVerticalCP, targetStraightCP]));
}

function $calculateControlPointsSloppy(edge, containingSegment){
  var approx, box, centerXPos, centerYPos, edgePointsDownwards, ei, endXPos, needToCheckSrc, needToCheckTgt, neighbor, neighborIndex, shortCutSource, shortCutTarget, sourceStraightCP, sourceVerticalCP, src_0, startXPos, targetStraightCP, targetVerticalCP, tgt, v1, v2, v3, ySourceAnchor, yTargetAnchor;
  ei = castTo($get_6(containingSegment.edgeInformation, edge), 435);
  startXPos = containingSegment.boundingBox.x_0;
  endXPos = containingSegment.boundingBox.x_0 + containingSegment.boundingBox.width_0;
  ySourceAnchor = ei.startY;
  yTargetAnchor = ei.endY;
  edgePointsDownwards = ySourceAnchor < yTargetAnchor;
  sourceStraightCP = new KVector_1(startXPos, ySourceAnchor);
  targetStraightCP = new KVector_1(endXPos, yTargetAnchor);
  centerXPos = (startXPos + endXPos) / 2;
  sourceVerticalCP = new KVector_1(centerXPos, ySourceAnchor);
  targetVerticalCP = new KVector_1(centerXPos, yTargetAnchor);
  centerYPos = $computeSloppyCenterY(edge, ySourceAnchor, yTargetAnchor);
  v1 = $getAbsoluteAnchor(containingSegment.sourcePort);
  v2 = new KVector_1(centerXPos, centerYPos);
  v3 = $getAbsoluteAnchor(containingSegment.targetPort);
  approx = approximateBezierSegment(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [v1, v2, v3]));
  shortCutSource = false;
  src_0 = containingSegment.sourcePort.owner;
  if (!!src_0 && !!src_0.layer && ei.normalSourceNode) {
    needToCheckSrc = edgePointsDownwards && src_0.id_0 < src_0.layer.nodes.array.length - 1 || !edgePointsDownwards && src_0.id_0 > 0;
    if (needToCheckSrc) {
      neighborIndex = src_0.id_0;
      edgePointsDownwards?++neighborIndex:--neighborIndex;
      neighbor = castTo($get_7(src_0.layer.nodes, neighborIndex), 9);
      box = $nodeToBoundingBox(neighbor);
      shortCutSource = !(intersects_0(box, v1, approx[0]) || contains_44(box, v1, approx[0]));
    }
     else {
      shortCutSource = true;
    }
  }
  shortCutTarget = false;
  tgt = containingSegment.targetPort.owner;
  if (!!tgt && !!tgt.layer && ei.normalTargetNode) {
    needToCheckTgt = edgePointsDownwards && tgt.id_0 > 0 || !edgePointsDownwards && tgt.id_0 < tgt.layer.nodes.array.length - 1;
    if (needToCheckTgt) {
      neighborIndex = tgt.id_0;
      edgePointsDownwards?--neighborIndex:++neighborIndex;
      neighbor = castTo($get_7(tgt.layer.nodes, neighborIndex), 9);
      box = $nodeToBoundingBox(neighbor);
      shortCutTarget = !(intersects_0(box, approx[0], v3) || contains_44(box, approx[0], v3));
    }
     else {
      shortCutTarget = true;
    }
  }
  shortCutSource && shortCutTarget && $add_7(edge.bendPoints, v2);
  shortCutSource || $addAll_5(edge.bendPoints, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourceStraightCP, sourceVerticalCP]));
  shortCutTarget || $addAll_5(edge.bendPoints, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [targetVerticalCP, targetStraightCP]));
}

function $computeSloppyCenterY(edge, ySourceAnchor, yTargetAnchor){
  var centerYPos, degreeDiff, indegree, outdegree, port, port$iterator;
  indegree = 0;
  outdegree = 0;
  if (edge.source) {
    for (port$iterator = new ArrayList$1(edge.target.owner.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      indegree += port.incomingEdges.array.length;
    }
  }
   else {
    indegree = 1;
  }
  if (edge.target) {
    for (port$iterator = new ArrayList$1(edge.source.owner.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      outdegree += port.outgoingEdges.array.length;
    }
  }
   else {
    outdegree = 1;
  }
  degreeDiff = round_int(signum(outdegree - indegree));
  centerYPos = (yTargetAnchor + ySourceAnchor) / 2 + (yTargetAnchor - ySourceAnchor) * (0.4 * degreeDiff);
  return centerYPos;
}

function $indexNodesPerLayer(graph){
  var index_0, l, l$iterator, n, n$iterator;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    index_0 = 0;
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      n.id_0 = index_0++;
    }
  }
}

function $nodeToBoundingBox(node){
  var m, pos, size_0;
  pos = node.pos;
  size_0 = node.size_0;
  m = node.margin;
  return new ElkRectangle_0(pos.x_0 - m.left, pos.y_0 - m.top_0, size_0.x_0 + (m.left + m.right), size_0.y_0 + (m.top_0 + m.bottom));
}

function $process_14(this$static, graph){
  var e, e$iterator, e$iterator0, edgeChain, spline, startEdges, survivingEdge;
  this$static.edgeEdgeSpacing = checkNotNull_1(castToDouble($getProperty(graph, ($clinit_LayeredOptions() , SPACING_EDGE_EDGE_BETWEEN_LAYERS_0))));
  this$static.edgeNodeSpacing = checkNotNull_1(castToDouble($getProperty(graph, SPACING_EDGE_NODE_BETWEEN_LAYERS_0)));
  this$static.splineRoutingMode = castTo($getProperty(graph, EDGE_ROUTING_SPLINES_MODE_0), 327);
  this$static.compactionStrategy = castTo($getProperty(graph, COMPACTION_POST_COMPACTION_STRATEGY_0), 265);
  $indexNodesPerLayer(graph);
  startEdges = castTo($collect_0($filter($filter($flatMap($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(graph.layers, 16)), new FinalSplineBendpointsCalculator$lambda$0$Type), new FinalSplineBendpointsCalculator$lambda$1$Type), new FinalSplineBendpointsCalculator$lambda$2$Type), new FinalSplineBendpointsCalculator$lambda$3$Type), of_3(new Collectors$21methodref$ctor$Type, new Collectors$20methodref$add$Type, new Collectors$lambda$21$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , IDENTITY_FINISH)]))), 15);
  for (e$iterator0 = startEdges.iterator_0(); e$iterator0.hasNext_0();) {
    e = castTo(e$iterator0.next_1(), 16);
    spline = castTo($getProperty(e, ($clinit_InternalProperties_1() , SPLINE_ROUTE_START)), 15);
    spline.forEach_0(new FinalSplineBendpointsCalculator$lambda$4$Type(this$static));
    $setProperty_0(e, SPLINE_ROUTE_START, null);
  }
  for (e$iterator = startEdges.iterator_0(); e$iterator.hasNext_0();) {
    e = castTo(e$iterator.next_1(), 16);
    survivingEdge = castTo($getProperty(e, ($clinit_InternalProperties_1() , SPLINE_SURVIVING_EDGE)), 16);
    edgeChain = castTo($getProperty(e, SPLINE_EDGE_CHAIN), 15);
    $calculateBezierBendPoints(this$static, edgeChain, survivingEdge);
    $setProperty_0(e, SPLINE_EDGE_CHAIN, null);
  }
}

function $segmentAllowsSloppyRouting(this$static, segment){
  var endXPos, n, nodeSegmentDistance, startXPos, t;
  if (this$static.compactionStrategy == ($clinit_GraphCompactionStrategy() , NONE_2)) {
    return true;
  }
  startXPos = segment.boundingBox.x_0;
  endXPos = segment.boundingBox.x_0 + segment.boundingBox.width_0;
  if (segment.initialSegment) {
    n = segment.sourceNode;
    t = n.layer.size_0.x_0 - n.size_0.x_0 / 2;
    nodeSegmentDistance = startXPos - (n.pos.x_0 + n.size_0.x_0);
    if (nodeSegmentDistance > t) {
      return false;
    }
  }
  if (segment.lastSegment) {
    n = segment.targetNode;
    t = n.layer.size_0.x_0 - n.size_0.x_0 / 2;
    nodeSegmentDistance = n.pos.x_0 - endXPos;
    if (nodeSegmentDistance > t) {
      return false;
    }
  }
  return true;
}

function FinalSplineBendpointsCalculator(){
}

defineClass(1386, 1, $intern_108, FinalSplineBendpointsCalculator);
_.process = function process_10(graph, progressMonitor){
  $process_14(this, castTo(graph, 32));
}
;
_.edgeEdgeSpacing = 0;
_.edgeNodeSpacing = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_FinalSplineBendpointsCalculator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'FinalSplineBendpointsCalculator', 1386);
function FinalSplineBendpointsCalculator$lambda$0$Type(){
}

defineClass(1387, 1, $intern_11, FinalSplineBendpointsCalculator$lambda$0$Type);
_.apply_0 = function apply_74(arg0){
  return new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_FinalSplineBendpointsCalculator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'FinalSplineBendpointsCalculator/lambda$0$Type', 1387);
function FinalSplineBendpointsCalculator$lambda$1$Type(){
}

defineClass(1388, 1, $intern_11, FinalSplineBendpointsCalculator$lambda$1$Type);
_.apply_0 = function apply_75(arg0){
  return new Stream$StreamSource(null, new Spliterators$IteratorSpliterator_0($iterator($getOutgoingEdges(castTo(arg0, 9)))));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_FinalSplineBendpointsCalculator$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'FinalSplineBendpointsCalculator/lambda$1$Type', 1388);
function FinalSplineBendpointsCalculator$lambda$2$Type(){
}

defineClass(1389, 1, $intern_90, FinalSplineBendpointsCalculator$lambda$2$Type);
_.test_0 = function test_33(arg0){
  return !$isSelfLoop(castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_FinalSplineBendpointsCalculator$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'FinalSplineBendpointsCalculator/lambda$2$Type', 1389);
function FinalSplineBendpointsCalculator$lambda$3$Type(){
}

defineClass(1390, 1, $intern_90, FinalSplineBendpointsCalculator$lambda$3$Type);
_.test_0 = function test_34(arg0){
  return $hasProperty(castTo(arg0, 16), ($clinit_InternalProperties_1() , SPLINE_ROUTE_START));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_FinalSplineBendpointsCalculator$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'FinalSplineBendpointsCalculator/lambda$3$Type', 1390);
function FinalSplineBendpointsCalculator$lambda$4$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1391, 1, {}, FinalSplineBendpointsCalculator$lambda$4$Type);
_.accept = function accept_59(arg0){
  $calculateControlPoints(this.$$outer_0, castTo(arg0, 121));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_FinalSplineBendpointsCalculator$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'FinalSplineBendpointsCalculator/lambda$4$Type', 1391);
function FinalSplineBendpointsCalculator$lambda$5$Type(){
}

defineClass(1392, 1, {}, FinalSplineBendpointsCalculator$lambda$5$Type);
_.accept = function accept_60(arg0){
  reverse_2(castTo(arg0, 16).bendPoints);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_FinalSplineBendpointsCalculator$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'FinalSplineBendpointsCalculator/lambda$5$Type', 1392);
function $getMirroredPortSideX(side){
  switch (side.ordinal) {
    case 2:
      return $clinit_PortSide() , WEST_1;
    case 4:
      return $clinit_PortSide() , EAST_1;
    default:return side;
  }
}

function $getMirroredPortSideY(side){
  switch (side.ordinal) {
    case 1:
      return $clinit_PortSide() , SOUTH_1;
    case 3:
      return $clinit_PortSide() , NORTH_1;
    default:return side;
  }
}

function $mirrorInLayerConstraintY(node){
  switch (castTo($getProperty(node, ($clinit_InternalProperties_1() , IN_LAYER_CONSTRAINT)), 290).ordinal) {
    case 1:
      $setProperty_0(node, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , BOTTOM_0));
      break;
    case 2:
      $setProperty_0(node, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , TOP_0));
  }
}

function $mirrorLayerConstraintX(node){
  switch (castTo($getProperty(node, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0)), 183).ordinal) {
    case 1:
      $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, ($clinit_LayerConstraint() , LAST));
      break;
    case 2:
      $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, ($clinit_LayerConstraint() , LAST_SEPARATE));
      break;
    case 3:
      $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, ($clinit_LayerConstraint() , FIRST));
      break;
    case 4:
      $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, ($clinit_LayerConstraint() , FIRST_SEPARATE));
  }
}

function $mirrorNodeLabelPlacementX(shape_0){
  var oldPlacement;
  if (!$hasProperty(shape_0, ($clinit_LayeredOptions() , NODE_LABELS_PLACEMENT))) {
    return;
  }
  oldPlacement = castTo($getProperty(shape_0, NODE_LABELS_PLACEMENT), 19);
  if (oldPlacement.contains(($clinit_NodeLabelPlacement() , H_LEFT_0))) {
    oldPlacement.remove_1(H_LEFT_0);
    oldPlacement.add_1(H_RIGHT_0);
  }
   else if (oldPlacement.contains(H_RIGHT_0)) {
    oldPlacement.remove_1(H_RIGHT_0);
    oldPlacement.add_1(H_LEFT_0);
  }
}

function $mirrorNodeLabelPlacementY(shape_0){
  var oldPlacement;
  if (!$hasProperty(shape_0, ($clinit_LayeredOptions() , NODE_LABELS_PLACEMENT))) {
    return;
  }
  oldPlacement = castTo($getProperty(shape_0, NODE_LABELS_PLACEMENT), 19);
  if (oldPlacement.contains(($clinit_NodeLabelPlacement() , V_TOP_0))) {
    oldPlacement.remove_1(V_TOP_0);
    oldPlacement.add_1(V_BOTTOM_0);
  }
   else if (oldPlacement.contains(V_BOTTOM_0)) {
    oldPlacement.remove_1(V_BOTTOM_0);
    oldPlacement.add_1(V_TOP_0);
  }
}

function $mirrorX(nodes, graph){
  var bendPoint, bendPoint$iterator, edge, edge$iterator, index_0, jp, jp$iterator, junctionPoints, label_0, label$iterator, label$iterator0, label$iterator1, node, node$iterator, node$iterator0, nodeSize, offset, port, port$iterator;
  offset = 0;
  if (graph.size_0.x_0 == 0) {
    for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      offset = $wnd.Math.max(offset, node.pos.x_0 + node.size_0.x_0 + node.margin.right);
    }
  }
   else {
    offset = graph.size_0.x_0 - graph.offset.x_0;
  }
  offset -= graph.offset.x_0;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $mirrorX_1(node.pos, offset - node.size_0.x_0);
    $mirrorX_0(node.padding);
    $mirrorNodeLabelPlacementX(node);
    (!node.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):node.propertyMap).containsKey(($clinit_LayeredOptions() , POSITION)) && $mirrorX_1(castTo($getProperty(node, POSITION), 8), offset - node.size_0.x_0);
    switch (castTo($getProperty(node, ALIGNMENT), 234).ordinal) {
      case 1:
        $setProperty_0(node, ALIGNMENT, ($clinit_Alignment() , RIGHT_4));
        break;
      case 2:
        $setProperty_0(node, ALIGNMENT, ($clinit_Alignment() , LEFT_4));
    }
    nodeSize = node.size_0;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      $mirrorX_1(port.pos, nodeSize.x_0 - port.size_0.x_0);
      $mirrorX_1(port.anchor, port.size_0.x_0);
      $setSide(port, $getMirroredPortSideX(port.side));
      index_0 = castTo($getProperty(port, PORT_INDEX), 21);
      !!index_0 && $setProperty_0(port, PORT_INDEX, valueOf_4(-index_0.value_0));
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        for (bendPoint$iterator = $listIterator_1(edge.bendPoints, 0); bendPoint$iterator.currentNode != bendPoint$iterator.this$01.tail;) {
          bendPoint = castTo($next_13(bendPoint$iterator), 8);
          bendPoint.x_0 = offset - bendPoint.x_0;
        }
        junctionPoints = castTo($getProperty(edge, JUNCTION_POINTS), 74);
        if (junctionPoints) {
          for (jp$iterator = $listIterator_1(junctionPoints, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
            jp = castTo($next_13(jp$iterator), 8);
            jp.x_0 = offset - jp.x_0;
          }
        }
        for (label$iterator0 = new ArrayList$1(edge.labels); label$iterator0.i < label$iterator0.this$01.array.length;) {
          label_0 = castTo($next_10(label$iterator0), 70);
          $mirrorX_1(label_0.pos, offset - label_0.size_0.x_0);
        }
      }
      for (label$iterator1 = new ArrayList$1(port.labels); label$iterator1.i < label$iterator1.this$01.array.length;) {
        label_0 = castTo($next_10(label$iterator1), 70);
        $mirrorX_1(label_0.pos, -label_0.size_0.x_0);
      }
    }
    if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      $setProperty_0(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE), $getMirroredPortSideX(castTo($getProperty(node, EXT_PORT_SIDE), 71)));
      $mirrorLayerConstraintX(node);
    }
    for (label$iterator = new ArrayList$1(node.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 70);
      $mirrorNodeLabelPlacementX(label_0);
      $mirrorX_1(label_0.pos, nodeSize.x_0 - label_0.size_0.x_0);
    }
  }
}

function $mirrorX_0(padding){
  var oldLeft, oldRight;
  oldLeft = padding.left;
  oldRight = padding.right;
  padding.left = oldRight;
  padding.right = oldLeft;
}

function $mirrorX_1(v, offset){
  v.x_0 = offset - v.x_0;
}

function $mirrorY(nodes, graph){
  var bendPoint, bendPoint$iterator, edge, edge$iterator, index_0, jp, jp$iterator, junctionPoints, label_0, label$iterator, label$iterator0, label$iterator1, node, node$iterator, node$iterator0, nodeSize, offset, port, port$iterator;
  offset = 0;
  if (graph.size_0.y_0 == 0) {
    for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      offset = $wnd.Math.max(offset, node.pos.y_0 + node.size_0.y_0 + node.margin.bottom);
    }
  }
   else {
    offset = graph.size_0.y_0 - graph.offset.y_0;
  }
  offset -= graph.offset.y_0;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $mirrorY_1(node.pos, offset - node.size_0.y_0);
    $mirrorY_0(node.padding);
    $mirrorNodeLabelPlacementY(node);
    (!node.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):node.propertyMap).containsKey(($clinit_LayeredOptions() , POSITION)) && $mirrorY_1(castTo($getProperty(node, POSITION), 8), offset - node.size_0.y_0);
    switch (castTo($getProperty(node, ALIGNMENT), 234).ordinal) {
      case 3:
        $setProperty_0(node, ALIGNMENT, ($clinit_Alignment() , BOTTOM_1));
        break;
      case 4:
        $setProperty_0(node, ALIGNMENT, ($clinit_Alignment() , TOP_1));
    }
    nodeSize = node.size_0;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      $mirrorY_1(port.pos, nodeSize.y_0 - port.size_0.y_0);
      $mirrorY_1(port.anchor, port.size_0.y_0);
      $setSide(port, $getMirroredPortSideY(port.side));
      index_0 = castTo($getProperty(port, PORT_INDEX), 21);
      !!index_0 && $setProperty_0(port, PORT_INDEX, valueOf_4(-index_0.value_0));
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        for (bendPoint$iterator = $listIterator_1(edge.bendPoints, 0); bendPoint$iterator.currentNode != bendPoint$iterator.this$01.tail;) {
          bendPoint = castTo($next_13(bendPoint$iterator), 8);
          bendPoint.y_0 = offset - bendPoint.y_0;
        }
        junctionPoints = castTo($getProperty(edge, JUNCTION_POINTS), 74);
        if (junctionPoints) {
          for (jp$iterator = $listIterator_1(junctionPoints, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
            jp = castTo($next_13(jp$iterator), 8);
            jp.y_0 = offset - jp.y_0;
          }
        }
        for (label$iterator0 = new ArrayList$1(edge.labels); label$iterator0.i < label$iterator0.this$01.array.length;) {
          label_0 = castTo($next_10(label$iterator0), 70);
          $mirrorY_1(label_0.pos, offset - label_0.size_0.y_0);
        }
      }
      for (label$iterator1 = new ArrayList$1(port.labels); label$iterator1.i < label$iterator1.this$01.array.length;) {
        label_0 = castTo($next_10(label$iterator1), 70);
        $mirrorY_1(label_0.pos, -label_0.size_0.y_0);
      }
    }
    if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      $setProperty_0(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE), $getMirroredPortSideY(castTo($getProperty(node, EXT_PORT_SIDE), 71)));
      $mirrorInLayerConstraintY(node);
    }
    for (label$iterator = new ArrayList$1(node.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 70);
      $mirrorNodeLabelPlacementY(label_0);
      $mirrorY_1(label_0.pos, nodeSize.y_0 - label_0.size_0.y_0);
    }
  }
}

function $mirrorY_0(padding){
  var oldBottom, oldTop;
  oldTop = padding.top_0;
  oldBottom = padding.bottom;
  padding.top_0 = oldBottom;
  padding.bottom = oldTop;
}

function $mirrorY_1(v, offset){
  v.y_0 = offset - v.y_0;
}

function $process_15(this$static, layeredGraph, monitor){
  var congruency, layer, layer$iterator, nodes;
  $begin(monitor, 'Graph transformation (' + this$static.mode + ')', 1);
  nodes = newArrayList(layeredGraph.layerlessNodes);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    $addAll_2(nodes, layer.nodes);
  }
  congruency = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , DIRECTION_CONGRUENCY_0)), 397);
  if (congruency == ($clinit_DirectionCongruency() , READING_DIRECTION)) {
    switch (castTo($getProperty(layeredGraph, DIRECTION), 107).ordinal) {
      case 2:
        $mirrorX(nodes, layeredGraph);
        $mirrorX_0(layeredGraph.padding);
        break;
      case 3:
        $transposeAll(layeredGraph, nodes);
        break;
      case 4:
        if (this$static.mode == ($clinit_GraphTransformer$Mode() , TO_INTERNAL_LTR)) {
          $transposeAll(layeredGraph, nodes);
          $mirrorY(nodes, layeredGraph);
          $mirrorY_0(layeredGraph.padding);
        }
         else {
          $mirrorY(nodes, layeredGraph);
          $mirrorY_0(layeredGraph.padding);
          $transposeAll(layeredGraph, nodes);
        }

    }
  }
   else {
    if (this$static.mode == ($clinit_GraphTransformer$Mode() , TO_INTERNAL_LTR)) {
      switch (castTo($getProperty(layeredGraph, DIRECTION), 107).ordinal) {
        case 2:
          $mirrorX(nodes, layeredGraph);
          $mirrorX_0(layeredGraph.padding);
          $mirrorY(nodes, layeredGraph);
          $mirrorY_0(layeredGraph.padding);
          break;
        case 3:
          $transposeAll(layeredGraph, nodes);
          $mirrorX(nodes, layeredGraph);
          $mirrorX_0(layeredGraph.padding);
          break;
        case 4:
          $mirrorX(nodes, layeredGraph);
          $mirrorX_0(layeredGraph.padding);
          $transposeAll(layeredGraph, nodes);
      }
    }
     else {
      switch (castTo($getProperty(layeredGraph, DIRECTION), 107).ordinal) {
        case 2:
          $mirrorX(nodes, layeredGraph);
          $mirrorX_0(layeredGraph.padding);
          $mirrorY(nodes, layeredGraph);
          $mirrorY_0(layeredGraph.padding);
          break;
        case 3:
          $mirrorX(nodes, layeredGraph);
          $mirrorX_0(layeredGraph.padding);
          $transposeAll(layeredGraph, nodes);
          break;
        case 4:
          $transposeAll(layeredGraph, nodes);
          $mirrorX(nodes, layeredGraph);
          $mirrorX_0(layeredGraph.padding);
      }
    }
  }
  $done_0(monitor);
}

function $transpose(nodes){
  var bendPoint, bendPoint$iterator, edge, edge$iterator, index_0, jp, jp$iterator, junctionPoints, label_0, label$iterator, label$iterator0, label$iterator1, node, node$iterator, port, port$iterator;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $transpose_1(node.pos);
    $transpose_1(node.size_0);
    $transpose_0(node.padding);
    $transposeNodeLabelPlacement(node);
    $transposeProperties(node);
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      $transpose_1(port.pos);
      $transpose_1(port.anchor);
      $transpose_1(port.size_0);
      $setSide(port, $transposePortSide(port.side));
      index_0 = castTo($getProperty(port, ($clinit_LayeredOptions() , PORT_INDEX)), 21);
      !!index_0 && $setProperty_0(port, PORT_INDEX, valueOf_4(-index_0.value_0));
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        for (bendPoint$iterator = $listIterator_1(edge.bendPoints, 0); bendPoint$iterator.currentNode != bendPoint$iterator.this$01.tail;) {
          bendPoint = castTo($next_13(bendPoint$iterator), 8);
          $transpose_1(bendPoint);
        }
        junctionPoints = castTo($getProperty(edge, JUNCTION_POINTS), 74);
        if (junctionPoints) {
          for (jp$iterator = $listIterator_1(junctionPoints, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
            jp = castTo($next_13(jp$iterator), 8);
            $transpose_1(jp);
          }
        }
        for (label$iterator0 = new ArrayList$1(edge.labels); label$iterator0.i < label$iterator0.this$01.array.length;) {
          label_0 = castTo($next_10(label$iterator0), 70);
          $transpose_1(label_0.pos);
          $transpose_1(label_0.size_0);
        }
      }
      for (label$iterator1 = new ArrayList$1(port.labels); label$iterator1.i < label$iterator1.this$01.array.length;) {
        label_0 = castTo($next_10(label$iterator1), 70);
        $transpose_1(label_0.pos);
        $transpose_1(label_0.size_0);
      }
    }
    if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      $setProperty_0(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE), $transposePortSide(castTo($getProperty(node, EXT_PORT_SIDE), 71)));
      $transposeLayerConstraint(node);
    }
    for (label$iterator = new ArrayList$1(node.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 70);
      $transposeNodeLabelPlacement(label_0);
      $transpose_1(label_0.size_0);
      $transpose_1(label_0.pos);
    }
  }
}

function $transpose_0(padding){
  var oldBottom, oldLeft, oldRight, oldTop;
  oldTop = padding.top_0;
  oldBottom = padding.bottom;
  oldLeft = padding.left;
  oldRight = padding.right;
  padding.top_0 = oldLeft;
  padding.bottom = oldRight;
  padding.left = oldTop;
  padding.right = oldBottom;
}

function $transpose_1(v){
  var temp;
  temp = v.x_0;
  v.x_0 = v.y_0;
  v.y_0 = temp;
}

function $transposeAll(layeredGraph, nodes){
  var oldSide;
  $transpose(nodes);
  oldSide = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , EDGE_LABELS_SIDE_SELECTION_0)), 266);
  !!oldSide && $setProperty_0(layeredGraph, EDGE_LABELS_SIDE_SELECTION_0, $transpose_2(oldSide));
  $transpose_1(layeredGraph.offset);
  $transpose_1(layeredGraph.size_0);
  $transpose_0(layeredGraph.padding);
}

function $transposeLayerConstraint(node){
  var inLayerConstraint, layerConstraint;
  layerConstraint = castTo($getProperty(node, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0)), 183);
  inLayerConstraint = castTo($getProperty(node, ($clinit_InternalProperties_1() , IN_LAYER_CONSTRAINT)), 290);
  if (layerConstraint == ($clinit_LayerConstraint() , FIRST_SEPARATE)) {
    $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, NONE_4);
    $setProperty_0(node, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , TOP_0));
  }
   else if (layerConstraint == LAST_SEPARATE) {
    $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, NONE_4);
    $setProperty_0(node, IN_LAYER_CONSTRAINT, ($clinit_InLayerConstraint() , BOTTOM_0));
  }
   else if (inLayerConstraint == ($clinit_InLayerConstraint() , TOP_0)) {
    $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, FIRST_SEPARATE);
    $setProperty_0(node, IN_LAYER_CONSTRAINT, NONE_3);
  }
   else if (inLayerConstraint == BOTTOM_0) {
    $setProperty_0(node, LAYERING_LAYER_CONSTRAINT_0, LAST_SEPARATE);
    $setProperty_0(node, IN_LAYER_CONSTRAINT, NONE_3);
  }
}

function $transposeNodeLabelPlacement(shape_0){
  var all, newPlacement, oldPlacement;
  if (!$hasProperty(shape_0, ($clinit_LayeredOptions() , NODE_LABELS_PLACEMENT))) {
    return;
  }
  oldPlacement = castTo($getProperty(shape_0, NODE_LABELS_PLACEMENT), 19);
  if (oldPlacement.isEmpty()) {
    return;
  }
  newPlacement = (all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  oldPlacement.contains(($clinit_NodeLabelPlacement() , INSIDE))?$add_5(newPlacement, INSIDE):$add_5(newPlacement, OUTSIDE);
  oldPlacement.contains(H_PRIORITY) || $add_5(newPlacement, H_PRIORITY);
  oldPlacement.contains(H_LEFT_0)?$add_5(newPlacement, V_TOP_0):oldPlacement.contains(H_CENTER_0)?$add_5(newPlacement, V_CENTER_0):oldPlacement.contains(H_RIGHT_0) && $add_5(newPlacement, V_BOTTOM_0);
  oldPlacement.contains(V_TOP_0)?$add_5(newPlacement, H_LEFT_0):oldPlacement.contains(V_CENTER_0)?$add_5(newPlacement, H_CENTER_0):oldPlacement.contains(V_BOTTOM_0) && $add_5(newPlacement, H_RIGHT_0);
  $setProperty_0(shape_0, NODE_LABELS_PLACEMENT, newPlacement);
}

function $transposePortSide(side){
  switch (side.ordinal) {
    case 1:
      return $clinit_PortSide() , WEST_1;
    case 4:
      return $clinit_PortSide() , NORTH_1;
    case 3:
      return $clinit_PortSide() , EAST_1;
    case 2:
      return $clinit_PortSide() , SOUTH_1;
    default:return $clinit_PortSide() , UNDEFINED_7;
  }
}

function $transposeProperties(node){
  var minSize, pos, tmp;
  minSize = castTo($getProperty(node, ($clinit_LayeredOptions() , NODE_SIZE_MINIMUM)), 8);
  $setProperty_0(node, NODE_SIZE_MINIMUM, new KVector_1(minSize.y_0, minSize.x_0));
  switch (castTo($getProperty(node, ALIGNMENT), 234).ordinal) {
    case 1:
      $setProperty_0(node, ALIGNMENT, ($clinit_Alignment() , TOP_1));
      break;
    case 2:
      $setProperty_0(node, ALIGNMENT, ($clinit_Alignment() , BOTTOM_1));
      break;
    case 3:
      $setProperty_0(node, ALIGNMENT, ($clinit_Alignment() , LEFT_4));
      break;
    case 4:
      $setProperty_0(node, ALIGNMENT, ($clinit_Alignment() , RIGHT_4));
  }
  if ((!node.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):node.propertyMap).containsKey(POSITION)) {
    pos = castTo($getProperty(node, POSITION), 8);
    tmp = pos.x_0;
    pos.x_0 = pos.y_0;
    pos.y_0 = tmp;
  }
}

function GraphTransformer(themode){
  this.mode = themode;
}

defineClass(735, 1, $intern_108, GraphTransformer);
_.process = function process_11(layeredGraph, monitor){
  $process_15(this, castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_GraphTransformer_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'GraphTransformer', 735);
function $clinit_GraphTransformer$Mode(){
  $clinit_GraphTransformer$Mode = emptyMethod;
  TO_INTERNAL_LTR = new GraphTransformer$Mode('TO_INTERNAL_LTR', 0);
  TO_INPUT_DIRECTION = new GraphTransformer$Mode('TO_INPUT_DIRECTION', 1);
}

function GraphTransformer$Mode(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_30(name_0){
  $clinit_GraphTransformer$Mode();
  return valueOf(($clinit_GraphTransformer$Mode$Map() , $MAP_18), name_0);
}

function values_26(){
  $clinit_GraphTransformer$Mode();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_intermediate_GraphTransformer$Mode_2_classLit, 1), $intern_38, 481, 0, [TO_INTERNAL_LTR, TO_INPUT_DIRECTION]);
}

defineClass(481, 22, {3:1, 34:1, 22:1, 481:1}, GraphTransformer$Mode);
var TO_INPUT_DIRECTION, TO_INTERNAL_LTR;
var Lorg_eclipse_elk_alg_layered_intermediate_GraphTransformer$Mode_2_classLit = createForEnum('org.eclipse.elk.alg.layered.intermediate', 'GraphTransformer/Mode', 481, Ljava_lang_Enum_2_classLit, values_26, valueOf_30);
function $clinit_GraphTransformer$Mode$Map(){
  $clinit_GraphTransformer$Mode$Map = emptyMethod;
  $MAP_18 = createValueOfMap(($clinit_GraphTransformer$Mode() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_intermediate_GraphTransformer$Mode_2_classLit, 1), $intern_38, 481, 0, [TO_INTERNAL_LTR, TO_INPUT_DIRECTION])));
}

var $MAP_18;
function $graphLayoutToNode(node, lgraph){
  var actualGraphSize, childNode, childNode$iterator, origin, port, portPosition;
  for (childNode$iterator = new ArrayList$1(lgraph.layerlessNodes); childNode$iterator.i < childNode$iterator.this$01.array.length;) {
    childNode = castTo($next_10(childNode$iterator), 9);
    origin = $getProperty(childNode, ($clinit_InternalProperties_1() , ORIGIN_0));
    if (instanceOf(origin, 11)) {
      port = castTo(origin, 11);
      portPosition = getExternalPortPosition(lgraph, childNode, port.size_0.x_0, port.size_0.y_0);
      port.pos.x_0 = portPosition.x_0;
      port.pos.y_0 = portPosition.y_0;
      $setSide(port, castTo($getProperty(childNode, EXT_PORT_SIDE), 71));
    }
  }
  actualGraphSize = new KVector_1(lgraph.size_0.x_0 + lgraph.padding.left + lgraph.padding.right, lgraph.size_0.y_0 + lgraph.padding.top_0 + lgraph.padding.bottom);
  if (castTo($getProperty(lgraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
    $setProperty_0(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
    castTo($getProperty($getGraph(node), GRAPH_PROPERTIES), 19).add_1(NON_FREE_PORTS);
    resizeNode(node, actualGraphSize, false);
  }
   else {
    resizeNode(node, actualGraphSize, true);
  }
}

function $process_16(graph, progressMonitor){
  var layer, layer$iterator, node, node$iterator;
  $begin(progressMonitor, 'Resize child graph to fit parent.', 1);
  for (layer$iterator = new ArrayList$1(graph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    $addAll_2(graph.layerlessNodes, layer.nodes);
    layer.nodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  }
  for (node$iterator = new ArrayList$1(graph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $setLayer_0(node, null);
  }
  graph.layers.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $resizeGraph_0(graph);
  !!castTo($getProperty(graph, ($clinit_InternalProperties_1() , PARENT_LNODE)), 9) && $graphLayoutToNode(castTo($getProperty(graph, PARENT_LNODE), 9), graph);
  $done_0(progressMonitor);
}

function $resizeGraph_0(lgraph){
  var adjustedSize, calculatedSize, minSize, sizeConstraint, sizeOptions;
  sizeConstraint = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , NODE_SIZE_CONSTRAINTS)), 19);
  sizeOptions = castTo($getProperty(lgraph, NODE_SIZE_OPTIONS), 19);
  calculatedSize = new KVector_1(lgraph.size_0.x_0 + lgraph.padding.left + lgraph.padding.right, lgraph.size_0.y_0 + lgraph.padding.top_0 + lgraph.padding.bottom);
  adjustedSize = new KVector_2(calculatedSize);
  if (sizeConstraint.contains(($clinit_SizeConstraint() , MINIMUM_SIZE))) {
    minSize = castTo($getProperty(lgraph, NODE_SIZE_MINIMUM), 8);
    if (sizeOptions.contains(($clinit_SizeOptions() , DEFAULT_MINIMUM_SIZE))) {
      minSize.x_0 <= 0 && (minSize.x_0 = 20);
      minSize.y_0 <= 0 && (minSize.y_0 = 20);
    }
    adjustedSize.x_0 = $wnd.Math.max(calculatedSize.x_0, minSize.x_0);
    adjustedSize.y_0 = $wnd.Math.max(calculatedSize.y_0, minSize.y_0);
  }
  $resizeGraphNoReallyIMeanIt_0(lgraph, calculatedSize, adjustedSize);
}

function $resizeGraphNoReallyIMeanIt_0(lgraph, oldSize, newSize){
  var contentAlignment, extPortSide, node, node$iterator, padding;
  contentAlignment = castTo($getProperty(lgraph, ($clinit_LayeredOptions() , CONTENT_ALIGNMENT_0)), 19);
  newSize.x_0 > oldSize.x_0 && (contentAlignment.contains(($clinit_ContentAlignment() , H_CENTER))?(lgraph.offset.x_0 += (newSize.x_0 - oldSize.x_0) / 2):contentAlignment.contains(H_RIGHT) && (lgraph.offset.x_0 += newSize.x_0 - oldSize.x_0));
  newSize.y_0 > oldSize.y_0 && (contentAlignment.contains(($clinit_ContentAlignment() , V_CENTER))?(lgraph.offset.y_0 += (newSize.y_0 - oldSize.y_0) / 2):contentAlignment.contains(V_BOTTOM) && (lgraph.offset.y_0 += newSize.y_0 - oldSize.y_0));
  if (castTo($getProperty(lgraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS)) && (newSize.x_0 > oldSize.x_0 || newSize.y_0 > oldSize.y_0)) {
    for (node$iterator = new ArrayList$1(lgraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        extPortSide = castTo($getProperty(node, EXT_PORT_SIDE), 71);
        extPortSide == ($clinit_PortSide() , EAST_1)?(node.pos.x_0 += newSize.x_0 - oldSize.x_0):extPortSide == SOUTH_1 && (node.pos.y_0 += newSize.y_0 - oldSize.y_0);
      }
    }
  }
  padding = lgraph.padding;
  lgraph.size_0.x_0 = newSize.x_0 - padding.left - padding.right;
  lgraph.size_0.y_0 = newSize.y_0 - padding.top_0 - padding.bottom;
}

function HierarchicalNodeResizingProcessor(){
}

defineClass(1393, 1, $intern_108, HierarchicalNodeResizingProcessor);
_.process = function process_12(graph, progressMonitor){
  $process_16(castTo(graph, 32), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HierarchicalNodeResizingProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HierarchicalNodeResizingProcessor', 1393);
function $createDummy(layeredGraph, originalDummy){
  var inputPort, newDummy, outputPort;
  newDummy = new LNode(layeredGraph);
  $copyProperties(newDummy, originalDummy);
  $setProperty_0(newDummy, ($clinit_InternalProperties_1() , EXT_PORT_REPLACED_DUMMY), originalDummy);
  $setProperty_0(newDummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty_0(newDummy, ALIGNMENT, ($clinit_Alignment() , CENTER_3));
  $setType(newDummy, ($clinit_LNode$NodeType() , EXTERNAL_PORT));
  inputPort = new LPort;
  $setNode(inputPort, newDummy);
  $setSide(inputPort, ($clinit_PortSide() , WEST_1));
  outputPort = new LPort;
  $setNode(outputPort, newDummy);
  $setSide(outputPort, EAST_1);
  return newDummy;
}

function $isNorthernOrSouthernDummy(node){
  var nodeType, portSide;
  nodeType = node.type_0;
  if (nodeType == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    portSide = castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
    return portSide == ($clinit_PortSide() , NORTH_1) || portSide == SOUTH_1;
  }
  return false;
}

function $process_17(layeredGraph, monitor){
  $begin(monitor, 'Hierarchical port constraint processing', 1);
  $processEasternAndWesternPortDummies(layeredGraph);
  $processNorthernAndSouthernPortDummies(layeredGraph);
  $done_0(monitor);
}

function $processEasternAndWesternPortDummies(layeredGraph){
  var layers;
  if (!$isOrderFixed(castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
    return;
  }
  layers = layeredGraph.layers;
  $processEasternAndWesternPortDummies_0((checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 25)));
  $processEasternAndWesternPortDummies_0(castTo($get_7(layers, layers.array.length - 1), 25));
}

function $processEasternAndWesternPortDummies_0(layer){
  var externalPortSide, lastHierarchicalDummy, node, node$index, node$max, nodes;
  nodes = castTo($toArray_2(layer.nodes, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, layer.nodes.array.length, 0, 1)), 125);
  sort_5(nodes, new HierarchicalPortConstraintProcessor$NodeComparator);
  lastHierarchicalDummy = null;
  for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {
    node = nodes[node$index];
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      break;
    }
    externalPortSide = castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
    if (externalPortSide != ($clinit_PortSide() , WEST_1) && externalPortSide != EAST_1) {
      continue;
    }
    !!lastHierarchicalDummy && castTo($getProperty(lastHierarchicalDummy, IN_LAYER_SUCCESSOR_CONSTRAINTS), 15).add_1(node);
    lastHierarchicalDummy = node;
  }
}

function $processNorthernAndSouthernPortDummies(layeredGraph){
  var currLayerIdx, currentLayer, currentNode, currentNode$iterator, dummy, dummy$iterator, edge, edge$iterator, edge$iterator0, extPortToDummyNodeMap, i, layer, layerCount, layers, newDummyNodes, nextExtPortToDummyNodesMap, nextLayerDummy, nextNewDummyNodes, nodeList, originalDummy, originalDummy$iterator, originalExternalPortDummies, portConstraints, prevExtPortToDummyNodesMap, prevLayerDummy, prevNewDummyNodes, sourceNode, targetNode;
  portConstraints = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
  if (!(portConstraints != ($clinit_PortConstraints() , FREE) && portConstraints != UNDEFINED_6)) {
    return;
  }
  layers = layeredGraph.layers;
  layerCount = layers.array.length;
  extPortToDummyNodeMap = new ArrayList_0((checkNonnegative(layerCount + 2, 'arraySize') , saturatedCast(add_20(add_20(5, layerCount + 2), (layerCount + 2) / 10 | 0))));
  newDummyNodes = new ArrayList_0((checkNonnegative(layerCount + 2, 'arraySize') , saturatedCast(add_20(add_20(5, layerCount + 2), (layerCount + 2) / 10 | 0))));
  $add_4(extPortToDummyNodeMap, new HashMap);
  $add_4(extPortToDummyNodeMap, new HashMap);
  $add_4(newDummyNodes, new ArrayList);
  $add_4(newDummyNodes, new ArrayList);
  originalExternalPortDummies = new ArrayList;
  for (currLayerIdx = 0; currLayerIdx < layerCount; currLayerIdx++) {
    currentLayer = (checkCriticalElementIndex(currLayerIdx, layers.array.length) , castTo(layers.array[currLayerIdx], 25));
    prevExtPortToDummyNodesMap = (checkCriticalElementIndex(currLayerIdx, extPortToDummyNodeMap.array.length) , castTo(extPortToDummyNodeMap.array[currLayerIdx], 111));
    nextExtPortToDummyNodesMap = ($clinit_Maps() , new HashMap);
    extPortToDummyNodeMap.array[extPortToDummyNodeMap.array.length] = nextExtPortToDummyNodesMap;
    prevNewDummyNodes = (checkCriticalElementIndex(currLayerIdx, newDummyNodes.array.length) , castTo(newDummyNodes.array[currLayerIdx], 15));
    nextNewDummyNodes = new ArrayList;
    newDummyNodes.array[newDummyNodes.array.length] = nextNewDummyNodes;
    for (currentNode$iterator = new ArrayList$1(currentLayer.nodes); currentNode$iterator.i < currentNode$iterator.this$01.array.length;) {
      currentNode = castTo($next_10(currentNode$iterator), 9);
      if ($isNorthernOrSouthernDummy(currentNode)) {
        originalExternalPortDummies.array[originalExternalPortDummies.array.length] = currentNode;
        continue;
      }
      for (edge$iterator0 = $iterator($getIncomingEdges(currentNode)); $hasNext_0(edge$iterator0);) {
        edge = castTo($next_2(edge$iterator0), 16);
        sourceNode = edge.source.owner;
        if (!$isNorthernOrSouthernDummy(sourceNode)) {
          continue;
        }
        prevLayerDummy = castTo(prevExtPortToDummyNodesMap.get_0($getProperty(sourceNode, ($clinit_InternalProperties_1() , ORIGIN_0))), 9);
        if (!prevLayerDummy) {
          prevLayerDummy = $createDummy(layeredGraph, sourceNode);
          prevExtPortToDummyNodesMap.put($getProperty(sourceNode, ORIGIN_0), prevLayerDummy);
          prevNewDummyNodes.add_1(prevLayerDummy);
        }
        $setSource_0(edge, castTo($get_7(prevLayerDummy.ports, 1), 11));
      }
      for (edge$iterator = $iterator($getOutgoingEdges(currentNode)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        targetNode = edge.target.owner;
        if (!$isNorthernOrSouthernDummy(targetNode)) {
          continue;
        }
        nextLayerDummy = castTo($get_6(nextExtPortToDummyNodesMap, $getProperty(targetNode, ($clinit_InternalProperties_1() , ORIGIN_0))), 9);
        if (!nextLayerDummy) {
          nextLayerDummy = $createDummy(layeredGraph, targetNode);
          $put_1(nextExtPortToDummyNodesMap, $getProperty(targetNode, ORIGIN_0), nextLayerDummy);
          nextNewDummyNodes.array[nextNewDummyNodes.array.length] = nextLayerDummy;
        }
        $setTarget_0(edge, castTo($get_7(nextLayerDummy.ports, 0), 11));
      }
    }
  }
  for (i = 0; i < newDummyNodes.array.length; i++) {
    nodeList = (checkCriticalElementIndex(i, newDummyNodes.array.length) , castTo(newDummyNodes.array[i], 15));
    if (nodeList.isEmpty()) {
      continue;
    }
    if (i == 0) {
      layer = new Layer(layeredGraph);
      checkCriticalPositionIndex(0, layers.array.length);
      insertTo(layers.array, 0, layer);
    }
     else if (i == extPortToDummyNodeMap.array.length - 1) {
      layer = new Layer(layeredGraph);
      layers.array[layers.array.length] = layer;
    }
     else {
      layer = (checkCriticalElementIndex(i - 1, layers.array.length) , castTo(layers.array[i - 1], 25));
    }
    for (dummy$iterator = nodeList.iterator_0(); dummy$iterator.hasNext_0();) {
      dummy = castTo(dummy$iterator.next_1(), 9);
      $setLayer_0(dummy, layer);
    }
  }
  for (originalDummy$iterator = new ArrayList$1(originalExternalPortDummies); originalDummy$iterator.i < originalDummy$iterator.this$01.array.length;) {
    originalDummy = castTo($next_10(originalDummy$iterator), 9);
    $setLayer_0(originalDummy, null);
  }
  $setProperty_0(layeredGraph, ($clinit_InternalProperties_1() , EXT_PORT_REPLACED_DUMMIES), originalExternalPortDummies);
}

function HierarchicalPortConstraintProcessor(){
}

defineClass(1394, 1, $intern_108, HierarchicalPortConstraintProcessor);
_.process = function process_13(layeredGraph, monitor){
  $process_17(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HierarchicalPortConstraintProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HierarchicalPortConstraintProcessor', 1394);
function $compare_11(node1, node2){
  var nodePos1, nodePos2, nodeType1, nodeType2;
  nodeType1 = node1.type_0;
  nodePos1 = checkNotNull_1(castToDouble($getProperty(node1, ($clinit_InternalProperties_1() , PORT_RATIO_OR_POSITION_0))));
  nodeType2 = node2.type_0;
  nodePos2 = checkNotNull_1(castToDouble($getProperty(node2, PORT_RATIO_OR_POSITION_0)));
  return nodeType2 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)?-1:nodeType1 != EXTERNAL_PORT?1:nodePos1 == nodePos2?0:nodePos1 < nodePos2?-1:1;
}

function HierarchicalPortConstraintProcessor$NodeComparator(){
}

defineClass(1395, 1, $intern_40, HierarchicalPortConstraintProcessor$NodeComparator);
_.compare_0 = function compare_41(node1, node2){
  return $compare_11(castTo(node1, 9), castTo(node2, 9));
}
;
_.equals_0 = function equals_109(other){
  return this === other;
}
;
_.reversed = function reversed_33(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HierarchicalPortConstraintProcessor$NodeComparator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HierarchicalPortConstraintProcessor/NodeComparator', 1395);
function $process_18(layeredGraph, monitor){
  var delta, edgeSpacing, layer, layer$iterator, node, node$iterator, northernDummies, side, southernDummies;
  $begin(monitor, 'Hierarchical port dummy size processing', 1);
  northernDummies = new ArrayList;
  southernDummies = new ArrayList;
  edgeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_EDGE_EDGE_BETWEEN_LAYERS_0))));
  delta = edgeSpacing * 2;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    northernDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    southernDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        side = castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
        side == ($clinit_PortSide() , NORTH_1)?(northernDummies.array[northernDummies.array.length] = node , true):side == SOUTH_1 && (southernDummies.array[southernDummies.array.length] = node , true);
      }
    }
    $setWidths(northernDummies, true, delta);
    $setWidths(southernDummies, false, delta);
  }
  $done_0(monitor);
}

function $setWidths(nodes, topDown, delta){
  var currentWidth, node, node$iterator, port, port$iterator, step;
  currentWidth = 0;
  step = delta;
  if (!topDown) {
    currentWidth = delta * (nodes.array.length - 1);
    step *= -1;
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $setProperty_0(node, ($clinit_LayeredOptions() , ALIGNMENT), ($clinit_Alignment() , CENTER_3));
    node.size_0.x_0 = currentWidth;
    for (port$iterator = $getPorts_1(node, ($clinit_PortSide() , EAST_1)).iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 11);
      port.pos.x_0 = currentWidth;
    }
    currentWidth += step;
  }
}

function HierarchicalPortDummySizeProcessor(){
}

defineClass(1396, 1, $intern_108, HierarchicalPortDummySizeProcessor);
_.process = function process_14(layeredGraph, monitor){
  $process_18(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HierarchicalPortDummySizeProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HierarchicalPortDummySizeProcessor', 1396);
function $assignAscendingCoordinates(dummies, graph){
  var currentMargin, currentPosition, currentSize, delta, graphSize, index_0, nextValidCoordinate, spacing;
  spacing = checkNotNull_1(castToDouble($getProperty(graph, ($clinit_LayeredOptions() , SPACING_PORT_PORT))));
  nextValidCoordinate = dummies[0].pos.x_0 + dummies[0].size_0.x_0 + dummies[0].margin.right + spacing;
  for (index_0 = 1; index_0 < dummies.length; index_0++) {
    currentPosition = dummies[index_0].pos;
    currentSize = dummies[index_0].size_0;
    currentMargin = dummies[index_0].margin;
    delta = currentPosition.x_0 - currentMargin.left - nextValidCoordinate;
    delta < 0 && (currentPosition.x_0 -= delta);
    graphSize = graph.size_0;
    graphSize.x_0 = $wnd.Math.max(graphSize.x_0, currentPosition.x_0 + currentSize.x_0);
    nextValidCoordinate = currentPosition.x_0 + currentSize.x_0 + currentMargin.right + spacing;
  }
}

function $calculateNorthSouthDummyPositions(dummy){
  var anchor, connectedPort, connectedPort$iterator, dummyInPort, offset, posSum;
  dummyInPort = castTo($get_7(dummy.ports, 0), 11);
  if (dummyInPort.incomingEdges.array.length + dummyInPort.outgoingEdges.array.length == 0) {
    dummy.pos.x_0 = 0;
  }
   else {
    posSum = 0;
    for (connectedPort$iterator = $iterator(concat_1(new LPort$7(dummyInPort), new LPort$8(dummyInPort))); $hasNext_0(connectedPort$iterator);) {
      connectedPort = castTo($next_2(connectedPort$iterator), 11);
      posSum += connectedPort.owner.pos.x_0 + connectedPort.pos.x_0 + connectedPort.anchor.x_0;
    }
    anchor = castTo($getProperty(dummy, ($clinit_LayeredOptions() , PORT_ANCHOR)), 8);
    offset = !anchor?0:anchor.x_0;
    dummy.pos.x_0 = posSum / (dummyInPort.incomingEdges.array.length + dummyInPort.outgoingEdges.array.length) - offset;
  }
}

function $correctSlantedEdgeSegments(layer){
  var bendPoints, edge, edge$iterator, extPortSide, firstBendPoint, lastBendPoint, node, node$iterator, sourcePort, targetPort;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    extPortSide = castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
    if (extPortSide == ($clinit_PortSide() , EAST_1) || extPortSide == WEST_1) {
      for (edge$iterator = $iterator($getConnectedEdges_0(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        bendPoints = edge.bendPoints;
        if (bendPoints.size_0 == 0) {
          continue;
        }
        sourcePort = edge.source;
        if (sourcePort.owner == node) {
          firstBendPoint = (checkCriticalElement(bendPoints.size_0 != 0) , castTo(bendPoints.header.next_0.value_0, 8));
          firstBendPoint.y_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor])).y_0;
        }
        targetPort = edge.target;
        if (targetPort.owner == node) {
          lastBendPoint = (checkCriticalElement(bendPoints.size_0 != 0) , castTo(bendPoints.tail.prev.value_0, 8));
          lastBendPoint.y_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).y_0;
        }
      }
    }
  }
}

function $ensureUniquePositions(dummies, graph){
  var dummyArray;
  if (dummies.array.length == 0) {
    return;
  }
  dummyArray = castTo($toArray_2(dummies, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, dummies.array.length, 0, 1)), 125);
  sort_5(dummyArray, new HierarchicalPortOrthogonalEdgeRouter$1);
  $assignAscendingCoordinates(dummyArray, graph);
}

function $fixCoordinates(layer, constraints, graph){
  var extPortSide, extPortSize, graphActualSize, newActualGraphHeight, node, node$iterator, node$iterator0, nodePosition, offset, padding, ratio, requiredActualGraphHeight;
  padding = graph.padding;
  offset = graph.offset;
  graphActualSize = new KVector_1(graph.size_0.x_0 + graph.padding.left + graph.padding.right, graph.size_0.y_0 + graph.padding.top_0 + graph.padding.bottom);
  newActualGraphHeight = graphActualSize.y_0;
  for (node$iterator0 = new ArrayList$1(layer.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    extPortSide = castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
    extPortSize = castTo($getProperty(node, EXT_PORT_SIZE), 8);
    nodePosition = node.pos;
    switch (extPortSide.ordinal) {
      case 2:
        nodePosition.x_0 = graph.size_0.x_0 + padding.right - offset.x_0;
        break;
      case 4:
        nodePosition.x_0 = -offset.x_0 - padding.left;
    }
    requiredActualGraphHeight = 0;
    switch (extPortSide.ordinal) {
      case 2:
      case 4:
        if (constraints == ($clinit_PortConstraints() , FIXED_RATIO)) {
          ratio = checkNotNull_1(castToDouble($getProperty(node, PORT_RATIO_OR_POSITION_0)));
          nodePosition.y_0 = graphActualSize.y_0 * ratio - castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_ANCHOR)), 8).y_0;
          requiredActualGraphHeight = nodePosition.y_0 + extPortSize.y_0;
          $borderToContentAreaCoordinates(node, false, true);
        }
         else if (constraints == FIXED_POS) {
          nodePosition.y_0 = checkNotNull_1(castToDouble($getProperty(node, PORT_RATIO_OR_POSITION_0))) - castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_ANCHOR)), 8).y_0;
          requiredActualGraphHeight = nodePosition.y_0 + extPortSize.y_0;
          $borderToContentAreaCoordinates(node, false, true);
        }

    }
    newActualGraphHeight = $wnd.Math.max(newActualGraphHeight, requiredActualGraphHeight);
  }
  graph.size_0.y_0 += newActualGraphHeight - graphActualSize.y_0;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    extPortSide = castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
    nodePosition = node.pos;
    switch (extPortSide.ordinal) {
      case 1:
        nodePosition.y_0 = -offset.y_0 - padding.top_0;
        break;
      case 3:
        nodePosition.y_0 = graph.size_0.y_0 + padding.bottom - offset.y_0;
    }
  }
}

function $process_19(this$static, layeredGraph, monitor){
  var northSouthDummies, constraints, layers, layers_0;
  $begin(monitor, 'Orthogonally routing hierarchical port edges', 1);
  this$static.northernExtPortEdgeRoutingHeight = 0;
  northSouthDummies = $restoreNorthSouthDummies(layeredGraph);
  $setNorthSouthDummyCoordinates(layeredGraph, northSouthDummies);
  $routeEdges(this$static, layeredGraph, northSouthDummies);
  $removeTemporaryNorthSouthDummies(layeredGraph);
  constraints = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
  layers = layeredGraph.layers;
  $fixCoordinates((checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 25)), constraints, layeredGraph);
  $fixCoordinates(castTo($get_7(layers, layers.array.length - 1), 25), constraints, layeredGraph);
  layers_0 = layeredGraph.layers;
  $correctSlantedEdgeSegments((checkCriticalElementIndex(0, layers_0.array.length) , castTo(layers_0.array[0], 25)));
  $correctSlantedEdgeSegments(castTo($get_7(layers_0, layers_0.array.length - 1), 25));
  $done_0(monitor);
}

function $removeTemporaryNorthSouthDummies(layeredGraph){
  var edge, edge$index, edge$index0, edge$max, edge$max0, edges, firstBendPoint, incomingEdgeBendPoints, iter, lastBendPoint, layer, layer$iterator, node, node$iterator, node$iterator0, nodeInPort, nodeOriginPort, nodeOutPort, nodeToOriginEdge, nodesToRemove, outgoingEdgeBendPoints, port, port$iterator, replacedDummy, replacedDummyPort;
  nodesToRemove = new ArrayList;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator0 = new ArrayList$1(layer.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        continue;
      }
      if (!$hasProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_REPLACED_DUMMY))) {
        continue;
      }
      nodeInPort = null;
      nodeOutPort = null;
      nodeOriginPort = null;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_10(port$iterator), 11);
        switch (port.side.ordinal) {
          case 4:
            nodeInPort = port;
            break;
          case 2:
            nodeOutPort = port;
            break;
          default:nodeOriginPort = port;
        }
      }
      nodeToOriginEdge = castTo($get_7(nodeOriginPort.outgoingEdges, 0), 16);
      incomingEdgeBendPoints = new KVectorChain_0(nodeToOriginEdge.bendPoints);
      firstBendPoint = new KVector_2(nodeOriginPort.pos);
      $add_19(firstBendPoint, node.pos);
      iter = $listIterator_1(incomingEdgeBendPoints, 0);
      $add_8(iter, firstBendPoint);
      outgoingEdgeBendPoints = reverse_3(nodeToOriginEdge.bendPoints);
      lastBendPoint = new KVector_2(nodeOriginPort.pos);
      $add_19(lastBendPoint, node.pos);
      $addNode_0(outgoingEdgeBendPoints, lastBendPoint, outgoingEdgeBendPoints.tail.prev, outgoingEdgeBendPoints.tail);
      replacedDummy = castTo($getProperty(node, EXT_PORT_REPLACED_DUMMY), 9);
      replacedDummyPort = castTo($get_7(replacedDummy.ports, 0), 11);
      edges = castTo($toArray_2(nodeInPort.incomingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, 0, 0, 1)), 101);
      for (edge$index0 = 0 , edge$max0 = edges.length; edge$index0 < edge$max0; ++edge$index0) {
        edge = edges[edge$index0];
        $setTarget_0(edge, replacedDummyPort);
        $addAllAsCopies(edge.bendPoints, edge.bendPoints.size_0, incomingEdgeBendPoints);
      }
      edges = castTo($toArray_2(nodeOutPort.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, nodeOutPort.outgoingEdges.array.length, 0, 1)), 101);
      for (edge$index = 0 , edge$max = edges.length; edge$index < edge$max; ++edge$index) {
        edge = edges[edge$index];
        $setSource_0(edge, replacedDummyPort);
        $addAllAsCopies(edge.bendPoints, 0, outgoingEdgeBendPoints);
      }
      $setSource_0(nodeToOriginEdge, null);
      $setTarget_0(nodeToOriginEdge, null);
      nodesToRemove.array[nodesToRemove.array.length] = node;
    }
  }
  for (node$iterator = new ArrayList$1(nodesToRemove); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $setLayer_0(node, null);
  }
}

function $restoreDummy(dummy, graph){
  var currentY, dummyPort, label_0, label$iterator, labelLabelSpacing, portLabelPlacement, portLabelSpacing, portSide, xCenterRelativeToPort;
  portSide = castTo($getProperty(dummy, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
  dummyPort = castTo($get_7(dummy.ports, 0), 11);
  portSide == ($clinit_PortSide() , NORTH_1)?$setSide(dummyPort, SOUTH_1):portSide == SOUTH_1 && $setSide(dummyPort, NORTH_1);
  if (castTo($getProperty(graph, ($clinit_LayeredOptions() , NODE_SIZE_CONSTRAINTS)), 190).contains(($clinit_SizeConstraint() , PORT_LABELS))) {
    portLabelSpacing = checkNotNull_1(castToDouble($getProperty(dummy, SPACING_LABEL_PORT)));
    labelLabelSpacing = checkNotNull_1(castToDouble($getProperty(dummy, SPACING_LABEL_LABEL)));
    portLabelPlacement = castTo($getProperty(graph, PORT_LABELS_PLACEMENT), 284);
    if (portLabelPlacement == ($clinit_PortLabelPlacement() , INSIDE_0)) {
      currentY = portLabelSpacing;
      xCenterRelativeToPort = dummy.size_0.x_0 / 2 - dummyPort.pos.x_0;
      for (label$iterator = new ArrayList$1(dummyPort.labels); label$iterator.i < label$iterator.this$01.array.length;) {
        label_0 = castTo($next_10(label$iterator), 70);
        label_0.pos.y_0 = currentY;
        label_0.pos.x_0 = xCenterRelativeToPort - label_0.size_0.x_0 / 2;
        currentY += label_0.size_0.y_0 + labelLabelSpacing;
      }
    }
     else if (portLabelPlacement == OUTSIDE_0) {
      for (label$iterator = new ArrayList$1(dummyPort.labels); label$iterator.i < label$iterator.this$01.array.length;) {
        label_0 = castTo($next_10(label$iterator), 70);
        label_0.pos.x_0 = portLabelSpacing + dummy.size_0.x_0 - dummyPort.pos.x_0;
      }
    }
    $processNode(new NodeMarginCalculator(new LGraphAdapters$LGraphAdapter(graph, false, new LGraphAdapters$lambda$0$Type)), new LGraphAdapters$LNodeAdapter(null, dummy, false));
  }
}

function $restoreNorthSouthDummies(layeredGraph){
  var dummy, dummy$iterator, dummy$iterator0, layer, layer$iterator, node, node$iterator, replacedDummy, restoredDummies, outPort, extPortSide, inPort, edge;
  restoredDummies = new ArrayList;
  if (!$hasProperty(layeredGraph, ($clinit_InternalProperties_1() , EXT_PORT_REPLACED_DUMMIES))) {
    return restoredDummies;
  }
  for (dummy$iterator0 = castTo($getProperty(layeredGraph, EXT_PORT_REPLACED_DUMMIES), 15).iterator_0(); dummy$iterator0.hasNext_0();) {
    dummy = castTo(dummy$iterator0.next_1(), 9);
    $restoreDummy(dummy, layeredGraph);
    restoredDummies.array[restoredDummies.array.length] = dummy;
  }
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        continue;
      }
      replacedDummy = castTo($getProperty(node, EXT_PORT_REPLACED_DUMMY), 9);
      !!replacedDummy && (outPort = new LPort , $setNode(outPort, node) , extPortSide = castTo($getProperty(node, EXT_PORT_SIDE), 71) , $setSide(outPort, extPortSide) , inPort = castTo($get_7(replacedDummy.ports, 0), 11) , edge = new LEdge , $setSource_0(edge, outPort) , $setTarget_0(edge, inPort) , undefined);
    }
  }
  for (dummy$iterator = new ArrayList$1(restoredDummies); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
    dummy = castTo($next_10(dummy$iterator), 9);
    $setLayer_0(dummy, castTo($get_7(layeredGraph.layers, layeredGraph.layers.array.length - 1), 25));
  }
  return restoredDummies;
}

function $restoreProperOrder(dummies, graph){
  var dummyArray;
  if (dummies.array.length == 0) {
    return;
  }
  dummyArray = castTo($toArray_2(dummies, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, dummies.array.length, 0, 1)), 125);
  sort_5(dummyArray, new HierarchicalPortOrthogonalEdgeRouter$2);
  $assignAscendingCoordinates(dummyArray, graph);
}

function $routeEdges(this$static, layeredGraph, northSouthDummies){
  var edge, edge$iterator, edgeSpacing, hierarchicalPortDummy, hierarchicalPortDummy$iterator, nodeSpacing, northernSourceLayer, northernTargetLayer, portSide, routingGenerator, slots, southernSourceLayer, southernTargetLayer;
  northernSourceLayer = new LinkedHashSet;
  northernTargetLayer = new LinkedHashSet;
  southernSourceLayer = new LinkedHashSet;
  southernTargetLayer = new LinkedHashSet;
  nodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
  edgeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_EDGE_EDGE)));
  checkNotNull_1(castToBoolean($getProperty(layeredGraph, DEBUG_MODE)));
  for (hierarchicalPortDummy$iterator = new ArrayList$1(northSouthDummies); hierarchicalPortDummy$iterator.i < hierarchicalPortDummy$iterator.this$01.array.length;) {
    hierarchicalPortDummy = castTo($next_10(hierarchicalPortDummy$iterator), 9);
    portSide = castTo($getProperty(hierarchicalPortDummy, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
    if (portSide == ($clinit_PortSide() , NORTH_1)) {
      northernTargetLayer.map_0.put(hierarchicalPortDummy, northernTargetLayer);
      for (edge$iterator = $iterator($getIncomingEdges(hierarchicalPortDummy)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        $add_6(northernSourceLayer, edge.source.owner);
      }
    }
     else if (portSide == SOUTH_1) {
      southernTargetLayer.map_0.put(hierarchicalPortDummy, southernTargetLayer);
      for (edge$iterator = $iterator($getIncomingEdges(hierarchicalPortDummy)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        $add_6(southernSourceLayer, edge.source.owner);
      }
    }
  }
  if (northernSourceLayer.map_0.size_1() != 0) {
    routingGenerator = new OrthogonalRoutingGenerator(2, edgeSpacing);
    slots = $routeEdges_0(routingGenerator, layeredGraph, northernSourceLayer, northernTargetLayer, -nodeSpacing - layeredGraph.offset.y_0);
    if (slots > 0) {
      this$static.northernExtPortEdgeRoutingHeight = nodeSpacing + (slots - 1) * edgeSpacing;
      layeredGraph.offset.y_0 += this$static.northernExtPortEdgeRoutingHeight;
      layeredGraph.size_0.y_0 += this$static.northernExtPortEdgeRoutingHeight;
    }
  }
  if (southernSourceLayer.map_0.size_1() != 0) {
    routingGenerator = new OrthogonalRoutingGenerator(1, edgeSpacing);
    slots = $routeEdges_0(routingGenerator, layeredGraph, southernSourceLayer, southernTargetLayer, layeredGraph.size_0.y_0 + nodeSpacing - layeredGraph.offset.y_0);
    slots > 0 && (layeredGraph.size_0.y_0 += nodeSpacing + (slots - 1) * edgeSpacing);
  }
}

function $setNorthSouthDummyCoordinates(layeredGraph, northSouthDummies){
  var constraints, dummy, dummy$iterator, graphPadding, graphSize, graphWidth, northY, northernDummies, southY, southernDummies, anchor, offset, anchor_0, offset_0;
  constraints = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
  graphSize = layeredGraph.size_0;
  graphPadding = layeredGraph.padding;
  graphWidth = graphSize.x_0 + graphPadding.left + graphPadding.right;
  northY = 0 - graphPadding.top_0 - layeredGraph.offset.y_0;
  southY = graphSize.y_0 + graphPadding.top_0 + graphPadding.bottom - layeredGraph.offset.y_0;
  northernDummies = new ArrayList;
  southernDummies = new ArrayList;
  for (dummy$iterator = new ArrayList$1(northSouthDummies); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
    dummy = castTo($next_10(dummy$iterator), 9);
    switch (constraints.ordinal) {
      case 1:
      case 2:
      case 3:
        $calculateNorthSouthDummyPositions(dummy);
        break;
      case 4:
        anchor = castTo($getProperty(dummy, PORT_ANCHOR), 8);
        offset = !anchor?0:anchor.x_0;
        dummy.pos.x_0 = graphWidth * checkNotNull_1(castToDouble($getProperty(dummy, ($clinit_InternalProperties_1() , PORT_RATIO_OR_POSITION_0)))) - offset;
        $borderToContentAreaCoordinates(dummy, true, false);
        break;
      case 5:
        anchor_0 = castTo($getProperty(dummy, PORT_ANCHOR), 8);
        offset_0 = !anchor_0?0:anchor_0.x_0;
        dummy.pos.x_0 = checkNotNull_1(castToDouble($getProperty(dummy, ($clinit_InternalProperties_1() , PORT_RATIO_OR_POSITION_0)))) - offset_0;
        $borderToContentAreaCoordinates(dummy, true, false);
        graphSize.x_0 = $wnd.Math.max(graphSize.x_0, dummy.pos.x_0 + dummy.size_0.x_0 / 2);
    }
    switch (castTo($getProperty(dummy, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71).ordinal) {
      case 1:
        dummy.pos.y_0 = northY;
        northernDummies.array[northernDummies.array.length] = dummy;
        break;
      case 3:
        dummy.pos.y_0 = southY;
        southernDummies.array[southernDummies.array.length] = dummy;
    }
  }
  switch (constraints.ordinal) {
    case 1:
    case 2:
      $ensureUniquePositions(northernDummies, layeredGraph);
      $ensureUniquePositions(southernDummies, layeredGraph);
      break;
    case 3:
      $restoreProperOrder(northernDummies, layeredGraph);
      $restoreProperOrder(southernDummies, layeredGraph);
  }
}

function HierarchicalPortOrthogonalEdgeRouter(){
}

defineClass(1397, 1, $intern_108, HierarchicalPortOrthogonalEdgeRouter);
_.process = function process_15(layeredGraph, monitor){
  $process_19(this, castTo(layeredGraph, 32), monitor);
}
;
_.northernExtPortEdgeRoutingHeight = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_HierarchicalPortOrthogonalEdgeRouter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HierarchicalPortOrthogonalEdgeRouter', 1397);
function $compare_12(a, b){
  return compare_5(a.pos.x_0, b.pos.x_0);
}

function HierarchicalPortOrthogonalEdgeRouter$1(){
}

defineClass(1398, 1, $intern_40, HierarchicalPortOrthogonalEdgeRouter$1);
_.compare_0 = function compare_42(a, b){
  return $compare_12(castTo(a, 9), castTo(b, 9));
}
;
_.equals_0 = function equals_110(other){
  return this === other;
}
;
_.reversed = function reversed_34(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HierarchicalPortOrthogonalEdgeRouter$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HierarchicalPortOrthogonalEdgeRouter/1', 1398);
function $compare_13(a, b){
  return compare_5(checkNotNull_1(castToDouble($getProperty(a, ($clinit_InternalProperties_1() , PORT_RATIO_OR_POSITION_0)))), checkNotNull_1(castToDouble($getProperty(b, PORT_RATIO_OR_POSITION_0))));
}

function HierarchicalPortOrthogonalEdgeRouter$2(){
}

defineClass(1399, 1, $intern_40, HierarchicalPortOrthogonalEdgeRouter$2);
_.compare_0 = function compare_43(a, b){
  return $compare_13(castTo(a, 9), castTo(b, 9));
}
;
_.equals_0 = function equals_111(other){
  return this === other;
}
;
_.reversed = function reversed_35(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HierarchicalPortOrthogonalEdgeRouter$2_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HierarchicalPortOrthogonalEdgeRouter/2', 1399);
function $fixCoordinates_0(layer, layeredGraph){
  var extPortSide, finalYCoordinate, graphHeight, node, node$iterator, portConstraints;
  portConstraints = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
  if (!(portConstraints == ($clinit_PortConstraints() , FIXED_RATIO) || portConstraints == FIXED_POS)) {
    return;
  }
  graphHeight = (new KVector_1(layeredGraph.size_0.x_0 + layeredGraph.padding.left + layeredGraph.padding.right, layeredGraph.size_0.y_0 + layeredGraph.padding.top_0 + layeredGraph.padding.bottom)).y_0;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
      continue;
    }
    extPortSide = castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
    if (extPortSide != ($clinit_PortSide() , EAST_1) && extPortSide != WEST_1) {
      continue;
    }
    finalYCoordinate = checkNotNull_1(castToDouble($getProperty(node, PORT_RATIO_OR_POSITION_0)));
    portConstraints == FIXED_RATIO && (finalYCoordinate *= graphHeight);
    node.pos.y_0 = finalYCoordinate - castTo($getProperty(node, PORT_ANCHOR), 8).y_0;
    $borderToContentAreaCoordinates(node, false, true);
  }
}

function $process_20(layeredGraph, monitor){
  var layers;
  $begin(monitor, 'Hierarchical port position processing', 1);
  layers = layeredGraph.layers;
  layers.array.length > 0 && $fixCoordinates_0((checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 25)), layeredGraph);
  layers.array.length > 1 && $fixCoordinates_0(castTo($get_7(layers, layers.array.length - 1), 25), layeredGraph);
  $done_0(monitor);
}

function HierarchicalPortPositionProcessor(){
}

defineClass(1400, 1, $intern_108, HierarchicalPortPositionProcessor);
_.process = function process_16(layeredGraph, monitor){
  $process_20(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HierarchicalPortPositionProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HierarchicalPortPositionProcessor', 1400);
function $clinit_HighDegreeNodeLayeringProcessor(){
  $clinit_HighDegreeNodeLayeringProcessor = emptyMethod;
  INCOMING_EDGES = new HighDegreeNodeLayeringProcessor$lambda$0$Type;
  OUTGOING_EDGES = new HighDegreeNodeLayeringProcessor$lambda$1$Type;
}

function $calculateInformation(this$static, hdn){
  var hdni, incEdge, incEdge$iterator, outEdge, outEdge$iterator, src_0, tgt, treeHeight;
  hdni = new HighDegreeNodeLayeringProcessor$HighDegreeNodeInformation;
  for (incEdge$iterator = $iterator($getIncomingEdges(hdn)); $hasNext_0(incEdge$iterator);) {
    incEdge = castTo($next_2(incEdge$iterator), 16);
    if ($isSelfLoop(incEdge)) {
      continue;
    }
    src_0 = incEdge.source.owner;
    if ($hasSingleConnection(src_0, OUTGOING_EDGES)) {
      treeHeight = $isTreeRoot(this$static, src_0, OUTGOING_EDGES, INCOMING_EDGES);
      if (treeHeight == -1) {
        continue;
      }
      hdni.incTreesMaxHeight = max_1(hdni.incTreesMaxHeight, treeHeight);
      !hdni.incTreeRoots && (hdni.incTreeRoots = new ArrayList);
      $add_4(hdni.incTreeRoots, src_0);
    }
  }
  for (outEdge$iterator = $iterator($getOutgoingEdges(hdn)); $hasNext_0(outEdge$iterator);) {
    outEdge = castTo($next_2(outEdge$iterator), 16);
    if ($isSelfLoop(outEdge)) {
      continue;
    }
    tgt = outEdge.target.owner;
    if ($hasSingleConnection(tgt, INCOMING_EDGES)) {
      treeHeight = $isTreeRoot(this$static, tgt, INCOMING_EDGES, OUTGOING_EDGES);
      if (treeHeight == -1) {
        continue;
      }
      hdni.outTreesMaxHeight = max_1(hdni.outTreesMaxHeight, treeHeight);
      !hdni.outTreeRoots && (hdni.outTreeRoots = new ArrayList);
      $add_4(hdni.outTreeRoots, tgt);
    }
  }
  return hdni;
}

function $hasSingleConnection(node, edgeSelector){
  var connection, e, e$iterator;
  connection = null;
  for (e$iterator = castTo(edgeSelector.apply_0(node), 20).iterator_0(); e$iterator.hasNext_0();) {
    e = castTo(e$iterator.next_1(), 16);
    if (!connection) {
      connection = e.source.owner == node?e.target.owner:e.source.owner;
    }
     else {
      if ((e.source.owner == node?e.target.owner:e.source.owner) != connection) {
        return false;
      }
    }
  }
  return true;
}

function $isTreeRoot(this$static, root, ancestorEdges, descendantEdges){
  var currentHeight, e, e$iterator, height, other;
  if (size_15(($clinit_HighDegreeNodeLayeringProcessor() , $getConnectedEdges_0(root))) >= this$static.degreeThreshold) {
    return -1;
  }
  if (!$hasSingleConnection(root, ancestorEdges)) {
    return -1;
  }
  if (isEmpty_10(castTo(descendantEdges.apply_0(root), 20))) {
    return 1;
  }
  currentHeight = 0;
  for (e$iterator = castTo(descendantEdges.apply_0(root), 20).iterator_0(); e$iterator.hasNext_0();) {
    e = castTo(e$iterator.next_1(), 16);
    other = e.source.owner == root?e.target.owner:e.source.owner;
    height = $isTreeRoot(this$static, other, ancestorEdges, descendantEdges);
    if (height == -1) {
      return -1;
    }
    currentHeight = currentHeight > height?currentHeight:height;
    if (currentHeight > this$static.treeHeightThreshold - 1) {
      return -1;
    }
  }
  return currentHeight + 1;
}

function $moveTree(this$static, root, edgesFun, layers){
  var e, e$iterator, other, subList;
  $setLayer_0(root, castTo(layers.get_3(0), 25));
  subList = layers.subList(1, layers.size_1());
  for (e$iterator = castTo(edgesFun.apply_0(root), 20).iterator_0(); e$iterator.hasNext_0();) {
    e = castTo(e$iterator.next_1(), 16);
    other = e.source.owner == root?e.target.owner:e.source.owner;
    $moveTree(this$static, other, edgesFun, subList);
  }
}

function $process_21(this$static, graph){
  var afterLayers, hdni, highDegreeNode, highDegreeNode$iterator, highDegreeNode$iterator0, highDegreeNodes, i, i0, incMax, incRoot, incRoot$iterator, incRoots, l, lay, layerIt, layerIt2, n, n$iterator, outMax, outRoot, outRoot$iterator, outRoots, preLayers, l_0, l_1;
  this$static.layeredGraph = graph;
  this$static.degreeThreshold = castTo($getProperty(graph, ($clinit_LayeredOptions() , HIGH_DEGREE_NODES_THRESHOLD_0)), 21).value_0;
  this$static.treeHeightThreshold = castTo($getProperty(graph, HIGH_DEGREE_NODES_TREE_HEIGHT_0), 21).value_0;
  this$static.treeHeightThreshold == 0 && (this$static.treeHeightThreshold = $intern_0);
  layerIt = new AbstractList$ListIteratorImpl(graph.layers, 0);
  while (layerIt.i < layerIt.this$01_0.size_1()) {
    lay = (checkCriticalElement(layerIt.i < layerIt.this$01_0.size_1()) , castTo(layerIt.this$01_0.get_3(layerIt.last = layerIt.i++), 25));
    highDegreeNodes = new ArrayList;
    incMax = -1;
    outMax = -1;
    for (n$iterator = new ArrayList$1(lay.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      if (size_15(($clinit_HighDegreeNodeLayeringProcessor() , $getConnectedEdges_0(n))) >= this$static.degreeThreshold) {
        hdni = $calculateInformation(this$static, n);
        incMax = max_1(incMax, hdni.incTreesMaxHeight);
        outMax = max_1(outMax, hdni.outTreesMaxHeight);
        $add_4(highDegreeNodes, new Pair(n, hdni));
      }
    }
    preLayers = new ArrayList;
    for (i0 = 0; i0 < incMax; ++i0) {
      $add_3(preLayers, 0, (checkCriticalElement(layerIt.i > 0) , layerIt.this$01.get_3(layerIt.last = --layerIt.i) , l_0 = new Layer(this$static.layeredGraph) , $add_2(layerIt, l_0) , checkCriticalElement(layerIt.i < layerIt.this$01_0.size_1()) , layerIt.this$01_0.get_3(layerIt.last = layerIt.i++) , l_0));
    }
    for (highDegreeNode$iterator0 = new ArrayList$1(highDegreeNodes); highDegreeNode$iterator0.i < highDegreeNode$iterator0.this$01.array.length;) {
      highDegreeNode = castTo($next_10(highDegreeNode$iterator0), 37);
      incRoots = castTo(highDegreeNode.second, 539).incTreeRoots;
      if (!incRoots) {
        continue;
      }
      for (incRoot$iterator = new ArrayList$1(incRoots); incRoot$iterator.i < incRoot$iterator.this$01.array.length;) {
        incRoot = castTo($next_10(incRoot$iterator), 9);
        $moveTree(this$static, incRoot, INCOMING_EDGES, preLayers);
      }
    }
    afterLayers = new ArrayList;
    for (i = 0; i < outMax; ++i) {
      $add_4(afterLayers, (l_1 = new Layer(this$static.layeredGraph) , $add_2(layerIt, l_1) , l_1));
    }
    for (highDegreeNode$iterator = new ArrayList$1(highDegreeNodes); highDegreeNode$iterator.i < highDegreeNode$iterator.this$01.array.length;) {
      highDegreeNode = castTo($next_10(highDegreeNode$iterator), 37);
      outRoots = castTo(highDegreeNode.second, 539).outTreeRoots;
      if (!outRoots) {
        continue;
      }
      for (outRoot$iterator = new ArrayList$1(outRoots); outRoot$iterator.i < outRoot$iterator.this$01.array.length;) {
        outRoot = castTo($next_10(outRoot$iterator), 9);
        $moveTree(this$static, outRoot, OUTGOING_EDGES, afterLayers);
      }
    }
  }
  layerIt2 = new AbstractList$ListIteratorImpl(graph.layers, 0);
  while (layerIt2.i < layerIt2.this$01_0.size_1()) {
    l = (checkCriticalElement(layerIt2.i < layerIt2.this$01_0.size_1()) , castTo(layerIt2.this$01_0.get_3(layerIt2.last = layerIt2.i++), 25));
    l.nodes.array.length == 0 && $remove_9(layerIt2);
  }
}

function HighDegreeNodeLayeringProcessor(){
  $clinit_HighDegreeNodeLayeringProcessor();
}

defineClass(1401, 1, $intern_108, HighDegreeNodeLayeringProcessor);
_.process = function process_17(graph, progressMonitor){
  $process_21(this, castTo(graph, 32));
}
;
_.degreeThreshold = 0;
_.treeHeightThreshold = 0;
var INCOMING_EDGES, OUTGOING_EDGES;
var Lorg_eclipse_elk_alg_layered_intermediate_HighDegreeNodeLayeringProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HighDegreeNodeLayeringProcessor', 1401);
function HighDegreeNodeLayeringProcessor$HighDegreeNodeInformation(){
}

defineClass(539, 1, {539:1}, HighDegreeNodeLayeringProcessor$HighDegreeNodeInformation);
_.incTreesMaxHeight = -1;
_.outTreesMaxHeight = -1;
var Lorg_eclipse_elk_alg_layered_intermediate_HighDegreeNodeLayeringProcessor$HighDegreeNodeInformation_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HighDegreeNodeLayeringProcessor/HighDegreeNodeInformation', 539);
function HighDegreeNodeLayeringProcessor$lambda$0$Type(){
}

defineClass(1402, 1, $intern_25, HighDegreeNodeLayeringProcessor$lambda$0$Type);
_.equals_0 = function equals_112(other){
  return this === other;
}
;
_.apply_0 = function apply_76(arg0){
  return $clinit_HighDegreeNodeLayeringProcessor() , $getIncomingEdges(castTo(arg0, 9));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HighDegreeNodeLayeringProcessor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HighDegreeNodeLayeringProcessor/lambda$0$Type', 1402);
function HighDegreeNodeLayeringProcessor$lambda$1$Type(){
}

defineClass(1403, 1, $intern_25, HighDegreeNodeLayeringProcessor$lambda$1$Type);
_.equals_0 = function equals_113(other){
  return this === other;
}
;
_.apply_0 = function apply_77(arg0){
  return $clinit_HighDegreeNodeLayeringProcessor() , $getOutgoingEdges(castTo(arg0, 9));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HighDegreeNodeLayeringProcessor$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HighDegreeNodeLayeringProcessor/lambda$1$Type', 1403);
function $checkMergeAllowed(currNode, lastNode){
  var currHasLabelDummies, currNodeSource, currNodeTarget, eligibleForSourceMerging, eligibleForTargetMerging, lastHasLabelDummies, lastNodeSource, lastNodeTarget, sameSource, sameTarget;
  currHasLabelDummies = checkNotNull_1(castToBoolean($getProperty(currNode, ($clinit_InternalProperties_1() , LONG_EDGE_HAS_LABEL_DUMMIES))));
  lastHasLabelDummies = checkNotNull_1(castToBoolean($getProperty(lastNode, LONG_EDGE_HAS_LABEL_DUMMIES)));
  currNodeSource = castTo($getProperty(currNode, LONG_EDGE_SOURCE), 11);
  lastNodeSource = castTo($getProperty(lastNode, LONG_EDGE_SOURCE), 11);
  currNodeTarget = castTo($getProperty(currNode, LONG_EDGE_TARGET), 11);
  lastNodeTarget = castTo($getProperty(lastNode, LONG_EDGE_TARGET), 11);
  sameSource = !!currNodeSource && currNodeSource == lastNodeSource;
  sameTarget = !!currNodeTarget && currNodeTarget == lastNodeTarget;
  if (!currHasLabelDummies && !lastHasLabelDummies) {
    return new HyperedgeDummyMerger$MergeState(castTo($next_10(new ArrayList$1(currNode.ports)), 11).id_0 == castTo($next_10(new ArrayList$1(lastNode.ports)), 11).id_0, sameSource, sameTarget);
  }
  eligibleForSourceMerging = (!checkNotNull_1(castToBoolean($getProperty(currNode, LONG_EDGE_HAS_LABEL_DUMMIES))) || checkNotNull_1(castToBoolean($getProperty(currNode, LONG_EDGE_BEFORE_LABEL_DUMMY)))) && (!checkNotNull_1(castToBoolean($getProperty(lastNode, LONG_EDGE_HAS_LABEL_DUMMIES))) || checkNotNull_1(castToBoolean($getProperty(lastNode, LONG_EDGE_BEFORE_LABEL_DUMMY))));
  eligibleForTargetMerging = (!checkNotNull_1(castToBoolean($getProperty(currNode, LONG_EDGE_HAS_LABEL_DUMMIES))) || !checkNotNull_1(castToBoolean($getProperty(currNode, LONG_EDGE_BEFORE_LABEL_DUMMY)))) && (!checkNotNull_1(castToBoolean($getProperty(lastNode, LONG_EDGE_HAS_LABEL_DUMMIES))) || !checkNotNull_1(castToBoolean($getProperty(lastNode, LONG_EDGE_BEFORE_LABEL_DUMMY))));
  return new HyperedgeDummyMerger$MergeState(sameSource && eligibleForSourceMerging || sameTarget && eligibleForTargetMerging, sameSource, sameTarget);
}

function $dfs_2(this$static, p, index_0){
  var p2, p2$iterator, p2$iterator0;
  p.id_0 = index_0;
  for (p2$iterator0 = $iterator(concat_1(new LPort$7(p), new LPort$8(p))); $hasNext_0(p2$iterator0);) {
    p2 = castTo($next_2(p2$iterator0), 11);
    p2.id_0 == -1 && $dfs_2(this$static, p2, index_0);
  }
  if (p.owner.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    for (p2$iterator = new ArrayList$1(p.owner.ports); p2$iterator.i < p2$iterator.this$01.array.length;) {
      p2 = castTo($next_10(p2$iterator), 11);
      p2 != p && p2.id_0 == -1 && $dfs_2(this$static, p2, index_0);
    }
  }
}

function $identifyHyperedges(this$static, lGraph){
  var index_0, p, p$iterator, ports;
  ports = castTo($collect_0($flatMap($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(lGraph.layers, 16)), new HyperedgeDummyMerger$lambda$0$Type), new HyperedgeDummyMerger$lambda$1$Type), of_3(new Collectors$21methodref$ctor$Type, new Collectors$20methodref$add$Type, new Collectors$lambda$21$Type, stampJavaTypeInfo(getClassLiteralForArray(Ljava_util_stream_Collector$Characteristics_2_classLit, 1), $intern_38, 154, 0, [($clinit_Collector$Characteristics() , IDENTITY_FINISH)]))), 15);
  ports.forEach_0(new HyperedgeDummyMerger$lambda$2$Type);
  index_0 = 0;
  for (p$iterator = ports.iterator_0(); p$iterator.hasNext_0();) {
    p = castTo(p$iterator.next_1(), 11);
    p.id_0 == -1 && $dfs_2(this$static, p, index_0++);
  }
}

function $mergeNodes(mergeSource, mergeTarget, keepSourcePort, keepTargetPort){
  var mergeTargetInputPort, mergeTargetOutputPort, port, port$iterator;
  mergeTargetInputPort = castTo($getPorts_1(mergeTarget, ($clinit_PortSide() , WEST_1)).iterator_0().next_1(), 11);
  mergeTargetOutputPort = castTo($getPorts_1(mergeTarget, EAST_1).iterator_0().next_1(), 11);
  for (port$iterator = new ArrayList$1(mergeSource.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    while (port.incomingEdges.array.length != 0) {
      $setTarget_0(castTo($get_7(port.incomingEdges, 0), 16), mergeTargetInputPort);
    }
    while (port.outgoingEdges.array.length != 0) {
      $setSource_0(castTo($get_7(port.outgoingEdges, 0), 16), mergeTargetOutputPort);
    }
  }
  keepSourcePort || $setProperty_0(mergeTarget, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), null);
  keepTargetPort || $setProperty_0(mergeTarget, ($clinit_InternalProperties_1() , LONG_EDGE_TARGET), null);
}

function $process_22(this$static, layeredGraph, monitor){
  var currNode, currNodeType, lastNode, lastNodeType, layer, layerIter, nodeIndex, nodes, state;
  $begin(monitor, 'Hyperedge merging', 1);
  $identifyHyperedges(this$static, layeredGraph);
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_3(layerIter.last = layerIter.i++), 25));
    nodes = layer.nodes;
    if (nodes.array.length == 0) {
      continue;
    }
    lastNode = null;
    lastNodeType = null;
    for (nodeIndex = 0; nodeIndex < nodes.array.length; nodeIndex++) {
      currNode = (checkCriticalElementIndex(nodeIndex, nodes.array.length) , castTo(nodes.array[nodeIndex], 9));
      currNodeType = currNode.type_0;
      if (currNodeType == ($clinit_LNode$NodeType() , LONG_EDGE) && lastNodeType == LONG_EDGE) {
        state = $checkMergeAllowed(currNode, lastNode);
        if (state.allowMerge) {
          $mergeNodes(currNode, lastNode, state.sameSource, state.sameTarget);
          checkCriticalElementIndex(nodeIndex, nodes.array.length);
          removeFrom(nodes.array, nodeIndex, 1);
          --nodeIndex;
          currNode = lastNode;
          currNodeType = lastNodeType;
        }
      }
      lastNode = currNode;
      lastNodeType = currNodeType;
    }
  }
  $done_0(monitor);
}

function HyperedgeDummyMerger(){
}

defineClass(1409, 1, $intern_108, HyperedgeDummyMerger);
_.process = function process_18(layeredGraph, monitor){
  $process_22(this, castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HyperedgeDummyMerger_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HyperedgeDummyMerger', 1409);
function HyperedgeDummyMerger$MergeState(allowMerge, sameSource, sameTarget){
  this.allowMerge = allowMerge;
  this.sameSource = sameSource;
  this.sameTarget = sameTarget;
}

defineClass(736, 1, {}, HyperedgeDummyMerger$MergeState);
_.allowMerge = false;
_.sameSource = false;
_.sameTarget = false;
var Lorg_eclipse_elk_alg_layered_intermediate_HyperedgeDummyMerger$MergeState_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HyperedgeDummyMerger/MergeState', 736);
function HyperedgeDummyMerger$lambda$0$Type(){
}

defineClass(1410, 1, $intern_11, HyperedgeDummyMerger$lambda$0$Type);
_.apply_0 = function apply_78(arg0){
  return new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HyperedgeDummyMerger$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HyperedgeDummyMerger/lambda$0$Type', 1410);
function HyperedgeDummyMerger$lambda$1$Type(){
}

defineClass(1411, 1, $intern_11, HyperedgeDummyMerger$lambda$1$Type);
_.apply_0 = function apply_79(arg0){
  return new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 9).ports, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HyperedgeDummyMerger$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HyperedgeDummyMerger/lambda$1$Type', 1411);
function HyperedgeDummyMerger$lambda$2$Type(){
}

defineClass(1412, 1, {}, HyperedgeDummyMerger$lambda$2$Type);
_.accept = function accept_61(arg0){
  castTo(arg0, 11).id_0 = -1;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HyperedgeDummyMerger$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HyperedgeDummyMerger/lambda$2$Type', 1412);
function $moveHypernode(layeredGraph, hypernode, right){
  var bendEdges, bendx, diffx, diffy, edge, edge$iterator, first, firstPoint, junctionPoints, lastPoint, northPort, port, port$iterator, second, southPort;
  bendEdges = new ArrayList;
  bendx = $intern_0;
  diffx = $intern_0;
  diffy = $intern_0;
  if (right) {
    bendx = layeredGraph.size_0.x_0;
    for (port$iterator = new ArrayList$1(hypernode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        if (edge.bendPoints.size_0 != 0) {
          firstPoint = castTo($getFirst(edge.bendPoints), 8);
          if (firstPoint.x_0 < bendx) {
            diffx = bendx - firstPoint.x_0;
            diffy = $intern_0;
            bendEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
            bendx = firstPoint.x_0;
          }
          if (firstPoint.x_0 <= bendx) {
            bendEdges.array[bendEdges.array.length] = edge;
            edge.bendPoints.size_0 > 1 && (diffy = $wnd.Math.min(diffy, $wnd.Math.abs(castTo($get_3(edge.bendPoints, 1), 8).y_0 - firstPoint.y_0)));
          }
        }
      }
    }
  }
   else {
    for (port$iterator = new ArrayList$1(hypernode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        if (edge.bendPoints.size_0 != 0) {
          lastPoint = castTo($getLast(edge.bendPoints), 8);
          if (lastPoint.x_0 > bendx) {
            diffx = lastPoint.x_0 - bendx;
            diffy = $intern_0;
            bendEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
            bendx = lastPoint.x_0;
          }
          if (lastPoint.x_0 >= bendx) {
            bendEdges.array[bendEdges.array.length] = edge;
            edge.bendPoints.size_0 > 1 && (diffy = $wnd.Math.min(diffy, $wnd.Math.abs(castTo($get_3(edge.bendPoints, edge.bendPoints.size_0 - 2), 8).y_0 - lastPoint.y_0)));
          }
        }
      }
    }
  }
  if (bendEdges.array.length != 0 && diffx > hypernode.size_0.x_0 / 2 && diffy > hypernode.size_0.y_0 / 2) {
    northPort = new LPort;
    $setNode(northPort, hypernode);
    $setSide(northPort, ($clinit_PortSide() , NORTH_1));
    northPort.pos.x_0 = hypernode.size_0.x_0 / 2;
    southPort = new LPort;
    $setNode(southPort, hypernode);
    $setSide(southPort, SOUTH_1);
    southPort.pos.x_0 = hypernode.size_0.x_0 / 2;
    southPort.pos.y_0 = hypernode.size_0.y_0;
    for (edge$iterator = new ArrayList$1(bendEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 16);
      if (right) {
        first = castTo($removeFirst_0(edge.bendPoints), 8);
        second = edge.bendPoints.size_0 == 0?$getAbsoluteAnchor(edge.target):castTo($getFirst(edge.bendPoints), 8);
        second.y_0 >= first.y_0?$setSource_0(edge, southPort):$setSource_0(edge, northPort);
      }
       else {
        first = castTo($removeLast(edge.bendPoints), 8);
        second = edge.bendPoints.size_0 == 0?$getAbsoluteAnchor(edge.source):castTo($getLast(edge.bendPoints), 8);
        second.y_0 >= first.y_0?$setTarget_0(edge, southPort):$setTarget_0(edge, northPort);
      }
      junctionPoints = castTo($getProperty(edge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
      !!junctionPoints && $advanceToFind(junctionPoints, first, true);
    }
    hypernode.pos.x_0 = bendx - hypernode.size_0.x_0 / 2;
  }
}

function $process_23(layeredGraph, monitor){
  var bottomEdges, layer, layer$iterator, leftEdges, node, node$iterator, port, port$iterator, rightEdges, topEdges;
  $begin(monitor, 'Hypernodes processing', 1);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayeredOptions() , HYPERNODE)))) && node.ports.array.length <= 2) {
        topEdges = 0;
        rightEdges = 0;
        bottomEdges = 0;
        leftEdges = 0;
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_10(port$iterator), 11);
          switch (port.side.ordinal) {
            case 1:
              ++topEdges;
              break;
            case 2:
              ++rightEdges;
              break;
            case 3:
              ++bottomEdges;
              break;
            case 4:
              ++leftEdges;
          }
        }
        topEdges == 0 && bottomEdges == 0 && $moveHypernode(layeredGraph, node, leftEdges <= rightEdges);
      }
    }
  }
  $done_0(monitor);
}

function HypernodesProcessor(){
}

defineClass(1413, 1, $intern_108, HypernodesProcessor);
_.process = function process_19(layeredGraph, monitor){
  $process_23(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_HypernodesProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'HypernodesProcessor', 1413);
function $process_24(layeredGraph, monitor){
  var bottomConstrainedNodes, constraint, i, layer, layer$iterator, node, node$iterator, nodes, topInsertionIndex;
  $begin(monitor, 'Layer constraint edge reversal', 1);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    topInsertionIndex = -1;
    bottomConstrainedNodes = new ArrayList;
    nodes = castTo($toArray_2(layer.nodes, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, layer.nodes.array.length, 0, 1)), 125);
    for (i = 0; i < nodes.length; i++) {
      constraint = castTo($getProperty(nodes[i], ($clinit_InternalProperties_1() , IN_LAYER_CONSTRAINT)), 290);
      if (topInsertionIndex == -1) {
        constraint != ($clinit_InLayerConstraint() , TOP_0) && (topInsertionIndex = i);
      }
       else {
        if (constraint == ($clinit_InLayerConstraint() , TOP_0)) {
          $setLayer_0(nodes[i], null);
          $setLayer(nodes[i], topInsertionIndex++, layer);
        }
      }
      constraint == ($clinit_InLayerConstraint() , BOTTOM_0) && $add_4(bottomConstrainedNodes, nodes[i]);
    }
    for (node$iterator = new ArrayList$1(bottomConstrainedNodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      $setLayer_0(node, null);
      $setLayer_0(node, layer);
    }
  }
  $done_0(monitor);
}

function InLayerConstraintProcessor(){
}

defineClass(1414, 1, $intern_108, InLayerConstraintProcessor);
_.process = function process_20(layeredGraph, monitor){
  $process_24(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_InLayerConstraintProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InLayerConstraintProcessor', 1414);
function $findNorthSouthPortXCoordinate(dummy){
  var e, e$iterator, margins, max_0, min_0, n, port;
  port = castTo($get_7(dummy.ports, 0), 11);
  if (port.outgoingEdges.array.length != 0 && port.incomingEdges.array.length != 0) {
    throw toJs(new IllegalStateException_0('Interactive layout does not support NORTH/SOUTH ports with incoming _and_ outgoing edges.'));
  }
  if (port.outgoingEdges.array.length != 0) {
    min_0 = $intern_62;
    for (e$iterator = new ArrayList$1(port.outgoingEdges); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_10(e$iterator), 16);
      n = e.target.owner;
      margins = castTo($getProperty(n, ($clinit_LayeredOptions() , MARGINS)), 137);
      min_0 = $wnd.Math.min(min_0, n.pos.x_0 - margins.left);
    }
    return new Present(checkNotNull(min_0));
  }
  if (port.incomingEdges.array.length != 0) {
    max_0 = $intern_63;
    for (e$iterator = new ArrayList$1(port.incomingEdges); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_10(e$iterator), 16);
      n = e.source.owner;
      margins = castTo($getProperty(n, ($clinit_LayeredOptions() , MARGINS)), 137);
      max_0 = $wnd.Math.max(max_0, n.pos.x_0 + n.size_0.x_0 + margins.right);
    }
    return new Present(checkNotNull(max_0));
  }
  return $clinit_Absent() , $clinit_Absent() , INSTANCE;
}

function $findYCoordinate(dummy, funGetOtherNode){
  var e, e$iterator, other;
  for (e$iterator = $iterator($getConnectedEdges_0(dummy)); $hasNext_0(e$iterator);) {
    e = castTo($next_2(e$iterator), 16);
    other = castTo(funGetOtherNode.apply_0(e), 9);
    return new Present(checkNotNull(other.pos.y_0 + other.size_0.y_0 / 2));
  }
  return $clinit_Absent() , $clinit_Absent() , INSTANCE;
}

function $process_25(this$static, layeredGraph){
  var ilc, lc, margins, node, node$iterator, node$iterator0;
  if (!castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
    return;
  }
  for (node$iterator0 = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL)) {
      margins = castTo($getProperty(node, ($clinit_LayeredOptions() , MARGINS)), 137);
      this$static.minX = $wnd.Math.min(this$static.minX, node.pos.x_0 - margins.left);
      this$static.maxX = $wnd.Math.max(this$static.maxX, node.pos.x_0 + node.size_0.x_0 + margins.right);
      this$static.minY = $wnd.Math.min(this$static.minY, node.pos.y_0 - margins.top_0);
      this$static.maxY = $wnd.Math.max(this$static.maxY, node.pos.y_0 + node.size_0.y_0 + margins.bottom);
    }
  }
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , NORMAL)) {
      switch (node.type_0.ordinal) {
        case 2:
          lc = castTo($getProperty(node, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0)), 183);
          if (lc == ($clinit_LayerConstraint() , FIRST_SEPARATE)) {
            node.pos.x_0 = this$static.minX - 10;
            $findYCoordinate(node, new InteractiveExternalPortPositioner$lambda$0$Type).transform(new InteractiveExternalPortPositioner$lambda$1$Type(node));
            break;
          }

          if (lc == LAST_SEPARATE) {
            node.pos.x_0 = this$static.maxX + 10;
            $findYCoordinate(node, new InteractiveExternalPortPositioner$lambda$2$Type).transform(new InteractiveExternalPortPositioner$lambda$3$Type(node));
            break;
          }

          ilc = castTo($getProperty(node, IN_LAYER_CONSTRAINT), 290);
          if (ilc == ($clinit_InLayerConstraint() , TOP_0)) {
            $findNorthSouthPortXCoordinate(node).transform(new InteractiveExternalPortPositioner$lambda$4$Type(node));
            node.pos.y_0 = this$static.minY - 10;
            break;
          }

          if (ilc == BOTTOM_0) {
            $findNorthSouthPortXCoordinate(node).transform(new InteractiveExternalPortPositioner$lambda$5$Type(node));
            node.pos.y_0 = this$static.maxY + 10;
            break;
          }

          break;
        default:throw toJs(new IllegalArgumentException_0('The node type ' + node.type_0 + ' is not supported by the ' + Lorg_eclipse_elk_alg_layered_intermediate_InteractiveExternalPortPositioner_2_classLit));
      }
    }
  }
}

function InteractiveExternalPortPositioner(){
}

function lambda$1_2(node_0, d_1){
  return node_0.pos.y_0 = (checkCriticalNotNull(d_1) , d_1);
}

function lambda$3_1(node_0, d_1){
  return node_0.pos.y_0 = (checkCriticalNotNull(d_1) , d_1);
}

function lambda$4_2(node_0, x_1){
  return node_0.pos.x_0 = (checkCriticalNotNull(x_1) , x_1) + 10;
}

function lambda$5_1(node_0, x_1){
  return node_0.pos.x_0 = (checkCriticalNotNull(x_1) , x_1) + 10;
}

defineClass(1415, 1, $intern_108, InteractiveExternalPortPositioner);
_.process = function process_21(layeredGraph, progressMonitor){
  $process_25(this, castTo(layeredGraph, 32));
}
;
_.maxX = $intern_63;
_.maxY = $intern_63;
_.minX = $intern_62;
_.minY = $intern_62;
var Lorg_eclipse_elk_alg_layered_intermediate_InteractiveExternalPortPositioner_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InteractiveExternalPortPositioner', 1415);
function InteractiveExternalPortPositioner$lambda$0$Type(){
}

defineClass(1416, 1, $intern_25, InteractiveExternalPortPositioner$lambda$0$Type);
_.equals_0 = function equals_114(other){
  return this === other;
}
;
_.apply_0 = function apply_80(arg0){
  return castTo(arg0, 16).target.owner;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_InteractiveExternalPortPositioner$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$0$Type', 1416);
function InteractiveExternalPortPositioner$lambda$1$Type(node_0){
  this.node_0 = node_0;
}

defineClass(1417, 1, $intern_25, InteractiveExternalPortPositioner$lambda$1$Type);
_.equals_0 = function equals_115(other){
  return this === other;
}
;
_.apply_0 = function apply_81(arg0){
  return lambda$1_2(this.node_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_InteractiveExternalPortPositioner$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$1$Type', 1417);
function InteractiveExternalPortPositioner$lambda$2$Type(){
}

defineClass(1418, 1, $intern_25, InteractiveExternalPortPositioner$lambda$2$Type);
_.equals_0 = function equals_116(other){
  return this === other;
}
;
_.apply_0 = function apply_82(arg0){
  return castTo(arg0, 16).source.owner;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_InteractiveExternalPortPositioner$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$2$Type', 1418);
function InteractiveExternalPortPositioner$lambda$3$Type(node_0){
  this.node_0 = node_0;
}

defineClass(1419, 1, $intern_25, InteractiveExternalPortPositioner$lambda$3$Type);
_.equals_0 = function equals_117(other){
  return this === other;
}
;
_.apply_0 = function apply_83(arg0){
  return lambda$3_1(this.node_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_InteractiveExternalPortPositioner$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$3$Type', 1419);
function InteractiveExternalPortPositioner$lambda$4$Type(node_0){
  this.node_0 = node_0;
}

defineClass(1420, 1, $intern_25, InteractiveExternalPortPositioner$lambda$4$Type);
_.equals_0 = function equals_118(other){
  return this === other;
}
;
_.apply_0 = function apply_84(arg0){
  return lambda$4_2(this.node_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_InteractiveExternalPortPositioner$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$4$Type', 1420);
function InteractiveExternalPortPositioner$lambda$5$Type(node_0){
  this.node_0 = node_0;
}

defineClass(1421, 1, $intern_25, InteractiveExternalPortPositioner$lambda$5$Type);
_.equals_0 = function equals_119(other){
  return this === other;
}
;
_.apply_0 = function apply_85(arg0){
  return lambda$5_1(this.node_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_InteractiveExternalPortPositioner$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InteractiveExternalPortPositioner/lambda$5$Type', 1421);
function $clinit_IntermediateProcessorStrategy(){
  $clinit_IntermediateProcessorStrategy = emptyMethod;
  DIRECTION_PREPROCESSOR = new IntermediateProcessorStrategy('DIRECTION_PREPROCESSOR', 0);
  COMMENT_PREPROCESSOR = new IntermediateProcessorStrategy('COMMENT_PREPROCESSOR', 1);
  EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER = new IntermediateProcessorStrategy('EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER', 2);
  SPLINE_SELF_LOOP_PREPROCESSOR = new IntermediateProcessorStrategy('SPLINE_SELF_LOOP_PREPROCESSOR', 3);
  INTERACTIVE_EXTERNAL_PORT_POSITIONER = new IntermediateProcessorStrategy('INTERACTIVE_EXTERNAL_PORT_POSITIONER', 4);
  PARTITION_PREPROCESSOR = new IntermediateProcessorStrategy('PARTITION_PREPROCESSOR', 5);
  BIG_NODES_PREPROCESSOR = new IntermediateProcessorStrategy('BIG_NODES_PREPROCESSOR', 6);
  LABEL_DUMMY_INSERTER = new IntermediateProcessorStrategy('LABEL_DUMMY_INSERTER', 7);
  HIGH_DEGREE_NODE_LAYER_PROCESSOR = new IntermediateProcessorStrategy('HIGH_DEGREE_NODE_LAYER_PROCESSOR', 8);
  PARTITION_POSTPROCESSOR = new IntermediateProcessorStrategy('PARTITION_POSTPROCESSOR', 9);
  NODE_PROMOTION = new IntermediateProcessorStrategy('NODE_PROMOTION', 10);
  LAYER_CONSTRAINT_PROCESSOR = new IntermediateProcessorStrategy('LAYER_CONSTRAINT_PROCESSOR', 11);
  HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR = new IntermediateProcessorStrategy('HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR', 12);
  BIG_NODES_INTERMEDIATEPROCESSOR = new IntermediateProcessorStrategy('BIG_NODES_INTERMEDIATEPROCESSOR', 13);
  SEMI_INTERACTIVE_CROSSMIN_PROCESSOR = new IntermediateProcessorStrategy('SEMI_INTERACTIVE_CROSSMIN_PROCESSOR', 14);
  BREAKING_POINT_INSERTER = new IntermediateProcessorStrategy('BREAKING_POINT_INSERTER', 15);
  LONG_EDGE_SPLITTER = new IntermediateProcessorStrategy('LONG_EDGE_SPLITTER', 16);
  PORT_SIDE_PROCESSOR = new IntermediateProcessorStrategy('PORT_SIDE_PROCESSOR', 17);
  INVERTED_PORT_PROCESSOR = new IntermediateProcessorStrategy('INVERTED_PORT_PROCESSOR', 18);
  SELF_LOOP_PROCESSOR = new IntermediateProcessorStrategy('SELF_LOOP_PROCESSOR', 19);
  PORT_LIST_SORTER = new IntermediateProcessorStrategy('PORT_LIST_SORTER', 20);
  NORTH_SOUTH_PORT_PREPROCESSOR = new IntermediateProcessorStrategy('NORTH_SOUTH_PORT_PREPROCESSOR', 21);
  BREAKING_POINT_PROCESSOR = new IntermediateProcessorStrategy('BREAKING_POINT_PROCESSOR', 22);
  ONE_SIDED_GREEDY_SWITCH = new IntermediateProcessorStrategy('ONE_SIDED_GREEDY_SWITCH', 23);
  TWO_SIDED_GREEDY_SWITCH = new IntermediateProcessorStrategy('TWO_SIDED_GREEDY_SWITCH', 24);
  SPLINE_SELF_LOOP_POSITIONER = new IntermediateProcessorStrategy('SPLINE_SELF_LOOP_POSITIONER', 25);
  SINGLE_EDGE_GRAPH_WRAPPER = new IntermediateProcessorStrategy('SINGLE_EDGE_GRAPH_WRAPPER', 26);
  IN_LAYER_CONSTRAINT_PROCESSOR = new IntermediateProcessorStrategy('IN_LAYER_CONSTRAINT_PROCESSOR', 27);
  BIG_NODES_SPLITTER = new IntermediateProcessorStrategy('BIG_NODES_SPLITTER', 28);
  END_NODE_PORT_LABEL_MANAGEMENT_PROCESSOR = new IntermediateProcessorStrategy('END_NODE_PORT_LABEL_MANAGEMENT_PROCESSOR', 29);
  LABEL_AND_NODE_SIZE_PROCESSOR = new IntermediateProcessorStrategy('LABEL_AND_NODE_SIZE_PROCESSOR', 30);
  SPLINE_SELF_LOOP_ROUTER = new IntermediateProcessorStrategy('SPLINE_SELF_LOOP_ROUTER', 31);
  NODE_MARGIN_CALCULATOR = new IntermediateProcessorStrategy('NODE_MARGIN_CALCULATOR', 32);
  END_LABEL_PREPROCESSOR = new IntermediateProcessorStrategy('END_LABEL_PREPROCESSOR', 33);
  LABEL_DUMMY_SWITCHER = new IntermediateProcessorStrategy('LABEL_DUMMY_SWITCHER', 34);
  CENTER_LABEL_MANAGEMENT_PROCESSOR = new IntermediateProcessorStrategy('CENTER_LABEL_MANAGEMENT_PROCESSOR', 35);
  LABEL_SIDE_SELECTOR = new IntermediateProcessorStrategy('LABEL_SIDE_SELECTOR', 36);
  HYPEREDGE_DUMMY_MERGER = new IntermediateProcessorStrategy('HYPEREDGE_DUMMY_MERGER', 37);
  HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR = new IntermediateProcessorStrategy('HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR', 38);
  LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR = new IntermediateProcessorStrategy('LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR', 39);
  HIERARCHICAL_PORT_POSITION_PROCESSOR = new IntermediateProcessorStrategy('HIERARCHICAL_PORT_POSITION_PROCESSOR', 40);
  BIG_NODES_POSTPROCESSOR = new IntermediateProcessorStrategy('BIG_NODES_POSTPROCESSOR', 41);
  COMMENT_POSTPROCESSOR = new IntermediateProcessorStrategy('COMMENT_POSTPROCESSOR', 42);
  HYPERNODE_PROCESSOR = new IntermediateProcessorStrategy('HYPERNODE_PROCESSOR', 43);
  HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER = new IntermediateProcessorStrategy('HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER', 44);
  LONG_EDGE_JOINER = new IntermediateProcessorStrategy('LONG_EDGE_JOINER', 45);
  BREAKING_POINT_REMOVER = new IntermediateProcessorStrategy('BREAKING_POINT_REMOVER', 46);
  NORTH_SOUTH_PORT_POSTPROCESSOR = new IntermediateProcessorStrategy('NORTH_SOUTH_PORT_POSTPROCESSOR', 47);
  HORIZONTAL_COMPACTOR = new IntermediateProcessorStrategy('HORIZONTAL_COMPACTOR', 48);
  LABEL_DUMMY_REMOVER = new IntermediateProcessorStrategy('LABEL_DUMMY_REMOVER', 49);
  FINAL_SPLINE_BENDPOINTS_CALCULATOR = new IntermediateProcessorStrategy('FINAL_SPLINE_BENDPOINTS_CALCULATOR', 50);
  REVERSED_EDGE_RESTORER = new IntermediateProcessorStrategy('REVERSED_EDGE_RESTORER', 51);
  END_LABEL_POSTPROCESSOR = new IntermediateProcessorStrategy('END_LABEL_POSTPROCESSOR', 52);
  HIERARCHICAL_NODE_RESIZER = new IntermediateProcessorStrategy('HIERARCHICAL_NODE_RESIZER', 53);
  DIRECTION_POSTPROCESSOR = new IntermediateProcessorStrategy('DIRECTION_POSTPROCESSOR', 54);
}

function IntermediateProcessorStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_31(name_0){
  $clinit_IntermediateProcessorStrategy();
  return valueOf(($clinit_IntermediateProcessorStrategy$Map() , $MAP_19), name_0);
}

function values_27(){
  $clinit_IntermediateProcessorStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_intermediate_IntermediateProcessorStrategy_2_classLit, 1), $intern_38, 77, 0, [DIRECTION_PREPROCESSOR, COMMENT_PREPROCESSOR, EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER, SPLINE_SELF_LOOP_PREPROCESSOR, INTERACTIVE_EXTERNAL_PORT_POSITIONER, PARTITION_PREPROCESSOR, BIG_NODES_PREPROCESSOR, LABEL_DUMMY_INSERTER, HIGH_DEGREE_NODE_LAYER_PROCESSOR, PARTITION_POSTPROCESSOR, NODE_PROMOTION, LAYER_CONSTRAINT_PROCESSOR, HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR, BIG_NODES_INTERMEDIATEPROCESSOR, SEMI_INTERACTIVE_CROSSMIN_PROCESSOR, BREAKING_POINT_INSERTER, LONG_EDGE_SPLITTER, PORT_SIDE_PROCESSOR, INVERTED_PORT_PROCESSOR, SELF_LOOP_PROCESSOR, PORT_LIST_SORTER, NORTH_SOUTH_PORT_PREPROCESSOR, BREAKING_POINT_PROCESSOR, ONE_SIDED_GREEDY_SWITCH, TWO_SIDED_GREEDY_SWITCH, SPLINE_SELF_LOOP_POSITIONER, SINGLE_EDGE_GRAPH_WRAPPER, IN_LAYER_CONSTRAINT_PROCESSOR, BIG_NODES_SPLITTER, END_NODE_PORT_LABEL_MANAGEMENT_PROCESSOR, LABEL_AND_NODE_SIZE_PROCESSOR, SPLINE_SELF_LOOP_ROUTER, NODE_MARGIN_CALCULATOR, END_LABEL_PREPROCESSOR, LABEL_DUMMY_SWITCHER, CENTER_LABEL_MANAGEMENT_PROCESSOR, LABEL_SIDE_SELECTOR, HYPEREDGE_DUMMY_MERGER, HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR, LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR, HIERARCHICAL_PORT_POSITION_PROCESSOR, BIG_NODES_POSTPROCESSOR, COMMENT_POSTPROCESSOR, HYPERNODE_PROCESSOR, HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER, LONG_EDGE_JOINER, BREAKING_POINT_REMOVER, NORTH_SOUTH_PORT_POSTPROCESSOR, HORIZONTAL_COMPACTOR, LABEL_DUMMY_REMOVER, FINAL_SPLINE_BENDPOINTS_CALCULATOR, REVERSED_EDGE_RESTORER, END_LABEL_POSTPROCESSOR, HIERARCHICAL_NODE_RESIZER, DIRECTION_POSTPROCESSOR]);
}

defineClass(77, 22, {3:1, 34:1, 22:1, 77:1, 231:1}, IntermediateProcessorStrategy);
_.create_1 = function create_6(){
  switch (this.ordinal) {
    case 13:
      return new BigNodesIntermediateProcessor;
    case 41:
      return new BigNodesPostProcessor;
    case 6:
      return new BigNodesPreProcessor;
    case 28:
      return new BigNodesSplitter;
    case 15:
      return new BreakingPointInserter;
    case 22:
      return new BreakingPointProcessor;
    case 46:
      return new BreakingPointRemover;
    case 29:
    case 35:
      return new LabelManagementProcessor;
    case 42:
      return new CommentPostprocessor;
    case 1:
      return new CommentPreprocessor;
    case 54:
      return new GraphTransformer(($clinit_GraphTransformer$Mode() , TO_INTERNAL_LTR));
    case 0:
      return new GraphTransformer(($clinit_GraphTransformer$Mode() , TO_INPUT_DIRECTION));
    case 2:
      return new EdgeAndLayerConstraintEdgeReverser;
    case 52:
      return new EndLabelPostprocessor;
    case 33:
      return new EndLabelPreprocessor;
    case 50:
      return new FinalSplineBendpointsCalculator;
    case 23:
      return new LayerSweepCrossingMinimizer(($clinit_LayerSweepCrossingMinimizer$CrossMinType() , ONE_SIDED_GREEDY_SWITCH_0));
    case 24:
      return new LayerSweepCrossingMinimizer(($clinit_LayerSweepCrossingMinimizer$CrossMinType() , TWO_SIDED_GREEDY_SWITCH_0));
    case 53:
      return new HierarchicalNodeResizingProcessor;
    case 12:
      return new HierarchicalPortConstraintProcessor;
    case 38:
      return new HierarchicalPortDummySizeProcessor;
    case 44:
      return new HierarchicalPortOrthogonalEdgeRouter;
    case 40:
      return new HierarchicalPortPositionProcessor;
    case 8:
      return new HighDegreeNodeLayeringProcessor;
    case 48:
      return new HorizontalGraphCompactor;
    case 37:
      return new HyperedgeDummyMerger;
    case 43:
      return new HypernodesProcessor;
    case 27:
      return new InLayerConstraintProcessor;
    case 4:
      return new InteractiveExternalPortPositioner;
    case 30:
      return new LabelAndNodeSizeProcessor;
    case 7:
      return new LabelDummyInserter;
    case 49:
      return new LabelDummyRemover;
    case 34:
      return new LabelDummySwitcher;
    case 36:
      return new LabelSideSelector;
    case 11:
      return new LayerConstraintProcessor;
    case 39:
      return new LayerSizeAndGraphHeightCalculator;
    case 45:
      return new LongEdgeJoiner;
    case 16:
      return new LongEdgeSplitter;
    case 32:
      return new NodeMarginCalculator_0;
    case 10:
      return new NodePromotion;
    case 47:
      return new NorthSouthPortPostprocessor;
    case 21:
      return new NorthSouthPortPreprocessor;
    case 18:
      return new InvertedPortProcessor;
    case 9:
      return new PartitionPostprocessor;
    case 5:
      return new PartitionPreprocessor;
    case 20:
      return new PortListSorter;
    case 17:
      return new PortSideProcessor;
    case 51:
      return new ReversedEdgeRestorer;
    case 26:
      return new SingleEdgeGraphWrapper;
    case 19:
      return new SelfLoopProcessor;
    case 14:
      return new SemiInteractiveCrossMinProcessor;
    case 25:
      return new SplineSelfLoopPositioner;
    case 3:
      return new SplineSelfLoopPreProcessor;
    case 31:
      return new SplineSelfLoopRouter;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout processor ' + (this.name_0 != null?this.name_0:'' + this.ordinal)));
  }
}
;
var BIG_NODES_INTERMEDIATEPROCESSOR, BIG_NODES_POSTPROCESSOR, BIG_NODES_PREPROCESSOR, BIG_NODES_SPLITTER, BREAKING_POINT_INSERTER, BREAKING_POINT_PROCESSOR, BREAKING_POINT_REMOVER, CENTER_LABEL_MANAGEMENT_PROCESSOR, COMMENT_POSTPROCESSOR, COMMENT_PREPROCESSOR, DIRECTION_POSTPROCESSOR, DIRECTION_PREPROCESSOR, EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER, END_LABEL_POSTPROCESSOR, END_LABEL_PREPROCESSOR, END_NODE_PORT_LABEL_MANAGEMENT_PROCESSOR, FINAL_SPLINE_BENDPOINTS_CALCULATOR, HIERARCHICAL_NODE_RESIZER, HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR, HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR, HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER, HIERARCHICAL_PORT_POSITION_PROCESSOR, HIGH_DEGREE_NODE_LAYER_PROCESSOR, HORIZONTAL_COMPACTOR, HYPEREDGE_DUMMY_MERGER, HYPERNODE_PROCESSOR, INTERACTIVE_EXTERNAL_PORT_POSITIONER, INVERTED_PORT_PROCESSOR, IN_LAYER_CONSTRAINT_PROCESSOR, LABEL_AND_NODE_SIZE_PROCESSOR, LABEL_DUMMY_INSERTER, LABEL_DUMMY_REMOVER, LABEL_DUMMY_SWITCHER, LABEL_SIDE_SELECTOR, LAYER_CONSTRAINT_PROCESSOR, LAYER_SIZE_AND_GRAPH_HEIGHT_CALCULATOR, LONG_EDGE_JOINER, LONG_EDGE_SPLITTER, NODE_MARGIN_CALCULATOR, NODE_PROMOTION, NORTH_SOUTH_PORT_POSTPROCESSOR, NORTH_SOUTH_PORT_PREPROCESSOR, ONE_SIDED_GREEDY_SWITCH, PARTITION_POSTPROCESSOR, PARTITION_PREPROCESSOR, PORT_LIST_SORTER, PORT_SIDE_PROCESSOR, REVERSED_EDGE_RESTORER, SELF_LOOP_PROCESSOR, SEMI_INTERACTIVE_CROSSMIN_PROCESSOR, SINGLE_EDGE_GRAPH_WRAPPER, SPLINE_SELF_LOOP_POSITIONER, SPLINE_SELF_LOOP_PREPROCESSOR, SPLINE_SELF_LOOP_ROUTER, TWO_SIDED_GREEDY_SWITCH;
var Lorg_eclipse_elk_alg_layered_intermediate_IntermediateProcessorStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.intermediate', 'IntermediateProcessorStrategy', 77, Ljava_lang_Enum_2_classLit, values_27, valueOf_31);
function $clinit_IntermediateProcessorStrategy$Map(){
  $clinit_IntermediateProcessorStrategy$Map = emptyMethod;
  $MAP_19 = createValueOfMap(values_27());
}

var $MAP_19;
function $createEastPortSideDummies(layeredGraph, eastwardPort, edge, layerNodeList){
  var dummy, dummyEdge, dummyInput, dummyOutput, label_0, labelIterator, labelPlacement;
  if (edge.source.owner == eastwardPort.owner) {
    return;
  }
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , LONG_EDGE));
  $setProperty_0(dummy, ($clinit_InternalProperties_1() , ORIGIN_0), edge);
  $setProperty_0(dummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
  layerNodeList.array[layerNodeList.array.length] = dummy;
  dummyInput = new LPort;
  $setNode(dummyInput, dummy);
  $setSide(dummyInput, ($clinit_PortSide() , WEST_1));
  dummyOutput = new LPort;
  $setNode(dummyOutput, dummy);
  $setSide(dummyOutput, EAST_1);
  $setTarget_0(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty_0(dummyEdge, JUNCTION_POINTS, null);
  $setSource_0(dummyEdge, dummyOutput);
  $setTarget_0(dummyEdge, eastwardPort);
  $setLongEdgeSourceAndTarget(dummy, dummyInput, dummyOutput);
  labelIterator = new AbstractList$ListIteratorImpl(edge.labels, 0);
  while (labelIterator.i < labelIterator.this$01_0.size_1()) {
    label_0 = (checkCriticalElement(labelIterator.i < labelIterator.this$01_0.size_1()) , castTo(labelIterator.this$01_0.get_3(labelIterator.last = labelIterator.i++), 70));
    labelPlacement = castTo($getProperty(label_0, EDGE_LABELS_PLACEMENT), 236);
    if (labelPlacement == ($clinit_EdgeLabelPlacement() , HEAD)) {
      $remove_9(labelIterator);
      $add_4(dummyEdge.labels, label_0);
    }
  }
}

function $createWestPortSideDummies(layeredGraph, westwardPort, edge, layerNodeList){
  var dummy, dummyEdge, dummyInput, dummyOutput, originalTarget;
  if (edge.target.owner == westwardPort.owner) {
    return;
  }
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , LONG_EDGE));
  $setProperty_0(dummy, ($clinit_InternalProperties_1() , ORIGIN_0), edge);
  $setProperty_0(dummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
  layerNodeList.array[layerNodeList.array.length] = dummy;
  dummyInput = new LPort;
  $setNode(dummyInput, dummy);
  $setSide(dummyInput, ($clinit_PortSide() , WEST_1));
  dummyOutput = new LPort;
  $setNode(dummyOutput, dummy);
  $setSide(dummyOutput, EAST_1);
  originalTarget = edge.target;
  $setTarget_0(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty_0(dummyEdge, JUNCTION_POINTS, null);
  $setSource_0(dummyEdge, dummyOutput);
  $setTarget_0(dummyEdge, originalTarget);
  $setLongEdgeSourceAndTarget(dummy, dummyInput, dummyOutput);
}

function $process_26(layeredGraph, monitor){
  var currentLayer, edge, edge$index, edge$max, edgeArray, edges, layerIterator, layers, node, node$iterator, node$iterator0, node$iterator1, port, port$iterator, port$iterator0, previousLayer, unassignedNodes;
  $begin(monitor, 'Inverted port preprocessing', 1);
  layers = layeredGraph.layers;
  layerIterator = new AbstractList$ListIteratorImpl(layers, 0);
  currentLayer = null;
  unassignedNodes = new ArrayList;
  while (layerIterator.i < layerIterator.this$01_0.size_1()) {
    previousLayer = currentLayer;
    currentLayer = (checkCriticalElement(layerIterator.i < layerIterator.this$01_0.size_1()) , castTo(layerIterator.this$01_0.get_3(layerIterator.last = layerIterator.i++), 25));
    for (node$iterator0 = new ArrayList$1(unassignedNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      $setLayer_0(node, previousLayer);
    }
    unassignedNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    for (node$iterator1 = new ArrayList$1(currentLayer.nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
      node = castTo($next_10(node$iterator1), 9);
      if (node.type_0 != ($clinit_LNode$NodeType() , NORMAL)) {
        continue;
      }
      if (!$isSideFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
        continue;
      }
      for (port$iterator0 = $getPorts_0(node, ($clinit_PortType() , INPUT), ($clinit_PortSide() , EAST_1)).iterator_0(); port$iterator0.hasNext_0();) {
        port = castTo(port$iterator0.next_1(), 11);
        edges = port.incomingEdges;
        edgeArray = castTo($toArray_2(edges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, edges.array.length, 0, 1)), 101);
        for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
          edge = edgeArray[edge$index];
          $createEastPortSideDummies(layeredGraph, port, edge, unassignedNodes);
        }
      }
      for (port$iterator = $getPorts_0(node, OUTPUT, WEST_1).iterator_0(); port$iterator.hasNext_0();) {
        port = castTo(port$iterator.next_1(), 11);
        edges = port.outgoingEdges;
        edgeArray = castTo($toArray_2(edges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, edges.array.length, 0, 1)), 101);
        for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
          edge = edgeArray[edge$index];
          $createWestPortSideDummies(layeredGraph, port, edge, unassignedNodes);
        }
      }
    }
  }
  for (node$iterator = new ArrayList$1(unassignedNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $setLayer_0(node, currentLayer);
  }
  $done_0(monitor);
}

function $setLongEdgeSourceAndTarget(longEdgeDummy, dummyInputPort, dummyOutputPort){
  var sourceNode, sourceNodeType, sourcePort, targetNode, targetNodeType, targetPort;
  sourcePort = castTo($get_7(dummyInputPort.incomingEdges, 0), 16).source;
  sourceNode = sourcePort.owner;
  sourceNodeType = sourceNode.type_0;
  targetPort = castTo($get_7(dummyOutputPort.outgoingEdges, 0), 16).target;
  targetNode = targetPort.owner;
  targetNodeType = targetNode.type_0;
  sourceNodeType == ($clinit_LNode$NodeType() , LONG_EDGE)?$setProperty_0(longEdgeDummy, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), castTo($getProperty(sourceNode, LONG_EDGE_SOURCE), 11)):$setProperty_0(longEdgeDummy, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), sourcePort);
  targetNodeType == LONG_EDGE?$setProperty_0(longEdgeDummy, ($clinit_InternalProperties_1() , LONG_EDGE_TARGET), castTo($getProperty(targetNode, LONG_EDGE_TARGET), 11)):$setProperty_0(longEdgeDummy, ($clinit_InternalProperties_1() , LONG_EDGE_TARGET), targetPort);
}

function InvertedPortProcessor(){
}

defineClass(1443, 1, $intern_108, InvertedPortProcessor);
_.process = function process_22(layeredGraph, monitor){
  $process_26(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_InvertedPortProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'InvertedPortProcessor', 1443);
function $computePortLabelBox(dummyPort, labelLabelSpacing){
  var label_0, label$iterator, labelSize, result;
  if (dummyPort.labels.array.length == 0) {
    return null;
  }
   else {
    result = new ElkRectangle;
    for (label$iterator = new ArrayList$1(dummyPort.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 70);
      labelSize = label_0.size_0;
      result.width_0 = $wnd.Math.max(result.width_0, labelSize.x_0);
      result.height += labelSize.y_0;
    }
    result.height += (dummyPort.labels.array.length - 1) * labelLabelSpacing;
    return result;
  }
}

function $lambda$2(portLabelPlacement_1, placeNextToPort_2, dummy_2){
  $placeExternalPortDummyLabels(dummy_2, portLabelPlacement_1, placeNextToPort_2);
}

function $placeExternalPortDummyLabels(dummy, graphPortLabelPlacement, placeNextToPortIfPossible){
  var currentY, dummyPort, dummyPortPos, dummySize, label_0, label$iterator, labelLabelSpacing, labelPortSpacing, labelPos, portLabelBox;
  labelPortSpacing = checkNotNull_1(castToDouble($getProperty(dummy, ($clinit_LayeredOptions() , SPACING_LABEL_PORT))));
  labelLabelSpacing = checkNotNull_1(castToDouble($getProperty(dummy, SPACING_LABEL_LABEL)));
  dummySize = dummy.size_0;
  dummyPort = castTo($get_7(dummy.ports, 0), 11);
  dummyPortPos = dummyPort.pos;
  portLabelBox = $computePortLabelBox(dummyPort, labelLabelSpacing);
  if (!portLabelBox) {
    return;
  }
  if (graphPortLabelPlacement == ($clinit_PortLabelPlacement() , INSIDE_0)) {
    switch (castTo($getProperty(dummy, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71).ordinal) {
      case 1:
        portLabelBox.x_0 = (dummySize.x_0 - portLabelBox.width_0) / 2 - dummyPortPos.x_0;
        portLabelBox.y_0 = labelPortSpacing;
        break;
      case 3:
        portLabelBox.x_0 = (dummySize.x_0 - portLabelBox.width_0) / 2 - dummyPortPos.x_0;
        portLabelBox.y_0 = -labelPortSpacing - portLabelBox.height;
        break;
      case 2:
        placeNextToPortIfPossible && dummyPort.incomingEdges.array.length == 0 && dummyPort.outgoingEdges.array.length == 0?(portLabelBox.y_0 = (dummySize.y_0 - portLabelBox.height) / 2 - dummyPortPos.y_0):(portLabelBox.y_0 = dummySize.y_0 + labelPortSpacing - dummyPortPos.y_0);
        portLabelBox.x_0 = -labelPortSpacing - portLabelBox.width_0;
        break;
      case 4:
        placeNextToPortIfPossible && dummyPort.incomingEdges.array.length == 0 && dummyPort.outgoingEdges.array.length == 0?(portLabelBox.y_0 = (dummySize.y_0 - portLabelBox.height) / 2 - dummyPortPos.y_0):(portLabelBox.y_0 = dummySize.y_0 + labelPortSpacing - dummyPortPos.y_0);
        portLabelBox.x_0 = labelPortSpacing;
    }
  }
   else if (graphPortLabelPlacement == OUTSIDE_0) {
    switch (castTo($getProperty(dummy, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71).ordinal) {
      case 1:
      case 3:
        portLabelBox.x_0 = dummyPortPos.x_0 + labelPortSpacing;
        break;
      case 2:
      case 4:
        portLabelBox.y_0 = dummyPortPos.y_0 + labelPortSpacing;
    }
  }
  currentY = portLabelBox.y_0;
  for (label$iterator = new ArrayList$1(dummyPort.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 70);
    labelPos = label_0.pos;
    labelPos.x_0 = portLabelBox.x_0;
    labelPos.y_0 = currentY;
    currentY += label_0.size_0.y_0 + labelLabelSpacing;
  }
}

function $process_27(layeredGraph, monitor){
  var layer, layer$iterator, placeNextToPort, portLabelPlacement;
  $begin(monitor, 'Node and Port Label Placement and Node Sizing', 1);
  $forEach_0($getNodes(new LGraphAdapters$LGraphAdapter(layeredGraph, true, new LabelAndNodeSizeProcessor$lambda$0$Type)), new NodeLabelAndSizeCalculator$lambda$0$Type);
  if (castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))) {
    portLabelPlacement = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , PORT_LABELS_PLACEMENT)), 284);
    placeNextToPort = checkNotNull_1(castToBoolean($getProperty(layeredGraph, PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE)));
    for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
      layer = castTo($next_10(layer$iterator), 25);
      $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(layer.nodes, 16)), new LabelAndNodeSizeProcessor$lambda$1$Type), new LabelAndNodeSizeProcessor$lambda$2$Type(portLabelPlacement, placeNextToPort));
    }
  }
  $done_0(monitor);
}

function LabelAndNodeSizeProcessor(){
}

defineClass(1422, 1, $intern_108, LabelAndNodeSizeProcessor);
_.process = function process_23(layeredGraph, monitor){
  $process_27(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelAndNodeSizeProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelAndNodeSizeProcessor', 1422);
function LabelAndNodeSizeProcessor$lambda$0$Type(){
}

defineClass(1423, 1, $intern_90, LabelAndNodeSizeProcessor$lambda$0$Type);
_.test_0 = function test_35(arg0){
  return castTo(arg0, 9).type_0 == ($clinit_LNode$NodeType() , NORMAL) || castTo(arg0, 9).type_0 == BIG_NODE;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelAndNodeSizeProcessor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelAndNodeSizeProcessor/lambda$0$Type', 1423);
function LabelAndNodeSizeProcessor$lambda$1$Type(){
}

defineClass(1424, 1, $intern_90, LabelAndNodeSizeProcessor$lambda$1$Type);
_.test_0 = function test_36(arg0){
  return castTo(arg0, 9).type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelAndNodeSizeProcessor$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelAndNodeSizeProcessor/lambda$1$Type', 1424);
function LabelAndNodeSizeProcessor$lambda$2$Type(portLabelPlacement_1, placeNextToPort_2){
  this.portLabelPlacement_1 = portLabelPlacement_1;
  this.placeNextToPort_2 = placeNextToPort_2;
}

defineClass(1425, 1, {}, LabelAndNodeSizeProcessor$lambda$2$Type);
_.accept = function accept_62(arg0){
  $lambda$2(this.portLabelPlacement_1, this.placeNextToPort_2, arg0);
}
;
_.placeNextToPort_2 = false;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelAndNodeSizeProcessor$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelAndNodeSizeProcessor/lambda$2$Type', 1425);
function $clinit_LabelDummyInserter(){
  $clinit_LabelDummyInserter = emptyMethod;
  CENTER_LABEL = new LabelDummyInserter$1;
}

function $createLabelDummy(layeredGraph, edge, thickness, representedLabels){
  var dummyNode, dummyPort, dummyPort$iterator, portPos;
  dummyNode = new LNode(layeredGraph);
  $setType(dummyNode, ($clinit_LNode$NodeType() , LABEL));
  $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0), edge);
  $setProperty_0(dummyNode, REPRESENTED_LABELS, representedLabels);
  $setProperty_0(dummyNode, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty_0(dummyNode, LONG_EDGE_SOURCE, edge.source);
  $setProperty_0(dummyNode, LONG_EDGE_TARGET, edge.target);
  splitEdge(edge, dummyNode);
  portPos = $wnd.Math.floor(thickness / 2);
  for (dummyPort$iterator = new ArrayList$1(dummyNode.ports); dummyPort$iterator.i < dummyPort$iterator.this$01.array.length;) {
    dummyPort = castTo($next_10(dummyPort$iterator), 11);
    dummyPort.pos.y_0 = portPos;
  }
  return dummyNode;
}

function $process_28(layeredGraph, monitor){
  var dummyNode, dummySize, edge, edge$iterator, edgeLabelSpacing, iterator, label_0, labelLabelSpacing, layoutDirection, newDummyNodes, node, node$iterator, representedLabels, thickness;
  $begin(monitor, 'Label dummy insertions', 1);
  newDummyNodes = new ArrayList;
  edgeLabelSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_EDGE_LABEL_0))));
  labelLabelSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_LABEL_LABEL)));
  layoutDirection = castTo($getProperty(layeredGraph, DIRECTION), 107);
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 16);
      if (edge.source.owner != edge.target.owner && any_0(edge.labels, CENTER_LABEL)) {
        thickness = $retrieveThickness(edge);
        representedLabels = newArrayListWithCapacity(edge.labels.array.length);
        dummyNode = $createLabelDummy(layeredGraph, edge, thickness, representedLabels);
        newDummyNodes.array[newDummyNodes.array.length] = dummyNode;
        dummySize = dummyNode.size_0;
        iterator = new AbstractList$ListIteratorImpl(edge.labels, 0);
        while (iterator.i < iterator.this$01_0.size_1()) {
          label_0 = (checkCriticalElement(iterator.i < iterator.this$01_0.size_1()) , castTo(iterator.this$01_0.get_3(iterator.last = iterator.i++), 70));
          if (maskUndefined($getProperty(label_0, EDGE_LABELS_PLACEMENT)) === maskUndefined(($clinit_EdgeLabelPlacement() , CENTER_4))) {
            if (layoutDirection == ($clinit_Direction_0() , UP_1) || layoutDirection == DOWN_1) {
              dummySize.x_0 += label_0.size_0.x_0 + labelLabelSpacing;
              dummySize.y_0 = $wnd.Math.max(dummySize.y_0, label_0.size_0.y_0);
            }
             else {
              dummySize.x_0 = $wnd.Math.max(dummySize.x_0, label_0.size_0.x_0);
              dummySize.y_0 += label_0.size_0.y_0 + labelLabelSpacing;
            }
            representedLabels.array[representedLabels.array.length] = label_0;
            $remove_9(iterator);
          }
        }
        if (layoutDirection == ($clinit_Direction_0() , UP_1) || layoutDirection == DOWN_1) {
          dummySize.x_0 -= labelLabelSpacing;
          dummySize.y_0 += edgeLabelSpacing + thickness;
        }
         else {
          dummySize.y_0 += edgeLabelSpacing - labelLabelSpacing + thickness;
        }
      }
    }
  }
  $addAll_2(layeredGraph.layerlessNodes, newDummyNodes);
  $done_0(monitor);
}

function $retrieveThickness(edge){
  var thickness;
  thickness = checkNotNull_1(castToDouble($getProperty(edge, ($clinit_LayeredOptions() , EDGE_THICKNESS_0))));
  if (thickness < 0) {
    thickness = 0;
    $setProperty_0(edge, EDGE_THICKNESS_0, thickness);
  }
  return thickness;
}

function LabelDummyInserter(){
  $clinit_LabelDummyInserter();
}

defineClass(1426, 1, $intern_108, LabelDummyInserter);
_.process = function process_24(layeredGraph, monitor){
  $process_28(castTo(layeredGraph, 32), monitor);
}
;
var CENTER_LABEL;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummyInserter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummyInserter', 1426);
function LabelDummyInserter$1(){
}

defineClass(1427, 1, $intern_91, LabelDummyInserter$1);
_.apply_1 = function apply_86(label_0){
  return maskUndefined($getProperty(castTo(label_0, 70), ($clinit_LayeredOptions() , EDGE_LABELS_PLACEMENT))) === maskUndefined(($clinit_EdgeLabelPlacement() , CENTER_4));
}
;
_.equals_0 = function equals_120(other){
  return this === other;
}
;
_.test_0 = function test_37(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummyInserter$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummyInserter/1', 1427);
function $placeLabelsForHorizontalLayout(labels, labelPos, labelSpacing, labelSpace){
  var label_0, label$iterator;
  for (label$iterator = labels.iterator_0(); label$iterator.hasNext_0();) {
    label_0 = castTo(label$iterator.next_1(), 70);
    label_0.pos.x_0 = labelPos.x_0 + (labelSpace.x_0 - label_0.size_0.x_0) / 2;
    label_0.pos.y_0 = labelPos.y_0;
    labelPos.y_0 += label_0.size_0.y_0 + labelSpacing;
  }
}

function $placeLabelsForVerticalLayout(labels, labelPos, labelSpacing, labelSpace, leftAligned){
  var label_0, label$iterator;
  for (label$iterator = labels.iterator_0(); label$iterator.hasNext_0();) {
    label_0 = castTo(label$iterator.next_1(), 70);
    label_0.pos.x_0 = labelPos.x_0;
    label_0.pos.y_0 = leftAligned?labelPos.y_0:labelPos.y_0 + labelSpace.y_0 - label_0.size_0.y_0;
    labelPos.x_0 += label_0.size_0.x_0 + labelSpacing;
  }
}

function $process_29(layeredGraph, monitor){
  var currLabelPos, edgeLabelSpacing, labelLabelSpacing, labelSpace, labelsBelowEdge, layer, layer$iterator, layoutDirection, node, nodeIterator, originEdge, representedLabels, thickness;
  $begin(monitor, 'Label dummy removal', 1);
  edgeLabelSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_EDGE_LABEL_0))));
  labelLabelSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_LABEL_LABEL)));
  layoutDirection = castTo($getProperty(layeredGraph, DIRECTION), 107);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    nodeIterator = new AbstractList$ListIteratorImpl(layer.nodes, 0);
    while (nodeIterator.i < nodeIterator.this$01_0.size_1()) {
      node = (checkCriticalElement(nodeIterator.i < nodeIterator.this$01_0.size_1()) , castTo(nodeIterator.this$01_0.get_3(nodeIterator.last = nodeIterator.i++), 9));
      if (node.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
        originEdge = castTo($getProperty(node, ($clinit_InternalProperties_1() , ORIGIN_0)), 16);
        thickness = checkNotNull_1(castToDouble($getProperty(originEdge, EDGE_THICKNESS_0)));
        labelsBelowEdge = maskUndefined($getProperty(node, LABEL_SIDE)) === maskUndefined(($clinit_LabelSide() , BELOW));
        currLabelPos = new KVector_2(node.pos);
        labelsBelowEdge && (currLabelPos.y_0 += thickness + edgeLabelSpacing);
        labelSpace = new KVector_1(node.size_0.x_0, node.size_0.y_0 - thickness - edgeLabelSpacing);
        representedLabels = castTo($getProperty(node, REPRESENTED_LABELS), 15);
        layoutDirection == ($clinit_Direction_0() , UP_1) || layoutDirection == DOWN_1?$placeLabelsForVerticalLayout(representedLabels, currLabelPos, labelLabelSpacing, labelSpace, labelsBelowEdge):$placeLabelsForHorizontalLayout(representedLabels, currLabelPos, labelLabelSpacing, labelSpace);
        $addAll_2(originEdge.labels, representedLabels);
        joinAt(node, false);
        $remove_9(nodeIterator);
      }
    }
  }
  $done_0(monitor);
}

function LabelDummyRemover(){
}

defineClass(1428, 1, $intern_108, LabelDummyRemover);
_.process = function process_25(layeredGraph, monitor){
  $process_29(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummyRemover_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummyRemover', 1428);
function $clinit_LabelDummySwitcher(){
  $clinit_LabelDummySwitcher = emptyMethod;
  INCLUDE_LABEL = new Property_0('edgelabelcenterednessanalysis.includelabel', ($clinit_Boolean() , FALSE_0));
}

function $assignIdsToLayers(layeredGraph){
  var layer, layer$iterator, layerIndex;
  layerIndex = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    layer.id_0 = layerIndex;
    ++layerIndex;
  }
}

function $assignLayer(this$static, labelDummyInfo, targetLayerIndex){
  var label_0, label$iterator, newLayerId;
  targetLayerIndex != labelDummyInfo.leftmostLayerId + labelDummyInfo.leftLongEdgeDummies.size_1() && $swapNodes(labelDummyInfo.labelDummy, $ithDummyNode(labelDummyInfo, targetLayerIndex - labelDummyInfo.leftmostLayerId));
  newLayerId = labelDummyInfo.labelDummy.layer.id_0;
  this$static.layerWidths[newLayerId] = $wnd.Math.max(this$static.layerWidths[newLayerId], labelDummyInfo.labelDummy.size_0.x_0);
  for (label$iterator = castTo($getProperty(labelDummyInfo.labelDummy, ($clinit_InternalProperties_1() , REPRESENTED_LABELS)), 15).iterator_0(); label$iterator.hasNext_0();) {
    label_0 = castTo(label$iterator.next_1(), 70);
    $setProperty_0(label_0, INCLUDE_LABEL, ($clinit_Boolean() , $clinit_Boolean() , true));
  }
}

function $assignToWiderLayer(this$static, labelDummyInfo){
  var dummyWidth, layer, layer$iterator, validLayers;
  dummyWidth = labelDummyInfo.labelDummy.size_0.x_0;
  validLayers = new AbstractList$SubList($getGraph(labelDummyInfo.labelDummy).layers, labelDummyInfo.leftmostLayerId, labelDummyInfo.rightmostLayerId + 1);
  for (layer$iterator = new AbstractList$IteratorImpl(validLayers); layer$iterator.i < layer$iterator.this$01_0.size_1();) {
    layer = (checkCriticalElement(layer$iterator.i < layer$iterator.this$01_0.size_1()) , castTo(layer$iterator.this$01_0.get_3(layer$iterator.last = layer$iterator.i++), 25));
    if (layer.size_0.x_0 >= dummyWidth) {
      $assignLayer(this$static, labelDummyInfo, layer.id_0);
      return true;
    }
  }
  return false;
}

function $calculateLayerWidths(this$static, layeredGraph){
  var layer, layer$iterator;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    this$static.layerWidths[layer.id_0] = findMaxNonDummyNodeWidth(layer);
  }
}

function $computeLayerWidthSums(this$static, labelDummyInfo){
  var currentIndex, currentWidthSum, edgeNodeSpacing, layerWidthSums, leftDummy, leftDummy$iterator, lgraph, minSpaceBetweenLayers, nodeNodeSpacing, rightDummy, rightDummy$iterator;
  lgraph = $getGraph(labelDummyInfo.labelDummy);
  edgeNodeSpacing = checkNotNull_1(castToDouble($getProperty(lgraph, ($clinit_LayeredOptions() , SPACING_EDGE_NODE_BETWEEN_LAYERS_0)))) * 2;
  nodeNodeSpacing = checkNotNull_1(castToDouble($getProperty(lgraph, SPACING_NODE_NODE_BETWEEN_LAYERS_0)));
  minSpaceBetweenLayers = $wnd.Math.max(edgeNodeSpacing, nodeNodeSpacing);
  layerWidthSums = initUnidimensionalArray(D_classLit, $intern_69, 23, labelDummyInfo.rightmostLayerId - labelDummyInfo.leftmostLayerId + 1, 15, 1);
  currentWidthSum = -minSpaceBetweenLayers;
  currentIndex = 0;
  for (leftDummy$iterator = labelDummyInfo.leftLongEdgeDummies.iterator_0(); leftDummy$iterator.hasNext_0();) {
    leftDummy = castTo(leftDummy$iterator.next_1(), 9);
    currentWidthSum += this$static.layerWidths[leftDummy.layer.id_0] + minSpaceBetweenLayers;
    layerWidthSums[currentIndex++] = currentWidthSum;
  }
  currentWidthSum += this$static.layerWidths[labelDummyInfo.labelDummy.layer.id_0] + minSpaceBetweenLayers;
  layerWidthSums[currentIndex++] = currentWidthSum;
  for (rightDummy$iterator = new ArrayList$1(labelDummyInfo.rightLongEdgeDummies); rightDummy$iterator.i < rightDummy$iterator.this$01.array.length;) {
    rightDummy = castTo($next_10(rightDummy$iterator), 9);
    currentWidthSum += this$static.layerWidths[rightDummy.layer.id_0] + minSpaceBetweenLayers;
    layerWidthSums[currentIndex++] = currentWidthSum;
  }
  return layerWidthSums;
}

function $computeSpaceEfficientAssignment(this$static, labelDummyInfos){
  var labelCount, labelIndex, nonTrivialLabels;
  nonTrivialLabels = $performTrivialAssignments(this$static, labelDummyInfos);
  if (nonTrivialLabels.array.length == 0) {
    return;
  }
  $sort(nonTrivialLabels, new LabelDummySwitcher$lambda$4$Type);
  labelCount = nonTrivialLabels.array.length;
  for (labelIndex = 0; labelIndex < labelCount; labelIndex++) {
    $assignLayer(this$static, (checkCriticalElementIndex(labelIndex, nonTrivialLabels.array.length) , castTo(nonTrivialLabels.array[labelIndex], 291)), $findPotentiallyWidestLayer(this$static, nonTrivialLabels, labelIndex));
  }
}

function $doUpdateLongEdgeLabelDummyInfo(labelDummy){
  var longEdgeDummy;
  longEdgeDummy = ($clinit_LabelDummySwitcher() , castTo($next_2($iterator($getIncomingEdges(labelDummy))), 16).source.owner);
  while (longEdgeDummy.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    $setProperty_0(longEdgeDummy, ($clinit_InternalProperties_1() , LONG_EDGE_BEFORE_LABEL_DUMMY), ($clinit_Boolean() , $clinit_Boolean() , true));
    longEdgeDummy = castTo($next_2($iterator($getIncomingEdges(longEdgeDummy))), 16).source.owner;
  }
}

function $findCenterLayerTargetId(this$static, labelDummyInfo){
  var i, layerWidthSums, threshold;
  layerWidthSums = $computeLayerWidthSums(this$static, labelDummyInfo);
  threshold = layerWidthSums[layerWidthSums.length - 1] / 2;
  for (i = 0; i < layerWidthSums.length; i++) {
    if (layerWidthSums[i] >= threshold) {
      return labelDummyInfo.leftmostLayerId + i;
    }
  }
  return labelDummyInfo.leftmostLayerId + labelDummyInfo.leftLongEdgeDummies.size_1();
}

function $findPotentiallyWidestLayer(this$static, labelDummyInfos, labelIndex){
  var currLabelInfo, label_0, labelCount, labelDummyInfo, labelDummyWidth, largestUnassignedLabel, layer, potentialWidth, widestLayerIndex, widestLayerWidth;
  labelCount = labelDummyInfos.array.length;
  labelDummyInfo = (checkCriticalElementIndex(labelIndex, labelDummyInfos.array.length) , castTo(labelDummyInfos.array[labelIndex], 291));
  labelDummyWidth = labelDummyInfo.labelDummy.size_0.x_0;
  widestLayerIndex = labelDummyInfo.leftmostLayerId;
  widestLayerWidth = 0;
  for (layer = labelDummyInfo.leftmostLayerId; layer <= labelDummyInfo.rightmostLayerId; layer++) {
    if (labelDummyWidth <= this$static.layerWidths[layer]) {
      return layer;
    }
    potentialWidth = this$static.layerWidths[layer];
    largestUnassignedLabel = null;
    for (label_0 = labelIndex + 1; label_0 < labelCount; label_0++) {
      currLabelInfo = (checkCriticalElementIndex(label_0, labelDummyInfos.array.length) , castTo(labelDummyInfos.array[label_0], 291));
      currLabelInfo.leftmostLayerId <= layer && currLabelInfo.rightmostLayerId >= layer && (largestUnassignedLabel = currLabelInfo);
    }
    !!largestUnassignedLabel && (potentialWidth = $wnd.Math.max(potentialWidth, largestUnassignedLabel.labelDummy.size_0.x_0));
    if (potentialWidth > widestLayerWidth) {
      widestLayerIndex = layer;
      widestLayerWidth = potentialWidth;
    }
  }
  return widestLayerIndex;
}

function $findWidestLayerTargetId(this$static, labelDummyInfo){
  var index_0, widestLayerIndex;
  widestLayerIndex = labelDummyInfo.leftmostLayerId;
  for (index_0 = widestLayerIndex + 1; index_0 <= labelDummyInfo.rightmostLayerId; index_0++) {
    this$static.layerWidths[index_0] > this$static.layerWidths[widestLayerIndex] && (widestLayerIndex = index_0);
  }
  return widestLayerIndex;
}

function $gatherLabelDummyInfos(layeredGraph, defaultPlacementStrategy){
  var infos, strategy, strategy$array, strategy$index, strategy$max;
  infos = new EnumMap(Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit);
  for (strategy$array = ($clinit_CenterEdgeLabelPlacementStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit, 1), $intern_38, 206, 0, [MEDIAN_LAYER, TAIL_LAYER, HEAD_LAYER, SPACE_EFFICIENT_LAYER, WIDEST_LAYER, CENTER_LAYER])) , strategy$index = 0 , strategy$max = strategy$array.length; strategy$index < strategy$max; ++strategy$index) {
    strategy = strategy$array[strategy$index];
    $put_3(infos, strategy, new ArrayList);
  }
  $forEach_2($map($filter($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(layeredGraph.layers, 16)), new LabelDummySwitcher$lambda$0$Type), new LabelDummySwitcher$lambda$1$Type), new LabelDummySwitcher$lambda$2$Type(defaultPlacementStrategy)), new LabelDummySwitcher$lambda$3$Type(infos));
  return infos;
}

function $isPartOfReversedEdge(labelDummyInfo){
  var incoming, outgoing;
  incoming = castTo($next_2($iterator($getIncomingEdges(labelDummyInfo.labelDummy))), 16);
  outgoing = castTo($next_2($iterator($getOutgoingEdges(labelDummyInfo.labelDummy))), 16);
  return checkNotNull_1(castToBoolean($getProperty(incoming, ($clinit_InternalProperties_1() , REVERSED)))) || checkNotNull_1(castToBoolean($getProperty(outgoing, REVERSED)));
}

function $performTrivialAssignments(this$static, labelDummyInfos){
  var labelDummyInfo, labelDummyInfo$iterator, remainingLabels;
  remainingLabels = new ArrayList_0(labelDummyInfos.size_1());
  for (labelDummyInfo$iterator = labelDummyInfos.iterator_0(); labelDummyInfo$iterator.hasNext_0();) {
    labelDummyInfo = castTo(labelDummyInfo$iterator.next_1(), 291);
    labelDummyInfo.leftmostLayerId == labelDummyInfo.rightmostLayerId?$assignLayer(this$static, labelDummyInfo, labelDummyInfo.leftmostLayerId):$assignToWiderLayer(this$static, labelDummyInfo) || (remainingLabels.array[remainingLabels.array.length] = labelDummyInfo , true);
  }
  return remainingLabels;
}

function $process_30(this$static, layeredGraph, monitor){
  var defaultPlacementStrategy, labelDummyInfos, strategy, strategy$array, strategy$array0, strategy$array1, strategy$index, strategy$index0, strategy$index1, strategy$max, strategy$max0, strategy$max1;
  $begin(monitor, 'Label dummy switching', 1);
  defaultPlacementStrategy = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_0)), 206);
  $assignIdsToLayers(layeredGraph);
  labelDummyInfos = $gatherLabelDummyInfos(layeredGraph, defaultPlacementStrategy);
  this$static.layerWidths = initUnidimensionalArray(D_classLit, $intern_69, 23, layeredGraph.layers.array.length, 15, 1);
  for (strategy$array0 = ($clinit_CenterEdgeLabelPlacementStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit, 1), $intern_38, 206, 0, [MEDIAN_LAYER, TAIL_LAYER, HEAD_LAYER, SPACE_EFFICIENT_LAYER, WIDEST_LAYER, CENTER_LAYER])) , strategy$index0 = 0 , strategy$max0 = strategy$array0.length; strategy$index0 < strategy$max0; ++strategy$index0) {
    strategy = strategy$array0[strategy$index0];
    if ((strategy == WIDEST_LAYER || strategy == CENTER_LAYER || strategy == SPACE_EFFICIENT_LAYER) && !castTo($containsEnum(labelDummyInfos.keySet, strategy)?labelDummyInfos.values[strategy.ordinal]:null, 15).isEmpty()) {
      $calculateLayerWidths(this$static, layeredGraph);
      break;
    }
  }
  for (strategy$array1 = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit, 1), $intern_38, 206, 0, [MEDIAN_LAYER, TAIL_LAYER, HEAD_LAYER, SPACE_EFFICIENT_LAYER, WIDEST_LAYER, CENTER_LAYER]) , strategy$index1 = 0 , strategy$max1 = strategy$array1.length; strategy$index1 < strategy$max1; ++strategy$index1) {
    strategy = strategy$array1[strategy$index1];
    strategy == WIDEST_LAYER || strategy == CENTER_LAYER || strategy == SPACE_EFFICIENT_LAYER || $processStrategy(this$static, castTo($containsEnum(labelDummyInfos.keySet, strategy)?labelDummyInfos.values[strategy.ordinal]:null, 15));
  }
  for (strategy$array = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit, 1), $intern_38, 206, 0, [MEDIAN_LAYER, TAIL_LAYER, HEAD_LAYER, SPACE_EFFICIENT_LAYER, WIDEST_LAYER, CENTER_LAYER]) , strategy$index = 0 , strategy$max = strategy$array.length; strategy$index < strategy$max; ++strategy$index) {
    strategy = strategy$array[strategy$index];
    (strategy == WIDEST_LAYER || strategy == CENTER_LAYER || strategy == SPACE_EFFICIENT_LAYER) && $processStrategy(this$static, castTo($containsEnum(labelDummyInfos.keySet, strategy)?labelDummyInfos.values[strategy.ordinal]:null, 15));
  }
  this$static.layerWidths = null;
  $done_0(monitor);
}

function $processStrategy(this$static, labelDummyInfos){
  var labelDummyInfo, labelDummyInfo$iterator, reversed, reversed0, layers, lowerMedian;
  if (labelDummyInfos.isEmpty()) {
    return;
  }
  if (castTo(labelDummyInfos.get_3(0), 291).placementStrategy == ($clinit_CenterEdgeLabelPlacementStrategy() , SPACE_EFFICIENT_LAYER)) {
    $computeSpaceEfficientAssignment(this$static, labelDummyInfos);
  }
   else {
    for (labelDummyInfo$iterator = labelDummyInfos.iterator_0(); labelDummyInfo$iterator.hasNext_0();) {
      labelDummyInfo = castTo(labelDummyInfo$iterator.next_1(), 291);
      switch (labelDummyInfo.placementStrategy.ordinal) {
        case 5:
          $assignLayer(this$static, labelDummyInfo, $findCenterLayerTargetId(this$static, labelDummyInfo));
          break;
        case 0:
          $assignLayer(this$static, labelDummyInfo, (layers = labelDummyInfo.rightmostLayerId - labelDummyInfo.leftmostLayerId + 1 , lowerMedian = (layers - 1) / 2 | 0 , labelDummyInfo.leftmostLayerId + lowerMedian));
          break;
        case 4:
          $assignLayer(this$static, labelDummyInfo, $findWidestLayerTargetId(this$static, labelDummyInfo));
          break;
        case 2:
          $setEndLayerNodeAlignment(labelDummyInfo);
          $assignLayer(this$static, labelDummyInfo, (reversed0 = $isPartOfReversedEdge(labelDummyInfo) , reversed0?labelDummyInfo.leftmostLayerId:labelDummyInfo.rightmostLayerId));
          break;
        case 1:
          $setEndLayerNodeAlignment(labelDummyInfo);
          $assignLayer(this$static, labelDummyInfo, (reversed = $isPartOfReversedEdge(labelDummyInfo) , reversed?labelDummyInfo.rightmostLayerId:labelDummyInfo.leftmostLayerId));
      }
      $doUpdateLongEdgeLabelDummyInfo(labelDummyInfo.labelDummy);
    }
  }
}

function $setEndLayerNodeAlignment(labelDummyInfo){
  var isHeadLabel, isPartOfReversedEdge;
  isHeadLabel = labelDummyInfo.placementStrategy == ($clinit_CenterEdgeLabelPlacementStrategy() , HEAD_LAYER);
  isPartOfReversedEdge = $isPartOfReversedEdge(labelDummyInfo);
  isHeadLabel && !isPartOfReversedEdge || !isHeadLabel && isPartOfReversedEdge?$setProperty_0(labelDummyInfo.labelDummy, ($clinit_LayeredOptions() , ALIGNMENT), ($clinit_Alignment() , RIGHT_4)):$setProperty_0(labelDummyInfo.labelDummy, ($clinit_LayeredOptions() , ALIGNMENT), ($clinit_Alignment() , LEFT_4));
}

function $swapNodes(labelDummy, longEdgeDummy){
  var dummy1LayerPosition, dummy2LayerPosition, edge, edge$index, edge$index0, edge$index1, edge$index2, edge$max, edge$max0, edge$max1, edge$max2, incomingEdges1, incomingEdges2, inputPort1, inputPort2, layer1, layer2, outgoingEdges1, outgoingEdges2, outputPort1, outputPort2;
  layer1 = labelDummy.layer;
  layer2 = longEdgeDummy.layer;
  dummy1LayerPosition = $indexOf_3(layer1.nodes, labelDummy, 0);
  dummy2LayerPosition = $indexOf_3(layer2.nodes, longEdgeDummy, 0);
  inputPort1 = castTo($getPorts(labelDummy, ($clinit_PortType() , INPUT)).iterator_0().next_1(), 11);
  outputPort1 = castTo($getPorts(labelDummy, OUTPUT).iterator_0().next_1(), 11);
  inputPort2 = castTo($getPorts(longEdgeDummy, INPUT).iterator_0().next_1(), 11);
  outputPort2 = castTo($getPorts(longEdgeDummy, OUTPUT).iterator_0().next_1(), 11);
  incomingEdges1 = castTo($toArray_2(inputPort1.incomingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, 1, 0, 1)), 101);
  outgoingEdges1 = castTo($toArray_2(outputPort1.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, 1, 0, 1)), 101);
  incomingEdges2 = castTo($toArray_2(inputPort2.incomingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, 1, 0, 1)), 101);
  outgoingEdges2 = castTo($toArray_2(outputPort2.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, 1, 0, 1)), 101);
  $setLayer(labelDummy, dummy2LayerPosition, layer2);
  for (edge$index0 = 0 , edge$max0 = incomingEdges2.length; edge$index0 < edge$max0; ++edge$index0) {
    edge = incomingEdges2[edge$index0];
    $setTarget_0(edge, inputPort1);
  }
  for (edge$index1 = 0 , edge$max1 = outgoingEdges2.length; edge$index1 < edge$max1; ++edge$index1) {
    edge = outgoingEdges2[edge$index1];
    $setSource_0(edge, outputPort1);
  }
  $setLayer(longEdgeDummy, dummy1LayerPosition, layer1);
  for (edge$index2 = 0 , edge$max2 = incomingEdges1.length; edge$index2 < edge$max2; ++edge$index2) {
    edge = incomingEdges1[edge$index2];
    $setTarget_0(edge, inputPort2);
  }
  for (edge$index = 0 , edge$max = outgoingEdges1.length; edge$index < edge$max; ++edge$index) {
    edge = outgoingEdges1[edge$index];
    $setSource_0(edge, outputPort2);
  }
}

function LabelDummySwitcher(){
  $clinit_LabelDummySwitcher();
}

function lambda$2_2(defaultPlacementStrategy_0, labelDummy_1){
  $clinit_LabelDummySwitcher();
  return new LabelDummySwitcher$LabelDummyInfo(labelDummy_1, defaultPlacementStrategy_0);
}

function lambda$3_2(infos_0, dummyInfo_1){
  $clinit_LabelDummySwitcher();
  return castTo($get_10(infos_0, dummyInfo_1.placementStrategy), 15).add_1(dummyInfo_1);
}

defineClass(1246, 1, $intern_108, LabelDummySwitcher);
_.process = function process_26(layeredGraph, monitor){
  $process_30(this, castTo(layeredGraph, 32), monitor);
}
;
_.layerWidths = null;
var INCLUDE_LABEL;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummySwitcher_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummySwitcher', 1246);
function $gatherLeftLongEdgeDummies(this$static){
  var source;
  source = this$static.labelDummy;
  do {
    source = castTo($next_2($iterator($getIncomingEdges(source))), 16).source.owner;
    source.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && this$static.leftLongEdgeDummies.add_1(source);
  }
   while (source.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE));
  this$static.leftLongEdgeDummies = reverse_0(this$static.leftLongEdgeDummies);
}

function $gatherRightLongEdgeDummies(this$static){
  var target;
  target = this$static.labelDummy;
  do {
    target = castTo($next_2($iterator($getOutgoingEdges(target))), 16).target.owner;
    target.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && $add_4(this$static.rightLongEdgeDummies, target);
  }
   while (target.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE));
}

function $ithDummyNode(this$static, i){
  return i < this$static.leftLongEdgeDummies.size_1()?castTo(this$static.leftLongEdgeDummies.get_3(i), 9):i == this$static.leftLongEdgeDummies.size_1()?this$static.labelDummy:castTo($get_7(this$static.rightLongEdgeDummies, i - this$static.leftLongEdgeDummies.size_1() - 1), 9);
}

function LabelDummySwitcher$LabelDummyInfo(labelDummy, defaultPlacementStrategy){
  var label_0, label$iterator;
  this.leftLongEdgeDummies = new ArrayList;
  this.rightLongEdgeDummies = new ArrayList;
  this.labelDummy = labelDummy;
  this.placementStrategy = defaultPlacementStrategy;
  $gatherLeftLongEdgeDummies(this);
  $gatherRightLongEdgeDummies(this);
  this.leftLongEdgeDummies.isEmpty()?(this.leftmostLayerId = labelDummy.layer.id_0):(this.leftmostLayerId = castTo(this.leftLongEdgeDummies.get_3(0), 9).layer.id_0);
  this.rightLongEdgeDummies.array.length == 0?(this.rightmostLayerId = labelDummy.layer.id_0):(this.rightmostLayerId = castTo($get_7(this.rightLongEdgeDummies, this.rightLongEdgeDummies.array.length - 1), 9).layer.id_0);
  for (label$iterator = castTo($getProperty(labelDummy, ($clinit_InternalProperties_1() , REPRESENTED_LABELS)), 15).iterator_0(); label$iterator.hasNext_0();) {
    label_0 = castTo(label$iterator.next_1(), 70);
    if ($hasProperty(label_0, ($clinit_LayeredOptions() , EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_0))) {
      this.placementStrategy = castTo($getProperty(label_0, EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_0), 206);
      break;
    }
  }
}

defineClass(291, 1, {291:1}, LabelDummySwitcher$LabelDummyInfo);
_.leftmostLayerId = 0;
_.placementStrategy = null;
_.rightmostLayerId = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummySwitcher$LabelDummyInfo_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummySwitcher/LabelDummyInfo', 291);
function LabelDummySwitcher$lambda$0$Type(){
}

defineClass(1247, 1, $intern_11, LabelDummySwitcher$lambda$0$Type);
_.apply_0 = function apply_87(arg0){
  return $clinit_LabelDummySwitcher() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummySwitcher$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummySwitcher/lambda$0$Type', 1247);
function LabelDummySwitcher$lambda$1$Type(){
}

defineClass(1248, 1, $intern_90, LabelDummySwitcher$lambda$1$Type);
_.test_0 = function test_38(arg0){
  return $clinit_LabelDummySwitcher() , castTo(arg0, 9).type_0 == ($clinit_LNode$NodeType() , LABEL);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummySwitcher$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummySwitcher/lambda$1$Type', 1248);
function LabelDummySwitcher$lambda$2$Type(defaultPlacementStrategy_0){
  this.defaultPlacementStrategy_0 = defaultPlacementStrategy_0;
}

defineClass(1249, 1, $intern_11, LabelDummySwitcher$lambda$2$Type);
_.apply_0 = function apply_88(arg0){
  return lambda$2_2(this.defaultPlacementStrategy_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummySwitcher$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummySwitcher/lambda$2$Type', 1249);
function LabelDummySwitcher$lambda$3$Type(infos_0){
  this.infos_0 = infos_0;
}

defineClass(1250, 1, {}, LabelDummySwitcher$lambda$3$Type);
_.accept = function accept_63(arg0){
  lambda$3_2(this.infos_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummySwitcher$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummySwitcher/lambda$3$Type', 1250);
function LabelDummySwitcher$lambda$4$Type(){
}

defineClass(1251, 1, $intern_40, LabelDummySwitcher$lambda$4$Type);
_.equals_0 = function equals_121(other){
  return this === other;
}
;
_.reversed = function reversed_36(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_44(arg0, arg1){
  return $clinit_LabelDummySwitcher() , compare_5(castTo(arg1, 291).labelDummy.size_0.x_0, castTo(arg0, 291).labelDummy.size_0.x_0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelDummySwitcher$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelDummySwitcher/lambda$4$Type', 1251);
function $process_31(layeredGraph, monitor){
  $begin(monitor, 'Label management', 1);
  throwClassCastExceptionUnlessNull($getProperty(layeredGraph, ($clinit_LabelManagementOptions() , LABEL_MANAGER)));
  $done_0(monitor);
}

function LabelManagementProcessor(){
}

defineClass(734, 1, $intern_108, LabelManagementProcessor);
_.process = function process_27(layeredGraph, monitor){
  $process_31(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelManagementProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelManagementProcessor', 734);
function $applyForDummyNodeRunWithSimpleLoops(dummyNodes, defaultSide){
  var currLongEdgeSource, currLongEdgeTarget, currentDummy, currentDummy$iterator, endPort, endPort0, labelDummyRun, prevLongEdgeSource, prevLongEdgeTarget;
  labelDummyRun = newArrayListWithCapacity(dummyNodes.tail - dummyNodes.head & dummyNodes.array.length - 1);
  prevLongEdgeSource = null;
  prevLongEdgeTarget = null;
  for (currentDummy$iterator = new ArrayDeque$IteratorImpl(dummyNodes); currentDummy$iterator.currentIndex != currentDummy$iterator.fence;) {
    currentDummy = castTo($next_9(currentDummy$iterator), 9);
    currLongEdgeSource = (endPort0 = castTo($getProperty(currentDummy, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE)), 11) , !endPort0?null:endPort0.owner);
    currLongEdgeTarget = (endPort = castTo($getProperty(currentDummy, LONG_EDGE_TARGET), 11) , !endPort?null:endPort.owner);
    if (prevLongEdgeSource != currLongEdgeSource || prevLongEdgeTarget != currLongEdgeTarget) {
      $applyLabelSidesToLabelDummyRun(labelDummyRun, defaultSide);
      prevLongEdgeSource = currLongEdgeSource;
      prevLongEdgeTarget = currLongEdgeTarget;
    }
    labelDummyRun.array[labelDummyRun.array.length] = currentDummy;
  }
  $applyLabelSidesToLabelDummyRun(labelDummyRun, defaultSide);
}

function $applyLabelSide(labels, side){
  var label_0, label$iterator;
  for (label$iterator = labels.iterator_0(); label$iterator.hasNext_0();) {
    label_0 = castTo(label$iterator.next_1(), 70);
    $setProperty_0(label_0, ($clinit_InternalProperties_1() , LABEL_SIDE), side);
  }
}

function $applyLabelSide_0(edge, side){
  var label_0, label$iterator;
  for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 70);
    $setProperty_0(label_0, ($clinit_InternalProperties_1() , LABEL_SIDE), side);
  }
}

function $applyLabelSide_1(labelDummy, side){
  var effectiveSide, originEdge, port, port$iterator, portPos, thickness;
  if (labelDummy.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
    effectiveSide = $findFirst($filter(castTo($getProperty(labelDummy, ($clinit_InternalProperties_1() , REPRESENTED_LABELS)), 15).stream(), new Predicate$lambda$0$Type(new LabelSideSelector$lambda$0$Type))).ref == null?($clinit_LabelSide() , INLINE):side;
    $setProperty_0(labelDummy, LABEL_SIDE, effectiveSide);
    if (effectiveSide != ($clinit_LabelSide() , BELOW)) {
      originEdge = castTo($getProperty(labelDummy, ORIGIN_0), 16);
      thickness = checkNotNull_1(castToDouble($getProperty(originEdge, ($clinit_LayeredOptions() , EDGE_THICKNESS_0))));
      portPos = 0;
      if (effectiveSide == ABOVE) {
        portPos = labelDummy.size_0.y_0 - $wnd.Math.ceil(thickness / 2);
      }
       else if (effectiveSide == INLINE) {
        labelDummy.size_0.y_0 -= checkNotNull_1(castToDouble($getProperty($getGraph(labelDummy), SPACING_EDGE_LABEL_0)));
        portPos = (labelDummy.size_0.y_0 - $wnd.Math.ceil(thickness)) / 2;
      }
      for (port$iterator = new ArrayList$1(labelDummy.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_10(port$iterator), 11);
        port.pos.y_0 = portPos;
      }
    }
  }
}

function $applyLabelSidesToLabelDummyRun(labelDummyRun, defaultSide){
  var dummyNode, dummyNode$iterator;
  if (labelDummyRun.array.length != 0) {
    if (labelDummyRun.array.length == 2) {
      $applyLabelSide_1((checkCriticalElementIndex(0, labelDummyRun.array.length) , castTo(labelDummyRun.array[0], 9)), ($clinit_LabelSide() , ABOVE));
      $applyLabelSide_1((checkCriticalElementIndex(1, labelDummyRun.array.length) , castTo(labelDummyRun.array[1], 9)), BELOW);
    }
     else {
      for (dummyNode$iterator = new ArrayList$1(labelDummyRun); dummyNode$iterator.i < dummyNode$iterator.this$01.array.length;) {
        dummyNode = castTo($next_10(dummyNode$iterator), 9);
        $applyLabelSide_1(dummyNode, defaultSide);
      }
    }
    labelDummyRun.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  }
}

function $basedOnDirection(graph, sideForRightwardEdges){
  var edge, edge$iterator, layer, layer$iterator, node, node$iterator, side, incoming, outgoing;
  for (layer$iterator = new ArrayList$1(graph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (node.type_0 == ($clinit_LNode$NodeType() , LABEL)) {
        side = (incoming = castTo($next_2($iterator($getIncomingEdges(node))), 16) , outgoing = castTo($next_2($iterator($getOutgoingEdges(node))), 16) , !checkNotNull_1(castToBoolean($getProperty(incoming, ($clinit_InternalProperties_1() , REVERSED)))) || !checkNotNull_1(castToBoolean($getProperty(outgoing, REVERSED))))?sideForRightwardEdges:$opposite_1(sideForRightwardEdges);
        $applyLabelSide_1(node, side);
      }
      for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        side = checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties_1() , REVERSED))))?$opposite_1(sideForRightwardEdges):sideForRightwardEdges;
        $applyLabelSide_0(edge, side);
      }
    }
  }
}

function $process_32(layeredGraph, monitor){
  var mode;
  mode = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , EDGE_LABELS_SIDE_SELECTION_0)), 266);
  $begin(monitor, 'Label side selection (' + mode + ')', 1);
  switch (mode.ordinal) {
    case 0:
      $sameSide(layeredGraph, ($clinit_LabelSide() , ABOVE));
      break;
    case 1:
      $sameSide(layeredGraph, ($clinit_LabelSide() , BELOW));
      break;
    case 2:
      $basedOnDirection(layeredGraph, ($clinit_LabelSide() , ABOVE));
      break;
    case 3:
      $basedOnDirection(layeredGraph, ($clinit_LabelSide() , BELOW));
      break;
    case 4:
      $smart(layeredGraph, ($clinit_LabelSide() , ABOVE));
      break;
    case 5:
      $smart(layeredGraph, ($clinit_LabelSide() , BELOW));
  }
  $done_0(monitor);
}

function $sameSide(graph, labelSide){
  var edge, edge$iterator, layer, layer$iterator, node, node$iterator;
  for (layer$iterator = new ArrayList$1(graph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      node.type_0 == ($clinit_LNode$NodeType() , LABEL) && $applyLabelSide_1(node, labelSide);
      for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        $applyLabelSide_0(edge, labelSide);
      }
    }
  }
}

function $smart(graph, defaultSide){
  var dummyNodeQueue, labelDummiesInQueue, layer, layer$iterator, node, node$iterator, topGroup;
  dummyNodeQueue = new ArrayDeque;
  for (layer$iterator = new ArrayList$1(graph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    topGroup = true;
    labelDummiesInQueue = 0;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      switch (node.type_0.ordinal) {
        case 4:
          ++labelDummiesInQueue;
        case 1:
          $addLast(dummyNodeQueue, node);
          break;
        case 0:
          $smartForRegularNode(node, defaultSide);
        default:dummyNodeQueue.head == dummyNodeQueue.tail || $smartForConsecutiveDummyNodeRun(dummyNodeQueue, labelDummiesInQueue, topGroup, false, defaultSide);
          topGroup = false;
          labelDummiesInQueue = 0;
      }
    }
    dummyNodeQueue.head == dummyNodeQueue.tail || $smartForConsecutiveDummyNodeRun(dummyNodeQueue, labelDummiesInQueue, topGroup, true, defaultSide);
  }
}

function $smartForConsecutiveDummyNodeRun(dummyNodes, labelDummyCount, topGroup, bottomGroup, defaultSide){
  if (topGroup && (!bottomGroup || (dummyNodes.tail - dummyNodes.head & dummyNodes.array.length - 1) > 1) && labelDummyCount == 1 && castTo(dummyNodes.array[dummyNodes.head], 9).type_0 == ($clinit_LNode$NodeType() , LABEL)) {
    $applyLabelSide_1(castTo(dummyNodes.array[dummyNodes.head], 9), ($clinit_LabelSide() , ABOVE));
  }
   else if (bottomGroup && (!topGroup || (dummyNodes.tail - dummyNodes.head & dummyNodes.array.length - 1) > 1) && labelDummyCount == 1 && castTo(dummyNodes.array[dummyNodes.tail - 1 & dummyNodes.array.length - 1], 9).type_0 == ($clinit_LNode$NodeType() , LABEL)) {
    $applyLabelSide_1(castTo(dummyNodes.array[dummyNodes.tail - 1 & dummyNodes.array.length - 1], 9), ($clinit_LabelSide() , BELOW));
  }
   else if ((dummyNodes.tail - dummyNodes.head & dummyNodes.array.length - 1) == 2) {
    $applyLabelSide_1(castTo($pollFirst(dummyNodes), 9), ($clinit_LabelSide() , ABOVE));
    $applyLabelSide_1(castTo($pollFirst(dummyNodes), 9), BELOW);
  }
   else {
    $applyForDummyNodeRunWithSimpleLoops(dummyNodes, defaultSide);
  }
  $clear_3(dummyNodes);
}

function $smartForRegularNode(node, defaultSide){
  var currentPortSide, endLabelQueue, port, port$iterator, portEndLabels;
  endLabelQueue = new ArrayDeque_0(node.ports.array.length);
  currentPortSide = null;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    if (port.side != currentPortSide) {
      endLabelQueue.head == endLabelQueue.tail || $smartForRegularNodePortEndLabels(endLabelQueue, currentPortSide, defaultSide);
      $clear_3(endLabelQueue);
      currentPortSide = port.side;
    }
    portEndLabels = gatherLabels(port);
    !!portEndLabels && ($addLast(endLabelQueue, portEndLabels) , true);
  }
  endLabelQueue.head == endLabelQueue.tail || $smartForRegularNodePortEndLabels(endLabelQueue, currentPortSide, defaultSide);
}

function $smartForRegularNodePortEndLabels(endLabelQueue, portSide, defaultSide){
  var labelList, labelList$iterator;
  if ((endLabelQueue.tail - endLabelQueue.head & endLabelQueue.array.length - 1) == 2) {
    if (portSide == ($clinit_PortSide() , NORTH_1) || portSide == EAST_1) {
      $applyLabelSide(castTo($pollFirst(endLabelQueue), 15), ($clinit_LabelSide() , ABOVE));
      $applyLabelSide(castTo($pollFirst(endLabelQueue), 15), BELOW);
    }
     else {
      $applyLabelSide(castTo($pollFirst(endLabelQueue), 15), ($clinit_LabelSide() , BELOW));
      $applyLabelSide(castTo($pollFirst(endLabelQueue), 15), ABOVE);
    }
  }
   else {
    for (labelList$iterator = new ArrayDeque$IteratorImpl(endLabelQueue); labelList$iterator.currentIndex != labelList$iterator.fence;) {
      labelList = castTo($next_9(labelList$iterator), 15);
      $applyLabelSide(labelList, defaultSide);
    }
  }
}

function LabelSideSelector(){
}

defineClass(1429, 1, $intern_108, LabelSideSelector);
_.process = function process_28(layeredGraph, monitor){
  $process_32(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelSideSelector_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelSideSelector', 1429);
function LabelSideSelector$lambda$0$Type(){
}

defineClass(1430, 1, $intern_90, LabelSideSelector$lambda$0$Type);
_.test_0 = function test_39(arg0){
  return checkNotNull_1(castToBoolean($getProperty(castTo(arg0, 70), ($clinit_LayeredOptions() , EDGE_LABELS_INLINE))));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LabelSideSelector$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LabelSideSelector/lambda$0$Type', 1430);
function $isAcceptableIncomingEdge(edge){
  var sourceNode, targetNode;
  sourceNode = edge.source.owner;
  targetNode = edge.target.owner;
  if (sourceNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) && targetNode.type_0 == EXTERNAL_PORT) {
    return true;
  }
  if (maskUndefined($getProperty(sourceNode, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0))) === maskUndefined(($clinit_LayerConstraint() , FIRST_SEPARATE))) {
    return true;
  }
  return sourceNode.type_0 == LABEL;
}

function $isAcceptableOutgoingEdge(edge){
  var sourceNode, targetNode;
  sourceNode = edge.source.owner;
  targetNode = edge.target.owner;
  if (sourceNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) && targetNode.type_0 == EXTERNAL_PORT) {
    return true;
  }
  if (maskUndefined($getProperty(targetNode, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0))) === maskUndefined(($clinit_LayerConstraint() , LAST_SEPARATE))) {
    return true;
  }
  return targetNode.type_0 == LABEL;
}

function $moveLabelsToLabelLayer(node, incoming, labelLayer){
  var edge, edge$iterator, possibleLableDummy;
  for (edge$iterator = $iterator(incoming?$getIncomingEdges(node):$getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 16);
    possibleLableDummy = incoming?edge.source.owner:edge.target.owner;
    possibleLableDummy.type_0 == ($clinit_LNode$NodeType() , LABEL) && $setLayer_0(possibleLableDummy, labelLayer);
  }
}

function $process_33(layeredGraph, monitor){
  var constraint, edge, edge$iterator, firstLabelLayer, firstLayer, lastLabelLayer, lastLayer, layer, layer$iterator, layers, moveAllowed, node, node$index, node$iterator, node$max, nodes, sndFirstLayer, sndLastLayer, veryFirstLayer, veryLastLayer;
  $begin(monitor, 'Layer constraint application', 1);
  layers = layeredGraph.layers;
  if (layers.array.length == 0) {
    $done_0(monitor);
    return;
  }
  firstLayer = (checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 25));
  lastLayer = castTo($get_7(layers, layers.array.length - 1), 25);
  veryFirstLayer = new Layer(layeredGraph);
  veryLastLayer = new Layer(layeredGraph);
  firstLabelLayer = new Layer(layeredGraph);
  lastLabelLayer = new Layer(layeredGraph);
  for (layer$iterator = new ArrayList$1(layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    nodes = castTo($toArray_2(layer.nodes, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, layer.nodes.array.length, 0, 1)), 125);
    for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {
      node = nodes[node$index];
      constraint = castTo($getProperty(node, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0)), 183);
      switch (constraint.ordinal) {
        case 1:
          $setLayer_0(node, firstLayer);
          $throwUpUnlessNoIncomingEdges(node, true);
          $moveLabelsToLabelLayer(node, true, firstLabelLayer);
          break;
        case 2:
          $setLayer_0(node, veryFirstLayer);
          $throwUpUnlessNoIncomingEdges(node, false);
          break;
        case 3:
          $setLayer_0(node, lastLayer);
          $throwUpUnlessNoOutgoingEdges(node, true);
          $moveLabelsToLabelLayer(node, false, lastLabelLayer);
          break;
        case 4:
          $setLayer_0(node, veryLastLayer);
          $throwUpUnlessNoOutgoingEdges(node, false);
      }
    }
  }
  if (layers.array.length >= 2) {
    moveAllowed = true;
    sndFirstLayer = (checkCriticalElementIndex(1, layers.array.length) , castTo(layers.array[1], 25));
    for (node$iterator = new ArrayList$1(firstLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (maskUndefined($getProperty(node, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0))) === maskUndefined(($clinit_LayerConstraint() , NONE_4))) {
        moveAllowed = false;
        break;
      }
      for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        if (edge.target.owner.layer == sndFirstLayer) {
          moveAllowed = false;
          break;
        }
      }
      if (!moveAllowed) {
        break;
      }
    }
    if (moveAllowed) {
      nodes = castTo($toArray_2(firstLayer.nodes, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, firstLayer.nodes.array.length, 0, 1)), 125);
      for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {
        node = nodes[node$index];
        $setLayer_0(node, sndFirstLayer);
      }
      $remove_13(layers, firstLayer);
    }
  }
  if (layers.array.length >= 2) {
    moveAllowed = true;
    sndLastLayer = castTo($get_7(layers, layers.array.length - 2), 25);
    for (node$iterator = new ArrayList$1(lastLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (maskUndefined($getProperty(node, ($clinit_LayeredOptions() , LAYERING_LAYER_CONSTRAINT_0))) === maskUndefined(($clinit_LayerConstraint() , NONE_4))) {
        moveAllowed = false;
        break;
      }
      for (edge$iterator = $iterator($getIncomingEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        if (edge.source.owner.layer == sndLastLayer) {
          moveAllowed = false;
          break;
        }
      }
      if (!moveAllowed) {
        break;
      }
    }
    if (moveAllowed) {
      nodes = castTo($toArray_2(lastLayer.nodes, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, lastLayer.nodes.array.length, 0, 1)), 125);
      for (node$index = 0 , node$max = nodes.length; node$index < node$max; ++node$index) {
        node = nodes[node$index];
        $setLayer_0(node, sndLastLayer);
      }
      $remove_13(layers, lastLayer);
    }
  }
  layers.array.length == 1 && (checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 25)).nodes.array.length == 0 && $remove_12(layers, 0);
  firstLabelLayer.nodes.array.length == 0 || (checkCriticalPositionIndex(0, layers.array.length) , insertTo(layers.array, 0, firstLabelLayer));
  veryFirstLayer.nodes.array.length == 0 || (checkCriticalPositionIndex(0, layers.array.length) , insertTo(layers.array, 0, veryFirstLayer));
  lastLabelLayer.nodes.array.length == 0 || (layers.array[layers.array.length] = lastLabelLayer , true);
  veryLastLayer.nodes.array.length == 0 || (layers.array[layers.array.length] = veryLastLayer , true);
  $done_0(monitor);
}

function $throwUpUnlessNoIncomingEdges(node, allowFromFirstSeparate){
  var incoming, incoming$iterator, name_0, port, port$iterator;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    for (incoming$iterator = new ArrayList$1(port.incomingEdges); incoming$iterator.i < incoming$iterator.this$01.array.length;) {
      incoming = castTo($next_10(incoming$iterator), 16);
      if (!$isAcceptableIncomingEdge(incoming)) {
        if (allowFromFirstSeparate) {
          throw toJs(new UnsupportedConfigurationException_0((name_0 = $getName_0(node) , "Node '" + (name_0 == null?'' + node.id_0:name_0) + "' has its layer constraint set to FIRST, but has at least one incoming edge that " + ' does not come from a FIRST_SEPARATE node. That must not happen.')));
        }
         else {
          throw toJs(new UnsupportedConfigurationException_0((name_0 = $getName_0(node) , "Node '" + (name_0 == null?'' + node.id_0:name_0) + "' has its layer constraint set to FIRST_SEPARATE, but has at least one incoming " + 'edge. FIRST_SEPARATE nodes must not have incoming edges.')));
        }
      }
    }
  }
}

function $throwUpUnlessNoOutgoingEdges(node, allowToLastSeparate){
  var name_0, outgoing, outgoing$iterator, port, port$iterator;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    for (outgoing$iterator = new ArrayList$1(port.outgoingEdges); outgoing$iterator.i < outgoing$iterator.this$01.array.length;) {
      outgoing = castTo($next_10(outgoing$iterator), 16);
      if (!$isAcceptableOutgoingEdge(outgoing)) {
        if (allowToLastSeparate) {
          throw toJs(new UnsupportedConfigurationException_0((name_0 = $getName_0(node) , "Node '" + (name_0 == null?'' + node.id_0:name_0) + "' has its layer constraint set to LAST, but has at least one outgoing edge that " + ' does not go to a LAST_SEPARATE node. That must not happen.')));
        }
         else {
          throw toJs(new UnsupportedConfigurationException_0((name_0 = $getName_0(node) , "Node '" + (name_0 == null?'' + node.id_0:name_0) + "' has its layer constraint set to LAST_SEPARATE, but has at least one outgoing " + 'edge. LAST_SEPARATE nodes must not have outgoing edges.')));
        }
      }
    }
  }
}

function LayerConstraintProcessor(){
}

defineClass(1431, 1, $intern_108, LayerConstraintProcessor);
_.process = function process_29(layeredGraph, monitor){
  $process_33(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LayerConstraintProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LayerConstraintProcessor', 1431);
function $process_34(layeredGraph, monitor){
  var bottom, firstNode, lastNode, layer, layer$iterator, layerSize, maxY, minY, node, node$iterator, nodeMargin, nodeSize, top_0;
  $begin(monitor, 'Layer size calculation', 1);
  minY = $intern_62;
  maxY = $intern_63;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    layerSize = layer.size_0;
    layerSize.x_0 = 0;
    layerSize.y_0 = 0;
    if (layer.nodes.array.length == 0) {
      continue;
    }
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      nodeSize = node.size_0;
      nodeMargin = node.margin;
      layerSize.x_0 = $wnd.Math.max(layerSize.x_0, nodeSize.x_0 + nodeMargin.left + nodeMargin.right);
    }
    firstNode = castTo($get_7(layer.nodes, 0), 9);
    top_0 = firstNode.pos.y_0 - firstNode.margin.top_0;
    lastNode = castTo($get_7(layer.nodes, layer.nodes.array.length - 1), 9);
    bottom = lastNode.pos.y_0 + lastNode.size_0.y_0 + lastNode.margin.bottom;
    layerSize.y_0 = bottom - top_0;
    minY = $wnd.Math.min(minY, top_0);
    maxY = $wnd.Math.max(maxY, bottom);
  }
  layeredGraph.size_0.y_0 = maxY - minY;
  layeredGraph.offset.y_0 -= minY;
  $done_0(monitor);
}

function LayerSizeAndGraphHeightCalculator(){
}

defineClass(1432, 1, $intern_108, LayerSizeAndGraphHeightCalculator);
_.process = function process_30(layeredGraph, monitor){
  $process_34(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LayerSizeAndGraphHeightCalculator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LayerSizeAndGraphHeightCalculator', 1432);
function $process_35(layeredGraph, monitor){
  var addUnnecessaryBendpoints, layer, layer$iterator, node, nodeIterator;
  $begin(monitor, 'Edge joining', 1);
  addUnnecessaryBendpoints = checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_LayeredOptions() , UNNECESSARY_BENDPOINTS_0))));
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    nodeIterator = new AbstractList$ListIteratorImpl(layer.nodes, 0);
    while (nodeIterator.i < nodeIterator.this$01_0.size_1()) {
      node = (checkCriticalElement(nodeIterator.i < nodeIterator.this$01_0.size_1()) , castTo(nodeIterator.this$01_0.get_3(nodeIterator.last = nodeIterator.i++), 9));
      if (node.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
        joinAt(node, addUnnecessaryBendpoints);
        $remove_9(nodeIterator);
      }
    }
  }
  $done_0(monitor);
}

function LongEdgeJoiner(){
}

function joinAt(longEdgeDummy, addUnnecessaryBendpoints){
  var bendPoint, bendPoint$iterator, droppedEdge, droppedEdgeListIndex, droppedJunctionsPoints, edgeCount, inputPortEdges, jp, jp$iterator, label_0, label$iterator, outputPortEdges, survivingBendPoints, survivingEdge, survivingJunctionPoints, survivingLabels, targetIncomingEdges, unnecessaryBendpoint;
  inputPortEdges = castTo($getPorts_1(longEdgeDummy, ($clinit_PortSide() , WEST_1)).iterator_0().next_1(), 11).incomingEdges;
  outputPortEdges = castTo($getPorts_1(longEdgeDummy, EAST_1).iterator_0().next_1(), 11).outgoingEdges;
  edgeCount = inputPortEdges.array.length;
  unnecessaryBendpoint = $getAbsoluteAnchor(castTo($get_7(longEdgeDummy.ports, 0), 11));
  while (edgeCount-- > 0) {
    survivingEdge = (checkCriticalElementIndex(0, inputPortEdges.array.length) , castTo(inputPortEdges.array[0], 16));
    droppedEdge = (checkCriticalElementIndex(0, outputPortEdges.array.length) , castTo(outputPortEdges.array[0], 16));
    targetIncomingEdges = droppedEdge.target.incomingEdges;
    droppedEdgeListIndex = $indexOf_3(targetIncomingEdges, droppedEdge, 0);
    $setTargetAndInsertAtIndex(survivingEdge, droppedEdge.target, droppedEdgeListIndex);
    $setSource_0(droppedEdge, null);
    $setTarget_0(droppedEdge, null);
    survivingBendPoints = survivingEdge.bendPoints;
    addUnnecessaryBendpoints && $add_7(survivingBendPoints, new KVector_2(unnecessaryBendpoint));
    for (bendPoint$iterator = $listIterator_1(droppedEdge.bendPoints, 0); bendPoint$iterator.currentNode != bendPoint$iterator.this$01.tail;) {
      bendPoint = castTo($next_13(bendPoint$iterator), 8);
      $add_7(survivingBendPoints, new KVector_2(bendPoint));
    }
    survivingLabels = survivingEdge.labels;
    for (label$iterator = new ArrayList$1(droppedEdge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 70);
      survivingLabels.array[survivingLabels.array.length] = label_0;
    }
    survivingJunctionPoints = castTo($getProperty(survivingEdge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
    droppedJunctionsPoints = castTo($getProperty(droppedEdge, JUNCTION_POINTS), 74);
    if (droppedJunctionsPoints) {
      if (!survivingJunctionPoints) {
        survivingJunctionPoints = new KVectorChain;
        $setProperty_0(survivingEdge, JUNCTION_POINTS, survivingJunctionPoints);
      }
      for (jp$iterator = $listIterator_1(droppedJunctionsPoints, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
        jp = castTo($next_13(jp$iterator), 8);
        $add_7(survivingJunctionPoints, new KVector_2(jp));
      }
    }
  }
}

defineClass(1433, 1, $intern_108, LongEdgeJoiner);
_.process = function process_31(layeredGraph, monitor){
  $process_35(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LongEdgeJoiner_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LongEdgeJoiner', 1433);
function $process_36(layeredGraph, monitor){
  var edge, edge$iterator, layer, layerIter, nextLayer, node, node$iterator, port, port$iterator, targetLayer, targetPort, dummyNode;
  $begin(monitor, 'Edge splitting', 1);
  if (layeredGraph.layers.array.length <= 2) {
    $done_0(monitor);
    return;
  }
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  nextLayer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_3(layerIter.last = layerIter.i++), 25));
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = nextLayer;
    nextLayer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_3(layerIter.last = layerIter.i++), 25));
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_10(port$iterator), 11);
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator), 16);
          targetPort = edge.target;
          targetLayer = targetPort.owner.layer;
          targetLayer != layer && targetLayer != nextLayer && splitEdge(edge, (dummyNode = new LNode(layeredGraph) , $setType(dummyNode, ($clinit_LNode$NodeType() , LONG_EDGE)) , $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0), edge) , $setProperty_0(dummyNode, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS)) , $setLayer_0(dummyNode, nextLayer) , dummyNode));
        }
      }
    }
  }
  $done_0(monitor);
}

function LongEdgeSplitter(){
}

function moveHeadLabels(oldEdge, newEdge){
  var label_0, labelIterator, labelPlacement;
  labelIterator = new AbstractList$ListIteratorImpl(oldEdge.labels, 0);
  while (labelIterator.i < labelIterator.this$01_0.size_1()) {
    label_0 = (checkCriticalElement(labelIterator.i < labelIterator.this$01_0.size_1()) , castTo(labelIterator.this$01_0.get_3(labelIterator.last = labelIterator.i++), 70));
    labelPlacement = castTo($getProperty(label_0, ($clinit_LayeredOptions() , EDGE_LABELS_PLACEMENT)), 236);
    if (labelPlacement == ($clinit_EdgeLabelPlacement() , HEAD)) {
      $remove_9(labelIterator);
      $add_4(newEdge.labels, label_0);
    }
  }
}

function setDummyNodeProperties(dummyNode, inEdge, outEdge){
  var inEdgeSourceNode, outEdgeTargetNode;
  inEdgeSourceNode = inEdge.source.owner;
  outEdgeTargetNode = outEdge.target.owner;
  if (inEdgeSourceNode.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), castTo($getProperty(inEdgeSourceNode, LONG_EDGE_SOURCE), 11));
    $setProperty_0(dummyNode, LONG_EDGE_TARGET, castTo($getProperty(inEdgeSourceNode, LONG_EDGE_TARGET), 11));
    $setProperty_0(dummyNode, LONG_EDGE_HAS_LABEL_DUMMIES, castToBoolean($getProperty(inEdgeSourceNode, LONG_EDGE_HAS_LABEL_DUMMIES)));
  }
   else if (inEdgeSourceNode.type_0 == LABEL) {
    $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), castTo($getProperty(inEdgeSourceNode, LONG_EDGE_SOURCE), 11));
    $setProperty_0(dummyNode, LONG_EDGE_TARGET, castTo($getProperty(inEdgeSourceNode, LONG_EDGE_TARGET), 11));
    $setProperty_0(dummyNode, LONG_EDGE_HAS_LABEL_DUMMIES, ($clinit_Boolean() , $clinit_Boolean() , true));
  }
   else if (outEdgeTargetNode.type_0 == LABEL) {
    $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), castTo($getProperty(outEdgeTargetNode, LONG_EDGE_SOURCE), 11));
    $setProperty_0(dummyNode, LONG_EDGE_TARGET, castTo($getProperty(outEdgeTargetNode, LONG_EDGE_TARGET), 11));
    $setProperty_0(dummyNode, LONG_EDGE_HAS_LABEL_DUMMIES, ($clinit_Boolean() , $clinit_Boolean() , true));
  }
   else {
    $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), inEdge.source);
    $setProperty_0(dummyNode, LONG_EDGE_TARGET, outEdge.target);
  }
}

function splitEdge(edge, dummyNode){
  var dummyEdge, dummyInput, dummyOutput, oldEdgeTarget, portPos, thickness;
  oldEdgeTarget = edge.target;
  thickness = checkNotNull_1(castToDouble($getProperty(edge, ($clinit_LayeredOptions() , EDGE_THICKNESS_0))));
  if (thickness < 0) {
    thickness = 0;
    $setProperty_0(edge, EDGE_THICKNESS_0, thickness);
  }
  dummyNode.size_0.y_0 = thickness;
  portPos = $wnd.Math.floor(thickness / 2);
  dummyInput = new LPort;
  $setSide(dummyInput, ($clinit_PortSide() , WEST_1));
  $setNode(dummyInput, dummyNode);
  dummyInput.pos.y_0 = portPos;
  dummyOutput = new LPort;
  $setSide(dummyOutput, EAST_1);
  $setNode(dummyOutput, dummyNode);
  dummyOutput.pos.y_0 = portPos;
  $setTarget_0(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty_0(dummyEdge, JUNCTION_POINTS, null);
  $setSource_0(dummyEdge, dummyOutput);
  $setTarget_0(dummyEdge, oldEdgeTarget);
  setDummyNodeProperties(dummyNode, edge, dummyEdge);
  moveHeadLabels(edge, dummyEdge);
  return dummyEdge;
}

defineClass(1434, 1, $intern_108, LongEdgeSplitter);
_.process = function process_32(layeredGraph, monitor){
  $process_36(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_LongEdgeSplitter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'LongEdgeSplitter', 1434);
function $process_37(layeredGraph, monitor){
  var layer, layer$iterator, node, node$iterator, nodeNodeSpacing, nodeMargin, selfLoopMargin;
  $begin(monitor, 'Node margin calculation', 1);
  $process($excludeEdgeHeadTailLabels(new NodeMarginCalculator(new LGraphAdapters$LGraphAdapter(layeredGraph, false, new LGraphAdapters$lambda$0$Type))));
  nodeNodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      $processComments(node, nodeNodeSpacing);
      nodeMargin = node.margin;
      selfLoopMargin = castTo($getProperty(node, ($clinit_InternalProperties_1() , SPLINE_SELF_LOOP_MARGINS)), 137);
      nodeMargin.left = $wnd.Math.max(nodeMargin.left, selfLoopMargin.left);
      nodeMargin.right = $wnd.Math.max(nodeMargin.right, selfLoopMargin.right);
      nodeMargin.bottom = $wnd.Math.max(nodeMargin.bottom, selfLoopMargin.bottom);
      nodeMargin.top_0 = $wnd.Math.max(nodeMargin.top_0, selfLoopMargin.top_0);
    }
  }
  $done_0(monitor);
}

function $processComments(node, spacing){
  var bottomBoxes, bottomWidth, commentBox, commentBox$iterator, margin, maxCommentWidth, maxHeight, protrusion, topBoxes, topWidth;
  margin = node.margin;
  topBoxes = castTo($getProperty(node, ($clinit_InternalProperties_1() , TOP_COMMENTS)), 15);
  topWidth = 0;
  if (topBoxes) {
    maxHeight = 0;
    for (commentBox$iterator = topBoxes.iterator_0(); commentBox$iterator.hasNext_0();) {
      commentBox = castTo(commentBox$iterator.next_1(), 9);
      maxHeight = $wnd.Math.max(maxHeight, commentBox.size_0.y_0);
      topWidth += commentBox.size_0.x_0;
    }
    topWidth += spacing / 2 * (topBoxes.size_1() - 1);
    margin.top_0 += maxHeight + spacing;
  }
  bottomBoxes = castTo($getProperty(node, BOTTOM_COMMENTS), 15);
  bottomWidth = 0;
  if (bottomBoxes) {
    maxHeight = 0;
    for (commentBox$iterator = bottomBoxes.iterator_0(); commentBox$iterator.hasNext_0();) {
      commentBox = castTo(commentBox$iterator.next_1(), 9);
      maxHeight = $wnd.Math.max(maxHeight, commentBox.size_0.y_0);
      bottomWidth += commentBox.size_0.x_0;
    }
    bottomWidth += spacing / 2 * (bottomBoxes.size_1() - 1);
    margin.bottom += maxHeight + spacing;
  }
  maxCommentWidth = $wnd.Math.max(topWidth, bottomWidth);
  if (maxCommentWidth > node.size_0.x_0) {
    protrusion = (maxCommentWidth - node.size_0.x_0) / 2;
    margin.left = $wnd.Math.max(margin.left, protrusion);
    margin.right = $wnd.Math.max(margin.right, protrusion);
  }
}

function NodeMarginCalculator_0(){
}

defineClass(1435, 1, $intern_108, NodeMarginCalculator_0);
_.process = function process_33(layeredGraph, monitor){
  $process_37(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_NodeMarginCalculator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'NodeMarginCalculator', 1435);
function $precalculateAndSetInformation(this$static){
  var dummyBaggage, inDegree, incoming, layer, layer$iterator, layer$iterator0, layerID, layerSize, layerSizePixel, node, node$iterator, nodeID, nodesNdummies, outDegree, outcoming;
  this$static.nodeSizeAffix = checkNotNull_1(castToDouble($getProperty(this$static.masterGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
  this$static.dummySize = checkNotNull_1(castToDouble($getProperty(this$static.masterGraph, SPACING_EDGE_NODE_BETWEEN_LAYERS_0)));
  this$static.maxHeight = this$static.masterGraph.layers.array.length;
  layerID = this$static.maxHeight - 1;
  nodeID = 0;
  this$static.maxWidth = 0;
  this$static.maxWidthPixel = 0;
  this$static.currentWidth = newArrayList_1(initUnidimensionalArray(Ljava_lang_Integer_2_classLit, $intern_33, 21, this$static.maxHeight, 0, 1));
  this$static.currentWidthPixel = newArrayList_1(initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_33, 323, this$static.maxHeight, 7, 1));
  for (layer$iterator0 = new ArrayList$1(this$static.masterGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator0), 25);
    layer.id_0 = layerID;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      node.id_0 = nodeID;
      ++nodeID;
    }
    --layerID;
  }
  this$static.layers = initUnidimensionalArray(I_classLit, $intern_49, 23, nodeID, 15, 1);
  this$static.degreeDiff = initMultidimensionalArray(I_classLit, [$intern_33, $intern_49], [40, 23], 15, [nodeID, 3], 2);
  this$static.nodes = new ArrayList;
  this$static.nodesWithIncomingEdges = new ArrayList;
  dummyBaggage = 0;
  this$static.dummyNodeCount = 0;
  for (layer$iterator = new ArrayList$1(this$static.masterGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    layerID = layer.id_0;
    incoming = 0;
    outcoming = 0;
    layerSize = layer.nodes.array.length;
    layerSizePixel = 0;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      nodeID = node.id_0;
      this$static.layers[nodeID] = node.layer.id_0;
      layerSizePixel += node.size_0.y_0 + this$static.nodeSizeAffix;
      inDegree = size_15($getIncomingEdges(node));
      outDegree = size_15($getOutgoingEdges(node));
      this$static.degreeDiff[nodeID][0] = outDegree - inDegree;
      this$static.degreeDiff[nodeID][1] = inDegree;
      this$static.degreeDiff[nodeID][2] = outDegree;
      incoming += inDegree;
      outcoming += outDegree;
      inDegree > 0 && $add_4(this$static.nodesWithIncomingEdges, node);
      $add_4(this$static.nodes, node);
    }
    dummyBaggage -= incoming;
    nodesNdummies = layerSize + dummyBaggage;
    layerSizePixel += dummyBaggage * this$static.dummySize;
    $set_1(this$static.currentWidth, layerID, valueOf_4(nodesNdummies));
    $set_1(this$static.currentWidthPixel, layerID, layerSizePixel);
    this$static.maxWidth = max_1(this$static.maxWidth, nodesNdummies);
    this$static.maxWidthPixel = $wnd.Math.max(this$static.maxWidthPixel, layerSizePixel);
    this$static.dummyNodeCount += dummyBaggage;
    dummyBaggage += outcoming;
  }
}

function $process_38(this$static, layeredGraph, progressMonitor){
  var donna, donna$iterator, funFunction, martha, martha$iterator, newMaxWidth, newMaxWidthPixel, promoteUntil, promoteUntilD, promoteUntilN;
  $begin(progressMonitor, 'Node promotion heuristic', 1);
  this$static.masterGraph = layeredGraph;
  $precalculateAndSetInformation(this$static);
  this$static.promotionStrategy = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , LAYERING_NODE_PROMOTION_STRATEGY_0)), 251);
  promoteUntil = castTo($getProperty(this$static.masterGraph, LAYERING_NODE_PROMOTION_MAX_ITERATIONS_0), 21).value_0;
  funFunction = new NodePromotion$lambda$0$Type;
  switch (this$static.promotionStrategy.ordinal) {
    case 2:
    case 1:
      $promotionMagic(this$static, funFunction);
      break;
    case 3:
      this$static.promotionStrategy = ($clinit_NodePromotionStrategy() , NO_BOUNDARY);
      $promotionMagic(this$static, funFunction);
      newMaxWidth = 0;
      for (martha$iterator = new ArrayList$1(this$static.currentWidth); martha$iterator.i < martha$iterator.this$01.array.length;) {
        martha = castTo($next_10(martha$iterator), 21);
        newMaxWidth = max_1(newMaxWidth, martha.value_0);
      }

      if (newMaxWidth > this$static.maxWidth) {
        this$static.promotionStrategy = NIKOLOV;
        $promotionMagic(this$static, funFunction);
      }

      break;
    case 4:
      this$static.promotionStrategy = ($clinit_NodePromotionStrategy() , NO_BOUNDARY);
      $promotionMagic(this$static, funFunction);
      newMaxWidthPixel = 0;
      for (donna$iterator = new ArrayList$1(this$static.currentWidthPixel); donna$iterator.i < donna$iterator.this$01.array.length;) {
        donna = castToDouble($next_10(donna$iterator));
        newMaxWidthPixel = $wnd.Math.max(newMaxWidthPixel, (checkCriticalNotNull(donna) , donna));
      }

      if (newMaxWidthPixel > this$static.maxWidthPixel) {
        this$static.promotionStrategy = NIKOLOV_PIXEL;
        $promotionMagic(this$static, funFunction);
      }

      break;
    case 6:
      promoteUntilN = round_int($wnd.Math.ceil(this$static.layers.length * promoteUntil / 100));
      $promotionMagic(this$static, new NodePromotion$lambda$1$Type(promoteUntilN));
      break;
    case 5:
      promoteUntilD = round_int($wnd.Math.ceil(this$static.dummyNodeCount * promoteUntil / 100));
      $promotionMagic(this$static, new NodePromotion$lambda$2$Type(promoteUntilD));
      break;
    default:$promotionMagic(this$static, funFunction);
  }
  $setNewLayering(this$static, layeredGraph);
  $done_0(progressMonitor);
}

function $promoteNode(this$static, node){
  var dummiesBuilt, dummiesReduced, dummydiff, edge, edge$iterator, masterNode, maxWidthNotExceeded, nodeLayerPos, nodeSize, promotion;
  maxWidthNotExceeded = true;
  dummydiff = 0;
  nodeLayerPos = this$static.layers[node.id_0];
  nodeSize = node.size_0.y_0 + this$static.nodeSizeAffix;
  dummiesBuilt = this$static.degreeDiff[node.id_0][2];
  $set_1(this$static.currentWidth, nodeLayerPos, valueOf_4(castTo($get_7(this$static.currentWidth, nodeLayerPos), 21).value_0 - 1 + dummiesBuilt));
  $set_1(this$static.currentWidthPixel, nodeLayerPos, checkNotNull_1(castToDouble($get_7(this$static.currentWidthPixel, nodeLayerPos))) - nodeSize + dummiesBuilt * this$static.dummySize);
  ++nodeLayerPos;
  if (nodeLayerPos >= this$static.maxHeight) {
    ++this$static.maxHeight;
    $add_4(this$static.currentWidth, valueOf_4(1));
    $add_4(this$static.currentWidthPixel, nodeSize);
  }
   else {
    dummiesReduced = this$static.degreeDiff[node.id_0][1];
    $set_1(this$static.currentWidth, nodeLayerPos, valueOf_4(castTo($get_7(this$static.currentWidth, nodeLayerPos), 21).value_0 + 1 - dummiesReduced));
    $set_1(this$static.currentWidthPixel, nodeLayerPos, checkNotNull_1(castToDouble($get_7(this$static.currentWidthPixel, nodeLayerPos))) + nodeSize - dummiesReduced * this$static.dummySize);
  }
  (this$static.promotionStrategy == ($clinit_NodePromotionStrategy() , NIKOLOV) && (castTo($get_7(this$static.currentWidth, nodeLayerPos), 21).value_0 > this$static.maxWidth || castTo($get_7(this$static.currentWidth, nodeLayerPos - 1), 21).value_0 > this$static.maxWidth) || this$static.promotionStrategy == NIKOLOV_PIXEL && (checkNotNull_1(castToDouble($get_7(this$static.currentWidthPixel, nodeLayerPos))) > this$static.maxWidthPixel || checkNotNull_1(castToDouble($get_7(this$static.currentWidthPixel, nodeLayerPos - 1))) > this$static.maxWidthPixel)) && (maxWidthNotExceeded = false);
  for (edge$iterator = $iterator($getIncomingEdges(node)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 16);
    masterNode = edge.source.owner;
    if (this$static.layers[masterNode.id_0] == nodeLayerPos) {
      promotion = $promoteNode(this$static, masterNode);
      dummydiff = dummydiff + castTo(promotion.first, 21).value_0;
      maxWidthNotExceeded = maxWidthNotExceeded && checkNotNull_1(castToBoolean(promotion.second));
    }
  }
  this$static.layers[node.id_0] = nodeLayerPos;
  dummydiff = dummydiff + this$static.degreeDiff[node.id_0][0];
  return new Pair(valueOf_4(dummydiff), ($clinit_Boolean() , maxWidthNotExceeded?true:false));
}

function $promotionMagic(this$static, funky){
  var apply_0, currentWidthBackup, currentWidthPixelBackup, dummyBackup, heightBackup, iterationCounter, layeringBackup, node, node$iterator, promotionFlag, promotionPair, promotions, reducedDummies;
  iterationCounter = 0;
  reducedDummies = 0;
  layeringBackup = copyOf_0(this$static.layers, this$static.layers.length);
  dummyBackup = this$static.dummyNodeCount;
  heightBackup = this$static.maxHeight;
  currentWidthBackup = this$static.currentWidth;
  currentWidthPixelBackup = this$static.currentWidthPixel;
  do {
    promotions = 0;
    for (node$iterator = new ArrayList$1(this$static.nodesWithIncomingEdges); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      promotionPair = $promoteNode(this$static, node);
      apply_0 = true;
      (this$static.promotionStrategy == ($clinit_NodePromotionStrategy() , NIKOLOV) || this$static.promotionStrategy == NIKOLOV_PIXEL) && (apply_0 = checkNotNull_1(castToBoolean(promotionPair.second)));
      if (castTo(promotionPair.first, 21).value_0 < 0 && apply_0) {
        ++promotions;
        layeringBackup = copyOf_0(this$static.layers, this$static.layers.length);
        this$static.dummyNodeCount = this$static.dummyNodeCount + castTo(promotionPair.first, 21).value_0;
        reducedDummies += dummyBackup - this$static.dummyNodeCount;
        dummyBackup = this$static.dummyNodeCount + castTo(promotionPair.first, 21).value_0;
        heightBackup = this$static.maxHeight;
        currentWidthBackup = newArrayList(this$static.currentWidth);
        currentWidthPixelBackup = newArrayList(this$static.currentWidthPixel);
      }
       else {
        this$static.layers = copyOf_0(layeringBackup, layeringBackup.length);
        this$static.dummyNodeCount = dummyBackup;
        this$static.currentWidth = (checkNotNull(currentWidthBackup) , currentWidthBackup?new ArrayList_1(($clinit_Collections2() , currentWidthBackup)):newArrayList_0(new ArrayList$1(null)));
        this$static.currentWidthPixel = (checkNotNull(currentWidthPixelBackup) , currentWidthPixelBackup?new ArrayList_1(($clinit_Collections2() , currentWidthPixelBackup)):newArrayList_0(new ArrayList$1(null)));
        this$static.maxHeight = heightBackup;
      }
    }
    ++iterationCounter;
    promotionFlag = promotions != 0 && checkNotNull_1(castToBoolean(funky.apply_0(new Pair(valueOf_4(reducedDummies), valueOf_4(iterationCounter)))));
  }
   while (promotionFlag);
}

function $setNewLayering(this$static, layeredGraph){
  var i, laLaLayer, layList, layerIt, node, node$iterator, possiblyEvilLayer;
  layList = new ArrayList;
  for (i = 0; i <= this$static.maxHeight; i++) {
    laLaLayer = new Layer(layeredGraph);
    laLaLayer.id_0 = this$static.maxHeight - i;
    layList.array[layList.array.length] = laLaLayer;
  }
  for (node$iterator = new ArrayList$1(this$static.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $setLayer_0(node, castTo($get_7(layList, this$static.maxHeight - this$static.layers[node.id_0]), 25));
  }
  layerIt = new ArrayList$1(layList);
  while (layerIt.i < layerIt.this$01.array.length) {
    possiblyEvilLayer = castTo($next_10(layerIt), 25);
    possiblyEvilLayer.nodes.array.length == 0 && $remove_14(layerIt);
  }
  layeredGraph.layers.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $addAll_2(layeredGraph.layers, layList);
}

function NodePromotion(){
}

function lambda$1_3(promoteUntilN_0, pair_1){
  return $clinit_Boolean() , castTo(pair_1.second, 21).value_0 < promoteUntilN_0?true:false;
}

function lambda$2_3(promoteUntilD_0, pair_1){
  return $clinit_Boolean() , castTo(pair_1.first, 21).value_0 < promoteUntilD_0?true:false;
}

defineClass(1436, 1, $intern_108, NodePromotion);
_.process = function process_34(layeredGraph, progressMonitor){
  $process_38(this, castTo(layeredGraph, 32), progressMonitor);
}
;
_.dummyNodeCount = 0;
_.dummySize = 0;
_.maxHeight = 0;
_.maxWidth = 0;
_.maxWidthPixel = 0;
_.nodeSizeAffix = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_NodePromotion_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'NodePromotion', 1436);
function NodePromotion$lambda$0$Type(){
}

defineClass(1437, 1, $intern_25, NodePromotion$lambda$0$Type);
_.equals_0 = function equals_122(other){
  return this === other;
}
;
_.apply_0 = function apply_89(arg0){
  return $clinit_Boolean() , $clinit_Boolean() , true;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_NodePromotion$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'NodePromotion/lambda$0$Type', 1437);
function NodePromotion$lambda$1$Type(promoteUntilN_0){
  this.promoteUntilN_0 = promoteUntilN_0;
}

defineClass(1438, 1, $intern_25, NodePromotion$lambda$1$Type);
_.equals_0 = function equals_123(other){
  return this === other;
}
;
_.apply_0 = function apply_90(arg0){
  return lambda$1_3(this.promoteUntilN_0, arg0);
}
;
_.promoteUntilN_0 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_NodePromotion$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'NodePromotion/lambda$1$Type', 1438);
function NodePromotion$lambda$2$Type(promoteUntilD_0){
  this.promoteUntilD_0 = promoteUntilD_0;
}

defineClass(1439, 1, $intern_25, NodePromotion$lambda$2$Type);
_.equals_0 = function equals_124(other){
  return this === other;
}
;
_.apply_0 = function apply_91(arg0){
  return lambda$2_3(this.promoteUntilD_0, arg0);
}
;
_.promoteUntilD_0 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_NodePromotion$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'NodePromotion/lambda$2$Type', 1439);
function $process_39(layeredGraph, monitor){
  var currentPort, layer, layer$iterator, node, node$index, node$max, nodeArray, port, port$iterator, portIterator, previousPort, routing, sameOriginPort, selfLoop, inputPort, outputPort, originInputPort, originOutputPort, bendPoint;
  $begin(monitor, 'Odd port side processing', 1);
  routing = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , EDGE_ROUTING)), 204);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    nodeArray = castTo($toArray_2(layer.nodes, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, layer.nodes.array.length, 0, 1)), 125);
    for (node$index = 0 , node$max = nodeArray.length; node$index < node$max; ++node$index) {
      node = nodeArray[node$index];
      if (node.type_0 != ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
        continue;
      }
      if (routing == ($clinit_EdgeRouting() , SPLINES)) {
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_10(port$iterator), 11);
          port.incomingEdges.array.length == 0 || $processSplineInputPort(port);
          port.outgoingEdges.array.length == 0 || $processSplineOutputPort(port);
        }
      }
       else if (instanceOf($getProperty(node, ($clinit_InternalProperties_1() , ORIGIN_0)), 16)) {
        selfLoop = castTo($getProperty(node, ORIGIN_0), 16);
        inputPort = castTo($getPorts_1(node, ($clinit_PortSide() , WEST_1)).iterator_0().next_1(), 11);
        outputPort = castTo($getPorts_1(node, EAST_1).iterator_0().next_1(), 11);
        originInputPort = castTo($getProperty(inputPort, ORIGIN_0), 11);
        originOutputPort = castTo($getProperty(outputPort, ORIGIN_0), 11);
        $setSource_0(selfLoop, originOutputPort);
        $setTarget_0(selfLoop, originInputPort);
        bendPoint = new KVector_2(outputPort.owner.pos);
        bendPoint.x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [originOutputPort.owner.pos, originOutputPort.pos, originOutputPort.anchor])).x_0;
        $add_7(selfLoop.bendPoints, bendPoint);
        bendPoint = new KVector_2(inputPort.owner.pos);
        bendPoint.x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [originInputPort.owner.pos, originInputPort.pos, originInputPort.anchor])).x_0;
        $add_7(selfLoop.bendPoints, bendPoint);
      }
       else {
        if (node.ports.array.length >= 2) {
          sameOriginPort = true;
          portIterator = new ArrayList$1(node.ports);
          currentPort = castTo($next_10(portIterator), 11);
          while (portIterator.i < portIterator.this$01.array.length) {
            previousPort = currentPort;
            currentPort = castTo($next_10(portIterator), 11);
            if (!equals_Ljava_lang_Object__Z__devirtual$($getProperty(previousPort, ORIGIN_0), $getProperty(currentPort, ORIGIN_0))) {
              sameOriginPort = false;
              break;
            }
          }
        }
         else {
          sameOriginPort = false;
        }
        for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
          port = castTo($next_10(port$iterator), 11);
          port.incomingEdges.array.length == 0 || $processInputPort(port, sameOriginPort);
          port.outgoingEdges.array.length == 0 || $processOutputPort(port, sameOriginPort);
        }
      }
      $setLayer_0(node, null);
    }
  }
  $done_0(monitor);
}

function $processInputPort(inputPort, addJunctionPoints){
  var edgeArray, inEdge, inEdge$index, inEdge$max, junctionPoints, originPort, x_0, y_0;
  originPort = castTo($getProperty(inputPort, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
  x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [originPort.owner.pos, originPort.pos, originPort.anchor])).x_0;
  y_0 = inputPort.owner.pos.y_0;
  edgeArray = castTo($toArray_2(inputPort.incomingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, inputPort.incomingEdges.array.length, 0, 1)), 101);
  for (inEdge$index = 0 , inEdge$max = edgeArray.length; inEdge$index < inEdge$max; ++inEdge$index) {
    inEdge = edgeArray[inEdge$index];
    $setTarget_0(inEdge, originPort);
    $addLast_0(inEdge.bendPoints, new KVector_1(x_0, y_0));
    if (addJunctionPoints) {
      junctionPoints = castTo($getProperty(inEdge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty_0(inEdge, JUNCTION_POINTS, junctionPoints);
      }
      $add_7(junctionPoints, new KVector_1(x_0, y_0));
    }
  }
}

function $processOutputPort(outputPort, addJunctionPoints){
  var edgeArray, junctionPoints, originPort, outEdge, outEdge$index, outEdge$max, x_0, y_0;
  originPort = castTo($getProperty(outputPort, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
  x_0 = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [originPort.owner.pos, originPort.pos, originPort.anchor])).x_0;
  y_0 = outputPort.owner.pos.y_0;
  edgeArray = castTo($toArray_2(outputPort.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, outputPort.outgoingEdges.array.length, 0, 1)), 101);
  for (outEdge$index = 0 , outEdge$max = edgeArray.length; outEdge$index < outEdge$max; ++outEdge$index) {
    outEdge = edgeArray[outEdge$index];
    $setSource_0(outEdge, originPort);
    $addFirst_0(outEdge.bendPoints, new KVector_1(x_0, y_0));
    if (addJunctionPoints) {
      junctionPoints = castTo($getProperty(outEdge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty_0(outEdge, JUNCTION_POINTS, junctionPoints);
      }
      $add_7(junctionPoints, new KVector_1(x_0, y_0));
    }
  }
}

function $processSplineInputPort(inputPort){
  var edgeArray, inEdge, inEdge$index, inEdge$max, originPort;
  originPort = castTo($getProperty(inputPort, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
  $setProperty_0(originPort, SPLINE_NS_PORT_Y_COORD, inputPort.owner.pos.y_0);
  edgeArray = castTo($toArray_2(inputPort.incomingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, inputPort.incomingEdges.array.length, 0, 1)), 101);
  for (inEdge$index = 0 , inEdge$max = edgeArray.length; inEdge$index < inEdge$max; ++inEdge$index) {
    inEdge = edgeArray[inEdge$index];
    $setTarget_0(inEdge, originPort);
  }
}

function $processSplineOutputPort(outputPort){
  var edgeArray, originPort, outEdge, outEdge$index, outEdge$max;
  originPort = castTo($getProperty(outputPort, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
  $setProperty_0(originPort, SPLINE_NS_PORT_Y_COORD, outputPort.owner.pos.y_0);
  edgeArray = castTo($toArray_2(outputPort.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, outputPort.outgoingEdges.array.length, 0, 1)), 101);
  for (outEdge$index = 0 , outEdge$max = edgeArray.length; outEdge$index < outEdge$max; ++outEdge$index) {
    outEdge = edgeArray[outEdge$index];
    $setSource_0(outEdge, originPort);
  }
}

function NorthSouthPortPostprocessor(){
}

defineClass(1440, 1, $intern_108, NorthSouthPortPostprocessor);
_.process = function process_35(layeredGraph, monitor){
  $process_39(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_NorthSouthPortPostprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'NorthSouthPortPostprocessor', 1440);
function $createDummyNode_0(layeredGraph, inPort, outPort, dummyNodes){
  var crossingHint, dummy, dummyInputPort, dummyOutputPort, edge, edge$index, edge$max, edgeArray;
  dummy = new LNode(layeredGraph);
  $setType(dummy, ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT));
  $setProperty_0(dummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
  crossingHint = 0;
  if (inPort) {
    dummyInputPort = new LPort;
    $setProperty_0(dummyInputPort, ($clinit_InternalProperties_1() , ORIGIN_0), inPort);
    $setProperty_0(dummy, ORIGIN_0, inPort.owner);
    $setSide(dummyInputPort, ($clinit_PortSide() , WEST_1));
    $setNode(dummyInputPort, dummy);
    edgeArray = castTo($toArray_2(inPort.incomingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, inPort.incomingEdges.array.length, 0, 1)), 101);
    for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
      edge = edgeArray[edge$index];
      $setTarget_0(edge, dummyInputPort);
    }
    $setProperty_0(inPort, PORT_DUMMY, dummy);
    ++crossingHint;
  }
  if (outPort) {
    dummyOutputPort = new LPort;
    $setProperty_0(dummy, ($clinit_InternalProperties_1() , ORIGIN_0), outPort.owner);
    $setProperty_0(dummyOutputPort, ORIGIN_0, outPort);
    $setSide(dummyOutputPort, ($clinit_PortSide() , EAST_1));
    $setNode(dummyOutputPort, dummy);
    edgeArray = castTo($toArray_2(outPort.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, outPort.outgoingEdges.array.length, 0, 1)), 101);
    for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
      edge = edgeArray[edge$index];
      $setSource_0(edge, dummyOutputPort);
    }
    $setProperty_0(outPort, PORT_DUMMY, dummy);
    ++crossingHint;
  }
  $setProperty_0(dummy, ($clinit_InternalProperties_1() , CROSSING_HINT), valueOf_4(crossingHint));
  dummyNodes.array[dummyNodes.array.length] = dummy;
  return dummy;
}

function $createDummyNodes(layeredGraph, ports, dummyNodes, opposingSideDummyNodes, barycenterAssociates){
  var edge, edge$iterator, edge$iterator0, edge$iterator1, in_0, inOutPort, inOutPort$iterator, inOutPorts, inPort, inPort$iterator, inPorts, northSouthSelfLoopEdges, out, outPort, outPort$iterator, outPorts, port, port$iterator, port$iterator0, sameSideSelfLoopEdges, dummy, dummyInputPort, dummyOutputPort;
  inPorts = new ArrayList_0(ports.size_0);
  outPorts = new ArrayList_0(ports.size_0);
  inOutPorts = new ArrayList_0(ports.size_0);
  sameSideSelfLoopEdges = new ArrayList_0(ports.size_0);
  northSouthSelfLoopEdges = new ArrayList_0(ports.size_0);
  for (port$iterator0 = $listIterator_1(ports, 0); port$iterator0.currentNode != port$iterator0.this$01.tail;) {
    port = castTo($next_13(port$iterator0), 11);
    for (edge$iterator0 = new ArrayList$1(port.outgoingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator0), 16);
      if (edge.source.owner == edge.target.owner) {
        if (port.side == edge.target.side) {
          sameSideSelfLoopEdges.array[sameSideSelfLoopEdges.array.length] = edge;
          continue;
        }
         else if (port.side == ($clinit_PortSide() , NORTH_1) && edge.target.side == SOUTH_1) {
          northSouthSelfLoopEdges.array[northSouthSelfLoopEdges.array.length] = edge;
          continue;
        }
      }
    }
  }
  for (edge$iterator1 = new ArrayList$1(northSouthSelfLoopEdges); edge$iterator1.i < edge$iterator1.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator1), 16);
    $createNorthSouthSelfLoopDummyNodes(layeredGraph, edge, dummyNodes, opposingSideDummyNodes, ($clinit_PortSide() , EAST_1));
  }
  for (edge$iterator = new ArrayList$1(sameSideSelfLoopEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 16);
    dummy = new LNode(layeredGraph);
    $setType(dummy, ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT));
    $setProperty_0(dummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
    $setProperty_0(dummy, ($clinit_InternalProperties_1() , ORIGIN_0), edge);
    dummyInputPort = new LPort;
    $setProperty_0(dummyInputPort, ORIGIN_0, edge.target);
    $setSide(dummyInputPort, ($clinit_PortSide() , WEST_1));
    $setNode(dummyInputPort, dummy);
    dummyOutputPort = new LPort;
    $setProperty_0(dummyOutputPort, ORIGIN_0, edge.source);
    $setSide(dummyOutputPort, EAST_1);
    $setNode(dummyOutputPort, dummy);
    $setProperty_0(edge.source, PORT_DUMMY, dummy);
    $setProperty_0(edge.target, PORT_DUMMY, dummy);
    $setSource_0(edge, null);
    $setTarget_0(edge, null);
    dummyNodes.array[dummyNodes.array.length] = dummy;
    $setProperty_0(dummy, CROSSING_HINT, valueOf_4(2));
  }
  for (port$iterator = $listIterator_1(ports, 0); port$iterator.currentNode != port$iterator.this$01.tail;) {
    port = castTo($next_13(port$iterator), 11);
    in_0 = port.incomingEdges.array.length > 0;
    out = port.outgoingEdges.array.length > 0;
    in_0 && out?(inOutPorts.array[inOutPorts.array.length] = port , true):in_0?(inPorts.array[inPorts.array.length] = port , true):out && (outPorts.array[outPorts.array.length] = port , true);
  }
  for (inPort$iterator = new ArrayList$1(inPorts); inPort$iterator.i < inPort$iterator.this$01.array.length;) {
    inPort = castTo($next_10(inPort$iterator), 11);
    $add_4(barycenterAssociates, $createDummyNode_0(layeredGraph, inPort, null, dummyNodes));
  }
  for (outPort$iterator = new ArrayList$1(outPorts); outPort$iterator.i < outPort$iterator.this$01.array.length;) {
    outPort = castTo($next_10(outPort$iterator), 11);
    $add_4(barycenterAssociates, $createDummyNode_0(layeredGraph, null, outPort, dummyNodes));
  }
  for (inOutPort$iterator = new ArrayList$1(inOutPorts); inOutPort$iterator.i < inOutPort$iterator.this$01.array.length;) {
    inOutPort = castTo($next_10(inOutPort$iterator), 11);
    $add_4(barycenterAssociates, $createDummyNode_0(layeredGraph, inOutPort, inOutPort, dummyNodes));
  }
}

function $createNorthSouthSelfLoopDummyNodes(layeredGraph, selfLoop, northDummyNodes, southDummyNodes, portSide){
  var northDummy, northDummyOutputPort, southDummy, southDummyInputPort;
  northDummy = new LNode(layeredGraph);
  $setType(northDummy, ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT));
  $setProperty_0(northDummy, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty_0(northDummy, ($clinit_InternalProperties_1() , ORIGIN_0), selfLoop.source.owner);
  northDummyOutputPort = new LPort;
  $setProperty_0(northDummyOutputPort, ORIGIN_0, selfLoop.source);
  $setSide(northDummyOutputPort, portSide);
  $setNode(northDummyOutputPort, northDummy);
  $setProperty_0(selfLoop.source, PORT_DUMMY, northDummy);
  southDummy = new LNode(layeredGraph);
  $setType(southDummy, NORTH_SOUTH_PORT);
  $setProperty_0(southDummy, PORT_CONSTRAINTS_0, FIXED_POS);
  $setProperty_0(southDummy, ORIGIN_0, selfLoop.target.owner);
  southDummyInputPort = new LPort;
  $setProperty_0(southDummyInputPort, ORIGIN_0, selfLoop.target);
  $setSide(southDummyInputPort, portSide);
  $setNode(southDummyInputPort, southDummy);
  $setProperty_0(selfLoop.target, PORT_DUMMY, southDummy);
  $setSource_0(selfLoop, northDummyOutputPort);
  $setTarget_0(selfLoop, southDummyInputPort);
  checkCriticalPositionIndex(0, northDummyNodes.array.length);
  insertTo(northDummyNodes.array, 0, northDummy);
  southDummyNodes.array[southDummyNodes.array.length] = southDummy;
  $setProperty_0(northDummy, CROSSING_HINT, valueOf_4(1));
  $setProperty_0(southDummy, CROSSING_HINT, valueOf_4(1));
}

function $process_40(layeredGraph, monitor){
  var barycenterAssociates, dummy, dummy$iterator, dummy$iterator0, dummyPort, insertPoint, layer, layer$iterator, node, node$index, node$max, nodeArray, northDummyNodes, originPort, pointer, port, port$iterator, portList, southDummyNodes;
  $begin(monitor, 'Odd port side processing', 1);
  northDummyNodes = new ArrayList;
  southDummyNodes = new ArrayList;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    pointer = -1;
    nodeArray = castTo($toArray_2(layer.nodes, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, layer.nodes.array.length, 0, 1)), 125);
    for (node$index = 0 , node$max = nodeArray.length; node$index < node$max; ++node$index) {
      node = nodeArray[node$index];
      ++pointer;
      if (!(node.type_0 == ($clinit_LNode$NodeType() , NORMAL) && $isSideFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83)))) {
        continue;
      }
      $isOrderFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83)) || $sortPortList(node);
      $setProperty_0(node, ($clinit_InternalProperties_1() , IN_LAYER_LAYOUT_UNIT), node);
      northDummyNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      southDummyNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      barycenterAssociates = new ArrayList;
      portList = new LinkedList;
      addAll_4(portList, $getPorts_1(node, ($clinit_PortSide() , NORTH_1)));
      $createDummyNodes(layeredGraph, portList, northDummyNodes, southDummyNodes, barycenterAssociates);
      insertPoint = pointer;
      for (dummy$iterator0 = new ArrayList$1(northDummyNodes); dummy$iterator0.i < dummy$iterator0.this$01.array.length;) {
        dummy = castTo($next_10(dummy$iterator0), 9);
        $setLayer(dummy, insertPoint, layer);
        ++pointer;
        $setProperty_0(dummy, IN_LAYER_LAYOUT_UNIT, node);
        dummyPort = castTo($get_7(dummy.ports, 0), 11);
        originPort = castTo($getProperty(dummyPort, ORIGIN_0), 11);
        checkNotNull_1(castToBoolean($getProperty(originPort, NORTH_OR_SOUTH_PORT_0))) || castTo($getProperty(dummy, IN_LAYER_SUCCESSOR_CONSTRAINTS), 15).add_1(node);
      }
      $reset_0(portList);
      for (port$iterator = $getPorts_1(node, SOUTH_1).iterator_0(); port$iterator.hasNext_0();) {
        port = castTo(port$iterator.next_1(), 11);
        $addNode_0(portList, port, portList.header, portList.header.next_0);
      }
      $createDummyNodes(layeredGraph, portList, southDummyNodes, null, barycenterAssociates);
      for (dummy$iterator = new ArrayList$1(southDummyNodes); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
        dummy = castTo($next_10(dummy$iterator), 9);
        $setLayer(dummy, ++pointer, layer);
        $setProperty_0(dummy, IN_LAYER_LAYOUT_UNIT, node);
        dummyPort = castTo($get_7(dummy.ports, 0), 11);
        originPort = castTo($getProperty(dummyPort, ORIGIN_0), 11);
        checkNotNull_1(castToBoolean($getProperty(originPort, NORTH_OR_SOUTH_PORT_0))) || castTo($getProperty(node, IN_LAYER_SUCCESSOR_CONSTRAINTS), 15).add_1(dummy);
      }
      barycenterAssociates.array.length == 0 || $setProperty_0(node, BARYCENTER_ASSOCIATES, barycenterAssociates);
    }
  }
  $done_0(monitor);
}

function $sortPortList(node){
  var inOutPorts, inPorts, incoming, outPorts, outgoing, port, port$iterator, ports;
  ports = node.ports.array.length;
  inPorts = 0;
  inOutPorts = ports;
  outPorts = 2 * ports;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    switch (port.side.ordinal) {
      case 2:
      case 4:
        port.id_0 = -1;
        break;
      case 1:
      case 3:
        incoming = port.incomingEdges.array.length;
        outgoing = port.outgoingEdges.array.length;
        incoming > 0 && outgoing > 0?(port.id_0 = inOutPorts++):incoming > 0?(port.id_0 = inPorts++):outgoing > 0?(port.id_0 = outPorts++):(port.id_0 = inPorts++);
    }
  }
  $clinit_Collections();
  $sort(node.ports, new NorthSouthPortPreprocessor$lambda$0$Type);
}

function NorthSouthPortPreprocessor(){
}

defineClass(1441, 1, $intern_108, NorthSouthPortPreprocessor);
_.process = function process_36(layeredGraph, monitor){
  $process_40(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_NorthSouthPortPreprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'NorthSouthPortPreprocessor', 1441);
function NorthSouthPortPreprocessor$lambda$0$Type(){
}

defineClass(1442, 1, $intern_40, NorthSouthPortPreprocessor$lambda$0$Type);
_.equals_0 = function equals_125(other){
  return this === other;
}
;
_.reversed = function reversed_37(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_45(arg0, arg1){
  var side1, side2;
  return side1 = arg0.side , side2 = arg1.side , side1 != side2?side1.ordinal - side2.ordinal:arg0.id_0 == arg1.id_0?0:side1 == ($clinit_PortSide() , NORTH_1)?arg0.id_0 - arg1.id_0:arg1.id_0 - arg0.id_0;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_NorthSouthPortPreprocessor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'NorthSouthPortPreprocessor/lambda$0$Type', 1442);
function $process_41(lGraph, monitor){
  var layer, layer$iterator, node, node$iterator, port, ports;
  $begin(monitor, 'Removing partition constraint edges', 1);
  for (layer$iterator = new ArrayList$1(lGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      ports = new ArrayList$1(node.ports);
      while (ports.i < ports.this$01.array.length) {
        port = castTo($next_10(ports), 11);
        checkNotNull_1(castToBoolean($getProperty(port, ($clinit_InternalProperties_1() , PARTITION_DUMMY)))) && $remove_14(ports);
      }
    }
  }
  $done_0(monitor);
}

function PartitionPostprocessor(){
}

defineClass(1444, 1, $intern_108, PartitionPostprocessor);
_.process = function process_37(lGraph, monitor){
  $process_41(castTo(lGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_PartitionPostprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PartitionPostprocessor', 1444);
function $process_42(this$static, lGraph, monitor){
  var edge, i, index_0, node, node$iterator, node$iterator0, otherNode, otherNode$iterator, sourcePort, targetPort;
  $begin(monitor, 'Adding partition constraint edges', 1);
  this$static.partitions = new ArrayList;
  for (node$iterator0 = new ArrayList$1(lGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    index_0 = castTo($getProperty(node, ($clinit_LayeredOptions() , PARTITIONING_PARTITION)), 21);
    $retrievePartition(this$static, index_0.value_0).add_1(node);
  }
  for (i = 0; i < this$static.partitions.array.length - 1; i++) {
    for (node$iterator = castTo($get_7(this$static.partitions, i), 15).iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 9);
      sourcePort = new LPort;
      $setNode(sourcePort, node);
      $setSide(sourcePort, ($clinit_PortSide() , EAST_1));
      $setProperty_0(sourcePort, ($clinit_InternalProperties_1() , PARTITION_DUMMY), ($clinit_Boolean() , $clinit_Boolean() , true));
      for (otherNode$iterator = castTo($get_7(this$static.partitions, i + 1), 15).iterator_0(); otherNode$iterator.hasNext_0();) {
        otherNode = castTo(otherNode$iterator.next_1(), 9);
        targetPort = new LPort;
        $setNode(targetPort, otherNode);
        $setSide(targetPort, WEST_1);
        $setProperty_0(targetPort, PARTITION_DUMMY, (null , true));
        edge = new LEdge;
        $setProperty_0(edge, PARTITION_DUMMY, (null , true));
        $setProperty_0(edge, ($clinit_LayeredOptions() , PRIORITY_DIRECTION_0), valueOf_4(20));
        $setSource_0(edge, sourcePort);
        $setTarget_0(edge, targetPort);
      }
    }
  }
  this$static.partitions = null;
  $done_0(monitor);
}

function $retrievePartition(this$static, index_0){
  while (index_0 >= this$static.partitions.array.length) {
    $add_4(this$static.partitions, new LinkedList);
  }
  return castTo($get_7(this$static.partitions, index_0), 15);
}

function PartitionPreprocessor(){
}

defineClass(1445, 1, $intern_108, PartitionPreprocessor);
_.process = function process_38(lGraph, monitor){
  $process_42(this, castTo(lGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_PartitionPreprocessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PartitionPreprocessor', 1445);
function $clinit_PortListSorter(){
  $clinit_PortListSorter = emptyMethod;
  IN_EDGES = new PortListSorter$lambda$0$Type;
  OUT_EDGES = new PortListSorter$lambda$1$Type;
  CMP_PORT_SIDE = new PortListSorter$lambda$2$Type;
  CMP_PORT_DEGREE_EAST_WEST = new PortListSorter$lambda$3$Type;
  CMP_FIXED_ORDER_AND_FIXED_POS = new PortListSorter$lambda$4$Type;
  CMP_COMBINED = (checkCriticalNotNull(CMP_FIXED_ORDER_AND_FIXED_POS) , new Comparator$lambda$0$Type);
}

function $findPortSideRange(ports, side){
  var currentSide, hb, highIdx, lb, lowIdx;
  if (ports.array.length == 0) {
    return new Pair(valueOf_4(0), valueOf_4(0));
  }
  currentSide = (checkCriticalElementIndex(0, ports.array.length) , castTo(ports.array[0], 11)).side;
  lowIdx = 0;
  lb = side.ordinal;
  hb = side.ordinal + 1;
  while (lowIdx < ports.array.length - 1 && currentSide.ordinal < lb) {
    ++lowIdx;
    currentSide = (checkCriticalElementIndex(lowIdx, ports.array.length) , castTo(ports.array[lowIdx], 11)).side;
  }
  highIdx = lowIdx;
  while (highIdx < ports.array.length - 1 && currentSide.ordinal < hb) {
    ++highIdx;
    currentSide = (checkCriticalElementIndex(lowIdx, ports.array.length) , castTo(ports.array[lowIdx], 11)).side;
  }
  return new Pair(valueOf_4(lowIdx), valueOf_4(highIdx));
}

function $process_43(layeredGraph, monitor){
  var layer, layer$iterator, node, node$iterator, portConstraints, ports, pss;
  $begin(monitor, 'Port order processing', 1);
  pss = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , PORT_SORTING_STRATEGY_0)), 399);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      portConstraints = castTo($getProperty(node, PORT_CONSTRAINTS_0), 83);
      ports = node.ports;
      if (portConstraints == ($clinit_PortConstraints() , FIXED_ORDER) || portConstraints == FIXED_RATIO || portConstraints == FIXED_POS) {
        $clinit_Collections();
        $sort(ports, CMP_COMBINED);
      }
       else if (portConstraints != FREE && portConstraints != UNDEFINED_6) {
        $clinit_Collections();
        $sort(ports, CMP_PORT_SIDE);
        $reverseWestAndSouthSide(ports);
        pss == ($clinit_PortSortingStrategy() , PORT_DEGREE) && $sort(ports, CMP_PORT_DEGREE_EAST_WEST);
      }
      node.portSidesCached = true;
      $findPortIndices(node);
    }
  }
  $done_0(monitor);
}

function $reverse_1(ports, lowIdx, highIdx){
  var i, n, tmp;
  if (highIdx <= lowIdx + 2) {
    return;
  }
  n = (highIdx - lowIdx) / 2 | 0;
  for (i = 0; i < n; ++i) {
    tmp = (checkCriticalElementIndex(lowIdx + i, ports.array.length) , castTo(ports.array[lowIdx + i], 11));
    $set_1(ports, lowIdx + i, (checkCriticalElementIndex(highIdx - i - 1, ports.array.length) , castTo(ports.array[highIdx - i - 1], 11)));
    checkCriticalElementIndex(highIdx - i - 1, ports.array.length);
    ports.array[highIdx - i - 1] = tmp;
  }
}

function $reverseWestAndSouthSide(ports){
  var southIndices, westIndices;
  if (ports.array.length <= 1) {
    return;
  }
  southIndices = $findPortSideRange(ports, ($clinit_PortSide() , SOUTH_1));
  $reverse_1(ports, castTo(southIndices.first, 21).value_0, castTo(southIndices.second, 21).value_0);
  westIndices = $findPortSideRange(ports, WEST_1);
  $reverse_1(ports, castTo(westIndices.first, 21).value_0, castTo(westIndices.second, 21).value_0);
}

function PortListSorter(){
  $clinit_PortListSorter();
}

function lambda$2_4(p1_0, p2_1){
  $clinit_PortListSorter();
  var ordinalDifference;
  ordinalDifference = p1_0.side.ordinal - p2_1.side.ordinal;
  if (ordinalDifference != 0) {
    return ordinalDifference;
  }
  return 0;
}

function lambda$3_3(p1_0, p2_1){
  $clinit_PortListSorter();
  var ordinalDifference;
  ordinalDifference = p1_0.side.ordinal - p2_1.side.ordinal;
  if (ordinalDifference != 0) {
    return 0;
  }
  switch (p1_0.side.ordinal) {
    case 2:
      return realDegree_0(p2_1, OUT_EDGES) - realDegree_0(p1_0, OUT_EDGES);
    case 4:
      return realDegree_0(p1_0, IN_EDGES) - realDegree_0(p2_1, IN_EDGES);
  }
  return 0;
}

function lambda$4_3(p1_0, p2_1){
  $clinit_PortListSorter();
  var index1, index2, indexDifference, ordinalDifference, portConstraints;
  portConstraints = castTo($getProperty(p1_0.owner, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
  ordinalDifference = p1_0.side.ordinal - p2_1.side.ordinal;
  if (ordinalDifference != 0 || !(portConstraints == ($clinit_PortConstraints() , FIXED_ORDER) || portConstraints == FIXED_RATIO || portConstraints == FIXED_POS)) {
    return 0;
  }
  if (portConstraints == ($clinit_PortConstraints() , FIXED_ORDER)) {
    index1 = castTo($getProperty(p1_0, PORT_INDEX), 21);
    index2 = castTo($getProperty(p2_1, PORT_INDEX), 21);
    if (!!index1 && !!index2) {
      indexDifference = index1.value_0 - index2.value_0;
      if (indexDifference != 0) {
        return indexDifference;
      }
    }
  }
  switch (p1_0.side.ordinal) {
    case 1:
      return compare_5(p1_0.pos.x_0, p2_1.pos.x_0);
    case 2:
      return compare_5(p1_0.pos.y_0, p2_1.pos.y_0);
    case 3:
      return compare_5(p2_1.pos.x_0, p1_0.pos.x_0);
    case 4:
      return compare_5(p2_1.pos.y_0, p1_0.pos.y_0);
    default:throw toJs(new IllegalStateException_0('Port side is undefined'));
  }
}

function realDegree_0(p, edgesFun){
  var e, e$iterator, realDegree;
  realDegree = 0;
  for (e$iterator = castTo(edgesFun.apply_0(p), 20).iterator_0(); e$iterator.hasNext_0();) {
    e = castTo(e$iterator.next_1(), 16);
    checkNotNull_1(castToBoolean($getProperty(e, ($clinit_InternalProperties_1() , REVERSED)))) || ++realDegree;
  }
  return realDegree;
}

defineClass(1446, 1, $intern_108, PortListSorter);
_.process = function process_39(layeredGraph, monitor){
  $process_43(castTo(layeredGraph, 32), monitor);
}
;
var CMP_COMBINED, CMP_FIXED_ORDER_AND_FIXED_POS, CMP_PORT_DEGREE_EAST_WEST, CMP_PORT_SIDE, IN_EDGES, OUT_EDGES;
var Lorg_eclipse_elk_alg_layered_intermediate_PortListSorter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PortListSorter', 1446);
function PortListSorter$lambda$0$Type(){
}

defineClass(1447, 1, $intern_11, PortListSorter$lambda$0$Type);
_.apply_0 = function apply_92(arg0){
  return $clinit_PortListSorter() , castTo(arg0, 11).incomingEdges;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_PortListSorter$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PortListSorter/lambda$0$Type', 1447);
function PortListSorter$lambda$1$Type(){
}

defineClass(1448, 1, $intern_11, PortListSorter$lambda$1$Type);
_.apply_0 = function apply_93(arg0){
  return $clinit_PortListSorter() , castTo(arg0, 11).outgoingEdges;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_PortListSorter$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PortListSorter/lambda$1$Type', 1448);
function PortListSorter$lambda$2$Type(){
}

defineClass(1449, 1, $intern_40, PortListSorter$lambda$2$Type);
_.equals_0 = function equals_126(other){
  return this === other;
}
;
_.reversed = function reversed_38(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_46(arg0, arg1){
  return lambda$2_4(arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_PortListSorter$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PortListSorter/lambda$2$Type', 1449);
function PortListSorter$lambda$3$Type(){
}

defineClass(1450, 1, $intern_40, PortListSorter$lambda$3$Type);
_.equals_0 = function equals_127(other){
  return this === other;
}
;
_.reversed = function reversed_39(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_47(arg0, arg1){
  return lambda$3_3(arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_PortListSorter$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PortListSorter/lambda$3$Type', 1450);
function PortListSorter$lambda$4$Type(){
}

defineClass(1451, 1, $intern_40, PortListSorter$lambda$4$Type);
_.equals_0 = function equals_128(other){
  return this === other;
}
;
_.reversed = function reversed_40(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_48(arg0, arg1){
  return lambda$4_3(arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_PortListSorter$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PortListSorter/lambda$4$Type', 1451);
function $process_44(layeredGraph, monitor){
  var layer, layer$iterator, node, node$iterator, node$iterator0;
  $begin(monitor, 'Port side processing', 1);
  for (node$iterator0 = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    $process_45(node);
  }
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      $process_45(node);
    }
  }
  $done_0(monitor);
}

function $process_45(node){
  var port, port$iterator;
  if ($isSideFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      port.side == ($clinit_PortSide() , UNDEFINED_7) && setPortSide(port);
    }
  }
   else {
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      setPortSide(port);
    }
    $setProperty_0(node, PORT_CONSTRAINTS_0, ($clinit_PortConstraints() , FIXED_SIDE));
  }
}

function PortSideProcessor(){
}

function setPortSide(port){
  var portAnchor, portDummy, portSize;
  portDummy = castTo($getProperty(port, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
  portDummy?$setSide(port, castTo($getProperty(portDummy, EXT_PORT_SIDE), 71)):port.incomingEdges.array.length - port.outgoingEdges.array.length < 0?$setSide(port, ($clinit_PortSide() , EAST_1)):$setSide(port, ($clinit_PortSide() , WEST_1));
  if (!port.anchorFixed) {
    portSize = port.size_0;
    portAnchor = port.anchor;
    switch (port.side.ordinal) {
      case 1:
        portAnchor.x_0 = portSize.x_0 / 2;
        portAnchor.y_0 = 0;
        break;
      case 2:
        portAnchor.x_0 = portSize.x_0;
        portAnchor.y_0 = portSize.y_0 / 2;
        break;
      case 3:
        portAnchor.x_0 = portSize.x_0 / 2;
        portAnchor.y_0 = portSize.y_0;
        break;
      case 4:
        portAnchor.x_0 = 0;
        portAnchor.y_0 = portSize.y_0 / 2;
    }
  }
}

defineClass(1452, 1, $intern_108, PortSideProcessor);
_.process = function process_40(layeredGraph, monitor){
  $process_44(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_PortSideProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'PortSideProcessor', 1452);
function $process_46(layeredGraph, monitor){
  var edge, edge$index, edge$max, edgeArray, layer, layer$iterator, node, node$iterator, port, port$iterator;
  $begin(monitor, 'Restoring reversed edges', 1);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_10(port$iterator), 11);
        edgeArray = castTo($toArray_2(port.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, port.outgoingEdges.array.length, 0, 1)), 101);
        for (edge$index = 0 , edge$max = edgeArray.length; edge$index < edge$max; ++edge$index) {
          edge = edgeArray[edge$index];
          checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties_1() , REVERSED)))) && $reverse_0(edge, false);
        }
      }
    }
  }
  $done_0(monitor);
}

function ReversedEdgeRestorer(){
}

defineClass(1453, 1, $intern_108, ReversedEdgeRestorer);
_.process = function process_41(layeredGraph, monitor){
  $process_46(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_ReversedEdgeRestorer_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'ReversedEdgeRestorer', 1453);
function $createDummy_0(layeredGraph, edge, sourcePort, targetPort){
  var dummyEdge, dummyInput, dummyNode, dummyOutput;
  dummyNode = new LNode(layeredGraph);
  $setType(dummyNode, ($clinit_LNode$NodeType() , LONG_EDGE));
  $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0), edge);
  $setProperty_0(dummyNode, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_POS));
  $setProperty_0(dummyNode, LONG_EDGE_SOURCE, sourcePort);
  $setProperty_0(dummyNode, LONG_EDGE_TARGET, targetPort);
  dummyInput = new LPort;
  $setSide(dummyInput, ($clinit_PortSide() , WEST_1));
  $setNode(dummyInput, dummyNode);
  dummyOutput = new LPort;
  $setSide(dummyOutput, EAST_1);
  $setNode(dummyOutput, dummyNode);
  $setTarget_0(edge, dummyInput);
  dummyEdge = new LEdge;
  $copyProperties(dummyEdge, edge);
  $setProperty_0(dummyEdge, JUNCTION_POINTS, null);
  $setSource_0(dummyEdge, dummyOutput);
  $setTarget_0(dummyEdge, targetPort);
  return dummyNode;
}

function $process_47(layeredGraph, monitor){
  var createdDummies, dummy, dummy$iterator, edge, edge$index, edge$max, edges, layer, layer$iterator, node, node$iterator, port, port$iterator, sourcePort, sourcePortSide, targetPort, targetPortSide;
  $begin(monitor, 'Self-loop processing', 1);
  createdDummies = new ArrayList;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    createdDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_10(port$iterator), 11);
        edges = castTo($toArray_2(port.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, port.outgoingEdges.array.length, 0, 1)), 101);
        for (edge$index = 0 , edge$max = edges.length; edge$index < edge$max; ++edge$index) {
          edge = edges[edge$index];
          if (edge.source.owner != edge.target.owner) {
            continue;
          }
          sourcePort = edge.source;
          targetPort = edge.target;
          sourcePortSide = sourcePort.side;
          targetPortSide = targetPort.side;
          (sourcePortSide == ($clinit_PortSide() , NORTH_1) || sourcePortSide == SOUTH_1) && targetPortSide == WEST_1?$reverse_0(edge, false):sourcePortSide == SOUTH_1 && targetPortSide == NORTH_1?$reverse_0(edge, false):sourcePortSide == EAST_1 && targetPortSide != EAST_1 && $reverse_0(edge, false);
          sourcePortSide == EAST_1 && targetPortSide == WEST_1?$add_4(createdDummies, $createDummy_0(layeredGraph, edge, targetPort, sourcePort)):sourcePortSide == WEST_1 && targetPortSide == EAST_1 && $add_4(createdDummies, $createDummy_0(layeredGraph, edge, sourcePort, targetPort));
        }
      }
    }
    for (dummy$iterator = new ArrayList$1(createdDummies); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
      dummy = castTo($next_10(dummy$iterator), 9);
      $setLayer_0(dummy, layer);
    }
  }
  $done_0(monitor);
}

function SelfLoopProcessor(){
}

defineClass(1455, 1, $intern_108, SelfLoopProcessor);
_.process = function process_42(layeredGraph, monitor){
  $process_47(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SelfLoopProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SelfLoopProcessor', 1455);
function $process_48(layeredGraph, progressMonitor){
  var l, l$iterator;
  $begin(progressMonitor, 'Semi-Interactive Crossing Minimization Processor', 1);
  for (l$iterator = new ArrayList$1(layeredGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    $reduce_0($sorted($filter($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(l.nodes, 16)), new SemiInteractiveCrossMinProcessor$lambda$0$Type), new SemiInteractiveCrossMinProcessor$lambda$1$Type), new SemiInteractiveCrossMinProcessor$lambda$2$Type), new SemiInteractiveCrossMinProcessor$lambda$3$Type);
  }
  $done_0(progressMonitor);
}

function SemiInteractiveCrossMinProcessor(){
}

defineClass(1456, 1, $intern_108, SemiInteractiveCrossMinProcessor);
_.process = function process_43(layeredGraph, progressMonitor){
  $process_48(castTo(layeredGraph, 32), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SemiInteractiveCrossMinProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SemiInteractiveCrossMinProcessor', 1456);
function SemiInteractiveCrossMinProcessor$lambda$0$Type(){
}

defineClass(1457, 1, $intern_90, SemiInteractiveCrossMinProcessor$lambda$0$Type);
_.test_0 = function test_40(arg0){
  return castTo(arg0, 9).type_0 == ($clinit_LNode$NodeType() , NORMAL);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SemiInteractiveCrossMinProcessor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SemiInteractiveCrossMinProcessor/lambda$0$Type', 1457);
function SemiInteractiveCrossMinProcessor$lambda$1$Type(){
}

defineClass(1458, 1, $intern_90, SemiInteractiveCrossMinProcessor$lambda$1$Type);
_.test_0 = function test_41(arg0){
  return $getAllProperties(castTo(arg0, 9)).containsKey(($clinit_LayeredOptions() , POSITION));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SemiInteractiveCrossMinProcessor$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SemiInteractiveCrossMinProcessor/lambda$1$Type', 1458);
function SemiInteractiveCrossMinProcessor$lambda$2$Type(){
}

defineClass(1459, 1, $intern_40, SemiInteractiveCrossMinProcessor$lambda$2$Type);
_.equals_0 = function equals_129(other){
  return this === other;
}
;
_.reversed = function reversed_41(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_49(arg0, arg1){
  var origPos1, origPos2;
  return origPos1 = castTo($getProperty(arg0, ($clinit_LayeredOptions() , POSITION)), 8) , origPos2 = castTo($getProperty(arg1, POSITION), 8) , compare_5(origPos1.y_0, origPos2.y_0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SemiInteractiveCrossMinProcessor$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SemiInteractiveCrossMinProcessor/lambda$2$Type', 1459);
function SemiInteractiveCrossMinProcessor$lambda$3$Type(){
}

defineClass(1460, 1, {}, SemiInteractiveCrossMinProcessor$lambda$3$Type);
_.apply_2 = function apply_94(arg0, arg1){
  return castTo($getProperty(castTo(arg0, 9), ($clinit_InternalProperties_1() , IN_LAYER_SUCCESSOR_CONSTRAINTS)), 15).add_1(castTo(arg1, 9)) , castTo(arg1, 9);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SemiInteractiveCrossMinProcessor$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SemiInteractiveCrossMinProcessor/lambda$3$Type', 1460);
function $addComponentWithNonLoopEdges(component){
  var edgeWithHiddenPort, edgeWithHiddenPort$iterator, hiddenPort, hiddenPorts, node, nodePortIter, portOnNode, portWithSide, portsWithSideIter;
  node = component.owner;
  hiddenPorts = newHashSet($getHidablePorts(component));
  portsWithSideIter = $listIterator_1(newLinkedList(component.portsWithNonLoopEdge), 0);
  while (portsWithSideIter.currentNode != portsWithSideIter.this$01.tail) {
    portWithSide = castTo($next_13(portsWithSideIter), 11);
    if (portWithSide.outgoingEdges.array.length == 0) {
      for (edgeWithHiddenPort$iterator = new ArrayList$1(portWithSide.incomingEdges); edgeWithHiddenPort$iterator.i < edgeWithHiddenPort$iterator.this$01.array.length;) {
        edgeWithHiddenPort = castTo($next_10(edgeWithHiddenPort$iterator), 16);
        hiddenPort = edgeWithHiddenPort.source;
        if (hiddenPorts.map_0.containsKey(hiddenPort)) {
          nodePortIter = new AbstractList$ListIteratorImpl(node.ports, 0);
          portOnNode = (checkCriticalElement(nodePortIter.i < nodePortIter.this$01_0.size_1()) , castTo(nodePortIter.this$01_0.get_3(nodePortIter.last = nodePortIter.i++), 11));
          while (portOnNode != portWithSide) {
            portOnNode = (checkCriticalElement(nodePortIter.i < nodePortIter.this$01_0.size_1()) , castTo(nodePortIter.this$01_0.get_3(nodePortIter.last = nodePortIter.i++), 11));
          }
          $add_2(nodePortIter, hiddenPort);
          $add_8(portsWithSideIter, hiddenPort);
          setSideOfPort(hiddenPort, portWithSide.side);
          $previous_1(portsWithSideIter);
          $previous_1(portsWithSideIter);
          hiddenPorts.map_0.remove(hiddenPort) != null;
        }
      }
    }
     else {
      for (edgeWithHiddenPort$iterator = new ArrayList$1(portWithSide.outgoingEdges); edgeWithHiddenPort$iterator.i < edgeWithHiddenPort$iterator.this$01.array.length;) {
        edgeWithHiddenPort = castTo($next_10(edgeWithHiddenPort$iterator), 16);
        hiddenPort = edgeWithHiddenPort.target;
        if (hiddenPorts.map_0.containsKey(hiddenPort)) {
          nodePortIter = new AbstractList$ListIteratorImpl(node.ports, 0);
          portOnNode = (checkCriticalElement(nodePortIter.i < nodePortIter.this$01_0.size_1()) , castTo(nodePortIter.this$01_0.get_3(nodePortIter.last = nodePortIter.i++), 11));
          while (portOnNode != portWithSide) {
            portOnNode = (checkCriticalElement(nodePortIter.i < nodePortIter.this$01_0.size_1()) , castTo(nodePortIter.this$01_0.get_3(nodePortIter.last = nodePortIter.i++), 11));
          }
          checkCriticalElement(nodePortIter.i > 0);
          nodePortIter.this$01.get_3(nodePortIter.last = --nodePortIter.i);
          $add_2(nodePortIter, hiddenPort);
          $add_8(portsWithSideIter, hiddenPort);
          setSideOfPort(hiddenPort, portWithSide.side);
          $previous_1(portsWithSideIter);
          $previous_1(portsWithSideIter);
          hiddenPorts.map_0.remove(hiddenPort) != null;
        }
      }
    }
  }
}

function $findNextSide(startSide, itr){
  var currentSide;
  currentSide = startSide;
  while (itr.i < itr.this$01_0.size_1() && currentSide == startSide) {
    currentSide = (checkCriticalElement(itr.i < itr.this$01_0.size_1()) , castTo(itr.this$01_0.get_3(itr.last = itr.i++), 11)).side;
  }
  currentSide == startSide || (checkCriticalElement(itr.i > 0) , itr.this$01.get_3(itr.last = --itr.i));
}

function $portLinedPositioning(components){
  var itr, node;
  if (components.isEmpty()) {
    return;
  }
  node = castTo(components.get_3(0), 156).owner;
  new SplineSelfLoopPositioner$PortReadder(components);
  itr = new AbstractList$ListIteratorImpl(node.ports, 0);
  $addSourcePortsReversed(($clinit_LoopSide() , NW), itr);
  $addTargetPorts(SWN, itr);
  $findNextSide(($clinit_PortSide() , NORTH_1), itr);
  $addInlineTargetsFirst(N, itr);
  $addTargetPorts(SEN, itr);
  $addAllPorts(EN, itr);
  $addSourcePortsReversed(ENW, itr);
  $findNextSide(EAST_1, itr);
  $addInlineTargetsFirst(E_0, itr);
  $addSourcePortsReversed(ESW, itr);
  $addAllPorts(SE, itr);
  $addSourcePortsReversed(SEN, itr);
  $findNextSide(SOUTH_1, itr);
  $addInlineTargetsFirst(S, itr);
  $addSourcePortsReversed(SWN, itr);
  $addAllPorts(WS, itr);
  $addTargetPorts(ESW, itr);
  while (itr.i < itr.this$01_0.size_1()) {
    checkCriticalElement(itr.i < itr.this$01_0.size_1());
    itr.this$01_0.get_3(itr.last = itr.i++);
  }
  $addInlineTargetsFirst(W, itr);
  $addTargetPorts(ENW, itr);
  $addTargetPorts(NW, itr);
}

function $portStackedPositioning(components){
  var itr, node;
  if (components.isEmpty()) {
    return;
  }
  node = castTo(components.get_3(0), 156).owner;
  new SplineSelfLoopPositioner$PortReadder(components);
  itr = new AbstractList$ListIteratorImpl(node.ports, 0);
  $addSourcePortsReversed(($clinit_LoopSide() , NW), itr);
  $addTargetPorts(SWN, itr);
  $findNextSide(($clinit_PortSide() , NORTH_1), itr);
  $addAllPorts(N, itr);
  $addTargetPorts(SEN, itr);
  $addAllPorts(EN, itr);
  $addSourcePortsReversed(ENW, itr);
  $findNextSide(EAST_1, itr);
  $addAllPorts(E_0, itr);
  $addSourcePortsReversed(ESW, itr);
  $addAllPorts(SE, itr);
  $addSourcePortsReversed(SEN, itr);
  $findNextSide(SOUTH_1, itr);
  $addAllPorts(S, itr);
  $addSourcePortsReversed(SWN, itr);
  $addAllPorts(WS, itr);
  $addTargetPorts(ESW, itr);
  while (itr.i < itr.this$01_0.size_1()) {
    checkCriticalElement(itr.i < itr.this$01_0.size_1());
    itr.this$01_0.get_3(itr.last = itr.i++);
  }
  $addAllPorts(W, itr);
  $addTargetPorts(ENW, itr);
  $addTargetPorts(NW, itr);
}

function $process_49(layeredGraph, monitor){
  var component, component$iterator, component$iterator0, component$iterator1, components, componentsToBePlaced, layer, layer$iterator, loopPlacement, node, node$iterator, constrainedPorts, loopSideCalculator;
  $begin(monitor, 'Spline SelfLoop positioning', 1);
  loopPlacement = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , EDGE_ROUTING_SELF_LOOP_PLACEMENT_0)), 358);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      components = castTo($getProperty(node, ($clinit_InternalProperties_1() , SPLINE_SELFLOOP_COMPONENTS)), 15);
      componentsToBePlaced = new ArrayList;
      for (component$iterator0 = components.iterator_0(); component$iterator0.hasNext_0();) {
        component = castTo(component$iterator0.next_1(), 156);
        $unhideEdges(component);
        if ((constrainedPorts = newHashSet(component.portsWithNonLoopEdge) , $addAll(constrainedPorts, component.portsWithPortSide) , constrainedPorts).map_0.size_1() == 0) {
          componentsToBePlaced.array[componentsToBePlaced.array.length] = component;
        }
         else {
          $setPortSideByConstraint(component);
          component.portsWithNonLoopEdge.map_0.size_1() == 0 || $addComponentWithNonLoopEdges(component);
        }
      }
      switch (loopPlacement.ordinal) {
        case 0:
          loopSideCalculator = new SplineSelfLoopPositioner$DistributedLoopSidesCalculator(node);
          $removeOccupiedSides(loopSideCalculator);
          $calculate(loopSideCalculator, componentsToBePlaced);
          break;
        case 2:
          for (component$iterator1 = new ArrayList$1(componentsToBePlaced); component$iterator1.i < component$iterator1.this$01.array.length;) {
            component = castTo($next_10(component$iterator1), 156);
            $setLoopSide(component, ($clinit_LoopSide() , N), true);
          }

          break;
        case 1:
          for (component$iterator = new ArrayList$1(componentsToBePlaced); component$iterator.i < component$iterator.this$01.array.length;) {
            component = castTo($next_10(component$iterator), 156);
            $setLoopSide(component, ($clinit_LoopSide() , N), true);
          }

      }
      switch (loopPlacement.ordinal) {
        case 0:
        case 1:
          $portStackedPositioning(components);
          break;
        case 2:
          $portLinedPositioning(components);
      }
    }
  }
  $done_0(monitor);
}

function $setPortSideByConstraint(component){
  var all, edge, iter, loopSidesInComponent, side, side0, sourceSide, targetSide;
  iter = cycle(newArrayList(component.edges));
  loopSidesInComponent = (all = castTo($getEnumConstants(Lorg_eclipse_elk_alg_layered_p5edges_splines_LoopSide_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  while (iter.iterator.hasNext_0() || iter.val$iterable1.iterator_0().hasNext_0()) {
    edge = castTo($next_1(iter), 16);
    sourceSide = edge.source.side;
    targetSide = edge.target.side;
    if (sourceSide == ($clinit_PortSide() , UNDEFINED_7)) {
      if (targetSide != UNDEFINED_7) {
        side0 = fromPortSides(targetSide);
        $setProperty_0(edge, ($clinit_InternalProperties_1() , SPLINE_LOOPSIDE), side0);
        $setSide(edge.source, targetSide);
        $add_5(loopSidesInComponent, side0);
        iter.iterator.remove_0();
      }
    }
     else {
      if (targetSide == UNDEFINED_7) {
        side0 = fromPortSides(sourceSide);
        $setProperty_0(edge, ($clinit_InternalProperties_1() , SPLINE_LOOPSIDE), side0);
        $setSide(edge.target, sourceSide);
        $add_5(loopSidesInComponent, side0);
        iter.iterator.remove_0();
      }
       else {
        side0 = fromPortSide(sourceSide, targetSide);
        $setProperty_0(edge, ($clinit_InternalProperties_1() , SPLINE_LOOPSIDE), side0);
        $add_5(loopSidesInComponent, side0);
        iter.iterator.remove_0();
      }
    }
  }
  loopSidesInComponent.size_0 == 1?(side = castTo($next_11(new EnumSet$EnumSetImpl$IteratorImpl(loopSidesInComponent)), 132)):(side = ($clinit_LoopSide() , UNDEFINED_1));
  $setLoopSide(component, side, false);
  return side;
}

function SplineSelfLoopPositioner(){
}

function setSideOfPort(port, side){
  switch (side.ordinal) {
    case 2:
      $setSide(port, ($clinit_PortSide() , EAST_1));
      port.anchor.x_0 = port.size_0.x_0;
      port.anchor.y_0 = port.size_0.y_0 / 2;
      break;
    case 4:
      $setSide(port, ($clinit_PortSide() , WEST_1));
      port.anchor.x_0 = 0;
      port.anchor.y_0 = port.size_0.y_0 / 2;
      break;
    case 1:
      $setSide(port, ($clinit_PortSide() , NORTH_1));
      port.anchor.x_0 = port.size_0.x_0 / 2;
      port.anchor.y_0 = 0;
      break;
    case 3:
      $setSide(port, ($clinit_PortSide() , SOUTH_1));
      port.anchor.x_0 = port.size_0.x_0 / 2;
      port.anchor.y_0 = port.size_0.y_0;
  }
}

function setSideOfPorts(ports, side){
  var port, port$iterator;
  for (port$iterator = new ArrayList$1(ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    setSideOfPort(port, side);
  }
}

defineClass(1461, 1, $intern_108, SplineSelfLoopPositioner);
_.process = function process_44(layeredGraph, monitor){
  $process_49(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopPositioner_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopPositioner', 1461);
function $assignAcrossSide(this$static, components){
  var component, component$iterator, side;
  for (component$iterator = new ArrayList$1(components); component$iterator.i < component$iterator.this$01.array.length;) {
    component = castTo($next_10(component$iterator), 156);
    side = $getLeastCrowdedHorizontalCrossing(this$static.loopSides);
    $addSize(this$static.loopSides, side, component.textWidth, component.textHeight);
    $setLoopSide(component, side, true);
  }
}

function $assignCornerSide(this$static, components){
  var component, component$iterator, side;
  for (component$iterator = new ArrayList$1(components); component$iterator.i < component$iterator.this$01.array.length;) {
    component = castTo($next_10(component$iterator), 156);
    side = $getLeastCrowdedCorner(this$static.loopSides);
    $addSize(this$static.loopSides, side, component.textWidth, component.textHeight);
    $setLoopSide(component, side, true);
  }
}

function $calculate(this$static, components){
  var availableStraights, center, component, component$iterator, fullSets, i, itrAvailable, itrComponent, itrComponent0, itrSides, number, portSides, remainer, side, tmpSide, withLongText, withShortText, withoutText;
  withLongText = new ArrayList;
  withShortText = new ArrayList;
  withoutText = new ArrayList;
  for (component$iterator = new ArrayList$1(components); component$iterator.i < component$iterator.this$01.array.length;) {
    component = castTo($next_10(component$iterator), 156);
    component.textWidth > 50?(withLongText.array[withLongText.array.length] = component , true):component.textWidth > 0?(withShortText.array[withShortText.array.length] = component , true):(withoutText.array[withoutText.array.length] = component , true);
  }
  if (withShortText.array.length == 1 && withLongText.array.length == 0) {
    $addAll_2(withLongText, withShortText);
    withShortText.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  }
  withLongText.array.length != 0 && $containsEnum($availableSides(this$static.loopSides), ($clinit_LoopSide() , N)) && $containsEnum($availableSides(this$static.loopSides), ($clinit_LoopSide() , S))?$assignAcrossSide(this$static, withLongText):$addAll_2(withShortText, withLongText);
  withShortText.array.length == 0 || $assignCornerSide(this$static, withShortText);
  if (withoutText.array.length != 0) {
    availableStraights = $availableStraightSides(this$static.loopSides);
    if (availableStraights.size_0 != 0) {
      itrComponent0 = new ArrayList$1(withoutText);
      itrAvailable = (checkNotNull(availableStraights) , cycle((new Iterables$1(availableStraights)).val$iterable1));
      while (itrComponent0.i < itrComponent0.this$01.array.length) {
        component = castTo($next_10(itrComponent0), 156);
        while (itrComponent0.i < itrComponent0.this$01.array.length && component.edges.map_0.size_1() < 2) {
          component = castTo($next_10(itrComponent0), 156);
        }
        if (component.edges.map_0.size_1() > 1) {
          side = castTo($next_1(itrAvailable), 132);
          $setLoopSide(component, side, true);
          $remove_14(itrComponent0);
          $removeSide(this$static.loopSides, side);
        }
      }
    }
    number = withoutText.array.length;
    center = $findCenter(this$static);
    portSides = new ArrayList;
    fullSets = number / $availableNotAcrossSides(this$static.loopSides).size_0 | 0;
    for (i = 0; i < fullSets; i++) {
      $addAll_2(portSides, $availableNotAcrossSides(this$static.loopSides));
    }
    remainer = number % $availableNotAcrossSides(this$static.loopSides).size_0;
    if (remainer > 3) {
      $addAll_2(portSides, ($clinit_LoopSide() , $clinit_LoopSide() , ALL_CORNERS));
      remainer -= 4;
    }
    switch (remainer) {
      case 3:
        $add_4(portSides, $opposite(center));
      case 2:
        tmpSide = $left($opposite(center));
        do {
          tmpSide = $left(tmpSide);
        }
         while (!$containsEnum($availableSides(this$static.loopSides), tmpSide));
        portSides.array[portSides.array.length] = tmpSide;
        tmpSide = $right($opposite(center));
        do {
          tmpSide = $right(tmpSide);
        }
         while (!$containsEnum($availableSides(this$static.loopSides), tmpSide));
        portSides.array[portSides.array.length] = tmpSide;
        break;
      case 1:
        $add_4(portSides, $opposite(center));
    }
    itrSides = new ArrayList$1(portSides);
    itrComponent = new ArrayList$1(withoutText);
    while (itrSides.i < itrSides.this$01.array.length && itrComponent.i < itrComponent.this$01.array.length) {
      $setLoopSide(castTo($next_10(itrComponent), 156), castTo($next_10(itrSides), 132), true);
    }
  }
}

function $findCenter(this$static){
  var first, itr, retVal, second;
  switch ($availableStraightSides(this$static.loopSides).size_0) {
    case 4:
      return $clinit_LoopSide() , S;
    case 3:
      return castTo($allRemovedStraightSides(this$static.loopSides).iterator_0().next_1(), 132);
    case 2:
      retVal = $availableStraightSides(this$static.loopSides);
      itr = new EnumSet$EnumSetImpl$IteratorImpl(retVal);
      first = castTo($next_11(itr), 132);
      second = castTo($next_11(itr), 132);
      return $opposite(first) == second?$containsEnum(retVal, ($clinit_LoopSide() , S))?E_0:S:$left($left(first)) == second?$left(first):$right(first);
    case 1:
      retVal = $availableStraightSides(this$static.loopSides);
      return $opposite(castTo($next_11(new EnumSet$EnumSetImpl$IteratorImpl(retVal)), 132));
    case 0:
      return $clinit_LoopSide() , SE;
    default:return null;
  }
}

function $removeOccupiedSides(this$static){
  var port, port$iterator;
  for (port$iterator = new ArrayList$1(this$static.node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $removeSide(this$static.loopSides, fromPortSides(port.side));
  }
}

function SplineSelfLoopPositioner$DistributedLoopSidesCalculator(node){
  this.loopSides = new SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides;
  this.node = node;
}

defineClass(1463, 1, {}, SplineSelfLoopPositioner$DistributedLoopSidesCalculator);
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopPositioner$DistributedLoopSidesCalculator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopPositioner/DistributedLoopSidesCalculator', 1463);
function $addSize(this$static, side, addedWidth, addedHeight){
  var size_0;
  size_0 = castTo($get_12(this$static.sizeMap, side), 259);
  size_0.width_0 += addedWidth;
  size_0.height += addedHeight;
  $put_6(this$static.sizeMap, side, size_0);
  this$static.sideRemovedOrChanged = true;
}

function $allRemovedStraightSides(this$static){
  var retVal;
  retVal = ($clinit_LoopSide() , $clinit_LoopSide() , ALL_STRAIGHTS);
  this$static.sideRemovedOrChanged && $updateAvailableSides(this$static);
  $removeAll_1();
  return retVal;
}

function $availableNotAcrossSides(this$static){
  this$static.sideRemovedOrChanged && $updateAvailableSides(this$static);
  return this$static.availableNotAcrossSides;
}

function $availableSides(this$static){
  this$static.sideRemovedOrChanged && $updateAvailableSides(this$static);
  return this$static.availableSides;
}

function $availableStraightSides(this$static){
  this$static.sideRemovedOrChanged && $updateAvailableSides(this$static);
  return this$static.availableStraightSides;
}

function $getLeastCrowdedCorner(this$static){
  var entry, entry$iterator, height, isLessHigh, isNotHigherAndLessWide, minHeight, minSide, minWidth, width_0;
  minHeight = $intern_62;
  minWidth = $intern_62;
  minSide = null;
  for (entry$iterator = new LinkedHashMap$EntrySet$EntryIterator(new LinkedHashMap$EntrySet(this$static.sizeMap)); entry$iterator.next_0 != entry$iterator.this$11.this$01.head;) {
    entry = $next_12(entry$iterator);
    if (castTo(entry.key, 132).type_0 == 1) {
      height = castTo(entry.value_0, 259).height;
      width_0 = castTo(entry.value_0, 259).width_0;
      isLessHigh = minHeight - height > $intern_113;
      isNotHigherAndLessWide = height - minHeight < $intern_113 && minWidth - width_0 > $intern_113;
      if (isLessHigh || isNotHigherAndLessWide) {
        minWidth = castTo(entry.value_0, 259).width_0;
        minHeight = castTo(entry.value_0, 259).height;
        minSide = castTo(entry.key, 132);
        if (minWidth == 0 && minHeight == 0) {
          return minSide;
        }
      }
    }
  }
  return minSide;
}

function $getLeastCrowdedHorizontalCrossing(this$static){
  var entry, entry$iterator, height, isLessHigh, isNotHigherAndLessWide, minHeight, minSide, minWidth, width_0;
  minHeight = $intern_62;
  minWidth = $intern_62;
  minSide = null;
  for (entry$iterator = new LinkedHashMap$EntrySet$EntryIterator(new LinkedHashMap$EntrySet(this$static.sizeMap)); entry$iterator.next_0 != entry$iterator.this$11.this$01.head;) {
    entry = $next_12(entry$iterator);
    if (maskUndefined(entry.key) === maskUndefined(($clinit_LoopSide() , ENW)) || maskUndefined(entry.key) === maskUndefined(ESW)) {
      height = castTo(entry.value_0, 259).height;
      width_0 = castTo(entry.value_0, 259).width_0;
      isLessHigh = minHeight - height > $intern_113;
      isNotHigherAndLessWide = height - minHeight < $intern_113 && minWidth - width_0 > $intern_113;
      if (isLessHigh || isNotHigherAndLessWide) {
        minWidth = castTo(entry.value_0, 259).width_0;
        minHeight = castTo(entry.value_0, 259).height;
        minSide = castTo(entry.key, 132);
        if (minWidth == 0 && minHeight == 0) {
          return minSide;
        }
      }
    }
  }
  return minSide;
}

function $removeSide(this$static, side){
  var wasRemoved;
  wasRemoved = castTo($remove_22(this$static.sizeMap, side), 259);
  !!wasRemoved && (this$static.sideRemovedOrChanged = true);
}

function $updateAvailableSides(this$static){
  var entry, outerIter, side, side$iterator;
  $clear_1(this$static.availableStraightSides);
  $clear_1(this$static.availableSides);
  $clear_1(this$static.availableNotAcrossSides);
  for (side$iterator = (outerIter = (new AbstractMap$1(this$static.sizeMap)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); side$iterator.val$outerIter2.hasNext_0();) {
    side = (entry = castTo(side$iterator.val$outerIter2.next_1(), 39) , castTo(entry.getKey(), 132));
    if (side.type_0 != 2) {
      $add_5(this$static.availableNotAcrossSides, side);
      side.type_0 == 0 && $add_5(this$static.availableStraightSides, side);
    }
    $add_5(this$static.availableSides, side);
  }
  this$static.sideRemovedOrChanged = false;
}

function SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides(){
  var side, side$iterator, all0, all1, all;
  this.sizeMap = ($clinit_Maps() , new LinkedHashMap);
  this.availableSides = (all0 = castTo($getEnumConstants(Lorg_eclipse_elk_alg_layered_p5edges_splines_LoopSide_2_classLit), 10) , new EnumSet$EnumSetImpl(all0, castTo(createFrom(all0, all0.length), 10), 0));
  this.availableStraightSides = (all1 = castTo($getEnumConstants(Lorg_eclipse_elk_alg_layered_p5edges_splines_LoopSide_2_classLit), 10) , new EnumSet$EnumSetImpl(all1, castTo(createFrom(all1, all1.length), 10), 0));
  this.availableNotAcrossSides = (all = castTo($getEnumConstants(Lorg_eclipse_elk_alg_layered_p5edges_splines_LoopSide_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  for (side$iterator = ($clinit_LoopSide() , $clinit_LoopSide() , ALL).iterator_0(); side$iterator.hasNext_0();) {
    side = castTo(side$iterator.next_1(), 132);
    $put_6(this.sizeMap, side, new SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides$SizeOfSide);
  }
}

defineClass(1464, 1, {}, SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides);
_.sideRemovedOrChanged = true;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopPositioner/DistributedLoopSidesCalculator/SortedLoopSides', 1464);
function SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides$SizeOfSide(){
  this.width_0 = 0;
  this.height = 0;
}

defineClass(259, 1, {259:1}, SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides$SizeOfSide);
_.height = 0;
_.width_0 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopPositioner$DistributedLoopSidesCalculator$SortedLoopSides$SizeOfSide_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopPositioner/DistributedLoopSidesCalculator/SortedLoopSides/SizeOfSide', 259);
function $clinit_SplineSelfLoopPositioner$PortReadder(){
  $clinit_SplineSelfLoopPositioner$PortReadder = emptyMethod;
  var side, side$array, side$index, side$max;
  LISTS_OF_COMPONENTS = new EnumMap(Lorg_eclipse_elk_alg_layered_p5edges_splines_LoopSide_2_classLit);
  for (side$array = values_60() , side$index = 0 , side$max = side$array.length; side$index < side$max; ++side$index) {
    side = side$array[side$index];
    $put_3(LISTS_OF_COMPONENTS, side, null);
  }
}

function $addAllPorts(loopSide, itr){
  var component, component$iterator, port, port$iterator, port$iterator0, secondPart, secondPartSide;
  secondPart = new ArrayList;
  secondPartSide = null;
  for (component$iterator = castTo($get_10(LISTS_OF_COMPONENTS, loopSide), 15).iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 156);
    for (port$iterator0 = component.exclusiveLoopTargetPorts.map_0.keySet_0().iterator_0(); port$iterator0.hasNext_0();) {
      port = castTo(port$iterator0.next_1(), 11);
      $add_2(itr, port);
      setSideOfPort(port, loopSide.target);
    }
    $addAll_2(secondPart, component.exclusiveLoopSourcePorts);
    secondPartSide = loopSide.source;
  }
  reverse_2(secondPart);
  setSideOfPorts(secondPart, secondPartSide);
  for (port$iterator = new ArrayList$1(secondPart); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $add_2(itr, port);
  }
}

function $addInlineTargetsFirst(loopSide, itr){
  var compItr, component, firstPart, port, port$iterator, port$iterator0, secondPart;
  firstPart = new ArrayList;
  secondPart = new ArrayList;
  compItr = castTo($get_10(LISTS_OF_COMPONENTS, loopSide), 15).iterator_0();
  while (compItr.hasNext_0()) {
    component = castTo(compItr.next_1(), 156);
    $addAll_1(firstPart, component.exclusiveLoopSourcePorts);
    $addAll_1(firstPart, $getTargetLoopPortsReversed(component));
    if (compItr.hasNext_0()) {
      component = castTo(compItr.next_1(), 156);
      $addAll_2(secondPart, $getTargetLoopPortsReversed(component));
      $addAll_2(secondPart, component.exclusiveLoopSourcePorts);
    }
  }
  setSideOfPorts(firstPart, loopSide.target);
  setSideOfPorts(secondPart, loopSide.source);
  for (port$iterator0 = new ArrayList$1(firstPart); port$iterator0.i < port$iterator0.this$01.array.length;) {
    port = castTo($next_10(port$iterator0), 11);
    $add_2(itr, port);
  }
  for (port$iterator = new ArrayList$1(secondPart); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $add_2(itr, port);
  }
}

function $addSourcePortsReversed(loopSide, itr){
  var component, component$iterator, port, port$iterator, sourcePorts;
  sourcePorts = new ArrayList;
  for (component$iterator = castTo($get_10(LISTS_OF_COMPONENTS, loopSide), 15).iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 156);
    $addAll_2(sourcePorts, component.exclusiveLoopSourcePorts);
  }
  reverse_2(sourcePorts);
  setSideOfPorts(sourcePorts, loopSide.source);
  for (port$iterator = new ArrayList$1(sourcePorts); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $add_2(itr, port);
  }
}

function $addTargetPorts(loopSide, itr){
  var component, component$iterator, port, port$iterator, portSide;
  portSide = loopSide.target;
  for (component$iterator = castTo($get_10(LISTS_OF_COMPONENTS, loopSide), 15).iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 156);
    for (port$iterator = component.exclusiveLoopTargetPorts.map_0.keySet_0().iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 11);
      $add_2(itr, port);
      setSideOfPort(port, portSide);
    }
  }
}

function SplineSelfLoopPositioner$PortReadder(components){
  $clinit_SplineSelfLoopPositioner$PortReadder();
  var component, component$iterator, entry, list, list$iterator, outerIter, side, side$array, side$index, side$max;
  this.loopSorter = new SplineSelfLoopPositioner$TextWidthComparator;
  this.withNonSelfLoop = new ArrayList;
  this.allHiddenPorts = new ArrayList;
  for (side$array = values_60() , side$index = 0 , side$max = side$array.length; side$index < side$max; ++side$index) {
    side = side$array[side$index];
    $put_3(LISTS_OF_COMPONENTS, side, new ArrayList);
  }
  for (component$iterator = components.iterator_0(); component$iterator.hasNext_0();) {
    component = castTo(component$iterator.next_1(), 156);
    $addAll_2(this.allHiddenPorts, $getHidablePorts(component));
    component.portsWithNonLoopEdge.map_0.size_1() == 0?castTo($get_10(LISTS_OF_COMPONENTS, component.loopSide), 15).add_1(component):$add_4(this.withNonSelfLoop, component);
  }
  for (list$iterator = (outerIter = (new AbstractMap$2(LISTS_OF_COMPONENTS)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter)); list$iterator.val$outerIter2.hasNext_0();) {
    list = (entry = castTo(list$iterator.val$outerIter2.next_1(), 39) , castTo(entry.getValue(), 15));
    $clinit_Collections();
    list.sort_0(this.loopSorter);
  }
  reverse_2(castTo($get_10(LISTS_OF_COMPONENTS, ($clinit_LoopSide() , NW)), 15));
}

defineClass(737, 1, {}, SplineSelfLoopPositioner$PortReadder);
var LISTS_OF_COMPONENTS;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopPositioner$PortReadder_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopPositioner/PortReadder', 737);
function $compare_14(loop0, loop1){
  return compare_5(loop1.textWidth, loop0.textWidth);
}

function SplineSelfLoopPositioner$TextWidthComparator(){
}

defineClass(1462, 1, $intern_40, SplineSelfLoopPositioner$TextWidthComparator);
_.compare_0 = function compare_50(loop0, loop1){
  return $compare_14(castTo(loop0, 156), castTo(loop1, 156));
}
;
_.equals_0 = function equals_130(other){
  return this === other;
}
;
_.reversed = function reversed_42(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopPositioner$TextWidthComparator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopPositioner/TextWidthComparator', 1462);
function $correctPortSideConstraint(node){
  var port, port$iterator;
  if (!$isSideFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      $setSide(port, ($clinit_PortSide() , UNDEFINED_7));
    }
  }
}

function $process_50(layeredGraph, monitor){
  var allComponents, component, component$iterator, edge, edge$iterator, edge$iterator0, hidingPortsAllowed, itr, loopEdges, node, node$iterator, old, port, portsToHide, sourcePortSide, targetPortSide;
  $begin(monitor, 'Spline SelfLoop pre-processing.', 1);
  loopEdges = new LinkedHashSet;
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $correctPortSideConstraint(node);
    loopEdges.map_0.clear_0();
    for (edge$iterator0 = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator0);) {
      edge = castTo($next_2(edge$iterator0), 16);
      $isSelfLoop(edge) && (old = loopEdges.map_0.put(edge, loopEdges) , old == null);
    }
    for (edge$iterator = loopEdges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
      edge = castTo(edge$iterator.next_1(), 16);
      sourcePortSide = edge.source.side;
      targetPortSide = edge.target.side;
      (sourcePortSide == ($clinit_PortSide() , NORTH_1) && (targetPortSide == EAST_1 || targetPortSide == SOUTH_1) || sourcePortSide == EAST_1 && targetPortSide == SOUTH_1 || sourcePortSide == SOUTH_1 && targetPortSide == WEST_1 || sourcePortSide == WEST_1 && (targetPortSide == NORTH_1 || targetPortSide == EAST_1)) && $reverse_0(edge, false);
    }
    allComponents = findAllConnectedComponents(loopEdges, node);
    $setProperty_0(node, ($clinit_InternalProperties_1() , SPLINE_SELFLOOP_COMPONENTS), allComponents);
    hidingPortsAllowed = !($isOrderFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83)) || maskUndefined($getProperty(node, HIERARCHY_HANDLING)) === maskUndefined(($clinit_HierarchyHandling() , INCLUDE_CHILDREN)));
    if (hidingPortsAllowed) {
      portsToHide = new HashSet;
      for (component$iterator = new ArrayList$1(allComponents); component$iterator.i < component$iterator.this$01.array.length;) {
        component = castTo($next_10(component$iterator), 156);
        $addAll(portsToHide, $getHidablePorts(component));
        $addAll(portsToHide, component.portsWithPortSide);
      }
      itr = new AbstractList$ListIteratorImpl(node.ports, 0);
      while (itr.i < itr.this$01_0.size_1()) {
        port = (checkCriticalElement(itr.i < itr.this$01_0.size_1()) , castTo(itr.this$01_0.get_3(itr.last = itr.i++), 11));
        portsToHide.map_0.containsKey(port) && $remove_9(itr);
      }
    }
  }
  $done_0(monitor);
}

function SplineSelfLoopPreProcessor(){
}

function findAConnectedComponent(portsToEdges, node, isFixedOrder){
  var allEdgesOnCurrentPort, connectedComponent, currentEdge, currentEdge$iterator, currentPort, edgeToPort, port, port$iterator, portsOfCurrentEdge, portsProcessed, portsToProcess, result;
  edgeToPort = new ArrayListMultimap;
  invertFrom(portsToEdges, edgeToPort);
  connectedComponent = new ConnectedSelfLoopComponent(node);
  portsToProcess = new ArrayList;
  $add_4(portsToProcess, castTo($next_0($iterator_2((result = portsToEdges.keys_0 , !result?(portsToEdges.keys_0 = new Multimaps$Keys(portsToEdges)):result))), 11));
  portsProcessed = new ArrayList;
  while (portsToProcess.array.length != 0) {
    currentPort = castTo($next_10(new ArrayList$1(portsToProcess)), 11);
    portsProcessed.array[portsProcessed.array.length] = currentPort;
    allEdgesOnCurrentPort = $removeAll_2(portsToEdges, currentPort);
    for (currentEdge$iterator = new Collections$UnmodifiableCollectionIterator(allEdgesOnCurrentPort.coll.iterator_0()); currentEdge$iterator.it.hasNext_0();) {
      currentEdge = castTo(currentEdge$iterator.it.next_1(), 16);
      if ($tryAddEdge(connectedComponent, currentEdge, isFixedOrder)) {
        portsOfCurrentEdge = castTo($removeAll(edgeToPort, currentEdge), 15);
        for (port$iterator = portsOfCurrentEdge.iterator_0(); port$iterator.hasNext_0();) {
          port = castTo(port$iterator.next_1(), 11);
          $indexOf_3(portsProcessed, port, 0) != -1 || (portsToProcess.array[portsToProcess.array.length] = port , true);
        }
      }
    }
    $remove_13(portsToProcess, currentPort);
  }
  return connectedComponent;
}

function findAllConnectedComponents(loopEdges, node){
  var components, edge, edge$iterator, portToEdge;
  components = new ArrayList;
  portToEdge = new LinkedListMultimap;
  for (edge$iterator = loopEdges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
    edge = castTo(edge$iterator.next_1(), 16);
    $addNode(portToEdge, edge.source, edge, null);
    $addNode(portToEdge, edge.target, edge, null);
  }
  while (portToEdge.head) {
    $add_4(components, findAConnectedComponent(portToEdge, node, $isOrderFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))));
  }
  return components;
}

defineClass(1465, 1, $intern_108, SplineSelfLoopPreProcessor);
_.process = function process_45(layeredGraph, monitor){
  $process_50(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopPreProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopPreProcessor', 1465);
function $calculateAcrossSelfLoop(edge, sourcePadding, middlePadding, targetPadding){
  var edgeMargins, label_0, label$iterator, labelMargins, nubs, textLength;
  textLength = 0;
  for (label$iterator = new ArrayList$1(edge.lEdge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 70);
    textLength = $wnd.Math.max(textLength, label_0.size_0.x_0);
  }
  nubs = createAcrossSelfLoop(edge.lEdge.source, sourcePadding, edge.lEdge.target, targetPadding, $getMiddleSide(edge.loopSide), middlePadding);
  $addAll(edge.lEdge.bendPoints, $getBezierCP(nubs));
  labelMargins = $placeLabels_1(edge.lEdge.labels, nubs.firstLabelPosition, edge.loopSide);
  edgeMargins = new Rectangle_2((!nubs.outerBox && (nubs.outerBox = new Rectangle_0($getControlPoints(nubs))) , nubs.outerBox));
  $enlarge(edgeMargins);
  return !labelMargins?edgeMargins:union(edgeMargins, labelMargins);
}

function $calculateCornerSelfLoop(edge, sourcePadding, targetPadding){
  var edgeMargins, label_0, label$iterator, labelLength, labelMargins, nubs, side;
  side = edge.loopSide;
  labelLength = 0;
  for (label$iterator = new ArrayList$1(edge.lEdge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 70);
    labelLength = $wnd.Math.max(labelLength, label_0.size_0.x_0);
  }
  nubs = createCornerSelfLoop(edge.lEdge.source, edge.lEdge.target, sourcePadding, targetPadding, labelLength);
  $addAll(edge.lEdge.bendPoints, $getBezierCP(nubs));
  labelMargins = $placeLabels_1(edge.lEdge.labels, nubs.firstLabelPosition, side);
  edgeMargins = new Rectangle_2((!nubs.outerBox && (nubs.outerBox = new Rectangle_0($getControlPoints(nubs))) , nubs.outerBox));
  $enlarge(edgeMargins);
  return !labelMargins?edgeMargins:union(edgeMargins, labelMargins);
}

function $placeLabel(label_0, rawPosition, side){
  var labelSize, thisLabelPosition;
  thisLabelPosition = new KVector_2(rawPosition);
  labelSize = new KVector_2(label_0.size_0);
  switch (side.ordinal) {
    case 1:
    case 8:
    case 7:
      $add_18(thisLabelPosition, -labelSize.x_0 / 2, -labelSize.y_0);
      $add_18(rawPosition, 0, -(0.5 + labelSize.y_0));
      break;
    case 3:
    case 4:
    case 5:
      $add_18(thisLabelPosition, -labelSize.x_0 / 2, 0);
      $add_18(rawPosition, 0, 0.5 + labelSize.y_0);
      break;
    case 0:
      $add_18(thisLabelPosition, -labelSize.x_0 / 2, -labelSize.y_0);
      $add_18(rawPosition, 0, -(0.5 + -labelSize.y_0));
      break;
    case 10:
    case 2:
      $add_18(thisLabelPosition, 0, -labelSize.y_0 / 2);
      $add_18(rawPosition, 0, -(0.5 + labelSize.y_0));
      break;
    case 6:
      $add_18(thisLabelPosition, -labelSize.x_0, labelSize.y_0 / 2);
      $add_18(rawPosition, 0, -(0.5 + labelSize.y_0));
      break;
    case 9:
      $add_18(thisLabelPosition, -labelSize.x_0 / 2, 0);
      $add_18(rawPosition, 0, -(0.5 + labelSize.y_0));
      break;
    case 11:
      $add_18(thisLabelPosition, -labelSize.x_0, -labelSize.y_0 / 2);
      $add_18(rawPosition, 0, -(0.5 + labelSize.y_0));
  }
  $add_19($reset_5(label_0.pos), thisLabelPosition);
  return new Rectangle_1(label_0);
}

function $placeLabels_1(labels, rawPosition, side){
  var allLabels, iter, label_0;
  iter = new ArrayList$1(labels);
  if (iter.i < iter.this$01.array.length) {
    label_0 = castTo($next_10(iter), 70);
    allLabels = $placeLabel(label_0, rawPosition, side);
    while (iter.i < iter.this$01.array.length) {
      label_0 = castTo($next_10(iter), 70);
      $union(allLabels, $placeLabel(label_0, rawPosition, side));
    }
    return new Rectangle_2(allLabels);
  }
   else {
    return null;
  }
}

function $process_51(layeredGraph, monitor){
  var component, component$iterator, currentPort, edge, edge$iterator, found, index_0, iter, layer, layer$iterator, loopEdges, loopIter, loopPaddings, loopRectangle, node, node$iterator, ports, selfLoops, side, sourceIndex, sourcePort, stepSize, stepSizeComparator, targetIndex, targetPort, retVal, shapeRectangle;
  $begin(monitor, 'Spline SelfLoop routing', 1);
  stepSizeComparator = new SplineSelfLoopRouter$SelfLoopEdge$StepSizeComparator;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      ports = node.ports;
      loopEdges = new LinkedHashSet;
      for (component$iterator = castTo($getProperty(node, ($clinit_InternalProperties_1() , SPLINE_SELFLOOP_COMPONENTS)), 15).iterator_0(); component$iterator.hasNext_0();) {
        component = castTo(component$iterator.next_1(), 156);
        $addAll(loopEdges, component.edges);
      }
      selfLoops = new ArrayList;
      for (edge$iterator = loopEdges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
        edge = castTo(edge$iterator.next_1(), 16);
        sourcePort = edge.source;
        targetPort = edge.target;
        iter = new ArrayList$1(edge.source.owner.ports);
        sourceIndex = 0;
        targetIndex = 0;
        found = 0;
        index_0 = 0;
        while (found < 2) {
          currentPort = castTo($next_10(iter), 11);
          if (sourcePort == currentPort) {
            sourceIndex = index_0;
            ++found;
          }
          if (targetPort == currentPort) {
            targetIndex = index_0;
            ++found;
          }
          ++index_0;
        }
        side = castTo($getProperty(edge, SPLINE_LOOPSIDE), 132);
        stepSize = side == ($clinit_LoopSide() , NW) || side == ENW?ports.array.length - (targetIndex - sourceIndex < 0?-(targetIndex - sourceIndex):targetIndex - sourceIndex) + 1:targetIndex - sourceIndex < 0?-(targetIndex - sourceIndex):targetIndex - sourceIndex;
        $add_4(selfLoops, new SplineSelfLoopRouter$SelfLoopEdge(sourceIndex, targetIndex, stepSize, side, edge));
      }
      $clinit_Collections();
      sort_4(selfLoops.array, selfLoops.array.length, stepSizeComparator);
      loopPaddings = new HashSet;
      loopIter = new ArrayList$1(selfLoops);
      if (loopIter.i < loopIter.this$01.array.length) {
        loopRectangle = $processSelfLoop(castTo($next_10(loopIter), 431), loopPaddings);
        while (loopIter.i < loopIter.this$01.array.length) {
          $union(loopRectangle, $processSelfLoop(castTo($next_10(loopIter), 431), loopPaddings));
        }
        $setProperty_0(node, SPLINE_SELF_LOOP_MARGINS, (retVal = new ElkMargin , shapeRectangle = new Rectangle(node.size_0.x_0, node.size_0.y_0) , retVal.top_0 = $wnd.Math.max(0, shapeRectangle.top_0 - loopRectangle.top_0) , retVal.left = $wnd.Math.max(0, shapeRectangle.left - loopRectangle.left) , retVal.bottom = $wnd.Math.max(0, loopRectangle.bottom - shapeRectangle.bottom) , retVal.right = $wnd.Math.max(0, loopRectangle.right - shapeRectangle.right) , retVal));
      }
    }
  }
  $done_0(monitor);
}

function $processSelfLoop(selfLoop, loopPaddings){
  var itr, loopRectangle, loopSide, middleHeight, pred, relevantPaddings, sidePredicate, sourceHeight, targetHeight, side, nubs, labelMargins, edgeMargins;
  pred = new SplineSelfLoopRouter$LoopPadding$EnclosingPredicate(selfLoop);
  relevantPaddings = newArrayList(filter_0(loopPaddings, pred));
  $clinit_Collections();
  $sort(relevantPaddings, new SplineSelfLoopRouter$LoopPadding$MarginComparator);
  loopSide = selfLoop.loopSide;
  switch (loopSide.type_0) {
    case 2:
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.source);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(sourceHeight = castTo($next(itr), 192).padding):(sourceHeight = 15);
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate($getMiddleSide(loopSide));
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(middleHeight = castTo($next(itr), 192).padding):(middleHeight = 15);
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.target);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(targetHeight = castTo($next(itr), 192).padding):(targetHeight = 15);
      loopRectangle = $calculateAcrossSelfLoop(selfLoop, sourceHeight, middleHeight, targetHeight);
      $add_6(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.source));
      $add_6(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, $getMiddleSide(loopSide)));
      $add_6(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.target));
      break;
    case 1:
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.source);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(sourceHeight = castTo($next(itr), 192).padding):(sourceHeight = 15);
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.target);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(targetHeight = castTo($next(itr), 192).padding):(targetHeight = 15);
      loopRectangle = $calculateCornerSelfLoop(selfLoop, sourceHeight, targetHeight);
      $add_6(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.source));
      $add_6(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.target));
      break;
    case 0:
      sidePredicate = new SplineSelfLoopRouter$LoopPadding$PortSidePredicate(loopSide.source);
      itr = $iterator_0(filter_0(relevantPaddings, sidePredicate));
      $hasNext(itr)?(sourceHeight = castTo($next(itr), 192).padding):(sourceHeight = 15);
      loopRectangle = (side = selfLoop.loopSide , nubs = createSideSelfLoop(selfLoop.lEdge.source, selfLoop.lEdge.target, sourceHeight) , $addAll(selfLoop.lEdge.bendPoints, $getBezierCP(nubs)) , labelMargins = $placeLabels_1(selfLoop.lEdge.labels, nubs.firstLabelPosition, side) , edgeMargins = new Rectangle_2((!nubs.outerBox && (nubs.outerBox = new Rectangle_0($getControlPoints(nubs))) , nubs.outerBox)) , $enlarge(edgeMargins) , !labelMargins?edgeMargins:union(edgeMargins, labelMargins));
      $add_6(loopPaddings, new SplineSelfLoopRouter$LoopPadding(loopRectangle, selfLoop.sourceIndex, selfLoop.targetIndex, selfLoop.lEdge.source.owner, loopSide.source));
      break;
    default:throw toJs(new IllegalArgumentException_0('The loopside must be defined.'));
  }
  return loopRectangle;
}

function SplineSelfLoopRouter(){
}

defineClass(1466, 1, $intern_108, SplineSelfLoopRouter);
_.process = function process_46(layeredGraph, monitor){
  $process_51(castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopRouter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopRouter', 1466);
function SplineSelfLoopRouter$LoopPadding(boundingBox, sourceIndex, targetIndex, shape_0, side){
  this.side = side;
  this.startIndex = sourceIndex;
  this.endIndex = targetIndex;
  switch (side.ordinal) {
    case 4:
      this.padding = $wnd.Math.abs(boundingBox.left);
      break;
    case 1:
      this.padding = $wnd.Math.abs(boundingBox.top_0);
      break;
    case 2:
      this.padding = $wnd.Math.abs(boundingBox.right - shape_0.size_0.x_0);
      break;
    case 3:
      this.padding = $wnd.Math.abs(boundingBox.bottom - shape_0.size_0.y_0);
      break;
    default:this.padding = 0;
  }
}

defineClass(192, 1, {192:1}, SplineSelfLoopRouter$LoopPadding);
_.toString_0 = function toString_92(){
  return this.padding + ': ' + this.startIndex + ' -> ' + this.endIndex + ' ' + $toString_2(this.side);
}
;
_.endIndex = 0;
_.padding = 0;
_.startIndex = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopRouter$LoopPadding_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopRouter/LoopPadding', 192);
function $apply_21(this$static, margin){
  if (!$getPortSides(this$static.loopSide).contains(margin.side)) {
    return false;
  }
  return $viaNW(this$static.loopSide)?!(isBetween_0(margin.startIndex, this$static.startIndex, this$static.endIndex) && isBetween_0(margin.endIndex, this$static.startIndex, this$static.endIndex)):isBetween_0(margin.startIndex, this$static.startIndex, this$static.endIndex) && isBetween_0(margin.endIndex, this$static.startIndex, this$static.endIndex);
}

function SplineSelfLoopRouter$LoopPadding$EnclosingPredicate(edge){
  this.startIndex = edge.sourceIndex;
  this.endIndex = edge.targetIndex;
  this.loopSide = edge.loopSide;
}

defineClass(1469, 1, $intern_91, SplineSelfLoopRouter$LoopPadding$EnclosingPredicate);
_.apply_1 = function apply_95(margin){
  return $apply_21(this, castTo(margin, 192));
}
;
_.equals_0 = function equals_131(other){
  return this === other;
}
;
_.test_0 = function test_42(input_0){
  return this.apply_1(input_0);
}
;
_.endIndex = 0;
_.startIndex = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopRouter$LoopPadding$EnclosingPredicate_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopRouter/LoopPadding/EnclosingPredicate', 1469);
function $compare_15(margin0, margin1){
  return compare_5(margin1.padding, margin0.padding);
}

function SplineSelfLoopRouter$LoopPadding$MarginComparator(){
}

defineClass(1468, 1, $intern_40, SplineSelfLoopRouter$LoopPadding$MarginComparator);
_.compare_0 = function compare_51(margin0, margin1){
  return $compare_15(castTo(margin0, 192), castTo(margin1, 192));
}
;
_.equals_0 = function equals_132(other){
  return this === other;
}
;
_.reversed = function reversed_43(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopRouter$LoopPadding$MarginComparator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopRouter/LoopPadding/MarginComparator', 1468);
function SplineSelfLoopRouter$LoopPadding$PortSidePredicate(side){
  this.side = side;
}

defineClass(432, 1, $intern_91, SplineSelfLoopRouter$LoopPadding$PortSidePredicate);
_.apply_1 = function apply_96(margin){
  return castTo(margin, 192).side == this.side;
}
;
_.equals_0 = function equals_133(other){
  return this === other;
}
;
_.test_0 = function test_43(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopRouter$LoopPadding$PortSidePredicate_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopRouter/LoopPadding/PortSidePredicate', 432);
function SplineSelfLoopRouter$SelfLoopEdge(sourceIndex, targetIndex, stepSize, loopSide, edge){
  this.sourceIndex = sourceIndex;
  this.targetIndex = targetIndex;
  this.stepSize = stepSize;
  this.loopSide = loopSide;
  this.lEdge = edge;
}

defineClass(431, 1, {431:1}, SplineSelfLoopRouter$SelfLoopEdge);
_.sourceIndex = 0;
_.stepSize = 0;
_.targetIndex = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopRouter$SelfLoopEdge_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopRouter/SelfLoopEdge', 431);
function $compare_16(edge0, edge1){
  return edge0.stepSize - edge1.stepSize;
}

function SplineSelfLoopRouter$SelfLoopEdge$StepSizeComparator(){
}

defineClass(1467, 1, $intern_40, SplineSelfLoopRouter$SelfLoopEdge$StepSizeComparator);
_.compare_0 = function compare_52(edge0, edge1){
  return $compare_16(castTo(edge0, 431), castTo(edge1, 431));
}
;
_.equals_0 = function equals_134(other){
  return this === other;
}
;
_.reversed = function reversed_44(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_SplineSelfLoopRouter$SelfLoopEdge$StepSizeComparator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate', 'SplineSelfLoopRouter/SelfLoopEdge/StepSizeComparator', 1467);
function $alterGroupedHitboxOrthogonal(g, spacing, fac){
  var delta, master, n, n$iterator, vs;
  master = g.master;
  !master && (master = castTo(g.cNodes.map_0.keySet_0().iterator_0().next_1(), 60));
  $alterHitbox(master, spacing, fac);
  if (g.cNodes.map_0.size_1() == 1) {
    return;
  }
  delta = spacing * fac;
  for (n$iterator = g.cNodes.map_0.keySet_0().iterator_0(); n$iterator.hasNext_0();) {
    n = castTo(n$iterator.next_1(), 60);
    if (n != master) {
      vs = getVerticalSegmentOrNull(n);
      if (vs.ignoreSpacing.up) {
        n.hitbox.y_0 += delta + $intern_96;
        n.hitbox.height -= delta + $intern_96;
      }
       else 
        vs.ignoreSpacing.down && (n.hitbox.height -= delta + $intern_96);
    }
  }
}

function $alterHitbox(n, spacing, fac){
  var delta, vs;
  delta = spacing * fac;
  if (instanceOf(n.origin, 164)) {
    vs = getVerticalSegmentOrNull(n);
    if (vs.ignoreSpacing.up) {
      vs.ignoreSpacing.down || (n.hitbox.height += delta + $intern_96);
    }
     else {
      n.hitbox.y_0 -= delta + $intern_96;
      n.hitbox.height += delta + $intern_96;
    }
  }
   else if (instanceOf(n.origin, 9)) {
    n.hitbox.y_0 -= delta;
    n.hitbox.height += 2 * delta;
  }
}

function $lambda$1_0(this$static, n_0){
  var lNode, spacing, vs;
  if (instanceOf(n_0.origin, 9) && castTo(n_0.origin, 9).type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return $intern_62;
  }
  vs = getVerticalSegmentOrNull(n_0);
  if (vs) {
    return $wnd.Math.max(0, this$static.verticalEdgeEdgeSpacing / 2 - 0.5);
  }
  lNode = getLNodeOrNull(n_0);
  if (lNode) {
    spacing = checkNotNull_1(castToDouble(getIndividualOrDefault(lNode, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
    return $wnd.Math.max(0, spacing / 2 - 0.5);
  }
  return $intern_62;
}

function $lambda$12(schedule_1, n_1){
  var finalSpacing, lNode, spacing;
  lNode = getLNodeOrNull(n_1);
  spacing = checkNotNull_1(castToDouble(getIndividualOrDefault(lNode, ($clinit_LayeredOptions() , SPACING_EDGE_EDGE))));
  finalSpacing = $wnd.Math.max(0, spacing / 2 - 0.5);
  $alterHitbox(n_1, finalSpacing, 1);
  $add_4(schedule_1, new EdgeAwareScanlineConstraintCalculation$lambda$22$Type(n_1, finalSpacing));
}

function $lambda$15(this$static, n_0){
  var lNode, spacing, vs;
  if (instanceOf(n_0.origin, 9) && castTo(n_0.origin, 9).type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return $intern_62;
  }
  vs = getVerticalSegmentOrNull(n_0);
  if (vs) {
    return $wnd.Math.max(0, this$static.verticalEdgeEdgeSpacing / 2 - 0.5);
  }
  lNode = getLNodeOrNull(n_0);
  if (lNode) {
    spacing = checkNotNull_1(castToDouble(getIndividualOrDefault(lNode, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
    return $wnd.Math.max(0, spacing / 2 - 0.5);
  }
  return $intern_62;
}

function $lambda$17(minSpacing_1, schedule_3, g_2){
  $alterGroupedHitboxOrthogonal(g_2, minSpacing_1, 1);
  $add_4(schedule_3, new EdgeAwareScanlineConstraintCalculation$lambda$23$Type(g_2, minSpacing_1));
}

function $lambda$4(minSpacing_1, schedule_3, n_2){
  $alterHitbox(n_2, minSpacing_1, 1);
  $add_4(schedule_3, new EdgeAwareScanlineConstraintCalculation$lambda$20$Type(n_2, minSpacing_1));
}

function $lambda$8(this$static, schedule_1, n_1){
  var spacing;
  spacing = $wnd.Math.max(0, this$static.verticalEdgeEdgeSpacing / 2 - 0.5);
  $alterHitbox(n_1, spacing, 1);
  $add_4(schedule_1, new EdgeAwareScanlineConstraintCalculation$lambda$21$Type(n_1, spacing));
}

function EdgeAwareScanlineConstraintCalculation(graph){
  ScanlineConstraintCalculator.call(this);
  this.verticalEdgeEdgeSpacing = checkNotNull_1(castToDouble($getProperty(graph, ($clinit_LayeredOptions() , SPACING_EDGE_EDGE))));
  this.edgeRouting = castTo($getProperty(graph, EDGE_ROUTING), 204);
}

defineClass(1544, 745, {}, EdgeAwareScanlineConstraintCalculation);
_.calculateConstraints = function calculateConstraints_1(theCompactor){
  var schedule, minSpacing, schedule_0, minSpacing_0;
  this.compactor = theCompactor;
  switch (this.edgeRouting.ordinal) {
    case 2:
      schedule = new ArrayList;
      $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this.compactor.cGraph.cNodes, 16)), new EdgeAwareScanlineConstraintCalculation$lambda$7$Type), new EdgeAwareScanlineConstraintCalculation$lambda$8$Type(this, schedule));
      $sweep(this, new EdgeAwareScanlineConstraintCalculation$lambda$9$Type);
      $forEach_0(schedule, new EdgeAwareScanlineConstraintCalculation$lambda$10$Type);
      schedule.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this.compactor.cGraph.cNodes, 16)), new EdgeAwareScanlineConstraintCalculation$lambda$11$Type), new EdgeAwareScanlineConstraintCalculation$lambda$12$Type(schedule));
      $sweep(this, new EdgeAwareScanlineConstraintCalculation$lambda$13$Type);
      $forEach_0(schedule, new EdgeAwareScanlineConstraintCalculation$lambda$14$Type);
      schedule.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      minSpacing = $orElseGet($min($mapToDouble(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this.compactor.cGraph.cNodes, 16)), new EdgeAwareScanlineConstraintCalculation$lambda$15$Type(this))), new EdgeAwareScanlineConstraintCalculation$lambda$16$Type);
      $forEach_2(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this.compactor.cGraph.cGroups, 16)), new EdgeAwareScanlineConstraintCalculation$lambda$17$Type(minSpacing, schedule));
      $sweep(this, new EdgeAwareScanlineConstraintCalculation$lambda$18$Type);
      $forEach_0(schedule, new EdgeAwareScanlineConstraintCalculation$lambda$19$Type);
      schedule.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      break;
    case 3:
      schedule_0 = new ArrayList;
      $sweep(this, new EdgeAwareScanlineConstraintCalculation$lambda$0$Type);
      minSpacing_0 = $orElseGet($min($mapToDouble(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this.compactor.cGraph.cNodes, 16)), new EdgeAwareScanlineConstraintCalculation$lambda$1$Type(this))), new EdgeAwareScanlineConstraintCalculation$lambda$2$Type);
      $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this.compactor.cGraph.cNodes, 16)), new EdgeAwareScanlineConstraintCalculation$lambda$3$Type), new EdgeAwareScanlineConstraintCalculation$lambda$4$Type(minSpacing_0, schedule_0));
      $sweep(this, new EdgeAwareScanlineConstraintCalculation$lambda$5$Type);
      $forEach_0(schedule_0, new EdgeAwareScanlineConstraintCalculation$lambda$6$Type);
      schedule_0.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      break;
    default:throw toJs(new UnsupportedConfigurationException);
  }
}
;
_.verticalEdgeEdgeSpacing = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation', 1544);
function EdgeAwareScanlineConstraintCalculation$lambda$0$Type(){
}

defineClass(1545, 1, $intern_91, EdgeAwareScanlineConstraintCalculation$lambda$0$Type);
_.equals_0 = function equals_135(other){
  return this === other;
}
;
_.test_0 = function test_44(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_97(arg0){
  return instanceOf(castTo(arg0, 60).origin, 164);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$0$Type', 1545);
function EdgeAwareScanlineConstraintCalculation$lambda$1$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1546, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$1$Type);
_.applyAsDouble = function applyAsDouble_3(arg0){
  return $lambda$1_0(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$1$Type', 1546);
function EdgeAwareScanlineConstraintCalculation$lambda$10$Type(){
}

defineClass(1557, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$10$Type);
_.accept = function accept_64(arg0){
  castTo(arg0, 447).run();
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$10$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$10$Type', 1557);
function EdgeAwareScanlineConstraintCalculation$lambda$11$Type(){
}

defineClass(1558, 1, $intern_90, EdgeAwareScanlineConstraintCalculation$lambda$11$Type);
_.test_0 = function test_45(arg0){
  return instanceOf(castTo(arg0, 60).origin, 9);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$11$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$11$Type', 1558);
function EdgeAwareScanlineConstraintCalculation$lambda$12$Type(schedule_1){
  this.schedule_1 = schedule_1;
}

defineClass(1560, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$12$Type);
_.accept = function accept_65(arg0){
  $lambda$12(this.schedule_1, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$12$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$12$Type', 1560);
function EdgeAwareScanlineConstraintCalculation$lambda$13$Type(){
}

defineClass(1561, 1, $intern_91, EdgeAwareScanlineConstraintCalculation$lambda$13$Type);
_.equals_0 = function equals_136(other){
  return this === other;
}
;
_.test_0 = function test_46(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_98(arg0){
  return instanceOf(castTo(arg0, 60).origin, 9);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$13$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$13$Type', 1561);
function EdgeAwareScanlineConstraintCalculation$lambda$14$Type(){
}

defineClass(1562, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$14$Type);
_.accept = function accept_66(arg0){
  castTo(arg0, 447).run();
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$14$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$14$Type', 1562);
function EdgeAwareScanlineConstraintCalculation$lambda$15$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1563, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$15$Type);
_.applyAsDouble = function applyAsDouble_4(arg0){
  return $lambda$15(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$15$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$15$Type', 1563);
function EdgeAwareScanlineConstraintCalculation$lambda$16$Type(){
}

defineClass(1564, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$16$Type);
_.getAsDouble = function getAsDouble(){
  return 0;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$16$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$16$Type', 1564);
function EdgeAwareScanlineConstraintCalculation$lambda$17$Type(minSpacing_1, schedule_3){
  this.minSpacing_1 = minSpacing_1;
  this.schedule_3 = schedule_3;
}

defineClass(1566, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$17$Type);
_.accept = function accept_67(arg0){
  $lambda$17(this.minSpacing_1, this.schedule_3, arg0);
}
;
_.minSpacing_1 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$17$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$17$Type', 1566);
function EdgeAwareScanlineConstraintCalculation$lambda$18$Type(){
}

defineClass(1567, 1, $intern_91, EdgeAwareScanlineConstraintCalculation$lambda$18$Type);
_.equals_0 = function equals_137(other){
  return this === other;
}
;
_.test_0 = function test_47(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_99(arg0){
  return true;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$18$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$18$Type', 1567);
function EdgeAwareScanlineConstraintCalculation$lambda$19$Type(){
}

defineClass(1568, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$19$Type);
_.accept = function accept_68(arg0){
  castTo(arg0, 447).run();
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$19$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$19$Type', 1568);
function EdgeAwareScanlineConstraintCalculation$lambda$2$Type(){
}

defineClass(1547, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$2$Type);
_.getAsDouble = function getAsDouble_0(){
  return 0;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$2$Type', 1547);
function EdgeAwareScanlineConstraintCalculation$lambda$20$Type(n_1, minSpacing_2){
  this.n_1 = n_1;
  this.minSpacing_2 = minSpacing_2;
}

defineClass(1549, 1, $intern_114, EdgeAwareScanlineConstraintCalculation$lambda$20$Type);
_.run = function run_0(){
  $alterHitbox(this.n_1, this.minSpacing_2, -1);
}
;
_.minSpacing_2 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$20$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$20$Type', 1549);
function EdgeAwareScanlineConstraintCalculation$lambda$21$Type(n_1, spacing_2){
  this.n_1 = n_1;
  this.spacing_2 = spacing_2;
}

defineClass(1554, 1, $intern_114, EdgeAwareScanlineConstraintCalculation$lambda$21$Type);
_.run = function run_1(){
  $alterHitbox(this.n_1, this.spacing_2, -1);
}
;
_.spacing_2 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$21$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$21$Type', 1554);
function EdgeAwareScanlineConstraintCalculation$lambda$22$Type(n_1, finalSpacing_2){
  this.n_1 = n_1;
  this.finalSpacing_2 = finalSpacing_2;
}

defineClass(1559, 1, $intern_114, EdgeAwareScanlineConstraintCalculation$lambda$22$Type);
_.run = function run_2(){
  $alterHitbox(this.n_1, this.finalSpacing_2, -1);
}
;
_.finalSpacing_2 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$22$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$22$Type', 1559);
function EdgeAwareScanlineConstraintCalculation$lambda$23$Type(g_1, minSpacing_2){
  this.g_1 = g_1;
  this.minSpacing_2 = minSpacing_2;
}

defineClass(1565, 1, $intern_114, EdgeAwareScanlineConstraintCalculation$lambda$23$Type);
_.run = function run_3(){
  $alterGroupedHitboxOrthogonal(this.g_1, this.minSpacing_2, -1);
}
;
_.minSpacing_2 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$23$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$23$Type', 1565);
function EdgeAwareScanlineConstraintCalculation$lambda$3$Type(){
}

defineClass(1548, 1, $intern_90, EdgeAwareScanlineConstraintCalculation$lambda$3$Type);
_.test_0 = function test_48(arg0){
  return instanceOf(castTo(arg0, 60).origin, 9);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$3$Type', 1548);
function EdgeAwareScanlineConstraintCalculation$lambda$4$Type(minSpacing_1, schedule_3){
  this.minSpacing_1 = minSpacing_1;
  this.schedule_3 = schedule_3;
}

defineClass(1550, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$4$Type);
_.accept = function accept_69(arg0){
  $lambda$4(this.minSpacing_1, this.schedule_3, arg0);
}
;
_.minSpacing_1 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$4$Type', 1550);
function EdgeAwareScanlineConstraintCalculation$lambda$5$Type(){
}

defineClass(1551, 1, $intern_91, EdgeAwareScanlineConstraintCalculation$lambda$5$Type);
_.equals_0 = function equals_138(other){
  return this === other;
}
;
_.test_0 = function test_49(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_100(arg0){
  return true;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$5$Type', 1551);
function EdgeAwareScanlineConstraintCalculation$lambda$6$Type(){
}

defineClass(1552, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$6$Type);
_.accept = function accept_70(arg0){
  castTo(arg0, 447).run();
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$6$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$6$Type', 1552);
function EdgeAwareScanlineConstraintCalculation$lambda$7$Type(){
}

defineClass(1553, 1, $intern_90, EdgeAwareScanlineConstraintCalculation$lambda$7$Type);
_.test_0 = function test_50(arg0){
  return instanceOf(castTo(arg0, 60).origin, 164);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$7$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$7$Type', 1553);
function EdgeAwareScanlineConstraintCalculation$lambda$8$Type($$outer_0, schedule_1){
  this.$$outer_0 = $$outer_0;
  this.schedule_1 = schedule_1;
}

defineClass(1555, 1, {}, EdgeAwareScanlineConstraintCalculation$lambda$8$Type);
_.accept = function accept_71(arg0){
  $lambda$8(this.$$outer_0, this.schedule_1, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$8$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$8$Type', 1555);
function EdgeAwareScanlineConstraintCalculation$lambda$9$Type(){
}

defineClass(1556, 1, $intern_91, EdgeAwareScanlineConstraintCalculation$lambda$9$Type);
_.equals_0 = function equals_139(other){
  return this === other;
}
;
_.test_0 = function test_51(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_101(arg0){
  return instanceOf(castTo(arg0, 60).origin, 164);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_EdgeAwareScanlineConstraintCalculation$lambda$9$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'EdgeAwareScanlineConstraintCalculation/lambda$9$Type', 1556);
function $clinit_HorizontalGraphCompactor(){
  $clinit_HorizontalGraphCompactor = emptyMethod;
  NETWORK_SIMPLEX_COMPACTION = new NetworkSimplexCompaction;
}

function $process_52(this$static, layeredGraph, progressMonitor){
  var odc, strategy, transformer;
  strategy = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , COMPACTION_POST_COMPACTION_STRATEGY_0)), 265);
  if (strategy == ($clinit_GraphCompactionStrategy() , NONE_2)) {
    return;
  }
  $begin(progressMonitor, 'Horizontal Compaction', 1);
  this$static.lGraph = layeredGraph;
  transformer = new LGraphToCGraphTransformer;
  odc = new OneDimensionalCompactor((transformer.layeredGraph = layeredGraph , transformer.edgeRouting = castTo($getProperty(transformer.layeredGraph, EDGE_ROUTING), 204) , $init(transformer) , $transformNodes_0(transformer) , $transformEdges_0(transformer) , transformer.cGraph));
  $setSpacingsHandler(odc, this$static.specialSpacingsHandler);
  switch (castTo($getProperty(layeredGraph, COMPACTION_POST_COMPACTION_CONSTRAINTS_0), 402).ordinal) {
    case 1:
      $setConstraintAlgorithm(odc, new EdgeAwareScanlineConstraintCalculation(this$static.lGraph));
      break;
    default:$setConstraintAlgorithm(odc, ($clinit_OneDimensionalCompactor() , QUADRATIC_CONSTRAINTS));
  }
  switch (strategy.ordinal) {
    case 1:
      $compact(odc);
      break;
    case 2:
      $compact($changeDirection(odc, ($clinit_Direction_0() , RIGHT_5)));
      break;
    case 3:
      $compact($setLockFunction($changeDirection($compact(odc), ($clinit_Direction_0() , RIGHT_5)), new HorizontalGraphCompactor$lambda$0$Type));
      break;
    case 4:
      $compact($setLockFunction($changeDirection($compact(odc), ($clinit_Direction_0() , RIGHT_5)), new HorizontalGraphCompactor$lambda$1$Type(transformer)));
      break;
    case 5:
      $compact($setCompactionAlgorithm(odc, NETWORK_SIMPLEX_COMPACTION));
  }
  $changeDirection(odc, ($clinit_Direction_0() , LEFT_5));
  odc.finished = true;
  $applyLayout_3(transformer);
  $done_0(progressMonitor);
}

function HorizontalGraphCompactor(){
  $clinit_HorizontalGraphCompactor();
  this.specialSpacingsHandler = new HorizontalGraphCompactor$1(this);
}

function getLNodeOrNull(cNode){
  $clinit_HorizontalGraphCompactor();
  if (instanceOf(cNode.origin, 9)) {
    return castTo(cNode.origin, 9);
  }
  return null;
}

function getVerticalSegmentOrNull(cNode){
  $clinit_HorizontalGraphCompactor();
  if (instanceOf(cNode.origin, 164)) {
    return castTo(cNode.origin, 164);
  }
  return null;
}

function isVerticalSegmentsOfSameEdge(cNode1, cNode2){
  $clinit_HorizontalGraphCompactor();
  var v1, v2;
  v1 = getVerticalSegmentOrNull(cNode1);
  v2 = getVerticalSegmentOrNull(cNode2);
  return !!v1 && !!v2 && !disjoint(v1.representedLEdges, v2.representedLEdges);
}

function lambda$1_4(transformer_0, node_1, dir_2){
  $clinit_HorizontalGraphCompactor();
  return $get_14(castTo($get_6(transformer_0.lockMap, node_1), 490), dir_2);
}

defineClass(1404, 1, $intern_108, HorizontalGraphCompactor);
_.process = function process_47(layeredGraph, progressMonitor){
  $process_52(this, castTo(layeredGraph, 32), progressMonitor);
}
;
var NETWORK_SIMPLEX_COMPACTION;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_HorizontalGraphCompactor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'HorizontalGraphCompactor', 1404);
function HorizontalGraphCompactor$1(this$0){
  this.this$01 = this$0;
}

defineClass(1405, 1, {}, HorizontalGraphCompactor$1);
_.getHorizontalSpacing = function getHorizontalSpacing_2(cNode1, cNode2){
  var node1, node2, spacings;
  if (isVerticalSegmentsOfSameEdge(cNode1, cNode2)) {
    return 0;
  }
  node1 = getLNodeOrNull(cNode1);
  node2 = getLNodeOrNull(cNode2);
  if (!!node1 && node1.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) || !!node2 && node2.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return 0;
  }
  spacings = castTo($getProperty(this.this$01.lGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  return $getHorizontalSpacing(spacings, node1?node1.type_0:($clinit_LNode$NodeType() , LONG_EDGE), node2?node2.type_0:($clinit_LNode$NodeType() , LONG_EDGE));
}
;
_.getVerticalSpacing = function getVerticalSpacing_2(cNode1, cNode2){
  var node1, node2, spacings;
  if (isVerticalSegmentsOfSameEdge(cNode1, cNode2)) {
    return 1;
  }
  node1 = getLNodeOrNull(cNode1);
  node2 = getLNodeOrNull(cNode2);
  spacings = castTo($getProperty(this.this$01.lGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  return $getVerticalSpacing(spacings, node1?node1.type_0:($clinit_LNode$NodeType() , LONG_EDGE), node2?node2.type_0:($clinit_LNode$NodeType() , LONG_EDGE));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_HorizontalGraphCompactor$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'HorizontalGraphCompactor/1', 1405);
function HorizontalGraphCompactor$lambda$0$Type(){
}

defineClass(1406, 1, {}, HorizontalGraphCompactor$lambda$0$Type);
_.isLocked = function isLocked(arg0, arg1){
  return $clinit_HorizontalGraphCompactor() , arg0.cGroup.outDegreeReal == 0;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_HorizontalGraphCompactor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'HorizontalGraphCompactor/lambda$0$Type', 1406);
function HorizontalGraphCompactor$lambda$1$Type(transformer_0){
  this.transformer_0 = transformer_0;
}

defineClass(1407, 1, {}, HorizontalGraphCompactor$lambda$1$Type);
_.isLocked = function isLocked_0(arg0, arg1){
  return lambda$1_4(this.transformer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_HorizontalGraphCompactor$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'HorizontalGraphCompactor/lambda$1$Type', 1407);
function $clinit_LGraphToCGraphTransformer(){
  $clinit_LGraphToCGraphTransformer = emptyMethod;
  NODE_TO_STRING_DELEGATE = new LGraphToCGraphTransformer$lambda$0$Type;
  VS_TO_STRING_DELEGATE = new LGraphToCGraphTransformer$lambda$1$Type;
}

function $adjustControlPointBetweenSegments(this$static, left, right, leftIdx, rightIdx, spline){
  var adjust, chunk, chunks, endX, idx1, idx2, k, n, newPos, startX, strip, width_0;
  idx1 = leftIdx;
  if (left.initialSegment && left.isStraight) {
    n = castTo($get_6(this$static.nodesMap, left.sourceNode), 60);
    startX = n.hitbox.x_0 + n.hitbox.width_0;
    --idx1;
  }
   else {
    startX = left.boundingBox.x_0 + left.boundingBox.width_0;
  }
  idx2 = rightIdx;
  if (right.lastSegment && right.isStraight) {
    n = castTo($get_6(this$static.nodesMap, right.targetNode), 60);
    endX = n.hitbox.x_0;
    ++idx2;
  }
   else {
    endX = right.boundingBox.x_0;
  }
  strip = endX - startX;
  chunks = 2 > idx2 - idx1?2:idx2 - idx1;
  chunk = strip / chunks;
  newPos = startX + chunk;
  for (k = idx1; k < idx2; ++k) {
    adjust = castTo(spline.get_3(k), 121);
    width_0 = adjust.boundingBox.width_0;
    adjust.boundingBox.x_0 = newPos - width_0 / 2;
    newPos += chunk;
  }
}

function $adjustSplineControlPoints(this$static, spline){
  var i, j, lastSeg, needle, nextSeg;
  if (spline.isEmpty()) {
    return;
  }
  lastSeg = castTo(spline.get_3(0), 121);
  if (spline.size_1() == 1) {
    $adjustControlPointBetweenSegments(this$static, lastSeg, lastSeg, 1, 0, spline);
    return;
  }
  i = 1;
  while (i < spline.size_1()) {
    if (lastSeg.initialSegment || !lastSeg.isStraight) {
      needle = $firstNonStraightSegment(spline, i);
      if (needle) {
        j = castTo(needle.first, 21).value_0;
        nextSeg = castTo(needle.second, 121);
        $adjustControlPointBetweenSegments(this$static, lastSeg, nextSeg, i, j, spline);
        i = j + 1;
        lastSeg = nextSeg;
      }
    }
  }
}

function $applyCommentPositions(this$static){
  var comment, e, e$iterator, offset, other;
  for (e$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this$static.commentOffsets)).this$01); e$iterator.hasNext;) {
    e = $next_7(e$iterator);
    comment = castTo(e.getKey(), 9);
    other = castTo(castTo(e.getValue(), 37).first, 9);
    offset = castTo(castTo(e.getValue(), 37).second, 8);
    $add_19($reset_5(comment.pos), $add_19($clone_0(other.pos), offset));
  }
}

function $applyExternalPortPositions(this$static, topLeft, bottomRight){
  var cNode, cNode$iterator, lNode;
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    lNode = getLNodeOrNull(cNode);
    if (lNode) {
      if (lNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
        switch (castTo($getProperty(lNode, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71).ordinal) {
          case 4:
            lNode.pos.x_0 = topLeft.x_0;
            break;
          case 2:
            lNode.pos.x_0 = bottomRight.x_0 - (lNode.size_0.x_0 + lNode.margin.right);
            break;
          case 1:
            lNode.pos.y_0 = topLeft.y_0;
            break;
          case 3:
            lNode.pos.y_0 = bottomRight.y_0 - (lNode.size_0.y_0 + lNode.margin.bottom);
        }
      }
    }
  }
}

function $applyLayout_3(this$static){
  var bottomRight, cNode, cNode$iterator, topLeft;
  $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.cGraph.cNodes, 16)), new LGraphToCGraphTransformer$lambda$8$Type), new LGraphToCGraphTransformer$lambda$9$Type);
  $applyCommentPositions(this$static);
  $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.cGraph.cNodes, 16)), new LGraphToCGraphTransformer$lambda$10$Type), new LGraphToCGraphTransformer$lambda$11$Type);
  if (this$static.edgeRouting == ($clinit_EdgeRouting() , SPLINES)) {
    $forEach_2($filter($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(new AbstractMap$1(this$static.nodesMap), 1)), new LGraphToCGraphTransformer$lambda$12$Type), new LGraphToCGraphTransformer$lambda$13$Type), new LGraphToCGraphTransformer$lambda$14$Type(this$static));
    $forEach_2($filter($map($flatMap($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.layeredGraph.layers, 16)), new LGraphToCGraphTransformer$lambda$15$Type), new LGraphToCGraphTransformer$lambda$16$Type), new LGraphToCGraphTransformer$lambda$17$Type), new LGraphToCGraphTransformer$lambda$18$Type), new LGraphToCGraphTransformer$lambda$19$Type(this$static));
  }
  topLeft = new KVector_1($intern_62, $intern_62);
  bottomRight = new KVector_1($intern_63, $intern_63);
  for (cNode$iterator = new ArrayList$1(this$static.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    topLeft.x_0 = $wnd.Math.min(topLeft.x_0, cNode.hitbox.x_0);
    topLeft.y_0 = $wnd.Math.min(topLeft.y_0, cNode.hitbox.y_0);
    bottomRight.x_0 = $wnd.Math.max(bottomRight.x_0, cNode.hitbox.x_0 + cNode.hitbox.width_0);
    bottomRight.y_0 = $wnd.Math.max(bottomRight.y_0, cNode.hitbox.y_0 + cNode.hitbox.height);
  }
  $add_19($reset_5(this$static.layeredGraph.offset), $negate(new KVector_1(topLeft.x_0, topLeft.y_0)));
  $add_19($reset_5(this$static.layeredGraph.size_0), $sub_0(new KVector_1(bottomRight.x_0, bottomRight.y_0), topLeft));
  $applyExternalPortPositions(this$static, topLeft, bottomRight);
  $reset(this$static.nodesMap);
  $reset(this$static.commentOffsets);
  $reset(this$static.verticalSegmentsMap);
  $reset(this$static.lockMap);
  this$static.cGraph.cGroups.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.cGraph.cNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.cGraph = null;
  this$static.layeredGraph = null;
}

function $collectVerticalSegmentsOrthogonal(this$static){
  var bend1, bend2, bends, cNode, cTargetNode, edge, edge$iterator, edge$iterator0, first, lastSegment, layer, layer$iterator, node, node$iterator, verticalSegments, vs;
  verticalSegments = new ArrayList;
  for (layer$iterator = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      cNode = castTo($get_6(this$static.nodesMap, node), 60);
      for (edge$iterator0 = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator0);) {
        edge = castTo($next_2(edge$iterator0), 16);
        bends = $listIterator_1(edge.bendPoints, 0);
        first = true;
        lastSegment = null;
        if (bends.currentNode != bends.this$01.tail) {
          bend1 = castTo($next_13(bends), 8);
          if (edge.source.side == ($clinit_PortSide() , NORTH_1)) {
            vs = new VerticalSegment(bend1, new KVector_1(bend1.x_0, cNode.hitbox.y_0), cNode, edge);
            vs.ignoreSpacing.down = true;
            vs.aPort = edge.source;
            verticalSegments.array[verticalSegments.array.length] = vs;
          }
          if (edge.source.side == SOUTH_1) {
            vs = new VerticalSegment(bend1, new KVector_1(bend1.x_0, cNode.hitbox.y_0 + cNode.hitbox.height), cNode, edge);
            vs.ignoreSpacing.up = true;
            vs.aPort = edge.source;
            verticalSegments.array[verticalSegments.array.length] = vs;
          }
          while (bends.currentNode != bends.this$01.tail) {
            bend2 = castTo($next_13(bends), 8);
            if (!eq_0(bend1.y_0, bend2.y_0)) {
              lastSegment = new VerticalSegment(bend1, bend2, null, edge);
              verticalSegments.array[verticalSegments.array.length] = lastSegment;
              if (first) {
                first = false;
                if (bend2.y_0 < cNode.hitbox.y_0) {
                  lastSegment.ignoreSpacing.down = true;
                }
                 else if (bend2.y_0 > cNode.hitbox.y_0 + cNode.hitbox.height) {
                  lastSegment.ignoreSpacing.up = true;
                }
                 else {
                  lastSegment.ignoreSpacing.up = true;
                  lastSegment.ignoreSpacing.down = true;
                }
              }
            }
            bends.currentNode != bends.this$01.tail && (bend1 = bend2);
          }
          if (lastSegment) {
            cTargetNode = castTo($get_6(this$static.nodesMap, edge.target.owner), 60);
            if (bend1.y_0 < cTargetNode.hitbox.y_0) {
              lastSegment.ignoreSpacing.down = true;
            }
             else if (bend1.y_0 > cTargetNode.hitbox.y_0 + cTargetNode.hitbox.height) {
              lastSegment.ignoreSpacing.up = true;
            }
             else {
              lastSegment.ignoreSpacing.up = true;
              lastSegment.ignoreSpacing.down = true;
            }
          }
        }
      }
      for (edge$iterator = $iterator($getIncomingEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        if (edge.bendPoints.size_0 != 0) {
          bend1 = castTo($getLast(edge.bendPoints), 8);
          if (edge.target.side == ($clinit_PortSide() , NORTH_1)) {
            vs = new VerticalSegment(bend1, new KVector_1(bend1.x_0, cNode.hitbox.y_0), cNode, edge);
            vs.ignoreSpacing.down = true;
            vs.aPort = edge.target;
            verticalSegments.array[verticalSegments.array.length] = vs;
          }
          if (edge.target.side == SOUTH_1) {
            vs = new VerticalSegment(bend1, new KVector_1(bend1.x_0, cNode.hitbox.y_0 + cNode.hitbox.height), cNode, edge);
            vs.ignoreSpacing.up = true;
            vs.aPort = edge.target;
            verticalSegments.array[verticalSegments.array.length] = vs;
          }
        }
      }
    }
  }
  return verticalSegments;
}

function $firstNonStraightSegment(spline, index_0){
  var i, seg;
  if (index_0 < 0 || index_0 >= spline.size_1()) {
    return null;
  }
  for (i = index_0; i < spline.size_1(); ++i) {
    seg = castTo(spline.get_3(i), 121);
    if (i == spline.size_1() - 1 || !seg.isStraight) {
      return new Pair(valueOf_4(i), seg);
    }
  }
  return null;
}

function $init(this$static){
  var hasEdges, index_0, l, l$iterator, n, n$iterator, supportedDirections;
  hasEdges = false;
  index_0 = 0;
  for (l$iterator = new ArrayList$1(this$static.layeredGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    l.id_0 = index_0++;
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      !hasEdges && !isEmpty_10($getConnectedEdges_0(n)) && (hasEdges = true);
    }
  }
  supportedDirections = of_1(($clinit_Direction_0() , UNDEFINED_3), stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_Direction_2_classLit, 1), $intern_38, 107, 0, [LEFT_5, RIGHT_5]));
  if (!hasEdges) {
    $add_5(supportedDirections, UP_1);
    $add_5(supportedDirections, DOWN_1);
  }
  this$static.cGraph = new CGraph(supportedDirections);
  $reset(this$static.nodesMap);
  $reset(this$static.commentOffsets);
  $reset(this$static.lockMap);
  $reset(this$static.verticalSegmentsMap);
}

function $lambda$14(this$static, sl_0){
  var cNode, deltaX, lNode;
  lNode = sl_0.source.owner;
  cNode = castTo($get_6(this$static.nodesMap, lNode), 60);
  deltaX = cNode.hitbox.x_0 - cNode.hitboxPreCompaction.x_0;
  $offset_1(sl_0.bendPoints, deltaX, 0);
}

function $lambda$2_0(this$static, vs_0){
  var vsNode;
  vsNode = castTo($get_6(this$static.verticalSegmentsMap, vs_0), 60);
  $forEach_0(vs_0.constraints, new LGraphToCGraphTransformer$lambda$20$Type(this$static, vsNode));
}

function $lambda$20(this$static, vsNode_1, other_1){
  var otherNode;
  otherNode = castTo($get_6(this$static.verticalSegmentsMap, other_1), 60);
  $add_4(this$static.cGraph.predefinedHorizontalConstraints, new Pair(vsNode_1, otherNode));
}

function $lambda$7(this$static, cNode_1, other_1){
  return $put_1(this$static.verticalSegmentsMap, other_1, cNode_1);
}

function $mergeVerticalSegments(this$static, verticalSegments){
  var next, survivor, vsIt, newX, newY, maxX, newW, maxY, newH;
  if (verticalSegments.array.length == 0) {
    return;
  }
  $clinit_Collections();
  sort_4(verticalSegments.array, verticalSegments.array.length, null);
  vsIt = new ArrayList$1(verticalSegments);
  survivor = castTo($next_10(vsIt), 164);
  while (vsIt.i < vsIt.this$01.array.length) {
    next = castTo($next_10(vsIt), 164);
    if (eq_0(survivor.hitbox.x_0, next.hitbox.x_0) && !(lt_0($getBottomLeft(survivor.hitbox).y_0, next.hitbox.y_0) || lt_0($getBottomLeft(next.hitbox).y_0, survivor.hitbox.y_0))) {
      survivor = ($addAll_2(survivor.representedLEdges, next.representedLEdges) , $addAll_2(survivor.affectedBends, next.affectedBends) , $addAll_2(survivor.affectedBoundingBoxes, next.affectedBoundingBoxes) , $addAll(survivor.junctionPoints, next.junctionPoints) , $addAll_2(survivor.constraints, next.constraints) , $addAll_2(survivor.potentialGroupParents, next.potentialGroupParents) , newX = $wnd.Math.min(survivor.hitbox.x_0, next.hitbox.x_0) , newY = $wnd.Math.min(survivor.hitbox.y_0, next.hitbox.y_0) , maxX = $wnd.Math.max(survivor.hitbox.x_0 + survivor.hitbox.width_0, next.hitbox.x_0 + next.hitbox.width_0) , newW = maxX - newX , maxY = $wnd.Math.max(survivor.hitbox.y_0 + survivor.hitbox.height, next.hitbox.y_0 + next.hitbox.height) , newH = maxY - newY , $setRect(survivor.hitbox, newX, newY, newW, newH) , $applyOr(survivor.ignoreSpacing, next.ignoreSpacing) , !survivor.aPort && (survivor.aPort = next.aPort) , $addAll_2(survivor.joined, next.joined) , $add_4(survivor.joined, next) , survivor);
    }
     else {
      $verticalSegmentToCNode(this$static, survivor);
      survivor = next;
    }
  }
  $verticalSegmentToCNode(this$static, survivor);
}

function $transformEdges_0(this$static){
  var style, verticalSegments, verticalSegments_0;
  style = castTo($getProperty(this$static.layeredGraph, ($clinit_LayeredOptions() , EDGE_ROUTING)), 204);
  switch (style.ordinal) {
    case 2:
      verticalSegments = $collectVerticalSegmentsOrthogonal(this$static);
      break;
    case 3:
      verticalSegments = (verticalSegments_0 = new ArrayList , $forEach_2($filter($map($flatMap($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.layeredGraph.layers, 16)), new LGraphToCGraphTransformer$lambda$3$Type), new LGraphToCGraphTransformer$lambda$4$Type), new LGraphToCGraphTransformer$lambda$5$Type), new LGraphToCGraphTransformer$0methodref$nonNull$Type), new LGraphToCGraphTransformer$lambda$6$Type(verticalSegments_0)) , verticalSegments_0);
      break;
    default:throw toJs(new IllegalStateException_0('Compaction not supported for ' + style + ' edges.'));
  }
  $mergeVerticalSegments(this$static, verticalSegments);
  $forEach(new AbstractMap$1(this$static.verticalSegmentsMap), new LGraphToCGraphTransformer$lambda$2$Type(this$static));
}

function $transformNodes_0(this$static){
  var cNode, difference, e, hitbox, layer, layer$iterator, node, node$iterator, nodeLock, other, p;
  for (layer$iterator = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (checkNotNull_1(castToBoolean($getProperty(node, ($clinit_LayeredOptions() , COMMENT_BOX))))) {
        if (!isEmpty_10($getConnectedEdges_0(node))) {
          e = castTo(get_12($getConnectedEdges_0(node)), 16);
          other = e.source.owner;
          other == node && (other = e.target.owner);
          p = new Pair(other, $sub_0($clone_0(node.pos), other.pos));
          $put_1(this$static.commentOffsets, node, p);
          continue;
        }
      }
      hitbox = new ElkRectangle_0(node.pos.x_0 - node.margin.left, node.pos.y_0 - node.margin.top_0, node.size_0.x_0 + node.margin.left + node.margin.right, node.size_0.y_0 + node.margin.top_0 + node.margin.bottom);
      cNode = $create_0($toStringDelegate($hitbox($origin(new CNode$CNodeBuilder, node), hitbox), NODE_TO_STRING_DELEGATE), this$static.cGraph);
      $create($master($nodes(new CGroup$CGroupBuilder, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_common_compaction_oned_CNode_2_classLit, 1), $intern_1, 60, 0, [cNode])), cNode), this$static.cGraph);
      nodeLock = new Quadruplet;
      $put_1(this$static.lockMap, cNode, nodeLock);
      difference = size_15($getIncomingEdges(node)) - size_15($getOutgoingEdges(node));
      difference < 0?$set_3(nodeLock, true, ($clinit_Direction_0() , LEFT_5)):difference > 0 && $set_3(nodeLock, true, ($clinit_Direction_0() , RIGHT_5));
      node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) && $set_4(nodeLock);
      $put_1(this$static.nodesMap, node, cNode);
    }
  }
}

function $verticalSegmentToCNode(this$static, verticalSegment){
  var cNode, difference, e, e$iterator, inc, out, vsLock;
  cNode = $create_0($toStringDelegate($hitbox($origin(new CNode$CNodeBuilder, verticalSegment), new ElkRectangle_1(verticalSegment.hitbox)), VS_TO_STRING_DELEGATE), this$static.cGraph);
  verticalSegment.potentialGroupParents.array.length == 0 || $addCNode(castTo($get_7(verticalSegment.potentialGroupParents, 0), 60).cGroup, cNode);
  vsLock = new Quadruplet;
  $put_1(this$static.lockMap, cNode, vsLock);
  inc = new HashSet;
  out = new HashSet;
  for (e$iterator = new ArrayList$1(verticalSegment.representedLEdges); e$iterator.i < e$iterator.this$01.array.length;) {
    e = castTo($next_10(e$iterator), 16);
    $add_6(inc, e.source);
    $add_6(out, e.target);
  }
  difference = inc.map_0.size_1() - out.map_0.size_1();
  if (difference < 0) {
    $set_3(vsLock, true, ($clinit_Direction_0() , LEFT_5));
    $set_3(vsLock, false, RIGHT_5);
  }
   else if (difference > 0) {
    $set_3(vsLock, false, ($clinit_Direction_0() , LEFT_5));
    $set_3(vsLock, true, RIGHT_5);
  }
  $forEach_0(verticalSegment.joined, new LGraphToCGraphTransformer$lambda$7$Type(this$static, cNode));
  $put_1(this$static.verticalSegmentsMap, verticalSegment, cNode);
}

function LGraphToCGraphTransformer(){
  $clinit_LGraphToCGraphTransformer();
  this.commentOffsets = ($clinit_Maps() , new HashMap);
  this.nodesMap = new HashMap;
  this.verticalSegmentsMap = new HashMap;
  this.lockMap = new HashMap;
}

function lambda$21(deltaX_0, b_1){
  $clinit_LGraphToCGraphTransformer();
  return b_1.x_0 += deltaX_0;
}

function lambda$22(deltaX_0, bb_1){
  $clinit_LGraphToCGraphTransformer();
  return bb_1.x_0 += deltaX_0;
}

function lambda$23(deltaX_0, jp_1){
  $clinit_LGraphToCGraphTransformer();
  return jp_1.x_0 += deltaX_0;
}

function lambda$6_0(verticalSegments_0, spline_1){
  $clinit_LGraphToCGraphTransformer();
  var lastVs, leftTop, rightBottom, s, s$iterator, vs;
  lastVs = null;
  for (s$iterator = spline_1.iterator_0(); s$iterator.hasNext_0();) {
    s = castTo(s$iterator.next_1(), 121);
    if (s.isStraight) {
      continue;
    }
    leftTop = $getTopLeft(s.boundingBox);
    rightBottom = $getBottomRight(s.boundingBox);
    vs = new VerticalSegment(leftTop, rightBottom, null, castTo(s.edges.map_0.keySet_0().iterator_0().next_1(), 16));
    $add_4(vs.affectedBoundingBoxes, s.boundingBox);
    verticalSegments_0.array[verticalSegments_0.array.length] = vs;
    !!lastVs && $add_4(lastVs.constraints, vs);
    lastVs = vs;
  }
}

defineClass(1515, 1, {}, LGraphToCGraphTransformer);
var NODE_TO_STRING_DELEGATE, VS_TO_STRING_DELEGATE;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer', 1515);
function LGraphToCGraphTransformer$0methodref$nonNull$Type(){
}

defineClass(1523, 1, $intern_90, LGraphToCGraphTransformer$0methodref$nonNull$Type);
_.test_0 = function test_52(arg0){
  return arg0 != null;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$0methodref$nonNull$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/0methodref$nonNull$Type', 1523);
function LGraphToCGraphTransformer$lambda$0$Type(){
}

defineClass(1516, 1, $intern_11, LGraphToCGraphTransformer$lambda$0$Type);
_.apply_0 = function apply_102(arg0){
  return $clinit_LGraphToCGraphTransformer() , toString_41($getProperty(castTo(castTo(arg0, 60).origin, 9), ($clinit_InternalProperties_1() , ORIGIN_0)));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$0$Type', 1516);
function LGraphToCGraphTransformer$lambda$1$Type(){
}

defineClass(1517, 1, $intern_11, LGraphToCGraphTransformer$lambda$1$Type);
_.apply_0 = function apply_103(arg0){
  return $clinit_LGraphToCGraphTransformer() , $toString_10(castTo(castTo(arg0, 60).origin, 164));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$1$Type', 1517);
function LGraphToCGraphTransformer$lambda$10$Type(){
}

defineClass(1528, 1, $intern_90, LGraphToCGraphTransformer$lambda$10$Type);
_.test_0 = function test_53(arg0){
  return $clinit_LGraphToCGraphTransformer() , instanceOf(castTo(arg0, 60).origin, 164);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$10$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$10$Type', 1528);
function LGraphToCGraphTransformer$lambda$11$Type(){
}

defineClass(1532, 1, {}, LGraphToCGraphTransformer$lambda$11$Type);
_.accept = function accept_72(arg0){
  var deltaX, vs;
  $clinit_LGraphToCGraphTransformer();
  deltaX = arg0.hitbox.x_0 - arg0.hitboxPreCompaction.x_0;
  vs = castTo(arg0.origin, 164);
  $forEach_0(vs.affectedBends, new LGraphToCGraphTransformer$lambda$21$Type(deltaX));
  $forEach_0(vs.affectedBoundingBoxes, new LGraphToCGraphTransformer$lambda$22$Type(deltaX));
  $forEach(vs.junctionPoints, new LGraphToCGraphTransformer$lambda$23$Type(deltaX));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$11$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$11$Type', 1532);
function LGraphToCGraphTransformer$lambda$12$Type(){
}

defineClass(1533, 1, $intern_11, LGraphToCGraphTransformer$lambda$12$Type);
_.apply_0 = function apply_104(arg0){
  return $clinit_LGraphToCGraphTransformer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator_0($iterator($getOutgoingEdges(castTo(arg0, 9)))));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$12$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$12$Type', 1533);
function LGraphToCGraphTransformer$lambda$13$Type(){
}

defineClass(1534, 1, $intern_90, LGraphToCGraphTransformer$lambda$13$Type);
_.test_0 = function test_54(arg0){
  return $clinit_LGraphToCGraphTransformer() , $isSelfLoop(castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$13$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$13$Type', 1534);
function LGraphToCGraphTransformer$lambda$14$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1535, 1, {}, LGraphToCGraphTransformer$lambda$14$Type);
_.accept = function accept_73(arg0){
  $lambda$14(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$14$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$14$Type', 1535);
function LGraphToCGraphTransformer$lambda$15$Type(){
}

defineClass(1536, 1, $intern_11, LGraphToCGraphTransformer$lambda$15$Type);
_.apply_0 = function apply_105(arg0){
  return $clinit_LGraphToCGraphTransformer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$15$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$15$Type', 1536);
function LGraphToCGraphTransformer$lambda$16$Type(){
}

defineClass(1537, 1, $intern_11, LGraphToCGraphTransformer$lambda$16$Type);
_.apply_0 = function apply_106(arg0){
  return $clinit_LGraphToCGraphTransformer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator_0($iterator($getOutgoingEdges(castTo(arg0, 9)))));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$16$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$16$Type', 1537);
function LGraphToCGraphTransformer$lambda$17$Type(){
}

defineClass(1538, 1, $intern_11, LGraphToCGraphTransformer$lambda$17$Type);
_.apply_0 = function apply_107(arg0){
  return $clinit_LGraphToCGraphTransformer() , castTo($getProperty(castTo(arg0, 16), ($clinit_InternalProperties_1() , SPLINE_ROUTE_START)), 15);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$17$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$17$Type', 1538);
function LGraphToCGraphTransformer$lambda$18$Type(){
}

defineClass(1539, 1, $intern_90, LGraphToCGraphTransformer$lambda$18$Type);
_.test_0 = function test_55(arg0){
  return $clinit_LGraphToCGraphTransformer() , !!castTo(arg0, 15) && !castTo(arg0, 15).isEmpty();
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$18$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$18$Type', 1539);
function LGraphToCGraphTransformer$lambda$19$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1540, 1, {}, LGraphToCGraphTransformer$lambda$19$Type);
_.accept = function accept_74(arg0){
  $adjustSplineControlPoints(this.$$outer_0, castTo(arg0, 15));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$19$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$19$Type', 1540);
function LGraphToCGraphTransformer$lambda$2$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1519, 1, {}, LGraphToCGraphTransformer$lambda$2$Type);
_.accept = function accept_75(arg0){
  $lambda$2_0(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$2$Type', 1519);
function LGraphToCGraphTransformer$lambda$20$Type($$outer_0, vsNode_1){
  this.$$outer_0 = $$outer_0;
  this.vsNode_1 = vsNode_1;
}

defineClass(1518, 1, {}, LGraphToCGraphTransformer$lambda$20$Type);
_.accept = function accept_76(arg0){
  $lambda$20(this.$$outer_0, this.vsNode_1, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$20$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$20$Type', 1518);
function LGraphToCGraphTransformer$lambda$21$Type(deltaX_0){
  this.deltaX_0 = deltaX_0;
}

defineClass(1529, 1, {}, LGraphToCGraphTransformer$lambda$21$Type);
_.accept = function accept_77(arg0){
  lambda$21(this.deltaX_0, arg0);
}
;
_.deltaX_0 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$21$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$21$Type', 1529);
function LGraphToCGraphTransformer$lambda$22$Type(deltaX_0){
  this.deltaX_0 = deltaX_0;
}

defineClass(1530, 1, {}, LGraphToCGraphTransformer$lambda$22$Type);
_.accept = function accept_78(arg0){
  lambda$22(this.deltaX_0, arg0);
}
;
_.deltaX_0 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$22$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$22$Type', 1530);
function LGraphToCGraphTransformer$lambda$23$Type(deltaX_0){
  this.deltaX_0 = deltaX_0;
}

defineClass(1531, 1, {}, LGraphToCGraphTransformer$lambda$23$Type);
_.accept = function accept_79(arg0){
  lambda$23(this.deltaX_0, arg0);
}
;
_.deltaX_0 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$23$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$23$Type', 1531);
function LGraphToCGraphTransformer$lambda$3$Type(){
}

defineClass(1520, 1, $intern_11, LGraphToCGraphTransformer$lambda$3$Type);
_.apply_0 = function apply_108(arg0){
  return $clinit_LGraphToCGraphTransformer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$3$Type', 1520);
function LGraphToCGraphTransformer$lambda$4$Type(){
}

defineClass(1521, 1, $intern_11, LGraphToCGraphTransformer$lambda$4$Type);
_.apply_0 = function apply_109(arg0){
  return $clinit_LGraphToCGraphTransformer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator_0($iterator($getOutgoingEdges(castTo(arg0, 9)))));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$4$Type', 1521);
function LGraphToCGraphTransformer$lambda$5$Type(){
}

defineClass(1522, 1, $intern_11, LGraphToCGraphTransformer$lambda$5$Type);
_.apply_0 = function apply_110(arg0){
  return $clinit_LGraphToCGraphTransformer() , castTo($getProperty(castTo(arg0, 16), ($clinit_InternalProperties_1() , SPLINE_ROUTE_START)), 15);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$5$Type', 1522);
function LGraphToCGraphTransformer$lambda$6$Type(verticalSegments_0){
  this.verticalSegments_0 = verticalSegments_0;
}

defineClass(1524, 1, {}, LGraphToCGraphTransformer$lambda$6$Type);
_.accept = function accept_80(arg0){
  lambda$6_0(this.verticalSegments_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$6$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$6$Type', 1524);
function LGraphToCGraphTransformer$lambda$7$Type($$outer_0, cNode_1){
  this.$$outer_0 = $$outer_0;
  this.cNode_1 = cNode_1;
}

defineClass(1525, 1, {}, LGraphToCGraphTransformer$lambda$7$Type);
_.accept = function accept_81(arg0){
  $lambda$7(this.$$outer_0, this.cNode_1, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$7$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$7$Type', 1525);
function LGraphToCGraphTransformer$lambda$8$Type(){
}

defineClass(1526, 1, $intern_90, LGraphToCGraphTransformer$lambda$8$Type);
_.test_0 = function test_56(arg0){
  return $clinit_LGraphToCGraphTransformer() , instanceOf(castTo(arg0, 60).origin, 9);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$8$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$8$Type', 1526);
function LGraphToCGraphTransformer$lambda$9$Type(){
}

defineClass(1527, 1, {}, LGraphToCGraphTransformer$lambda$9$Type);
_.accept = function accept_82(arg0){
  var lNode;
  $clinit_LGraphToCGraphTransformer();
  lNode = castTo(arg0.origin, 9);
  lNode.pos.x_0 = arg0.hitbox.x_0 + lNode.margin.left;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_LGraphToCGraphTransformer$lambda$9$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'LGraphToCGraphTransformer/lambda$9$Type', 1527);
function $addArtificialSourceNode(this$static){
  var dummySource, lastArg, n, n$iterator, sources, src_0, src$iterator;
  sources = new LinkedList;
  for (n$iterator = new ArrayList$1(this$static.networkSimplexGraph.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 115);
    n.incomingEdges.list.array.length == 0 && ($addNode_0(sources, n, sources.tail.prev, sources.tail) , true);
  }
  if (sources.size_0 > 1) {
    dummySource = $create_2((lastArg = new NNode$NNodeBuilder , ++this$static.index_0 , lastArg), this$static.networkSimplexGraph);
    for (src$iterator = $listIterator_1(sources, 0); src$iterator.currentNode != src$iterator.this$01.tail;) {
      src_0 = castTo($next_13(src$iterator), 115);
      $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 1), 0), dummySource), src_0));
    }
  }
}

function $addEdgeConstraints(this$static){
  var cNode, cNode$iterator, cNode$iterator0, e, e$iterator, lEdge, lEdge$iterator, lEdgeMap, lNode, lNodeMap, n, n$iterator, src_0, srcPort, target, tgt, tgtPort, vs;
  lNodeMap = ($clinit_Maps() , new HashMap);
  lEdgeMap = new HashMultimap;
  for (cNode$iterator0 = new ArrayList$1(this$static.compactor.cGraph.cNodes); cNode$iterator0.i < cNode$iterator0.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator0), 60);
    lNode = getLNodeOrNull(cNode);
    if (lNode) {
      $put_4(lNodeMap.hashCodeMap, lNode, cNode);
    }
     else {
      vs = getVerticalSegmentOrNull(cNode);
      if (vs) {
        for (e$iterator = new ArrayList$1(vs.representedLEdges); e$iterator.i < e$iterator.this$01.array.length;) {
          e = castTo($next_10(e$iterator), 16);
          $put(lEdgeMap, e, cNode);
        }
      }
    }
  }
  for (cNode$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    lNode = getLNodeOrNull(cNode);
    if (lNode) {
      for (lEdge$iterator = $iterator($getOutgoingEdges(lNode)); $hasNext_0(lEdge$iterator);) {
        lEdge = castTo($next_2(lEdge$iterator), 16);
        if ($isSelfLoop(lEdge)) {
          continue;
        }
        srcPort = lEdge.source;
        tgtPort = lEdge.target;
        if (($clinit_PortSide() , SIDES_NORTH_SOUTH).contains(lEdge.source.side) && SIDES_NORTH_SOUTH.contains(lEdge.target.side)) {
          continue;
        }
        target = castTo($get_6(lNodeMap, lEdge.target.owner), 60);
        $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 0), 100), this$static.nNodes[cNode.cGroup.id_0]), this$static.nNodes[target.cGroup.id_0]));
        if (srcPort.side == WEST_1 && $apply_13(($clinit_LPort() , OUTPUT_PREDICATE , srcPort))) {
          for (n$iterator = castTo($get_0(lEdgeMap, lEdge), 19).iterator_0(); n$iterator.hasNext_0();) {
            n = castTo(n$iterator.next_1(), 60);
            if (n.hitbox.x_0 < cNode.hitbox.x_0) {
              src_0 = this$static.nNodes[n.cGroup.id_0];
              tgt = this$static.nNodes[cNode.cGroup.id_0];
              if (src_0 == tgt) {
                continue;
              }
              $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 1), 100), src_0), tgt));
            }
          }
        }
        if (tgtPort.side == EAST_1 && $apply_14(($clinit_LPort() , INPUT_PREDICATE , tgtPort))) {
          for (n$iterator = castTo($get_0(lEdgeMap, lEdge), 19).iterator_0(); n$iterator.hasNext_0();) {
            n = castTo(n$iterator.next_1(), 60);
            if (n.hitbox.x_0 > cNode.hitbox.x_0) {
              src_0 = this$static.nNodes[cNode.cGroup.id_0];
              tgt = this$static.nNodes[n.cGroup.id_0];
              if (src_0 == tgt) {
                continue;
              }
              $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 1), 100), src_0), tgt));
            }
          }
        }
      }
    }
  }
}

function $addSeparationConstraints(this$static){
  var adjust, alterOffset, cNode, cNode$iterator, delta, helper, incNode, incNode$iterator, offsetDelta, port, spacing, weight;
  for (cNode$iterator = new ArrayList$1(this$static.compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    for (incNode$iterator = cNode.constraints.iterator_0(); incNode$iterator.hasNext_0();) {
      incNode = castTo(incNode$iterator.next_1(), 60);
      if (cNode.cGroup == incNode.cGroup) {
        continue;
      }
      $isHorizontal(this$static.compactor.direction)?(spacing = this$static.compactor.spacingsHandler.getHorizontalSpacing(cNode, incNode)):(spacing = this$static.compactor.spacingsHandler.getVerticalSpacing(cNode, incNode));
      delta = cNode.cGroupOffset.x_0 + cNode.hitbox.width_0 + spacing - incNode.cGroupOffset.x_0;
      delta = $wnd.Math.ceil(delta);
      delta = $wnd.Math.max(0, delta);
      if (isVerticalSegmentsOfSameEdge(cNode, incNode)) {
        helper = $create_2(new NNode$NNodeBuilder, this$static.networkSimplexGraph);
        offsetDelta = round_int($wnd.Math.ceil(incNode.cGroupOffset.x_0 - cNode.cGroupOffset.x_0));
        adjust = offsetDelta - (incNode.cGroupOffset.x_0 - cNode.cGroupOffset.x_0);
        port = getVerticalSegmentOrNull(cNode).aPort;
        alterOffset = cNode;
        if (!port) {
          port = getVerticalSegmentOrNull(incNode).aPort;
          adjust = -adjust;
          alterOffset = incNode;
        }
        if (port) {
          alterOffset.cGroupOffset.x_0 -= adjust;
          port.pos.x_0 -= adjust;
        }
        $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 0 > offsetDelta?0:offsetDelta), 1), helper), this$static.nNodes[cNode.cGroup.id_0]));
        $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 0 > -offsetDelta?0:-offsetDelta), 1), helper), this$static.nNodes[incNode.cGroup.id_0]));
      }
       else {
        weight = 1;
        (instanceOf(cNode.origin, 164) && instanceOf(incNode.origin, 9) || instanceOf(incNode.origin, 164) && instanceOf(cNode.origin, 9)) && (weight = 2);
        $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, round_int(delta)), weight), this$static.nNodes[cNode.cGroup.id_0]), this$static.nNodes[incNode.cGroup.id_0]));
      }
    }
  }
}

function NetworkSimplexCompaction(){
}

defineClass(1514, 1, {}, NetworkSimplexCompaction);
_.compact = function compact_1(theCompactor){
  var cGroup, cGroup$iterator, cNode, cNode$iterator, nNode;
  this.compactor = theCompactor;
  this.networkSimplexGraph = new NGraph;
  this.nNodes = initUnidimensionalArray(Lorg_eclipse_elk_alg_common_networksimplex_NNode_2_classLit, $intern_1, 115, this.compactor.cGraph.cGroups.array.length, 0, 1);
  this.index_0 = 0;
  for (cGroup$iterator = new ArrayList$1(this.compactor.cGraph.cGroups); cGroup$iterator.i < cGroup$iterator.this$01.array.length;) {
    cGroup = castTo($next_10(cGroup$iterator), 316);
    cGroup.id_0 = this.index_0;
    nNode = $create_2($origin_0(new NNode$NNodeBuilder, cGroup), this.networkSimplexGraph);
    this.nNodes[this.index_0] = nNode;
    ++this.index_0;
  }
  $addSeparationConstraints(this);
  $addEdgeConstraints(this);
  $addArtificialSourceNode(this);
  $execute(forGraph(this.networkSimplexGraph), new BasicProgressMonitor);
  for (cNode$iterator = new ArrayList$1(this.compactor.cGraph.cNodes); cNode$iterator.i < cNode$iterator.this$01.array.length;) {
    cNode = castTo($next_10(cNode$iterator), 60);
    cNode.hitbox.x_0 = this.nNodes[cNode.cGroup.id_0].layer + cNode.cGroupOffset.x_0;
  }
}
;
_.index_0 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_NetworkSimplexCompaction_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'NetworkSimplexCompaction', 1514);
function $compareTo_12(this$static, o){
  var d;
  d = fuzzyCompare(this$static.hitbox.x_0, o.hitbox.x_0);
  if (d == 0) {
    return compare_5(this$static.hitbox.y_0, o.hitbox.y_0);
  }
  return d;
}

function $toString_10(this$static){
  var sb;
  sb = new StringBuilder;
  sb.string += 'VerticalSegment ';
  $append_10(sb, this$static.hitbox);
  sb.string += ' ';
  $append_11(sb, $join(new Joiner(', '), new ArrayList$1(this$static.representedLEdges)));
  return sb.string;
}

function VerticalSegment(bend1, bend2, cNode, lEdge){
  var inJPs, jp, jp$iterator;
  this.potentialGroupParents = new ArrayList;
  this.representedLEdges = new ArrayList;
  this.affectedBends = new ArrayList;
  this.affectedBoundingBoxes = new ArrayList;
  this.hitbox = new ElkRectangle;
  this.junctionPoints = new KVectorChain;
  this.ignoreSpacing = new Quadruplet;
  this.constraints = new ArrayList;
  this.joined = new ArrayList;
  $add_4(this.affectedBends, bend1);
  $add_4(this.affectedBends, bend2);
  this.hitbox.x_0 = $wnd.Math.min(bend1.x_0, bend2.x_0);
  this.hitbox.y_0 = $wnd.Math.min(bend1.y_0, bend2.y_0);
  this.hitbox.width_0 = $wnd.Math.abs(bend1.x_0 - bend2.x_0);
  this.hitbox.height = $wnd.Math.abs(bend1.y_0 - bend2.y_0);
  inJPs = castTo($getProperty(lEdge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
  if (inJPs) {
    for (jp$iterator = $listIterator_1(inJPs, 0); jp$iterator.currentNode != jp$iterator.this$01.tail;) {
      jp = castTo($next_13(jp$iterator), 8);
      eq_0(jp.x_0, bend1.x_0) && $add_7(this.junctionPoints, jp);
    }
  }
  !!cNode && $add_4(this.potentialGroupParents, cNode);
  $add_4(this.representedLEdges, lEdge);
}

defineClass(164, 1, {34:1, 164:1}, VerticalSegment);
_.compareTo_0 = function compareTo_13(o){
  return $compareTo_12(this, castTo(o, 164));
}
;
_.toString_0 = function toString_93(){
  return $toString_10(this);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_compaction_VerticalSegment_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.compaction', 'VerticalSegment', 164);
function $addEasternCrossings(this$static, upperNode, lowerNode){
  this$static.upperAdjacencies = $getAdjacencyFor(this$static, upperNode, ($clinit_PortSide() , EAST_1), this$static.easternAdjacencies);
  this$static.lowerAdjacencies = $getAdjacencyFor(this$static, lowerNode, EAST_1, this$static.easternAdjacencies);
  if (this$static.upperAdjacencies.currentSize == 0 || this$static.lowerAdjacencies.currentSize == 0) {
    return;
  }
  $countCrossingsByMergingAdjacencyLists(this$static);
}

function $addWesternCrossings(this$static, upperNode, lowerNode){
  this$static.upperAdjacencies = $getAdjacencyFor(this$static, upperNode, ($clinit_PortSide() , WEST_1), this$static.westernAdjacencies);
  this$static.lowerAdjacencies = $getAdjacencyFor(this$static, lowerNode, WEST_1, this$static.westernAdjacencies);
  if (this$static.upperAdjacencies.currentSize == 0 || this$static.lowerAdjacencies.currentSize == 0) {
    return;
  }
  $countCrossingsByMergingAdjacencyLists(this$static);
}

function $countBothSideCrossings(this$static, upperNode, lowerNode){
  this$static.upperLowerCrossings = 0;
  this$static.lowerUpperCrossings = 0;
  if (upperNode == lowerNode) {
    return;
  }
  $addWesternCrossings(this$static, upperNode, lowerNode);
  $addEasternCrossings(this$static, upperNode, lowerNode);
}

function $countCrossingsByMergingAdjacencyLists(this$static){
  while (this$static.upperAdjacencies.currentSize != 0 && this$static.lowerAdjacencies.currentSize != 0) {
    if ($currentAdjacency(this$static.upperAdjacencies).position > $currentAdjacency(this$static.lowerAdjacencies).position) {
      this$static.upperLowerCrossings += this$static.upperAdjacencies.currentSize;
      $removeFirst_1(this$static.lowerAdjacencies);
    }
     else if ($currentAdjacency(this$static.lowerAdjacencies).position > $currentAdjacency(this$static.upperAdjacencies).position) {
      this$static.lowerUpperCrossings += this$static.lowerAdjacencies.currentSize;
      $removeFirst_1(this$static.upperAdjacencies);
    }
     else {
      this$static.upperLowerCrossings += $countAdjacenciesBelowNodeOfFirstPort(this$static.upperAdjacencies);
      this$static.lowerUpperCrossings += $countAdjacenciesBelowNodeOfFirstPort(this$static.lowerAdjacencies);
      $removeFirst_1(this$static.upperAdjacencies);
      $removeFirst_1(this$static.lowerAdjacencies);
    }
  }
}

function $countEasternEdgeCrossings(this$static, upperNode, lowerNode){
  this$static.upperLowerCrossings = 0;
  this$static.lowerUpperCrossings = 0;
  if (upperNode == lowerNode) {
    return;
  }
  $addEasternCrossings(this$static, upperNode, lowerNode);
}

function $countWesternEdgeCrossings(this$static, upperNode, lowerNode){
  this$static.upperLowerCrossings = 0;
  this$static.lowerUpperCrossings = 0;
  if (upperNode == lowerNode) {
    return;
  }
  $addWesternCrossings(this$static, upperNode, lowerNode);
}

function $getAdjacencyFor(this$static, node, side, adjacencies){
  var aL, n, n$array, n$index, n$max;
  if (adjacencies.hashCodeMap.size_0 + adjacencies.stringMap.size_0 == 0) {
    for (n$array = this$static.currentNodeOrder[this$static.freeLayerIndex] , n$index = 0 , n$max = n$array.length; n$index < n$max; ++n$index) {
      n = n$array[n$index];
      $put_1(adjacencies, n, new BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList(this$static, n, side));
    }
  }
  aL = castTo(getEntryValueOrNull($getEntry(adjacencies.hashCodeMap, node)), 622);
  aL.currentIndex = 0;
  aL.currentSize = aL.size_0;
  aL.currentSize == 0 || $reset_3(castTo($get_7(aL.adjacencyList, aL.currentIndex), 280));
  return aL;
}

function $setPortPositionsForLayer(this$static, layerIndex, portSide){
  var node, node$array, node$index, node$max, port, port$iterator, portId, ports;
  portId = 0;
  for (node$array = this$static.currentNodeOrder[layerIndex] , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    ports = inNorthSouthEastWestOrder(node, portSide);
    for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 11);
      $put_1(this$static.portPositions, port, valueOf_4(portId++));
    }
  }
}

function BetweenLayerEdgeTwoNodeCrossingsCounter(currentNodeOrder, freeLayerIndex){
  this.portPositions = ($clinit_Maps() , new HashMap);
  this.easternAdjacencies = new HashMap;
  this.westernAdjacencies = new HashMap;
  this.currentNodeOrder = currentNodeOrder;
  this.freeLayerIndex = freeLayerIndex;
  this.freeLayerIndex > 0 && $setPortPositionsForLayer(this, this.freeLayerIndex - 1, ($clinit_PortSide() , EAST_1));
  this.freeLayerIndex < this.currentNodeOrder.length - 1 && $setPortPositionsForLayer(this, this.freeLayerIndex + 1, ($clinit_PortSide() , WEST_1));
}

defineClass(764, 1, {}, BetweenLayerEdgeTwoNodeCrossingsCounter);
_.freeLayerIndex = 0;
_.lowerUpperCrossings = 0;
_.upperLowerCrossings = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_greedyswitch_BetweenLayerEdgeTwoNodeCrossingsCounter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.greedyswitch', 'BetweenLayerEdgeTwoNodeCrossingsCounter', 764);
function $addAdjacencyOf(this$static, edge){
  var adjacentPort, adjacentPortPosition, lastIndex;
  adjacentPort = $adjacentPortOf(edge, this$static.side);
  adjacentPortPosition = castTo($get_6(this$static.this$01.portPositions, adjacentPort), 21).value_0;
  lastIndex = this$static.adjacencyList.array.length - 1;
  if (this$static.adjacencyList.array.length != 0 && castTo($get_7(this$static.adjacencyList, lastIndex), 280).position == adjacentPortPosition) {
    ++castTo($get_7(this$static.adjacencyList, lastIndex), 280).cardinality;
    ++castTo($get_7(this$static.adjacencyList, lastIndex), 280).currentCardinality;
  }
   else {
    $add_4(this$static.adjacencyList, new BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList$Adjacency(adjacentPortPosition));
  }
}

function $adjacentPortOf(e, s){
  return s == ($clinit_PortSide() , WEST_1)?e.source:e.target;
}

function $countAdjacenciesBelowNodeOfFirstPort(this$static){
  return this$static.currentSize - castTo($get_7(this$static.adjacencyList, this$static.currentIndex), 280).currentCardinality;
}

function $currentAdjacency(this$static){
  return castTo($get_7(this$static.adjacencyList, this$static.currentIndex), 280);
}

function $iterateTroughEdgesCollectingAdjacencies(this$static){
  var edge, edge$iterator, edges, port, port$iterator, ports;
  ports = inNorthSouthEastWestOrder(this$static.node, this$static.side);
  for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    edges = this$static.side == ($clinit_PortSide() , WEST_1)?port.incomingEdges:port.outgoingEdges;
    for (edge$iterator = new ArrayList$1(edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 16);
      if (!$isSelfLoop(edge) && edge.source.owner.layer != edge.target.owner.layer) {
        $addAdjacencyOf(this$static, edge);
        ++this$static.size_0;
        ++this$static.currentSize;
      }
    }
  }
}

function $removeFirst_1(this$static){
  var currentEntry;
  if (this$static.currentSize == 0) {
    return;
  }
  currentEntry = castTo($get_7(this$static.adjacencyList, this$static.currentIndex), 280);
  currentEntry.currentCardinality == 1?(++this$static.currentIndex , this$static.currentIndex < this$static.adjacencyList.array.length && $reset_3(castTo($get_7(this$static.adjacencyList, this$static.currentIndex), 280))):--currentEntry.currentCardinality;
  --this$static.currentSize;
}

function BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList(this$0, node, side){
  this.this$01 = this$0;
  this.node = node;
  this.side = side;
  this.adjacencyList = new ArrayList;
  $iterateTroughEdgesCollectingAdjacencies(this);
  $clinit_Collections();
  $sort(this.adjacencyList, null);
}

defineClass(622, 1, {622:1}, BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList);
_.toString_0 = function toString_94(){
  return 'AdjacencyList [node=' + this.node + ', adjacencies= ' + this.adjacencyList + ']';
}
;
_.currentIndex = 0;
_.currentSize = 0;
_.size_0 = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_greedyswitch_BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.greedyswitch', 'BetweenLayerEdgeTwoNodeCrossingsCounter/AdjacencyList', 622);
function $compareTo_13(this$static, o){
  return this$static.position < o.position?-1:this$static.position == o.position?0:1;
}

function $reset_3(this$static){
  this$static.currentCardinality = this$static.cardinality;
}

function BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList$Adjacency(adjacentPortPosition){
  this.position = adjacentPortPosition;
  this.cardinality = 1;
  this.currentCardinality = 1;
}

defineClass(280, 1, {34:1, 280:1}, BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList$Adjacency);
_.compareTo_0 = function compareTo_14(o){
  return $compareTo_13(this, castTo(o, 280));
}
;
_.toString_0 = function toString_95(){
  return 'Adjacency [position=' + this.position + ', cardinality=' + this.cardinality + ', currentCardinality=' + this.currentCardinality + ']';
}
;
_.cardinality = 0;
_.currentCardinality = 0;
_.position = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_greedyswitch_BetweenLayerEdgeTwoNodeCrossingsCounter$AdjacencyList$Adjacency_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.greedyswitch', 'BetweenLayerEdgeTwoNodeCrossingsCounter/AdjacencyList/Adjacency', 280);
function $fillCrossingMatrix(this$static, upperNode, lowerNode){
  if (this$static.oneSided) {
    switch (this$static.direction) {
      case 1:
        $countEasternEdgeCrossings(this$static.inBetweenLayerCrossingCounter, upperNode, lowerNode);
        break;
      case 0:
        $countWesternEdgeCrossings(this$static.inBetweenLayerCrossingCounter, upperNode, lowerNode);
    }
  }
   else {
    $countBothSideCrossings(this$static.inBetweenLayerCrossingCounter, upperNode, lowerNode);
  }
  this$static.crossingMatrix[upperNode.id_0][lowerNode.id_0] = this$static.inBetweenLayerCrossingCounter.upperLowerCrossings;
  this$static.crossingMatrix[lowerNode.id_0][upperNode.id_0] = this$static.inBetweenLayerCrossingCounter.lowerUpperCrossings;
}

function $getCrossingMatrixEntry(this$static, upperNode, lowerNode){
  if (!this$static.isCrossingMatrixFilled[upperNode.id_0][lowerNode.id_0]) {
    $fillCrossingMatrix(this$static, upperNode, lowerNode);
    this$static.isCrossingMatrixFilled[upperNode.id_0][lowerNode.id_0] = true;
    this$static.isCrossingMatrixFilled[lowerNode.id_0][upperNode.id_0] = true;
  }
  return this$static.crossingMatrix[upperNode.id_0][lowerNode.id_0];
}

function CrossingMatrixFiller(greedySwitchType, graph, freeLayerIndex, direction){
  var freeLayer;
  this.direction = direction;
  this.oneSided = greedySwitchType == ($clinit_LayerSweepCrossingMinimizer$CrossMinType() , ONE_SIDED_GREEDY_SWITCH_0);
  freeLayer = graph[freeLayerIndex];
  this.isCrossingMatrixFilled = initMultidimensionalArray(Z_classLit, [$intern_33, $intern_93], [229, 23], 16, [freeLayer.length, freeLayer.length], 2);
  this.crossingMatrix = initMultidimensionalArray(I_classLit, [$intern_33, $intern_49], [40, 23], 15, [freeLayer.length, freeLayer.length], 2);
  this.inBetweenLayerCrossingCounter = new BetweenLayerEdgeTwoNodeCrossingsCounter(graph, freeLayerIndex);
}

defineClass(1711, 1, {}, CrossingMatrixFiller);
_.direction = 0;
_.oneSided = false;
var Lorg_eclipse_elk_alg_layered_intermediate_greedyswitch_CrossingMatrixFiller_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.greedyswitch', 'CrossingMatrixFiller', 1711);
function init_0(initializables, order){
  var e, edge, edge$iterator, i, i$iterator, i$iterator0, i$iterator1, i$iterator2, i$iterator3, l, n, p, port, ports;
  for (l = 0; l < order.length; l++) {
    for (i$iterator0 = initializables.iterator_0(); i$iterator0.hasNext_0();) {
      i = castTo(i$iterator0.next_1(), 215);
      i.initAtLayerLevel(l, order);
    }
    for (n = 0; n < order[l].length; n++) {
      for (i$iterator1 = initializables.iterator_0(); i$iterator1.hasNext_0();) {
        i = castTo(i$iterator1.next_1(), 215);
        i.initAtNodeLevel(l, n, order);
      }
      ports = order[l][n].ports;
      for (p = 0; p < ports.array.length; p++) {
        for (i$iterator2 = initializables.iterator_0(); i$iterator2.hasNext_0();) {
          i = castTo(i$iterator2.next_1(), 215);
          i.initAtPortLevel(l, n, p, order);
        }
        port = (checkCriticalElementIndex(p, ports.array.length) , castTo(ports.array[p], 11));
        e = 0;
        for (edge$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(edge$iterator.firstIterator) || $hasNext_2(edge$iterator.secondIterator);) {
          edge = castTo($hasNext_2(edge$iterator.firstIterator)?$next_10(edge$iterator.firstIterator):$next_10(edge$iterator.secondIterator), 16);
          for (i$iterator3 = initializables.iterator_0(); i$iterator3.hasNext_0();) {
            i = castTo(i$iterator3.next_1(), 215);
            i.initAtEdgeLevel(l, n, p, e++, edge, order);
          }
        }
      }
    }
  }
  for (i$iterator = initializables.iterator_0(); i$iterator.hasNext_0();) {
    i = castTo(i$iterator.next_1(), 215);
    i.initAfterTraversal();
  }
}

var Lorg_eclipse_elk_alg_layered_p3order_counting_IInitializable_2_classLit = createForInterface('org.eclipse.elk.alg.layered.p3order.counting', 'IInitializable');
function $continueSwitchingUntilNoImprovementInLayer(this$static, freeLayerIndex){
  var continueSwitching, improved;
  improved = false;
  do {
    continueSwitching = $sweepDownwardInLayer(this$static, freeLayerIndex);
    improved = improved | continueSwitching;
  }
   while (continueSwitching);
  return improved;
}

function $setUp(this$static, order, freeLayerIndex, forwardSweep){
  var crossingMatrixFiller, side;
  this$static.currentNodeOrder = order;
  side = forwardSweep?0:1;
  this$static.switchDecider = (crossingMatrixFiller = new CrossingMatrixFiller(this$static.greedySwitchType, this$static.currentNodeOrder, freeLayerIndex, side) , new SwitchDecider(freeLayerIndex, this$static.currentNodeOrder, crossingMatrixFiller, this$static.portPositions, this$static.graphData, this$static.greedySwitchType == ($clinit_LayerSweepCrossingMinimizer$CrossMinType() , ONE_SIDED_GREEDY_SWITCH_0)));
}

function $startIndex(isForwardSweep, length_0){
  return isForwardSweep?0:length_0 - 1;
}

function $sweepDownwardInLayer(this$static, layerIndex){
  var continueSwitching, lengthOfFreeLayer, lowerNodeIndex, upperNodeIndex;
  continueSwitching = false;
  lengthOfFreeLayer = this$static.currentNodeOrder[layerIndex].length;
  for (upperNodeIndex = 0; upperNodeIndex < lengthOfFreeLayer - 1; upperNodeIndex++) {
    lowerNodeIndex = upperNodeIndex + 1;
    continueSwitching = continueSwitching | $switchIfImproves(this$static, layerIndex, upperNodeIndex, lowerNodeIndex);
  }
  return continueSwitching;
}

function $switchIfImproves(this$static, layerIndex, upperNodeIndex, lowerNodeIndex){
  var continueSwitching, layer, temp;
  continueSwitching = false;
  if ($doesSwitchReduceCrossings(this$static.switchDecider, upperNodeIndex, lowerNodeIndex)) {
    $notifyOfSwitch(this$static.switchDecider, this$static.currentNodeOrder[layerIndex][upperNodeIndex], this$static.currentNodeOrder[layerIndex][lowerNodeIndex]);
    layer = this$static.currentNodeOrder[layerIndex];
    temp = layer[lowerNodeIndex];
    layer[lowerNodeIndex] = layer[upperNodeIndex];
    layer[upperNodeIndex] = temp;
    continueSwitching = true;
  }
  return continueSwitching;
}

function GreedySwitchHeuristic(greedyType, graphData){
  this.graphData = graphData;
  this.greedySwitchType = greedyType;
}

defineClass(1612, 1, $intern_115, GreedySwitchHeuristic);
_.initAtEdgeLevel = function initAtEdgeLevel(l, n, p, e, edge, nodeOrder){
}
;
_.initAtNodeLevel = function initAtNodeLevel(l, n, nodeOrder){
}
;
_.alwaysImproves = function alwaysImproves(){
  return this.greedySwitchType != ($clinit_LayerSweepCrossingMinimizer$CrossMinType() , ONE_SIDED_GREEDY_SWITCH_0);
}
;
_.initAfterTraversal = function initAfterTraversal(){
  this.portPositions = initUnidimensionalArray(I_classLit, $intern_49, 23, this.nPorts, 15, 1);
}
;
_.initAtLayerLevel = function initAtLayerLevel(l, nodeOrder){
  nodeOrder[l][0].layer.id_0 = l;
}
;
_.initAtPortLevel = function initAtPortLevel(l, n, p, nodeOrder){
  ++this.nPorts;
}
;
_.isDeterministic = function isDeterministic(){
  return true;
}
;
_.minimizeCrossings = function minimizeCrossings(order, freeLayerIndex, forwardSweep, isFirstSweep){
  $setUp(this, order, freeLayerIndex, forwardSweep);
  return $continueSwitchingUntilNoImprovementInLayer(this, freeLayerIndex);
}
;
_.setFirstLayerOrder = function setFirstLayerOrder(currentOrder, isForwardSweep){
  var startIndex;
  startIndex = $startIndex(isForwardSweep, currentOrder.length);
  $setUp(this, currentOrder, startIndex, isForwardSweep);
  return $sweepDownwardInLayer(this, startIndex);
}
;
_.nPorts = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_greedyswitch_GreedySwitchHeuristic_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.greedyswitch', 'GreedySwitchHeuristic', 1612);
function $countCrossings(this$static, upperNode, lowerNode){
  this$static.upperLowerCrossings = 0;
  this$static.lowerUpperCrossings = 0;
  upperNode.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT) && lowerNode.type_0 == NORTH_SOUTH_PORT && castTo($getProperty(upperNode, ($clinit_InternalProperties_1() , ORIGIN_0)), 9) == castTo($getProperty(lowerNode, ORIGIN_0), 9) && ($originPortOf(upperNode).side == ($clinit_PortSide() , NORTH_1)?$countCrossingsOfTwoNorthSouthDummies(this$static, upperNode, lowerNode):$countCrossingsOfTwoNorthSouthDummies(this$static, lowerNode, upperNode));
  upperNode.type_0 == NORTH_SOUTH_PORT && lowerNode.type_0 == LONG_EDGE?$originPortOf(upperNode).side == ($clinit_PortSide() , NORTH_1)?(this$static.upperLowerCrossings = 1):(this$static.lowerUpperCrossings = 1):lowerNode.type_0 == NORTH_SOUTH_PORT && upperNode.type_0 == LONG_EDGE && ($originPortOf(lowerNode).side == ($clinit_PortSide() , NORTH_1)?(this$static.lowerUpperCrossings = 1):(this$static.upperLowerCrossings = 1));
  $processIfNormalNodeWithNSPortsAndLongEdgeDummy(this$static, upperNode, lowerNode);
}

function $countCrossingsOfTwoNorthSouthDummies(this$static, furtherFromNormalNode, closerToNormalNode){
  var closerEastPorts, closerWestPorts, furtherEastPorts, furtherWestPorts;
  if ($originPortPositionOf(this$static, furtherFromNormalNode) > $originPortPositionOf(this$static, closerToNormalNode)) {
    closerEastPorts = $getPortSideView(closerToNormalNode, ($clinit_PortSide() , EAST_1));
    this$static.upperLowerCrossings = closerEastPorts.isEmpty()?0:$getDegree(castTo(closerEastPorts.get_3(0), 11));
    furtherWestPorts = $getPortSideView(furtherFromNormalNode, WEST_1);
    this$static.lowerUpperCrossings = furtherWestPorts.isEmpty()?0:$getDegree(castTo(furtherWestPorts.get_3(0), 11));
  }
   else {
    closerWestPorts = $getPortSideView(closerToNormalNode, ($clinit_PortSide() , WEST_1));
    this$static.upperLowerCrossings = closerWestPorts.isEmpty()?0:$getDegree(castTo(closerWestPorts.get_3(0), 11));
    furtherEastPorts = $getPortSideView(furtherFromNormalNode, EAST_1);
    this$static.lowerUpperCrossings = furtherEastPorts.isEmpty()?0:$getDegree(castTo(furtherEastPorts.get_3(0), 11));
  }
}

function $initializePortPositions(this$static){
  var node, node$array, node$index, node$max;
  for (node$array = this$static.layer , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    $setPortIdsOn(this$static, node, ($clinit_PortSide() , SOUTH_1));
    $setPortIdsOn(this$static, node, NORTH_1);
  }
}

function $numberOfNorthSouthEdges(node, side){
  var numberOfEdges, port, port$iterator;
  numberOfEdges = 0;
  for (port$iterator = $getPortSideView(node, side).iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    numberOfEdges += $getProperty(port, ($clinit_InternalProperties_1() , PORT_DUMMY)) != null?1:0;
  }
  return numberOfEdges;
}

function $originPortOf(node){
  var origin, port;
  port = castTo($get_7(node.ports, 0), 11);
  origin = castTo($getProperty(port, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
  return origin;
}

function $originPortPositionOf(this$static, node){
  var origin;
  origin = $originPortOf(node);
  return castTo($get_6(this$static.portPositions, origin), 21).value_0;
}

function $processIfNormalNodeWithNSPortsAndLongEdgeDummy(this$static, upperNode, lowerNode){
  if (upperNode.type_0 == ($clinit_LNode$NodeType() , NORMAL) && lowerNode.type_0 == LONG_EDGE) {
    this$static.upperLowerCrossings = $numberOfNorthSouthEdges(upperNode, ($clinit_PortSide() , SOUTH_1));
    this$static.lowerUpperCrossings = $numberOfNorthSouthEdges(upperNode, NORTH_1);
  }
  if (lowerNode.type_0 == NORMAL && upperNode.type_0 == LONG_EDGE) {
    this$static.upperLowerCrossings = $numberOfNorthSouthEdges(lowerNode, ($clinit_PortSide() , NORTH_1));
    this$static.lowerUpperCrossings = $numberOfNorthSouthEdges(lowerNode, SOUTH_1);
  }
}

function $setPortIdsOn(this$static, node, side){
  var port, port$iterator, portId, ports;
  ports = inNorthSouthEastWestOrder(node, side);
  portId = 0;
  for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    $put_1(this$static.portPositions, port, valueOf_4(portId++));
  }
}

function NorthSouthEdgeNeighbouringNodeCrossingsCounter(nodes){
  this.layer = nodes;
  this.portPositions = new HashMap;
  $initializePortPositions(this);
}

defineClass(1712, 1, {}, NorthSouthEdgeNeighbouringNodeCrossingsCounter);
_.lowerUpperCrossings = 0;
_.upperLowerCrossings = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_greedyswitch_NorthSouthEdgeNeighbouringNodeCrossingsCounter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.greedyswitch', 'NorthSouthEdgeNeighbouringNodeCrossingsCounter', 1712);
function $doesSwitchReduceCrossings(this$static, upperNodeIndex, lowerNodeIndex){
  var crossingNumbers, leftInlayer, lowerNode, lowerPort, lowerUpperCrossings, rightInlayer, upperLowerCrossings, upperNode, upperPort, upperNode_0, lowerNode_0, constraints, neitherNodeIsLongEdgeDummy, upperLayoutUnit, lowerLayoutUnit, areInDifferentLayoutUnits, nodesHaveLayoutUnits, upperNodeHasNorthernEdges, lowerNodeHasSouthernEdges, hasLayoutUnitConstraint;
  if (upperNode_0 = this$static.freeLayer[upperNodeIndex] , lowerNode_0 = this$static.freeLayer[lowerNodeIndex] , (constraints = castTo($getProperty(upperNode_0, ($clinit_InternalProperties_1() , IN_LAYER_SUCCESSOR_CONSTRAINTS)), 15) , !!constraints && constraints.size_1() != 0 && constraints.contains(lowerNode_0)) || (neitherNodeIsLongEdgeDummy = upperNode_0.type_0 != ($clinit_LNode$NodeType() , LONG_EDGE) && lowerNode_0.type_0 != LONG_EDGE , upperLayoutUnit = castTo($getProperty(upperNode_0, IN_LAYER_LAYOUT_UNIT), 9) , lowerLayoutUnit = castTo($getProperty(lowerNode_0, IN_LAYER_LAYOUT_UNIT), 9) , areInDifferentLayoutUnits = upperLayoutUnit != lowerLayoutUnit , nodesHaveLayoutUnits = !!upperLayoutUnit && upperLayoutUnit != upperNode_0 || !!lowerLayoutUnit && lowerLayoutUnit != lowerNode_0 , upperNodeHasNorthernEdges = $hasEdgesOnSide(upperNode_0, ($clinit_PortSide() , NORTH_1)) , lowerNodeHasSouthernEdges = $hasEdgesOnSide(lowerNode_0, SOUTH_1) , nodesHaveLayoutUnits = nodesHaveLayoutUnits | ($hasEdgesOnSide(upperNode_0, SOUTH_1) || $hasEdgesOnSide(lowerNode_0, NORTH_1)) , hasLayoutUnitConstraint = nodesHaveLayoutUnits && areInDifferentLayoutUnits || upperNodeHasNorthernEdges || lowerNodeHasSouthernEdges , neitherNodeIsLongEdgeDummy && hasLayoutUnitConstraint) || upperNode_0.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT) && lowerNode_0.type_0 == NORMAL || lowerNode_0.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT) && upperNode_0.type_0 == NORMAL) {
    return false;
  }
  upperNode = this$static.freeLayer[upperNodeIndex];
  lowerNode = this$static.freeLayer[lowerNodeIndex];
  leftInlayer = $countInLayerCrossingsBetweenNodesInBothOrders(this$static.leftInLayerCounter, upperNode, lowerNode, ($clinit_PortSide() , WEST_1));
  rightInlayer = $countInLayerCrossingsBetweenNodesInBothOrders(this$static.rightInLayerCounter, upperNode, lowerNode, EAST_1);
  $countCrossings(this$static.northSouthCounter, upperNode, lowerNode);
  upperLowerCrossings = $getCrossingMatrixEntry(this$static.crossingMatrixFiller, upperNode, lowerNode) + castTo(leftInlayer.first, 21).value_0 + castTo(rightInlayer.first, 21).value_0 + this$static.northSouthCounter.upperLowerCrossings;
  lowerUpperCrossings = $getCrossingMatrixEntry(this$static.crossingMatrixFiller, lowerNode, upperNode) + castTo(leftInlayer.second, 21).value_0 + castTo(rightInlayer.second, 21).value_0 + this$static.northSouthCounter.lowerUpperCrossings;
  if (this$static.countCrossingsCausedByPortSwitch) {
    upperPort = castTo($getProperty(upperNode, ORIGIN_0), 11);
    lowerPort = castTo($getProperty(lowerNode, ORIGIN_0), 11);
    crossingNumbers = $countCrossingsBetweenPortsInBothOrders(this$static.parentCrossCounter, upperPort, lowerPort);
    upperLowerCrossings += castTo(crossingNumbers.first, 21).value_0;
    lowerUpperCrossings += castTo(crossingNumbers.second, 21).value_0;
  }
  return upperLowerCrossings > lowerUpperCrossings;
}

function $hasEdgesOnSide(node, side){
  var port, port$iterator, ports;
  ports = $getPortSideView(node, side);
  for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    if ($getProperty(port, ($clinit_InternalProperties_1() , PORT_DUMMY)) != null || $hasNext_5(new LPort$CombineIter$1(port.connectedEdges))) {
      return true;
    }
  }
  return false;
}

function $initParentCrossingsCounters(this$static, freeLayerIndex, length_0){
  var leftLayer, middleLayer, parentGraphData, parentNodeLayerPos, parentNodeOrder, portPos, rightLayer, rightMostLayer;
  parentGraphData = this$static.graphData.parentGraphData;
  parentNodeOrder = parentGraphData.currentNodeOrder;
  portPos = parentGraphData.portPositions;
  this$static.parentCrossCounter = new CrossingsCounter(portPos);
  parentNodeLayerPos = this$static.graphData.parent_0.layer.id_0;
  leftLayer = parentNodeLayerPos > 0?parentNodeOrder[parentNodeLayerPos - 1]:initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, 0, 0, 1);
  middleLayer = parentNodeOrder[parentNodeLayerPos];
  rightLayer = parentNodeLayerPos < parentNodeOrder.length - 1?parentNodeOrder[parentNodeLayerPos + 1]:initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, 0, 0, 1);
  rightMostLayer = freeLayerIndex == length_0 - 1;
  rightMostLayer?$initForCountingBetween(this$static.parentCrossCounter, middleLayer, rightLayer):$initForCountingBetween(this$static.parentCrossCounter, leftLayer, middleLayer);
}

function $notifyOfSwitch(this$static, upperNode, lowerNode){
  var lowerPort, upperPort;
  $switchNodes(this$static.leftInLayerCounter, upperNode, lowerNode, ($clinit_PortSide() , WEST_1));
  $switchNodes(this$static.rightInLayerCounter, upperNode, lowerNode, EAST_1);
  if (this$static.countCrossingsCausedByPortSwitch) {
    upperPort = castTo($getProperty(upperNode, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
    lowerPort = castTo($getProperty(lowerNode, ORIGIN_0), 11);
    $switchPorts(this$static.parentCrossCounter, upperPort, lowerPort);
  }
}

function SwitchDecider(freeLayerIndex, graph, crossingMatrixFiller, portPositions, graphData, oneSided){
  this.crossingMatrixFiller = crossingMatrixFiller;
  this.graphData = graphData;
  if (freeLayerIndex >= graph.length) {
    throw toJs(new IndexOutOfBoundsException_0('Greedy SwitchDecider: Free layer not in graph.'));
  }
  this.freeLayer = graph[freeLayerIndex];
  this.leftInLayerCounter = new CrossingsCounter(portPositions);
  $initPortPositionsForInLayerCrossings(this.leftInLayerCounter, this.freeLayer, ($clinit_PortSide() , WEST_1));
  this.rightInLayerCounter = new CrossingsCounter(portPositions);
  $initPortPositionsForInLayerCrossings(this.rightInLayerCounter, this.freeLayer, EAST_1);
  this.northSouthCounter = new NorthSouthEdgeNeighbouringNodeCrossingsCounter(this.freeLayer);
  this.countCrossingsCausedByPortSwitch = !oneSided && graphData.hasParent && !graphData.useBottomUp && this.freeLayer[0].type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT);
  this.countCrossingsCausedByPortSwitch && $initParentCrossingsCounters(this, freeLayerIndex, graph.length);
}

defineClass(1708, 1, {}, SwitchDecider);
_.countCrossingsCausedByPortSwitch = false;
var Lorg_eclipse_elk_alg_layered_intermediate_greedyswitch_SwitchDecider_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.greedyswitch', 'SwitchDecider', 1708);
function ARDCutIndexHeuristic(){
}

function getChunkCount(gs){
  var rows_0, rowsd;
  rowsd = $wnd.Math.sqrt((gs.sumWidth == null && (gs.sumWidth = $determineWidth(gs, new GraphStats$lambda$0$Type)) , checkNotNull_1(gs.sumWidth) / (gs.dar * (gs.maxHeight == null && (gs.maxHeight = $determineHeight(gs, new GraphStats$2methodref$max$Type)) , checkNotNull_1(gs.maxHeight)))));
  rows_0 = toInt_0(fromDouble_0($wnd.Math.round(rowsd)));
  rows_0 = min_1(rows_0, gs.longestPath);
  return rows_0;
}

defineClass(743, 1, {}, ARDCutIndexHeuristic);
_.getCutIndexes = function getCutIndexes(graph, gs){
  var cuts, idx, rows_0, step;
  rows_0 = getChunkCount(gs);
  cuts = new ArrayList;
  step = gs.longestPath / rows_0;
  for (idx = 1; idx < rows_0; ++idx) {
    $add_4(cuts, valueOf_4(toInt_0(fromDouble_0($wnd.Math.round(idx * step)))));
  }
  return cuts;
}
;
_.guaranteeValid = function guaranteeValid(){
  return false;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_ARDCutIndexHeuristic_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'ARDCutIndexHeuristic', 743);
function $applyCuts(graph, cuts){
  var alreadySplit, bpEndMarker, bpLayer1, bpLayer2, bpStartMarker, bpi, bpiPrev, cut, cutIt, e, e$iterator, e$iterator0, idx, inPortBp1, inPortBp2, layer, layerIt, n, n$iterator, noSplitEdges, nodeStartEdge, openEdges, originalEdge, originalEdge$iterator, outPortBp1, outPortBp2, prevNode, startEndEdge;
  layerIt = new AbstractList$ListIteratorImpl(graph.layers, 0);
  cutIt = cuts.iterator_0();
  idx = 0;
  cut = castTo(cutIt.next_1(), 21).value_0;
  noSplitEdges = 0;
  alreadySplit = new HashSet;
  openEdges = new LinkedHashSet;
  while (layerIt.i < layerIt.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIt.i < layerIt.this$01_0.size_1()) , castTo(layerIt.this$01_0.get_3(layerIt.last = layerIt.i++), 25));
    for (n$iterator = new ArrayList$1(layer.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      for (e$iterator0 = $iterator($getOutgoingEdges(n)); $hasNext_0(e$iterator0);) {
        e = castTo($next_2(e$iterator0), 16);
        openEdges.map_0.put(e, openEdges);
      }
      for (e$iterator = $iterator($getIncomingEdges(n)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 16);
        openEdges.map_0.remove(e) != null;
      }
    }
    if (idx + 1 == cut) {
      bpLayer1 = new Layer(graph);
      $add_2(layerIt, bpLayer1);
      bpLayer2 = new Layer(graph);
      $add_2(layerIt, bpLayer2);
      for (originalEdge$iterator = openEdges.map_0.keySet_0().iterator_0(); originalEdge$iterator.hasNext_0();) {
        originalEdge = castTo(originalEdge$iterator.next_1(), 16);
        if (!alreadySplit.map_0.containsKey(originalEdge)) {
          ++noSplitEdges;
          alreadySplit.map_0.put(originalEdge, alreadySplit);
        }
        bpStartMarker = new LNode(graph);
        $setProperty_0(bpStartMarker, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_SIDE));
        $setLayer_0(bpStartMarker, bpLayer1);
        $setType(bpStartMarker, ($clinit_LNode$NodeType() , BREAKING_POINT));
        inPortBp1 = new LPort;
        $setNode(inPortBp1, bpStartMarker);
        $setSide(inPortBp1, ($clinit_PortSide() , WEST_1));
        outPortBp1 = new LPort;
        $setNode(outPortBp1, bpStartMarker);
        $setSide(outPortBp1, EAST_1);
        bpEndMarker = new LNode(graph);
        $setProperty_0(bpEndMarker, PORT_CONSTRAINTS_0, FIXED_SIDE);
        $setLayer_0(bpEndMarker, bpLayer2);
        $setType(bpEndMarker, BREAKING_POINT);
        inPortBp2 = new LPort;
        $setNode(inPortBp2, bpEndMarker);
        $setSide(inPortBp2, WEST_1);
        outPortBp2 = new LPort;
        $setNode(outPortBp2, bpEndMarker);
        $setSide(outPortBp2, EAST_1);
        nodeStartEdge = new LEdge;
        $setSource_0(nodeStartEdge, originalEdge.source);
        $setTarget_0(nodeStartEdge, inPortBp1);
        startEndEdge = new LEdge;
        $setSource_0(startEndEdge, outPortBp1);
        $setTarget_0(startEndEdge, inPortBp2);
        $setSource_0(originalEdge, outPortBp2);
        bpi = new BreakingPointInserter$BPInfo(bpStartMarker, bpEndMarker, nodeStartEdge, startEndEdge, originalEdge);
        $setProperty_0(bpStartMarker, ($clinit_InternalProperties_1() , BREAKING_POINT_INFO), bpi);
        $setProperty_0(bpEndMarker, BREAKING_POINT_INFO, bpi);
        prevNode = nodeStartEdge.source.owner;
        if (prevNode.type_0 == BREAKING_POINT) {
          bpiPrev = castTo($getProperty(prevNode, BREAKING_POINT_INFO), 292);
          bpiPrev.next_0 = bpi;
          bpi.prev = bpiPrev;
        }
      }
      if (cutIt.hasNext_0()) {
        cut = castTo(cutIt.next_1(), 21).value_0;
      }
       else {
        break;
      }
    }
    ++idx;
  }
  return valueOf_4(noSplitEdges);
}

function $computeEdgeSpans(graph){
  var e, e$iterator, i, l, l$iterator, n, n$iterator, n$iterator0, open_0, spans;
  spans = initUnidimensionalArray(I_classLit, $intern_49, 23, graph.layers.array.length + 1, 15, 1);
  open_0 = new HashSet;
  i = 0;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    spans[i++] = open_0.map_0.size_1();
    for (n$iterator0 = new ArrayList$1(l.nodes); n$iterator0.i < n$iterator0.this$01.array.length;) {
      n = castTo($next_10(n$iterator0), 9);
      for (e$iterator = $iterator($getOutgoingEdges(n)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 16);
        open_0.map_0.put(e, open_0);
      }
    }
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      for (e$iterator = $iterator($getIncomingEdges(n)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 16);
        open_0.map_0.remove(e) != null;
      }
    }
  }
  return spans;
}

function $improveCuts(graph, cuts){
  var bestCut, bestScore, ccuts, cut, cutIdx, cutIdx$iterator, dist, hit, i, idx, improvedCuts, lCut, lDist, lastCut, rCut, rDist, score, spans, distancePenalty;
  improvedCuts = new ArrayList;
  ccuts = new ArrayList;
  lastCut = null;
  for (cutIdx$iterator = cuts.iterator_0(); cutIdx$iterator.hasNext_0();) {
    cutIdx = castTo(cutIdx$iterator.next_1(), 21);
    cut = new BreakingPointInserter$Cut(cutIdx.value_0);
    ccuts.array[ccuts.array.length] = cut;
    if (lastCut) {
      cut.prev = lastCut;
      lastCut.suc = cut;
    }
    lastCut = cut;
  }
  spans = $computeEdgeSpans(graph);
  for (i = 0; i < ccuts.array.length; ++i) {
    lCut = null;
    rCut = $selfOrNext((checkCriticalElementIndex(0, ccuts.array.length) , castTo(ccuts.array[0], 612)));
    bestCut = null;
    bestScore = $intern_62;
    for (idx = 1; idx < graph.layers.array.length; ++idx) {
      rDist = rCut?abs_0(rCut.index_0 - idx):abs_0(idx - lCut.index_0) + 1;
      lDist = lCut?abs_0(idx - lCut.index_0):rDist + 1;
      if (lDist < rDist) {
        hit = lCut;
        dist = lDist;
      }
       else {
        hit = rCut;
        dist = rDist;
      }
      score = (distancePenalty = checkNotNull_1(castToDouble($getProperty(graph, ($clinit_LayeredOptions() , WRAPPING_MULTI_EDGE_DISTANCE_PENALTY_0)))) , spans[idx] + $wnd.Math.pow(dist, distancePenalty));
      if (score < bestScore) {
        bestScore = score;
        bestCut = hit;
        hit.newIndex = idx;
      }
      if (!!rCut && idx == rCut.index_0) {
        lCut = rCut;
        rCut = $next_15(rCut);
      }
    }
    if (bestCut) {
      $add_4(improvedCuts, valueOf_4(bestCut.newIndex));
      bestCut.assigned = true;
      $offset(bestCut);
    }
  }
  $clinit_Collections();
  sort_4(improvedCuts.array, improvedCuts.array.length, null);
  return improvedCuts;
}

function $process_53(graph, progressMonitor){
  var cuts, gs, icic;
  $begin(progressMonitor, 'Breaking Point Insertion', 1);
  gs = new GraphStats(graph);
  switch (castTo($getProperty(graph, ($clinit_LayeredOptions() , WRAPPING_CUTTING_STRATEGY_0)), 328).ordinal) {
    case 2:
    case 0:
      icic = new ARDCutIndexHeuristic;
      break;
    default:icic = new MSDCutIndexHeuristic;
  }
  cuts = icic.getCutIndexes(graph, gs);
  checkNotNull_1(castToBoolean($getProperty(graph, WRAPPING_MULTI_EDGE_IMPROVE_CUTS_0))) && (cuts = $improveCuts(graph, cuts));
  if (!icic.guaranteeValid() && $hasProperty(graph, WRAPPING_VALIDIFY_STRATEGY_0)) {
    switch (castTo($getProperty(graph, WRAPPING_VALIDIFY_STRATEGY_0), 329).ordinal) {
      case 2:
        cuts = validifyIndexesLookingBack_0(gs, cuts);
        break;
      case 1:
        cuts = validifyIndexesGreedily(gs, cuts);
    }
  }
  if (cuts.isEmpty()) {
    $done_0(progressMonitor);
    return;
  }
  $applyCuts(graph, cuts);
  $done_0(progressMonitor);
}

function BreakingPointInserter(){
}

defineClass(1365, 1, $intern_108, BreakingPointInserter);
_.process = function process_48(graph, progressMonitor){
  $process_53(castTo(graph, 32), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_BreakingPointInserter_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'BreakingPointInserter', 1365);
function BreakingPointInserter$BPInfo(startDummy, endDummy, nodeStartEdge, startEndEdge, originalEdge){
  this.start_0 = startDummy;
  this.end = endDummy;
  this.nodeStartEdge = nodeStartEdge;
  this.startEndEdge = startEndEdge;
  this.originalEdge = originalEdge;
}

function isEnd(n){
  var bpi;
  bpi = castTo($getProperty(n, ($clinit_InternalProperties_1() , BREAKING_POINT_INFO)), 292);
  if (bpi) {
    return bpi.end == n;
  }
  return false;
}

function isStart(n){
  var bpi;
  bpi = castTo($getProperty(n, ($clinit_InternalProperties_1() , BREAKING_POINT_INFO)), 292);
  if (bpi) {
    return bpi.start_0 == n;
  }
  return false;
}

defineClass(292, 1, {292:1}, BreakingPointInserter$BPInfo);
_.toString_0 = function toString_96(){
  var sb;
  sb = new StringBuilder;
  sb.string += 'BPInfo[';
  sb.string += '\n\tstart=';
  $append_10(sb, this.start_0);
  sb.string += '\n\tend=';
  $append_10(sb, this.end);
  sb.string += '\n\tnodeStartEdge=';
  $append_10(sb, this.nodeStartEdge);
  sb.string += '\n\tstartEndEdge=';
  $append_10(sb, this.startEndEdge);
  sb.string += '\n\toriginalEdge=';
  $append_10(sb, this.originalEdge);
  sb.string += '\n\tstartInLayerDummy=';
  $append_10(sb, this.startInLayerDummy);
  sb.string += '\n\tstartInLayerEdge=';
  $append_10(sb, this.startInLayerEdge);
  sb.string += '\n\tendInLayerDummy=';
  $append_10(sb, this.endInLayerDummy);
  sb.string += '\n\tendInLayerEdge=';
  $append_10(sb, this.endInLayerEdge);
  return sb.string;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_BreakingPointInserter$BPInfo_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'BreakingPointInserter/BPInfo', 292);
function $next_15(this$static){
  if (this$static.suc) {
    return $selfOrNext(this$static.suc);
  }
  return null;
}

function $offset(this$static){
  var offset;
  if (!this$static.assigned) {
    throw toJs(new IllegalStateException_0('Cannot offset an unassigned cut.'));
  }
  offset = this$static.newIndex - this$static.index_0;
  this$static.index_0 += offset;
  $offsetPrev(this$static, offset);
  $offsetSuc(this$static, offset);
}

function $offset_0(this$static, offset){
  this$static.index_0 += offset;
}

function $offsetPrev(this$static, offset){
  if (!!this$static.prev && !this$static.prev.assigned) {
    $offset_0(this$static.prev, offset);
    $offsetPrev(this$static.prev, offset);
  }
}

function $offsetSuc(this$static, offset){
  if (!!this$static.suc && !this$static.suc.assigned) {
    $offset_0(this$static.suc, offset);
    $offsetSuc(this$static.suc, offset);
  }
}

function $selfOrNext(this$static){
  if (this$static.assigned) {
    if (this$static.suc) {
      return $selfOrNext(this$static.suc);
    }
  }
   else {
    return this$static;
  }
  return null;
}

function BreakingPointInserter$Cut(index_0){
  this.index_0 = index_0;
}

defineClass(612, 1, {612:1}, BreakingPointInserter$Cut);
_.assigned = false;
_.index_0 = 0;
_.newIndex = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_BreakingPointInserter$Cut_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'BreakingPointInserter/Cut', 612);
function $dropDummies(bpNode, inLayerDummy, forwards, force){
  var didsome, newLayer, nextOne, nextTwo, predOne, predTwo;
  predOne = $nextLongEdgeDummy(bpNode, forwards);
  predTwo = $nextLongEdgeDummy(inLayerDummy, forwards);
  didsome = false;
  while (!!predOne && !!predTwo) {
    if (force || $isAdjacentOrSeparatedByBreakingpoints(predOne, predTwo, forwards)) {
      nextOne = $nextLongEdgeDummy(predOne, forwards);
      nextTwo = $nextLongEdgeDummy(predTwo, forwards);
      $updateIndexesAfter(inLayerDummy);
      $updateIndexesAfter(bpNode);
      newLayer = predOne.layer;
      joinAt(predOne, false);
      joinAt(predTwo, false);
      if (forwards) {
        $setLayer(inLayerDummy, predTwo.id_0, newLayer);
        inLayerDummy.id_0 = predTwo.id_0;
        $setLayer(bpNode, predOne.id_0 + 1, newLayer);
        bpNode.id_0 = predOne.id_0;
      }
       else {
        $setLayer(bpNode, predOne.id_0, newLayer);
        bpNode.id_0 = predOne.id_0;
        $setLayer(inLayerDummy, predTwo.id_0 + 1, newLayer);
        inLayerDummy.id_0 = predTwo.id_0;
      }
      $setLayer_0(predOne, null);
      $setLayer_0(predTwo, null);
      predOne = nextOne;
      predTwo = nextTwo;
      didsome = true;
    }
     else {
      break;
    }
  }
  return didsome;
}

function $improveMultiCutIndexEdges(graph){
  var current, info, l, l$iterator, n, n$iterator, newInfo, next;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    for (n$iterator = new ArrayList$1(newArrayList(l.nodes)); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      if (isStart(n)) {
        info = castTo($getProperty(n, ($clinit_InternalProperties_1() , BREAKING_POINT_INFO)), 292);
        if (!info.prev && !!info.next_0) {
          current = info;
          next = info.next_0;
          while (next) {
            $dropDummies(next.start_0, next.startInLayerDummy, false, true);
            $updateIndexesAfter(current.end);
            $updateIndexesAfter(next.start_0);
            $updateIndexesAfter(next.startInLayerDummy);
            $updateIndexesAfter(next.endInLayerDummy);
            $setTarget_0(next.endInLayerEdge, current.endInLayerEdge.target);
            $setTarget_0(current.endInLayerEdge, null);
            $setLayer_0(current.end, null);
            $setLayer_0(next.start_0, null);
            $setLayer_0(next.startInLayerDummy, null);
            $setLayer_0(next.endInLayerDummy, null);
            newInfo = new BreakingPointInserter$BPInfo(current.start_0, next.end, current.nodeStartEdge, next.startEndEdge, next.originalEdge);
            newInfo.startInLayerDummy = current.startInLayerDummy;
            newInfo.startInLayerEdge = current.startInLayerEdge;
            newInfo.endInLayerDummy = current.endInLayerDummy;
            newInfo.endInLayerEdge = next.endInLayerEdge;
            newInfo.prev = current.prev;
            newInfo.next_0 = next.next_0;
            $setProperty_0(current.start_0, BREAKING_POINT_INFO, newInfo);
            $setProperty_0(next.end, BREAKING_POINT_INFO, newInfo);
            next = next.next_0;
            current = newInfo;
          }
        }
      }
    }
  }
}

function $improveUnneccesarilyLongEdges(graph, forwards){
  var bpInfo, check, didsome, dummy, layer, layer$iterator, layers, n, n$iterator, nodes;
  check = forwards?new BreakingPointProcessor$0methodref$isEnd$Type:new BreakingPointProcessor$1methodref$isStart$Type;
  do {
    didsome = false;
    layers = forwards?reverse_0(graph.layers):graph.layers;
    for (layer$iterator = layers.iterator_0(); layer$iterator.hasNext_0();) {
      layer = castTo(layer$iterator.next_1(), 25);
      nodes = newArrayList(layer.nodes);
      forwards || new Lists$RandomAccessReverseList(nodes);
      for (n$iterator = new ArrayList$1(nodes); n$iterator.i < n$iterator.this$01.array.length;) {
        n = castTo($next_10(n$iterator), 9);
        if (check.test_0(n)) {
          bpInfo = castTo($getProperty(n, ($clinit_InternalProperties_1() , BREAKING_POINT_INFO)), 292);
          dummy = forwards?bpInfo.endInLayerDummy:bpInfo.startInLayerDummy;
          didsome = $dropDummies(n, dummy, forwards, false);
        }
      }
    }
  }
   while (didsome);
}

function $isAdjacentOrSeparatedByBreakingpoints(dummy1, dummy2, forwards){
  var end, i, layer, node, start_0;
  layer = dummy1.layer;
  start_0 = forwards?dummy2:dummy1;
  end = forwards?dummy1:dummy2;
  for (i = start_0.id_0 + 1; i < end.id_0; ++i) {
    node = castTo($get_7(layer.nodes, i), 9);
    if (!(node.type_0 == ($clinit_LNode$NodeType() , BREAKING_POINT) || $isInLayerDummy(node))) {
      return false;
    }
  }
  return true;
}

function $isInLayerDummy(node){
  var e, e$iterator;
  if (node.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    for (e$iterator = $iterator($getConnectedEdges_0(node)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      if (!$isSelfLoop(e) && node.layer == $getOther_1(e, node).layer) {
        return true;
      }
    }
  }
  return false;
}

function $nextLongEdgeDummy(start_0, forwards){
  var e, e$iterator, edges, other;
  edges = forwards?$getOutgoingEdges(start_0):$getIncomingEdges(start_0);
  for (e$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(edges.val$inputs1, new Iterables$12)))); $hasNext_0(e$iterator);) {
    e = castTo($next_2(e$iterator), 16);
    other = $getOther_1(e, start_0);
    if (other.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && other.layer != start_0.layer) {
      return other;
    }
  }
  return null;
}

function $performWrapping(graph){
  var aNode, bpi, dummyEdges, e, e$iterator, idx, it, l, layer, layerIt, layers, n, n$iterator, n$iterator0, newLayer, nodesToMove, offset, reverse, startInLayerEdge;
  layers = graph.layers;
  layerIt = new AbstractList$ListIteratorImpl(layers, 0);
  $add_2(layerIt, new Layer(graph));
  reverse = false;
  idx = 1;
  while (layerIt.i < layerIt.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIt.i < layerIt.this$01_0.size_1()) , castTo(layerIt.this$01_0.get_3(layerIt.last = layerIt.i++), 25));
    newLayer = (checkCriticalElementIndex(idx, layers.array.length) , castTo(layers.array[idx], 25));
    nodesToMove = newArrayList(layer.nodes);
    offset = nodesToMove.array.length;
    for (n$iterator0 = new ArrayList$1(nodesToMove); n$iterator0.i < n$iterator0.this$01.array.length;) {
      n = castTo($next_10(n$iterator0), 9);
      $setLayer_0(n, newLayer);
    }
    if (reverse) {
      for (n$iterator = $listIterator_0(new Lists$RandomAccessReverseList(nodesToMove), 0); n$iterator.val$forwardIterator2.hasPrevious();) {
        n = castTo($next_6(n$iterator), 9);
        for (e$iterator = new ArrayList$1(newArrayList($getIncomingEdges(n))); e$iterator.i < e$iterator.this$01.array.length;) {
          e = castTo($next_10(e$iterator), 16);
          $reverse_0(e, true);
          $setProperty_0(graph, ($clinit_InternalProperties_1() , CYCLIC), ($clinit_Boolean() , $clinit_Boolean() , true));
          dummyEdges = insertDummies(graph, e, offset);
          bpi = castTo($getProperty(n, BREAKING_POINT_INFO), 292);
          startInLayerEdge = castTo($get_7(dummyEdges, dummyEdges.array.length - 1), 16);
          bpi.startInLayerDummy = startInLayerEdge.source.owner;
          bpi.startInLayerEdge = startInLayerEdge;
          bpi.endInLayerDummy = e.target.owner;
          bpi.endInLayerEdge = e;
        }
      }
      reverse = false;
    }
     else {
      if (nodesToMove.array.length != 0) {
        aNode = (checkCriticalElementIndex(0, nodesToMove.array.length) , castTo(nodesToMove.array[0], 9));
        if (aNode.type_0 == ($clinit_LNode$NodeType() , BREAKING_POINT)) {
          reverse = true;
          idx = -1;
        }
      }
    }
    ++idx;
  }
  it = new AbstractList$ListIteratorImpl(graph.layers, 0);
  while (it.i < it.this$01_0.size_1()) {
    l = (checkCriticalElement(it.i < it.this$01_0.size_1()) , castTo(it.this$01_0.get_3(it.last = it.i++), 25));
    l.nodes.array.length == 0 && $remove_9(it);
  }
}

function $process_54(graph, progressMonitor){
  var index_0, l, l$iterator, n, n$iterator;
  $begin(progressMonitor, 'Breaking Point Processor', 1);
  $performWrapping(graph);
  if (checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_LayeredOptions() , WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES_0))))) {
    for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_10(l$iterator), 25);
      index_0 = 0;
      for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
        n = castTo($next_10(n$iterator), 9);
        n.id_0 = index_0++;
      }
    }
    $improveMultiCutIndexEdges(graph);
    $improveUnneccesarilyLongEdges(graph, true);
    $improveUnneccesarilyLongEdges(graph, false);
  }
  $done_0(progressMonitor);
}

function $updateIndexesAfter(node){
  var i;
  for (i = node.id_0 + 1; i < node.layer.nodes.array.length; ++i) {
    --castTo($get_7(node.layer.nodes, i), 9).id_0;
  }
}

function BreakingPointProcessor(){
}

defineClass(1366, 1, $intern_108, BreakingPointProcessor);
_.process = function process_49(graph, progressMonitor){
  $process_54(castTo(graph, 32), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_BreakingPointProcessor_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'BreakingPointProcessor', 1366);
function BreakingPointProcessor$0methodref$isEnd$Type(){
}

defineClass(1367, 1, $intern_90, BreakingPointProcessor$0methodref$isEnd$Type);
_.test_0 = function test_57(arg0){
  return isEnd(castTo(arg0, 9));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_BreakingPointProcessor$0methodref$isEnd$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'BreakingPointProcessor/0methodref$isEnd$Type', 1367);
function BreakingPointProcessor$1methodref$isStart$Type(){
}

defineClass(1368, 1, $intern_90, BreakingPointProcessor$1methodref$isStart$Type);
_.test_0 = function test_58(arg0){
  return isStart(castTo(arg0, 9));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_BreakingPointProcessor$1methodref$isStart$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'BreakingPointProcessor/1methodref$isStart$Type', 1368);
function $addNullSafe(container, toAdd){
  if (!toAdd) {
    return false;
  }
  return $addAll(container, toAdd);
}

function $process_55(this$static, graph, progressMonitor){
  var bpi, l, l$iterator, node, node$iterator;
  $begin(progressMonitor, 'Breaking Point Removing', 1);
  this$static.edgeRouting = castTo($getProperty(graph, ($clinit_LayeredOptions() , EDGE_ROUTING)), 204);
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    for (node$iterator = new ArrayList$1(newArrayList(l.nodes)); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (isEnd(node)) {
        bpi = castTo($getProperty(node, ($clinit_InternalProperties_1() , BREAKING_POINT_INFO)), 292);
        !bpi.next_0 && $remove_30(this$static, bpi);
      }
    }
  }
  $done_0(progressMonitor);
}

function $remove_30(this$static, bpi){
  var e1, e2, e3, joinedEdges, joinedSegments, junctionPointsOne, junctionPointsThree, junctionPointsTwo, newBends, newJunctionPoints, s1, s2, s3;
  newBends = new KVectorChain;
  switch (this$static.edgeRouting.ordinal) {
    case 3:
      s1 = castTo($getProperty(bpi.nodeStartEdge, ($clinit_InternalProperties_1() , SPLINE_ROUTE_START)), 15);
      s2 = castTo($getProperty(bpi.startEndEdge, SPLINE_ROUTE_START), 15);
      s3 = castTo($getProperty(bpi.originalEdge, SPLINE_ROUTE_START), 15);
      e1 = castTo($getProperty(bpi.nodeStartEdge, SPLINE_EDGE_CHAIN), 15);
      e2 = castTo($getProperty(bpi.startEndEdge, SPLINE_EDGE_CHAIN), 15);
      e3 = castTo($getProperty(bpi.originalEdge, SPLINE_EDGE_CHAIN), 15);
      joinedSegments = new ArrayList;
      $addAll_2(joinedSegments, s1);
      s2.forEach_0(new BreakingPointRemover$lambda$0$Type);
      $addAll_2(joinedSegments, instanceOf(s2, 166)?$reverse(castTo(s2, 166)):instanceOf(s2, 138)?castTo(s2, 138).forwardList:instanceOf(s2, 50)?new Lists$RandomAccessReverseList(s2):new Lists$ReverseList(s2));
      $addAll_2(joinedSegments, s3);
      joinedEdges = new ArrayList;
      $addAll_2(joinedEdges, e1);
      $addAll_2(joinedEdges, instanceOf(e2, 166)?$reverse(castTo(e2, 166)):instanceOf(e2, 138)?castTo(e2, 138).forwardList:instanceOf(e2, 50)?new Lists$RandomAccessReverseList(e2):new Lists$ReverseList(e2));
      $addAll_2(joinedEdges, e3);
      $setProperty_0(bpi.originalEdge, SPLINE_ROUTE_START, joinedSegments);
      $setProperty_0(bpi.originalEdge, SPLINE_EDGE_CHAIN, joinedEdges);
      $setProperty_0(bpi.originalEdge, SPLINE_SURVIVING_EDGE, bpi.originalEdge);
      $setProperty_0(bpi.nodeStartEdge, SPLINE_ROUTE_START, null);
      $setProperty_0(bpi.nodeStartEdge, SPLINE_EDGE_CHAIN, null);
      $setProperty_0(bpi.startEndEdge, SPLINE_ROUTE_START, null);
      $setProperty_0(bpi.startEndEdge, SPLINE_EDGE_CHAIN, null);
      break;
    case 1:
      $addAll(newBends, bpi.nodeStartEdge.bendPoints);
      $add_7(newBends, bpi.start_0.pos);
      $addAll(newBends, reverse_0(bpi.startEndEdge.bendPoints));
      $add_7(newBends, bpi.end.pos);
      $addAll(newBends, bpi.originalEdge.bendPoints);
      break;
    default:$addAll(newBends, bpi.nodeStartEdge.bendPoints);
      $addAll(newBends, reverse_0(bpi.startEndEdge.bendPoints));
      $addAll(newBends, bpi.originalEdge.bendPoints);
  }
  $reset_0(bpi.originalEdge.bendPoints);
  $addAll(bpi.originalEdge.bendPoints, newBends);
  $setSource_0(bpi.originalEdge, bpi.nodeStartEdge.source);
  junctionPointsOne = castTo($getProperty(bpi.nodeStartEdge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
  junctionPointsTwo = castTo($getProperty(bpi.startEndEdge, JUNCTION_POINTS), 74);
  junctionPointsThree = castTo($getProperty(bpi.originalEdge, JUNCTION_POINTS), 74);
  if (!!junctionPointsOne || !!junctionPointsTwo || !!junctionPointsThree) {
    newJunctionPoints = new KVectorChain;
    $addNullSafe(newJunctionPoints, junctionPointsThree);
    $addNullSafe(newJunctionPoints, junctionPointsTwo);
    $addNullSafe(newJunctionPoints, junctionPointsOne);
    $setProperty_0(bpi.originalEdge, JUNCTION_POINTS, newJunctionPoints);
  }
  $setSource_0(bpi.startEndEdge, null);
  $setTarget_0(bpi.startEndEdge, null);
  $setSource_0(bpi.nodeStartEdge, null);
  $setTarget_0(bpi.nodeStartEdge, null);
  $setLayer_0(bpi.end, null);
  $setLayer_0(bpi.start_0, null);
  !!bpi.prev && $remove_30(this$static, bpi.prev);
}

function BreakingPointRemover(){
}

defineClass(1369, 1, $intern_108, BreakingPointRemover);
_.process = function process_50(graph, progressMonitor){
  $process_55(this, castTo(graph, 32), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_BreakingPointRemover_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'BreakingPointRemover', 1369);
function BreakingPointRemover$lambda$0$Type(){
}

defineClass(1370, 1, {}, BreakingPointRemover$lambda$0$Type);
_.accept = function accept_83(arg0){
  castTo(arg0, 121).inverseOrder = true;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_BreakingPointRemover$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'BreakingPointRemover/lambda$0$Type', 1370);
function insertDummies(layeredGraph, originalEdge, offsetFirstInLayerDummy){
  var additionalSpacing, createdEdges, dummyEdge, dummyInput, dummyNode, dummyOutput, edge, edgeNodeSpacing, i, is, nextLayer, portPos, src_0, srcIndex, targetPort, tgt, tgtIndex, thickness;
  edgeNodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_EDGE_NODE))));
  additionalSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, WRAPPING_ADDITIONAL_EDGE_SPACING_0)));
  is = new IndividualSpacings;
  $setProperty_0(is, SPACING_EDGE_NODE, edgeNodeSpacing + additionalSpacing);
  edge = originalEdge;
  targetPort = originalEdge.target;
  src_0 = originalEdge.source.owner;
  tgt = originalEdge.target.owner;
  srcIndex = $getIndex_0(src_0.layer);
  tgtIndex = $getIndex_0(tgt.layer);
  createdEdges = new ArrayList;
  for (i = srcIndex; i <= tgtIndex; i++) {
    dummyNode = new LNode(layeredGraph);
    $setType(dummyNode, ($clinit_LNode$NodeType() , LONG_EDGE));
    $setProperty_0(dummyNode, ($clinit_InternalProperties_1() , ORIGIN_0), edge);
    $setProperty_0(dummyNode, PORT_CONSTRAINTS_0, ($clinit_PortConstraints() , FIXED_POS));
    $setProperty_0(dummyNode, SPACING_INDIVIDUAL_OVERRIDE, is);
    nextLayer = castTo($get_7(layeredGraph.layers, i), 25);
    i == srcIndex?$setLayer(dummyNode, nextLayer.nodes.array.length - offsetFirstInLayerDummy, nextLayer):$setLayer_0(dummyNode, nextLayer);
    thickness = checkNotNull_1(castToDouble($getProperty(edge, EDGE_THICKNESS_0)));
    if (thickness < 0) {
      thickness = 0;
      $setProperty_0(edge, EDGE_THICKNESS_0, thickness);
    }
    dummyNode.size_0.y_0 = thickness;
    portPos = $wnd.Math.floor(thickness / 2);
    dummyInput = new LPort;
    $setSide(dummyInput, ($clinit_PortSide() , WEST_1));
    $setNode(dummyInput, dummyNode);
    dummyInput.pos.y_0 = portPos;
    dummyOutput = new LPort;
    $setSide(dummyOutput, EAST_1);
    $setNode(dummyOutput, dummyNode);
    dummyOutput.pos.y_0 = portPos;
    $setTarget_0(edge, dummyInput);
    dummyEdge = new LEdge;
    $copyProperties(dummyEdge, edge);
    $setProperty_0(dummyEdge, JUNCTION_POINTS, null);
    $setSource_0(dummyEdge, dummyOutput);
    $setTarget_0(dummyEdge, targetPort);
    setDummyProperties(dummyNode, edge, dummyEdge);
    createdEdges.array[createdEdges.array.length] = dummyEdge;
    edge = dummyEdge;
  }
  return createdEdges;
}

function setDummyProperties(dummy, inEdge, outEdge){
  var inEdgeSourceNode;
  inEdgeSourceNode = inEdge.source.owner;
  if (inEdgeSourceNode.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    $setProperty_0(dummy, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), castTo($getProperty(inEdgeSourceNode, LONG_EDGE_SOURCE), 11));
    $setProperty_0(dummy, LONG_EDGE_TARGET, castTo($getProperty(inEdgeSourceNode, LONG_EDGE_TARGET), 11));
  }
   else {
    $setProperty_0(dummy, ($clinit_InternalProperties_1() , LONG_EDGE_SOURCE), inEdge.source);
    $setProperty_0(dummy, LONG_EDGE_TARGET, outEdge.target);
  }
}

function $determineHeight(this$static, fun){
  return checkNotNull_1(castToDouble($get_13($reduce_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.graph_0.layers, 16)), new GraphStats$lambda$3$Type(this$static)), fun))));
}

function $determineLayerHeight(this$static, layer){
  var inc, inc$iterator, lH, n, n$iterator, origin, src_0;
  lH = 0;
  for (n$iterator = new ArrayList$1(layer.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 9);
    lH += n.size_0.y_0 + n.margin.bottom + n.margin.top_0 + this$static.inLayerSpacing;
    for (inc$iterator = $iterator($getIncomingEdges(n)); $hasNext_0(inc$iterator);) {
      inc = castTo($next_2(inc$iterator), 16);
      if (inc.source.owner.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
        src_0 = inc.source.owner;
        origin = castTo($getProperty(src_0, ($clinit_InternalProperties_1() , ORIGIN_0)), 9);
        lH += origin.size_0.y_0 + origin.margin.bottom + origin.margin.top_0;
      }
    }
  }
  return lH;
}

function $determineLayerWidth(this$static, l){
  var maxW, n, n$iterator, nW;
  maxW = 0;
  for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 9);
    nW = n.size_0.x_0 + n.margin.right + n.margin.left + this$static.spacing;
    maxW = $wnd.Math.max(maxW, nW);
  }
  return maxW;
}

function $determineWidth(this$static, fun){
  return checkNotNull_1(castToDouble($get_13($reduce_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.graph_0.layers, 16)), new GraphStats$lambda$1$Type(this$static)), fun))));
}

function $initCutAllowed(this$static){
  var f, f$iterator, forbidden, i, layer, layerIt;
  if (this$static.cutsAllowed != null) {
    return;
  }
  this$static.cutsAllowed = initUnidimensionalArray(Z_classLit, $intern_93, 23, this$static.graph_0.layers.array.length, 16, 1);
  this$static.cutsAllowed[0] = false;
  if ($hasProperty(this$static.graph_0, ($clinit_LayeredOptions() , WRAPPING_VALIDIFY_FORBIDDEN_INDICES_0))) {
    forbidden = castTo($getProperty(this$static.graph_0, WRAPPING_VALIDIFY_FORBIDDEN_INDICES_0), 15);
    for (f$iterator = forbidden.iterator_0(); f$iterator.hasNext_0();) {
      f = castTo(f$iterator.next_1(), 21).value_0;
      f > 0 && f < this$static.cutsAllowed.length && (this$static.cutsAllowed[f] = false);
    }
  }
   else {
    layerIt = new ArrayList$1(this$static.graph_0.layers);
    layerIt.i < layerIt.this$01.array.length && $next_10(layerIt);
    i = 1;
    while (layerIt.i < layerIt.this$01.array.length) {
      layer = castTo($next_10(layerIt), 25);
      this$static.cutsAllowed[i++] = $isCutAllowed_0(layer);
    }
  }
}

function $initWidthsAndHeights(this$static){
  var i, l, n;
  n = this$static.longestPath;
  this$static.widths = initUnidimensionalArray(D_classLit, $intern_69, 23, n, 15, 1);
  this$static.heights = initUnidimensionalArray(D_classLit, $intern_69, 23, n, 15, 1);
  for (i = 0; i < n; i++) {
    l = castTo($get_7(this$static.graph_0.layers, i), 25);
    this$static.widths[i] = $determineLayerWidth(this$static, l);
    this$static.heights[i] = $determineLayerHeight(this$static, l);
  }
}

function $isCutAllowed(this$static, layerIndex){
  this$static.cutsAllowed == null && $initCutAllowed(this$static);
  return this$static.cutsAllowed[layerIndex];
}

function $isCutAllowed_0(layer){
  var cutAllowed, e, e$iterator, n1, n2, src_0, tgt, tgt$iterator;
  cutAllowed = true;
  n1 = null;
  n2 = null;
  check: for (tgt$iterator = new ArrayList$1(layer.nodes); tgt$iterator.i < tgt$iterator.this$01.array.length;) {
    tgt = castTo($next_10(tgt$iterator), 9);
    for (e$iterator = $iterator($getIncomingEdges(tgt)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      if (!!n1 && n1 != tgt) {
        cutAllowed = false;
        break check;
      }
      n1 = tgt;
      src_0 = e.source.owner;
      if (!!n2 && n2 != src_0) {
        cutAllowed = false;
        break check;
      }
      n2 = src_0;
    }
  }
  return cutAllowed;
}

function GraphStats(graph){
  var aspectRatio, correction, dir_0;
  this.graph_0 = graph;
  dir_0 = castTo($getProperty(graph, ($clinit_LayeredOptions() , DIRECTION)), 107);
  aspectRatio = checkNotNull_1(castToDouble($getProperty(graph, ASPECT_RATIO_1)));
  correction = checkNotNull_1(castToDouble($getProperty(graph, WRAPPING_CORRECTION_FACTOR_0)));
  dir_0 == ($clinit_Direction_0() , LEFT_5) || dir_0 == RIGHT_5 || dir_0 == UNDEFINED_3?(this.dar = aspectRatio * correction):(this.dar = 1 / (aspectRatio * correction));
  this.spacing = checkNotNull_1(castToDouble($getProperty(graph, SPACING_NODE_NODE_BETWEEN_LAYERS_0)));
  this.inLayerSpacing = checkNotNull_1(castToDouble($getProperty(graph, SPACING_NODE_NODE_0)));
  this.longestPath = graph.layers.array.length;
}

defineClass(740, 1, {}, GraphStats);
_.dar = 0;
_.inLayerSpacing = 0;
_.longestPath = 0;
_.spacing = 0;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_GraphStats_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'GraphStats', 740);
function GraphStats$0methodref$max$Type(){
}

defineClass(741, 1, {}, GraphStats$0methodref$max$Type);
_.apply_2 = function apply_111(arg0, arg1){
  return $wnd.Math.max(checkNotNull_1(castToDouble(arg0)), checkNotNull_1(castToDouble(arg1)));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_GraphStats$0methodref$max$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'GraphStats/0methodref$max$Type', 741);
function GraphStats$2methodref$max$Type(){
}

defineClass(742, 1, {}, GraphStats$2methodref$max$Type);
_.apply_2 = function apply_112(arg0, arg1){
  return $wnd.Math.max(checkNotNull_1(castToDouble(arg0)), checkNotNull_1(castToDouble(arg1)));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_GraphStats$2methodref$max$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'GraphStats/2methodref$max$Type', 742);
function GraphStats$lambda$0$Type(){
}

defineClass(1510, 1, {}, GraphStats$lambda$0$Type);
_.apply_2 = function apply_113(arg0, arg1){
  return checkNotNull_1(castToDouble(arg0)) + checkNotNull_1(castToDouble(arg1));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_GraphStats$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'GraphStats/lambda$0$Type', 1510);
function GraphStats$lambda$1$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1511, 1, $intern_11, GraphStats$lambda$1$Type);
_.apply_0 = function apply_114(arg0){
  return $determineLayerWidth(this.$$outer_0, castTo(arg0, 25));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_GraphStats$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'GraphStats/lambda$1$Type', 1511);
function GraphStats$lambda$3$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1512, 1, $intern_11, GraphStats$lambda$3$Type);
_.apply_0 = function apply_115(arg0){
  return $determineLayerHeight(this.$$outer_0, castTo(arg0, 25));
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_GraphStats$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'GraphStats/lambda$3$Type', 1512);
function ICutIndexCalculator$ManualCutIndexCalculator(){
}

defineClass(1513, 1, {}, ICutIndexCalculator$ManualCutIndexCalculator);
_.getCutIndexes = function getCutIndexes_0(graph, gs){
  var cuts;
  cuts = castTo($getProperty(graph, ($clinit_LayeredOptions() , WRAPPING_CUTTING_CUTS_0)), 15);
  return cuts?cuts:($clinit_Collections() , $clinit_Collections() , EMPTY_LIST);
}
;
_.guaranteeValid = function guaranteeValid_0(){
  return false;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_ICutIndexCalculator$ManualCutIndexCalculator_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'ICutIndexCalculator/ManualCutIndexCalculator', 1513);
function MSDCutIndexHeuristic(){
}

defineClass(744, 1, {}, MSDCutIndexHeuristic);
_.getCutIndexes = function getCutIndexes_1(graph, gs){
  var bestCuts, bestMaxScale, cutCnt, cuts, freedom, height, heights, i, index_0, lastCutWidth, m, maxScale, rowHeightMax, rowSum, sumSoFar, total, width_0, widthAtIndex, widths;
  widths = (gs.widths == null && $initWidthsAndHeights(gs) , gs.widths);
  heights = (gs.heights == null && $initWidthsAndHeights(gs) , gs.heights);
  widthAtIndex = initUnidimensionalArray(D_classLit, $intern_69, 23, widths.length, 15, 1);
  widthAtIndex[0] = widths[0];
  total = widths[0];
  for (i = 1; i < widths.length; i++) {
    widthAtIndex[i] = widthAtIndex[i - 1] + widths[i];
    total += widths[i];
  }
  cutCnt = getChunkCount(gs) - 1;
  freedom = castTo($getProperty(graph, ($clinit_LayeredOptions() , WRAPPING_CUTTING_MSD_FREEDOM_0)), 21).value_0;
  bestMaxScale = $intern_63;
  bestCuts = new ArrayList;
  for (m = 0 > cutCnt - freedom?0:cutCnt - freedom; m <= min_1(gs.longestPath - 1, cutCnt + freedom); m++) {
    rowSum = total / (m + 1);
    sumSoFar = 0;
    index_0 = 1;
    cuts = new ArrayList;
    width_0 = $intern_63;
    lastCutWidth = 0;
    height = 0;
    rowHeightMax = heights[0];
    if (m == 0) {
      width_0 = total;
      height = (gs.maxHeight == null && (gs.maxHeight = $determineHeight(gs, new GraphStats$2methodref$max$Type)) , checkNotNull_1(gs.maxHeight));
    }
     else {
      while (index_0 < gs.longestPath) {
        if (widthAtIndex[index_0 - 1] - sumSoFar >= rowSum) {
          $add_4(cuts, valueOf_4(index_0));
          width_0 = $wnd.Math.max(width_0, widthAtIndex[index_0 - 1] - lastCutWidth);
          height += rowHeightMax;
          sumSoFar += widthAtIndex[index_0 - 1] - sumSoFar;
          lastCutWidth = widthAtIndex[index_0 - 1];
          rowHeightMax = heights[index_0];
        }
        rowHeightMax = $wnd.Math.max(rowHeightMax, heights[index_0]);
        ++index_0;
      }
      height += rowHeightMax;
    }
    maxScale = $wnd.Math.min(1 / width_0, 1 / gs.dar / height);
    if (maxScale > bestMaxScale) {
      bestMaxScale = maxScale;
      bestCuts = cuts;
    }
  }
  return bestCuts;
}
;
_.guaranteeValid = function guaranteeValid_1(){
  return false;
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_MSDCutIndexHeuristic_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'MSDCutIndexHeuristic', 744);
function $performCuts(graph, gs, cuts){
  var cutIt, e, e$iterator, incEdges, index_0, it, l, n, n$iterator, newIndex, newLayer, nextCut, nodesToMove, oldLayer;
  if (cuts.isEmpty()) {
    return;
  }
  index_0 = 0;
  newIndex = 0;
  cutIt = cuts.iterator_0();
  nextCut = castTo(cutIt.next_1(), 21).value_0;
  while (index_0 < gs.longestPath) {
    if (index_0 == nextCut) {
      newIndex = 0;
      cutIt.hasNext_0()?(nextCut = castTo(cutIt.next_1(), 21).value_0):(nextCut = gs.longestPath + 1);
    }
    if (index_0 != newIndex) {
      oldLayer = castTo($get_7(graph.layers, index_0), 25);
      newLayer = castTo($get_7(graph.layers, newIndex), 25);
      nodesToMove = newArrayList(oldLayer.nodes);
      for (n$iterator = new ArrayList$1(nodesToMove); n$iterator.i < n$iterator.this$01.array.length;) {
        n = castTo($next_10(n$iterator), 9);
        $setLayer(n, newLayer.nodes.array.length, newLayer);
        if (newIndex == 0) {
          incEdges = newArrayList($getIncomingEdges(n));
          for (e$iterator = new ArrayList$1(incEdges); e$iterator.i < e$iterator.this$01.array.length;) {
            e = castTo($next_10(e$iterator), 16);
            $reverse_0(e, true);
            $setProperty_0(graph, ($clinit_InternalProperties_1() , CYCLIC), ($clinit_Boolean() , $clinit_Boolean() , true));
            insertDummies(graph, e, 1);
          }
        }
      }
    }
    ++newIndex;
    ++index_0;
  }
  it = new AbstractList$ListIteratorImpl(graph.layers, 0);
  while (it.i < it.this$01_0.size_1()) {
    l = (checkCriticalElement(it.i < it.this$01_0.size_1()) , castTo(it.this$01_0.get_3(it.last = it.i++), 25));
    l.nodes.array.length == 0 && $remove_9(it);
  }
}

function $process_56(graph, progressMonitor){
  var currentAR, cuts, gs, icic, sumWidth;
  $begin(progressMonitor, 'Path-Like Graph Wrapping', 1);
  if (graph.layers.array.length == 0) {
    $done_0(progressMonitor);
    return;
  }
  gs = new GraphStats(graph);
  sumWidth = (gs.maxWidth == null && (gs.maxWidth = $determineWidth(gs, new GraphStats$0methodref$max$Type)) , checkNotNull_1(gs.maxWidth) * gs.longestPath);
  currentAR = sumWidth / (gs.maxWidth == null && (gs.maxWidth = $determineWidth(gs, new GraphStats$0methodref$max$Type)) , checkNotNull_1(gs.maxWidth));
  if (gs.dar > currentAR) {
    $done_0(progressMonitor);
    return;
  }
  switch (castTo($getProperty(graph, ($clinit_LayeredOptions() , WRAPPING_CUTTING_STRATEGY_0)), 328).ordinal) {
    case 2:
      icic = new ICutIndexCalculator$ManualCutIndexCalculator;
      break;
    case 0:
      icic = new ARDCutIndexHeuristic;
      break;
    default:icic = new MSDCutIndexHeuristic;
  }
  cuts = icic.getCutIndexes(graph, gs);
  if (!icic.guaranteeValid()) {
    switch (castTo($getProperty(graph, WRAPPING_VALIDIFY_STRATEGY_0), 329).ordinal) {
      case 2:
        cuts = validifyIndexesLookingBack_0(gs, cuts);
        break;
      case 1:
        cuts = validifyIndexesGreedily(gs, cuts);
    }
  }
  $performCuts(graph, gs, cuts);
  $done_0(progressMonitor);
}

function SingleEdgeGraphWrapper(){
}

function validifyIndexesGreedily(gs, cuts){
  var cut, cutIt, offset, validCuts;
  validCuts = new ArrayList;
  offset = 0;
  cutIt = cuts.iterator_0();
  while (cutIt.hasNext_0()) {
    cut = valueOf_4(castTo(cutIt.next_1(), 21).value_0 + offset);
    while (cut.value_0 < gs.longestPath && !$isCutAllowed(gs, cut.value_0)) {
      cut = valueOf_4(cut.value_0 + 1);
      ++offset;
    }
    if (cut.value_0 >= gs.longestPath) {
      break;
    }
    validCuts.array[validCuts.array.length] = cut;
  }
  return validCuts;
}

function validifyIndexesLookingBack(desiredCuts, validCuts){
  var cIdx, current, distHigher, distLower, finalCuts, iIdx, offset, select;
  finalCuts = new ArrayList;
  iIdx = 0;
  cIdx = 0;
  offset = 0;
  while (iIdx < validCuts.array.length - 1 && cIdx < desiredCuts.size_1()) {
    current = castTo(desiredCuts.get_3(cIdx), 21).value_0 + offset;
    while ((checkCriticalElementIndex(iIdx + 1, validCuts.array.length) , castTo(validCuts.array[iIdx + 1], 21)).value_0 < current) {
      ++iIdx;
    }
    select = 0;
    distLower = current - (checkCriticalElementIndex(iIdx, validCuts.array.length) , castTo(validCuts.array[iIdx], 21)).value_0;
    distHigher = (checkCriticalElementIndex(iIdx + 1, validCuts.array.length) , castTo(validCuts.array[iIdx + 1], 21)).value_0 - current;
    distLower > distHigher && ++select;
    $add_4(finalCuts, (checkCriticalElementIndex(iIdx + select, validCuts.array.length) , castTo(validCuts.array[iIdx + select], 21)));
    offset += (checkCriticalElementIndex(iIdx + select, validCuts.array.length) , castTo(validCuts.array[iIdx + select], 21)).value_0 - current;
    ++cIdx;
    while (cIdx < desiredCuts.size_1() && castTo(desiredCuts.get_3(cIdx), 21).value_0 + offset <= (checkCriticalElementIndex(iIdx + select, validCuts.array.length) , castTo(validCuts.array[iIdx + select], 21)).value_0) {
      ++cIdx;
    }
    iIdx += 1 + select;
  }
  return finalCuts;
}

function validifyIndexesLookingBack_0(gs, desiredCuts){
  var i, validCuts;
  if (desiredCuts.isEmpty()) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  validCuts = new ArrayList;
  $add_4(validCuts, valueOf_4($intern_43));
  for (i = 1; i < gs.longestPath; ++i) {
    gs.cutsAllowed == null && $initCutAllowed(gs);
    gs.cutsAllowed[i] && $add_4(validCuts, valueOf_4(i));
  }
  if (validCuts.array.length == 1) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  $add_4(validCuts, valueOf_4($intern_0));
  return validifyIndexesLookingBack(desiredCuts, validCuts);
}

defineClass(1454, 1, $intern_108, SingleEdgeGraphWrapper);
_.process = function process_51(graph, progressMonitor){
  $process_56(castTo(graph, 32), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_layered_intermediate_wrapping_SingleEdgeGraphWrapper_2_classLit = createForClass('org.eclipse.elk.alg.layered.intermediate.wrapping', 'SingleEdgeGraphWrapper', 1454);
function $clinit_CenterEdgeLabelPlacementStrategy(){
  $clinit_CenterEdgeLabelPlacementStrategy = emptyMethod;
  MEDIAN_LAYER = new CenterEdgeLabelPlacementStrategy('MEDIAN_LAYER', 0);
  TAIL_LAYER = new CenterEdgeLabelPlacementStrategy('TAIL_LAYER', 1);
  HEAD_LAYER = new CenterEdgeLabelPlacementStrategy('HEAD_LAYER', 2);
  SPACE_EFFICIENT_LAYER = new CenterEdgeLabelPlacementStrategy('SPACE_EFFICIENT_LAYER', 3);
  WIDEST_LAYER = new CenterEdgeLabelPlacementStrategy('WIDEST_LAYER', 4);
  CENTER_LAYER = new CenterEdgeLabelPlacementStrategy('CENTER_LAYER', 5);
}

function CenterEdgeLabelPlacementStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_32(name_0){
  $clinit_CenterEdgeLabelPlacementStrategy();
  return valueOf(($clinit_CenterEdgeLabelPlacementStrategy$Map() , $MAP_20), name_0);
}

function values_28(){
  $clinit_CenterEdgeLabelPlacementStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit, 1), $intern_38, 206, 0, [MEDIAN_LAYER, TAIL_LAYER, HEAD_LAYER, SPACE_EFFICIENT_LAYER, WIDEST_LAYER, CENTER_LAYER]);
}

defineClass(206, 22, {3:1, 34:1, 22:1, 206:1}, CenterEdgeLabelPlacementStrategy);
var CENTER_LAYER, HEAD_LAYER, MEDIAN_LAYER, SPACE_EFFICIENT_LAYER, TAIL_LAYER, WIDEST_LAYER;
var Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'CenterEdgeLabelPlacementStrategy', 206, Ljava_lang_Enum_2_classLit, values_28, valueOf_32);
function $clinit_CenterEdgeLabelPlacementStrategy$Map(){
  $clinit_CenterEdgeLabelPlacementStrategy$Map = emptyMethod;
  $MAP_20 = createValueOfMap(($clinit_CenterEdgeLabelPlacementStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit, 1), $intern_38, 206, 0, [MEDIAN_LAYER, TAIL_LAYER, HEAD_LAYER, SPACE_EFFICIENT_LAYER, WIDEST_LAYER, CENTER_LAYER])));
}

var $MAP_20;
function $clinit_ConstraintCalculationStrategy(){
  $clinit_ConstraintCalculationStrategy = emptyMethod;
  QUADRATIC = new ConstraintCalculationStrategy('QUADRATIC', 0);
  SCANLINE = new ConstraintCalculationStrategy('SCANLINE', 1);
}

function ConstraintCalculationStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_33(name_0){
  $clinit_ConstraintCalculationStrategy();
  return valueOf(($clinit_ConstraintCalculationStrategy$Map() , $MAP_21), name_0);
}

function values_29(){
  $clinit_ConstraintCalculationStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_ConstraintCalculationStrategy_2_classLit, 1), $intern_38, 402, 0, [QUADRATIC, SCANLINE]);
}

defineClass(402, 22, {3:1, 34:1, 22:1, 402:1}, ConstraintCalculationStrategy);
var QUADRATIC, SCANLINE;
var Lorg_eclipse_elk_alg_layered_options_ConstraintCalculationStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'ConstraintCalculationStrategy', 402, Ljava_lang_Enum_2_classLit, values_29, valueOf_33);
function $clinit_ConstraintCalculationStrategy$Map(){
  $clinit_ConstraintCalculationStrategy$Map = emptyMethod;
  $MAP_21 = createValueOfMap(($clinit_ConstraintCalculationStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_ConstraintCalculationStrategy_2_classLit, 1), $intern_38, 402, 0, [QUADRATIC, SCANLINE])));
}

var $MAP_21;
function $clinit_ContentAlignment(){
  $clinit_ContentAlignment = emptyMethod;
  V_TOP = new ContentAlignment('V_TOP', 0);
  V_CENTER = new ContentAlignment('V_CENTER', 1);
  V_BOTTOM = new ContentAlignment('V_BOTTOM', 2);
  H_LEFT = new ContentAlignment('H_LEFT', 3);
  H_CENTER = new ContentAlignment('H_CENTER', 4);
  H_RIGHT = new ContentAlignment('H_RIGHT', 5);
}

function ContentAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_34(name_0){
  $clinit_ContentAlignment();
  return valueOf(($clinit_ContentAlignment$Map() , $MAP_22), name_0);
}

function values_30(){
  $clinit_ContentAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_ContentAlignment_2_classLit, 1), $intern_38, 299, 0, [V_TOP, V_CENTER, V_BOTTOM, H_LEFT, H_CENTER, H_RIGHT]);
}

defineClass(299, 22, {3:1, 34:1, 22:1, 299:1}, ContentAlignment);
var H_CENTER, H_LEFT, H_RIGHT, V_BOTTOM, V_CENTER, V_TOP;
var Lorg_eclipse_elk_alg_layered_options_ContentAlignment_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'ContentAlignment', 299, Ljava_lang_Enum_2_classLit, values_30, valueOf_34);
function $clinit_ContentAlignment$Map(){
  $clinit_ContentAlignment$Map = emptyMethod;
  $MAP_22 = createValueOfMap(($clinit_ContentAlignment() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_ContentAlignment_2_classLit, 1), $intern_38, 299, 0, [V_TOP, V_CENTER, V_BOTTOM, H_LEFT, H_CENTER, H_RIGHT])));
}

var $MAP_22;
function $clinit_CrossingMinimizationStrategy(){
  $clinit_CrossingMinimizationStrategy = emptyMethod;
  LAYER_SWEEP = new CrossingMinimizationStrategy('LAYER_SWEEP', 0);
  INTERACTIVE_1 = new CrossingMinimizationStrategy('INTERACTIVE', 1);
}

function $create_3(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new LayerSweepCrossingMinimizer(($clinit_LayerSweepCrossingMinimizer$CrossMinType() , BARYCENTER));
    case 1:
      return new InteractiveCrossingMinimizer;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the crossing minimizer ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function CrossingMinimizationStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_35(name_0){
  $clinit_CrossingMinimizationStrategy();
  return valueOf(($clinit_CrossingMinimizationStrategy$Map() , $MAP_23), name_0);
}

function values_31(){
  $clinit_CrossingMinimizationStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CrossingMinimizationStrategy_2_classLit, 1), $intern_38, 325, 0, [LAYER_SWEEP, INTERACTIVE_1]);
}

defineClass(325, 22, {3:1, 34:1, 22:1, 325:1, 230:1, 231:1}, CrossingMinimizationStrategy);
_.create_1 = function create_8(){
  return $create_3(this);
}
;
_.create_2 = function create_7(){
  return $create_3(this);
}
;
var INTERACTIVE_1, LAYER_SWEEP;
var Lorg_eclipse_elk_alg_layered_options_CrossingMinimizationStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'CrossingMinimizationStrategy', 325, Ljava_lang_Enum_2_classLit, values_31, valueOf_35);
function $clinit_CrossingMinimizationStrategy$Map(){
  $clinit_CrossingMinimizationStrategy$Map = emptyMethod;
  $MAP_23 = createValueOfMap(($clinit_CrossingMinimizationStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CrossingMinimizationStrategy_2_classLit, 1), $intern_38, 325, 0, [LAYER_SWEEP, INTERACTIVE_1])));
}

var $MAP_23;
function $clinit_CuttingStrategy(){
  $clinit_CuttingStrategy = emptyMethod;
  ARD = new CuttingStrategy('ARD', 0);
  MSD = new CuttingStrategy('MSD', 1);
  MANUAL = new CuttingStrategy('MANUAL', 2);
}

function CuttingStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_36(name_0){
  $clinit_CuttingStrategy();
  return valueOf(($clinit_CuttingStrategy$Map() , $MAP_24), name_0);
}

function values_32(){
  $clinit_CuttingStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CuttingStrategy_2_classLit, 1), $intern_38, 328, 0, [ARD, MSD, MANUAL]);
}

defineClass(328, 22, {3:1, 34:1, 22:1, 328:1}, CuttingStrategy);
var ARD, MANUAL, MSD;
var Lorg_eclipse_elk_alg_layered_options_CuttingStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'CuttingStrategy', 328, Ljava_lang_Enum_2_classLit, values_32, valueOf_36);
function $clinit_CuttingStrategy$Map(){
  $clinit_CuttingStrategy$Map = emptyMethod;
  $MAP_24 = createValueOfMap(($clinit_CuttingStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CuttingStrategy_2_classLit, 1), $intern_38, 328, 0, [ARD, MSD, MANUAL])));
}

var $MAP_24;
function $clinit_CycleBreakingStrategy(){
  $clinit_CycleBreakingStrategy = emptyMethod;
  GREEDY = new CycleBreakingStrategy('GREEDY', 0);
  DEPTH_FIRST = new CycleBreakingStrategy('DEPTH_FIRST', 1);
  INTERACTIVE_2 = new CycleBreakingStrategy('INTERACTIVE', 2);
}

function $create_4(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new GreedyCycleBreaker;
    case 1:
      return new DepthFirstCycleBreaker;
    case 2:
      return new InteractiveCycleBreaker;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the cycle breaker ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function CycleBreakingStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_37(name_0){
  $clinit_CycleBreakingStrategy();
  return valueOf(($clinit_CycleBreakingStrategy$Map() , $MAP_25), name_0);
}

function values_33(){
  $clinit_CycleBreakingStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CycleBreakingStrategy_2_classLit, 1), $intern_38, 400, 0, [GREEDY, DEPTH_FIRST, INTERACTIVE_2]);
}

defineClass(400, 22, {3:1, 34:1, 22:1, 400:1, 230:1, 231:1}, CycleBreakingStrategy);
_.create_1 = function create_10(){
  return $create_4(this);
}
;
_.create_2 = function create_9(){
  return $create_4(this);
}
;
var DEPTH_FIRST, GREEDY, INTERACTIVE_2;
var Lorg_eclipse_elk_alg_layered_options_CycleBreakingStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'CycleBreakingStrategy', 400, Ljava_lang_Enum_2_classLit, values_33, valueOf_37);
function $clinit_CycleBreakingStrategy$Map(){
  $clinit_CycleBreakingStrategy$Map = emptyMethod;
  $MAP_25 = createValueOfMap(($clinit_CycleBreakingStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_CycleBreakingStrategy_2_classLit, 1), $intern_38, 400, 0, [GREEDY, DEPTH_FIRST, INTERACTIVE_2])));
}

var $MAP_25;
function $clinit_DirectionCongruency(){
  $clinit_DirectionCongruency = emptyMethod;
  READING_DIRECTION = new DirectionCongruency('READING_DIRECTION', 0);
  ROTATION = new DirectionCongruency('ROTATION', 1);
}

function DirectionCongruency(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_38(name_0){
  $clinit_DirectionCongruency();
  return valueOf(($clinit_DirectionCongruency$Map() , $MAP_26), name_0);
}

function values_34(){
  $clinit_DirectionCongruency();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_DirectionCongruency_2_classLit, 1), $intern_38, 397, 0, [READING_DIRECTION, ROTATION]);
}

defineClass(397, 22, {3:1, 34:1, 22:1, 397:1}, DirectionCongruency);
var READING_DIRECTION, ROTATION;
var Lorg_eclipse_elk_alg_layered_options_DirectionCongruency_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'DirectionCongruency', 397, Ljava_lang_Enum_2_classLit, values_34, valueOf_38);
function $clinit_DirectionCongruency$Map(){
  $clinit_DirectionCongruency$Map = emptyMethod;
  $MAP_26 = createValueOfMap(($clinit_DirectionCongruency() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_DirectionCongruency_2_classLit, 1), $intern_38, 397, 0, [READING_DIRECTION, ROTATION])));
}

var $MAP_26;
function $clinit_EdgeConstraint(){
  $clinit_EdgeConstraint = emptyMethod;
  NONE = new EdgeConstraint('NONE', 0);
  INCOMING_ONLY = new EdgeConstraint('INCOMING_ONLY', 1);
  OUTGOING_ONLY = new EdgeConstraint('OUTGOING_ONLY', 2);
}

function EdgeConstraint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_39(name_0){
  $clinit_EdgeConstraint();
  return valueOf(($clinit_EdgeConstraint$Map() , $MAP_27), name_0);
}

function values_35(){
  $clinit_EdgeConstraint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_EdgeConstraint_2_classLit, 1), $intern_38, 424, 0, [NONE, INCOMING_ONLY, OUTGOING_ONLY]);
}

defineClass(424, 22, {3:1, 34:1, 22:1, 424:1}, EdgeConstraint);
var INCOMING_ONLY, NONE, OUTGOING_ONLY;
var Lorg_eclipse_elk_alg_layered_options_EdgeConstraint_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'EdgeConstraint', 424, Ljava_lang_Enum_2_classLit, values_35, valueOf_39);
function $clinit_EdgeConstraint$Map(){
  $clinit_EdgeConstraint$Map = emptyMethod;
  $MAP_27 = createValueOfMap(($clinit_EdgeConstraint() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_EdgeConstraint_2_classLit, 1), $intern_38, 424, 0, [NONE, INCOMING_ONLY, OUTGOING_ONLY])));
}

var $MAP_27;
function $clinit_EdgeLabelSideSelection(){
  $clinit_EdgeLabelSideSelection = emptyMethod;
  ALWAYS_UP = new EdgeLabelSideSelection('ALWAYS_UP', 0);
  ALWAYS_DOWN = new EdgeLabelSideSelection('ALWAYS_DOWN', 1);
  DIRECTION_UP = new EdgeLabelSideSelection('DIRECTION_UP', 2);
  DIRECTION_DOWN = new EdgeLabelSideSelection('DIRECTION_DOWN', 3);
  SMART_UP = new EdgeLabelSideSelection('SMART_UP', 4);
  SMART_DOWN = new EdgeLabelSideSelection('SMART_DOWN', 5);
}

function $transpose_2(this$static){
  switch (this$static.ordinal) {
    case 0:
      return ALWAYS_DOWN;
    case 1:
      return ALWAYS_UP;
    case 2:
      return DIRECTION_DOWN;
    case 3:
      return DIRECTION_UP;
    case 4:
      return SMART_DOWN;
    case 5:
      return SMART_UP;
    default:return null;
  }
}

function EdgeLabelSideSelection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_40(name_0){
  $clinit_EdgeLabelSideSelection();
  return valueOf(($clinit_EdgeLabelSideSelection$Map() , $MAP_28), name_0);
}

function values_36(){
  $clinit_EdgeLabelSideSelection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_EdgeLabelSideSelection_2_classLit, 1), $intern_38, 266, 0, [ALWAYS_UP, ALWAYS_DOWN, DIRECTION_UP, DIRECTION_DOWN, SMART_UP, SMART_DOWN]);
}

defineClass(266, 22, {3:1, 34:1, 22:1, 266:1}, EdgeLabelSideSelection);
var ALWAYS_DOWN, ALWAYS_UP, DIRECTION_DOWN, DIRECTION_UP, SMART_DOWN, SMART_UP;
var Lorg_eclipse_elk_alg_layered_options_EdgeLabelSideSelection_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'EdgeLabelSideSelection', 266, Ljava_lang_Enum_2_classLit, values_36, valueOf_40);
function $clinit_EdgeLabelSideSelection$Map(){
  $clinit_EdgeLabelSideSelection$Map = emptyMethod;
  $MAP_28 = createValueOfMap(($clinit_EdgeLabelSideSelection() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_EdgeLabelSideSelection_2_classLit, 1), $intern_38, 266, 0, [ALWAYS_UP, ALWAYS_DOWN, DIRECTION_UP, DIRECTION_DOWN, SMART_UP, SMART_DOWN])));
}

var $MAP_28;
function $clinit_EdgeStraighteningStrategy(){
  $clinit_EdgeStraighteningStrategy = emptyMethod;
  NONE_0 = new EdgeStraighteningStrategy('NONE', 0);
  IMPROVE_STRAIGHTNESS = new EdgeStraighteningStrategy('IMPROVE_STRAIGHTNESS', 1);
}

function EdgeStraighteningStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_41(name_0){
  $clinit_EdgeStraighteningStrategy();
  return valueOf(($clinit_EdgeStraighteningStrategy$Map() , $MAP_29), name_0);
}

function values_37(){
  $clinit_EdgeStraighteningStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_EdgeStraighteningStrategy_2_classLit, 1), $intern_38, 452, 0, [NONE_0, IMPROVE_STRAIGHTNESS]);
}

defineClass(452, 22, {3:1, 34:1, 22:1, 452:1}, EdgeStraighteningStrategy);
var IMPROVE_STRAIGHTNESS, NONE_0;
var Lorg_eclipse_elk_alg_layered_options_EdgeStraighteningStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'EdgeStraighteningStrategy', 452, Ljava_lang_Enum_2_classLit, values_37, valueOf_41);
function $clinit_EdgeStraighteningStrategy$Map(){
  $clinit_EdgeStraighteningStrategy$Map = emptyMethod;
  $MAP_29 = createValueOfMap(($clinit_EdgeStraighteningStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_EdgeStraighteningStrategy_2_classLit, 1), $intern_38, 452, 0, [NONE_0, IMPROVE_STRAIGHTNESS])));
}

var $MAP_29;
function $clinit_FixedAlignment(){
  $clinit_FixedAlignment = emptyMethod;
  NONE_1 = new FixedAlignment('NONE', 0);
  LEFTUP = new FixedAlignment('LEFTUP', 1);
  RIGHTUP = new FixedAlignment('RIGHTUP', 2);
  LEFTDOWN = new FixedAlignment('LEFTDOWN', 3);
  RIGHTDOWN = new FixedAlignment('RIGHTDOWN', 4);
  BALANCED = new FixedAlignment('BALANCED', 5);
}

function FixedAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_42(name_0){
  $clinit_FixedAlignment();
  return valueOf(($clinit_FixedAlignment$Map() , $MAP_30), name_0);
}

function values_38(){
  $clinit_FixedAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_FixedAlignment_2_classLit, 1), $intern_38, 264, 0, [NONE_1, LEFTUP, RIGHTUP, LEFTDOWN, RIGHTDOWN, BALANCED]);
}

defineClass(264, 22, {3:1, 34:1, 22:1, 264:1}, FixedAlignment);
var BALANCED, LEFTDOWN, LEFTUP, NONE_1, RIGHTDOWN, RIGHTUP;
var Lorg_eclipse_elk_alg_layered_options_FixedAlignment_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'FixedAlignment', 264, Ljava_lang_Enum_2_classLit, values_38, valueOf_42);
function $clinit_FixedAlignment$Map(){
  $clinit_FixedAlignment$Map = emptyMethod;
  $MAP_30 = createValueOfMap(($clinit_FixedAlignment() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_FixedAlignment_2_classLit, 1), $intern_38, 264, 0, [NONE_1, LEFTUP, RIGHTUP, LEFTDOWN, RIGHTDOWN, BALANCED])));
}

var $MAP_30;
function $clinit_GraphCompactionStrategy(){
  $clinit_GraphCompactionStrategy = emptyMethod;
  NONE_2 = new GraphCompactionStrategy('NONE', 0);
  LEFT_1 = new GraphCompactionStrategy('LEFT', 1);
  RIGHT_1 = new GraphCompactionStrategy('RIGHT', 2);
  LEFT_RIGHT_CONSTRAINT_LOCKING = new GraphCompactionStrategy('LEFT_RIGHT_CONSTRAINT_LOCKING', 3);
  LEFT_RIGHT_CONNECTION_LOCKING = new GraphCompactionStrategy('LEFT_RIGHT_CONNECTION_LOCKING', 4);
  EDGE_LENGTH = new GraphCompactionStrategy('EDGE_LENGTH', 5);
}

function GraphCompactionStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_43(name_0){
  $clinit_GraphCompactionStrategy();
  return valueOf(($clinit_GraphCompactionStrategy$Map() , $MAP_31), name_0);
}

function values_39(){
  $clinit_GraphCompactionStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_GraphCompactionStrategy_2_classLit, 1), $intern_38, 265, 0, [NONE_2, LEFT_1, RIGHT_1, LEFT_RIGHT_CONSTRAINT_LOCKING, LEFT_RIGHT_CONNECTION_LOCKING, EDGE_LENGTH]);
}

defineClass(265, 22, {3:1, 34:1, 22:1, 265:1}, GraphCompactionStrategy);
var EDGE_LENGTH, LEFT_1, LEFT_RIGHT_CONNECTION_LOCKING, LEFT_RIGHT_CONSTRAINT_LOCKING, NONE_2, RIGHT_1;
var Lorg_eclipse_elk_alg_layered_options_GraphCompactionStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'GraphCompactionStrategy', 265, Ljava_lang_Enum_2_classLit, values_39, valueOf_43);
function $clinit_GraphCompactionStrategy$Map(){
  $clinit_GraphCompactionStrategy$Map = emptyMethod;
  $MAP_31 = createValueOfMap(($clinit_GraphCompactionStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_GraphCompactionStrategy_2_classLit, 1), $intern_38, 265, 0, [NONE_2, LEFT_1, RIGHT_1, LEFT_RIGHT_CONSTRAINT_LOCKING, LEFT_RIGHT_CONNECTION_LOCKING, EDGE_LENGTH])));
}

var $MAP_31;
function $clinit_GraphProperties(){
  $clinit_GraphProperties = emptyMethod;
  COMMENTS = new GraphProperties('COMMENTS', 0);
  EXTERNAL_PORTS = new GraphProperties('EXTERNAL_PORTS', 1);
  HYPEREDGES = new GraphProperties('HYPEREDGES', 2);
  HYPERNODES = new GraphProperties('HYPERNODES', 3);
  NON_FREE_PORTS = new GraphProperties('NON_FREE_PORTS', 4);
  NORTH_SOUTH_PORTS = new GraphProperties('NORTH_SOUTH_PORTS', 5);
  SELF_LOOPS = new GraphProperties('SELF_LOOPS', 6);
  CENTER_LABELS = new GraphProperties('CENTER_LABELS', 7);
  END_LABELS = new GraphProperties('END_LABELS', 8);
  PARTITIONS = new GraphProperties('PARTITIONS', 9);
}

function GraphProperties(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_44(name_0){
  $clinit_GraphProperties();
  return valueOf(($clinit_GraphProperties$Map() , $MAP_32), name_0);
}

function values_40(){
  $clinit_GraphProperties();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_GraphProperties_2_classLit, 1), $intern_38, 244, 0, [COMMENTS, EXTERNAL_PORTS, HYPEREDGES, HYPERNODES, NON_FREE_PORTS, NORTH_SOUTH_PORTS, SELF_LOOPS, CENTER_LABELS, END_LABELS, PARTITIONS]);
}

defineClass(244, 22, {3:1, 34:1, 22:1, 244:1}, GraphProperties);
var CENTER_LABELS, COMMENTS, END_LABELS, EXTERNAL_PORTS, HYPEREDGES, HYPERNODES, NON_FREE_PORTS, NORTH_SOUTH_PORTS, PARTITIONS, SELF_LOOPS;
var Lorg_eclipse_elk_alg_layered_options_GraphProperties_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'GraphProperties', 244, Ljava_lang_Enum_2_classLit, values_40, valueOf_44);
function $clinit_GraphProperties$Map(){
  $clinit_GraphProperties$Map = emptyMethod;
  $MAP_32 = createValueOfMap(($clinit_GraphProperties() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_GraphProperties_2_classLit, 1), $intern_38, 244, 0, [COMMENTS, EXTERNAL_PORTS, HYPEREDGES, HYPERNODES, NON_FREE_PORTS, NORTH_SOUTH_PORTS, SELF_LOOPS, CENTER_LABELS, END_LABELS, PARTITIONS])));
}

var $MAP_32;
function $clinit_GreedySwitchType(){
  $clinit_GreedySwitchType = emptyMethod;
  ONE_SIDED = new GreedySwitchType('ONE_SIDED', 0);
  TWO_SIDED = new GreedySwitchType('TWO_SIDED', 1);
  OFF = new GreedySwitchType('OFF', 2);
}

function GreedySwitchType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_45(name_0){
  $clinit_GreedySwitchType();
  return valueOf(($clinit_GreedySwitchType$Map() , $MAP_33), name_0);
}

function values_41(){
  $clinit_GreedySwitchType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_GreedySwitchType_2_classLit, 1), $intern_38, 326, 0, [ONE_SIDED, TWO_SIDED, OFF]);
}

defineClass(326, 22, {3:1, 34:1, 22:1, 326:1}, GreedySwitchType);
var OFF, ONE_SIDED, TWO_SIDED;
var Lorg_eclipse_elk_alg_layered_options_GreedySwitchType_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'GreedySwitchType', 326, Ljava_lang_Enum_2_classLit, values_41, valueOf_45);
function $clinit_GreedySwitchType$Map(){
  $clinit_GreedySwitchType$Map = emptyMethod;
  $MAP_33 = createValueOfMap(($clinit_GreedySwitchType() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_GreedySwitchType_2_classLit, 1), $intern_38, 326, 0, [ONE_SIDED, TWO_SIDED, OFF])));
}

var $MAP_33;
function $clinit_InLayerConstraint(){
  $clinit_InLayerConstraint = emptyMethod;
  NONE_3 = new InLayerConstraint('NONE', 0);
  TOP_0 = new InLayerConstraint('TOP', 1);
  BOTTOM_0 = new InLayerConstraint('BOTTOM', 2);
}

function InLayerConstraint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_46(name_0){
  $clinit_InLayerConstraint();
  return valueOf(($clinit_InLayerConstraint$Map() , $MAP_34), name_0);
}

function values_42(){
  $clinit_InLayerConstraint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_InLayerConstraint_2_classLit, 1), $intern_38, 290, 0, [NONE_3, TOP_0, BOTTOM_0]);
}

defineClass(290, 22, {3:1, 34:1, 22:1, 290:1}, InLayerConstraint);
var BOTTOM_0, NONE_3, TOP_0;
var Lorg_eclipse_elk_alg_layered_options_InLayerConstraint_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'InLayerConstraint', 290, Ljava_lang_Enum_2_classLit, values_42, valueOf_46);
function $clinit_InLayerConstraint$Map(){
  $clinit_InLayerConstraint$Map = emptyMethod;
  $MAP_34 = createValueOfMap(($clinit_InLayerConstraint() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_InLayerConstraint_2_classLit, 1), $intern_38, 290, 0, [NONE_3, TOP_0, BOTTOM_0])));
}

var $MAP_34;
function $clinit_InteractiveReferencePoint(){
  $clinit_InteractiveReferencePoint = emptyMethod;
  CENTER_2 = new InteractiveReferencePoint('CENTER', 0);
  TOP_LEFT = new InteractiveReferencePoint('TOP_LEFT', 1);
}

function InteractiveReferencePoint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_47(name_0){
  $clinit_InteractiveReferencePoint();
  return valueOf(($clinit_InteractiveReferencePoint$Map() , $MAP_35), name_0);
}

function values_43(){
  $clinit_InteractiveReferencePoint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_InteractiveReferencePoint_2_classLit, 1), $intern_38, 398, 0, [CENTER_2, TOP_LEFT]);
}

defineClass(398, 22, {3:1, 34:1, 22:1, 398:1}, InteractiveReferencePoint);
var CENTER_2, TOP_LEFT;
var Lorg_eclipse_elk_alg_layered_options_InteractiveReferencePoint_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'InteractiveReferencePoint', 398, Ljava_lang_Enum_2_classLit, values_43, valueOf_47);
function $clinit_InteractiveReferencePoint$Map(){
  $clinit_InteractiveReferencePoint$Map = emptyMethod;
  $MAP_35 = createValueOfMap(($clinit_InteractiveReferencePoint() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_InteractiveReferencePoint_2_classLit, 1), $intern_38, 398, 0, [CENTER_2, TOP_LEFT])));
}

var $MAP_35;
function $clinit_InternalProperties_1(){
  $clinit_InternalProperties_1 = emptyMethod;
  var all, all0;
  ORIGIN_0 = new Property('origin');
  COORDINATE_SYSTEM_ORIGIN = new Property('coordinateOrigin');
  PROCESSORS = new Property('processors');
  COMPOUND_NODE = new Property_0('compoundNode', ($clinit_Boolean() , $clinit_Boolean() , false));
  INSIDE_CONNECTIONS = new Property_0('insideConnections', (null , false));
  NESTED_LGRAPH = new Property('nestedLGraph');
  PARENT_LNODE = new Property('parentLNode');
  ORIGINAL_BENDPOINTS = new Property('originalBendpoints');
  ORIGINAL_DUMMY_NODE_POSITION = new Property('originalDummyNodePosition');
  ORIGINAL_LABEL_EDGE = new Property('originalLabelEdge');
  REPRESENTED_LABELS = new Property('representedLabels');
  END_LABELS_0 = new Property('endLabels');
  LABEL_SIDE = new Property_0('labelSide', ($clinit_LabelSide() , UNKNOWN));
  MAX_EDGE_THICKNESS = new Property_0('maxEdgeThickness', 0);
  REVERSED = new Property_0('reversed', (null , false));
  RANDOM_0 = new Property('random');
  LONG_EDGE_SOURCE = new Property_0('longEdgeSource', null);
  LONG_EDGE_TARGET = new Property_0('longEdgeTarget', null);
  LONG_EDGE_HAS_LABEL_DUMMIES = new Property_0('longEdgeHasLabelDummies', (null , false));
  LONG_EDGE_BEFORE_LABEL_DUMMY = new Property_0('longEdgeBeforeLabelDummy', (null , false));
  EDGE_CONSTRAINT = new Property_0('edgeConstraint', ($clinit_EdgeConstraint() , NONE));
  IN_LAYER_LAYOUT_UNIT = new Property('inLayerLayoutUnit');
  IN_LAYER_CONSTRAINT = new Property_0('inLayerConstraint', ($clinit_InLayerConstraint() , NONE_3));
  IN_LAYER_SUCCESSOR_CONSTRAINTS = new Property_0('inLayerSuccessorConstraint', new ArrayList);
  PORT_DUMMY = new Property('portDummy');
  CROSSING_HINT = new Property_0('crossingHint', valueOf_4(0));
  GRAPH_PROPERTIES = new Property_0('graphProperties', (all0 = castTo($getEnumConstants(Lorg_eclipse_elk_alg_layered_options_GraphProperties_2_classLit), 10) , new EnumSet$EnumSetImpl(all0, castTo(createFrom(all0, all0.length), 10), 0)));
  EXT_PORT_SIDE = new Property_0('externalPortSide', ($clinit_PortSide() , UNDEFINED_7));
  EXT_PORT_SIZE = new Property_0('externalPortSize', new KVector);
  EXT_PORT_REPLACED_DUMMIES = new Property('externalPortReplacedDummies');
  EXT_PORT_REPLACED_DUMMY = new Property('externalPortReplacedDummy');
  EXT_PORT_CONNECTIONS = new Property_0('externalPortConnections', (all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_PortSide_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0)));
  PORT_RATIO_OR_POSITION_0 = new Property_0('portRatioOrPosition', 0);
  BARYCENTER_ASSOCIATES = new Property('barycenterAssociates');
  TOP_COMMENTS = new Property('TopSideComments');
  BOTTOM_COMMENTS = new Property('BottomSideComments');
  COMMENT_CONN_PORT = new Property('CommentConnectionPort');
  INPUT_COLLECT = new Property_0('inputCollect', (null , false));
  OUTPUT_COLLECT = new Property_0('outputCollect', (null , false));
  CYCLIC = new Property_0('cyclic', (null , false));
  BIG_NODE_ORIGINAL_SIZE = new Property_0('bigNodeOriginalSize', new Float(0));
  BIG_NODE_INITIAL = new Property_0('bigNodeInitial', (null , false));
  BIGNODES_ORIG_LABELS = new Property_0('org.eclipse.elk.alg.layered.bigNodeLabels', new ArrayList);
  BIGNODES_POST_PROCESS = new Property_0('org.eclipse.elk.alg.layered.postProcess', null);
  CROSS_HIERARCHY_MAP = new Property('crossHierarchyMap');
  TARGET_OFFSET = new Property('targetOffset');
  SPLINE_LABEL_SIZE = new Property_0('splineLabelSize', new KVector);
  SPLINE_LOOPSIDE = new Property_0('splineLoopSide', ($clinit_LoopSide() , UNDEFINED_1));
  SPLINE_SELFLOOP_COMPONENTS = new Property_0('splineSelfLoopComponents', new ArrayList);
  SPLINE_SELF_LOOP_MARGINS = new Property_0('splineSelfLoopMargins', new ElkMargin);
  SPACINGS = new Property('spacings');
  PARTITION_DUMMY = new Property_0('partitionConstraint', (null , false));
  BREAKING_POINT_INFO = new Property('breakingPoint.info');
  SPLINE_SURVIVING_EDGE = new Property('splines.survivingEdge');
  SPLINE_ROUTE_START = new Property('splines.route.start');
  SPLINE_EDGE_CHAIN = new Property('splines.edgeChain');
  SPLINE_NS_PORT_Y_COORD = new Property('splines.nsPortY');
}

var BARYCENTER_ASSOCIATES, BIGNODES_ORIG_LABELS, BIGNODES_POST_PROCESS, BIG_NODE_INITIAL, BIG_NODE_ORIGINAL_SIZE, BOTTOM_COMMENTS, BREAKING_POINT_INFO, COMMENT_CONN_PORT, COMPOUND_NODE, COORDINATE_SYSTEM_ORIGIN, CROSSING_HINT, CROSS_HIERARCHY_MAP, CYCLIC, EDGE_CONSTRAINT, END_LABELS_0, EXT_PORT_CONNECTIONS, EXT_PORT_REPLACED_DUMMIES, EXT_PORT_REPLACED_DUMMY, EXT_PORT_SIDE, EXT_PORT_SIZE, GRAPH_PROPERTIES, INPUT_COLLECT, INSIDE_CONNECTIONS, IN_LAYER_CONSTRAINT, IN_LAYER_LAYOUT_UNIT, IN_LAYER_SUCCESSOR_CONSTRAINTS, LABEL_SIDE, LONG_EDGE_BEFORE_LABEL_DUMMY, LONG_EDGE_HAS_LABEL_DUMMIES, LONG_EDGE_SOURCE, LONG_EDGE_TARGET, MAX_EDGE_THICKNESS, NESTED_LGRAPH, ORIGIN_0, ORIGINAL_BENDPOINTS, ORIGINAL_DUMMY_NODE_POSITION, ORIGINAL_LABEL_EDGE, OUTPUT_COLLECT, PARENT_LNODE, PARTITION_DUMMY, PORT_DUMMY, PORT_RATIO_OR_POSITION_0, PROCESSORS, RANDOM_0, REPRESENTED_LABELS, REVERSED, SPACINGS, SPLINE_EDGE_CHAIN, SPLINE_LABEL_SIZE, SPLINE_LOOPSIDE, SPLINE_NS_PORT_Y_COORD, SPLINE_ROUTE_START, SPLINE_SELFLOOP_COMPONENTS, SPLINE_SELF_LOOP_MARGINS, SPLINE_SURVIVING_EDGE, TARGET_OFFSET, TOP_COMMENTS;
function $clinit_LayerConstraint(){
  $clinit_LayerConstraint = emptyMethod;
  NONE_4 = new LayerConstraint('NONE', 0);
  FIRST = new LayerConstraint('FIRST', 1);
  FIRST_SEPARATE = new LayerConstraint('FIRST_SEPARATE', 2);
  LAST = new LayerConstraint('LAST', 3);
  LAST_SEPARATE = new LayerConstraint('LAST_SEPARATE', 4);
}

function LayerConstraint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_48(name_0){
  $clinit_LayerConstraint();
  return valueOf(($clinit_LayerConstraint$Map() , $MAP_36), name_0);
}

function values_44(){
  $clinit_LayerConstraint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_LayerConstraint_2_classLit, 1), $intern_38, 183, 0, [NONE_4, FIRST, FIRST_SEPARATE, LAST, LAST_SEPARATE]);
}

defineClass(183, 22, {3:1, 34:1, 22:1, 183:1}, LayerConstraint);
var FIRST, FIRST_SEPARATE, LAST, LAST_SEPARATE, NONE_4;
var Lorg_eclipse_elk_alg_layered_options_LayerConstraint_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'LayerConstraint', 183, Ljava_lang_Enum_2_classLit, values_44, valueOf_48);
function $clinit_LayerConstraint$Map(){
  $clinit_LayerConstraint$Map = emptyMethod;
  $MAP_36 = createValueOfMap(($clinit_LayerConstraint() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_LayerConstraint_2_classLit, 1), $intern_38, 183, 0, [NONE_4, FIRST, FIRST_SEPARATE, LAST, LAST_SEPARATE])));
}

var $MAP_36;
function $clinit_LayeredMetaDataProvider(){
  $clinit_LayeredMetaDataProvider = emptyMethod;
  var all;
  CONTENT_ALIGNMENT_DEFAULT = (all = castTo($getEnumConstants(Lorg_eclipse_elk_alg_layered_options_ContentAlignment_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  CONTENT_ALIGNMENT = new Property_1('org.eclipse.elk.layered.contentAlignment', CONTENT_ALIGNMENT_DEFAULT);
  DIRECTION_CONGRUENCY_DEFAULT = ($clinit_DirectionCongruency() , READING_DIRECTION);
  DIRECTION_CONGRUENCY = new Property_1('org.eclipse.elk.layered.directionCongruency', DIRECTION_CONGRUENCY_DEFAULT);
  FEEDBACK_EDGES = new Property_1('org.eclipse.elk.layered.feedbackEdges', ($clinit_Boolean() , $clinit_Boolean() , false));
  INTERACTIVE_REFERENCE_POINT_DEFAULT = ($clinit_InteractiveReferencePoint() , CENTER_2);
  INTERACTIVE_REFERENCE_POINT = new Property_1('org.eclipse.elk.layered.interactiveReferencePoint', INTERACTIVE_REFERENCE_POINT_DEFAULT);
  MERGE_EDGES = new Property_1('org.eclipse.elk.layered.mergeEdges', (null , false));
  MERGE_HIERARCHY_EDGES = new Property_1('org.eclipse.elk.layered.mergeHierarchyEdges', (null , true));
  NORTH_OR_SOUTH_PORT = new Property_1('org.eclipse.elk.layered.northOrSouthPort', (null , false));
  PORT_SORTING_STRATEGY_DEFAULT = ($clinit_PortSortingStrategy() , INPUT_ORDER);
  PORT_SORTING_STRATEGY = new Property_1('org.eclipse.elk.layered.portSortingStrategy', PORT_SORTING_STRATEGY_DEFAULT);
  valueOf_4(1);
  THOROUGHNESS = new Property_1('org.eclipse.elk.layered.thoroughness', valueOf_4(7));
  UNNECESSARY_BENDPOINTS = new Property_1('org.eclipse.elk.layered.unnecessaryBendpoints', (null , false));
  CYCLE_BREAKING_STRATEGY_DEFAULT = ($clinit_CycleBreakingStrategy() , GREEDY);
  CYCLE_BREAKING_STRATEGY = new Property_1('org.eclipse.elk.layered.cycleBreaking.strategy', CYCLE_BREAKING_STRATEGY_DEFAULT);
  LAYERING_STRATEGY_DEFAULT = ($clinit_LayeringStrategy() , NETWORK_SIMPLEX);
  LAYERING_STRATEGY = new Property_1('org.eclipse.elk.layered.layering.strategy', LAYERING_STRATEGY_DEFAULT);
  LAYERING_LAYER_CONSTRAINT_DEFAULT = ($clinit_LayerConstraint() , NONE_4);
  LAYERING_LAYER_CONSTRAINT = new Property_1('org.eclipse.elk.layered.layering.layerConstraint', LAYERING_LAYER_CONSTRAINT_DEFAULT);
  LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_DEFAULT = ($clinit_WideNodesStrategy() , OFF_0);
  LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS = new Property_1('org.eclipse.elk.layered.layering.wideNodesOnMultipleLayers', LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_DEFAULT);
  valueOf_4(-1);
  LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH = new Property_1('org.eclipse.elk.layered.layering.minWidth.upperBoundOnWidth', valueOf_4(4));
  valueOf_4(-1);
  LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR = new Property_1('org.eclipse.elk.layered.layering.minWidth.upperLayerEstimationScalingFactor', valueOf_4(2));
  LAYERING_NODE_PROMOTION_STRATEGY_DEFAULT = ($clinit_NodePromotionStrategy() , NONE_6);
  LAYERING_NODE_PROMOTION_STRATEGY = new Property_1('org.eclipse.elk.layered.layering.nodePromotion.strategy', LAYERING_NODE_PROMOTION_STRATEGY_DEFAULT);
  valueOf_4(0);
  LAYERING_NODE_PROMOTION_MAX_ITERATIONS = new Property_1('org.eclipse.elk.layered.layering.nodePromotion.maxIterations', valueOf_4(0));
  LAYERING_COFFMAN_GRAHAM_LAYER_BOUND = new Property_1('org.eclipse.elk.layered.layering.coffmanGraham.layerBound', valueOf_4($intern_0));
  CROSSING_MINIMIZATION_STRATEGY_DEFAULT = ($clinit_CrossingMinimizationStrategy() , LAYER_SWEEP);
  CROSSING_MINIMIZATION_STRATEGY = new Property_1('org.eclipse.elk.layered.crossingMinimization.strategy', CROSSING_MINIMIZATION_STRATEGY_DEFAULT);
  CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS = new Property_1('org.eclipse.elk.layered.crossingMinimization.hierarchicalSweepiness', 0.1);
  CROSSING_MINIMIZATION_SEMI_INTERACTIVE = new Property_1('org.eclipse.elk.layered.crossingMinimization.semiInteractive', (null , false));
  valueOf_4(0);
  CROSSING_MINIMIZATION_GREEDY_SWITCH_ACTIVATION_THRESHOLD = new Property_1('org.eclipse.elk.layered.crossingMinimization.greedySwitch.activationThreshold', valueOf_4(40));
  CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_DEFAULT = ($clinit_GreedySwitchType() , TWO_SIDED);
  CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE = new Property_1('org.eclipse.elk.layered.crossingMinimization.greedySwitch.type', CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_DEFAULT);
  NODE_PLACEMENT_STRATEGY_DEFAULT = ($clinit_NodePlacementStrategy() , BRANDES_KOEPF);
  NODE_PLACEMENT_STRATEGY = new Property_1('org.eclipse.elk.layered.nodePlacement.strategy', NODE_PLACEMENT_STRATEGY_DEFAULT);
  NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES = new Property('org.eclipse.elk.layered.nodePlacement.favorStraightEdges');
  NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_DEFAULT = ($clinit_EdgeStraighteningStrategy() , IMPROVE_STRAIGHTNESS);
  NODE_PLACEMENT_BK_EDGE_STRAIGHTENING = new Property_1('org.eclipse.elk.layered.nodePlacement.bk.edgeStraightening', NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_DEFAULT);
  NODE_PLACEMENT_BK_FIXED_ALIGNMENT_DEFAULT = ($clinit_FixedAlignment() , NONE_1);
  NODE_PLACEMENT_BK_FIXED_ALIGNMENT = new Property_1('org.eclipse.elk.layered.nodePlacement.bk.fixedAlignment', NODE_PLACEMENT_BK_FIXED_ALIGNMENT_DEFAULT);
  new ExclusiveBounds$ExclusiveLowerBound;
  NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING = new Property_1('org.eclipse.elk.layered.nodePlacement.linearSegments.deflectionDampening', 0.3);
  NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY = new Property('org.eclipse.elk.layered.nodePlacement.networkSimplex.nodeFlexibility');
  NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_DEFAULT = ($clinit_NodeFlexibility() , NONE_5);
  NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT = new Property_1('org.eclipse.elk.layered.nodePlacement.networkSimplex.nodeFlexibility.default', NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_DEFAULT);
  EDGE_ROUTING_SELF_LOOP_PLACEMENT_DEFAULT = ($clinit_SelfLoopPlacement() , NORTH_STACKED);
  EDGE_ROUTING_SELF_LOOP_PLACEMENT = new Property_1('org.eclipse.elk.layered.edgeRouting.selfLoopPlacement', EDGE_ROUTING_SELF_LOOP_PLACEMENT_DEFAULT);
  EDGE_ROUTING_SPLINES_MODE_DEFAULT = ($clinit_SplineRoutingMode() , SLOPPY);
  EDGE_ROUTING_SPLINES_MODE = new Property_1('org.eclipse.elk.layered.edgeRouting.splines.mode', EDGE_ROUTING_SPLINES_MODE_DEFAULT);
  EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR = new Property_1('org.eclipse.elk.layered.edgeRouting.splines.sloppy.layerSpacingFactor', 0.2);
  SPACING_EDGE_NODE_BETWEEN_LAYERS = new Property_1('org.eclipse.elk.layered.spacing.edgeNodeBetweenLayers', 10);
  SPACING_EDGE_EDGE_BETWEEN_LAYERS = new Property_1('org.eclipse.elk.layered.spacing.edgeEdgeBetweenLayers', 10);
  SPACING_NODE_NODE_BETWEEN_LAYERS = new Property_1('org.eclipse.elk.layered.spacing.nodeNodeBetweenLayers', 20);
  valueOf_4(0);
  PRIORITY_DIRECTION = new Property_1('org.eclipse.elk.layered.priority.direction', valueOf_4(0));
  valueOf_4(0);
  PRIORITY_SHORTNESS = new Property_1('org.eclipse.elk.layered.priority.shortness', valueOf_4(0));
  valueOf_4(0);
  PRIORITY_STRAIGHTNESS = new Property_1('org.eclipse.elk.layered.priority.straightness', valueOf_4(0));
  COMPACTION_CONNECTED_COMPONENTS = new Property_1('org.eclipse.elk.layered.compaction.connectedComponents', (null , false));
  COMPACTION_POST_COMPACTION_STRATEGY_DEFAULT = ($clinit_GraphCompactionStrategy() , NONE_2);
  COMPACTION_POST_COMPACTION_STRATEGY = new Property_1('org.eclipse.elk.layered.compaction.postCompaction.strategy', COMPACTION_POST_COMPACTION_STRATEGY_DEFAULT);
  COMPACTION_POST_COMPACTION_CONSTRAINTS_DEFAULT = ($clinit_ConstraintCalculationStrategy() , SCANLINE);
  COMPACTION_POST_COMPACTION_CONSTRAINTS = new Property_1('org.eclipse.elk.layered.compaction.postCompaction.constraints', COMPACTION_POST_COMPACTION_CONSTRAINTS_DEFAULT);
  HIGH_DEGREE_NODES_TREATMENT = new Property_1('org.eclipse.elk.layered.highDegreeNodes.treatment', (null , false));
  valueOf_4(0);
  HIGH_DEGREE_NODES_THRESHOLD = new Property_1('org.eclipse.elk.layered.highDegreeNodes.threshold', valueOf_4(16));
  valueOf_4(0);
  HIGH_DEGREE_NODES_TREE_HEIGHT = new Property_1('org.eclipse.elk.layered.highDegreeNodes.treeHeight', valueOf_4(5));
  WRAPPING_STRATEGY_DEFAULT = ($clinit_WrappingStrategy() , OFF_1);
  WRAPPING_STRATEGY = new Property_1('org.eclipse.elk.layered.wrapping.strategy', WRAPPING_STRATEGY_DEFAULT);
  WRAPPING_ADDITIONAL_EDGE_SPACING = new Property_1('org.eclipse.elk.layered.wrapping.additionalEdgeSpacing', 10);
  WRAPPING_CORRECTION_FACTOR = new Property_1('org.eclipse.elk.layered.wrapping.correctionFactor', 1);
  WRAPPING_CUTTING_STRATEGY_DEFAULT = ($clinit_CuttingStrategy() , MSD);
  WRAPPING_CUTTING_STRATEGY = new Property_1('org.eclipse.elk.layered.wrapping.cutting.strategy', WRAPPING_CUTTING_STRATEGY_DEFAULT);
  WRAPPING_CUTTING_CUTS = new Property('org.eclipse.elk.layered.wrapping.cutting.cuts');
  WRAPPING_CUTTING_MSD_FREEDOM_DEFAULT = valueOf_4(1);
  valueOf_4(0);
  WRAPPING_CUTTING_MSD_FREEDOM = new Property_1('org.eclipse.elk.layered.wrapping.cutting.msd.freedom', WRAPPING_CUTTING_MSD_FREEDOM_DEFAULT);
  WRAPPING_VALIDIFY_STRATEGY_DEFAULT = ($clinit_ValidifyStrategy() , GREEDY_0);
  WRAPPING_VALIDIFY_STRATEGY = new Property_1('org.eclipse.elk.layered.wrapping.validify.strategy', WRAPPING_VALIDIFY_STRATEGY_DEFAULT);
  WRAPPING_VALIDIFY_FORBIDDEN_INDICES = new Property('org.eclipse.elk.layered.wrapping.validify.forbiddenIndices');
  WRAPPING_MULTI_EDGE_IMPROVE_CUTS = new Property_1('org.eclipse.elk.layered.wrapping.multiEdge.improveCuts', (null , true));
  WRAPPING_MULTI_EDGE_DISTANCE_PENALTY = new Property_1('org.eclipse.elk.layered.wrapping.multiEdge.distancePenalty', 2);
  WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES = new Property_1('org.eclipse.elk.layered.wrapping.multiEdge.improveWrappedEdges', (null , true));
  EDGE_LABELS_SIDE_SELECTION_DEFAULT = ($clinit_EdgeLabelSideSelection() , SMART_DOWN);
  EDGE_LABELS_SIDE_SELECTION = new Property_1('org.eclipse.elk.layered.edgeLabels.sideSelection', EDGE_LABELS_SIDE_SELECTION_DEFAULT);
  EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_DEFAULT = ($clinit_CenterEdgeLabelPlacementStrategy() , MEDIAN_LAYER);
  EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY = new Property_1('org.eclipse.elk.layered.edgeLabels.centerLabelPlacementStrategy', EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_DEFAULT);
  INTERACTIVE_REFERENCE_POINT_DEP_CYCLE_BREAKING_STRATEGY_0 = INTERACTIVE_2;
  INTERACTIVE_REFERENCE_POINT_DEP_CROSSING_MINIMIZATION_STRATEGY_1 = INTERACTIVE_1;
  LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH_DEP_LAYERING_STRATEGY_0 = MIN_WIDTH;
  LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR_DEP_LAYERING_STRATEGY_0 = MIN_WIDTH;
  LAYERING_COFFMAN_GRAHAM_LAYER_BOUND_DEP_LAYERING_STRATEGY_0 = COFFMAN_GRAHAM;
  CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS_DEP_HIERARCHY_HANDLING_0 = ($clinit_HierarchyHandling() , INCLUDE_CHILDREN);
  CROSSING_MINIMIZATION_SEMI_INTERACTIVE_DEP_CROSSING_MINIMIZATION_STRATEGY_0 = LAYER_SWEEP;
  NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_DEP_NODE_PLACEMENT_STRATEGY_0 = NETWORK_SIMPLEX_0;
  NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_DEP_NODE_PLACEMENT_STRATEGY_1 = BRANDES_KOEPF;
  NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_DEP_NODE_PLACEMENT_STRATEGY_0 = BRANDES_KOEPF;
  NODE_PLACEMENT_BK_FIXED_ALIGNMENT_DEP_NODE_PLACEMENT_STRATEGY_0 = BRANDES_KOEPF;
  NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING_DEP_NODE_PLACEMENT_STRATEGY_0 = LINEAR_SEGMENTS;
  NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEP_NODE_PLACEMENT_STRATEGY_0 = NETWORK_SIMPLEX_0;
  NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_DEP_NODE_PLACEMENT_STRATEGY_0 = NETWORK_SIMPLEX_0;
  EDGE_ROUTING_SELF_LOOP_PLACEMENT_DEP_EDGE_ROUTING_0 = ($clinit_EdgeRouting() , SPLINES);
  EDGE_ROUTING_SPLINES_MODE_DEP_EDGE_ROUTING_0 = SPLINES;
  EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_DEP_EDGE_ROUTING_0 = SPLINES;
  EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_DEP_EDGE_ROUTING_SPLINES_MODE_1 = SLOPPY;
  WRAPPING_ADDITIONAL_EDGE_SPACING_DEP_WRAPPING_STRATEGY_0 = SINGLE_EDGE;
  WRAPPING_ADDITIONAL_EDGE_SPACING_DEP_WRAPPING_STRATEGY_1 = MULTI_EDGE;
  WRAPPING_CORRECTION_FACTOR_DEP_WRAPPING_STRATEGY_0 = SINGLE_EDGE;
  WRAPPING_CORRECTION_FACTOR_DEP_WRAPPING_STRATEGY_1 = MULTI_EDGE;
  WRAPPING_CUTTING_STRATEGY_DEP_WRAPPING_STRATEGY_0 = SINGLE_EDGE;
  WRAPPING_CUTTING_STRATEGY_DEP_WRAPPING_STRATEGY_1 = MULTI_EDGE;
  WRAPPING_CUTTING_CUTS_DEP_WRAPPING_CUTTING_STRATEGY_0 = MANUAL;
  WRAPPING_CUTTING_MSD_FREEDOM_DEP_WRAPPING_CUTTING_STRATEGY_0 = MSD;
  WRAPPING_VALIDIFY_STRATEGY_DEP_WRAPPING_STRATEGY_0 = SINGLE_EDGE;
  WRAPPING_VALIDIFY_STRATEGY_DEP_WRAPPING_STRATEGY_1 = MULTI_EDGE;
  WRAPPING_VALIDIFY_FORBIDDEN_INDICES_DEP_WRAPPING_STRATEGY_0 = SINGLE_EDGE;
  WRAPPING_VALIDIFY_FORBIDDEN_INDICES_DEP_WRAPPING_STRATEGY_1 = MULTI_EDGE;
  WRAPPING_MULTI_EDGE_IMPROVE_CUTS_DEP_WRAPPING_STRATEGY_0 = MULTI_EDGE;
  WRAPPING_MULTI_EDGE_DISTANCE_PENALTY_DEP_WRAPPING_STRATEGY_0 = MULTI_EDGE;
  WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES_DEP_WRAPPING_STRATEGY_0 = MULTI_EDGE;
}

function LayeredMetaDataProvider(){
  $clinit_LayeredMetaDataProvider();
}

defineClass(778, 1, $intern_92, LayeredMetaDataProvider);
_.apply_3 = function apply_116(registry){
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.contentAlignment'), ''), 'Content Alignment'), 'Specifies how the content of compound nodes is to be aligned, e.g. top-left.'), CONTENT_ALIGNMENT_DEFAULT), ($clinit_LayoutOptionData$Type() , ENUMSET)), Lorg_eclipse_elk_alg_layered_options_ContentAlignment_2_classLit), of_0(($clinit_LayoutOptionData$Target() , PARENTS))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.contentAlignment']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.directionCongruency'), ''), 'Direction Congruency'), 'Specifies how drawings of the same graph with different layout directions compare to each other: either a natural reading direction is preserved or the drawings are rotated versions of each other.'), DIRECTION_CONGRUENCY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_DirectionCongruency_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.feedbackEdges'), ''), 'Feedback Edges'), 'Whether feedback edges should be highlighted by routing around the nodes.'), ($clinit_Boolean() , $clinit_Boolean() , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.feedBackEdges']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.interactiveReferencePoint'), ''), 'Interactive Reference Point'), 'Determines which point of a node is considered by interactive layout phases.'), INTERACTIVE_REFERENCE_POINT_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_InteractiveReferencePoint_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.interactiveReferencePoint']))));
  $addDependency(registry, 'org.eclipse.elk.layered.interactiveReferencePoint', 'org.eclipse.elk.layered.cycleBreaking.strategy', INTERACTIVE_REFERENCE_POINT_DEP_CYCLE_BREAKING_STRATEGY_0);
  $addDependency(registry, 'org.eclipse.elk.layered.interactiveReferencePoint', 'org.eclipse.elk.layered.crossingMinimization.strategy', INTERACTIVE_REFERENCE_POINT_DEP_CROSSING_MINIMIZATION_STRATEGY_1);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.mergeEdges'), ''), 'Merge Edges'), 'Edges that have no ports are merged so they touch the connected nodes at the same points. When this option is disabled, one port is created for each edge directly connected to a node. When it is enabled, all such incoming edges share an input port, and all outgoing edges share an output port.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.mergeEdges']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.mergeHierarchyEdges'), ''), 'Merge Hierarchy-Crossing Edges'), 'If hierarchical layout is active, hierarchy-crossing edges use as few hierarchical ports as possible. They are broken by the algorithm, with hierarchical ports inserted as required. Usually, one such port is created for each edge at each hierarchy crossing point. With this option set to true, we try to create as few hierarchical ports as possible in the process. In particular, all edges that form a hyperedge can share a port.'), (null , true)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.mergeHierarchyEdges']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.northOrSouthPort'), ''), 'North or South Port'), 'Specifies that this port can either be placed on the north side of a node or on the south side (if port constraints permit)'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PORTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.northOrSouthPort']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.portSortingStrategy'), ''), 'Port Sorting Strategy'), "Only relevant for nodes with FIXED_SIDE port constraints. Determines the way a node's ports are distributed on the sides of a node if their order is not prescribed. The option is set on parent nodes."), PORT_SORTING_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_PortSortingStrategy_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.thoroughness'), ''), 'Thoroughness'), 'How much effort should be spent to produce a nice layout.'), valueOf_4(7)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.thoroughness']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.unnecessaryBendpoints'), ''), 'Add Unnecessary Bendpoints'), 'Adds bend points even if an edge does not change direction. If true, each long edge dummy will contribute a bend point to its edges and hierarchy-crossing edges will always get a bend point where they cross hierarchy boundaries. By default, bend points are only added where an edge changes direction.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.unnecessaryBendpoints']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.cycleBreaking.strategy'), 'cycleBreaking'), 'Cycle Breaking Strategy'), 'Strategy for cycle breaking. Cycle breaking looks for cycles in the graph and determines which edges to reverse to break the cycles. Reversed edges will end up pointing to the opposite direction of regular edges (that is, reversed edges will point left if edges usually point right).'), CYCLE_BREAKING_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_CycleBreakingStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.cycleBreaking']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.layering.strategy'), 'layering'), 'Node Layering Strategy'), 'Strategy for node layering.'), LAYERING_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_LayeringStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.nodeLayering']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.layering.layerConstraint'), 'layering'), 'Layer Constraint'), 'Determines a constraint on the placement of the node regarding the layering.'), LAYERING_LAYER_CONSTRAINT_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_LayerConstraint_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.layerConstraint']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.layering.wideNodesOnMultipleLayers'), 'layering'), 'Wide Nodes on Multiple Layers'), 'Strategy to distribute wide nodes over multiple layers.'), LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_WideNodesStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.wideNodesOnMultipleLayers']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.layering.minWidth.upperBoundOnWidth'), 'layering.minWidth'), 'Upper Bound On Width [MinWidth Layerer]'), "Defines a loose upper bound on the width of the MinWidth layerer. If set to '-1' multiple values are tested and the best result is selected."), valueOf_4(4)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.minWidthUpperBoundOnWidth']))));
  $addDependency(registry, 'org.eclipse.elk.layered.layering.minWidth.upperBoundOnWidth', 'org.eclipse.elk.layered.layering.strategy', LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH_DEP_LAYERING_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.layering.minWidth.upperLayerEstimationScalingFactor'), 'layering.minWidth'), 'Upper Layer Estimation Scaling Factor [MinWidth Layerer]'), "Multiplied with Upper Bound On Width for defining an upper bound on the width of layers which haven't been determined yet, but whose maximum width had been (roughly) estimated by the MinWidth algorithm. Compensates for too high estimations. If set to '-1' multiple values are tested and the best result is selected."), valueOf_4(2)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.minWidthUpperLayerEstimationScalingFactor']))));
  $addDependency(registry, 'org.eclipse.elk.layered.layering.minWidth.upperLayerEstimationScalingFactor', 'org.eclipse.elk.layered.layering.strategy', LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR_DEP_LAYERING_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.layering.nodePromotion.strategy'), 'layering.nodePromotion'), 'Node Promotion Strategy'), 'Reduces number of dummy nodes after layering phase (if possible).'), LAYERING_NODE_PROMOTION_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_NodePromotionStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.nodePromotion']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.layering.nodePromotion.maxIterations'), 'layering.nodePromotion'), 'Max Node Promotion Iterations'), 'Limits the number of iterations for node promotion.'), valueOf_4(0)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.nodePromotionBoundary']))));
  $addDependency(registry, 'org.eclipse.elk.layered.layering.nodePromotion.maxIterations', 'org.eclipse.elk.layered.layering.nodePromotion.strategy', null);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.layering.coffmanGraham.layerBound'), 'layering.coffmanGraham'), 'Layer Bound'), 'The maximum number of nodes allowed per layer.'), valueOf_4($intern_0)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.layering.coffmanGraham.layerBound', 'org.eclipse.elk.layered.layering.strategy', LAYERING_COFFMAN_GRAHAM_LAYER_BOUND_DEP_LAYERING_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.crossingMinimization.strategy'), 'crossingMinimization'), 'Crossing Minimization Strategy'), 'Strategy for crossing minimization.'), CROSSING_MINIMIZATION_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_CrossingMinimizationStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.crossMin']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.crossingMinimization.hierarchicalSweepiness'), 'crossingMinimization'), 'Hierarchical Sweepiness'), 'How likely it is to use cross-hierarchy (1) vs bottom-up (-1).'), 0.1), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.crossingMinimization.hierarchicalSweepiness', 'org.eclipse.elk.hierarchyHandling', CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS_DEP_HIERARCHY_HANDLING_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.crossingMinimization.semiInteractive'), 'crossingMinimization'), 'Semi-Interactive Crossing Minimization'), "Preserves the order of nodes within a layer but still minimizes crossings between edges connecting long edge dummies. Derives the desired order from positions specified by the 'org.eclipse.elk.position' layout option. Requires a crossing minimization strategy that is able to process 'in-layer' constraints."), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.crossingMinimization.semiInteractive', 'org.eclipse.elk.layered.crossingMinimization.strategy', CROSSING_MINIMIZATION_SEMI_INTERACTIVE_DEP_CROSSING_MINIMIZATION_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.crossingMinimization.greedySwitch.activationThreshold'), 'crossingMinimization.greedySwitch'), 'Greedy Switch Activation Threshold'), "By default it is decided automatically if the greedy switch is activated or not. The decision is based on whether the size of the input graph (without dummy nodes) is smaller than the value of this option. A '0' enforces the activation."), valueOf_4(40)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.crossingMinimization.greedySwitch.type'), 'crossingMinimization.greedySwitch'), 'Greedy Switch Crossing Minimization'), 'Greedy Switch strategy for crossing minimization. The greedy switch heuristic is executed after the regular layer sweep as a post-processor.'), CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_GreedySwitchType_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.greedySwitch']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.nodePlacement.strategy'), 'nodePlacement'), 'Node Placement Strategy'), 'Strategy for node placement.'), NODE_PLACEMENT_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_NodePlacementStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.nodePlace']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.nodePlacement.favorStraightEdges'), 'nodePlacement'), 'Favor Straight Edges Over Balancing'), "Favor straight edges over a balanced node placement. The default behavior is determined automatically based on the used 'edgeRouting'. For an orthogonal style it is set to true, for all other styles to false."), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.nodePlacement.favorStraightEdges', 'org.eclipse.elk.layered.nodePlacement.strategy', NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_DEP_NODE_PLACEMENT_STRATEGY_0);
  $addDependency(registry, 'org.eclipse.elk.layered.nodePlacement.favorStraightEdges', 'org.eclipse.elk.layered.nodePlacement.strategy', NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_DEP_NODE_PLACEMENT_STRATEGY_1);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.nodePlacement.bk.edgeStraightening'), 'nodePlacement.bk'), 'BK Edge Straightening'), "Specifies whether the Brandes Koepf node placer tries to increase the number of straight edges at the expense of diagram size. There is a subtle difference to the 'favorStraightEdges' option, which decides whether a balanced placement of the nodes is desired, or not. In bk terms this means combining the four alignments into a single balanced one, or not. This option on the other hand tries to straighten additional edges during the creation of each of the four alignments."), NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_EdgeStraighteningStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.nodeplace.compactionStrategy']))));
  $addDependency(registry, 'org.eclipse.elk.layered.nodePlacement.bk.edgeStraightening', 'org.eclipse.elk.layered.nodePlacement.strategy', NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_DEP_NODE_PLACEMENT_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.nodePlacement.bk.fixedAlignment'), 'nodePlacement.bk'), 'BK Fixed Alignment'), 'Tells the BK node placer to use a certain alignment (out of its four) instead of the one producing the smallest height, or the combination of all four.'), NODE_PLACEMENT_BK_FIXED_ALIGNMENT_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_FixedAlignment_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.fixedAlignment']))));
  $addDependency(registry, 'org.eclipse.elk.layered.nodePlacement.bk.fixedAlignment', 'org.eclipse.elk.layered.nodePlacement.strategy', NODE_PLACEMENT_BK_FIXED_ALIGNMENT_DEP_NODE_PLACEMENT_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.nodePlacement.linearSegments.deflectionDampening'), 'nodePlacement.linearSegments'), 'Linear Segments Deflection Dampening'), 'Dampens the movement of nodes to keep the diagram from getting too large.'), 0.3), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.linearSegmentsDeflectionDampening']))));
  $addDependency(registry, 'org.eclipse.elk.layered.nodePlacement.linearSegments.deflectionDampening', 'org.eclipse.elk.layered.nodePlacement.strategy', NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING_DEP_NODE_PLACEMENT_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.nodePlacement.networkSimplex.nodeFlexibility'), 'nodePlacement.networkSimplex'), 'Node Flexibility'), "Aims at shorter and straighter edges. Two configurations are possible: (a) allow ports to move freely on the side they are assigned to (the order is always defined beforehand), (b) additionally allow to enlarge a node wherever it helps. If this option is not configured for a node, the 'nodeFlexibility.default' value is used, which is specified for the node's parent."), ENUM), Lorg_eclipse_elk_alg_layered_options_NodeFlexibility_2_classLit), of_0(NODES))));
  $addDependency(registry, 'org.eclipse.elk.layered.nodePlacement.networkSimplex.nodeFlexibility', 'org.eclipse.elk.layered.nodePlacement.strategy', NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEP_NODE_PLACEMENT_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.nodePlacement.networkSimplex.nodeFlexibility.default'), 'nodePlacement.networkSimplex.nodeFlexibility'), 'Node Flexibility Default'), "Default value of the 'nodeFlexibility' option for the children of a hierarchical node."), NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_NodeFlexibility_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.nodePlacement.networkSimplex.nodeFlexibility.default', 'org.eclipse.elk.layered.nodePlacement.strategy', NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_DEP_NODE_PLACEMENT_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.edgeRouting.selfLoopPlacement'), 'edgeRouting'), 'Spline Self-Loop Placement'), null), EDGE_ROUTING_SELF_LOOP_PLACEMENT_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_SelfLoopPlacement_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.splines.selfLoopPlacement']))));
  $addDependency(registry, 'org.eclipse.elk.layered.edgeRouting.selfLoopPlacement', 'org.eclipse.elk.edgeRouting', EDGE_ROUTING_SELF_LOOP_PLACEMENT_DEP_EDGE_ROUTING_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.edgeRouting.splines.mode'), 'edgeRouting.splines'), 'Spline Routing Mode'), 'Specifies the way control points are assembled for each individual edge. CONSERVATIVE ensures that edges are properly routed around the nodes but feels rather orthogonal at times. SLOPPY uses fewer control points to obtain curvier edge routes but may result in edges overlapping nodes.'), EDGE_ROUTING_SPLINES_MODE_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_SplineRoutingMode_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.edgeRouting.splines.mode', 'org.eclipse.elk.edgeRouting', EDGE_ROUTING_SPLINES_MODE_DEP_EDGE_ROUTING_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.edgeRouting.splines.sloppy.layerSpacingFactor'), 'edgeRouting.splines.sloppy'), 'Sloppy Spline Layer Spacing Factor'), 'Spacing factor for routing area between layers when using sloppy spline routing.'), 0.2), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.edgeRouting.splines.sloppy.layerSpacingFactor', 'org.eclipse.elk.edgeRouting', EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_DEP_EDGE_ROUTING_0);
  $addDependency(registry, 'org.eclipse.elk.layered.edgeRouting.splines.sloppy.layerSpacingFactor', 'org.eclipse.elk.layered.edgeRouting.splines.mode', EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_DEP_EDGE_ROUTING_SPLINES_MODE_1);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.spacing.edgeNodeBetweenLayers'), 'spacing'), 'Edge Node Between Layers Spacing'), "The spacing to be preserved between nodes and edges that are routed next to the node's layer. For the spacing between nodes and edges that cross the node's layer 'spacing.edgeNode' is used."), 10), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.spacing.edgeEdgeBetweenLayers'), 'spacing'), 'Edge Edge Between Layer Spacing'), "Spacing to be preserved between pairs of edges that are routed between the same pair of layers. Note that 'spacing.edgeEdge' is used for the spacing between pairs of edges crossing the same layer."), 10), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.spacing.nodeNodeBetweenLayers'), 'spacing'), 'Node Node Between Layers Spacing'), "The spacing to be preserved between any pair of nodes of two adjacent layers. Note that 'spacing.nodeNode' is used for the spacing between nodes within the layer itself."), 20), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.priority.direction'), 'priority'), 'Direction Priority'), 'Defines how important it is to have a certain edge point into the direction of the overall layout. This option is evaluated during the cycle breaking phase.'), valueOf_4(0)), INT), Ljava_lang_Integer_2_classLit), of_0(EDGES))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.priority.shortness'), 'priority'), 'Shortness Priority'), 'Defines how important it is to keep an edge as short as possible. This option is evaluated during the layering phase.'), valueOf_4(0)), INT), Ljava_lang_Integer_2_classLit), of_0(EDGES))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.priority.straightness'), 'priority'), 'Straightness Priority'), 'Defines how important it is to keep an edge straight, i.e. aligned with one of the two axes. This option is evaluated during node placement.'), valueOf_4(0)), INT), Ljava_lang_Integer_2_classLit), of_0(EDGES))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.compaction.connectedComponents'), 'compaction'), 'Connected Components Compaction'), 'Tries to further compact components (disconnected sub-graphs).'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.components.compact']))));
  $addDependency(registry, 'org.eclipse.elk.layered.compaction.connectedComponents', 'org.eclipse.elk.separateConnectedComponents', (null , true));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.compaction.postCompaction.strategy'), 'compaction.postCompaction'), 'Post Compaction Strategy'), 'Specifies whether and how post-process compaction is applied.'), COMPACTION_POST_COMPACTION_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_GraphCompactionStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.postCompaction']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.compaction.postCompaction.constraints'), 'compaction.postCompaction'), 'Post Compaction Constraint Calculation'), 'Specifies whether and how post-process compaction is applied.'), COMPACTION_POST_COMPACTION_CONSTRAINTS_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_ConstraintCalculationStrategy_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.postCompaction.constraints']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.highDegreeNodes.treatment'), 'highDegreeNodes'), 'High Degree Node Treatment'), 'Makes room around high degree nodes to place leafs and trees.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.highDegreeNode.treatment']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.highDegreeNodes.threshold'), 'highDegreeNodes'), 'High Degree Node Threshold'), 'Whether a node is considered to have a high degree.'), valueOf_4(16)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.highDegreeNode.threshold']))));
  $addDependency(registry, 'org.eclipse.elk.layered.highDegreeNodes.threshold', 'org.eclipse.elk.layered.highDegreeNodes.treatment', (null , true));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.highDegreeNodes.treeHeight'), 'highDegreeNodes'), 'High Degree Node Maximum Tree Height'), 'Maximum height of a subtree connected to a high degree node to be moved to separate layers.'), valueOf_4(5)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.highDegreeNode.treeHeight']))));
  $addDependency(registry, 'org.eclipse.elk.layered.highDegreeNodes.treeHeight', 'org.eclipse.elk.layered.highDegreeNodes.treatment', (null , true));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.strategy'), 'wrapping'), 'Graph Wrapping Strategy'), "For certain graphs and certain prescribed drawing areas it may be desirable to split the laid out graph into chunks that are placed side by side. The edges that connect different chunks are 'wrapped' around from the end of one chunk to the start of the other chunk. The points between the chunks are referred to as 'cuts'."), WRAPPING_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_WrappingStrategy_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.additionalEdgeSpacing'), 'wrapping'), 'Additional Wrapped Edges Spacing'), 'To visually separate edges that are wrapped from regularly routed edges an additional spacing value can be specified in form of this layout option. The spacing is added to the regular edgeNode spacing.'), 10), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.additionalEdgeSpacing', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_ADDITIONAL_EDGE_SPACING_DEP_WRAPPING_STRATEGY_0);
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.additionalEdgeSpacing', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_ADDITIONAL_EDGE_SPACING_DEP_WRAPPING_STRATEGY_1);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.correctionFactor'), 'wrapping'), 'Correction Factor for Wrapping'), "At times and for certain types of graphs the executed wrapping may produce results that are consistently biased in the same fashion: either wrapping to often or to rarely. This factor can be used to correct the bias. Internally, it is simply multiplied with the 'aspect ratio' layout option."), 1), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.correctionFactor', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_CORRECTION_FACTOR_DEP_WRAPPING_STRATEGY_0);
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.correctionFactor', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_CORRECTION_FACTOR_DEP_WRAPPING_STRATEGY_1);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.cutting.strategy'), 'wrapping.cutting'), 'Cutting Strategy'), 'The strategy by which the layer indexes are determined at which the layering crumbles into chunks.'), WRAPPING_CUTTING_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_CuttingStrategy_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.cutting.strategy', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_CUTTING_STRATEGY_DEP_WRAPPING_STRATEGY_0);
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.cutting.strategy', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_CUTTING_STRATEGY_DEP_WRAPPING_STRATEGY_1);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.cutting.cuts'), 'wrapping.cutting'), 'Manually Specified Cuts'), 'Allows the user to specify her own cuts for a certain graph.'), OBJECT), Ljava_util_List_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.cutting.cuts', 'org.eclipse.elk.layered.wrapping.cutting.strategy', WRAPPING_CUTTING_CUTS_DEP_WRAPPING_CUTTING_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.cutting.msd.freedom'), 'wrapping.cutting.msd'), 'MSD Freedom'), 'The MSD cutting strategy starts with an initial guess on the number of chunks the graph should be split into. The freedom specifies how much the strategy may deviate from this guess. E.g. if an initial number of 3 is computed, a freedom of 1 allows 2, 3, and 4 cuts.'), WRAPPING_CUTTING_MSD_FREEDOM_DEFAULT), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.cutting.msd.freedom', 'org.eclipse.elk.layered.wrapping.cutting.strategy', WRAPPING_CUTTING_MSD_FREEDOM_DEP_WRAPPING_CUTTING_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.validify.strategy'), 'wrapping.validify'), 'Validification Strategy'), 'When wrapping graphs, one can specify indices that are not allowed as split points. The validification strategy makes sure every computed split point is allowed.'), WRAPPING_VALIDIFY_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_ValidifyStrategy_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.validify.strategy', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_VALIDIFY_STRATEGY_DEP_WRAPPING_STRATEGY_0);
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.validify.strategy', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_VALIDIFY_STRATEGY_DEP_WRAPPING_STRATEGY_1);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.validify.forbiddenIndices'), 'wrapping.validify'), 'Valid Indices for Wrapping'), null), OBJECT), Ljava_util_List_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.validify.forbiddenIndices', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_VALIDIFY_FORBIDDEN_INDICES_DEP_WRAPPING_STRATEGY_0);
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.validify.forbiddenIndices', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_VALIDIFY_FORBIDDEN_INDICES_DEP_WRAPPING_STRATEGY_1);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.multiEdge.improveCuts'), 'wrapping.multiEdge'), 'Improve Cuts'), 'For general graphs it is important that not too many edges wrap backwards. Thus a compromise between evenly-distributed cuts and the total number of cut edges is sought.'), (null , true)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.multiEdge.improveCuts', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_MULTI_EDGE_IMPROVE_CUTS_DEP_WRAPPING_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.multiEdge.distancePenalty'), 'wrapping.multiEdge'), 'Distance Penalty When Improving Cuts'), null), 2), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.multiEdge.distancePenalty', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_MULTI_EDGE_DISTANCE_PENALTY_DEP_WRAPPING_STRATEGY_0);
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.multiEdge.distancePenalty', 'org.eclipse.elk.layered.wrapping.multiEdge.improveCuts', (null , true));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.wrapping.multiEdge.improveWrappedEdges'), 'wrapping.multiEdge'), 'Improve Wrapped Edges'), 'The initial wrapping is performed in a very simple way. As a consequence, edges that wrap from one chunk to another may be unnecessarily long. Activating this option tries to shorten such edges.'), (null , true)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.layered.wrapping.multiEdge.improveWrappedEdges', 'org.eclipse.elk.layered.wrapping.strategy', WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES_DEP_WRAPPING_STRATEGY_0);
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.edgeLabels.sideSelection'), 'edgeLabels'), 'Edge Label Side Selection'), 'Method to decide on edge label sides.'), EDGE_LABELS_SIDE_SELECTION_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_EdgeLabelSideSelection_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.klay.layered.edgeLabelSideSelection']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layered.edgeLabels.centerLabelPlacementStrategy'), 'edgeLabels'), 'Edge Center Label Placement Strategy'), 'Determines in which layer center labels of long edges should be placed.'), EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_layered_options_CenterEdgeLabelPlacementStrategy_2_classLit), of_1(PARENTS, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [LABELS]))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.edgeLabelPlacementStrategy']))));
  $apply_22((new LayeredOptions , registry));
}
;
var COMPACTION_CONNECTED_COMPONENTS, COMPACTION_POST_COMPACTION_CONSTRAINTS, COMPACTION_POST_COMPACTION_CONSTRAINTS_DEFAULT, COMPACTION_POST_COMPACTION_STRATEGY, COMPACTION_POST_COMPACTION_STRATEGY_DEFAULT, CONTENT_ALIGNMENT, CONTENT_ALIGNMENT_DEFAULT, CROSSING_MINIMIZATION_GREEDY_SWITCH_ACTIVATION_THRESHOLD, CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE, CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_DEFAULT, CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS, CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS_DEP_HIERARCHY_HANDLING_0, CROSSING_MINIMIZATION_SEMI_INTERACTIVE, CROSSING_MINIMIZATION_SEMI_INTERACTIVE_DEP_CROSSING_MINIMIZATION_STRATEGY_0, CROSSING_MINIMIZATION_STRATEGY, CROSSING_MINIMIZATION_STRATEGY_DEFAULT, CYCLE_BREAKING_STRATEGY, CYCLE_BREAKING_STRATEGY_DEFAULT, DIRECTION_CONGRUENCY, DIRECTION_CONGRUENCY_DEFAULT, EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY, EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_DEFAULT, EDGE_LABELS_SIDE_SELECTION, EDGE_LABELS_SIDE_SELECTION_DEFAULT, EDGE_ROUTING_SELF_LOOP_PLACEMENT, EDGE_ROUTING_SELF_LOOP_PLACEMENT_DEFAULT, EDGE_ROUTING_SELF_LOOP_PLACEMENT_DEP_EDGE_ROUTING_0, EDGE_ROUTING_SPLINES_MODE, EDGE_ROUTING_SPLINES_MODE_DEFAULT, EDGE_ROUTING_SPLINES_MODE_DEP_EDGE_ROUTING_0, EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR, EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_DEP_EDGE_ROUTING_0, EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_DEP_EDGE_ROUTING_SPLINES_MODE_1, FEEDBACK_EDGES, HIGH_DEGREE_NODES_THRESHOLD, HIGH_DEGREE_NODES_TREATMENT, HIGH_DEGREE_NODES_TREE_HEIGHT, INTERACTIVE_REFERENCE_POINT, INTERACTIVE_REFERENCE_POINT_DEFAULT, INTERACTIVE_REFERENCE_POINT_DEP_CROSSING_MINIMIZATION_STRATEGY_1, INTERACTIVE_REFERENCE_POINT_DEP_CYCLE_BREAKING_STRATEGY_0, LAYERING_COFFMAN_GRAHAM_LAYER_BOUND, LAYERING_COFFMAN_GRAHAM_LAYER_BOUND_DEP_LAYERING_STRATEGY_0, LAYERING_LAYER_CONSTRAINT, LAYERING_LAYER_CONSTRAINT_DEFAULT, LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH, LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH_DEP_LAYERING_STRATEGY_0, LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR, LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR_DEP_LAYERING_STRATEGY_0, LAYERING_NODE_PROMOTION_MAX_ITERATIONS, LAYERING_NODE_PROMOTION_STRATEGY, LAYERING_NODE_PROMOTION_STRATEGY_DEFAULT, LAYERING_STRATEGY, LAYERING_STRATEGY_DEFAULT, LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS, LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_DEFAULT, MERGE_EDGES, MERGE_HIERARCHY_EDGES, NODE_PLACEMENT_BK_EDGE_STRAIGHTENING, NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_DEFAULT, NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_DEP_NODE_PLACEMENT_STRATEGY_0, NODE_PLACEMENT_BK_FIXED_ALIGNMENT, NODE_PLACEMENT_BK_FIXED_ALIGNMENT_DEFAULT, NODE_PLACEMENT_BK_FIXED_ALIGNMENT_DEP_NODE_PLACEMENT_STRATEGY_0, NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES, NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_DEP_NODE_PLACEMENT_STRATEGY_0, NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_DEP_NODE_PLACEMENT_STRATEGY_1, NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING, NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING_DEP_NODE_PLACEMENT_STRATEGY_0, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_DEFAULT, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_DEP_NODE_PLACEMENT_STRATEGY_0, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEP_NODE_PLACEMENT_STRATEGY_0, NODE_PLACEMENT_STRATEGY, NODE_PLACEMENT_STRATEGY_DEFAULT, NORTH_OR_SOUTH_PORT, PORT_SORTING_STRATEGY, PORT_SORTING_STRATEGY_DEFAULT, PRIORITY_DIRECTION, PRIORITY_SHORTNESS, PRIORITY_STRAIGHTNESS, SPACING_EDGE_EDGE_BETWEEN_LAYERS, SPACING_EDGE_NODE_BETWEEN_LAYERS, SPACING_NODE_NODE_BETWEEN_LAYERS, THOROUGHNESS, UNNECESSARY_BENDPOINTS, WRAPPING_ADDITIONAL_EDGE_SPACING, WRAPPING_ADDITIONAL_EDGE_SPACING_DEP_WRAPPING_STRATEGY_0, WRAPPING_ADDITIONAL_EDGE_SPACING_DEP_WRAPPING_STRATEGY_1, WRAPPING_CORRECTION_FACTOR, WRAPPING_CORRECTION_FACTOR_DEP_WRAPPING_STRATEGY_0, WRAPPING_CORRECTION_FACTOR_DEP_WRAPPING_STRATEGY_1, WRAPPING_CUTTING_CUTS, WRAPPING_CUTTING_CUTS_DEP_WRAPPING_CUTTING_STRATEGY_0, WRAPPING_CUTTING_MSD_FREEDOM, WRAPPING_CUTTING_MSD_FREEDOM_DEFAULT, WRAPPING_CUTTING_MSD_FREEDOM_DEP_WRAPPING_CUTTING_STRATEGY_0, WRAPPING_CUTTING_STRATEGY, WRAPPING_CUTTING_STRATEGY_DEFAULT, WRAPPING_CUTTING_STRATEGY_DEP_WRAPPING_STRATEGY_0, WRAPPING_CUTTING_STRATEGY_DEP_WRAPPING_STRATEGY_1, WRAPPING_MULTI_EDGE_DISTANCE_PENALTY, WRAPPING_MULTI_EDGE_DISTANCE_PENALTY_DEP_WRAPPING_STRATEGY_0, WRAPPING_MULTI_EDGE_IMPROVE_CUTS, WRAPPING_MULTI_EDGE_IMPROVE_CUTS_DEP_WRAPPING_STRATEGY_0, WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES, WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES_DEP_WRAPPING_STRATEGY_0, WRAPPING_STRATEGY, WRAPPING_STRATEGY_DEFAULT, WRAPPING_VALIDIFY_FORBIDDEN_INDICES, WRAPPING_VALIDIFY_FORBIDDEN_INDICES_DEP_WRAPPING_STRATEGY_0, WRAPPING_VALIDIFY_FORBIDDEN_INDICES_DEP_WRAPPING_STRATEGY_1, WRAPPING_VALIDIFY_STRATEGY, WRAPPING_VALIDIFY_STRATEGY_DEFAULT, WRAPPING_VALIDIFY_STRATEGY_DEP_WRAPPING_STRATEGY_0, WRAPPING_VALIDIFY_STRATEGY_DEP_WRAPPING_STRATEGY_1;
var Lorg_eclipse_elk_alg_layered_options_LayeredMetaDataProvider_2_classLit = createForClass('org.eclipse.elk.alg.layered.options', 'LayeredMetaDataProvider', 778);
function $clinit_LayeredOptions(){
  $clinit_LayeredOptions = emptyMethod;
  SPACING_COMPONENT_COMPONENT_0 = ($clinit_CoreOptions() , SPACING_COMPONENT_COMPONENT_1);
  SPACING_EDGE_EDGE = SPACING_EDGE_EDGE_0;
  SPACING_EDGE_LABEL_0 = SPACING_EDGE_LABEL_1;
  SPACING_EDGE_NODE = SPACING_EDGE_NODE_0;
  SPACING_LABEL_LABEL = SPACING_LABEL_LABEL_0;
  SPACING_LABEL_PORT = SPACING_LABEL_PORT_0;
  SPACING_LABEL_NODE = SPACING_LABEL_NODE_0;
  SPACING_NODE_NODE_0 = new Property_2(SPACING_NODE_NODE_5, 20);
  SPACING_PORT_PORT = SPACING_PORT_PORT_0;
  SPACING_INDIVIDUAL_OVERRIDE = SPACING_INDIVIDUAL_OVERRIDE_0;
  SPACING_EDGE_EDGE_BETWEEN_LAYERS_0 = ($clinit_LayeredMetaDataProvider() , SPACING_EDGE_EDGE_BETWEEN_LAYERS);
  SPACING_EDGE_NODE_BETWEEN_LAYERS_0 = SPACING_EDGE_NODE_BETWEEN_LAYERS;
  SPACING_NODE_NODE_BETWEEN_LAYERS_0 = SPACING_NODE_NODE_BETWEEN_LAYERS;
  PRIORITY_0 = new Property_2(PRIORITY_3, valueOf_4(0));
  PRIORITY_DIRECTION_0 = PRIORITY_DIRECTION;
  PRIORITY_SHORTNESS_0 = PRIORITY_SHORTNESS;
  PRIORITY_STRAIGHTNESS_0 = PRIORITY_STRAIGHTNESS;
  WRAPPING_STRATEGY_0 = WRAPPING_STRATEGY;
  WRAPPING_ADDITIONAL_EDGE_SPACING_0 = WRAPPING_ADDITIONAL_EDGE_SPACING;
  WRAPPING_CORRECTION_FACTOR_0 = WRAPPING_CORRECTION_FACTOR;
  WRAPPING_CUTTING_STRATEGY_0 = WRAPPING_CUTTING_STRATEGY;
  WRAPPING_CUTTING_CUTS_0 = WRAPPING_CUTTING_CUTS;
  WRAPPING_CUTTING_MSD_FREEDOM_0 = WRAPPING_CUTTING_MSD_FREEDOM;
  WRAPPING_VALIDIFY_STRATEGY_0 = WRAPPING_VALIDIFY_STRATEGY;
  WRAPPING_VALIDIFY_FORBIDDEN_INDICES_0 = WRAPPING_VALIDIFY_FORBIDDEN_INDICES;
  WRAPPING_MULTI_EDGE_IMPROVE_CUTS_0 = WRAPPING_MULTI_EDGE_IMPROVE_CUTS;
  WRAPPING_MULTI_EDGE_DISTANCE_PENALTY_0 = WRAPPING_MULTI_EDGE_DISTANCE_PENALTY;
  WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES_0 = WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES;
  NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0 = NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY;
  NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_0 = NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT;
  EDGE_ROUTING_SPLINES_MODE_0 = EDGE_ROUTING_SPLINES_MODE;
  EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_0 = EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR;
  PADDING_DEFAULT_0 = new ElkPadding_0(12);
  PADDING_1 = new Property_2(PADDING_5, PADDING_DEFAULT_0);
  EDGE_ROUTING_DEFAULT = ($clinit_EdgeRouting() , ORTHOGONAL);
  EDGE_ROUTING = new Property_2(EDGE_ROUTING_0, EDGE_ROUTING_DEFAULT);
  PORT_BORDER_OFFSET = new Property_2(PORT_BORDER_OFFSET_0, 0);
  RANDOM_SEED_0 = new Property_2(RANDOM_SEED_1, valueOf_4(1));
  ASPECT_RATIO_1 = new Property_2(ASPECT_RATIO_4, $intern_105);
  NO_LAYOUT = NO_LAYOUT_0;
  PORT_CONSTRAINTS_0 = PORT_CONSTRAINTS_1;
  PORT_SIDE = PORT_SIDE_0;
  DEBUG_MODE = DEBUG_MODE_3;
  ALIGNMENT = ALIGNMENT_0;
  HIERARCHY_HANDLING = HIERARCHY_HANDLING_0;
  SEPARATE_CONNECTED_COMPONENTS_0 = new Property_2(SEPARATE_CONNECTED_COMPONENTS_2, ($clinit_Boolean() , $clinit_Boolean() , true));
  INSIDE_SELF_LOOPS_ACTIVATE = INSIDE_SELF_LOOPS_ACTIVATE_0;
  INSIDE_SELF_LOOPS_YO = INSIDE_SELF_LOOPS_YO_0;
  NODE_SIZE_CONSTRAINTS = NODE_SIZE_CONSTRAINTS_1;
  NODE_SIZE_OPTIONS = NODE_SIZE_OPTIONS_1;
  DIRECTION_DEFAULT = ($clinit_Direction_0() , UNDEFINED_3);
  DIRECTION = new Property_2(DIRECTION_0, DIRECTION_DEFAULT);
  NODE_LABELS_PLACEMENT = NODE_LABELS_PLACEMENT_0;
  PORT_LABELS_PLACEMENT = PORT_LABELS_PLACEMENT_0;
  PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE = PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE_0;
  PORT_ALIGNMENT_DEFAULT_DEFAULT = ($clinit_PortAlignment() , JUSTIFIED);
  new Property_2(PORT_ALIGNMENT_DEFAULT, PORT_ALIGNMENT_DEFAULT_DEFAULT);
  PORT_ALIGNMENT_NORTH = PORT_ALIGNMENT_NORTH_0;
  PORT_ALIGNMENT_SOUTH = PORT_ALIGNMENT_SOUTH_0;
  PORT_ALIGNMENT_WEST = PORT_ALIGNMENT_WEST_0;
  PORT_ALIGNMENT_EAST = PORT_ALIGNMENT_EAST_0;
  UNNECESSARY_BENDPOINTS_0 = UNNECESSARY_BENDPOINTS;
  LAYERING_STRATEGY_0 = LAYERING_STRATEGY;
  LAYERING_NODE_PROMOTION_STRATEGY_0 = LAYERING_NODE_PROMOTION_STRATEGY;
  THOROUGHNESS_0 = THOROUGHNESS;
  LAYERING_LAYER_CONSTRAINT_0 = LAYERING_LAYER_CONSTRAINT;
  CYCLE_BREAKING_STRATEGY_0 = CYCLE_BREAKING_STRATEGY;
  CROSSING_MINIMIZATION_STRATEGY_0 = CROSSING_MINIMIZATION_STRATEGY;
  CROSSING_MINIMIZATION_GREEDY_SWITCH_ACTIVATION_THRESHOLD_0 = CROSSING_MINIMIZATION_GREEDY_SWITCH_ACTIVATION_THRESHOLD;
  CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_0 = CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE;
  CROSSING_MINIMIZATION_SEMI_INTERACTIVE_0 = CROSSING_MINIMIZATION_SEMI_INTERACTIVE;
  MERGE_EDGES_0 = MERGE_EDGES;
  MERGE_HIERARCHY_EDGES_0 = MERGE_HIERARCHY_EDGES;
  INTERACTIVE_REFERENCE_POINT_0 = INTERACTIVE_REFERENCE_POINT;
  NODE_PLACEMENT_STRATEGY_0 = NODE_PLACEMENT_STRATEGY;
  NODE_PLACEMENT_BK_FIXED_ALIGNMENT_0 = NODE_PLACEMENT_BK_FIXED_ALIGNMENT;
  FEEDBACK_EDGES_0 = FEEDBACK_EDGES;
  LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_0 = LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS;
  NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING_0 = NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING;
  EDGE_ROUTING_SELF_LOOP_PLACEMENT_0 = EDGE_ROUTING_SELF_LOOP_PLACEMENT;
  CONTENT_ALIGNMENT_0 = CONTENT_ALIGNMENT;
  NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_0 = NODE_PLACEMENT_BK_EDGE_STRAIGHTENING;
  COMPACTION_POST_COMPACTION_STRATEGY_0 = COMPACTION_POST_COMPACTION_STRATEGY;
  COMPACTION_POST_COMPACTION_CONSTRAINTS_0 = COMPACTION_POST_COMPACTION_CONSTRAINTS;
  COMPACTION_CONNECTED_COMPONENTS_0 = COMPACTION_CONNECTED_COMPONENTS;
  HIGH_DEGREE_NODES_TREATMENT_0 = HIGH_DEGREE_NODES_TREATMENT;
  HIGH_DEGREE_NODES_THRESHOLD_0 = HIGH_DEGREE_NODES_THRESHOLD;
  HIGH_DEGREE_NODES_TREE_HEIGHT_0 = HIGH_DEGREE_NODES_TREE_HEIGHT;
  NODE_SIZE_MINIMUM = NODE_SIZE_MINIMUM_1;
  JUNCTION_POINTS = JUNCTION_POINTS_0;
  EDGE_THICKNESS_0 = EDGE_THICKNESS_1;
  EDGE_LABELS_PLACEMENT = EDGE_LABELS_PLACEMENT_0;
  EDGE_LABELS_INLINE = EDGE_LABELS_INLINE_0;
  CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS_0 = CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS;
  PORT_INDEX = PORT_INDEX_0;
  COMMENT_BOX = COMMENT_BOX_0;
  HYPERNODE = HYPERNODE_0;
  PORT_ANCHOR = PORT_ANCHOR_0;
  PARTITIONING_ACTIVATE = PARTITIONING_ACTIVATE_0;
  PARTITIONING_PARTITION = PARTITIONING_PARTITION_0;
  LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH_0 = LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH;
  LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR_0 = LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR;
  POSITION = POSITION_2;
  NORTH_OR_SOUTH_PORT_0 = NORTH_OR_SOUTH_PORT;
  LAYERING_NODE_PROMOTION_MAX_ITERATIONS_0 = LAYERING_NODE_PROMOTION_MAX_ITERATIONS;
  EDGE_LABELS_SIDE_SELECTION_0 = EDGE_LABELS_SIDE_SELECTION;
  EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_0 = EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY;
  MARGINS = MARGINS_0;
  LAYERING_COFFMAN_GRAHAM_LAYER_BOUND_0 = LAYERING_COFFMAN_GRAHAM_LAYER_BOUND;
  NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_0 = NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES;
  SPACING_PORTS_SURROUNDING = SPACING_PORTS_SURROUNDING_0;
  DIRECTION_CONGRUENCY_0 = DIRECTION_CONGRUENCY;
  PORT_SORTING_STRATEGY_0 = PORT_SORTING_STRATEGY;
}

function $apply_22(registry){
  $register(registry, new LayoutAlgorithmData($supportedFeatures($category($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.layered'), 'ELK Layered'), 'Layer-based algorithm provided by the Eclipse Layout Kernel. Arranges as many edges as possible into one direction by placing nodes into subsequent layers. This implementation supports different routing styles (straight, orthogonal, splines); if orthogonal routing is selected, arbitrary port constraints are respected, thus enabling the layout of block diagrams such as actor-oriented models or circuit schematics. Furthermore, full layout of compound graphs with cross-hierarchy edges is supported when the respective option is activated on the top level.'), new LayeredOptions$LayeredFactory), 'org.eclipse.elk.layered'), of_1(($clinit_GraphFeature() , SELF_LOOPS_0), stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_graph_properties_GraphFeature_2_classLit, 1), $intern_38, 238, 0, [INSIDE_SELF_LOOPS, MULTI_EDGES, EDGE_LABELS, PORTS_1, COMPOUND, CLUSTERS])))));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.componentComponent', $getDefault(SPACING_COMPONENT_COMPONENT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.edgeEdge', $getDefault(SPACING_EDGE_EDGE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.edgeLabel', $getDefault(SPACING_EDGE_LABEL_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.edgeNode', $getDefault(SPACING_EDGE_NODE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.labelLabel', $getDefault(SPACING_LABEL_LABEL));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.labelPort', $getDefault(SPACING_LABEL_PORT));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.labelNode', $getDefault(SPACING_LABEL_NODE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.nodeNode', 20);
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.portPort', $getDefault(SPACING_PORT_PORT));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.individualOverride', $getDefault(SPACING_INDIVIDUAL_OVERRIDE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.spacing.edgeEdgeBetweenLayers', $getDefault(SPACING_EDGE_EDGE_BETWEEN_LAYERS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.spacing.edgeNodeBetweenLayers', $getDefault(SPACING_EDGE_NODE_BETWEEN_LAYERS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.spacing.nodeNodeBetweenLayers', $getDefault(SPACING_NODE_NODE_BETWEEN_LAYERS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.priority', valueOf_4(0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.priority.direction', $getDefault(PRIORITY_DIRECTION_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.priority.shortness', $getDefault(PRIORITY_SHORTNESS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.priority.straightness', $getDefault(PRIORITY_STRAIGHTNESS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.strategy', $getDefault(WRAPPING_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.additionalEdgeSpacing', $getDefault(WRAPPING_ADDITIONAL_EDGE_SPACING_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.correctionFactor', $getDefault(WRAPPING_CORRECTION_FACTOR_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.cutting.strategy', $getDefault(WRAPPING_CUTTING_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.cutting.cuts', $getDefault(WRAPPING_CUTTING_CUTS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.cutting.msd.freedom', $getDefault(WRAPPING_CUTTING_MSD_FREEDOM_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.validify.strategy', $getDefault(WRAPPING_VALIDIFY_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.validify.forbiddenIndices', $getDefault(WRAPPING_VALIDIFY_FORBIDDEN_INDICES_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.multiEdge.improveCuts', $getDefault(WRAPPING_MULTI_EDGE_IMPROVE_CUTS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.multiEdge.distancePenalty', $getDefault(WRAPPING_MULTI_EDGE_DISTANCE_PENALTY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.wrapping.multiEdge.improveWrappedEdges', $getDefault(WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.nodePlacement.networkSimplex.nodeFlexibility', $getDefault(NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.nodePlacement.networkSimplex.nodeFlexibility.default', $getDefault(NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.edgeRouting.splines.mode', $getDefault(EDGE_ROUTING_SPLINES_MODE_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.edgeRouting.splines.sloppy.layerSpacingFactor', $getDefault(EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.padding', PADDING_DEFAULT_0);
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.edgeRouting', EDGE_ROUTING_DEFAULT);
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.port.borderOffset', 0);
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.randomSeed', valueOf_4(1));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.aspectRatio', $intern_105);
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.noLayout', $getDefault(NO_LAYOUT));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.portConstraints', $getDefault(PORT_CONSTRAINTS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.port.side', $getDefault(PORT_SIDE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.debugMode', $getDefault(DEBUG_MODE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.alignment', $getDefault(ALIGNMENT));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.hierarchyHandling', $getDefault(HIERARCHY_HANDLING));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.separateConnectedComponents', ($clinit_Boolean() , $clinit_Boolean() , true));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.insideSelfLoops.activate', $getDefault(INSIDE_SELF_LOOPS_ACTIVATE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.insideSelfLoops.yo', $getDefault(INSIDE_SELF_LOOPS_YO));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.nodeSize.constraints', $getDefault(NODE_SIZE_CONSTRAINTS));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.nodeSize.options', $getDefault(NODE_SIZE_OPTIONS));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.direction', DIRECTION_DEFAULT);
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.nodeLabels.placement', $getDefault(NODE_LABELS_PLACEMENT));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.portLabels.placement', $getDefault(PORT_LABELS_PLACEMENT));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.portLabels.nextToPortIfPossible', $getDefault(PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.portAlignment.default', PORT_ALIGNMENT_DEFAULT_DEFAULT);
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.portAlignment.north', $getDefault(PORT_ALIGNMENT_NORTH));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.portAlignment.south', $getDefault(PORT_ALIGNMENT_SOUTH));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.portAlignment.west', $getDefault(PORT_ALIGNMENT_WEST));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.portAlignment.east', $getDefault(PORT_ALIGNMENT_EAST));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.unnecessaryBendpoints', $getDefault(UNNECESSARY_BENDPOINTS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.layering.strategy', $getDefault(LAYERING_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.layering.nodePromotion.strategy', $getDefault(LAYERING_NODE_PROMOTION_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.thoroughness', $getDefault(THOROUGHNESS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.layering.layerConstraint', $getDefault(LAYERING_LAYER_CONSTRAINT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.cycleBreaking.strategy', $getDefault(CYCLE_BREAKING_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.crossingMinimization.strategy', $getDefault(CROSSING_MINIMIZATION_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.crossingMinimization.greedySwitch.activationThreshold', $getDefault(CROSSING_MINIMIZATION_GREEDY_SWITCH_ACTIVATION_THRESHOLD_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.crossingMinimization.greedySwitch.type', $getDefault(CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.crossingMinimization.semiInteractive', $getDefault(CROSSING_MINIMIZATION_SEMI_INTERACTIVE_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.mergeEdges', $getDefault(MERGE_EDGES_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.mergeHierarchyEdges', $getDefault(MERGE_HIERARCHY_EDGES_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.interactiveReferencePoint', $getDefault(INTERACTIVE_REFERENCE_POINT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.nodePlacement.strategy', $getDefault(NODE_PLACEMENT_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.nodePlacement.bk.fixedAlignment', $getDefault(NODE_PLACEMENT_BK_FIXED_ALIGNMENT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.feedbackEdges', $getDefault(FEEDBACK_EDGES_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.layering.wideNodesOnMultipleLayers', $getDefault(LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.nodePlacement.linearSegments.deflectionDampening', $getDefault(NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.edgeRouting.selfLoopPlacement', $getDefault(EDGE_ROUTING_SELF_LOOP_PLACEMENT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.contentAlignment', $getDefault(CONTENT_ALIGNMENT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.nodePlacement.bk.edgeStraightening', $getDefault(NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.compaction.postCompaction.strategy', $getDefault(COMPACTION_POST_COMPACTION_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.compaction.postCompaction.constraints', $getDefault(COMPACTION_POST_COMPACTION_CONSTRAINTS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.compaction.connectedComponents', $getDefault(COMPACTION_CONNECTED_COMPONENTS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.highDegreeNodes.treatment', $getDefault(HIGH_DEGREE_NODES_TREATMENT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.highDegreeNodes.threshold', $getDefault(HIGH_DEGREE_NODES_THRESHOLD_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.highDegreeNodes.treeHeight', $getDefault(HIGH_DEGREE_NODES_TREE_HEIGHT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.nodeSize.minimum', $getDefault(NODE_SIZE_MINIMUM));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.junctionPoints', $getDefault(JUNCTION_POINTS));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.edge.thickness', $getDefault(EDGE_THICKNESS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.edgeLabels.placement', $getDefault(EDGE_LABELS_PLACEMENT));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.edgeLabels.inline', $getDefault(EDGE_LABELS_INLINE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.crossingMinimization.hierarchicalSweepiness', $getDefault(CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.port.index', $getDefault(PORT_INDEX));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.commentBox', $getDefault(COMMENT_BOX));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.hypernode', $getDefault(HYPERNODE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.port.anchor', $getDefault(PORT_ANCHOR));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.partitioning.activate', $getDefault(PARTITIONING_ACTIVATE));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.partitioning.partition', $getDefault(PARTITIONING_PARTITION));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.layering.minWidth.upperBoundOnWidth', $getDefault(LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.layering.minWidth.upperLayerEstimationScalingFactor', $getDefault(LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.position', $getDefault(POSITION));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.northOrSouthPort', $getDefault(NORTH_OR_SOUTH_PORT_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.layering.nodePromotion.maxIterations', $getDefault(LAYERING_NODE_PROMOTION_MAX_ITERATIONS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.edgeLabels.sideSelection', $getDefault(EDGE_LABELS_SIDE_SELECTION_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.edgeLabels.centerLabelPlacementStrategy', $getDefault(EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.margins', $getDefault(MARGINS));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.layering.coffmanGraham.layerBound', $getDefault(LAYERING_COFFMAN_GRAHAM_LAYER_BOUND_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.nodePlacement.favorStraightEdges', $getDefault(NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.spacing.portsSurrounding', $getDefault(SPACING_PORTS_SURROUNDING));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.directionCongruency', $getDefault(DIRECTION_CONGRUENCY_0));
  $addOptionSupport(registry, 'org.eclipse.elk.layered', 'org.eclipse.elk.layered.portSortingStrategy', $getDefault(PORT_SORTING_STRATEGY_0));
}

function LayeredOptions(){
  $clinit_LayeredOptions();
}

defineClass(912, 1, $intern_92, LayeredOptions);
_.apply_3 = function apply_117(registry){
  $apply_22(registry);
}
;
var ALIGNMENT, ASPECT_RATIO_1, COMMENT_BOX, COMPACTION_CONNECTED_COMPONENTS_0, COMPACTION_POST_COMPACTION_CONSTRAINTS_0, COMPACTION_POST_COMPACTION_STRATEGY_0, CONTENT_ALIGNMENT_0, CROSSING_MINIMIZATION_GREEDY_SWITCH_ACTIVATION_THRESHOLD_0, CROSSING_MINIMIZATION_GREEDY_SWITCH_TYPE_0, CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS_0, CROSSING_MINIMIZATION_SEMI_INTERACTIVE_0, CROSSING_MINIMIZATION_STRATEGY_0, CYCLE_BREAKING_STRATEGY_0, DEBUG_MODE, DIRECTION, DIRECTION_CONGRUENCY_0, DIRECTION_DEFAULT, EDGE_LABELS_CENTER_LABEL_PLACEMENT_STRATEGY_0, EDGE_LABELS_INLINE, EDGE_LABELS_PLACEMENT, EDGE_LABELS_SIDE_SELECTION_0, EDGE_ROUTING, EDGE_ROUTING_DEFAULT, EDGE_ROUTING_SELF_LOOP_PLACEMENT_0, EDGE_ROUTING_SPLINES_MODE_0, EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_0, EDGE_THICKNESS_0, FEEDBACK_EDGES_0, HIERARCHY_HANDLING, HIGH_DEGREE_NODES_THRESHOLD_0, HIGH_DEGREE_NODES_TREATMENT_0, HIGH_DEGREE_NODES_TREE_HEIGHT_0, HYPERNODE, INSIDE_SELF_LOOPS_ACTIVATE, INSIDE_SELF_LOOPS_YO, INTERACTIVE_REFERENCE_POINT_0, JUNCTION_POINTS, LAYERING_COFFMAN_GRAHAM_LAYER_BOUND_0, LAYERING_LAYER_CONSTRAINT_0, LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH_0, LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR_0, LAYERING_NODE_PROMOTION_MAX_ITERATIONS_0, LAYERING_NODE_PROMOTION_STRATEGY_0, LAYERING_STRATEGY_0, LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_0, MARGINS, MERGE_EDGES_0, MERGE_HIERARCHY_EDGES_0, NODE_LABELS_PLACEMENT, NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_0, NODE_PLACEMENT_BK_FIXED_ALIGNMENT_0, NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_0, NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING_0, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_0, NODE_PLACEMENT_STRATEGY_0, NODE_SIZE_CONSTRAINTS, NODE_SIZE_MINIMUM, NODE_SIZE_OPTIONS, NORTH_OR_SOUTH_PORT_0, NO_LAYOUT, PADDING_1, PADDING_DEFAULT_0, PARTITIONING_ACTIVATE, PARTITIONING_PARTITION, PORT_ALIGNMENT_DEFAULT_DEFAULT, PORT_ALIGNMENT_EAST, PORT_ALIGNMENT_NORTH, PORT_ALIGNMENT_SOUTH, PORT_ALIGNMENT_WEST, PORT_ANCHOR, PORT_BORDER_OFFSET, PORT_CONSTRAINTS_0, PORT_INDEX, PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE, PORT_LABELS_PLACEMENT, PORT_SIDE, PORT_SORTING_STRATEGY_0, POSITION, PRIORITY_0, PRIORITY_DIRECTION_0, PRIORITY_SHORTNESS_0, PRIORITY_STRAIGHTNESS_0, RANDOM_SEED_0, SEPARATE_CONNECTED_COMPONENTS_0, SPACING_COMPONENT_COMPONENT_0, SPACING_EDGE_EDGE, SPACING_EDGE_EDGE_BETWEEN_LAYERS_0, SPACING_EDGE_LABEL_0, SPACING_EDGE_NODE, SPACING_EDGE_NODE_BETWEEN_LAYERS_0, SPACING_INDIVIDUAL_OVERRIDE, SPACING_LABEL_LABEL, SPACING_LABEL_NODE, SPACING_LABEL_PORT, SPACING_NODE_NODE_0, SPACING_NODE_NODE_BETWEEN_LAYERS_0, SPACING_PORTS_SURROUNDING, SPACING_PORT_PORT, THOROUGHNESS_0, UNNECESSARY_BENDPOINTS_0, WRAPPING_ADDITIONAL_EDGE_SPACING_0, WRAPPING_CORRECTION_FACTOR_0, WRAPPING_CUTTING_CUTS_0, WRAPPING_CUTTING_MSD_FREEDOM_0, WRAPPING_CUTTING_STRATEGY_0, WRAPPING_MULTI_EDGE_DISTANCE_PENALTY_0, WRAPPING_MULTI_EDGE_IMPROVE_CUTS_0, WRAPPING_MULTI_EDGE_IMPROVE_WRAPPED_EDGES_0, WRAPPING_STRATEGY_0, WRAPPING_VALIDIFY_FORBIDDEN_INDICES_0, WRAPPING_VALIDIFY_STRATEGY_0;
var Lorg_eclipse_elk_alg_layered_options_LayeredOptions_2_classLit = createForClass('org.eclipse.elk.alg.layered.options', 'LayeredOptions', 912);
function LayeredOptions$LayeredFactory(){
}

defineClass(913, 1, {}, LayeredOptions$LayeredFactory);
_.create_0 = function create_11(){
  var provider;
  return provider = new LayeredLayoutProvider , provider;
}
;
_.destroy = function destroy_2(obj){
}
;
var Lorg_eclipse_elk_alg_layered_options_LayeredOptions$LayeredFactory_2_classLit = createForClass('org.eclipse.elk.alg.layered.options', 'LayeredOptions/LayeredFactory', 913);
function $clinit_LayeringStrategy(){
  $clinit_LayeringStrategy = emptyMethod;
  NETWORK_SIMPLEX = new LayeringStrategy('NETWORK_SIMPLEX', 0);
  LONGEST_PATH = new LayeringStrategy('LONGEST_PATH', 1);
  COFFMAN_GRAHAM = new LayeringStrategy('COFFMAN_GRAHAM', 2);
  INTERACTIVE_3 = new LayeringStrategy('INTERACTIVE', 3);
  STRETCH_WIDTH = new LayeringStrategy('STRETCH_WIDTH', 4);
  MIN_WIDTH = new LayeringStrategy('MIN_WIDTH', 5);
}

function $create_5(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new NetworkSimplexLayerer;
    case 1:
      return new LongestPathLayerer;
    case 2:
      return new CoffmanGrahamLayerer;
    case 3:
      return new InteractiveLayerer;
    case 4:
      return new StretchWidthLayerer;
    case 5:
      return new MinWidthLayerer;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layerer ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function LayeringStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_49(name_0){
  $clinit_LayeringStrategy();
  return valueOf(($clinit_LayeringStrategy$Map() , $MAP_37), name_0);
}

function values_45(){
  $clinit_LayeringStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_LayeringStrategy_2_classLit, 1), $intern_38, 300, 0, [NETWORK_SIMPLEX, LONGEST_PATH, COFFMAN_GRAHAM, INTERACTIVE_3, STRETCH_WIDTH, MIN_WIDTH]);
}

defineClass(300, 22, {3:1, 34:1, 22:1, 300:1, 230:1, 231:1}, LayeringStrategy);
_.create_1 = function create_13(){
  return $create_5(this);
}
;
_.create_2 = function create_12(){
  return $create_5(this);
}
;
var COFFMAN_GRAHAM, INTERACTIVE_3, LONGEST_PATH, MIN_WIDTH, NETWORK_SIMPLEX, STRETCH_WIDTH;
var Lorg_eclipse_elk_alg_layered_options_LayeringStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'LayeringStrategy', 300, Ljava_lang_Enum_2_classLit, values_45, valueOf_49);
function $clinit_LayeringStrategy$Map(){
  $clinit_LayeringStrategy$Map = emptyMethod;
  $MAP_37 = createValueOfMap(($clinit_LayeringStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_LayeringStrategy_2_classLit, 1), $intern_38, 300, 0, [NETWORK_SIMPLEX, LONGEST_PATH, COFFMAN_GRAHAM, INTERACTIVE_3, STRETCH_WIDTH, MIN_WIDTH])));
}

var $MAP_37;
function $clinit_NodeFlexibility(){
  $clinit_NodeFlexibility = emptyMethod;
  NONE_5 = new NodeFlexibility('NONE', 0);
  PORT_POSITION = new NodeFlexibility('PORT_POSITION', 1);
  NODE_SIZE_WHERE_SPACE_PERMITS = new NodeFlexibility('NODE_SIZE_WHERE_SPACE_PERMITS', 2);
  NODE_SIZE = new NodeFlexibility('NODE_SIZE', 3);
}

function $isFlexibleSizeWhereSpacePermits(this$static){
  return this$static == NODE_SIZE_WHERE_SPACE_PERMITS || this$static == NODE_SIZE;
}

function NodeFlexibility(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function getNodeFlexibility(lNode){
  $clinit_NodeFlexibility();
  var nf;
  (!lNode.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):lNode.propertyMap).containsKey(($clinit_LayeredOptions() , NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0))?(nf = castTo($getProperty(lNode, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0), 184)):(nf = castTo($getProperty($getGraph(lNode), NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_0), 184));
  return nf;
}

function valueOf_50(name_0){
  $clinit_NodeFlexibility();
  return valueOf(($clinit_NodeFlexibility$Map() , $MAP_38), name_0);
}

function values_46(){
  $clinit_NodeFlexibility();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_NodeFlexibility_2_classLit, 1), $intern_38, 184, 0, [NONE_5, PORT_POSITION, NODE_SIZE_WHERE_SPACE_PERMITS, NODE_SIZE]);
}

defineClass(184, 22, {3:1, 34:1, 22:1, 184:1}, NodeFlexibility);
var NODE_SIZE, NODE_SIZE_WHERE_SPACE_PERMITS, NONE_5, PORT_POSITION;
var Lorg_eclipse_elk_alg_layered_options_NodeFlexibility_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'NodeFlexibility', 184, Ljava_lang_Enum_2_classLit, values_46, valueOf_50);
function $clinit_NodeFlexibility$Map(){
  $clinit_NodeFlexibility$Map = emptyMethod;
  $MAP_38 = createValueOfMap(($clinit_NodeFlexibility() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_NodeFlexibility_2_classLit, 1), $intern_38, 184, 0, [NONE_5, PORT_POSITION, NODE_SIZE_WHERE_SPACE_PERMITS, NODE_SIZE])));
}

var $MAP_38;
function $clinit_NodePlacementStrategy(){
  $clinit_NodePlacementStrategy = emptyMethod;
  SIMPLE = new NodePlacementStrategy('SIMPLE', 0);
  INTERACTIVE_4 = new NodePlacementStrategy('INTERACTIVE', 1);
  LINEAR_SEGMENTS = new NodePlacementStrategy('LINEAR_SEGMENTS', 2);
  BRANDES_KOEPF = new NodePlacementStrategy('BRANDES_KOEPF', 3);
  NETWORK_SIMPLEX_0 = new NodePlacementStrategy('NETWORK_SIMPLEX', 4);
}

function $create_6(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new SimpleNodePlacer;
    case 1:
      return new InteractiveNodePlacer;
    case 2:
      return new LinearSegmentsNodePlacer;
    case 3:
      return new BKNodePlacer;
    case 4:
      return new NetworkSimplexPlacer;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the node placer ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function NodePlacementStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_51(name_0){
  $clinit_NodePlacementStrategy();
  return valueOf(($clinit_NodePlacementStrategy$Map() , $MAP_39), name_0);
}

function values_47(){
  $clinit_NodePlacementStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_NodePlacementStrategy_2_classLit, 1), $intern_38, 301, 0, [SIMPLE, INTERACTIVE_4, LINEAR_SEGMENTS, BRANDES_KOEPF, NETWORK_SIMPLEX_0]);
}

defineClass(301, 22, {3:1, 34:1, 22:1, 301:1, 230:1, 231:1}, NodePlacementStrategy);
_.create_1 = function create_15(){
  return $create_6(this);
}
;
_.create_2 = function create_14(){
  return $create_6(this);
}
;
var BRANDES_KOEPF, INTERACTIVE_4, LINEAR_SEGMENTS, NETWORK_SIMPLEX_0, SIMPLE;
var Lorg_eclipse_elk_alg_layered_options_NodePlacementStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'NodePlacementStrategy', 301, Ljava_lang_Enum_2_classLit, values_47, valueOf_51);
function $clinit_NodePlacementStrategy$Map(){
  $clinit_NodePlacementStrategy$Map = emptyMethod;
  $MAP_39 = createValueOfMap(($clinit_NodePlacementStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_NodePlacementStrategy_2_classLit, 1), $intern_38, 301, 0, [SIMPLE, INTERACTIVE_4, LINEAR_SEGMENTS, BRANDES_KOEPF, NETWORK_SIMPLEX_0])));
}

var $MAP_39;
function $clinit_NodePromotionStrategy(){
  $clinit_NodePromotionStrategy = emptyMethod;
  NONE_6 = new NodePromotionStrategy('NONE', 0);
  NIKOLOV = new NodePromotionStrategy('NIKOLOV', 1);
  NIKOLOV_PIXEL = new NodePromotionStrategy('NIKOLOV_PIXEL', 2);
  NIKOLOV_IMPROVED = new NodePromotionStrategy('NIKOLOV_IMPROVED', 3);
  NIKOLOV_IMPROVED_PIXEL = new NodePromotionStrategy('NIKOLOV_IMPROVED_PIXEL', 4);
  DUMMYNODE_PERCENTAGE = new NodePromotionStrategy('DUMMYNODE_PERCENTAGE', 5);
  NODECOUNT_PERCENTAGE = new NodePromotionStrategy('NODECOUNT_PERCENTAGE', 6);
  NO_BOUNDARY = new NodePromotionStrategy('NO_BOUNDARY', 7);
}

function NodePromotionStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_52(name_0){
  $clinit_NodePromotionStrategy();
  return valueOf(($clinit_NodePromotionStrategy$Map() , $MAP_40), name_0);
}

function values_48(){
  $clinit_NodePromotionStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_NodePromotionStrategy_2_classLit, 1), $intern_38, 251, 0, [NONE_6, NIKOLOV, NIKOLOV_PIXEL, NIKOLOV_IMPROVED, NIKOLOV_IMPROVED_PIXEL, DUMMYNODE_PERCENTAGE, NODECOUNT_PERCENTAGE, NO_BOUNDARY]);
}

defineClass(251, 22, {3:1, 34:1, 22:1, 251:1}, NodePromotionStrategy);
var DUMMYNODE_PERCENTAGE, NIKOLOV, NIKOLOV_IMPROVED, NIKOLOV_IMPROVED_PIXEL, NIKOLOV_PIXEL, NODECOUNT_PERCENTAGE, NONE_6, NO_BOUNDARY;
var Lorg_eclipse_elk_alg_layered_options_NodePromotionStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'NodePromotionStrategy', 251, Ljava_lang_Enum_2_classLit, values_48, valueOf_52);
function $clinit_NodePromotionStrategy$Map(){
  $clinit_NodePromotionStrategy$Map = emptyMethod;
  $MAP_40 = createValueOfMap(($clinit_NodePromotionStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_NodePromotionStrategy_2_classLit, 1), $intern_38, 251, 0, [NONE_6, NIKOLOV, NIKOLOV_PIXEL, NIKOLOV_IMPROVED, NIKOLOV_IMPROVED_PIXEL, DUMMYNODE_PERCENTAGE, NODECOUNT_PERCENTAGE, NO_BOUNDARY])));
}

var $MAP_40;
function $clinit_PortSortingStrategy(){
  $clinit_PortSortingStrategy = emptyMethod;
  INPUT_ORDER = new PortSortingStrategy('INPUT_ORDER', 0);
  PORT_DEGREE = new PortSortingStrategy('PORT_DEGREE', 1);
}

function PortSortingStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_53(name_0){
  $clinit_PortSortingStrategy();
  return valueOf(($clinit_PortSortingStrategy$Map() , $MAP_41), name_0);
}

function values_49(){
  $clinit_PortSortingStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_PortSortingStrategy_2_classLit, 1), $intern_38, 399, 0, [INPUT_ORDER, PORT_DEGREE]);
}

defineClass(399, 22, {3:1, 34:1, 22:1, 399:1}, PortSortingStrategy);
var INPUT_ORDER, PORT_DEGREE;
var Lorg_eclipse_elk_alg_layered_options_PortSortingStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'PortSortingStrategy', 399, Ljava_lang_Enum_2_classLit, values_49, valueOf_53);
function $clinit_PortSortingStrategy$Map(){
  $clinit_PortSortingStrategy$Map = emptyMethod;
  $MAP_41 = createValueOfMap(($clinit_PortSortingStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_PortSortingStrategy_2_classLit, 1), $intern_38, 399, 0, [INPUT_ORDER, PORT_DEGREE])));
}

var $MAP_41;
function $clinit_PortType(){
  $clinit_PortType = emptyMethod;
  UNDEFINED_0 = new PortType('UNDEFINED', 0);
  INPUT = new PortType('INPUT', 1);
  OUTPUT = new PortType('OUTPUT', 2);
}

function PortType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_54(name_0){
  $clinit_PortType();
  return valueOf(($clinit_PortType$Map() , $MAP_42), name_0);
}

function values_50(){
  $clinit_PortType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_PortType_2_classLit, 1), $intern_38, 427, 0, [UNDEFINED_0, INPUT, OUTPUT]);
}

defineClass(427, 22, {3:1, 34:1, 22:1, 427:1}, PortType);
var INPUT, OUTPUT, UNDEFINED_0;
var Lorg_eclipse_elk_alg_layered_options_PortType_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'PortType', 427, Ljava_lang_Enum_2_classLit, values_50, valueOf_54);
function $clinit_PortType$Map(){
  $clinit_PortType$Map = emptyMethod;
  $MAP_42 = createValueOfMap(($clinit_PortType() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_PortType_2_classLit, 1), $intern_38, 427, 0, [UNDEFINED_0, INPUT, OUTPUT])));
}

var $MAP_42;
function $clinit_SelfLoopPlacement(){
  $clinit_SelfLoopPlacement = emptyMethod;
  EQUALLY_DISTRIBUTED = new SelfLoopPlacement('EQUALLY_DISTRIBUTED', 0);
  NORTH_STACKED = new SelfLoopPlacement('NORTH_STACKED', 1);
  NORTH_SEQUENCE = new SelfLoopPlacement('NORTH_SEQUENCE', 2);
}

function SelfLoopPlacement(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_55(name_0){
  $clinit_SelfLoopPlacement();
  return valueOf(($clinit_SelfLoopPlacement$Map() , $MAP_43), name_0);
}

function values_51(){
  $clinit_SelfLoopPlacement();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_SelfLoopPlacement_2_classLit, 1), $intern_38, 358, 0, [EQUALLY_DISTRIBUTED, NORTH_STACKED, NORTH_SEQUENCE]);
}

defineClass(358, 22, {3:1, 34:1, 22:1, 358:1}, SelfLoopPlacement);
var EQUALLY_DISTRIBUTED, NORTH_SEQUENCE, NORTH_STACKED;
var Lorg_eclipse_elk_alg_layered_options_SelfLoopPlacement_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'SelfLoopPlacement', 358, Ljava_lang_Enum_2_classLit, values_51, valueOf_55);
function $clinit_SelfLoopPlacement$Map(){
  $clinit_SelfLoopPlacement$Map = emptyMethod;
  $MAP_43 = createValueOfMap(($clinit_SelfLoopPlacement() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_SelfLoopPlacement_2_classLit, 1), $intern_38, 358, 0, [EQUALLY_DISTRIBUTED, NORTH_STACKED, NORTH_SEQUENCE])));
}

var $MAP_43;
function $getHorizontalSpacing(this$static, nt1, nt2){
  return $getLocalSpacing(this$static, nt1, nt2, this$static.nodeTypeSpacingOptionsHorizontal);
}

function $getLocalSpacing(this$static, nt1, nt2, nodeTypeSpacingMapping){
  var layoutOption;
  layoutOption = nodeTypeSpacingMapping[nt1.ordinal][nt2.ordinal];
  return checkNotNull_1(castToDouble($getProperty(this$static.graph_0, layoutOption)));
}

function $getLocalSpacing_0(n1, n2, nodeTypeSpacingMapping){
  var layoutOption, s1, s2, t1, t2;
  t1 = n1.type_0;
  t2 = n2.type_0;
  layoutOption = nodeTypeSpacingMapping[t1.ordinal][t2.ordinal];
  s1 = castToDouble(getIndividualOrDefault(n1, layoutOption));
  s2 = castToDouble(getIndividualOrDefault(n2, layoutOption));
  return $wnd.Math.max((checkCriticalNotNull(s1) , s1), (checkCriticalNotNull(s2) , s2));
}

function $getVerticalSpacing(this$static, nt1, nt2){
  return $getLocalSpacing(this$static, nt1, nt2, this$static.nodeTypeSpacingOptionsVertical);
}

function $getVerticalSpacing_0(this$static, n1, n2){
  return $getLocalSpacing_0(n1, n2, this$static.nodeTypeSpacingOptionsVertical);
}

function $nodeTypeSpacing(this$static, n1, n2, spacing){
  setCheck(this$static.nodeTypeSpacingOptionsVertical[n1.ordinal], n2.ordinal, spacing);
  setCheck(this$static.nodeTypeSpacingOptionsVertical[n2.ordinal], n1.ordinal, spacing);
}

function $nodeTypeSpacing_0(this$static, n1, n2, spacingVert, spacingHorz){
  setCheck(this$static.nodeTypeSpacingOptionsVertical[n1.ordinal], n2.ordinal, spacingVert);
  setCheck(this$static.nodeTypeSpacingOptionsVertical[n2.ordinal], n1.ordinal, spacingVert);
  setCheck(this$static.nodeTypeSpacingOptionsHorizontal[n1.ordinal], n2.ordinal, spacingHorz);
  setCheck(this$static.nodeTypeSpacingOptionsHorizontal[n2.ordinal], n1.ordinal, spacingHorz);
}

function $nodeTypeSpacing_1(this$static, nt, spacing){
  setCheck(this$static.nodeTypeSpacingOptionsVertical[nt.ordinal], nt.ordinal, spacing);
}

function $nodeTypeSpacing_2(this$static, nt, spacingVert, spacingHorz){
  setCheck(this$static.nodeTypeSpacingOptionsVertical[nt.ordinal], nt.ordinal, spacingVert);
  setCheck(this$static.nodeTypeSpacingOptionsHorizontal[nt.ordinal], nt.ordinal, spacingHorz);
}

function $precalculateNodeTypeSpacings(this$static){
  $nodeTypeSpacing_2(this$static, ($clinit_LNode$NodeType() , NORMAL), ($clinit_LayeredOptions() , SPACING_NODE_NODE_0), SPACING_NODE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_0(this$static, NORMAL, LONG_EDGE, SPACING_EDGE_NODE, SPACING_EDGE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing(this$static, NORMAL, NORTH_SOUTH_PORT, SPACING_EDGE_NODE);
  $nodeTypeSpacing(this$static, NORMAL, EXTERNAL_PORT, SPACING_EDGE_NODE);
  $nodeTypeSpacing_0(this$static, NORMAL, LABEL, SPACING_NODE_NODE_0, SPACING_NODE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_0(this$static, NORMAL, BIG_NODE, SPACING_NODE_NODE_0, SPACING_NODE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_2(this$static, LONG_EDGE, SPACING_EDGE_EDGE, SPACING_EDGE_EDGE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing(this$static, LONG_EDGE, NORTH_SOUTH_PORT, SPACING_EDGE_EDGE);
  $nodeTypeSpacing(this$static, LONG_EDGE, EXTERNAL_PORT, SPACING_EDGE_EDGE);
  $nodeTypeSpacing_0(this$static, LONG_EDGE, LABEL, SPACING_EDGE_NODE, SPACING_EDGE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_0(this$static, LONG_EDGE, BIG_NODE, SPACING_EDGE_NODE, SPACING_EDGE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_1(this$static, NORTH_SOUTH_PORT, SPACING_EDGE_EDGE);
  $nodeTypeSpacing(this$static, NORTH_SOUTH_PORT, EXTERNAL_PORT, SPACING_EDGE_EDGE);
  $nodeTypeSpacing(this$static, NORTH_SOUTH_PORT, LABEL, SPACING_LABEL_NODE);
  $nodeTypeSpacing(this$static, NORTH_SOUTH_PORT, BIG_NODE, SPACING_EDGE_NODE);
  $nodeTypeSpacing_1(this$static, EXTERNAL_PORT, SPACING_PORT_PORT);
  $nodeTypeSpacing(this$static, EXTERNAL_PORT, LABEL, SPACING_LABEL_PORT);
  $nodeTypeSpacing(this$static, EXTERNAL_PORT, BIG_NODE, SPACING_PORT_PORT);
  $nodeTypeSpacing_2(this$static, LABEL, SPACING_EDGE_EDGE, SPACING_EDGE_EDGE);
  $nodeTypeSpacing(this$static, LABEL, BIG_NODE, SPACING_EDGE_NODE);
  $nodeTypeSpacing_2(this$static, BIG_NODE, SPACING_NODE_NODE_0, SPACING_NODE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_2(this$static, BREAKING_POINT, SPACING_EDGE_EDGE, SPACING_EDGE_EDGE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_0(this$static, BREAKING_POINT, NORMAL, SPACING_EDGE_NODE, SPACING_EDGE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_0(this$static, BREAKING_POINT, LABEL, SPACING_EDGE_NODE, SPACING_EDGE_NODE_BETWEEN_LAYERS_0);
  $nodeTypeSpacing_0(this$static, BREAKING_POINT, LONG_EDGE, SPACING_EDGE_NODE, SPACING_EDGE_NODE_BETWEEN_LAYERS_0);
}

function Spacings(graph){
  var n;
  this.graph_0 = graph;
  n = ($clinit_LNode$NodeType() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_graph_LNode$NodeType_2_classLit, 1), $intern_38, 243, 0, [NORMAL, LONG_EDGE, EXTERNAL_PORT, NORTH_SOUTH_PORT, LABEL, BIG_NODE, BREAKING_POINT])).length;
  this.nodeTypeSpacingOptionsHorizontal = initMultidimensionalArray(Lorg_eclipse_elk_graph_properties_IProperty_2_classLit, [$intern_33, $intern_116], [638, 169], 0, [n, n], 2);
  this.nodeTypeSpacingOptionsVertical = initMultidimensionalArray(Lorg_eclipse_elk_graph_properties_IProperty_2_classLit, [$intern_33, $intern_116], [638, 169], 0, [n, n], 2);
  $precalculateNodeTypeSpacings(this);
}

function getIndividualOrDefault(node, property){
  var individualSpacings, result;
  result = null;
  if ($hasProperty(node, ($clinit_LayeredOptions() , SPACING_INDIVIDUAL_OVERRIDE))) {
    individualSpacings = castTo($getProperty(node, SPACING_INDIVIDUAL_OVERRIDE), 94);
    individualSpacings.hasProperty(property) && (result = individualSpacings.getProperty(property));
  }
  result == null && (result = $getProperty($getGraph(node), property));
  return result;
}

defineClass(277, 1, {277:1}, Spacings);
var Lorg_eclipse_elk_alg_layered_options_Spacings_2_classLit = createForClass('org.eclipse.elk.alg.layered.options', 'Spacings', 277);
function $clinit_SplineRoutingMode(){
  $clinit_SplineRoutingMode = emptyMethod;
  CONSERVATIVE = new SplineRoutingMode('CONSERVATIVE', 0);
  CONSERVATIVE_SOFT = new SplineRoutingMode('CONSERVATIVE_SOFT', 1);
  SLOPPY = new SplineRoutingMode('SLOPPY', 2);
}

function SplineRoutingMode(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_56(name_0){
  $clinit_SplineRoutingMode();
  return valueOf(($clinit_SplineRoutingMode$Map() , $MAP_44), name_0);
}

function values_52(){
  $clinit_SplineRoutingMode();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_SplineRoutingMode_2_classLit, 1), $intern_38, 327, 0, [CONSERVATIVE, CONSERVATIVE_SOFT, SLOPPY]);
}

defineClass(327, 22, {3:1, 34:1, 22:1, 327:1}, SplineRoutingMode);
var CONSERVATIVE, CONSERVATIVE_SOFT, SLOPPY;
var Lorg_eclipse_elk_alg_layered_options_SplineRoutingMode_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'SplineRoutingMode', 327, Ljava_lang_Enum_2_classLit, values_52, valueOf_56);
function $clinit_SplineRoutingMode$Map(){
  $clinit_SplineRoutingMode$Map = emptyMethod;
  $MAP_44 = createValueOfMap(($clinit_SplineRoutingMode() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_SplineRoutingMode_2_classLit, 1), $intern_38, 327, 0, [CONSERVATIVE, CONSERVATIVE_SOFT, SLOPPY])));
}

var $MAP_44;
function $clinit_ValidifyStrategy(){
  $clinit_ValidifyStrategy = emptyMethod;
  NO = new ValidifyStrategy('NO', 0);
  GREEDY_0 = new ValidifyStrategy('GREEDY', 1);
  LOOK_BACK = new ValidifyStrategy('LOOK_BACK', 2);
}

function ValidifyStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_57(name_0){
  $clinit_ValidifyStrategy();
  return valueOf(($clinit_ValidifyStrategy$Map() , $MAP_45), name_0);
}

function values_53(){
  $clinit_ValidifyStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_ValidifyStrategy_2_classLit, 1), $intern_38, 329, 0, [NO, GREEDY_0, LOOK_BACK]);
}

defineClass(329, 22, {3:1, 34:1, 22:1, 329:1}, ValidifyStrategy);
var GREEDY_0, LOOK_BACK, NO;
var Lorg_eclipse_elk_alg_layered_options_ValidifyStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'ValidifyStrategy', 329, Ljava_lang_Enum_2_classLit, values_53, valueOf_57);
function $clinit_ValidifyStrategy$Map(){
  $clinit_ValidifyStrategy$Map = emptyMethod;
  $MAP_45 = createValueOfMap(($clinit_ValidifyStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_ValidifyStrategy_2_classLit, 1), $intern_38, 329, 0, [NO, GREEDY_0, LOOK_BACK])));
}

var $MAP_45;
function $clinit_WideNodesStrategy(){
  $clinit_WideNodesStrategy = emptyMethod;
  OFF_0 = new WideNodesStrategy('OFF', 0);
  AGGRESSIVE = new WideNodesStrategy('AGGRESSIVE', 1);
  CAREFUL = new WideNodesStrategy('CAREFUL', 2);
}

function WideNodesStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_58(name_0){
  $clinit_WideNodesStrategy();
  return valueOf(($clinit_WideNodesStrategy$Map() , $MAP_46), name_0);
}

function values_54(){
  $clinit_WideNodesStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_WideNodesStrategy_2_classLit, 1), $intern_38, 401, 0, [OFF_0, AGGRESSIVE, CAREFUL]);
}

defineClass(401, 22, {3:1, 34:1, 22:1, 401:1}, WideNodesStrategy);
var AGGRESSIVE, CAREFUL, OFF_0;
var Lorg_eclipse_elk_alg_layered_options_WideNodesStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'WideNodesStrategy', 401, Ljava_lang_Enum_2_classLit, values_54, valueOf_58);
function $clinit_WideNodesStrategy$Map(){
  $clinit_WideNodesStrategy$Map = emptyMethod;
  $MAP_46 = createValueOfMap(($clinit_WideNodesStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_WideNodesStrategy_2_classLit, 1), $intern_38, 401, 0, [OFF_0, AGGRESSIVE, CAREFUL])));
}

var $MAP_46;
function $clinit_WrappingStrategy(){
  $clinit_WrappingStrategy = emptyMethod;
  OFF_1 = new WrappingStrategy('OFF', 0);
  SINGLE_EDGE = new WrappingStrategy('SINGLE_EDGE', 1);
  MULTI_EDGE = new WrappingStrategy('MULTI_EDGE', 2);
}

function WrappingStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_59(name_0){
  $clinit_WrappingStrategy();
  return valueOf(($clinit_WrappingStrategy$Map() , $MAP_47), name_0);
}

function values_55(){
  $clinit_WrappingStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_WrappingStrategy_2_classLit, 1), $intern_38, 359, 0, [OFF_1, SINGLE_EDGE, MULTI_EDGE]);
}

defineClass(359, 22, {3:1, 34:1, 22:1, 359:1}, WrappingStrategy);
var MULTI_EDGE, OFF_1, SINGLE_EDGE;
var Lorg_eclipse_elk_alg_layered_options_WrappingStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.layered.options', 'WrappingStrategy', 359, Ljava_lang_Enum_2_classLit, values_55, valueOf_59);
function $clinit_WrappingStrategy$Map(){
  $clinit_WrappingStrategy$Map = emptyMethod;
  $MAP_47 = createValueOfMap(($clinit_WrappingStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_options_WrappingStrategy_2_classLit, 1), $intern_38, 359, 0, [OFF_1, SINGLE_EDGE, MULTI_EDGE])));
}

var $MAP_47;
function $clinit_DepthFirstCycleBreaker(){
  $clinit_DepthFirstCycleBreaker = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION = $addAfter(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , REVERSED_EDGE_RESTORER));
}

function $dfs_3(this$static, n, index_0, rootId){
  var out, out$iterator, target;
  if (this$static.mark[n.id_0] != -1) {
    return;
  }
  this$static.mark[n.id_0] = index_0;
  this$static.root[n.id_0] = rootId;
  for (out$iterator = $iterator($getOutgoingEdges(n)); $hasNext_0(out$iterator);) {
    out = castTo($next_2(out$iterator), 16);
    if ($isSelfLoop(out)) {
      continue;
    }
    target = out.target.owner;
    $dfs_3(this$static, target, index_0 + 1, rootId);
  }
}

function $process_57(this$static, graph, monitor){
  var e, e$iterator, i, index_0, n, node, node$iterator, nodes, source, source$iterator, u, u$iterator, unprocessedNodeCount, v;
  $begin(monitor, 'Depth-first cycle removal', 1);
  nodes = graph.layerlessNodes;
  unprocessedNodeCount = nodes.array.length;
  this$static.mark = initUnidimensionalArray(I_classLit, $intern_49, 23, unprocessedNodeCount, 15, 1);
  fill_2(this$static.mark);
  this$static.root = initUnidimensionalArray(I_classLit, $intern_49, 23, unprocessedNodeCount, 15, 1);
  fill_2(this$static.root);
  index_0 = 0;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    node.id_0 = index_0;
    isEmpty_10($getIncomingEdges(node)) && $add_4(this$static.sources, node);
    ++index_0;
  }
  for (source$iterator = new ArrayList$1(this$static.sources); source$iterator.i < source$iterator.this$01.array.length;) {
    source = castTo($next_10(source$iterator), 9);
    $dfs_3(this$static, source, 0, source.id_0);
  }
  for (i = 0; i < this$static.mark.length; i++) {
    if (this$static.mark[i] == -1) {
      n = (checkCriticalElementIndex(i, nodes.array.length) , castTo(nodes.array[i], 9));
      $dfs_3(this$static, n, 0, n.id_0);
    }
  }
  for (u$iterator = new ArrayList$1(nodes); u$iterator.i < u$iterator.this$01.array.length;) {
    u = castTo($next_10(u$iterator), 9);
    for (e$iterator = new ArrayList$1(newArrayList($getOutgoingEdges(u))); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_10(e$iterator), 16);
      if ($isSelfLoop(e)) {
        continue;
      }
      v = $getOther_1(e, u);
      if (this$static.root[u.id_0] === this$static.root[v.id_0] && this$static.mark[v.id_0] < this$static.mark[u.id_0]) {
        $reverse_0(e, true);
        $setProperty_0(graph, ($clinit_InternalProperties_1() , CYCLIC), ($clinit_Boolean() , $clinit_Boolean() , true));
      }
    }
  }
  this$static.mark = null;
  this$static.root = null;
  this$static.sources.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $done_0(monitor);
}

function DepthFirstCycleBreaker(){
  $clinit_DepthFirstCycleBreaker();
  this.sources = new ArrayList;
}

defineClass(1257, 1, $intern_117, DepthFirstCycleBreaker);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration(graph){
  return castTo(graph, 32) , INTERMEDIATE_PROCESSING_CONFIGURATION;
}
;
_.process = function process_52(graph, monitor){
  $process_57(this, castTo(graph, 32), monitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIGURATION;
var Lorg_eclipse_elk_alg_layered_p1cycles_DepthFirstCycleBreaker_2_classLit = createForClass('org.eclipse.elk.alg.layered.p1cycles', 'DepthFirstCycleBreaker', 1257);
function $clinit_GreedyCycleBreaker(){
  $clinit_GreedyCycleBreaker = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION_0 = $addAfter(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , REVERSED_EDGE_RESTORER));
}

function $process_58(this$static, layeredGraph, monitor){
  var edge, edge$index, edge$iterator, edge$iterator0, edge$max, index_0, maxNode, maxNodes, maxOutflow, nextLeft, nextRight, node, node$iterator, node$iterator0, node$iterator1, nodes, outflow, outgoingEdges, port, port$index, port$iterator, port$max, ports, priority, random, shiftBase, sink, source, targetIx, unprocessedNodeCount;
  $begin(monitor, 'Greedy cycle removal', 1);
  nodes = layeredGraph.layerlessNodes;
  unprocessedNodeCount = nodes.array.length;
  this$static.indeg = initUnidimensionalArray(I_classLit, $intern_49, 23, unprocessedNodeCount, 15, 1);
  this$static.outdeg = initUnidimensionalArray(I_classLit, $intern_49, 23, unprocessedNodeCount, 15, 1);
  this$static.mark = initUnidimensionalArray(I_classLit, $intern_49, 23, unprocessedNodeCount, 15, 1);
  index_0 = 0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    node.id_0 = index_0;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      for (edge$iterator0 = new ArrayList$1(port.incomingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator0), 16);
        if (edge.source.owner == node) {
          continue;
        }
        priority = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_DIRECTION_0)), 21).value_0;
        this$static.indeg[index_0] += priority > 0?priority + 1:1;
      }
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        if (edge.target.owner == node) {
          continue;
        }
        priority = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_DIRECTION_0)), 21).value_0;
        this$static.outdeg[index_0] += priority > 0?priority + 1:1;
      }
    }
    this$static.outdeg[index_0] == 0?$add_7(this$static.sinks, node):this$static.indeg[index_0] == 0 && $add_7(this$static.sources, node);
    ++index_0;
  }
  nextRight = -1;
  nextLeft = 1;
  maxNodes = new ArrayList;
  random = castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , RANDOM_0)), 221);
  while (unprocessedNodeCount > 0) {
    while (this$static.sinks.size_0 != 0) {
      sink = castTo($removeFirst_0(this$static.sinks), 9);
      this$static.mark[sink.id_0] = nextRight--;
      $updateNeighbors(this$static, sink);
      --unprocessedNodeCount;
    }
    while (this$static.sources.size_0 != 0) {
      source = castTo($removeFirst_0(this$static.sources), 9);
      this$static.mark[source.id_0] = nextLeft++;
      $updateNeighbors(this$static, source);
      --unprocessedNodeCount;
    }
    if (unprocessedNodeCount > 0) {
      maxOutflow = $intern_43;
      for (node$iterator1 = new ArrayList$1(nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
        node = castTo($next_10(node$iterator1), 9);
        if (this$static.mark[node.id_0] == 0) {
          outflow = this$static.outdeg[node.id_0] - this$static.indeg[node.id_0];
          if (outflow >= maxOutflow) {
            if (outflow > maxOutflow) {
              maxNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
              maxOutflow = outflow;
            }
            maxNodes.array[maxNodes.array.length] = node;
          }
        }
      }
      maxNode = castTo($get_7(maxNodes, $nextInt(random, maxNodes.array.length)), 9);
      this$static.mark[maxNode.id_0] = nextLeft++;
      $updateNeighbors(this$static, maxNode);
      --unprocessedNodeCount;
    }
  }
  shiftBase = nodes.array.length + 1;
  for (index_0 = 0; index_0 < nodes.array.length; index_0++) {
    this$static.mark[index_0] < 0 && (this$static.mark[index_0] += shiftBase);
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    ports = castTo($toArray_2(node.ports, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LPort_2_classLit, $intern_112, 11, node.ports.array.length, 0, 1)), 639);
    for (port$index = 0 , port$max = ports.length; port$index < port$max; ++port$index) {
      port = ports[port$index];
      outgoingEdges = castTo($toArray_2(port.outgoingEdges, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LEdge_2_classLit, $intern_107, 16, port.outgoingEdges.array.length, 0, 1)), 101);
      for (edge$index = 0 , edge$max = outgoingEdges.length; edge$index < edge$max; ++edge$index) {
        edge = outgoingEdges[edge$index];
        targetIx = edge.target.owner.id_0;
        if (this$static.mark[node.id_0] > this$static.mark[targetIx]) {
          $reverse_0(edge, true);
          $setProperty_0(layeredGraph, CYCLIC, ($clinit_Boolean() , $clinit_Boolean() , true));
        }
      }
    }
  }
  this$static.indeg = null;
  this$static.outdeg = null;
  this$static.mark = null;
  $reset_0(this$static.sources);
  $reset_0(this$static.sinks);
  $done_0(monitor);
}

function $updateNeighbors(this$static, node){
  var connectedPort, edge, edge$iterator, endpoint, index_0, port, port$iterator, priority;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    for (edge$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(edge$iterator.firstIterator) || $hasNext_2(edge$iterator.secondIterator);) {
      edge = castTo($hasNext_2(edge$iterator.firstIterator)?$next_10(edge$iterator.firstIterator):$next_10(edge$iterator.secondIterator), 16);
      connectedPort = edge.source == port?edge.target:edge.source;
      endpoint = connectedPort.owner;
      if (node == endpoint) {
        continue;
      }
      priority = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_DIRECTION_0)), 21).value_0;
      priority < 0 && (priority = 0);
      index_0 = endpoint.id_0;
      if (this$static.mark[index_0] == 0) {
        if (edge.target == connectedPort) {
          this$static.indeg[index_0] -= priority + 1;
          this$static.indeg[index_0] <= 0 && this$static.outdeg[index_0] > 0 && $add_7(this$static.sources, endpoint);
        }
         else {
          this$static.outdeg[index_0] -= priority + 1;
          this$static.outdeg[index_0] <= 0 && this$static.indeg[index_0] > 0 && $add_7(this$static.sinks, endpoint);
        }
      }
    }
  }
}

function GreedyCycleBreaker(){
  $clinit_GreedyCycleBreaker();
  this.sources = new LinkedList;
  this.sinks = new LinkedList;
}

defineClass(1256, 1, $intern_117, GreedyCycleBreaker);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_0(graph){
  return castTo(graph, 32) , INTERMEDIATE_PROCESSING_CONFIGURATION_0;
}
;
_.process = function process_53(layeredGraph, monitor){
  $process_58(this, castTo(layeredGraph, 32), monitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIGURATION_0;
var Lorg_eclipse_elk_alg_layered_p1cycles_GreedyCycleBreaker_2_classLit = createForClass('org.eclipse.elk.alg.layered.p1cycles', 'GreedyCycleBreaker', 1256);
function $clinit_InteractiveCycleBreaker(){
  $clinit_InteractiveCycleBreaker = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION_1 = $addAfter($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , INTERACTIVE_EXTERNAL_PORT_POSITIONER)), P5_EDGE_ROUTING, REVERSED_EDGE_RESTORER);
}

function $findCycles(this$static, node1, revEdges){
  var edge, edge$iterator, node2, port, port$iterator;
  node1.id_0 = -1;
  for (port$iterator = $getPorts(node1, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 16);
      node2 = edge.target.owner;
      node1 != node2 && (node2.id_0 < 0?revEdges.add_1(edge):node2.id_0 > 0 && $findCycles(this$static, node2, revEdges));
    }
  }
  node1.id_0 = 0;
}

function $process_59(this$static, layeredGraph, monitor){
  var edge, edge$iterator, edge$iterator0, edge$iterator1, node, node$iterator, port, port$iterator, revEdges, source, source$iterator, sourcex, target, targetx;
  $begin(monitor, 'Interactive cycle breaking', 1);
  revEdges = new ArrayList;
  for (source$iterator = new ArrayList$1(layeredGraph.layerlessNodes); source$iterator.i < source$iterator.this$01.array.length;) {
    source = castTo($next_10(source$iterator), 9);
    source.id_0 = 1;
    sourcex = $getInteractiveReferencePoint(source).x_0;
    for (port$iterator = $getPorts(source, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 11);
      for (edge$iterator0 = new ArrayList$1(port.outgoingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator0), 16);
        target = edge.target.owner;
        if (target != source) {
          targetx = $getInteractiveReferencePoint(target).x_0;
          targetx < sourcex && (revEdges.array[revEdges.array.length] = edge , true);
        }
      }
    }
  }
  for (edge$iterator1 = new ArrayList$1(revEdges); edge$iterator1.i < edge$iterator1.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator1), 16);
    $reverse_0(edge, true);
  }
  revEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    node.id_0 > 0 && $findCycles(this$static, node, revEdges);
  }
  for (edge$iterator = new ArrayList$1(revEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 16);
    $reverse_0(edge, true);
  }
  revEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $done_0(monitor);
}

function InteractiveCycleBreaker(){
  $clinit_InteractiveCycleBreaker();
}

defineClass(1258, 1, $intern_117, InteractiveCycleBreaker);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_1(graph){
  return castTo(graph, 32) , INTERMEDIATE_PROCESSING_CONFIGURATION_1;
}
;
_.process = function process_54(layeredGraph, monitor){
  $process_59(this, castTo(layeredGraph, 32), monitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIGURATION_1;
var Lorg_eclipse_elk_alg_layered_p1cycles_InteractiveCycleBreaker_2_classLit = createForClass('org.eclipse.elk.alg.layered.p1cycles', 'InteractiveCycleBreaker', 1258);
function $clinit_CoffmanGrahamLayerer(){
  $clinit_CoffmanGrahamLayerer = emptyMethod;
  BASELINE_PROCESSING_CONFIGURATION_0 = $addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER)), P3_NODE_ORDERING, LAYER_CONSTRAINT_PROCESSOR);
}

function $canAdd_0(n, l){
  var e, e$iterator, v;
  for (e$iterator = $iterator($getOutgoingEdges(n)); $hasNext_0(e$iterator);) {
    e = castTo($next_2(e$iterator), 16);
    v = e.target.owner;
    if (v.layer == l) {
      return false;
    }
  }
  return true;
}

function $compareNodesInTopo(this$static, u, v){
  var inListU, inLsitV, itU, itV, iu, iv;
  inListU = castTo($get_0(this$static.inTopo, u), 15);
  inLsitV = castTo($get_0(this$static.inTopo, v), 15);
  itU = inListU.listIterator_1(inListU.size_1());
  itV = inLsitV.listIterator_1(inLsitV.size_1());
  while (itU.hasPrevious() && itV.hasPrevious()) {
    iu = castTo(itU.previous_0(), 21);
    iv = castTo(itV.previous_0(), 21);
    if (iu != iv) {
      return compare_6(iu.value_0, iv.value_0);
    }
  }
  return !itU.hasNext_0() && !itV.hasNext_0()?0:itU.hasNext_0()?1:-1;
}

function $createLayer(graph, layers){
  var aLayer;
  aLayer = new Layer(graph);
  layers.array[layers.array.length] = aLayer;
  return aLayer;
}

function $dfs_4(this$static, start_0, v){
  var out, out$iterator, transitive, transitive$iterator, w;
  if (this$static.nodeMark[v.id_0]) {
    return;
  }
  for (out$iterator = $iterator($getOutgoingEdges(v)); $hasNext_0(out$iterator);) {
    out = castTo($next_2(out$iterator), 16);
    w = out.target.owner;
    for (transitive$iterator = $iterator($getIncomingEdges(w)); $hasNext_0(transitive$iterator);) {
      transitive = castTo($next_2(transitive$iterator), 16);
      transitive.source.owner == start_0 && (this$static.edgeMark[transitive.id_0] = true);
    }
    $dfs_4(this$static, start_0, w);
  }
  this$static.nodeMark[v.id_0] = true;
}

function $lambda$1_1(this$static, n1_0, n2_1){
  return -compare_6(this$static.topoOrd[n1_0.id_0], this$static.topoOrd[n2_1.id_0]);
}

function $process_60(this$static, layeredGraph, progressMonitor){
  var currentLayer, e, e$iterator, edgeIndex, i, index_0, j, layers, n, n$iterator, sinks, sources, src_0, tgt, u, v, v$iterator, v$iterator0, w;
  $begin(progressMonitor, 'Coffman-Graham Layering', 1);
  w = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , LAYERING_COFFMAN_GRAHAM_LAYER_BOUND_0)), 21).value_0;
  index_0 = 0;
  edgeIndex = 0;
  for (n$iterator = new ArrayList$1(layeredGraph.layerlessNodes); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 9);
    n.id_0 = index_0++;
    for (e$iterator = $iterator($getOutgoingEdges(n)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      e.id_0 = edgeIndex++;
    }
  }
  this$static.nodeMark = initUnidimensionalArray(Z_classLit, $intern_93, 23, index_0, 16, 1);
  this$static.edgeMark = initUnidimensionalArray(Z_classLit, $intern_93, 23, edgeIndex, 16, 1);
  this$static.inDeg = initUnidimensionalArray(I_classLit, $intern_49, 23, index_0, 15, 1);
  this$static.outDeg = initUnidimensionalArray(I_classLit, $intern_49, 23, index_0, 15, 1);
  this$static.topoOrd = initUnidimensionalArray(I_classLit, $intern_49, 23, index_0, 15, 1);
  $clear_0(this$static.inTopo);
  $transitiveReduction(this$static, layeredGraph);
  sources = new PriorityQueue(new CoffmanGrahamLayerer$lambda$0$Type(this$static));
  for (v$iterator0 = new ArrayList$1(layeredGraph.layerlessNodes); v$iterator0.i < v$iterator0.this$01.array.length;) {
    v = castTo($next_10(v$iterator0), 9);
    for (e$iterator = $iterator($getIncomingEdges(v)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      this$static.edgeMark[e.id_0] || ++this$static.inDeg[v.id_0];
    }
    this$static.inDeg[v.id_0] == 0 && (checkCriticalState_0($offer(sources, v)) , true);
  }
  i = 0;
  while (sources.heap.array.length != 0) {
    v = castTo($poll_0(sources), 9);
    this$static.topoOrd[v.id_0] = i++;
    for (e$iterator = $iterator($getOutgoingEdges(v)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      if (this$static.edgeMark[e.id_0]) {
        continue;
      }
      tgt = e.target.owner;
      --this$static.inDeg[tgt.id_0];
      $put(this$static.inTopo, tgt, valueOf_4(this$static.topoOrd[v.id_0]));
      this$static.inDeg[tgt.id_0] == 0 && (checkCriticalState_0($offer(sources, tgt)) , true);
    }
  }
  sinks = new PriorityQueue(new CoffmanGrahamLayerer$lambda$1$Type(this$static));
  for (v$iterator = new ArrayList$1(layeredGraph.layerlessNodes); v$iterator.i < v$iterator.this$01.array.length;) {
    v = castTo($next_10(v$iterator), 9);
    for (e$iterator = $iterator($getOutgoingEdges(v)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      this$static.edgeMark[e.id_0] || ++this$static.outDeg[v.id_0];
    }
    this$static.outDeg[v.id_0] == 0 && (checkCriticalState_0($offer(sinks, v)) , true);
  }
  layers = new ArrayList;
  currentLayer = $createLayer(layeredGraph, layers);
  while (sinks.heap.array.length != 0) {
    u = castTo($poll_0(sinks), 9);
    (currentLayer.nodes.array.length >= w || !$canAdd_0(u, currentLayer)) && (currentLayer = $createLayer(layeredGraph, layers));
    $setLayer_0(u, currentLayer);
    for (e$iterator = $iterator($getIncomingEdges(u)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      if (this$static.edgeMark[e.id_0]) {
        continue;
      }
      src_0 = e.source.owner;
      --this$static.outDeg[src_0.id_0];
      this$static.outDeg[src_0.id_0] == 0 && (checkCriticalState_0($offer(sinks, src_0)) , true);
    }
  }
  for (j = layers.array.length - 1; j >= 0; --j) {
    $add_4(layeredGraph.layers, (checkCriticalElementIndex(j, layers.array.length) , castTo(layers.array[j], 25)));
  }
  layeredGraph.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $done_0(progressMonitor);
}

function $transitiveReduction(this$static, graph){
  var out, out$iterator, start_0, start$iterator;
  for (start$iterator = new ArrayList$1(graph.layerlessNodes); start$iterator.i < start$iterator.this$01.array.length;) {
    start_0 = castTo($next_10(start$iterator), 9);
    fill_4(this$static.nodeMark);
    for (out$iterator = $iterator($getOutgoingEdges(start_0)); $hasNext_0(out$iterator);) {
      out = castTo($next_2(out$iterator), 16);
      $dfs_4(this$static, start_0, out.target.owner);
    }
  }
}

function CoffmanGrahamLayerer(){
  $clinit_CoffmanGrahamLayerer();
  this.inTopo = new ArrayListMultimap;
}

defineClass(1261, 1, $intern_117, CoffmanGrahamLayerer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_2(graph){
  return castTo(graph, 32) , BASELINE_PROCESSING_CONFIGURATION_0;
}
;
_.process = function process_55(layeredGraph, progressMonitor){
  $process_60(this, castTo(layeredGraph, 32), progressMonitor);
}
;
var BASELINE_PROCESSING_CONFIGURATION_0;
var Lorg_eclipse_elk_alg_layered_p2layers_CoffmanGrahamLayerer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'CoffmanGrahamLayerer', 1261);
function CoffmanGrahamLayerer$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1262, 1, $intern_40, CoffmanGrahamLayerer$lambda$0$Type);
_.equals_0 = function equals_140(other){
  return this === other;
}
;
_.reversed = function reversed_45(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_53(arg0, arg1){
  return $compareNodesInTopo(this.$$outer_0, castTo(arg0, 9), castTo(arg1, 9));
}
;
var Lorg_eclipse_elk_alg_layered_p2layers_CoffmanGrahamLayerer$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'CoffmanGrahamLayerer/lambda$0$Type', 1262);
function CoffmanGrahamLayerer$lambda$1$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1263, 1, $intern_40, CoffmanGrahamLayerer$lambda$1$Type);
_.equals_0 = function equals_141(other){
  return this === other;
}
;
_.reversed = function reversed_46(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_54(arg0, arg1){
  return $lambda$1_1(this.$$outer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_p2layers_CoffmanGrahamLayerer$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'CoffmanGrahamLayerer/lambda$1$Type', 1263);
function $checkNode(this$static, node1, graph){
  var edge, edge$iterator, layer1, layer2, newIndex, newLayer, node2, port, port$iterator;
  node1.id_0 = 1;
  layer1 = node1.layer;
  for (port$iterator = $getPorts(node1, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 16);
      node2 = edge.target.owner;
      if (node1 != node2) {
        layer2 = node2.layer;
        if (layer2.id_0 <= layer1.id_0) {
          newIndex = layer1.id_0 + 1;
          if (newIndex == graph.layers.array.length) {
            newLayer = new Layer(graph);
            newLayer.id_0 = newIndex;
            $add_4(graph.layers, newLayer);
            $setLayer_0(node2, newLayer);
          }
           else {
            newLayer = castTo($get_7(graph.layers, newIndex), 25);
            $setLayer_0(node2, newLayer);
          }
          $checkNode(this$static, node2, graph);
        }
      }
    }
  }
}

function $process_61(this$static, layeredGraph, monitor){
  var currentSpans, foundSpan, layer, layers, maxx, minx, nextIndex, node, node$iterator, node$iterator0, node$iterator1, span_0, span$iterator, spanIter;
  $begin(monitor, 'Interactive node layering', 1);
  currentSpans = new ArrayList;
  for (node$iterator0 = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    minx = node.pos.x_0;
    maxx = minx + node.size_0.x_0;
    maxx = $wnd.Math.max(minx + 1, maxx);
    spanIter = new AbstractList$ListIteratorImpl(currentSpans, 0);
    foundSpan = null;
    while (spanIter.i < spanIter.this$01_0.size_1()) {
      span_0 = (checkCriticalElement(spanIter.i < spanIter.this$01_0.size_1()) , castTo(spanIter.this$01_0.get_3(spanIter.last = spanIter.i++), 538));
      if (span_0.start_0 >= maxx) {
        checkCriticalElement(spanIter.i > 0);
        spanIter.this$01.get_3(spanIter.last = --spanIter.i);
        break;
      }
       else if (span_0.end > minx) {
        if (!foundSpan) {
          $add_4(span_0.nodes, node);
          span_0.start_0 = $wnd.Math.min(span_0.start_0, minx);
          span_0.end = $wnd.Math.max(span_0.end, maxx);
          foundSpan = span_0;
        }
         else {
          $addAll_2(foundSpan.nodes, span_0.nodes);
          foundSpan.end = $wnd.Math.max(foundSpan.end, span_0.end);
          $remove_9(spanIter);
        }
      }
    }
    if (!foundSpan) {
      foundSpan = new InteractiveLayerer$LayerSpan;
      foundSpan.start_0 = minx;
      foundSpan.end = maxx;
      $add_2(spanIter, foundSpan);
      $add_4(foundSpan.nodes, node);
    }
  }
  layers = layeredGraph.layers;
  nextIndex = 0;
  for (span$iterator = new ArrayList$1(currentSpans); span$iterator.i < span$iterator.this$01.array.length;) {
    span_0 = castTo($next_10(span$iterator), 538);
    layer = new Layer(layeredGraph);
    layer.id_0 = nextIndex++;
    layers.array[layers.array.length] = layer;
    for (node$iterator1 = new ArrayList$1(span_0.nodes); node$iterator1.i < node$iterator1.this$01.array.length;) {
      node = castTo($next_10(node$iterator1), 9);
      $setLayer_0(node, layer);
      node.id_0 = 0;
    }
  }
  for (node$iterator = new ArrayList$1(layeredGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    node.id_0 == 0 && $checkNode(this$static, node, layeredGraph);
  }
  while ((checkCriticalElementIndex(0, layers.array.length) , castTo(layers.array[0], 25)).nodes.array.length == 0) {
    checkCriticalElementIndex(0, layers.array.length);
    layers.array.splice(0, 1);
  }
  layeredGraph.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $done_0(monitor);
}

function InteractiveLayerer(){
}

defineClass(1264, 1, $intern_117, InteractiveLayerer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_3(graph){
  return castTo(graph, 32) , $addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , INTERACTIVE_EXTERNAL_PORT_POSITIONER)), P3_NODE_ORDERING, LAYER_CONSTRAINT_PROCESSOR);
}
;
_.process = function process_56(layeredGraph, monitor){
  $process_61(this, castTo(layeredGraph, 32), monitor);
}
;
var Lorg_eclipse_elk_alg_layered_p2layers_InteractiveLayerer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'InteractiveLayerer', 1264);
function InteractiveLayerer$LayerSpan(){
  this.nodes = new ArrayList;
}

defineClass(538, 1, {538:1}, InteractiveLayerer$LayerSpan);
_.end = 0;
_.start_0 = 0;
var Lorg_eclipse_elk_alg_layered_p2layers_InteractiveLayerer$LayerSpan_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'InteractiveLayerer/LayerSpan', 538);
function $clinit_LongestPathLayerer(){
  $clinit_LongestPathLayerer = emptyMethod;
  BASELINE_PROCESSING_CONFIGURATION_1 = $addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER)), P3_NODE_ORDERING, LAYER_CONSTRAINT_PROCESSOR);
  BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE = $addAfter($addBefore($addBefore(new LayoutProcessorConfiguration, P2_LAYERING, BIG_NODES_PREPROCESSOR), P3_NODE_ORDERING, BIG_NODES_INTERMEDIATEPROCESSOR), P5_EDGE_ROUTING, BIG_NODES_POSTPROCESSOR);
  BIG_NODES_PROCESSING_ADDITIONS_CAREFUL = $addAfter($addBefore(new LayoutProcessorConfiguration, P4_NODE_PLACEMENT, BIG_NODES_SPLITTER), P5_EDGE_ROUTING, BIG_NODES_POSTPROCESSOR);
}

function $getLayoutProcessorConfiguration(graph){
  var strategy;
  strategy = createFrom_0(BASELINE_PROCESSING_CONFIGURATION_1);
  maskUndefined($getProperty(graph, ($clinit_LayeredOptions() , LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_0))) === maskUndefined(($clinit_WideNodesStrategy() , AGGRESSIVE))?$addAll_4(strategy, BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE):maskUndefined($getProperty(graph, LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_0)) === maskUndefined(CAREFUL) && $addAll_4(strategy, BIG_NODES_PROCESSING_ADDITIONS_CAREFUL);
  return strategy;
}

function $process_62(this$static, thelayeredGraph, monitor){
  var index_0, node, node$iterator, node$iterator0, nodes;
  $begin(monitor, 'Longest path layering', 1);
  this$static.layeredGraph = thelayeredGraph;
  nodes = this$static.layeredGraph.layerlessNodes;
  this$static.nodeHeights = initUnidimensionalArray(I_classLit, $intern_49, 23, nodes.array.length, 15, 1);
  index_0 = 0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    node.id_0 = index_0;
    this$static.nodeHeights[index_0] = -1;
    ++index_0;
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $visit(this$static, node);
  }
  nodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.layeredGraph = null;
  this$static.nodeHeights = null;
  $done_0(monitor);
}

function $putNode(this$static, node, height){
  var i, layers;
  layers = this$static.layeredGraph.layers;
  for (i = layers.array.length; i < height; i++) {
    $add_3(layers, 0, new Layer(this$static.layeredGraph));
  }
  $setLayer_0(node, castTo($get_7(layers, layers.array.length - height), 25));
  this$static.nodeHeights[node.id_0] = height;
}

function $visit(this$static, node){
  var edge, edge$iterator, height, maxHeight, port, port$iterator, targetHeight, targetNode;
  height = this$static.nodeHeights[node.id_0];
  if (height >= 0) {
    return height;
  }
   else {
    maxHeight = 1;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        targetNode = edge.target.owner;
        if (node != targetNode) {
          targetHeight = $visit(this$static, targetNode);
          maxHeight = maxHeight > targetHeight + 1?maxHeight:targetHeight + 1;
        }
      }
    }
    $putNode(this$static, node, maxHeight);
    return maxHeight;
  }
}

function LongestPathLayerer(){
  $clinit_LongestPathLayerer();
}

defineClass(1260, 1, $intern_117, LongestPathLayerer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_4(graph){
  return $getLayoutProcessorConfiguration(castTo(graph, 32));
}
;
_.process = function process_57(thelayeredGraph, monitor){
  $process_62(this, castTo(thelayeredGraph, 32), monitor);
}
;
var BASELINE_PROCESSING_CONFIGURATION_1, BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE, BIG_NODES_PROCESSING_ADDITIONS_CAREFUL;
var Lorg_eclipse_elk_alg_layered_p2layers_LongestPathLayerer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'LongestPathLayerer', 1260);
function $clinit_MinWidthLayerer(){
  $clinit_MinWidthLayerer = emptyMethod;
  UPPERBOUND_ON_WIDTH_RANGE = closed_0(valueOf_4(1), valueOf_4(4));
  COMPENSATOR_RANGE = closed_0(valueOf_4(1), valueOf_4(2));
}

function $computeMinWidthLayering(this$static, upperBoundOnWidth, compensator, nodes, nodeSuccessors){
  var alreadyPlacedInCurrentLayer, alreadyPlacedInOtherLayers, currentLayer, currentNode, currentSpanningEdges, goingOutFromThisLayer, inDeg, layers, maxWidth, outDeg, realWidth, ubwConsiderSize, unplacedNodes, widthCurrent, widthUp;
  layers = new ArrayList;
  unplacedNodes = newLinkedHashSet(nodes);
  ubwConsiderSize = upperBoundOnWidth * this$static.avgSize;
  outDeg = 0;
  alreadyPlacedInCurrentLayer = new HashSet;
  alreadyPlacedInOtherLayers = new HashSet;
  currentLayer = new ArrayList;
  widthCurrent = 0;
  widthUp = 0;
  maxWidth = 0;
  realWidth = 0;
  currentSpanningEdges = 0;
  goingOutFromThisLayer = 0;
  while (unplacedNodes.map_0.size_1() != 0) {
    currentNode = $selectNode(unplacedNodes, nodeSuccessors, alreadyPlacedInOtherLayers);
    if (currentNode) {
      unplacedNodes.map_0.remove(currentNode) != null;
      currentLayer.array[currentLayer.array.length] = currentNode;
      alreadyPlacedInCurrentLayer.map_0.put(currentNode, alreadyPlacedInCurrentLayer);
      outDeg = this$static.outDegree[currentNode.id_0];
      widthCurrent += this$static.normSize[currentNode.id_0] - outDeg * this$static.dummySize;
      inDeg = this$static.inDegree[currentNode.id_0];
      widthUp += inDeg * this$static.dummySize;
      goingOutFromThisLayer += outDeg * this$static.dummySize;
      realWidth += this$static.normSize[currentNode.id_0];
    }
    if (!currentNode || unplacedNodes.map_0.size_1() == 0 || widthCurrent >= ubwConsiderSize && this$static.normSize[currentNode.id_0] > outDeg * this$static.dummySize || widthUp >= compensator * ubwConsiderSize) {
      layers.array[layers.array.length] = currentLayer;
      currentLayer = new ArrayList;
      $addAll(alreadyPlacedInOtherLayers, alreadyPlacedInCurrentLayer);
      alreadyPlacedInCurrentLayer.map_0.clear_0();
      currentSpanningEdges -= goingOutFromThisLayer;
      maxWidth = $wnd.Math.max(maxWidth, currentSpanningEdges * this$static.dummySize + realWidth);
      currentSpanningEdges += widthUp;
      widthCurrent = widthUp;
      widthUp = 0;
      goingOutFromThisLayer = 0;
      realWidth = 0;
    }
  }
  return new Pair(maxWidth, layers);
}

function $countEdgesExceptSelfLoops(edges){
  var edge, edge$iterator, i;
  i = 0;
  for (edge$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(edges.val$inputs1, new Iterables$12)))); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 16);
    edge.source.owner == edge.target.owner || ++i;
  }
  return i;
}

function $precalcSuccessors(nodes){
  var edge, edge$iterator, node, node$iterator, outEdges, outNodes, successors;
  successors = newArrayListWithCapacity(nodes.array.length);
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    outNodes = new HashSet;
    outEdges = $getOutgoingEdges(node);
    for (edge$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(outEdges.val$inputs1, new Iterables$12)))); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 16);
      edge.source.owner == edge.target.owner || $add_6(outNodes, edge.target.owner);
    }
    successors.array[successors.array.length] = outNodes;
  }
  return successors;
}

function $process_63(this$static, layeredGraph, progressMonitor){
  var c, cEnd, cStart, candidateLayering, compensator, currentLayer, i, layerList, layerList$iterator, layering, layers, minNumOfLayers, minWidth, newNumOfLayers, newWidth, node, node$iterator, node$iterator0, node$iterator1, nodeSuccessors, notInserted, numOfNodes, result, size_0, ubw, ubwEnd, ubwStart, upperBoundOnWidth;
  $begin(progressMonitor, 'MinWidth layering', 1);
  layers = layeredGraph.layers;
  notInserted = layeredGraph.layerlessNodes;
  upperBoundOnWidth = castTo($getProperty(layeredGraph, ($clinit_LayeredOptions() , LAYERING_MIN_WIDTH_UPPER_BOUND_ON_WIDTH_0)), 21).value_0;
  compensator = castTo($getProperty(layeredGraph, LAYERING_MIN_WIDTH_UPPER_LAYER_ESTIMATION_SCALING_FACTOR_0), 21).value_0;
  this$static.dummySize = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_EDGE_EDGE)));
  this$static.minimumNodeSize = $intern_62;
  for (node$iterator0 = new ArrayList$1(notInserted); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , NORMAL)) {
      continue;
    }
    size_0 = node.size_0.y_0;
    this$static.minimumNodeSize = $wnd.Math.min(this$static.minimumNodeSize, size_0);
  }
  this$static.minimumNodeSize = $wnd.Math.max(1, this$static.minimumNodeSize);
  numOfNodes = notInserted.array.length;
  this$static.inDegree = initUnidimensionalArray(I_classLit, $intern_49, 23, numOfNodes, 15, 1);
  this$static.outDegree = initUnidimensionalArray(I_classLit, $intern_49, 23, numOfNodes, 15, 1);
  this$static.normSize = initUnidimensionalArray(D_classLit, $intern_69, 23, numOfNodes, 15, 1);
  i = 0;
  this$static.avgSize = 0;
  for (node$iterator1 = new ArrayList$1(notInserted); node$iterator1.i < node$iterator1.this$01.array.length;) {
    node = castTo($next_10(node$iterator1), 9);
    node.id_0 = i++;
    this$static.inDegree[node.id_0] = $countEdgesExceptSelfLoops($getIncomingEdges(node));
    this$static.outDegree[node.id_0] = $countEdgesExceptSelfLoops($getOutgoingEdges(node));
    this$static.normSize[node.id_0] = node.size_0.y_0 / this$static.minimumNodeSize;
    this$static.avgSize += this$static.normSize[node.id_0];
  }
  this$static.dummySize /= this$static.minimumNodeSize;
  this$static.avgSize /= numOfNodes;
  nodeSuccessors = $precalcSuccessors(notInserted);
  $sort(notInserted, reverseOrder(new MinWidthLayerer$MinOutgoingEdgesComparator(this$static)));
  minWidth = $intern_62;
  minNumOfLayers = $intern_0;
  candidateLayering = null;
  ubwStart = upperBoundOnWidth;
  ubwEnd = upperBoundOnWidth;
  cStart = compensator;
  cEnd = compensator;
  if (upperBoundOnWidth < 0) {
    ubwStart = castTo(UPPERBOUND_ON_WIDTH_RANGE.lowerBound.endpoint_0(), 21).value_0;
    ubwEnd = castTo(UPPERBOUND_ON_WIDTH_RANGE.upperBound.endpoint_0(), 21).value_0;
  }
  if (compensator < 0) {
    cStart = castTo(COMPENSATOR_RANGE.lowerBound.endpoint_0(), 21).value_0;
    cEnd = castTo(COMPENSATOR_RANGE.upperBound.endpoint_0(), 21).value_0;
  }
  for (ubw = ubwStart; ubw <= ubwEnd; ubw++) {
    for (c = cStart; c <= cEnd; c++) {
      result = $computeMinWidthLayering(this$static, ubw, c, notInserted, nodeSuccessors);
      newWidth = checkNotNull_1(castToDouble(result.first));
      layering = castTo(result.second, 15);
      newNumOfLayers = layering.size_1();
      if (newWidth < minWidth || newWidth == minWidth && newNumOfLayers < minNumOfLayers) {
        minWidth = newWidth;
        minNumOfLayers = newNumOfLayers;
        candidateLayering = layering;
      }
    }
  }
  for (layerList$iterator = candidateLayering.iterator_0(); layerList$iterator.hasNext_0();) {
    layerList = castTo(layerList$iterator.next_1(), 15);
    currentLayer = new Layer(layeredGraph);
    for (node$iterator = layerList.iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 9);
      $setLayer_0(node, currentLayer);
    }
    layers.array[layers.array.length] = currentLayer;
  }
  reverse_2(layers);
  notInserted.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $done_0(progressMonitor);
}

function $selectNode(nodes, successors, targets){
  var node, node$iterator;
  for (node$iterator = nodes.map_0.keySet_0().iterator_0(); node$iterator.hasNext_0();) {
    node = castTo(node$iterator.next_1(), 9);
    if ($containsAll(targets, castTo($get_7(successors, node.id_0), 13))) {
      return node;
    }
  }
  return null;
}

function MinWidthLayerer(){
  $clinit_MinWidthLayerer();
}

defineClass(1267, 1, $intern_117, MinWidthLayerer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_5(graph){
  return castTo(graph, 32) , $addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER)), P3_NODE_ORDERING, LAYER_CONSTRAINT_PROCESSOR);
}
;
_.process = function process_58(layeredGraph, progressMonitor){
  $process_63(this, castTo(layeredGraph, 32), progressMonitor);
}
;
_.avgSize = 0;
_.dummySize = 0;
_.minimumNodeSize = 0;
var COMPENSATOR_RANGE, UPPERBOUND_ON_WIDTH_RANGE;
var Lorg_eclipse_elk_alg_layered_p2layers_MinWidthLayerer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'MinWidthLayerer', 1267);
function $compare_17(this$static, o1, o2){
  var outs1, outs2;
  outs1 = this$static.this$01.outDegree[o1.id_0];
  outs2 = this$static.this$01.outDegree[o2.id_0];
  if (outs1 < outs2) {
    return -1;
  }
  if (outs1 == outs2) {
    return 0;
  }
  return 1;
}

function MinWidthLayerer$MinOutgoingEdgesComparator(this$0){
  this.this$01 = this$0;
}

defineClass(1268, 1, $intern_40, MinWidthLayerer$MinOutgoingEdgesComparator);
_.compare_0 = function compare_55(o1, o2){
  return $compare_17(this, castTo(o1, 9), castTo(o2, 9));
}
;
_.equals_0 = function equals_142(other){
  return this === other;
}
;
_.reversed = function reversed_47(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_p2layers_MinWidthLayerer$MinOutgoingEdgesComparator_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'MinWidthLayerer/MinOutgoingEdgesComparator', 1268);
function $clinit_NetworkSimplexLayerer(){
  $clinit_NetworkSimplexLayerer = emptyMethod;
  BASELINE_PROCESSING_CONFIGURATION_2 = $addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER)), P3_NODE_ORDERING, LAYER_CONSTRAINT_PROCESSOR);
  BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE_0 = $addAfter($addBefore($addBefore(new LayoutProcessorConfiguration, P2_LAYERING, BIG_NODES_PREPROCESSOR), P3_NODE_ORDERING, BIG_NODES_INTERMEDIATEPROCESSOR), P5_EDGE_ROUTING, BIG_NODES_POSTPROCESSOR);
  BIG_NODES_PROCESSING_ADDITIONS_CAREFUL_0 = $addAfter($addBefore(new LayoutProcessorConfiguration, P4_NODE_PLACEMENT, BIG_NODES_SPLITTER), P5_EDGE_ROUTING, BIG_NODES_POSTPROCESSOR);
}

function $connectedComponents(this$static, theNodes){
  var components, counter, node, node$iterator, node$iterator0;
  this$static.nodeVisited == null || this$static.nodeVisited.length < theNodes.array.length?(this$static.nodeVisited = initUnidimensionalArray(Z_classLit, $intern_93, 23, theNodes.array.length, 16, 1)):fill_4(this$static.nodeVisited);
  this$static.componentNodes = new ArrayList;
  counter = 0;
  for (node$iterator0 = new ArrayList$1(theNodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    node.id_0 = counter++;
  }
  components = new LinkedList;
  for (node$iterator = new ArrayList$1(theNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    if (!this$static.nodeVisited[node.id_0]) {
      $connectedComponentsDFS(this$static, node);
      components.size_0 == 0 || (checkCriticalElement(components.size_0 != 0) , castTo(components.header.next_0.value_0, 15)).size_1() < this$static.componentNodes.array.length?$addFirst_0(components, this$static.componentNodes):$addLast_0(components, this$static.componentNodes);
      this$static.componentNodes = new ArrayList;
    }
  }
  return components;
}

function $connectedComponentsDFS(this$static, node){
  var edge, edge$iterator, opposite, port, port$iterator;
  this$static.nodeVisited[node.id_0] = true;
  $add_4(this$static.componentNodes, node);
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    for (edge$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(edge$iterator.firstIterator) || $hasNext_2(edge$iterator.secondIterator);) {
      edge = castTo($hasNext_2(edge$iterator.firstIterator)?$next_10(edge$iterator.firstIterator):$next_10(edge$iterator.secondIterator), 16);
      opposite = $getOpposite(port, edge).owner;
      this$static.nodeVisited[opposite.id_0] || $connectedComponentsDFS(this$static, opposite);
    }
  }
}

function $getLayoutProcessorConfiguration_0(this$static, graph){
  var strategy;
  strategy = createFrom_0(BASELINE_PROCESSING_CONFIGURATION_2);
  if (maskUndefined($getProperty(graph, ($clinit_LayeredOptions() , LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_0))) === maskUndefined(($clinit_WideNodesStrategy() , AGGRESSIVE))) {
    $addAll_4(strategy, BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE_0);
    this$static.wideNodesStrategy = AGGRESSIVE;
  }
   else if (maskUndefined($getProperty(graph, LAYERING_WIDE_NODES_ON_MULTIPLE_LAYERS_0)) === maskUndefined(CAREFUL)) {
    $addAll_4(strategy, BIG_NODES_PROCESSING_ADDITIONS_CAREFUL_0);
    this$static.wideNodesStrategy = CAREFUL;
  }
  return strategy;
}

function $getOpposite(port, edge){
  if (edge.source == port) {
    return edge.target;
  }
   else if (edge.target == port) {
    return edge.source;
  }
  throw toJs(new IllegalArgumentException_0('Input edge is not connected to the input port.'));
}

function $initialize_2(theNodes){
  var graph, lEdge, lEdge$iterator, lNode, lNode$iterator, lNode$iterator0, nNode, nodeMap;
  nodeMap = ($clinit_Maps() , new HashMap);
  graph = new NGraph;
  for (lNode$iterator0 = theNodes.iterator_0(); lNode$iterator0.hasNext_0();) {
    lNode = castTo(lNode$iterator0.next_1(), 9);
    nNode = $create_2($origin_0(new NNode$NNodeBuilder, lNode), graph);
    $put_4(nodeMap.hashCodeMap, lNode, nNode);
  }
  for (lNode$iterator = theNodes.iterator_0(); lNode$iterator.hasNext_0();) {
    lNode = castTo(lNode$iterator.next_1(), 9);
    for (lEdge$iterator = $iterator($getOutgoingEdges(lNode)); $hasNext_0(lEdge$iterator);) {
      lEdge = castTo($next_2(lEdge$iterator), 16);
      if ($isSelfLoop(lEdge)) {
        continue;
      }
      $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, max_1(1, castTo($getProperty(lEdge, ($clinit_LayeredOptions() , PRIORITY_SHORTNESS_0)), 21).value_0)), 1), castTo($get_6(nodeMap, lEdge.source.owner), 115)), castTo($get_6(nodeMap, lEdge.target.owner), 115)));
    }
  }
  return graph;
}

function $process_64(this$static, theLayeredGraph, monitor){
  var connComp, connComp$iterator, connectedComponents, graph, iterLimit, l, l$iterator, lNode, layerIdx, layers, nNode, nNode$iterator, previousLayeringNodeCounts, theNodes, thoroughness;
  $begin(monitor, 'Network simplex layering', 1);
  this$static.layeredGraph = theLayeredGraph;
  thoroughness = castTo($getProperty(theLayeredGraph, ($clinit_LayeredOptions() , THOROUGHNESS_0)), 21).value_0 * 4;
  theNodes = this$static.layeredGraph.layerlessNodes;
  if (theNodes.array.length < 1) {
    $done_0(monitor);
    return;
  }
  connectedComponents = $connectedComponents(this$static, theNodes);
  previousLayeringNodeCounts = null;
  for (connComp$iterator = $listIterator_1(connectedComponents, 0); connComp$iterator.currentNode != connComp$iterator.this$01.tail;) {
    connComp = castTo($next_13(connComp$iterator), 15);
    iterLimit = thoroughness * round_int($wnd.Math.sqrt(connComp.size_1()));
    graph = $initialize_2(connComp);
    $execute($withBalancing($withPreviousLayering($withIterationLimit(forGraph(graph), iterLimit), previousLayeringNodeCounts), this$static.wideNodesStrategy == ($clinit_WideNodesStrategy() , OFF_0)), $subTask(monitor, 1));
    layers = this$static.layeredGraph.layers;
    for (nNode$iterator = new ArrayList$1(graph.nodes); nNode$iterator.i < nNode$iterator.this$01.array.length;) {
      nNode = castTo($next_10(nNode$iterator), 115);
      while (layers.array.length <= nNode.layer) {
        $add_3(layers, layers.array.length, new Layer(this$static.layeredGraph));
      }
      lNode = castTo(nNode.origin, 9);
      $setLayer_0(lNode, castTo($get_7(layers, nNode.layer), 25));
    }
    if (connectedComponents.size_0 > 1) {
      previousLayeringNodeCounts = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.layeredGraph.layers.array.length, 15, 1);
      layerIdx = 0;
      for (l$iterator = new ArrayList$1(this$static.layeredGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
        l = castTo($next_10(l$iterator), 25);
        previousLayeringNodeCounts[layerIdx++] = l.nodes.array.length;
      }
    }
  }
  theNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.componentNodes = null;
  this$static.layeredGraph = null;
  this$static.nodeVisited = null;
  $done_0(monitor);
}

function NetworkSimplexLayerer(){
  $clinit_NetworkSimplexLayerer();
  this.wideNodesStrategy = ($clinit_WideNodesStrategy() , OFF_0);
}

defineClass(1259, 1, $intern_117, NetworkSimplexLayerer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_6(graph){
  return $getLayoutProcessorConfiguration_0(this, castTo(graph, 32));
}
;
_.process = function process_59(theLayeredGraph, monitor){
  $process_64(this, castTo(theLayeredGraph, 32), monitor);
}
;
var BASELINE_PROCESSING_CONFIGURATION_2, BIG_NODES_PROCESSING_ADDITIONS_AGGRESSIVE_0, BIG_NODES_PROCESSING_ADDITIONS_CAREFUL_0;
var Lorg_eclipse_elk_alg_layered_p2layers_NetworkSimplexLayerer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'NetworkSimplexLayerer', 1259);
function $computeDegrees(this$static){
  var node, node$iterator;
  this$static.inDegree = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.sortedLayerlessNodes.array.length, 15, 1);
  this$static.outDegree = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.sortedLayerlessNodes.array.length, 15, 1);
  for (node$iterator = new ArrayList$1(this$static.sortedLayerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    this$static.inDegree[node.id_0] = size_15($getIncomingEdges(node));
    this$static.outDegree[node.id_0] = size_15($getOutgoingEdges(node));
  }
}

function $computeNormalizedSize(this$static){
  var node, node$iterator;
  this$static.normSize = initUnidimensionalArray(D_classLit, $intern_69, 23, this$static.sortedLayerlessNodes.array.length, 15, 1);
  for (node$iterator = new ArrayList$1(this$static.sortedLayerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    this$static.normSize[node.id_0] = node.size_0.y_0 / this$static.minimumNodeSize;
  }
}

function $computeSortedNodes(this$static){
  var node, node$iterator, unsortedNodes;
  unsortedNodes = this$static.currentGraph.layerlessNodes;
  this$static.sortedLayerlessNodes = (checkNotNull(unsortedNodes) , new ArrayList_1(($clinit_Collections2() , unsortedNodes)));
  for (node$iterator = new ArrayList$1(unsortedNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    node.id_0 = $getRank(node).value_0;
  }
  $clinit_Collections();
  $sort(this$static.sortedLayerlessNodes, new StretchWidthLayerer$1);
}

function $computeSuccessors(this$static){
  var currSucc, edge, edge$iterator, i, node, node$iterator;
  i = 0;
  this$static.successors = new ArrayList;
  currSucc = new HashSet;
  for (node$iterator = new ArrayList$1(this$static.sortedLayerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    node.id_0 = i;
    for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 16);
      $add_6(currSucc, edge.target.owner);
    }
    currSucc.map_0.remove(node) != null;
    $add_4(this$static.successors, new HashSet_1(($clinit_Collections2() , currSucc)));
    currSucc.map_0.clear_0();
    ++i;
  }
}

function $conditionGoUp(this$static){
  var a, b;
  a = this$static.widthCurrent - this$static.outDegree[this$static.selectedNode.id_0] * this$static.dummySize + this$static.normSize[this$static.selectedNode.id_0] > this$static.maxWidth;
  b = this$static.widthUp + this$static.inDegree[this$static.selectedNode.id_0] * this$static.dummySize > this$static.maxWidth * this$static.upperLayerInfluence * this$static.dummySize;
  return a || b;
}

function $getAverageOutDegree(this$static){
  var allOut, node, node$iterator;
  allOut = 0;
  for (node$iterator = new ArrayList$1(this$static.currentGraph.layerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    allOut += size_15($getOutgoingEdges(node));
  }
  return allOut / this$static.currentGraph.layerlessNodes.array.length;
}

function $getRank(node){
  var max_0, pre, preEdge, preEdge$iterator, temp;
  max_0 = size_15($getOutgoingEdges(node));
  for (preEdge$iterator = $iterator($getIncomingEdges(node)); $hasNext_0(preEdge$iterator);) {
    preEdge = castTo($next_2(preEdge$iterator), 16);
    pre = preEdge.source.owner;
    temp = size_15($getOutgoingEdges(pre));
    max_0 = max_0 > temp?max_0:temp;
  }
  return valueOf_4(max_0);
}

function $minMaxNodeSize(this$static){
  var node, node$iterator, size_0;
  for (node$iterator = new ArrayList$1(this$static.sortedLayerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    if (node.type_0 != ($clinit_LNode$NodeType() , NORMAL)) {
      continue;
    }
    size_0 = node.size_0.y_0;
    this$static.minimumNodeSize = $wnd.Math.min(this$static.minimumNodeSize, size_0);
    this$static.maximumNodeSize = $wnd.Math.max(this$static.maximumNodeSize, size_0);
  }
}

function $process_65(this$static, layeredGraph, progressMonitor){
  var currentLayer;
  $begin(progressMonitor, 'StretchWidth layering', 1);
  if (layeredGraph.layerlessNodes.array.length == 0) {
    $done_0(progressMonitor);
    return;
  }
  this$static.currentGraph = layeredGraph;
  this$static.widthCurrent = 0;
  this$static.widthUp = 0;
  this$static.minimumNodeSize = $intern_62;
  this$static.maximumNodeSize = $intern_63;
  this$static.dummySize = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_EDGE_EDGE))));
  $computeSortedNodes(this$static);
  $computeSuccessors(this$static);
  $computeDegrees(this$static);
  $minMaxNodeSize(this$static);
  $computeNormalizedSize(this$static);
  this$static.minimumNodeSize = $wnd.Math.max(1, this$static.minimumNodeSize);
  this$static.maximumNodeSize = $wnd.Math.max(1, this$static.maximumNodeSize);
  this$static.dummySize = this$static.dummySize / this$static.minimumNodeSize;
  this$static.maxWidth = this$static.maximumNodeSize / this$static.minimumNodeSize;
  this$static.upperLayerInfluence = $getAverageOutDegree(this$static);
  currentLayer = new Layer(this$static.currentGraph);
  $add_4(this$static.currentGraph.layers, currentLayer);
  this$static.tempLayerlessNodes = newArrayList(this$static.sortedLayerlessNodes);
  this$static.remainingOutGoing = copyOf_0(this$static.outDegree, this$static.outDegree.length);
  while (this$static.tempLayerlessNodes.array.length != 0) {
    this$static.selectedNode = $selectNode_0(this$static);
    if (!this$static.selectedNode || $conditionGoUp(this$static) && this$static.alreadyPlacedNodes.map_0.size_1() != 0) {
      $updateOutGoing(this$static, currentLayer);
      currentLayer = new Layer(this$static.currentGraph);
      $add_4(this$static.currentGraph.layers, currentLayer);
      $addAll(this$static.alreadyPlacedInOtherLayers, this$static.alreadyPlacedNodes);
      this$static.alreadyPlacedNodes.map_0.clear_0();
      this$static.widthCurrent = this$static.widthUp;
      this$static.widthUp = 0;
    }
     else {
      if ($conditionGoUp(this$static)) {
        this$static.currentGraph.layers.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
        currentLayer = new Layer(this$static.currentGraph);
        $add_4(this$static.currentGraph.layers, currentLayer);
        this$static.widthCurrent = 0;
        this$static.widthUp = 0;
        this$static.alreadyPlacedNodes.map_0.clear_0();
        this$static.alreadyPlacedInOtherLayers.map_0.clear_0();
        ++this$static.maxWidth;
        this$static.tempLayerlessNodes = newArrayList(this$static.sortedLayerlessNodes);
        this$static.remainingOutGoing = copyOf_0(this$static.outDegree, this$static.outDegree.length);
      }
       else {
        $setLayer_0(this$static.selectedNode, currentLayer);
        $remove_13(this$static.tempLayerlessNodes, this$static.selectedNode);
        $add_6(this$static.alreadyPlacedNodes, this$static.selectedNode);
        this$static.widthCurrent = this$static.widthCurrent - this$static.outDegree[this$static.selectedNode.id_0] * this$static.dummySize + this$static.normSize[this$static.selectedNode.id_0];
        this$static.widthUp += this$static.inDegree[this$static.selectedNode.id_0] * this$static.dummySize;
      }
    }
  }
  layeredGraph.layerlessNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  reverse_2(layeredGraph.layers);
  $done_0(progressMonitor);
}

function $selectNode_0(this$static){
  var node, node$iterator;
  for (node$iterator = new ArrayList$1(this$static.tempLayerlessNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    if (this$static.remainingOutGoing[node.id_0] <= 0) {
      return node;
    }
  }
  return null;
}

function $updateOutGoing(this$static, currentLayer){
  var edge, edge$iterator, node, node$iterator, pos;
  for (node$iterator = new ArrayList$1(currentLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    for (edge$iterator = $iterator($getIncomingEdges(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 16);
      pos = edge.source.owner.id_0;
      this$static.remainingOutGoing[pos] = this$static.remainingOutGoing[pos] - 1;
    }
  }
}

function StretchWidthLayerer(){
  this.alreadyPlacedNodes = new HashSet;
  this.alreadyPlacedInOtherLayers = new HashSet;
}

defineClass(1265, 1, $intern_117, StretchWidthLayerer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_7(graph){
  return castTo(graph, 32) , $addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P1_CYCLE_BREAKING), ($clinit_IntermediateProcessorStrategy() , EDGE_AND_LAYER_CONSTRAINT_EDGE_REVERSER)), P3_NODE_ORDERING, LAYER_CONSTRAINT_PROCESSOR);
}
;
_.process = function process_60(layeredGraph, progressMonitor){
  $process_65(this, castTo(layeredGraph, 32), progressMonitor);
}
;
_.dummySize = 0;
_.maxWidth = 0;
_.maximumNodeSize = 0;
_.minimumNodeSize = 0;
_.upperLayerInfluence = 0;
_.widthCurrent = 0;
_.widthUp = 0;
var Lorg_eclipse_elk_alg_layered_p2layers_StretchWidthLayerer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'StretchWidthLayerer', 1265);
function $compare_18(o1, o2){
  if (o1.id_0 < o2.id_0) {
    return 1;
  }
   else if (o1.id_0 > o2.id_0) {
    return -1;
  }
  return 0;
}

function StretchWidthLayerer$1(){
}

defineClass(1266, 1, $intern_40, StretchWidthLayerer$1);
_.compare_0 = function compare_56(o1, o2){
  return $compare_18(castTo(o1, 9), castTo(o2, 9));
}
;
_.equals_0 = function equals_143(other){
  return this === other;
}
;
_.reversed = function reversed_48(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_p2layers_StretchWidthLayerer$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.p2layers', 'StretchWidthLayerer/1', 1266);
function create_16(cmt, r, currentOrder){
  return cmt == ($clinit_LayerSweepCrossingMinimizer$CrossMinType() , TWO_SIDED_GREEDY_SWITCH_0)?new GreedyPortDistributor:$nextInternal(r, 1) != 0?new NodeRelativePortDistributor(currentOrder.length):new LayerTotalPortDistributor(currentOrder.length);
}

function $calculateInLayerPortsBarycenterValues(this$static, node){
  var barycenter, connectedPort, connectedPort$iterator, inLayerConnections, inLayerPort, inLayerPort$iterator, layerSize, nodeIndexInLayer, portSide, sum;
  nodeIndexInLayer = this$static.nodePositions[node.layer.id_0][node.id_0] + 1;
  layerSize = node.layer.nodes.array.length + 1;
  for (inLayerPort$iterator = new ArrayList$1(this$static.inLayerPorts); inLayerPort$iterator.i < inLayerPort$iterator.this$01.array.length;) {
    inLayerPort = castTo($next_10(inLayerPort$iterator), 11);
    sum = 0;
    inLayerConnections = 0;
    for (connectedPort$iterator = $iterator(concat_1(new LPort$7(inLayerPort), new LPort$8(inLayerPort))); $hasNext_0(connectedPort$iterator);) {
      connectedPort = castTo($next_2(connectedPort$iterator), 11);
      if (connectedPort.owner.layer == node.layer) {
        sum += $positionOf(this$static, connectedPort.owner) + 1;
        ++inLayerConnections;
      }
    }
    barycenter = sum / inLayerConnections;
    portSide = inLayerPort.side;
    portSide == ($clinit_PortSide() , EAST_1)?barycenter < nodeIndexInLayer?(this$static.portBarycenter[inLayerPort.id_0] = this$static.minBarycenter - barycenter):(this$static.portBarycenter[inLayerPort.id_0] = this$static.maxBarycenter + (layerSize - barycenter)):portSide == WEST_1 && (barycenter < nodeIndexInLayer?(this$static.portBarycenter[inLayerPort.id_0] = this$static.maxBarycenter + barycenter):(this$static.portBarycenter[inLayerPort.id_0] = this$static.minBarycenter - (layerSize - barycenter)));
  }
}

function $calculatePortRanks(this$static, layer, portType){
  var consumedRank, nodeIx;
  consumedRank = 0;
  for (nodeIx = 0; nodeIx < layer.length; nodeIx++) {
    consumedRank += this$static.calculatePortRanks(layer[nodeIx], consumedRank, portType);
  }
}

function $dealWithNorthSouthPorts(this$static, absurdlyLargeFloat, port, portDummy){
  var input_0, output, portDummyPort, portDummyPort$iterator, sum;
  input_0 = false;
  output = false;
  for (portDummyPort$iterator = new ArrayList$1(portDummy.ports); portDummyPort$iterator.i < portDummyPort$iterator.this$01.array.length;) {
    portDummyPort = castTo($next_10(portDummyPort$iterator), 11);
    maskUndefined($getProperty(portDummyPort, ($clinit_InternalProperties_1() , ORIGIN_0))) === maskUndefined(port) && (portDummyPort.outgoingEdges.array.length == 0?portDummyPort.incomingEdges.array.length == 0 || (input_0 = true):(output = true));
  }
  sum = 0;
  input_0 && !output?(sum = port.side == ($clinit_PortSide() , NORTH_1)?-this$static.nodePositions[portDummy.layer.id_0][portDummy.id_0]:absurdlyLargeFloat - this$static.nodePositions[portDummy.layer.id_0][portDummy.id_0]):output && !input_0?(sum = this$static.nodePositions[portDummy.layer.id_0][portDummy.id_0] + 1):input_0 && output && (sum = port.side == ($clinit_PortSide() , NORTH_1)?0:absurdlyLargeFloat / 2);
  return sum;
}

function $distributePorts(this$static, node, ports){
  this$static.inLayerPorts.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $iteratePortsAndCollectInLayerPorts(this$static, node, ports);
  this$static.inLayerPorts.array.length == 0 || $calculateInLayerPortsBarycenterValues(this$static, node);
}

function $distributePorts_0(this$static, node, side){
  if (!$isOrderFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
    $distributePorts(this$static, node, $getPorts_1(node, side));
    $distributePorts(this$static, node, $getPorts_1(node, ($clinit_PortSide() , SOUTH_1)));
    $distributePorts(this$static, node, $getPorts_1(node, NORTH_1));
    $clinit_Collections();
    $sort(node.ports, new AbstractBarycenterPortDistributor$lambda$0$Type(this$static));
  }
}

function $distributePortsWhileSweeping(this$static, nodeOrder, currentIndex, isForwardSweep){
  var fixedLayer, freeLayer, node, node$index, node$index0, node$max, node$max0, side;
  $updateNodePositions(this$static, nodeOrder, currentIndex);
  freeLayer = nodeOrder[currentIndex];
  side = isForwardSweep?($clinit_PortSide() , WEST_1):($clinit_PortSide() , EAST_1);
  if ($isNotFirstLayer(nodeOrder.length, currentIndex, isForwardSweep)) {
    fixedLayer = nodeOrder[isForwardSweep?currentIndex - 1:currentIndex + 1];
    $calculatePortRanks(this$static, fixedLayer, isForwardSweep?($clinit_PortType() , OUTPUT):($clinit_PortType() , INPUT));
    for (node$index0 = 0 , node$max0 = freeLayer.length; node$index0 < node$max0; ++node$index0) {
      node = freeLayer[node$index0];
      $distributePorts_0(this$static, node, side);
    }
    $calculatePortRanks(this$static, freeLayer, isForwardSweep?($clinit_PortType() , INPUT):($clinit_PortType() , OUTPUT));
    for (node$index = 0 , node$max = fixedLayer.length; node$index < node$max; ++node$index) {
      node = fixedLayer[node$index];
      $getProperty(node, ($clinit_InternalProperties_1() , NESTED_LGRAPH)) != null || $distributePorts_0(this$static, node, $opposed(side));
    }
  }
   else {
    for (node$index = 0 , node$max = freeLayer.length; node$index < node$max; ++node$index) {
      node = freeLayer[node$index];
      $distributePorts_0(this$static, node, side);
    }
  }
  return false;
}

function $isNotFirstLayer(length_0, currentIndex, isForwardSweep){
  return isForwardSweep?currentIndex != 0:currentIndex != length_0 - 1;
}

function $iteratePortsAndCollectInLayerPorts(this$static, node, ports){
  var absurdlyLargeFloat, connectedPort, incomingEdge, incomingEdge$iterator, northSouthPort, outgoingEdge, outgoingEdge$iterator, port, port$iterator, portDummy, sum;
  this$static.minBarycenter = 0;
  this$static.maxBarycenter = 0;
  absurdlyLargeFloat = 2 * node.layer.nodes.array.length + 1;
  PortIteration: for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    northSouthPort = port.side == ($clinit_PortSide() , NORTH_1) || port.side == SOUTH_1;
    sum = 0;
    if (northSouthPort) {
      portDummy = castTo($getProperty(port, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
      if (!portDummy) {
        continue;
      }
      sum += $dealWithNorthSouthPorts(this$static, absurdlyLargeFloat, port, portDummy);
    }
     else {
      for (outgoingEdge$iterator = new ArrayList$1(port.outgoingEdges); outgoingEdge$iterator.i < outgoingEdge$iterator.this$01.array.length;) {
        outgoingEdge = castTo($next_10(outgoingEdge$iterator), 16);
        connectedPort = outgoingEdge.target;
        if (connectedPort.owner.layer == node.layer) {
          $add_4(this$static.inLayerPorts, port);
          continue PortIteration;
        }
         else {
          sum += this$static.portRanks[connectedPort.id_0];
        }
      }
      for (incomingEdge$iterator = new ArrayList$1(port.incomingEdges); incomingEdge$iterator.i < incomingEdge$iterator.this$01.array.length;) {
        incomingEdge = castTo($next_10(incomingEdge$iterator), 16);
        connectedPort = incomingEdge.source;
        if (connectedPort.owner.layer == node.layer) {
          $add_4(this$static.inLayerPorts, port);
          continue PortIteration;
        }
         else {
          sum -= this$static.portRanks[connectedPort.id_0];
        }
      }
    }
    if (port.incomingEdges.array.length + port.outgoingEdges.array.length > 0) {
      this$static.portBarycenter[port.id_0] = sum / (port.incomingEdges.array.length + port.outgoingEdges.array.length);
      this$static.minBarycenter = $wnd.Math.min(this$static.minBarycenter, this$static.portBarycenter[port.id_0]);
      this$static.maxBarycenter = $wnd.Math.max(this$static.maxBarycenter, this$static.portBarycenter[port.id_0]);
    }
     else 
      northSouthPort && (this$static.portBarycenter[port.id_0] = sum);
  }
}

function $lambda$0_6(this$static, port1_0, port2_1){
  var port1Bary, port2Bary, side1, side2;
  side1 = port1_0.side;
  side2 = port2_1.side;
  if (side1 != side2) {
    return side1.ordinal - side2.ordinal;
  }
   else {
    port1Bary = this$static.portBarycenter[port1_0.id_0];
    port2Bary = this$static.portBarycenter[port2_1.id_0];
    return port1Bary == 0 && port2Bary == 0?0:port1Bary == 0?-1:port2Bary == 0?1:compare_5(port1Bary, port2Bary);
  }
}

function $positionOf(this$static, node){
  return this$static.nodePositions[node.layer.id_0][node.id_0];
}

function $updateNodePositions(this$static, nodeOrder, currentIndex){
  var i, layer, node;
  layer = nodeOrder[currentIndex];
  for (i = 0; i < layer.length; i++) {
    node = layer[i];
    this$static.nodePositions[node.layer.id_0][node.id_0] = i;
  }
}

function AbstractBarycenterPortDistributor(numLayers){
  this.inLayerPorts = new ArrayList;
  this.nodePositions = initUnidimensionalArray(I_classLit, $intern_33, 40, numLayers, 0, 2);
}

defineClass(433, 1, $intern_118);
_.initAtEdgeLevel = function initAtEdgeLevel_0(l, n, p, e, edge, nodeOrder){
}
;
_.distributePortsWhileSweeping = function distributePortsWhileSweeping(nodeOrder, currentIndex, isForwardSweep){
  return $distributePortsWhileSweeping(this, nodeOrder, currentIndex, isForwardSweep);
}
;
_.initAfterTraversal = function initAfterTraversal_0(){
  this.portRanks = initUnidimensionalArray(F_classLit, $intern_119, 23, this.nPorts, 15, 1);
  this.portBarycenter = initUnidimensionalArray(F_classLit, $intern_119, 23, this.nPorts, 15, 1);
}
;
_.initAtLayerLevel = function initAtLayerLevel_0(l, nodeOrder){
  this.nodePositions[l] = initUnidimensionalArray(I_classLit, $intern_49, 23, nodeOrder[l].length, 15, 1);
}
;
_.initAtNodeLevel = function initAtNodeLevel_0(l, n, nodeOrder){
  var node;
  node = nodeOrder[l][n];
  node.id_0 = n;
  this.nodePositions[l][n] = n;
}
;
_.initAtPortLevel = function initAtPortLevel_0(l, n, p, nodeOrder){
  castTo($get_7(nodeOrder[l][n].ports, p), 11).id_0 = this.nPorts++;
}
;
_.maxBarycenter = 0;
_.minBarycenter = 0;
_.nPorts = 0;
var Lorg_eclipse_elk_alg_layered_p3order_AbstractBarycenterPortDistributor_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'AbstractBarycenterPortDistributor', 433);
function AbstractBarycenterPortDistributor$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1479, 1, $intern_40, AbstractBarycenterPortDistributor$lambda$0$Type);
_.equals_0 = function equals_144(other){
  return this === other;
}
;
_.reversed = function reversed_49(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_57(arg0, arg1){
  return $lambda$0_6(this.$$outer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_AbstractBarycenterPortDistributor$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'AbstractBarycenterPortDistributor/lambda$0$Type', 1479);
function $calculateBarycenter(this$static, node, forward_0){
  var associate, associate$iterator, barycenterAssociates, fixedNode, fixedPort, fixedPort$iterator, freePort, freePort$iterator, portIterable;
  if (this$static.barycenterState[node.layer.id_0][node.id_0].visited) {
    return;
  }
   else {
    this$static.barycenterState[node.layer.id_0][node.id_0].visited = true;
  }
  this$static.barycenterState[node.layer.id_0][node.id_0].degree = 0;
  this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight = 0;
  this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = null;
  for (freePort$iterator = new ArrayList$1(node.ports); freePort$iterator.i < freePort$iterator.this$01.array.length;) {
    freePort = castTo($next_10(freePort$iterator), 11);
    portIterable = forward_0?new LPort$7(freePort):new LPort$8(freePort);
    for (fixedPort$iterator = portIterable.iterator_0(); fixedPort$iterator.hasNext_0();) {
      fixedPort = castTo(fixedPort$iterator.next_1(), 11);
      fixedNode = fixedPort.owner;
      if (fixedNode.layer == node.layer) {
        if (fixedNode != node) {
          $calculateBarycenter(this$static, fixedNode, forward_0);
          this$static.barycenterState[node.layer.id_0][node.id_0].degree += this$static.barycenterState[fixedNode.layer.id_0][fixedNode.id_0].degree;
          this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight += this$static.barycenterState[fixedNode.layer.id_0][fixedNode.id_0].summedWeight;
        }
      }
       else {
        this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight += this$static.portRanks[fixedPort.id_0];
        ++this$static.barycenterState[node.layer.id_0][node.id_0].degree;
      }
    }
  }
  barycenterAssociates = castTo($getProperty(node, ($clinit_InternalProperties_1() , BARYCENTER_ASSOCIATES)), 15);
  if (barycenterAssociates) {
    for (associate$iterator = barycenterAssociates.iterator_0(); associate$iterator.hasNext_0();) {
      associate = castTo(associate$iterator.next_1(), 9);
      if (node.layer == associate.layer) {
        $calculateBarycenter(this$static, associate, forward_0);
        this$static.barycenterState[node.layer.id_0][node.id_0].degree += this$static.barycenterState[associate.layer.id_0][associate.id_0].degree;
        this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight += this$static.barycenterState[associate.layer.id_0][associate.id_0].summedWeight;
      }
    }
  }
  if (this$static.barycenterState[node.layer.id_0][node.id_0].degree > 0) {
    this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight += $nextInternal(this$static.random_0, 24) * $intern_84 * 0.07000000029802322 - 0.03500000014901161;
    this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight / this$static.barycenterState[node.layer.id_0][node.id_0].degree;
  }
}

function $calculateBarycenters(this$static, nodes, forward_0){
  var node, node$iterator, node$iterator0;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    this$static.barycenterState[node.layer.id_0][node.id_0].visited = false;
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $calculateBarycenter(this$static, node, forward_0);
  }
}

function $fillInUnknownBarycenters(this$static, nodes, preOrdered){
  var lastValue, maxBary, nextNodeIterator, nextValue, node, node$iterator, node$iterator0, nodesIterator, value_0, x_0;
  if (preOrdered) {
    lastValue = -1;
    nodesIterator = new AbstractList$ListIteratorImpl(nodes, 0);
    while (nodesIterator.i < nodesIterator.this$01_0.size_1()) {
      node = (checkCriticalElement(nodesIterator.i < nodesIterator.this$01_0.size_1()) , castTo(nodesIterator.this$01_0.get_3(nodesIterator.last = nodesIterator.i++), 9));
      value_0 = this$static.barycenterState[node.layer.id_0][node.id_0].barycenter;
      if (value_0 == null) {
        nextValue = lastValue + 1;
        nextNodeIterator = new AbstractList$ListIteratorImpl(nodes, nodesIterator.i);
        while (nextNodeIterator.i < nextNodeIterator.this$01_0.size_1()) {
          x_0 = $stateOf(this$static, (checkCriticalElement(nextNodeIterator.i < nextNodeIterator.this$01_0.size_1()) , castTo(nextNodeIterator.this$01_0.get_3(nextNodeIterator.last = nextNodeIterator.i++), 9))).barycenter;
          if (x_0 != null) {
            nextValue = (checkCriticalNotNull(x_0) , x_0);
            break;
          }
        }
        value_0 = (lastValue + nextValue) / 2;
        this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = value_0;
        this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight = (checkCriticalNotNull(value_0) , value_0);
        this$static.barycenterState[node.layer.id_0][node.id_0].degree = 1;
      }
      lastValue = (checkCriticalNotNull(value_0) , value_0);
    }
  }
   else {
    maxBary = 0;
    for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      this$static.barycenterState[node.layer.id_0][node.id_0].barycenter != null && (maxBary = $wnd.Math.max(maxBary, checkNotNull_1(this$static.barycenterState[node.layer.id_0][node.id_0].barycenter)));
    }
    maxBary += 2;
    for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (this$static.barycenterState[node.layer.id_0][node.id_0].barycenter == null) {
        value_0 = $nextInternal(this$static.random_0, 24) * $intern_84 * maxBary - 1;
        this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = value_0;
        this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight = value_0;
        this$static.barycenterState[node.layer.id_0][node.id_0].degree = 1;
      }
    }
  }
}

function $lambda$0_7(this$static, n1_0, n2_1){
  var s1, s2;
  s1 = this$static.barycenterState[n1_0.layer.id_0][n1_0.id_0];
  s2 = this$static.barycenterState[n2_1.layer.id_0][n2_1.id_0];
  if (s1.barycenter != null && s2.barycenter != null) {
    return $compareTo_4(s1.barycenter, s2.barycenter);
  }
   else if (s1.barycenter != null) {
    return -1;
  }
   else if (s2.barycenter != null) {
    return 1;
  }
  return 0;
}

function $minimizeCrossings(this$static, layer, preOrdered, randomize, forward_0){
  if (randomize) {
    $randomizeBarycenters(this$static, layer);
  }
   else {
    $calculateBarycenters(this$static, layer, forward_0);
    $fillInUnknownBarycenters(this$static, layer, preOrdered);
  }
  if (layer.array.length > 1) {
    $clinit_Collections();
    $sort(layer, this$static.barycenterStateComparator);
    $processConstraints(this$static.constraintResolver, layer);
  }
}

function $randomizeBarycenters(this$static, nodes){
  var node, node$iterator;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    this$static.barycenterState[node.layer.id_0][node.id_0].barycenter = $nextDouble(this$static.random_0);
    this$static.barycenterState[node.layer.id_0][node.id_0].summedWeight = checkNotNull_1(this$static.barycenterState[node.layer.id_0][node.id_0].barycenter);
    this$static.barycenterState[node.layer.id_0][node.id_0].degree = 1;
  }
}

function $startIndex_0(dir_0, length_0){
  return dir_0?0:0 > length_0 - 1?0:length_0 - 1;
}

function $stateOf(this$static, node){
  return this$static.barycenterState[node.layer.id_0][node.id_0];
}

function BarycenterHeuristic(constraintResolver, random, portDistributor){
  this.barycenterStateComparator = new BarycenterHeuristic$lambda$0$Type(this);
  this.constraintResolver = constraintResolver;
  this.random_0 = random;
  this.portDistributor = portDistributor;
}

defineClass(1610, 1, $intern_115, BarycenterHeuristic);
_.initAtEdgeLevel = function initAtEdgeLevel_1(l, n, p, e, edge, nodeOrder){
}
;
_.initAtNodeLevel = function initAtNodeLevel_1(l, n, nodeOrder){
}
;
_.initAtPortLevel = function initAtPortLevel_1(l, n, p, nodeOrder){
}
;
_.alwaysImproves = function alwaysImproves_0(){
  return false;
}
;
_.initAfterTraversal = function initAfterTraversal_1(){
  this.barycenterState = this.constraintResolver.barycenterStates;
  this.portRanks = this.portDistributor.portRanks;
}
;
_.initAtLayerLevel = function initAtLayerLevel_1(l, nodeOrder){
  nodeOrder[l][0].layer.id_0 = l;
}
;
_.isDeterministic = function isDeterministic_0(){
  return false;
}
;
_.minimizeCrossings = function minimizeCrossings_0(order, freeLayerIndex, forwardSweep, isFirstSweep){
  var firstNodeInLayer, fixedLayer, index_0, nodeGroup, nodeGroup$iterator, nodes, preOrdered;
  if (freeLayerIndex != $startIndex_0(forwardSweep, order.length)) {
    fixedLayer = order[freeLayerIndex - (forwardSweep?1:-1)];
    $calculatePortRanks(this.portDistributor, fixedLayer, forwardSweep?($clinit_PortType() , OUTPUT):($clinit_PortType() , INPUT));
  }
  firstNodeInLayer = order[freeLayerIndex][0];
  preOrdered = !isFirstSweep || firstNodeInLayer.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT);
  nodes = newArrayList_1(order[freeLayerIndex]);
  $minimizeCrossings(this, nodes, preOrdered, false, forwardSweep);
  index_0 = 0;
  for (nodeGroup$iterator = new ArrayList$1(nodes); nodeGroup$iterator.i < nodeGroup$iterator.this$01.array.length;) {
    nodeGroup = castTo($next_10(nodeGroup$iterator), 9);
    order[freeLayerIndex][index_0++] = nodeGroup;
  }
  return false;
}
;
_.setFirstLayerOrder = function setFirstLayerOrder_0(order, isForwardSweep){
  var index_0, nodeGroup, nodeGroup$iterator, nodes, startIndex;
  startIndex = $startIndex_0(isForwardSweep, order.length);
  nodes = newArrayList_1(order[startIndex]);
  $minimizeCrossings(this, nodes, false, true, isForwardSweep);
  index_0 = 0;
  for (nodeGroup$iterator = new ArrayList$1(nodes); nodeGroup$iterator.i < nodeGroup$iterator.this$01.array.length;) {
    nodeGroup = castTo($next_10(nodeGroup$iterator), 9);
    order[startIndex][index_0++] = nodeGroup;
  }
  return false;
}
;
var Lorg_eclipse_elk_alg_layered_p3order_BarycenterHeuristic_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'BarycenterHeuristic', 1610);
function BarycenterHeuristic$BarycenterState(node){
  this.node = node;
}

defineClass(618, 1, {618:1}, BarycenterHeuristic$BarycenterState);
_.toString_0 = function toString_97(){
  return 'BarycenterState [node=' + this.node + ', summedWeight=' + this.summedWeight + ', degree=' + this.degree + ', barycenter=' + this.barycenter + ', visited=' + this.visited + ']';
}
;
_.degree = 0;
_.summedWeight = 0;
_.visited = false;
var Lorg_eclipse_elk_alg_layered_p3order_BarycenterHeuristic$BarycenterState_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'BarycenterHeuristic/BarycenterState', 618);
function BarycenterHeuristic$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1611, 1, $intern_40, BarycenterHeuristic$lambda$0$Type);
_.equals_0 = function equals_145(other){
  return this === other;
}
;
_.reversed = function reversed_50(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_58(arg0, arg1){
  return $lambda$0_7(this.$$outer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_BarycenterHeuristic$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'BarycenterHeuristic/lambda$0$Type', 1611);
function $buildConstraintsGraph(this$static, groups){
  var currentUnitNode, currentUnitNode$iterator, group, group$iterator, group$iterator0, lastNonDummyNode, lastUnitNode, lastUnitNode$iterator, node, successor, successor$iterator;
  for (group$iterator0 = new ArrayList$1(groups); group$iterator0.i < group$iterator0.this$01.array.length;) {
    group = castTo($next_10(group$iterator0), 213);
    group.outgoingConstraints = null;
    group.incomingConstraintsCount = 0;
  }
  lastNonDummyNode = null;
  for (group$iterator = new ArrayList$1(groups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 213);
    node = group.nodes[0];
    for (successor$iterator = castTo($getProperty(node, ($clinit_InternalProperties_1() , IN_LAYER_SUCCESSOR_CONSTRAINTS)), 15).iterator_0(); successor$iterator.hasNext_0();) {
      successor = castTo(successor$iterator.next_1(), 9);
      (!group.outgoingConstraints && (group.outgoingConstraints = new ArrayList) , group.outgoingConstraints).add_1(this$static.constraintGroups[successor.layer.id_0][successor.id_0]);
      ++this$static.constraintGroups[successor.layer.id_0][successor.id_0].incomingConstraintsCount;
    }
    if (node.type_0 == ($clinit_LNode$NodeType() , NORMAL)) {
      if (lastNonDummyNode) {
        for (lastUnitNode$iterator = castTo($get_0(this$static.layoutUnits, lastNonDummyNode), 19).iterator_0(); lastUnitNode$iterator.hasNext_0();) {
          lastUnitNode = castTo(lastUnitNode$iterator.next_1(), 9);
          for (currentUnitNode$iterator = castTo($get_0(this$static.layoutUnits, node), 19).iterator_0(); currentUnitNode$iterator.hasNext_0();) {
            currentUnitNode = castTo(currentUnitNode$iterator.next_1(), 9);
            $getOutgoingConstraints(this$static.constraintGroups[lastUnitNode.layer.id_0][lastUnitNode.id_0]).add_1(this$static.constraintGroups[currentUnitNode.layer.id_0][currentUnitNode.id_0]);
            ++this$static.constraintGroups[currentUnitNode.layer.id_0][currentUnitNode.id_0].incomingConstraintsCount;
          }
        }
      }
      lastNonDummyNode = node;
    }
  }
}

function $findViolatedConstraint(groups){
  var activeGroups, group, group$iterator, predecessor, predecessor$iterator, successor, successor$iterator, successorIncomingList;
  activeGroups = null;
  for (group$iterator = new ArrayList$1(groups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 213);
    checkNotNull_1($stateOf_0(group.this$01, group.nodes[0]).barycenter);
    group.incomingConstraints = null;
    if (!!group.outgoingConstraints && group.outgoingConstraints.size_1() > 0 && group.incomingConstraintsCount == 0) {
      !activeGroups && (activeGroups = new ArrayList);
      activeGroups.array[activeGroups.array.length] = group;
    }
  }
  if (activeGroups) {
    while (activeGroups.array.length != 0) {
      group = castTo($remove_12(activeGroups, 0), 213);
      if (!!group.incomingConstraints && group.incomingConstraints.array.length > 0) {
        for (predecessor$iterator = (!group.incomingConstraints && (group.incomingConstraints = new ArrayList) , new ArrayList$1(group.incomingConstraints)); predecessor$iterator.i < predecessor$iterator.this$01.array.length;) {
          predecessor = castTo($next_10(predecessor$iterator), 213);
          if (checkNotNull_1($stateOf_0(predecessor.this$01, predecessor.nodes[0]).barycenter) == checkNotNull_1($stateOf_0(group.this$01, group.nodes[0]).barycenter)) {
            if ($indexOf_3(groups, predecessor, 0) > $indexOf_3(groups, group, 0)) {
              return new Pair(predecessor, group);
            }
          }
           else if (checkNotNull_1($stateOf_0(predecessor.this$01, predecessor.nodes[0]).barycenter) > checkNotNull_1($stateOf_0(group.this$01, group.nodes[0]).barycenter)) {
            return new Pair(predecessor, group);
          }
        }
      }
      for (successor$iterator = (!group.outgoingConstraints && (group.outgoingConstraints = new ArrayList) , group.outgoingConstraints).iterator_0(); successor$iterator.hasNext_0();) {
        successor = castTo(successor$iterator.next_1(), 213);
        successorIncomingList = (!successor.incomingConstraints && (successor.incomingConstraints = new ArrayList) , successor.incomingConstraints);
        checkCriticalPositionIndex(0, successorIncomingList.array.length);
        insertTo(successorIncomingList.array, 0, group);
        successor.incomingConstraintsCount == successorIncomingList.array.length && (activeGroups.array[activeGroups.array.length] = successor , true);
      }
    }
  }
  return null;
}

function $handleViolatedConstraint(this$static, firstNodeGroup, secondNodeGroup, nodeGroups){
  var alreadyInserted, firstNodeGroupConstraint, newNodeGroup, nodeGroup, nodeGroupIterator, secondNodeGroupConstraint;
  newNodeGroup = new ForsterConstraintResolver$ConstraintGroup_0(this$static, firstNodeGroup, secondNodeGroup);
  nodeGroupIterator = new AbstractList$ListIteratorImpl(nodeGroups, 0);
  alreadyInserted = false;
  while (nodeGroupIterator.i < nodeGroupIterator.this$01_0.size_1()) {
    nodeGroup = (checkCriticalElement(nodeGroupIterator.i < nodeGroupIterator.this$01_0.size_1()) , castTo(nodeGroupIterator.this$01_0.get_3(nodeGroupIterator.last = nodeGroupIterator.i++), 213));
    if (nodeGroup == firstNodeGroup || nodeGroup == secondNodeGroup) {
      $remove_9(nodeGroupIterator);
    }
     else if (!alreadyInserted && checkNotNull_1($stateOf_0(nodeGroup.this$01, nodeGroup.nodes[0]).barycenter) > checkNotNull_1($stateOf_0(newNodeGroup.this$01, newNodeGroup.nodes[0]).barycenter)) {
      checkCriticalElement(nodeGroupIterator.i > 0);
      nodeGroupIterator.this$01.get_3(nodeGroupIterator.last = --nodeGroupIterator.i);
      $add_2(nodeGroupIterator, newNodeGroup);
      alreadyInserted = true;
    }
     else if (!!nodeGroup.outgoingConstraints && nodeGroup.outgoingConstraints.size_1() > 0) {
      firstNodeGroupConstraint = (!nodeGroup.outgoingConstraints && (nodeGroup.outgoingConstraints = new ArrayList) , nodeGroup.outgoingConstraints).remove_1(firstNodeGroup);
      secondNodeGroupConstraint = (!nodeGroup.outgoingConstraints && (nodeGroup.outgoingConstraints = new ArrayList) , nodeGroup.outgoingConstraints).remove_1(secondNodeGroup);
      if (firstNodeGroupConstraint || secondNodeGroupConstraint) {
        (!nodeGroup.outgoingConstraints && (nodeGroup.outgoingConstraints = new ArrayList) , nodeGroup.outgoingConstraints).add_1(newNodeGroup);
        ++newNodeGroup.incomingConstraintsCount;
      }
    }
  }
  alreadyInserted || (nodeGroups.array[nodeGroups.array.length] = newNodeGroup , true);
}

function $processConstraints(this$static, nodes){
  var group, group$iterator, groups, node, node$array, node$index, node$iterator, node$max, violatedConstraint;
  groups = new ArrayList;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    $add_4(groups, this$static.constraintGroups[node.layer.id_0][node.id_0]);
  }
  $buildConstraintsGraph(this$static, groups);
  while (violatedConstraint = $findViolatedConstraint(groups)) {
    $handleViolatedConstraint(this$static, castTo(violatedConstraint.first, 213), castTo(violatedConstraint.second, 213), groups);
  }
  nodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  for (group$iterator = new ArrayList$1(groups); group$iterator.i < group$iterator.this$01.array.length;) {
    group = castTo($next_10(group$iterator), 213);
    for (node$array = group.nodes , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
      node = node$array[node$index];
      nodes.array[nodes.array.length] = node;
      this$static.barycenterStates[node.layer.id_0][node.id_0].barycenter = $stateOf_0(group.this$01, group.nodes[0]).barycenter;
    }
  }
}

function $stateOf_0(this$static, node){
  return this$static.barycenterStates[node.layer.id_0][node.id_0];
}

function ForsterConstraintResolver(currentNodeOrder){
  this.barycenterStates = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_BarycenterHeuristic$BarycenterState_2_classLit, $intern_33, 1786, currentNodeOrder.length, 0, 2);
  this.constraintGroups = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_ForsterConstraintResolver$ConstraintGroup_2_classLit, $intern_33, 1787, currentNodeOrder.length, 0, 2);
  this.layoutUnits = new LinkedHashMultimap;
}

defineClass(1605, 1, $intern_115, ForsterConstraintResolver);
_.initAfterTraversal = function initAfterTraversal_2(){
}
;
_.initAtEdgeLevel = function initAtEdgeLevel_2(l, n, p, e, edge, nodeOrder){
}
;
_.initAtPortLevel = function initAtPortLevel_2(l, n, p, nodeOrder){
}
;
_.initAtLayerLevel = function initAtLayerLevel_2(l, nodeOrder){
  this.barycenterStates[l] = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_BarycenterHeuristic$BarycenterState_2_classLit, {3:1, 4:1, 5:1, 1786:1}, 618, nodeOrder[l].length, 0, 1);
  this.constraintGroups[l] = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_ForsterConstraintResolver$ConstraintGroup_2_classLit, {3:1, 4:1, 5:1, 1787:1}, 213, nodeOrder[l].length, 0, 1);
}
;
_.initAtNodeLevel = function initAtNodeLevel_2(l, n, nodeOrder){
  var layoutUnit, node;
  node = nodeOrder[l][n];
  this.barycenterStates[l][n] = new BarycenterHeuristic$BarycenterState(node);
  this.constraintGroups[l][n] = new ForsterConstraintResolver$ConstraintGroup(this, node);
  layoutUnit = castTo($getProperty(node, ($clinit_InternalProperties_1() , IN_LAYER_LAYOUT_UNIT)), 9);
  !!layoutUnit && $put(this.layoutUnits, layoutUnit, node);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_ForsterConstraintResolver_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'ForsterConstraintResolver', 1605);
function $getOutgoingConstraints(this$static){
  !this$static.outgoingConstraints && (this$static.outgoingConstraints = new ArrayList);
  return this$static.outgoingConstraints;
}

function $setBarycenter(this$static, barycenter){
  var node, node$array, node$index, node$max;
  for (node$array = this$static.nodes , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    $stateOf_0(this$static.this$01, node).barycenter = barycenter;
  }
}

function ForsterConstraintResolver$ConstraintGroup(this$0, node){
  this.this$01 = this$0;
  this.nodes = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, 1), $intern_109, 9, 0, [node]);
}

function ForsterConstraintResolver$ConstraintGroup_0(this$0, nodeGroup1, nodeGroup2){
  var candidate, candidate$iterator, i, i0, length1, length2;
  this.this$01 = this$0;
  length1 = nodeGroup1.nodes.length;
  length2 = nodeGroup2.nodes.length;
  this.nodes = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, length1 + length2, 0, 1);
  for (i0 = 0; i0 < length1; i0++) {
    this.nodes[i0] = nodeGroup1.nodes[i0];
  }
  for (i = 0; i < length2; i++) {
    this.nodes[length1 + i] = nodeGroup2.nodes[i];
  }
  if (nodeGroup1.outgoingConstraints) {
    this.outgoingConstraints = newLinkedList(nodeGroup1.outgoingConstraints);
    this.outgoingConstraints.remove_1(nodeGroup2);
    if (nodeGroup2.outgoingConstraints) {
      for (candidate$iterator = nodeGroup2.outgoingConstraints.iterator_0(); candidate$iterator.hasNext_0();) {
        candidate = castTo(candidate$iterator.next_1(), 213);
        if (candidate == nodeGroup1) {
          continue;
        }
         else 
          this.outgoingConstraints.contains(candidate)?--candidate.incomingConstraintsCount:this.outgoingConstraints.add_1(candidate);
      }
    }
  }
   else if (nodeGroup2.outgoingConstraints) {
    this.outgoingConstraints = newLinkedList(nodeGroup2.outgoingConstraints);
    this.outgoingConstraints.remove_1(nodeGroup1);
  }
  this.summedWeight = nodeGroup1.summedWeight + nodeGroup2.summedWeight;
  this.degree = nodeGroup1.degree + nodeGroup2.degree;
  this.degree > 0?$setBarycenter(this, this.summedWeight / this.degree):$stateOf_0(nodeGroup1.this$01, nodeGroup1.nodes[0]).barycenter != null && $stateOf_0(nodeGroup2.this$01, nodeGroup2.nodes[0]).barycenter != null?$setBarycenter(this, (checkNotNull_1($stateOf_0(nodeGroup1.this$01, nodeGroup1.nodes[0]).barycenter) + checkNotNull_1($stateOf_0(nodeGroup2.this$01, nodeGroup2.nodes[0]).barycenter)) / 2):$stateOf_0(nodeGroup1.this$01, nodeGroup1.nodes[0]).barycenter != null?$setBarycenter(this, $stateOf_0(nodeGroup1.this$01, nodeGroup1.nodes[0]).barycenter):$stateOf_0(nodeGroup2.this$01, nodeGroup2.nodes[0]).barycenter != null && $setBarycenter(this, $stateOf_0(nodeGroup2.this$01, nodeGroup2.nodes[0]).barycenter);
}

defineClass(213, 1, {213:1}, ForsterConstraintResolver$ConstraintGroup, ForsterConstraintResolver$ConstraintGroup_0);
_.toString_0 = function toString_98(){
  var i, sb;
  sb = new StringBuilder;
  sb.string += '[';
  for (i = 0; i < this.nodes.length; i++) {
    $append_11(sb, $toString_9(this.nodes[i]));
    $stateOf_0(this.this$01, this.nodes[0]).barycenter != null && $append_11($append_11((sb.string += '<' , sb), '' + checkNotNull_1($stateOf_0(this.this$01, this.nodes[0]).barycenter)), '>');
    i < this.nodes.length - 1 && (sb.string += ', ' , sb);
  }
  return (sb.string += ']' , sb).string;
}
;
_.degree = 0;
_.incomingConstraintsCount = 0;
_.summedWeight = 0;
var Lorg_eclipse_elk_alg_layered_p3order_ForsterConstraintResolver$ConstraintGroup_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'ForsterConstraintResolver/ConstraintGroup', 213);
function $setBestNodeNPortOrder(this$static, bestNodeNPortOrder){
  this$static.bestNodeAndPortOrder = bestNodeNPortOrder;
}

function $setCurrentlyBestNodeAndPortOrder(this$static, currentlyBestNodeAndPortOrder){
  this$static.currentlyBestNodeAndPortOrder = currentlyBestNodeAndPortOrder;
}

function GraphInfoHolder(graph, crossMinType, graphs){
  var constraintResolver, graphProperties, initializables, random;
  this.lGraph = graph;
  this.currentNodeOrder = $toNodeArray(graph);
  this.parent_0 = castTo($getProperty(this.lGraph, ($clinit_InternalProperties_1() , PARENT_LNODE)), 9);
  this.hasParent = !!this.parent_0;
  this.parentGraphData = this.hasParent?castTo($get_7(graphs, $getGraph(this.parent_0).id_0), 212):null;
  graphProperties = castTo($getProperty(graph, GRAPH_PROPERTIES), 19);
  this.hasExternalPorts = graphProperties.contains(($clinit_GraphProperties() , EXTERNAL_PORTS));
  this.childGraphs = new ArrayList;
  this.crossingsCounter = new AllCrossingsCounter(this.currentNodeOrder);
  random = castTo($getProperty(this.lGraph, RANDOM_0), 221);
  this.portDistributor = create_16(crossMinType, random, this.currentNodeOrder);
  this.layerSweepTypeDecider = new LayerSweepTypeDecider(this);
  initializables = newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p3order_counting_IInitializable_2_classLit, 1), $intern_1, 215, 0, [this, this.crossingsCounter, this.layerSweepTypeDecider, this.portDistributor]));
  if (crossMinType == ($clinit_LayerSweepCrossingMinimizer$CrossMinType() , BARYCENTER)) {
    constraintResolver = new ForsterConstraintResolver(this.currentNodeOrder);
    initializables.array[initializables.array.length] = constraintResolver;
    this.crossMinimizer = new BarycenterHeuristic(constraintResolver, random, castTo(this.portDistributor, 433));
  }
   else {
    this.crossMinimizer = new GreedySwitchHeuristic(crossMinType, this);
  }
  $add_4(initializables, this.crossMinimizer);
  init_0(initializables, this.currentNodeOrder);
  this.useBottomUp = $useBottomUp(this.layerSweepTypeDecider);
}

defineClass(212, 1, {212:1, 215:1}, GraphInfoHolder);
_.initAtEdgeLevel = function initAtEdgeLevel_3(l, n, p, e, edge, nodeOrder){
}
;
_.initAtLayerLevel = function initAtLayerLevel_3(l, nodeOrderr){
}
;
_.initAfterTraversal = function initAfterTraversal_3(){
  this.portPositions = initUnidimensionalArray(I_classLit, $intern_49, 23, this.nPorts, 15, 1);
}
;
_.initAtNodeLevel = function initAtNodeLevel_3(l, n, nodeOrder){
  var nestedGraph, node;
  node = nodeOrder[l][n];
  nestedGraph = castTo($getProperty(node, ($clinit_InternalProperties_1() , NESTED_LGRAPH)), 32);
  !!nestedGraph && $add_4(this.childGraphs, nestedGraph);
}
;
_.initAtPortLevel = function initAtPortLevel_3(l, n, p, nodeOrder){
  ++this.nPorts;
}
;
_.toString_0 = function toString_99(){
  return deepToString(this.currentNodeOrder, new HashSet);
}
;
_.hasExternalPorts = false;
_.hasParent = false;
_.nPorts = 0;
_.useBottomUp = false;
var Lorg_eclipse_elk_alg_layered_p3order_GraphInfoHolder_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'GraphInfoHolder', 212);
function $distributePortsInLayer(this$static, nodeOrder, currentIndex, isForwardSweep){
  var improved, innerGraph, nestedGraph, node, node$array, node$index, node$max, side, useHierarchicalCrossCounter;
  side = isForwardSweep?($clinit_PortSide() , WEST_1):($clinit_PortSide() , EAST_1);
  improved = false;
  for (node$array = nodeOrder[currentIndex] , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    if ($isOrderFixed(castTo($getProperty(node, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83))) {
      continue;
    }
    nestedGraph = castTo($getProperty(node, ($clinit_InternalProperties_1() , NESTED_LGRAPH)), 32);
    useHierarchicalCrossCounter = !$getPortSideView(node, side).isEmpty() && !!nestedGraph;
    if (useHierarchicalCrossCounter) {
      innerGraph = $toNodeArray(nestedGraph);
      this$static.hierarchicalCrossingsCounter = new BetweenLayerEdgeTwoNodeCrossingsCounter(innerGraph, isForwardSweep?0:innerGraph.length - 1);
    }
    improved = improved | $distributePortsOnNode(this$static, node, side, useHierarchicalCrossCounter);
  }
  return improved;
}

function $distributePortsOnNode(this$static, node, side, useHierarchicalCrosscounter){
  var continueSwitching, i, improved, lowerPort, ports, upperPort, lower;
  ports = $getPortSideView(node, side);
  (side == ($clinit_PortSide() , SOUTH_1) || side == WEST_1) && (ports = instanceOf(ports, 166)?$reverse(castTo(ports, 166)):instanceOf(ports, 138)?castTo(ports, 138).forwardList:instanceOf(ports, 50)?new Lists$RandomAccessReverseList(ports):new Lists$ReverseList(ports));
  improved = false;
  do {
    continueSwitching = false;
    for (i = 0; i < ports.size_1() - 1; i++) {
      upperPort = castTo(ports.get_3(i), 11);
      lowerPort = castTo(ports.get_3(i + 1), 11);
      if ($switchingDecreasesCrossings(this$static, upperPort, lowerPort, useHierarchicalCrosscounter)) {
        improved = true;
        $switchPorts(this$static.crossingsCounter, castTo(ports.get_3(i), 11), castTo(ports.get_3(i + 1), 11));
        lower = castTo(ports.get_3(i + 1), 11);
        ports.set_2(i + 1, castTo(ports.get_3(i), 11));
        ports.set_2(i, lower);
        continueSwitching = true;
      }
    }
  }
   while (continueSwitching);
  return improved;
}

function $switchingDecreasesCrossings(this$static, upperPort, lowerPort, useHierarchicalCrosscounter){
  var lowerNode, lowerUpperCrossings, originalNSwitchedCrossings, upperLowerCrossings, upperNode;
  originalNSwitchedCrossings = $countCrossingsBetweenPortsInBothOrders(this$static.crossingsCounter, upperPort, lowerPort);
  upperLowerCrossings = castTo(originalNSwitchedCrossings.first, 21).value_0;
  lowerUpperCrossings = castTo(originalNSwitchedCrossings.second, 21).value_0;
  if (useHierarchicalCrosscounter) {
    upperNode = castTo($getProperty(upperPort, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
    lowerNode = castTo($getProperty(lowerPort, PORT_DUMMY), 9);
    if (!!upperNode && !!lowerNode) {
      $countBothSideCrossings(this$static.hierarchicalCrossingsCounter, upperNode, lowerNode);
      upperLowerCrossings += this$static.hierarchicalCrossingsCounter.upperLowerCrossings;
      lowerUpperCrossings += this$static.hierarchicalCrossingsCounter.lowerUpperCrossings;
    }
  }
  return upperLowerCrossings > lowerUpperCrossings;
}

function GreedyPortDistributor(){
}

defineClass(1620, 1, $intern_115, GreedyPortDistributor);
_.initAtEdgeLevel = function initAtEdgeLevel_4(l, n, p, e, edge, nodeOrder){
}
;
_.initAtLayerLevel = function initAtLayerLevel_4(l, nodeOrderr){
}
;
_.initAtPortLevel = function initAtPortLevel_4(l, n, p, nodeOrder){
}
;
_.distributePortsWhileSweeping = function distributePortsWhileSweeping_0(nodeOrder, currentIndex, isForwardSweep){
  isForwardSweep && currentIndex > 0?($initForCountingBetween(this.crossingsCounter, nodeOrder[currentIndex - 1], nodeOrder[currentIndex]) , undefined):!isForwardSweep && currentIndex < nodeOrder.length - 1?($initForCountingBetween(this.crossingsCounter, nodeOrder[currentIndex], nodeOrder[currentIndex + 1]) , undefined):$initPortPositionsForInLayerCrossings(this.crossingsCounter, nodeOrder[currentIndex], isForwardSweep?($clinit_PortSide() , WEST_1):($clinit_PortSide() , EAST_1));
  return $distributePortsInLayer(this, nodeOrder, currentIndex, isForwardSweep);
}
;
_.initAfterTraversal = function initAfterTraversal_4(){
  this.portPos = initUnidimensionalArray(I_classLit, $intern_49, 23, this.nPorts, 15, 1);
  this.crossingsCounter = new CrossingsCounter(this.portPos);
}
;
_.initAtNodeLevel = function initAtNodeLevel_4(l, n, nodeOrder){
  var node;
  node = nodeOrder[l][n];
  this.nPorts += node.ports.array.length;
}
;
_.nPorts = 0;
var Lorg_eclipse_elk_alg_layered_p3order_GreedyPortDistributor_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'GreedyPortDistributor', 1620);
function $clinit_InteractiveCrossingMinimizer(){
  $clinit_InteractiveCrossingMinimizer = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION_2 = $addAfter($addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , LONG_EDGE_SPLITTER)), P4_NODE_PLACEMENT, IN_LAYER_CONSTRAINT_PROCESSOR), P5_EDGE_ROUTING, LONG_EDGE_JOINER);
}

function $getLayoutProcessorConfiguration_1(graph){
  var configuration;
  configuration = createFrom_0(INTERMEDIATE_PROCESSING_CONFIGURATION_2);
  castTo($getProperty(graph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , NON_FREE_PORTS)) && $addBefore(configuration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , PORT_LIST_SORTER));
  return configuration;
}

function $getPos(node, horizPos){
  var bendpoints, edge, originNode, originPort, point1, point2, pointIter, source, sourcePoint, target, targetPoint;
  switch (node.type_0.ordinal) {
    case 1:
      edge = castTo($getProperty(node, ($clinit_InternalProperties_1() , ORIGIN_0)), 16);
      bendpoints = castTo($getProperty(edge, ORIGINAL_BENDPOINTS), 74);
      !bendpoints?(bendpoints = new KVectorChain):checkNotNull_1(castToBoolean($getProperty(edge, REVERSED))) && (bendpoints = reverse_3(bendpoints));
      source = castTo($getProperty(node, LONG_EDGE_SOURCE), 11);
      if (source) {
        sourcePoint = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [source.owner.pos, source.pos, source.anchor]));
        if (horizPos <= sourcePoint.x_0) {
          return sourcePoint.y_0;
        }
        $addNode_0(bendpoints, sourcePoint, bendpoints.header, bendpoints.header.next_0);
      }

      target = castTo($getProperty(node, LONG_EDGE_TARGET), 11);
      if (target) {
        targetPoint = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [target.owner.pos, target.pos, target.anchor]));
        if (targetPoint.x_0 <= horizPos) {
          return targetPoint.y_0;
        }
        $addNode_0(bendpoints, targetPoint, bendpoints.tail.prev, bendpoints.tail);
      }

      if (bendpoints.size_0 >= 2) {
        pointIter = $listIterator_1(bendpoints, 0);
        point1 = castTo($next_13(pointIter), 8);
        point2 = castTo($next_13(pointIter), 8);
        while (point2.x_0 < horizPos && pointIter.currentNode != pointIter.this$01.tail) {
          point1 = point2;
          point2 = castTo($next_13(pointIter), 8);
        }
        return point1.y_0 + (horizPos - point1.x_0) / (point2.x_0 - point1.x_0) * (point2.y_0 - point1.y_0);
      }

      break;
    case 3:
      originPort = castTo($getProperty(castTo($get_7(node.ports, 0), 11), ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
      originNode = originPort.owner;
      switch (originPort.side.ordinal) {
        case 1:
          return originNode.pos.y_0;
        case 3:
          return originNode.pos.y_0 + originNode.size_0.y_0;
      }

  }
  return $getInteractiveReferencePoint(node).y_0;
}

function $process_66(layeredGraph, monitor){
  var horizPos, layer, layer$iterator, layer$iterator0, layerIndex, nextIndex, node, node$iterator, node$iterator0, nodeCount, nodeOrder, port, port$iterator, portCount, portDistributor, pos;
  $begin(monitor, 'Interactive crossing minimization', 1);
  layerIndex = 0;
  for (layer$iterator0 = new ArrayList$1(layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator0), 25);
    layer.id_0 = layerIndex++;
  }
  nodeOrder = $toNodeArray(layeredGraph);
  portDistributor = new NodeRelativePortDistributor(nodeOrder.length);
  init_0(new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p3order_counting_IInitializable_2_classLit, 1), $intern_1, 215, 0, [portDistributor])), nodeOrder);
  portCount = 0;
  layerIndex = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    horizPos = 0;
    nodeCount = 0;
    for (node$iterator0 = new ArrayList$1(layer.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      if (node.pos.x_0 > 0) {
        horizPos += node.pos.x_0 + node.size_0.x_0 / 2;
        ++nodeCount;
      }
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_10(port$iterator), 11);
        port.id_0 = portCount++;
      }
    }
    horizPos /= nodeCount;
    pos = initUnidimensionalArray(D_classLit, $intern_69, 23, layer.nodes.array.length, 15, 1);
    nextIndex = 0;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      node.id_0 = nextIndex++;
      pos[node.id_0] = $getPos(node, horizPos);
      node.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE) && $setProperty_0(node, ($clinit_InternalProperties_1() , ORIGINAL_DUMMY_NODE_POSITION), pos[node.id_0]);
    }
    $clinit_Collections();
    $sort(layer.nodes, new InteractiveCrossingMinimizer$1(pos));
    $distributePortsWhileSweeping(portDistributor, nodeOrder, layerIndex, true);
    ++layerIndex;
  }
  $done_0(monitor);
}

function InteractiveCrossingMinimizer(){
  $clinit_InteractiveCrossingMinimizer();
}

defineClass(1273, 1, $intern_117, InteractiveCrossingMinimizer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_8(graph){
  return $getLayoutProcessorConfiguration_1(castTo(graph, 32));
}
;
_.process = function process_61(layeredGraph, monitor){
  $process_66(castTo(layeredGraph, 32), monitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIGURATION_2;
var Lorg_eclipse_elk_alg_layered_p3order_InteractiveCrossingMinimizer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'InteractiveCrossingMinimizer', 1273);
function $compare_19(this$static, node1, node2){
  var compare, node1Successors, node2Successors;
  compare = compare_5(this$static.val$pos2[node1.id_0], this$static.val$pos2[node2.id_0]);
  if (compare == 0) {
    node1Successors = castTo($getProperty(node1, ($clinit_InternalProperties_1() , IN_LAYER_SUCCESSOR_CONSTRAINTS)), 15);
    node2Successors = castTo($getProperty(node2, IN_LAYER_SUCCESSOR_CONSTRAINTS), 15);
    if (node1Successors.contains(node2)) {
      return -1;
    }
     else if (node2Successors.contains(node1)) {
      return 1;
    }
  }
  return compare;
}

function InteractiveCrossingMinimizer$1(val$pos){
  this.val$pos2 = val$pos;
}

defineClass(1274, 1, $intern_40, InteractiveCrossingMinimizer$1);
_.compare_0 = function compare_59(node1, node2){
  return $compare_19(this, castTo(node1, 9), castTo(node2, 9));
}
;
_.equals_0 = function equals_146(other){
  return this === other;
}
;
_.reversed = function reversed_51(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_InteractiveCrossingMinimizer$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'InteractiveCrossingMinimizer/1', 1274);
function $clinit_LayerSweepCrossingMinimizer(){
  $clinit_LayerSweepCrossingMinimizer = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIGURATION_3 = $add_17($after($addBefore($addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , LONG_EDGE_SPLITTER)), P4_NODE_PLACEMENT, IN_LAYER_CONSTRAINT_PROCESSOR), P5_EDGE_ROUTING), LONG_EDGE_JOINER);
}

function $compareDifferentRandomizedLayouts(this$static, gData){
  var bestCrossings, crossings, i, thouroughness;
  $setSeed_0(this$static.random_0, this$static.randomSeed);
  this$static.graphsWhoseNodeOrderChanged.map_0.clear_0();
  bestCrossings = $intern_0;
  thouroughness = castTo($getProperty(gData.lGraph, ($clinit_LayeredOptions() , THOROUGHNESS_0)), 21).value_0;
  for (i = 0; i < thouroughness; i++) {
    crossings = $minimizeCrossingsWithCounter(this$static, gData);
    if (crossings < bestCrossings) {
      bestCrossings = crossings;
      $saveAllNodeOrdersOfChangedGraphs(this$static);
      if (crossings == 0) {
        break;
      }
    }
  }
}

function $countCurrentNumberOfCrossings(this$static, currentGraph){
  var child, childLGraph, childLGraph$iterator, countCrossingsIn, gD, totalCrossings;
  totalCrossings = 0;
  countCrossingsIn = new ArrayDeque;
  $addFirst(countCrossingsIn, currentGraph);
  while (countCrossingsIn.head != countCrossingsIn.tail) {
    gD = castTo($removeFirst(countCrossingsIn), 212);
    totalCrossings += $countAllCrossings(gD.crossingsCounter, gD.currentNodeOrder);
    for (childLGraph$iterator = new ArrayList$1(gD.childGraphs); childLGraph$iterator.i < childLGraph$iterator.this$01.array.length;) {
      childLGraph = castTo($next_10(childLGraph$iterator), 32);
      child = castTo($get_7(this$static.graphInfoHolders, childLGraph.id_0), 212);
      child.useBottomUp || (totalCrossings += $countCurrentNumberOfCrossings(this$static, child));
    }
  }
  return totalCrossings;
}

function $endIndex(isForwardSweep, length_0){
  return isForwardSweep?length_0 - 1:0;
}

function $firstIndex(isForwardSweep, length_0){
  return isForwardSweep?0:length_0 - 1;
}

function $initialize_3(this$static, rootGraph){
  var gData, graph, graphs, graphsToSweepOn, i, iter;
  this$static.graphInfoHolders = new ArrayList;
  this$static.random_0 = castTo($getProperty(rootGraph, ($clinit_InternalProperties_1() , RANDOM_0)), 221);
  this$static.randomSeed = $nextLong(this$static.random_0);
  graphsToSweepOn = new LinkedList;
  graphs = newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_graph_LGraph_2_classLit, 1), $intern_106, 32, 0, [rootGraph]));
  i = 0;
  while (i < graphs.array.length) {
    graph = (checkCriticalElementIndex(i, graphs.array.length) , castTo(graphs.array[i], 32));
    graph.id_0 = i++;
    gData = new GraphInfoHolder(graph, this$static.crossMinType, this$static.graphInfoHolders);
    $addAll_2(graphs, gData.childGraphs);
    $add_4(this$static.graphInfoHolders, gData);
    gData.useBottomUp && (iter = $listIterator_1(graphsToSweepOn, 0) , $add_8(iter, gData));
  }
  this$static.graphsWhoseNodeOrderChanged = new HashSet;
  return graphsToSweepOn;
}

function $minimizeCrossings_0(graphsToSweepOn, minimizingMethod){
  var gData, gData$iterator;
  for (gData$iterator = $listIterator_1(graphsToSweepOn, 0); gData$iterator.currentNode != gData$iterator.this$01.tail;) {
    gData = castTo($next_13(gData$iterator), 212);
    if (gData.currentNodeOrder.length > 0) {
      minimizingMethod.accept(gData);
      gData.hasParent && $setPortOrderOnParentGraph(gData);
    }
  }
}

function $minimizeCrossingsNoCounter(this$static, gData){
  var improved, isForwardSweep;
  isForwardSweep = $nextInternal(this$static.random_0, 1) != 0;
  improved = true;
  while (improved) {
    improved = gData.crossMinimizer.setFirstLayerOrder(gData.currentNodeOrder, isForwardSweep);
    improved = improved | $sweepReducingCrossings(this$static, gData, isForwardSweep, false);
    isForwardSweep = !isForwardSweep;
  }
  $setCurrentlyBestNodeOrders(this$static);
}

function $minimizeCrossingsWithCounter(this$static, gData){
  var crossingsInGraph, isForwardSweep, oldNumberOfCrossings;
  isForwardSweep = $nextInternal(this$static.random_0, 1) != 0;
  gData.crossMinimizer.setFirstLayerOrder(gData.currentNodeOrder, isForwardSweep);
  $sweepReducingCrossings(this$static, gData, isForwardSweep, true);
  crossingsInGraph = $countCurrentNumberOfCrossings(this$static, gData);
  do {
    $setCurrentlyBestNodeOrders(this$static);
    if (crossingsInGraph == 0) {
      return 0;
    }
    isForwardSweep = !isForwardSweep;
    oldNumberOfCrossings = crossingsInGraph;
    $sweepReducingCrossings(this$static, gData, isForwardSweep, false);
    crossingsInGraph = $countCurrentNumberOfCrossings(this$static, gData);
  }
   while (oldNumberOfCrossings > crossingsInGraph);
  return oldNumberOfCrossings;
}

function $process_67(this$static, layeredGraph, progressMonitor){
  var emptyGraph, graphsToSweepOn, hierarchicalLayout, minimizingMethod, parent_0, singleNode;
  $begin(progressMonitor, 'Minimize Crossings ' + this$static.crossMinType, 1);
  emptyGraph = layeredGraph.layers.array.length == 0 || $findFirst($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(layeredGraph.layers, 16)), new Predicate$lambda$0$Type(new LayerSweepCrossingMinimizer$lambda$0$Type))).ref == null;
  singleNode = layeredGraph.layers.array.length == 1 && castTo($get_7(layeredGraph.layers, 0), 25).nodes.array.length == 1;
  hierarchicalLayout = maskUndefined($getProperty(layeredGraph, ($clinit_LayeredOptions() , HIERARCHY_HANDLING))) === maskUndefined(($clinit_HierarchyHandling() , INCLUDE_CHILDREN));
  if (emptyGraph || singleNode && !hierarchicalLayout) {
    $done_0(progressMonitor);
    return;
  }
  graphsToSweepOn = $initialize_3(this$static, layeredGraph);
  minimizingMethod = (parent_0 = castTo($get_3(graphsToSweepOn, 0), 212) , parent_0.crossMinimizer.isDeterministic()?parent_0.crossMinimizer.alwaysImproves()?new LayerSweepCrossingMinimizer$lambda$2$Type(this$static):new LayerSweepCrossingMinimizer$lambda$3$Type(this$static):new LayerSweepCrossingMinimizer$lambda$1$Type(this$static));
  $minimizeCrossings_0(graphsToSweepOn, minimizingMethod);
  $transferNodeAndPortOrdersToGraph(this$static);
  $done_0(progressMonitor);
}

function $saveAllNodeOrdersOfChangedGraphs(this$static){
  var graph, graph$iterator;
  for (graph$iterator = this$static.graphsWhoseNodeOrderChanged.map_0.keySet_0().iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 212);
    $setBestNodeNPortOrder(graph, new SweepCopy(graph.currentlyBestNodeAndPortOrder));
  }
}

function $setCurrentlyBestNodeOrders(this$static){
  var graph, graph$iterator;
  for (graph$iterator = this$static.graphsWhoseNodeOrderChanged.map_0.keySet_0().iterator_0(); graph$iterator.hasNext_0();) {
    graph = castTo(graph$iterator.next_1(), 212);
    $setCurrentlyBestNodeAndPortOrder(graph, new SweepCopy_0(graph.currentNodeOrder));
  }
}

function $setPortOrderOnParentGraph(gData){
  var bestSweep;
  if (gData.hasExternalPorts) {
    bestSweep = gData.crossMinimizer.isDeterministic()?gData.currentlyBestNodeAndPortOrder:gData.bestNodeAndPortOrder;
    $sortPortsByDummyPositionsInLastLayer(bestSweep.nodeOrder, gData.parent_0, true);
    $sortPortsByDummyPositionsInLastLayer(bestSweep.nodeOrder, gData.parent_0, false);
    $setProperty_0(gData.parent_0, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0), ($clinit_PortConstraints() , FIXED_ORDER));
  }
}

function $sortPortDummiesByPortPositions(parentNode, layerCloseToNodeEdge, side){
  var i, port, port$iterator, ports, sortedDummies;
  ports = inNorthSouthEastWestOrder(parentNode, side);
  sortedDummies = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, layerCloseToNodeEdge.length, 0, 1);
  i = 0;
  for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    checkNotNull_1(castToBoolean($getProperty(port, ($clinit_InternalProperties_1() , INSIDE_CONNECTIONS)))) && (sortedDummies[i++] = castTo($getProperty(port, PORT_DUMMY), 9));
  }
  return sortedDummies;
}

function $sortPortsByDummyPositionsInLastLayer(nodeOrder, parent_0, onRightMostLayer){
  var endIndex, i, j, lastLayer, port, ports;
  endIndex = $endIndex(onRightMostLayer, nodeOrder.length);
  lastLayer = nodeOrder[endIndex];
  if (lastLayer[0].type_0 != ($clinit_LNode$NodeType() , EXTERNAL_PORT)) {
    return;
  }
  j = $firstIndex(onRightMostLayer, lastLayer.length);
  ports = parent_0.ports;
  for (i = 0; i < ports.array.length; i++) {
    port = (checkCriticalElementIndex(i, ports.array.length) , castTo(ports.array[i], 11));
    if ((onRightMostLayer?port.side == ($clinit_PortSide() , EAST_1):port.side == ($clinit_PortSide() , WEST_1)) && checkNotNull_1(castToBoolean($getProperty(port, ($clinit_InternalProperties_1() , INSIDE_CONNECTIONS))))) {
      $set_1(ports, i, castTo($getProperty(lastLayer[j], ($clinit_InternalProperties_1() , ORIGIN_0)), 11));
      j += onRightMostLayer?1:-1;
    }
  }
}

function $sweepInHierarchicalNodes(this$static, layer, isForwardSweep, isFirstSweep){
  var improved, node, node$index, node$max, nestedLGraph, nestedGraph, nestedGraphNodeOrder, startIndex, firstNode, improved_0;
  improved = false;
  for (node$index = 0 , node$max = layer.length; node$index < node$max; ++node$index) {
    node = layer[node$index];
    checkNotNull_1(($clinit_Boolean() , castTo($getProperty(node, ($clinit_InternalProperties_1() , NESTED_LGRAPH)), 32)?true:false)) && !castTo($get_7(this$static.graphInfoHolders, castTo($getProperty(node, NESTED_LGRAPH), 32).id_0), 212).useBottomUp && (improved = improved | (nestedLGraph = castTo($getProperty(node, NESTED_LGRAPH), 32) , nestedGraph = castTo($get_7(this$static.graphInfoHolders, nestedLGraph.id_0), 212) , nestedGraphNodeOrder = nestedGraph.currentNodeOrder , startIndex = $firstIndex(isForwardSweep, nestedGraphNodeOrder.length) , firstNode = nestedGraphNodeOrder[startIndex][0] , firstNode.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT)?(nestedGraphNodeOrder[startIndex] = $sortPortDummiesByPortPositions(node, nestedGraphNodeOrder[startIndex], isForwardSweep?($clinit_PortSide() , WEST_1):($clinit_PortSide() , EAST_1))):nestedGraph.crossMinimizer.setFirstLayerOrder(nestedGraphNodeOrder, isForwardSweep) , improved_0 = $sweepReducingCrossings(this$static, nestedGraph, isForwardSweep, isFirstSweep) , $sortPortsByDummyPositionsInLastLayer(nestedGraph.currentNodeOrder, nestedGraph.parent_0, isForwardSweep) , improved_0));
  }
  return improved;
}

function $sweepReducingCrossings(this$static, graph, forward_0, firstSweep){
  var firstLayer, i, improved, length_0, nodes;
  nodes = graph.currentNodeOrder;
  length_0 = nodes.length;
  improved = graph.portDistributor.distributePortsWhileSweeping(nodes, forward_0?0:length_0 - 1, forward_0);
  firstLayer = nodes[forward_0?0:length_0 - 1];
  improved = improved | $sweepInHierarchicalNodes(this$static, firstLayer, forward_0, firstSweep);
  for (i = forward_0?1:length_0 - 2; forward_0?i < length_0:i >= 0; i += forward_0?1:-1) {
    improved = improved | graph.crossMinimizer.minimizeCrossings(nodes, i, forward_0, firstSweep);
    improved = improved | graph.portDistributor.distributePortsWhileSweeping(nodes, i, forward_0);
    improved = improved | $sweepInHierarchicalNodes(this$static, nodes[i], forward_0, firstSweep);
  }
  $add_6(this$static.graphsWhoseNodeOrderChanged, graph);
  return improved;
}

function $transferNodeAndPortOrdersToGraph(this$static){
  var bestSweep, gD, gD$iterator;
  for (gD$iterator = new ArrayList$1(this$static.graphInfoHolders); gD$iterator.i < gD$iterator.this$01.array.length;) {
    gD = castTo($next_10(gD$iterator), 212);
    bestSweep = gD.crossMinimizer.isDeterministic()?gD.currentlyBestNodeAndPortOrder:gD.bestNodeAndPortOrder;
    !!bestSweep && $transferNodeAndPortOrdersToGraph_0(bestSweep, gD.lGraph);
  }
}

function LayerSweepCrossingMinimizer(cT){
  $clinit_LayerSweepCrossingMinimizer();
  this.crossMinType = cT;
}

defineClass(477, 1, {477:1, 126:1, 45:1}, LayerSweepCrossingMinimizer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_9(graph){
  var configuration;
  return castTo(graph, 32) , configuration = createFrom_0(INTERMEDIATE_PROCESSING_CONFIGURATION_3) , $addBefore(configuration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , PORT_LIST_SORTER)) , configuration;
}
;
_.process = function process_62(layeredGraph, progressMonitor){
  $process_67(this, castTo(layeredGraph, 32), progressMonitor);
}
;
_.randomSeed = 0;
var INTERMEDIATE_PROCESSING_CONFIGURATION_3;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepCrossingMinimizer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepCrossingMinimizer', 477);
function $clinit_LayerSweepCrossingMinimizer$CrossMinType(){
  $clinit_LayerSweepCrossingMinimizer$CrossMinType = emptyMethod;
  BARYCENTER = new LayerSweepCrossingMinimizer$CrossMinType('BARYCENTER', 0);
  ONE_SIDED_GREEDY_SWITCH_0 = new LayerSweepCrossingMinimizer$CrossMinType('ONE_SIDED_GREEDY_SWITCH', 1);
  TWO_SIDED_GREEDY_SWITCH_0 = new LayerSweepCrossingMinimizer$CrossMinType('TWO_SIDED_GREEDY_SWITCH', 2);
}

function LayerSweepCrossingMinimizer$CrossMinType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_60(name_0){
  $clinit_LayerSweepCrossingMinimizer$CrossMinType();
  return valueOf(($clinit_LayerSweepCrossingMinimizer$CrossMinType$Map() , $MAP_48), name_0);
}

function values_56(){
  $clinit_LayerSweepCrossingMinimizer$CrossMinType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p3order_LayerSweepCrossingMinimizer$CrossMinType_2_classLit, 1), $intern_38, 428, 0, [BARYCENTER, ONE_SIDED_GREEDY_SWITCH_0, TWO_SIDED_GREEDY_SWITCH_0]);
}

defineClass(428, 22, {3:1, 34:1, 22:1, 428:1}, LayerSweepCrossingMinimizer$CrossMinType);
var BARYCENTER, ONE_SIDED_GREEDY_SWITCH_0, TWO_SIDED_GREEDY_SWITCH_0;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepCrossingMinimizer$CrossMinType_2_classLit = createForEnum('org.eclipse.elk.alg.layered.p3order', 'LayerSweepCrossingMinimizer/CrossMinType', 428, Ljava_lang_Enum_2_classLit, values_56, valueOf_60);
function $clinit_LayerSweepCrossingMinimizer$CrossMinType$Map(){
  $clinit_LayerSweepCrossingMinimizer$CrossMinType$Map = emptyMethod;
  $MAP_48 = createValueOfMap(($clinit_LayerSweepCrossingMinimizer$CrossMinType() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p3order_LayerSweepCrossingMinimizer$CrossMinType_2_classLit, 1), $intern_38, 428, 0, [BARYCENTER, ONE_SIDED_GREEDY_SWITCH_0, TWO_SIDED_GREEDY_SWITCH_0])));
}

var $MAP_48;
function LayerSweepCrossingMinimizer$lambda$0$Type(){
}

defineClass(1269, 1, $intern_90, LayerSweepCrossingMinimizer$lambda$0$Type);
_.test_0 = function test_59(arg0){
  return $clinit_LayerSweepCrossingMinimizer() , castTo(arg0, 25).nodes.array.length == 0;
}
;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepCrossingMinimizer$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepCrossingMinimizer/lambda$0$Type', 1269);
function LayerSweepCrossingMinimizer$lambda$1$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1270, 1, {}, LayerSweepCrossingMinimizer$lambda$1$Type);
_.accept = function accept_84(arg0){
  $compareDifferentRandomizedLayouts(this.$$outer_0, castTo(arg0, 212));
}
;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepCrossingMinimizer$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepCrossingMinimizer/lambda$1$Type', 1270);
function LayerSweepCrossingMinimizer$lambda$2$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1271, 1, {}, LayerSweepCrossingMinimizer$lambda$2$Type);
_.accept = function accept_85(arg0){
  $minimizeCrossingsNoCounter(this.$$outer_0, castTo(arg0, 212));
}
;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepCrossingMinimizer$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepCrossingMinimizer/lambda$2$Type', 1271);
function LayerSweepCrossingMinimizer$lambda$3$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1272, 1, {}, LayerSweepCrossingMinimizer$lambda$3$Type);
_.accept = function accept_86(arg0){
  $minimizeCrossingsWithCounter(this.$$outer_0, castTo(arg0, 212));
}
;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepCrossingMinimizer$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepCrossingMinimizer/lambda$3$Type', 1272);
function $transferInfoTo(this$static, currentNode, target){
  var targetNodeInfo;
  targetNodeInfo = this$static.nodeInfo[target.layer.id_0][target.id_0];
  targetNodeInfo.hierarchicalInfluence += currentNode.hierarchicalInfluence;
  targetNodeInfo.randomInfluence += currentNode.randomInfluence;
  targetNodeInfo.connectedEdges += currentNode.connectedEdges;
  ++targetNodeInfo.connectedEdges;
}

function $useBottomUp(this$static){
  var allPaths, boundary, currentNode, eastPorts, edge, edge$iterator, layer, layer$array, layer$index, layer$max, node, node$index, node$iterator, node$max, normalized, northSouthPorts, nsDummy, nsPortDummies, pathsToHierarchical, pathsToRandom, port, port$iterator, target, westPorts;
  boundary = checkNotNull_1(castToDouble($getProperty(this$static.graphData.lGraph, ($clinit_LayeredOptions() , CROSSING_MINIMIZATION_HIERARCHICAL_SWEEPINESS_0))));
  if (boundary < -1 || !this$static.graphData.hasParent || $isOrderFixed(castTo($getProperty(this$static.graphData.parent_0, PORT_CONSTRAINTS_0), 83)) || $getPortSideView(this$static.graphData.parent_0, ($clinit_PortSide() , EAST_1)).size_1() < 2 && $getPortSideView(this$static.graphData.parent_0, WEST_1).size_1() < 2) {
    return true;
  }
  if (this$static.graphData.crossMinimizer.isDeterministic()) {
    return false;
  }
  pathsToRandom = 0;
  pathsToHierarchical = 0;
  nsPortDummies = new ArrayList;
  for (layer$array = this$static.graphData.currentNodeOrder , layer$index = 0 , layer$max = layer$array.length; layer$index < layer$max; ++layer$index) {
    layer = layer$array[layer$index];
    for (node$index = 0 , node$max = layer.length; node$index < node$max; ++node$index) {
      node = layer[node$index];
      if (node.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT)) {
        nsPortDummies.array[nsPortDummies.array.length] = node;
        continue;
      }
      currentNode = this$static.nodeInfo[node.layer.id_0][node.id_0];
      if (node.type_0 == EXTERNAL_PORT) {
        currentNode.hierarchicalInfluence = 1;
        castTo($getProperty(node, ($clinit_InternalProperties_1() , ORIGIN_0)), 11).side == ($clinit_PortSide() , EAST_1) && (pathsToHierarchical += currentNode.connectedEdges);
      }
       else {
        westPorts = $getPortSideView(node, ($clinit_PortSide() , WEST_1));
        westPorts.isEmpty() || !any_0(westPorts, new LayerSweepTypeDecider$lambda$1$Type)?(currentNode.randomInfluence = 1):(eastPorts = $getPortSideView(node, EAST_1) , (eastPorts.isEmpty() || !any_0(eastPorts, new LayerSweepTypeDecider$lambda$0$Type)) && (pathsToRandom += currentNode.connectedEdges));
      }
      for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        pathsToRandom += currentNode.randomInfluence;
        pathsToHierarchical += currentNode.hierarchicalInfluence;
        target = edge.target.owner;
        $transferInfoTo(this$static, currentNode, target);
      }
      northSouthPorts = concat_1($getPortSideView(node, ($clinit_PortSide() , NORTH_1)), $getPortSideView(node, SOUTH_1));
      for (port$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(northSouthPorts.val$inputs1, new Iterables$12)))); $hasNext_0(port$iterator);) {
        port = castTo($next_2(port$iterator), 11);
        nsDummy = castTo($getProperty(port, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
        if (nsDummy) {
          pathsToRandom += currentNode.randomInfluence;
          pathsToHierarchical += currentNode.hierarchicalInfluence;
          $transferInfoTo(this$static, currentNode, nsDummy);
        }
      }
    }
    for (node$iterator = new ArrayList$1(nsPortDummies); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      currentNode = this$static.nodeInfo[node.layer.id_0][node.id_0];
      for (edge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        pathsToRandom += currentNode.randomInfluence;
        pathsToHierarchical += currentNode.hierarchicalInfluence;
        target = edge.target.owner;
        $transferInfoTo(this$static, currentNode, target);
      }
    }
    nsPortDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  }
  allPaths = pathsToRandom + pathsToHierarchical;
  normalized = allPaths == 0?$intern_62:(pathsToRandom - pathsToHierarchical) / allPaths;
  return normalized >= boundary;
}

function LayerSweepTypeDecider(graphData){
  this.graphData = graphData;
  this.nodeInfo = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_LayerSweepTypeDecider$NodeInfo_2_classLit, $intern_33, 1722, graphData.currentNodeOrder.length, 0, 2);
}

defineClass(1607, 1, $intern_115, LayerSweepTypeDecider);
_.initAfterTraversal = function initAfterTraversal_5(){
}
;
_.initAtEdgeLevel = function initAtEdgeLevel_5(l, n, p, e, edge, nodeOrder){
}
;
_.initAtPortLevel = function initAtPortLevel_5(l, n, p, nodeOrder){
}
;
_.initAtLayerLevel = function initAtLayerLevel_5(l, nodeOrder){
  nodeOrder[l][0].layer.id_0 = l;
  this.nodeInfo[l] = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_LayerSweepTypeDecider$NodeInfo_2_classLit, {3:1, 4:1, 5:1, 1722:1}, 619, nodeOrder[l].length, 0, 1);
}
;
_.initAtNodeLevel = function initAtNodeLevel_5(l, n, nodeOrder){
  var node;
  node = nodeOrder[l][n];
  node.id_0 = n;
  setCheck(this.nodeInfo[l], n, new LayerSweepTypeDecider$NodeInfo);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepTypeDecider_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepTypeDecider', 1607);
function LayerSweepTypeDecider$NodeInfo(){
}

defineClass(619, 1, {619:1}, LayerSweepTypeDecider$NodeInfo);
_.toString_0 = function toString_100(){
  return 'NodeInfo [connectedEdges=' + this.connectedEdges + ', hierarchicalInfluence=' + this.hierarchicalInfluence + ', randomInfluence=' + this.randomInfluence + ']';
}
;
_.connectedEdges = 0;
_.hierarchicalInfluence = 0;
_.randomInfluence = 0;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepTypeDecider$NodeInfo_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepTypeDecider/NodeInfo', 619);
function LayerSweepTypeDecider$lambda$0$Type(){
}

defineClass(1608, 1, $intern_91, LayerSweepTypeDecider$lambda$0$Type);
_.equals_0 = function equals_147(other){
  return this === other;
}
;
_.test_0 = function test_60(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_118(arg0){
  return $hasNext_5(new LPort$CombineIter$1(castTo(arg0, 11).connectedEdges));
}
;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepTypeDecider$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepTypeDecider/lambda$0$Type', 1608);
function LayerSweepTypeDecider$lambda$1$Type(){
}

defineClass(1609, 1, $intern_91, LayerSweepTypeDecider$lambda$1$Type);
_.equals_0 = function equals_148(other){
  return this === other;
}
;
_.test_0 = function test_61(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_119(arg0){
  return $hasNext_5(new LPort$CombineIter$1(castTo(arg0, 11).connectedEdges));
}
;
var Lorg_eclipse_elk_alg_layered_p3order_LayerSweepTypeDecider$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerSweepTypeDecider/lambda$1$Type', 1609);
function LayerTotalPortDistributor(numLayers){
  AbstractBarycenterPortDistributor.call(this, numLayers);
}

defineClass(1621, 433, $intern_118, LayerTotalPortDistributor);
_.calculatePortRanks = function calculatePortRanks(node, rankSum, type_0){
  var inputCount, northInputCount, northPos, port, port$iterator, port$iterator0, portRanks, pos, restPos;
  portRanks = this.portRanks;
  switch (type_0.ordinal) {
    case 1:
      {
        inputCount = 0;
        northInputCount = 0;
        for (port$iterator0 = new ArrayList$1(node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
          port = castTo($next_10(port$iterator0), 11);
          if (port.incomingEdges.array.length != 0) {
            ++inputCount;
            port.side == ($clinit_PortSide() , NORTH_1) && ++northInputCount;
          }
        }
        northPos = rankSum + northInputCount;
        restPos = rankSum + inputCount;
        for (port$iterator = $getPorts(node, ($clinit_PortType() , INPUT)).iterator_0(); port$iterator.hasNext_0();) {
          port = castTo(port$iterator.next_1(), 11);
          if (port.side == ($clinit_PortSide() , NORTH_1)) {
            portRanks[port.id_0] = northPos;
            --northPos;
          }
           else {
            portRanks[port.id_0] = restPos;
            --restPos;
          }
        }
        return inputCount;
      }

    case 2:
      {
        pos = 0;
        for (port$iterator = $getPorts(node, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
          port = castTo(port$iterator.next_1(), 11);
          ++pos;
          portRanks[port.id_0] = rankSum + pos;
        }
        return pos;
      }

    default:throw toJs(new IllegalArgumentException);
  }
}
;
var Lorg_eclipse_elk_alg_layered_p3order_LayerTotalPortDistributor_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'LayerTotalPortDistributor', 1621);
function NodeRelativePortDistributor(numLayers){
  AbstractBarycenterPortDistributor.call(this, numLayers);
}

defineClass(739, 433, $intern_118, NodeRelativePortDistributor);
_.calculatePortRanks = function calculatePortRanks_0(node, rankSum, type_0){
  var incr, inputCount, northInputCount, northPos, outputCount, port, port$iterator, port$iterator0, portRanks, pos, restPos;
  portRanks = this.portRanks;
  switch (type_0.ordinal) {
    case 1:
      {
        inputCount = 0;
        northInputCount = 0;
        for (port$iterator0 = new ArrayList$1(node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
          port = castTo($next_10(port$iterator0), 11);
          if (port.incomingEdges.array.length != 0) {
            ++inputCount;
            port.side == ($clinit_PortSide() , NORTH_1) && ++northInputCount;
          }
        }
        incr = 1 / (inputCount + 1);
        northPos = rankSum + northInputCount * incr;
        restPos = rankSum + 1 - incr;
        for (port$iterator = $getPorts(node, ($clinit_PortType() , INPUT)).iterator_0(); port$iterator.hasNext_0();) {
          port = castTo(port$iterator.next_1(), 11);
          if (port.side == ($clinit_PortSide() , NORTH_1)) {
            portRanks[port.id_0] = northPos;
            northPos -= incr;
          }
           else {
            portRanks[port.id_0] = restPos;
            restPos -= incr;
          }
        }
        break;
      }

    case 2:
      {
        outputCount = 0;
        for (port$iterator0 = new ArrayList$1(node.ports); port$iterator0.i < port$iterator0.this$01.array.length;) {
          port = castTo($next_10(port$iterator0), 11);
          port.outgoingEdges.array.length == 0 || ++outputCount;
        }
        incr = 1 / (outputCount + 1);
        pos = rankSum + incr;
        for (port$iterator = $getPorts(node, ($clinit_PortType() , OUTPUT)).iterator_0(); port$iterator.hasNext_0();) {
          port = castTo(port$iterator.next_1(), 11);
          portRanks[port.id_0] = pos;
          pos += incr;
        }
        break;
      }

    default:throw toJs(new IllegalArgumentException_0('Port type is undefined'));
  }
  return 1;
}
;
var Lorg_eclipse_elk_alg_layered_p3order_NodeRelativePortDistributor_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'NodeRelativePortDistributor', 739);
function $assertCorrectPortSides(dummy){
  var dummyPort, dummyPorts, origin, port, port$iterator;
  origin = castTo($getProperty(dummy, ($clinit_InternalProperties_1() , IN_LAYER_LAYOUT_UNIT)), 9);
  dummyPorts = dummy.ports;
  dummyPort = (checkCriticalElementIndex(0, dummyPorts.array.length) , castTo(dummyPorts.array[0], 11));
  for (port$iterator = new ArrayList$1(origin.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    if (maskUndefined(port) === maskUndefined($getProperty(dummyPort, ORIGIN_0))) {
      port.side == ($clinit_PortSide() , NORTH_1) && dummy.id_0 > origin.id_0?$setSide(port, SOUTH_1):port.side == SOUTH_1 && origin.id_0 > dummy.id_0 && $setSide(port, NORTH_1);
      break;
    }
  }
  return origin;
}

function $deepCopy(currentlyBestNodeOrder){
  var i, result;
  if (currentlyBestNodeOrder == null) {
    return null;
  }
  result = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_33, 125, currentlyBestNodeOrder.length, 0, 2);
  for (i = 0; i < result.length; i++) {
    result[i] = castTo(copyOf_1(currentlyBestNodeOrder[i], currentlyBestNodeOrder[i].length), 125);
  }
  return result;
}

function $transferNodeAndPortOrdersToGraph_0(this$static, lGraph){
  var dummy, dummy$iterator, i, j, layers, node, node$iterator, nodes, northSouthPortDummies, origin, updatePortOrder;
  northSouthPortDummies = new ArrayList;
  updatePortOrder = new HashSet;
  layers = lGraph.layers;
  for (i = 0; i < layers.array.length; i++) {
    nodes = (checkCriticalElementIndex(i, layers.array.length) , castTo(layers.array[i], 25)).nodes;
    northSouthPortDummies.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    for (j = 0; j < nodes.array.length; j++) {
      node = this$static.nodeOrder[i][j];
      node.id_0 = j;
      node.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT) && (northSouthPortDummies.array[northSouthPortDummies.array.length] = node , true);
      $set_1(castTo($get_7(lGraph.layers, i), 25).nodes, j, node);
      node.ports.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      $addAll_2(node.ports, castTo(castTo($get_7(this$static.portOrders, i), 15).get_3(j), 13));
    }
    for (dummy$iterator = new ArrayList$1(northSouthPortDummies); dummy$iterator.i < dummy$iterator.this$01.array.length;) {
      dummy = castTo($next_10(dummy$iterator), 9);
      origin = $assertCorrectPortSides(dummy);
      updatePortOrder.map_0.put(origin, updatePortOrder);
      updatePortOrder.map_0.put(dummy, updatePortOrder);
    }
  }
  for (node$iterator = updatePortOrder.map_0.keySet_0().iterator_0(); node$iterator.hasNext_0();) {
    node = castTo(node$iterator.next_1(), 9);
    $clinit_Collections();
    $sort(node.ports, ($clinit_PortListSorter() , CMP_COMBINED));
    node.portSidesCached = true;
    $findPortIndices(node);
  }
}

function SweepCopy(sc){
  this.nodeOrder = $deepCopy(sc.nodeOrder);
  this.portOrders = new ArrayList_1(sc.portOrders);
}

function SweepCopy_0(nodeOrderIn){
  var lNodes, lNodes$index, lNodes$max, layer, node, node$index, node$max;
  this.nodeOrder = $deepCopy(nodeOrderIn);
  this.portOrders = new ArrayList;
  for (lNodes$index = 0 , lNodes$max = nodeOrderIn.length; lNodes$index < lNodes$max; ++lNodes$index) {
    lNodes = nodeOrderIn[lNodes$index];
    layer = new ArrayList;
    $add_4(this.portOrders, layer);
    for (node$index = 0 , node$max = lNodes.length; node$index < node$max; ++node$index) {
      node = lNodes[node$index];
      $add_4(layer, new ArrayList_1(node.ports));
    }
  }
}

defineClass(747, 1, {}, SweepCopy, SweepCopy_0);
var Lorg_eclipse_elk_alg_layered_p3order_SweepCopy_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order', 'SweepCopy', 747);
function $countAllCrossings(this$static, currentOrder){
  var crossings, layerIndex;
  if (currentOrder.length == 0) {
    return 0;
  }
  crossings = $countInLayerCrossingsOnSide(this$static.crossingCounter, currentOrder[0], ($clinit_PortSide() , WEST_1));
  crossings += $countInLayerCrossingsOnSide(this$static.crossingCounter, currentOrder[currentOrder.length - 1], EAST_1);
  for (layerIndex = 0; layerIndex < currentOrder.length; layerIndex++) {
    crossings += $countCrossingsAt(this$static, layerIndex, currentOrder);
  }
  return crossings;
}

function $countCrossingsAt(this$static, layerIndex, currentOrder){
  var leftLayer, rightLayer, totalCrossings;
  totalCrossings = 0;
  leftLayer = currentOrder[layerIndex];
  if (layerIndex < currentOrder.length - 1) {
    rightLayer = currentOrder[layerIndex + 1];
    if (this$static.hasHyperEdgesEastOfIndex[layerIndex]) {
      totalCrossings = $countCrossings_0(this$static.hyperedgeCrossingsCounter, leftLayer, rightLayer);
      totalCrossings += $countInLayerCrossingsOnSide(this$static.crossingCounter, leftLayer, ($clinit_PortSide() , EAST_1));
      totalCrossings += $countInLayerCrossingsOnSide(this$static.crossingCounter, rightLayer, WEST_1);
    }
     else {
      totalCrossings = $countCrossingsBetweenLayers(this$static.crossingCounter, leftLayer, rightLayer);
    }
  }
  this$static.hasNorthSouthPorts[layerIndex] && (totalCrossings += $countNorthSouthPortCrossingsInLayer(this$static.crossingCounter, leftLayer));
  return totalCrossings;
}

function AllCrossingsCounter(graph){
  this.inLayerEdgeCounts = initUnidimensionalArray(I_classLit, $intern_49, 23, graph.length, 15, 1);
  this.hasNorthSouthPorts = initUnidimensionalArray(Z_classLit, $intern_93, 23, graph.length, 16, 1);
  this.hasHyperEdgesEastOfIndex = initUnidimensionalArray(Z_classLit, $intern_93, 23, graph.length, 16, 1);
  this.nPorts = 0;
}

defineClass(1606, 1, $intern_115, AllCrossingsCounter);
_.initAtLayerLevel = function initAtLayerLevel_6(l, nodeOrderr){
}
;
_.initAfterTraversal = function initAfterTraversal_6(){
  var portPos;
  portPos = initUnidimensionalArray(I_classLit, $intern_49, 23, this.nPorts, 15, 1);
  this.hyperedgeCrossingsCounter = new HyperedgeCrossingsCounter(portPos);
  this.crossingCounter = new CrossingsCounter(portPos);
}
;
_.initAtEdgeLevel = function initAtEdgeLevel_6(l, n, p, e, edge, nodeOrder){
  var port;
  port = castTo($get_7(nodeOrder[l][n].ports, p), 11);
  edge.source == port && edge.source.owner.layer == edge.target.owner.layer && ++this.inLayerEdgeCounts[l];
}
;
_.initAtNodeLevel = function initAtNodeLevel_6(l, n, nodeOrder){
  var node;
  node = nodeOrder[l][n];
  this.hasNorthSouthPorts[l] = this.hasNorthSouthPorts[l] | node.type_0 == ($clinit_LNode$NodeType() , NORTH_SOUTH_PORT);
}
;
_.initAtPortLevel = function initAtPortLevel_6(l, n, p, nodeOrder){
  var port;
  port = castTo($get_7(nodeOrder[l][n].ports, p), 11);
  port.id_0 = this.nPorts++;
  port.outgoingEdges.array.length + port.incomingEdges.array.length > 1 && (port.side == ($clinit_PortSide() , EAST_1)?(this.hasHyperEdgesEastOfIndex[l] = true):port.side == WEST_1 && l > 0 && (this.hasHyperEdgesEastOfIndex[l - 1] = true));
}
;
_.nPorts = 0;
var Lorg_eclipse_elk_alg_layered_p3order_counting_AllCrossingsCounter_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'AllCrossingsCounter', 1606);
function $add_16(this$static, index_0){
  var i;
  ++this$static.size_0;
  ++this$static.numsPerIndex[index_0];
  i = index_0 + 1;
  while (i < this$static.binarySums.length) {
    ++this$static.binarySums[i];
    i += i & -i;
  }
}

function $clear_7(this$static){
  this$static.binarySums = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.maxNum + 1, 15, 1);
  this$static.numsPerIndex = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.maxNum, 15, 1);
  this$static.size_0 = 0;
}

function $rank(this$static, index_0){
  var i, sum;
  i = index_0;
  sum = 0;
  while (i > 0) {
    sum += this$static.binarySums[i];
    i -= i & -i;
  }
  return sum;
}

function $removeAll_3(this$static, index_0){
  var i, numEntries;
  numEntries = this$static.numsPerIndex[index_0];
  if (numEntries == 0) {
    return;
  }
  this$static.numsPerIndex[index_0] = 0;
  this$static.size_0 -= numEntries;
  i = index_0 + 1;
  while (i < this$static.binarySums.length) {
    this$static.binarySums[i] -= numEntries;
    i += i & -i;
  }
}

function BinaryIndexedTree(maxNum){
  this.maxNum = maxNum;
  this.binarySums = initUnidimensionalArray(I_classLit, $intern_49, 23, maxNum + 1, 15, 1);
  this.numsPerIndex = initUnidimensionalArray(I_classLit, $intern_49, 23, maxNum, 15, 1);
  this.size_0 = 0;
}

defineClass(555, 1, {}, BinaryIndexedTree);
_.maxNum = 0;
_.size_0 = 0;
var Lorg_eclipse_elk_alg_layered_p3order_counting_BinaryIndexedTree_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'BinaryIndexedTree', 555);
function inNorthSouthEastWestOrder(node, side){
  switch (side.ordinal) {
    case 2:
    case 1:
      return $getPortSideView(node, side);
    case 3:
    case 4:
      return reverse_0($getPortSideView(node, side));
  }
  return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
}

function $clinit_CrossingsCounter(){
  $clinit_CrossingsCounter = emptyMethod;
  INDEXING_SIDE = ($clinit_PortSide() , WEST_1);
  STACK_SIDE = EAST_1;
}

function $connectedInLayerPortsSortedByPosition(this$static, upperNode, lowerNode, side){
  var edge, edge$iterator, node, node$array, node$index, node$max, port, port$iterator, ports;
  ports = new TreeSet_0(new CrossingsCounter$lambda$2$Type(this$static));
  for (node$array = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, 1), $intern_109, 9, 0, [upperNode, lowerNode]) , node$index = 0 , node$max = node$array.length; node$index < node$max; ++node$index) {
    node = node$array[node$index];
    for (port$iterator = inNorthSouthEastWestOrder(node, side).iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 11);
      for (edge$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(edge$iterator.firstIterator) || $hasNext_2(edge$iterator.secondIterator);) {
        edge = castTo($hasNext_2(edge$iterator.firstIterator)?$next_10(edge$iterator.firstIterator):$next_10(edge$iterator.secondIterator), 16);
        if (!$isSelfLoop(edge)) {
          $put_7(ports.map_0, port, ($clinit_Boolean() , FALSE_0)) == null;
          $isInLayer(edge) && $add_10(ports, port == edge.source?edge.target:edge.source);
        }
      }
    }
  }
  return checkNotNull(ports) , new ArrayList_1(($clinit_Collections2() , ports));
}

function $connectedPortsSortedByPosition(this$static, upperPort, lowerPort){
  var edge, edge$iterator, port, port$array, port$index, port$max, ports;
  ports = new TreeSet_0(new CrossingsCounter$lambda$3$Type(this$static));
  for (port$array = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_graph_LPort_2_classLit, 1), $intern_112, 11, 0, [upperPort, lowerPort]) , port$index = 0 , port$max = port$array.length; port$index < port$max; ++port$index) {
    port = port$array[port$index];
    $put_7(ports.map_0, port, ($clinit_Boolean() , FALSE_0)) == null;
    for (edge$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(edge$iterator.firstIterator) || $hasNext_2(edge$iterator.secondIterator);) {
      edge = castTo($hasNext_2(edge$iterator.firstIterator)?$next_10(edge$iterator.firstIterator):$next_10(edge$iterator.secondIterator), 16);
      edge.source == edge.target || $add_10(ports, port == edge.source?edge.target:edge.source);
    }
  }
  return checkNotNull(ports) , new ArrayList_1(($clinit_Collections2() , ports));
}

function $countCrossingsBetweenLayers(this$static, leftLayerNodes, rightLayerNodes){
  var ports;
  ports = $initPortPositionsCounterClockwise(this$static, leftLayerNodes, rightLayerNodes);
  this$static.indexTree = new BinaryIndexedTree(ports.array.length);
  return $countCrossingsOnPorts(this$static, ports);
}

function $countCrossingsBetweenPortsInBothOrders(this$static, upperPort, lowerPort){
  var lowerUpperCrossings, ports, upperLowerCrossings;
  ports = $connectedPortsSortedByPosition(this$static, upperPort, lowerPort);
  upperLowerCrossings = $countCrossingsOnPorts(this$static, ports);
  $clear_7(this$static.indexTree);
  $switchPorts(this$static, upperPort, lowerPort);
  $clinit_Collections();
  $sort(ports, new CrossingsCounter$lambda$0$Type(this$static));
  lowerUpperCrossings = $countCrossingsOnPorts(this$static, ports);
  $clear_7(this$static.indexTree);
  $switchPorts(this$static, lowerPort, upperPort);
  return new Pair(valueOf_4(upperLowerCrossings), valueOf_4(lowerUpperCrossings));
}

function $countCrossingsOnPorts(this$static, ports){
  var crossings, edge, edge$iterator, endPosition, port, port$iterator;
  crossings = 0;
  for (port$iterator = new ArrayList$1(ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $removeAll_3(this$static.indexTree, this$static.portPositions[port.id_0]);
    for (edge$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(edge$iterator.firstIterator) || $hasNext_2(edge$iterator.secondIterator);) {
      edge = castTo($hasNext_2(edge$iterator.firstIterator)?$next_10(edge$iterator.firstIterator):$next_10(edge$iterator.secondIterator), 16);
      endPosition = $positionOf_0(this$static, port == edge.source?edge.target:edge.source);
      if (endPosition > this$static.portPositions[port.id_0]) {
        crossings += $rank(this$static.indexTree, endPosition);
        $addFirst(this$static.ends, valueOf_4(endPosition));
      }
    }
    while (!$isEmpty(this$static.ends)) {
      $add_16(this$static.indexTree, castTo($removeFirst(this$static.ends), 21).value_0);
    }
  }
  return crossings;
}

function $countInLayerCrossingsBetweenNodesInBothOrders(this$static, upperNode, lowerNode, side){
  var lowerUpperCrossings, ports, upperLowerCrossings;
  ports = $connectedInLayerPortsSortedByPosition(this$static, upperNode, lowerNode, side);
  upperLowerCrossings = $countInLayerCrossingsOnPorts(this$static, ports);
  $switchNodes(this$static, upperNode, lowerNode, side);
  $clear_7(this$static.indexTree);
  $clinit_Collections();
  $sort(ports, new CrossingsCounter$lambda$1$Type(this$static));
  lowerUpperCrossings = $countInLayerCrossingsOnPorts(this$static, ports);
  $switchNodes(this$static, lowerNode, upperNode, side);
  $clear_7(this$static.indexTree);
  return new Pair(valueOf_4(upperLowerCrossings), valueOf_4(lowerUpperCrossings));
}

function $countInLayerCrossingsOnPorts(this$static, ports){
  var crossings, edge, edge$iterator, endPosition, numBetweenLayerEdges, port, port$iterator;
  crossings = 0;
  for (port$iterator = new ArrayList$1(ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $removeAll_3(this$static.indexTree, this$static.portPositions[port.id_0]);
    numBetweenLayerEdges = 0;
    for (edge$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(edge$iterator.firstIterator) || $hasNext_2(edge$iterator.secondIterator);) {
      edge = castTo($hasNext_2(edge$iterator.firstIterator)?$next_10(edge$iterator.firstIterator):$next_10(edge$iterator.secondIterator), 16);
      if ($isInLayer(edge)) {
        endPosition = $positionOf_0(this$static, port == edge.source?edge.target:edge.source);
        if (endPosition > this$static.portPositions[port.id_0]) {
          crossings += $rank(this$static.indexTree, endPosition);
          $addFirst(this$static.ends, valueOf_4(endPosition));
        }
      }
       else {
        ++numBetweenLayerEdges;
      }
    }
    crossings += this$static.indexTree.size_0 * numBetweenLayerEdges;
    while (!$isEmpty(this$static.ends)) {
      $add_16(this$static.indexTree, castTo($removeFirst(this$static.ends), 21).value_0);
    }
  }
  return crossings;
}

function $countInLayerCrossingsOnSide(this$static, nodes, side){
  var ports;
  ports = $initPortPositionsForInLayerCrossings(this$static, nodes, side);
  return $countInLayerCrossingsOnPorts(this$static, ports);
}

function $countNorthSouthCrossingsOnPorts(this$static, ports){
  var crossings, dummy, dummyPort, endPosition, port, port$iterator, targetAndDegree, targetAndDegree$iterator, targetsAndDegrees;
  crossings = 0;
  targetsAndDegrees = new ArrayList;
  for (port$iterator = new ArrayList$1(ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    $removeAll_3(this$static.indexTree, this$static.portPositions[port.id_0]);
    targetsAndDegrees.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    switch (port.owner.type_0.ordinal) {
      case 0:
        dummy = castTo($getProperty(port, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
        $forEach_0(dummy.ports, new CrossingsCounter$lambda$4$Type(targetsAndDegrees));
        break;
      case 1:
        $ifPresent($findFirst($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(port.owner.ports, 16)), new CrossingsCounter$lambda$5$Type(port))), new CrossingsCounter$lambda$6$Type(targetsAndDegrees));
        break;
      case 3:
        dummyPort = castTo($getProperty(port, ($clinit_InternalProperties_1() , ORIGIN_0)), 11);
        $add_4(targetsAndDegrees, new Pair(dummyPort, valueOf_4(port.incomingEdges.array.length + port.outgoingEdges.array.length)));
    }
    for (targetAndDegree$iterator = new ArrayList$1(targetsAndDegrees); targetAndDegree$iterator.i < targetAndDegree$iterator.this$01.array.length;) {
      targetAndDegree = castTo($next_10(targetAndDegree$iterator), 37);
      endPosition = $positionOf_0(this$static, castTo(targetAndDegree.first, 11));
      if (endPosition > this$static.portPositions[port.id_0]) {
        crossings += $rank(this$static.indexTree, endPosition) * castTo(targetAndDegree.second, 21).value_0;
        $addFirst(this$static.ends, valueOf_4(endPosition));
      }
    }
    while (!$isEmpty(this$static.ends)) {
      $add_16(this$static.indexTree, castTo($removeFirst(this$static.ends), 21).value_0);
    }
  }
  return crossings;
}

function $countNorthSouthPortCrossingsInLayer(this$static, layer){
  var ports;
  ports = $initPositionsForNorthSouthCounting(this$static, layer);
  this$static.indexTree = new BinaryIndexedTree(ports.array.length);
  return $countNorthSouthCrossingsOnPorts(this$static, ports);
}

function $emptyStack(this$static, stack_0, ports, side, startIndex){
  var dummy, index_0, p;
  index_0 = startIndex;
  while (stack_0.head != stack_0.tail) {
    dummy = castTo($removeFirst(stack_0), 9);
    p = castTo($getPortSideView(dummy, side).get_3(0), 11);
    this$static.portPositions[p.id_0] = index_0++;
    ports.array[ports.array.length] = p;
  }
  return index_0;
}

function $initForCountingBetween(this$static, leftLayerNodes, rightLayerNodes){
  var ports;
  ports = $initPortPositionsCounterClockwise(this$static, leftLayerNodes, rightLayerNodes);
  this$static.indexTree = new BinaryIndexedTree(ports.array.length);
}

function $initPortPositionsCounterClockwise(this$static, leftLayerNodes, rightLayerNodes){
  var ports;
  ports = new ArrayList;
  $initPositions(this$static, leftLayerNodes, ports, ($clinit_PortSide() , EAST_1), true, false);
  $initPositions(this$static, rightLayerNodes, ports, WEST_1, false, false);
  return ports;
}

function $initPortPositionsForInLayerCrossings(this$static, nodes, side){
  var ports;
  ports = new ArrayList;
  $initPositions(this$static, nodes, ports, side, true, true);
  this$static.indexTree = new BinaryIndexedTree(ports.array.length);
  return ports;
}

function $initPositions(this$static, nodes, ports, side, topDown, getCardinalities){
  var i, node, nodePorts, numPorts, port, port$iterator;
  numPorts = ports.array.length;
  getCardinalities && (this$static.nodeCardinalities = initUnidimensionalArray(I_classLit, $intern_49, 23, nodes.length, 15, 1));
  for (i = topDown?0:nodes.length - 1; topDown?i < nodes.length:i >= 0; i += topDown?1:-1) {
    node = nodes[i];
    nodePorts = side == ($clinit_PortSide() , EAST_1)?topDown?$getPortSideView(node, side):reverse_0($getPortSideView(node, side)):topDown?reverse_0($getPortSideView(node, side)):$getPortSideView(node, side);
    getCardinalities && (this$static.nodeCardinalities[node.id_0] = nodePorts.size_1());
    for (port$iterator = nodePorts.iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 11);
      this$static.portPositions[port.id_0] = numPorts++;
    }
    $addAll_2(ports, nodePorts);
  }
}

function $initPositionsForNorthSouthCounting(this$static, nodes){
  var current, i, index_0, lastLayoutUnit, p, p$iterator, p$iterator0, p$iterator1, ports, stack_0;
  ports = new ArrayList;
  stack_0 = new ArrayDeque;
  lastLayoutUnit = null;
  index_0 = 0;
  for (i = 0; i < nodes.length; ++i) {
    current = nodes[i];
    $isLayoutUnitChanged(lastLayoutUnit, current) && (index_0 = $emptyStack(this$static, stack_0, ports, STACK_SIDE, index_0));
    $hasProperty(current, ($clinit_InternalProperties_1() , IN_LAYER_LAYOUT_UNIT)) && (lastLayoutUnit = castTo($getProperty(current, IN_LAYER_LAYOUT_UNIT), 9));
    switch (current.type_0.ordinal) {
      case 0:
      case 5:
        for (p$iterator0 = $iterator_0(filter_0($getPortSideView(current, ($clinit_PortSide() , NORTH_1)), new CrossingsCounter$lambda$8$Type)); $hasNext(p$iterator0);) {
          p = castTo($next(p$iterator0), 11);
          this$static.portPositions[p.id_0] = index_0++;
          ports.array[ports.array.length] = p;
        }

        index_0 = $emptyStack(this$static, stack_0, ports, STACK_SIDE, index_0);
        for (p$iterator1 = $iterator_0(filter_0($getPortSideView(current, SOUTH_1), new CrossingsCounter$lambda$8$Type)); $hasNext(p$iterator1);) {
          p = castTo($next(p$iterator1), 11);
          this$static.portPositions[p.id_0] = index_0++;
          ports.array[ports.array.length] = p;
        }

        break;
      case 3:
        if (!$getPortSideView(current, INDEXING_SIDE).isEmpty()) {
          p = castTo($getPortSideView(current, INDEXING_SIDE).get_3(0), 11);
          this$static.portPositions[p.id_0] = index_0++;
          ports.array[ports.array.length] = p;
        }

        $getPortSideView(current, STACK_SIDE).isEmpty() || $addFirst(stack_0, current);
        break;
      case 1:
        for (p$iterator = $getPortSideView(current, ($clinit_PortSide() , WEST_1)).iterator_0(); p$iterator.hasNext_0();) {
          p = castTo(p$iterator.next_1(), 11);
          this$static.portPositions[p.id_0] = index_0++;
          ports.array[ports.array.length] = p;
        }

        $getPortSideView(current, EAST_1).forEach_0(new CrossingsCounter$lambda$7$Type(stack_0, current));
    }
  }
  $emptyStack(this$static, stack_0, ports, STACK_SIDE, index_0);
  return ports;
}

function $isInLayer(edge){
  var sourceLayer, targetLayer;
  sourceLayer = edge.source.owner.layer;
  targetLayer = edge.target.owner.layer;
  return sourceLayer == targetLayer;
}

function $isLayoutUnitChanged(lastUnit, node){
  var unit;
  if (!lastUnit || lastUnit == node || !$hasProperty(node, ($clinit_InternalProperties_1() , IN_LAYER_LAYOUT_UNIT))) {
    return false;
  }
  unit = castTo($getProperty(node, ($clinit_InternalProperties_1() , IN_LAYER_LAYOUT_UNIT)), 9);
  return unit != lastUnit;
}

function $lambda$0_8(this$static, a_0, b_1){
  return compare_6(this$static.portPositions[a_0.id_0], this$static.portPositions[b_1.id_0]);
}

function $lambda$1_2(this$static, a_0, b_1){
  return compare_6(this$static.portPositions[a_0.id_0], this$static.portPositions[b_1.id_0]);
}

function $lambda$2_1(this$static, a_0, b_1){
  return compare_6(this$static.portPositions[a_0.id_0], this$static.portPositions[b_1.id_0]);
}

function $lambda$3(this$static, a_0, b_1){
  return compare_6(this$static.portPositions[a_0.id_0], this$static.portPositions[b_1.id_0]);
}

function $positionOf_0(this$static, port){
  return this$static.portPositions[port.id_0];
}

function $switchNodes(this$static, wasUpperNode, wasLowerNode, side){
  var port, port$iterator, port$iterator0, ports;
  ports = inNorthSouthEastWestOrder(wasUpperNode, side);
  for (port$iterator0 = ports.iterator_0(); port$iterator0.hasNext_0();) {
    port = castTo(port$iterator0.next_1(), 11);
    this$static.portPositions[port.id_0] = this$static.portPositions[port.id_0] + this$static.nodeCardinalities[wasLowerNode.id_0];
  }
  ports = inNorthSouthEastWestOrder(wasLowerNode, side);
  for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    this$static.portPositions[port.id_0] = this$static.portPositions[port.id_0] - this$static.nodeCardinalities[wasUpperNode.id_0];
  }
}

function $switchPorts(this$static, topPort, bottomPort){
  var topPortPos;
  topPortPos = this$static.portPositions[topPort.id_0];
  this$static.portPositions[topPort.id_0] = this$static.portPositions[bottomPort.id_0];
  this$static.portPositions[bottomPort.id_0] = topPortPos;
}

function CrossingsCounter(portPositions){
  $clinit_CrossingsCounter();
  this.portPositions = portPositions;
  this.ends = new ArrayDeque;
}

function lambda$4_4(targetsAndDegrees_0, p_1){
  $clinit_CrossingsCounter();
  return $add_4(targetsAndDegrees_0, new Pair(p_1, valueOf_4(p_1.incomingEdges.array.length + p_1.outgoingEdges.array.length)));
}

function lambda$5_2(port_0, p_1){
  $clinit_CrossingsCounter();
  return p_1 != port_0;
}

function lambda$6_1(targetsAndDegrees_0, p_1){
  $clinit_CrossingsCounter();
  return $add_4(targetsAndDegrees_0, new Pair(p_1, valueOf_4(p_1.incomingEdges.array.length + p_1.outgoingEdges.array.length)));
}

defineClass(493, 1, {}, CrossingsCounter);
var INDEXING_SIDE, STACK_SIDE;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter', 493);
function CrossingsCounter$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1642, 1, $intern_40, CrossingsCounter$lambda$0$Type);
_.equals_0 = function equals_149(other){
  return this === other;
}
;
_.reversed = function reversed_52(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_60(arg0, arg1){
  return $lambda$0_8(this.$$outer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$0$Type', 1642);
function CrossingsCounter$lambda$1$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1643, 1, $intern_40, CrossingsCounter$lambda$1$Type);
_.equals_0 = function equals_150(other){
  return this === other;
}
;
_.reversed = function reversed_53(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_61(arg0, arg1){
  return $lambda$1_2(this.$$outer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$1$Type', 1643);
function CrossingsCounter$lambda$2$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1644, 1, $intern_40, CrossingsCounter$lambda$2$Type);
_.equals_0 = function equals_151(other){
  return this === other;
}
;
_.reversed = function reversed_54(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_62(arg0, arg1){
  return $lambda$2_1(this.$$outer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$2$Type', 1644);
function CrossingsCounter$lambda$3$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1645, 1, $intern_40, CrossingsCounter$lambda$3$Type);
_.equals_0 = function equals_152(other){
  return this === other;
}
;
_.reversed = function reversed_55(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_63(arg0, arg1){
  return $lambda$3(this.$$outer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$3$Type', 1645);
function CrossingsCounter$lambda$4$Type(targetsAndDegrees_0){
  this.targetsAndDegrees_0 = targetsAndDegrees_0;
}

defineClass(1646, 1, {}, CrossingsCounter$lambda$4$Type);
_.accept = function accept_87(arg0){
  lambda$4_4(this.targetsAndDegrees_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$4$Type', 1646);
function CrossingsCounter$lambda$5$Type(port_0){
  this.port_0 = port_0;
}

defineClass(1647, 1, $intern_90, CrossingsCounter$lambda$5$Type);
_.test_0 = function test_62(arg0){
  return lambda$5_2(this.port_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$5$Type', 1647);
function $accept_4(this$static, arg0){
  lambda$6_1(this$static.targetsAndDegrees_0, arg0);
}

function CrossingsCounter$lambda$6$Type(targetsAndDegrees_0){
  this.targetsAndDegrees_0 = targetsAndDegrees_0;
}

defineClass(1648, 1, {}, CrossingsCounter$lambda$6$Type);
_.accept = function accept_88(arg0){
  $accept_4(this, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$6$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$6$Type', 1648);
function CrossingsCounter$lambda$7$Type(stack_0, current_1){
  this.stack_0 = stack_0;
  this.current_1 = current_1;
}

defineClass(1649, 1, {}, CrossingsCounter$lambda$7$Type);
_.accept = function accept_89(arg0){
  $clinit_CrossingsCounter();
  $addFirst(this.stack_0, this.current_1);
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$7$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$7$Type', 1649);
function CrossingsCounter$lambda$8$Type(){
}

defineClass(761, 1, $intern_91, CrossingsCounter$lambda$8$Type);
_.equals_0 = function equals_153(other){
  return this === other;
}
;
_.test_0 = function test_63(input_0){
  return this.apply_1(input_0);
}
;
_.apply_1 = function apply_120(arg0){
  return $clinit_CrossingsCounter() , $hasProperty(castTo(arg0, 11), ($clinit_InternalProperties_1() , PORT_DUMMY));
}
;
var Lorg_eclipse_elk_alg_layered_p3order_counting_CrossingsCounter$lambda$8$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'CrossingsCounter/lambda$8$Type', 761);
function $countCrossings_0(this$static, leftLayer, rightLayer){
  var compressDeltas, crossings, delta, edge, edge$iterator, firstIndex, he, he$index, he$max, hyperedge, hyperedgeSet, hyperedges, i, i0, i1, i2, i3, i4, i5, index_0, k, leftCorners, leftLayerRef, node, node$index, node$index0, node$index1, node$max, node$max0, node$max1, northInputPorts, openHyperedges, otherInputPorts, p, p$iterator, port, port$iterator, port2HyperedgeMap, portEdges, portIter, pos, q, rightCorners, rightLayerRef, sourceCount, sourceHE, sourcePort, sourcePort$iterator, southSequence, targetCount, targetHE, targetPort, tree, treeSize;
  sourceCount = 0;
  for (node$index0 = 0 , node$max0 = leftLayer.length; node$index0 < node$max0; ++node$index0) {
    node = leftLayer[node$index0];
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      portEdges = 0;
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        node.layer != edge.target.owner.layer && ++portEdges;
      }
      portEdges > 0 && (this$static.portPos[port.id_0] = sourceCount++);
    }
  }
  targetCount = 0;
  for (node$index1 = 0 , node$max1 = rightLayer.length; node$index1 < node$max1; ++node$index1) {
    node = rightLayer[node$index1];
    northInputPorts = 0;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      if (port.side == ($clinit_PortSide() , NORTH_1)) {
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator), 16);
          if (node.layer != edge.source.owner.layer) {
            ++northInputPorts;
            break;
          }
        }
      }
       else {
        break;
      }
    }
    otherInputPorts = 0;
    portIter = new AbstractList$ListIteratorImpl(node.ports, node.ports.array.length);
    while (portIter.i > 0) {
      port = (checkCriticalElement(portIter.i > 0) , castTo(portIter.this$01.get_3(portIter.last = --portIter.i), 11));
      portEdges = 0;
      for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        node.layer != edge.source.owner.layer && ++portEdges;
      }
      if (portEdges > 0) {
        if (port.side == ($clinit_PortSide() , NORTH_1)) {
          this$static.portPos[port.id_0] = targetCount;
          ++targetCount;
        }
         else {
          this$static.portPos[port.id_0] = targetCount + northInputPorts + otherInputPorts;
          ++otherInputPorts;
        }
      }
    }
    targetCount += otherInputPorts;
  }
  port2HyperedgeMap = ($clinit_Maps() , new HashMap);
  hyperedgeSet = new LinkedHashSet;
  for (node$index = 0 , node$max = leftLayer.length; node$index < node$max; ++node$index) {
    node = leftLayer[node$index];
    for (sourcePort$iterator = new ArrayList$1(node.ports); sourcePort$iterator.i < sourcePort$iterator.this$01.array.length;) {
      sourcePort = castTo($next_10(sourcePort$iterator), 11);
      for (edge$iterator = new ArrayList$1(sourcePort.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        targetPort = edge.target;
        if (node.layer != targetPort.owner.layer) {
          sourceHE = castTo(getEntryValueOrNull($getEntry(port2HyperedgeMap.hashCodeMap, sourcePort)), 442);
          targetHE = castTo(getEntryValueOrNull($getEntry(port2HyperedgeMap.hashCodeMap, targetPort)), 442);
          if (!sourceHE && !targetHE) {
            hyperedge = new HyperedgeCrossingsCounter$Hyperedge;
            hyperedgeSet.map_0.put(hyperedge, hyperedgeSet);
            $add_4(hyperedge.edges, edge);
            $add_4(hyperedge.ports, sourcePort);
            $put_4(port2HyperedgeMap.hashCodeMap, sourcePort, hyperedge);
            $add_4(hyperedge.ports, targetPort);
            $put_4(port2HyperedgeMap.hashCodeMap, targetPort, hyperedge);
          }
           else if (!sourceHE) {
            $add_4(targetHE.edges, edge);
            $add_4(targetHE.ports, sourcePort);
            $put_4(port2HyperedgeMap.hashCodeMap, sourcePort, targetHE);
          }
           else if (!targetHE) {
            $add_4(sourceHE.edges, edge);
            $add_4(sourceHE.ports, targetPort);
            $put_4(port2HyperedgeMap.hashCodeMap, targetPort, sourceHE);
          }
           else if (sourceHE == targetHE) {
            $add_4(sourceHE.edges, edge);
          }
           else {
            $add_4(sourceHE.edges, edge);
            for (p$iterator = new ArrayList$1(targetHE.ports); p$iterator.i < p$iterator.this$01.array.length;) {
              p = castTo($next_10(p$iterator), 11);
              $put_4(port2HyperedgeMap.hashCodeMap, p, sourceHE);
            }
            $addAll_2(sourceHE.edges, targetHE.edges);
            $addAll_2(sourceHE.ports, targetHE.ports);
            hyperedgeSet.map_0.remove(targetHE) != null;
          }
        }
      }
    }
  }
  hyperedges = castTo($toArray_0(hyperedgeSet, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter$Hyperedge_2_classLit, {3:1, 4:1, 5:1, 1724:1}, 442, hyperedgeSet.map_0.size_1(), 0, 1)), 1724);
  leftLayerRef = leftLayer[0].layer;
  rightLayerRef = rightLayer[0].layer;
  for (he$index = 0 , he$max = hyperedges.length; he$index < he$max; ++he$index) {
    he = hyperedges[he$index];
    he.upperLeft = sourceCount;
    he.upperRight = targetCount;
    for (port$iterator = new ArrayList$1(he.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      pos = this$static.portPos[port.id_0];
      if (port.owner.layer == leftLayerRef) {
        pos < he.upperLeft && (he.upperLeft = pos);
        pos > he.lowerLeft && (he.lowerLeft = pos);
      }
       else if (port.owner.layer == rightLayerRef) {
        pos < he.upperRight && (he.upperRight = pos);
        pos > he.lowerRight && (he.lowerRight = pos);
      }
    }
  }
  mergeSort(hyperedges, 0, hyperedges.length, null);
  southSequence = initUnidimensionalArray(I_classLit, $intern_49, 23, hyperedges.length, 15, 1);
  compressDeltas = initUnidimensionalArray(I_classLit, $intern_49, 23, targetCount + 1, 15, 1);
  for (i0 = 0; i0 < hyperedges.length; i0++) {
    southSequence[i0] = hyperedges[i0].upperRight;
    compressDeltas[southSequence[i0]] = 1;
  }
  delta = 0;
  for (i1 = 0; i1 < compressDeltas.length; i1++) {
    compressDeltas[i1] == 1?(compressDeltas[i1] = delta):--delta;
  }
  q = 0;
  for (i2 = 0; i2 < southSequence.length; i2++) {
    southSequence[i2] += compressDeltas[southSequence[i2]];
    q = max_1(q, southSequence[i2] + 1);
  }
  firstIndex = 1;
  while (firstIndex < q) {
    firstIndex *= 2;
  }
  treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  tree = initUnidimensionalArray(I_classLit, $intern_49, 23, treeSize, 15, 1);
  crossings = 0;
  for (k = 0; k < southSequence.length; k++) {
    index_0 = southSequence[k] + firstIndex;
    ++tree[index_0];
    while (index_0 > 0) {
      index_0 % 2 > 0 && (crossings += tree[index_0 + 1]);
      index_0 = (index_0 - 1) / 2 | 0;
      ++tree[index_0];
    }
  }
  leftCorners = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner_2_classLit, $intern_1, 349, hyperedges.length * 2, 0, 1);
  for (i3 = 0; i3 < hyperedges.length; i3++) {
    leftCorners[2 * i3] = new HyperedgeCrossingsCounter$HyperedgeCorner(hyperedges[i3], hyperedges[i3].upperLeft, hyperedges[i3].lowerLeft, ($clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type() , UPPER));
    leftCorners[2 * i3 + 1] = new HyperedgeCrossingsCounter$HyperedgeCorner(hyperedges[i3], hyperedges[i3].lowerLeft, hyperedges[i3].upperLeft, LOWER);
  }
  mergeSort(leftCorners, 0, leftCorners.length, null);
  openHyperedges = 0;
  for (i4 = 0; i4 < leftCorners.length; i4++) {
    switch (leftCorners[i4].type_0.ordinal) {
      case 0:
        ++openHyperedges;
        break;
      case 1:
        --openHyperedges;
        crossings += openHyperedges;
    }
  }
  rightCorners = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner_2_classLit, $intern_1, 349, hyperedges.length * 2, 0, 1);
  for (i5 = 0; i5 < hyperedges.length; i5++) {
    rightCorners[2 * i5] = new HyperedgeCrossingsCounter$HyperedgeCorner(hyperedges[i5], hyperedges[i5].upperRight, hyperedges[i5].lowerRight, ($clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type() , UPPER));
    rightCorners[2 * i5 + 1] = new HyperedgeCrossingsCounter$HyperedgeCorner(hyperedges[i5], hyperedges[i5].lowerRight, hyperedges[i5].upperRight, LOWER);
  }
  mergeSort(rightCorners, 0, rightCorners.length, null);
  openHyperedges = 0;
  for (i = 0; i < rightCorners.length; i++) {
    switch (rightCorners[i].type_0.ordinal) {
      case 0:
        ++openHyperedges;
        break;
      case 1:
        --openHyperedges;
        crossings += openHyperedges;
    }
  }
  return crossings;
}

function HyperedgeCrossingsCounter(portPos){
  this.portPos = portPos;
}

defineClass(1641, 1, {}, HyperedgeCrossingsCounter);
var Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'HyperedgeCrossingsCounter', 1641);
function $compareTo_14(this$static, other){
  if (this$static.upperLeft < other.upperLeft) {
    return -1;
  }
   else if (this$static.upperLeft > other.upperLeft) {
    return 1;
  }
   else if (this$static.upperRight < other.upperRight) {
    return -1;
  }
   else if (this$static.upperRight > other.upperRight) {
    return 1;
  }
  return hashCode__I__devirtual$(this$static) - hashCode__I__devirtual$(other);
}

function HyperedgeCrossingsCounter$Hyperedge(){
  this.edges = new ArrayList;
  this.ports = new ArrayList;
}

defineClass(442, 1, {34:1, 442:1}, HyperedgeCrossingsCounter$Hyperedge);
_.compareTo_0 = function compareTo_15(other){
  return $compareTo_14(this, castTo(other, 442));
}
;
_.lowerLeft = 0;
_.lowerRight = 0;
_.upperLeft = 0;
_.upperRight = 0;
var Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter$Hyperedge_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'HyperedgeCrossingsCounter/Hyperedge', 442);
function $compareTo_15(this$static, other){
  if (this$static.position < other.position) {
    return -1;
  }
   else if (this$static.position > other.position) {
    return 1;
  }
   else if (this$static.oppositePosition < other.oppositePosition) {
    return -1;
  }
   else if (this$static.oppositePosition > other.oppositePosition) {
    return 1;
  }
   else if (this$static.hyperedge != other.hyperedge) {
    return hashCode__I__devirtual$(this$static.hyperedge) - hashCode__I__devirtual$(other.hyperedge);
  }
   else if (this$static.type_0 == ($clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type() , UPPER) && other.type_0 == LOWER) {
    return -1;
  }
   else if (this$static.type_0 == LOWER && other.type_0 == UPPER) {
    return 1;
  }
  return 0;
}

function HyperedgeCrossingsCounter$HyperedgeCorner(hyperedge, position, oppositePosition, type_0){
  this.hyperedge = hyperedge;
  this.position = position;
  this.oppositePosition = oppositePosition;
  this.type_0 = type_0;
}

defineClass(349, 1, {34:1, 349:1}, HyperedgeCrossingsCounter$HyperedgeCorner);
_.compareTo_0 = function compareTo_16(other){
  return $compareTo_15(this, castTo(other, 349));
}
;
_.oppositePosition = 0;
_.position = 0;
var Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner_2_classLit = createForClass('org.eclipse.elk.alg.layered.p3order.counting', 'HyperedgeCrossingsCounter/HyperedgeCorner', 349);
function $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type(){
  $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type = emptyMethod;
  UPPER = new HyperedgeCrossingsCounter$HyperedgeCorner$Type('UPPER', 0);
  LOWER = new HyperedgeCrossingsCounter$HyperedgeCorner$Type('LOWER', 1);
}

function HyperedgeCrossingsCounter$HyperedgeCorner$Type(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_61(name_0){
  $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type();
  return valueOf(($clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type$Map() , $MAP_49), name_0);
}

function values_57(){
  $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner$Type_2_classLit, 1), $intern_38, 492, 0, [UPPER, LOWER]);
}

defineClass(492, 22, {3:1, 34:1, 22:1, 492:1}, HyperedgeCrossingsCounter$HyperedgeCorner$Type);
var LOWER, UPPER;
var Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner$Type_2_classLit = createForEnum('org.eclipse.elk.alg.layered.p3order.counting', 'HyperedgeCrossingsCounter/HyperedgeCorner/Type', 492, Ljava_lang_Enum_2_classLit, values_57, valueOf_61);
function $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type$Map(){
  $clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type$Map = emptyMethod;
  $MAP_49 = createValueOfMap(($clinit_HyperedgeCrossingsCounter$HyperedgeCorner$Type() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p3order_counting_HyperedgeCrossingsCounter$HyperedgeCorner$Type_2_classLit, 1), $intern_38, 492, 0, [UPPER, LOWER])));
}

var $MAP_49;
function $clinit_InteractiveNodePlacer(){
  $clinit_InteractiveNodePlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS = $addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
}

function $placeNodes(this$static, layer){
  var minValidY, node, node$iterator, nodeType, originalYCoordinate, prevNodeType, spacing;
  minValidY = $intern_63;
  prevNodeType = ($clinit_LNode$NodeType() , NORMAL);
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    nodeType = node.type_0;
    if (nodeType != NORMAL) {
      originalYCoordinate = castToDouble($getProperty(node, ($clinit_InternalProperties_1() , ORIGINAL_DUMMY_NODE_POSITION)));
      if (originalYCoordinate == null) {
        minValidY = $wnd.Math.max(minValidY, 0);
        node.pos.y_0 = minValidY + $getVerticalSpacing(this$static.spacings, nodeType, prevNodeType);
      }
       else {
        node.pos.y_0 = (checkCriticalNotNull(originalYCoordinate) , originalYCoordinate);
      }
    }
    spacing = $getVerticalSpacing(this$static.spacings, nodeType, prevNodeType);
    node.pos.y_0 < minValidY + spacing + node.margin.top_0 && (node.pos.y_0 = minValidY + spacing + node.margin.top_0);
    minValidY = node.pos.y_0 + node.size_0.y_0 + node.margin.bottom;
    prevNodeType = nodeType;
  }
}

function $process_68(this$static, layeredGraph, monitor){
  var layer, layer$iterator;
  $begin(monitor, 'Interactive node placement', 1);
  this$static.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    $placeNodes(this$static, layer);
  }
  $done_0(monitor);
}

function InteractiveNodePlacer(){
  $clinit_InteractiveNodePlacer();
}

defineClass(1276, 1, $intern_117, InteractiveNodePlacer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_10(graph){
  return castTo($getProperty(castTo(graph, 32), ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS:null;
}
;
_.process = function process_63(layeredGraph, monitor){
  $process_68(this, castTo(layeredGraph, 32), monitor);
}
;
var HIERARCHY_PROCESSING_ADDITIONS;
var Lorg_eclipse_elk_alg_layered_p4nodes_InteractiveNodePlacer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'InteractiveNodePlacer', 1276);
function $clinit_LinearSegmentsNodePlacer(){
  $clinit_LinearSegmentsNodePlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS_0 = $addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
  INPUT_PRIO = new Property_0('linearSegments.inputPrio', valueOf_4(0));
  OUTPUT_PRIO = new Property_0('linearSegments.outputPrio', valueOf_4(0));
}

function $balancePlacement(this$static, layeredGraph){
  var deflection, deflectionDampening, finalIters, incoming, lastTotalDeflection, merged, mode, node, node$iterator, outgoing, pendulumIters, ready, segment, segment$array, segment$array0, segment$index, segment$index0, segment$max, segment$max0, thoroughness, threshold, totalDeflection;
  deflectionDampening = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , NODE_PLACEMENT_LINEAR_SEGMENTS_DEFLECTION_DAMPENING_0))));
  thoroughness = castTo($getProperty(layeredGraph, THOROUGHNESS_0), 21).value_0;
  pendulumIters = 4;
  finalIters = 3;
  threshold = 20 / thoroughness;
  ready = false;
  mode = 0;
  lastTotalDeflection = $intern_0;
  do {
    incoming = mode != 1;
    outgoing = mode != 0;
    totalDeflection = 0;
    for (segment$array0 = this$static.linearSegments , segment$index0 = 0 , segment$max0 = segment$array0.length; segment$index0 < segment$max0; ++segment$index0) {
      segment = segment$array0[segment$index0];
      segment.refSegment = null;
      $calcDeflection(this$static, segment, incoming, outgoing, deflectionDampening);
      totalDeflection += $wnd.Math.abs(segment.deflection);
    }
    do {
      merged = $mergeRegions(this$static, layeredGraph);
    }
     while (merged);
    for (segment$array = this$static.linearSegments , segment$index = 0 , segment$max = segment$array.length; segment$index < segment$max; ++segment$index) {
      segment = segment$array[segment$index];
      deflection = $region(segment).deflection;
      if (deflection != 0) {
        for (node$iterator = new ArrayList$1(segment.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
          node = castTo($next_10(node$iterator), 9);
          node.pos.y_0 += deflection;
        }
      }
    }
    if (mode == 0 || mode == 1) {
      --pendulumIters;
      if (pendulumIters <= 0 && (totalDeflection < lastTotalDeflection || -pendulumIters > thoroughness)) {
        mode = 2;
        lastTotalDeflection = $intern_0;
      }
       else if (mode == 0) {
        mode = 1;
        lastTotalDeflection = totalDeflection;
      }
       else {
        mode = 0;
        lastTotalDeflection = totalDeflection;
      }
    }
     else {
      ready = totalDeflection >= lastTotalDeflection || lastTotalDeflection - totalDeflection < threshold;
      lastTotalDeflection = totalDeflection;
      ready && --finalIters;
    }
  }
   while (!(ready && finalIters <= 0));
}

function $calcDeflection(this$static, segment, incoming, outgoing, deflectionDampening){
  var edge, edge$iterator, edgeWeightSum, inputPrio, minPrio, node, node$iterator, nodeDeflection, nodeWeightSum, otherNode, otherPort, otherPrio, outputPrio, port, port$iterator, portpos, prio, segmentDeflection;
  segmentDeflection = 0;
  nodeWeightSum = 0;
  for (node$iterator = new ArrayList$1(segment.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    nodeDeflection = 0;
    edgeWeightSum = 0;
    inputPrio = incoming?castTo($getProperty(node, INPUT_PRIO), 21).value_0:$intern_43;
    outputPrio = outgoing?castTo($getProperty(node, OUTPUT_PRIO), 21).value_0:$intern_43;
    minPrio = inputPrio > outputPrio?inputPrio:outputPrio;
    for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
      port = castTo($next_10(port$iterator), 11);
      portpos = node.pos.y_0 + port.pos.y_0 + port.anchor.y_0;
      if (outgoing) {
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator), 16);
          otherPort = edge.target;
          otherNode = otherPort.owner;
          if (segment != this$static.linearSegments[otherNode.id_0]) {
            otherPrio = max_1(castTo($getProperty(otherNode, INPUT_PRIO), 21).value_0, castTo($getProperty(otherNode, OUTPUT_PRIO), 21).value_0);
            prio = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_STRAIGHTNESS_0)), 21).value_0;
            if (prio >= minPrio && prio >= otherPrio) {
              nodeDeflection += otherNode.pos.y_0 + otherPort.pos.y_0 + otherPort.anchor.y_0 - portpos;
              ++edgeWeightSum;
            }
          }
        }
      }
      if (incoming) {
        for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator), 16);
          otherPort = edge.source;
          otherNode = otherPort.owner;
          if (segment != this$static.linearSegments[otherNode.id_0]) {
            otherPrio = max_1(castTo($getProperty(otherNode, INPUT_PRIO), 21).value_0, castTo($getProperty(otherNode, OUTPUT_PRIO), 21).value_0);
            prio = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_STRAIGHTNESS_0)), 21).value_0;
            if (prio >= minPrio && prio >= otherPrio) {
              nodeDeflection += otherNode.pos.y_0 + otherPort.pos.y_0 + otherPort.anchor.y_0 - portpos;
              ++edgeWeightSum;
            }
          }
        }
      }
    }
    if (edgeWeightSum > 0) {
      segmentDeflection += nodeDeflection / edgeWeightSum;
      ++nodeWeightSum;
    }
  }
  if (nodeWeightSum > 0) {
    segment.deflection = deflectionDampening * segmentDeflection / nodeWeightSum;
    segment.weight = nodeWeightSum;
  }
   else {
    segment.deflection = 0;
    segment.weight = 0;
  }
}

function $createDependencyGraphEdges(layeredGraph, segmentList, outgoingList, incomingCountList){
  var currentNode, currentSegment, cycleNode, cycleNodesIter, cycleSegment, indexInLayer, layer, layer$iterator, layerIndex, nextLinearSegmentID, nextNode, nextSegment, nodeIter, nodes, previousNode;
  nextLinearSegmentID = segmentList.array.length;
  layerIndex = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    nodes = layer.nodes;
    if (nodes.array.length == 0) {
      continue;
    }
    nodeIter = new ArrayList$1(nodes);
    indexInLayer = 0;
    previousNode = null;
    currentNode = castTo($next_10(nodeIter), 9);
    while (currentNode) {
      currentSegment = castTo($get_7(segmentList, currentNode.id_0), 246);
      if (currentSegment.indexInLastLayer >= 0) {
        cycleSegment = null;
        cycleNodesIter = new AbstractList$ListIteratorImpl(layer.nodes, indexInLayer + 1);
        while (cycleNodesIter.i < cycleNodesIter.this$01_0.size_1()) {
          cycleNode = (checkCriticalElement(cycleNodesIter.i < cycleNodesIter.this$01_0.size_1()) , castTo(cycleNodesIter.this$01_0.get_3(cycleNodesIter.last = cycleNodesIter.i++), 9));
          cycleSegment = castTo($get_7(segmentList, cycleNode.id_0), 246);
          if (cycleSegment.lastLayer == currentSegment.lastLayer && cycleSegment.indexInLastLayer < currentSegment.indexInLastLayer) {
            break;
          }
           else {
            cycleSegment = null;
          }
        }
        if (cycleSegment) {
          if (previousNode) {
            $set_1(incomingCountList, currentNode.id_0, valueOf_4(castTo($get_7(incomingCountList, currentNode.id_0), 21).value_0 - 1));
            castTo($get_7(outgoingList, previousNode.id_0), 15).remove_1(currentSegment);
          }
          currentSegment = $split_3(currentSegment, currentNode, nextLinearSegmentID++);
          segmentList.array[segmentList.array.length] = currentSegment;
          $add_4(outgoingList, new ArrayList);
          if (previousNode) {
            castTo($get_7(outgoingList, previousNode.id_0), 15).add_1(currentSegment);
            $add_4(incomingCountList, valueOf_4(1));
          }
           else {
            $add_4(incomingCountList, valueOf_4(0));
          }
        }
      }
      nextNode = null;
      if (nodeIter.i < nodeIter.this$01.array.length) {
        nextNode = castTo($next_10(nodeIter), 9);
        nextSegment = castTo($get_7(segmentList, nextNode.id_0), 246);
        castTo($get_7(outgoingList, currentNode.id_0), 15).add_1(nextSegment);
        $set_1(incomingCountList, nextNode.id_0, valueOf_4(castTo($get_7(incomingCountList, nextNode.id_0), 21).value_0 + 1));
      }
      currentSegment.lastLayer = layerIndex;
      currentSegment.indexInLastLayer = indexInLayer++;
      previousNode = currentNode;
      currentNode = nextNode;
    }
    ++layerIndex;
  }
}

function $createUnbalancedPlacement(this$static, layeredGraph){
  var layer, layerIndex, node, node$iterator, node$iterator0, nodeCount, recentNode, recentNodeType, segment, segment$array, segment$index, segment$max, spacing, uppermostPlace;
  nodeCount = initUnidimensionalArray(I_classLit, $intern_49, 23, layeredGraph.layers.array.length, 15, 1);
  recentNodeType = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode$NodeType_2_classLit, $intern_38, 243, layeredGraph.layers.array.length, 0, 1);
  recentNode = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, layeredGraph.layers.array.length, 0, 1);
  for (segment$array = this$static.linearSegments , segment$index = 0 , segment$max = segment$array.length; segment$index < segment$max; ++segment$index) {
    segment = segment$array[segment$index];
    uppermostPlace = 0;
    for (node$iterator0 = new ArrayList$1(segment.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      layerIndex = $getIndex_0(node.layer);
      ++nodeCount[layerIndex];
      spacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_EDGE_EDGE))));
      nodeCount[layerIndex] > 0 && !!recentNode[layerIndex] && (spacing = $getVerticalSpacing_0(this$static.spacings, recentNode[layerIndex], node));
      uppermostPlace = $wnd.Math.max(uppermostPlace, node.layer.size_0.y_0 + spacing);
    }
    for (node$iterator = new ArrayList$1(segment.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      node.pos.y_0 = uppermostPlace + node.margin.top_0;
      layer = node.layer;
      layer.size_0.y_0 = uppermostPlace + node.margin.top_0 + node.size_0.y_0 + node.margin.bottom;
      recentNodeType[$indexOf_3(layer.owner.layers, layer, 0)] = node.type_0;
      recentNode[$indexOf_3(layer.owner.layers, layer, 0)] = node;
    }
  }
}

function $fillSegment(this$static, node, segment){
  var edgesIter, nodeType, sourcePort, sourcePort$iterator, targetNode, targetNodeType, targetPort, targetPort$iterator;
  nodeType = node.type_0;
  checkNotNull_1(castToBoolean($getProperty(node, ($clinit_InternalProperties_1() , BIG_NODE_INITIAL)))) && (nodeType = ($clinit_LNode$NodeType() , BIG_NODE));
  if (node.id_0 >= 0) {
    return false;
  }
   else if (!!segment.nodeType && nodeType == ($clinit_LNode$NodeType() , BIG_NODE) && nodeType != segment.nodeType) {
    return false;
  }
   else {
    node.id_0 = segment.id_0;
    $add_4(segment.nodes, node);
  }
  segment.nodeType = nodeType;
  if (nodeType == ($clinit_LNode$NodeType() , LONG_EDGE) || nodeType == NORTH_SOUTH_PORT || nodeType == BIG_NODE) {
    for (sourcePort$iterator = new ArrayList$1(node.ports); sourcePort$iterator.i < sourcePort$iterator.this$01.array.length;) {
      sourcePort = castTo($next_10(sourcePort$iterator), 11);
      for (targetPort$iterator = (edgesIter = new ArrayList$1((new LPort$8(sourcePort)).this$01.outgoingEdges) , new LPort$8$1(edgesIter)); $hasNext_2(targetPort$iterator.val$edgesIter2);) {
        targetPort = castTo($next_10(targetPort$iterator.val$edgesIter2), 16).target;
        targetNode = targetPort.owner;
        targetNodeType = targetNode.type_0;
        if (node.layer != targetNode.layer) {
          if (nodeType == BIG_NODE) {
            if (targetNodeType == BIG_NODE) {
              if ($fillSegment(this$static, targetNode, segment)) {
                return true;
              }
            }
          }
           else {
            if (targetNodeType == LONG_EDGE || targetNodeType == NORTH_SOUTH_PORT) {
              if ($fillSegment(this$static, targetNode, segment)) {
                return true;
              }
            }
          }
        }
      }
    }
  }
  return true;
}

function $mergeRegions(this$static, layeredGraph){
  var changed, layer, layer$iterator, node1, node1Extent, node2, node2Extent, nodeIter, nodeSpacing, region1, region2, spacing, threshold, weightSum;
  changed = false;
  nodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
  threshold = $intern_42 * nodeSpacing;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    nodeIter = new ArrayList$1(layer.nodes);
    node1 = castTo($next_10(nodeIter), 9);
    region1 = $region(this$static.linearSegments[node1.id_0]);
    while (nodeIter.i < nodeIter.this$01.array.length) {
      node2 = castTo($next_10(nodeIter), 9);
      region2 = $region(this$static.linearSegments[node2.id_0]);
      if (region1 != region2) {
        spacing = $getVerticalSpacing_0(this$static.spacings, node1, node2);
        node1Extent = node1.pos.y_0 + node1.size_0.y_0 + node1.margin.bottom + region1.deflection + spacing;
        node2Extent = node2.pos.y_0 - node2.margin.top_0 + region2.deflection;
        if (node1Extent > node2Extent + threshold) {
          weightSum = region1.weight + region2.weight;
          region2.deflection = (region2.weight * region2.deflection + region1.weight * region1.deflection) / weightSum;
          region2.weight = weightSum;
          region1.refSegment = region2;
          changed = true;
        }
      }
      node1 = node2;
      region1 = region2;
    }
  }
  return changed;
}

function $postProcess(this$static){
  var d, edge, edge$iterator, firstNode, foundPlace, index_0, lastNode, minDisplacement, minRoomAbove, minRoomBelow, neighbor, node, node$iterator, node$iterator0, pos, roomAbove, roomBelow, segment, segment$array, segment$index, segment$max, source, source$iterator, spacing, target, target$iterator;
  for (segment$array = this$static.linearSegments , segment$index = 0 , segment$max = segment$array.length; segment$index < segment$max; ++segment$index) {
    segment = segment$array[segment$index];
    minRoomAbove = $intern_0;
    minRoomBelow = $intern_0;
    for (node$iterator0 = new ArrayList$1(segment.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
      node = castTo($next_10(node$iterator0), 9);
      index_0 = !node.layer?-1:$indexOf_3(node.layer.nodes, node, 0);
      if (index_0 > 0) {
        neighbor = castTo($get_7(node.layer.nodes, index_0 - 1), 9);
        spacing = $getVerticalSpacing_0(this$static.spacings, node, neighbor);
        roomAbove = node.pos.y_0 - node.margin.top_0 - (neighbor.pos.y_0 + neighbor.size_0.y_0 + neighbor.margin.bottom + spacing);
      }
       else {
        roomAbove = node.pos.y_0 - node.margin.top_0;
      }
      minRoomAbove = $wnd.Math.min(roomAbove, minRoomAbove);
      if (index_0 < node.layer.nodes.array.length - 1) {
        neighbor = castTo($get_7(node.layer.nodes, index_0 + 1), 9);
        spacing = $getVerticalSpacing_0(this$static.spacings, node, neighbor);
        roomBelow = neighbor.pos.y_0 - neighbor.margin.top_0 - (node.pos.y_0 + node.size_0.y_0 + node.margin.bottom + spacing);
      }
       else {
        roomBelow = 2 * node.pos.y_0;
      }
      minRoomBelow = $wnd.Math.min(roomBelow, minRoomBelow);
    }
    minDisplacement = $intern_0;
    foundPlace = false;
    firstNode = castTo($get_7(segment.nodes, 0), 9);
    for (target$iterator = new ArrayList$1(firstNode.ports); target$iterator.i < target$iterator.this$01.array.length;) {
      target = castTo($next_10(target$iterator), 11);
      pos = firstNode.pos.y_0 + target.pos.y_0 + target.anchor.y_0;
      for (edge$iterator = new ArrayList$1(target.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        source = edge.source;
        d = source.owner.pos.y_0 + source.pos.y_0 + source.anchor.y_0 - pos;
        if ($wnd.Math.abs(d) < $wnd.Math.abs(minDisplacement) && $wnd.Math.abs(d) < (d < 0?minRoomAbove:minRoomBelow)) {
          minDisplacement = d;
          foundPlace = true;
        }
      }
    }
    lastNode = castTo($get_7(segment.nodes, segment.nodes.array.length - 1), 9);
    for (source$iterator = new ArrayList$1(lastNode.ports); source$iterator.i < source$iterator.this$01.array.length;) {
      source = castTo($next_10(source$iterator), 11);
      pos = lastNode.pos.y_0 + source.pos.y_0 + source.anchor.y_0;
      for (edge$iterator = new ArrayList$1(source.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        target = edge.target;
        d = target.owner.pos.y_0 + target.pos.y_0 + target.anchor.y_0 - pos;
        if ($wnd.Math.abs(d) < $wnd.Math.abs(minDisplacement) && $wnd.Math.abs(d) < (d < 0?minRoomAbove:minRoomBelow)) {
          minDisplacement = d;
          foundPlace = true;
        }
      }
    }
    if (foundPlace && minDisplacement != 0) {
      for (node$iterator = new ArrayList$1(segment.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
        node = castTo($next_10(node$iterator), 9);
        node.pos.y_0 += minDisplacement;
      }
    }
  }
}

function $process_69(this$static, layeredGraph, monitor){
  $begin(monitor, 'Linear segments node placement', 1);
  this$static.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  $sortLinearSegments(this$static, layeredGraph);
  $createUnbalancedPlacement(this$static, layeredGraph);
  $balancePlacement(this$static, layeredGraph);
  $postProcess(this$static);
  this$static.linearSegments = null;
  this$static.spacings = null;
  $done_0(monitor);
}

function $sortLinearSegments(this$static, layeredGraph){
  var edge, edge$iterator, edge$iterator0, i, i0, i1, i2, incomingCount, incomingCountList, inprio, layer, layer$iterator, layer$iterator0, ls, newRanks, nextLinearSegmentID, nextRank, noIncoming, node, node$iterator, outgoing, outgoingList, outprio, port, port$iterator, prio, rank, segment, segmentList, segments, target;
  segmentList = new ArrayList;
  for (layer$iterator0 = new ArrayList$1(layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator0), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      node.id_0 = -1;
      inprio = $intern_43;
      outprio = $intern_43;
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_10(port$iterator), 11);
        for (edge$iterator0 = new ArrayList$1(port.incomingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator0), 16);
          prio = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_STRAIGHTNESS_0)), 21).value_0;
          inprio = inprio > prio?inprio:prio;
        }
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator), 16);
          prio = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_STRAIGHTNESS_0)), 21).value_0;
          outprio = outprio > prio?outprio:prio;
        }
      }
      $setProperty_0(node, INPUT_PRIO, valueOf_4(inprio));
      $setProperty_0(node, OUTPUT_PRIO, valueOf_4(outprio));
    }
  }
  nextLinearSegmentID = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      if (node.id_0 < 0) {
        segment = new LinearSegmentsNodePlacer$LinearSegment;
        segment.id_0 = nextLinearSegmentID++;
        $fillSegment(this$static, node, segment);
        segmentList.array[segmentList.array.length] = segment;
      }
    }
  }
  outgoingList = newArrayListWithCapacity(segmentList.array.length);
  incomingCountList = newArrayListWithCapacity(segmentList.array.length);
  for (i0 = 0; i0 < segmentList.array.length; i0++) {
    $add_4(outgoingList, new ArrayList);
    $add_4(incomingCountList, valueOf_4(0));
  }
  $createDependencyGraphEdges(layeredGraph, segmentList, outgoingList, incomingCountList);
  segments = castTo($toArray_2(segmentList, initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p4nodes_LinearSegmentsNodePlacer$LinearSegment_2_classLit, $intern_120, 246, segmentList.array.length, 0, 1)), 774);
  outgoing = castTo($toArray_2(outgoingList, initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, outgoingList.array.length, 0, 1)), 180);
  incomingCount = initUnidimensionalArray(I_classLit, $intern_49, 23, incomingCountList.array.length, 15, 1);
  for (i1 = 0; i1 < incomingCount.length; i1++) {
    incomingCount[i1] = (checkCriticalElementIndex(i1, incomingCountList.array.length) , castTo(incomingCountList.array[i1], 21)).value_0;
  }
  nextRank = 0;
  noIncoming = new ArrayList;
  for (i2 = 0; i2 < segments.length; i2++) {
    incomingCount[i2] == 0 && $add_4(noIncoming, segments[i2]);
  }
  newRanks = initUnidimensionalArray(I_classLit, $intern_49, 23, segments.length, 15, 1);
  while (noIncoming.array.length != 0) {
    segment = castTo($remove_12(noIncoming, 0), 246);
    newRanks[segment.id_0] = nextRank++;
    while (!outgoing[segment.id_0].isEmpty()) {
      target = castTo(outgoing[segment.id_0].remove_2(0), 246);
      --incomingCount[target.id_0];
      incomingCount[target.id_0] == 0 && (noIncoming.array[noIncoming.array.length] = target , true);
    }
  }
  this$static.linearSegments = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p4nodes_LinearSegmentsNodePlacer$LinearSegment_2_classLit, $intern_120, 246, segments.length, 0, 1);
  for (i = 0; i < segments.length; i++) {
    ls = segments[i];
    rank = newRanks[i];
    this$static.linearSegments[rank] = ls;
    ls.id_0 = rank;
    for (node$iterator = new ArrayList$1(ls.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      node.id_0 = rank;
    }
  }
  return this$static.linearSegments;
}

function LinearSegmentsNodePlacer(){
  $clinit_LinearSegmentsNodePlacer();
}

defineClass(1277, 1, $intern_117, LinearSegmentsNodePlacer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_11(graph){
  return castTo($getProperty(castTo(graph, 32), ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS_0:null;
}
;
_.process = function process_64(layeredGraph, monitor){
  $process_69(this, castTo(layeredGraph, 32), monitor);
}
;
var HIERARCHY_PROCESSING_ADDITIONS_0, INPUT_PRIO, OUTPUT_PRIO;
var Lorg_eclipse_elk_alg_layered_p4nodes_LinearSegmentsNodePlacer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'LinearSegmentsNodePlacer', 1277);
function $compareTo_16(this$static, other){
  return this$static.id_0 - other.id_0;
}

function $region(this$static){
  var seg;
  seg = this$static;
  while (seg.refSegment) {
    seg = seg.refSegment;
  }
  return seg;
}

function $split_3(this$static, node, newId){
  var iterator, movedNode, newSegment, nodeIndex;
  nodeIndex = $indexOf_3(this$static.nodes, node, 0);
  newSegment = new LinearSegmentsNodePlacer$LinearSegment;
  newSegment.id_0 = newId;
  iterator = new AbstractList$ListIteratorImpl(this$static.nodes, nodeIndex);
  while (iterator.i < iterator.this$01_0.size_1()) {
    movedNode = (checkCriticalElement(iterator.i < iterator.this$01_0.size_1()) , castTo(iterator.this$01_0.get_3(iterator.last = iterator.i++), 9));
    movedNode.id_0 = newId;
    $add_4(newSegment.nodes, movedNode);
    $remove_9(iterator);
  }
  return newSegment;
}

function LinearSegmentsNodePlacer$LinearSegment(){
  this.nodes = new ArrayList;
}

defineClass(246, 1, {34:1, 246:1}, LinearSegmentsNodePlacer$LinearSegment);
_.compareTo_0 = function compareTo_17(other){
  return $compareTo_16(this, castTo(other, 246));
}
;
_.equals_0 = function equals_154(object){
  var other;
  if (instanceOf(object, 246)) {
    other = castTo(object, 246);
    return this.id_0 == other.id_0;
  }
  return false;
}
;
_.hashCode_1 = function hashCode_57(){
  return this.id_0;
}
;
_.toString_0 = function toString_101(){
  return 'ls' + $toString_1(this.nodes);
}
;
_.deflection = 0;
_.id_0 = 0;
_.indexInLastLayer = -1;
_.lastLayer = -1;
_.weight = 0;
var Lorg_eclipse_elk_alg_layered_p4nodes_LinearSegmentsNodePlacer$LinearSegment_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'LinearSegmentsNodePlacer/LinearSegment', 246);
function $clinit_NetworkSimplexPlacer(){
  $clinit_NetworkSimplexPlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS_1 = $addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
}

function $applyPositions(this$static){
  var flexibleNode, l, l$iterator, lNode, lNode$iterator, label_0, label$iterator, maxY, minY, nNode, nf, nf0, nodeRep, p, p$iterator, placement, sizeDelta;
  for (l$iterator = new ArrayList$1(this$static.lGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    for (lNode$iterator = new ArrayList$1(l.nodes); lNode$iterator.i < lNode$iterator.this$01.array.length;) {
      lNode = castTo($next_10(lNode$iterator), 9);
      nodeRep = this$static.nodeReps[lNode.id_0];
      minY = nodeRep.head.layer;
      maxY = nodeRep.tail.layer;
      lNode.pos.y_0 = minY;
      sizeDelta = maxY - minY - lNode.size_0.y_0;
      flexibleNode = isFlexibleNode(lNode);
      nf0 = ($clinit_NodeFlexibility() , (!lNode.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):lNode.propertyMap).containsKey(($clinit_LayeredOptions() , NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0))?(nf = castTo($getProperty(lNode, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0), 184)):(nf = castTo($getProperty($getGraph(lNode), NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_0), 184)) , nf);
      flexibleNode && (nf0 == NODE_SIZE_WHERE_SPACE_PERMITS || nf0 == NODE_SIZE) && (lNode.size_0.y_0 += sizeDelta);
      if (flexibleNode && (nf0 == PORT_POSITION || nf0 == NODE_SIZE_WHERE_SPACE_PERMITS || nf0 == NODE_SIZE)) {
        for (p$iterator = new ArrayList$1(lNode.ports); p$iterator.i < p$iterator.this$01.array.length;) {
          p = castTo($next_10(p$iterator), 11);
          if (($clinit_PortSide() , SIDES_EAST_WEST).contains(p.side)) {
            nNode = castTo($get_6(this$static.portMap, p), 115);
            p.pos.y_0 = nNode.layer - minY;
          }
        }
        for (label$iterator = new ArrayList$1(lNode.labels); label$iterator.i < label$iterator.this$01.array.length;) {
          label_0 = castTo($next_10(label$iterator), 70);
          placement = castTo($getProperty(lNode, NODE_LABELS_PLACEMENT), 19);
          placement.contains(($clinit_NodeLabelPlacement() , V_BOTTOM_0))?(label_0.pos.y_0 += sizeDelta):placement.contains(V_CENTER_0) && (label_0.pos.y_0 += sizeDelta / 2);
        }
        (nf0 == NODE_SIZE_WHERE_SPACE_PERMITS || nf0 == NODE_SIZE) && $getPortSideView(lNode, ($clinit_PortSide() , SOUTH_1)).forEach_0(new NetworkSimplexPlacer$lambda$18$Type(sizeDelta));
      }
    }
  }
}

function $buildInitialAuxiliaryGraph(this$static){
  var l, l$iterator;
  for (l$iterator = new ArrayList$1(this$static.lGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    $transformLayer(this$static, l);
  }
  $forEach_2($filter($flatMap($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.lGraph.layers, 16)), new NetworkSimplexPlacer$lambda$2$Type), new NetworkSimplexPlacer$lambda$3$Type), new NetworkSimplexPlacer$lambda$4$Type), new NetworkSimplexPlacer$lambda$5$Type(this$static));
}

function $follow(this$static, edge, current, path){
  var incident, incident$iterator, other;
  other = $getOther_1(edge, current);
  path.array[path.array.length] = edge;
  if (this$static.nodeState[other.id_0] == -1 || this$static.nodeState[other.id_0] == 2 || this$static.crossing[edge.id_0]) {
    return path;
  }
  this$static.nodeState[other.id_0] = -1;
  for (incident$iterator = $iterator($getConnectedEdges_0(other)); $hasNext_0(incident$iterator);) {
    incident = castTo($next_2(incident$iterator), 16);
    if (!(!$isSelfLoop(incident) && !(!$isSelfLoop(incident) && incident.source.owner.layer == incident.target.owner.layer)) || incident == edge) {
      continue;
    }
    return $follow(this$static, incident, other, path);
  }
  return path;
}

function $getEdgeWeight(nodeType1, nodeType2){
  return nodeType1 == ($clinit_LNode$NodeType() , NORMAL) && nodeType2 == NORMAL?4:nodeType1 == NORMAL || nodeType2 == NORMAL?8:32;
}

function $improveTwoPath(this$static, path, probe){
  var a, above, aboveDist, aboveRep, b, below, belowDist, belowRep, c, caseA, caseB, caseC, caseD, centerNode, centerOrigin, d, leftEdge, move, nNode, nodeIndex, rightEdge, spacing;
  leftEdge = this$static.edgeReps[(checkCriticalElementIndex(0, path.array.length) , castTo(path.array[0], 16)).id_0];
  rightEdge = this$static.edgeReps[(checkCriticalElementIndex(1, path.array.length) , castTo(path.array[1], 16)).id_0];
  if (leftEdge.left.target.layer - leftEdge.left.delta - (leftEdge.right.target.layer - leftEdge.right.delta) == 0 && rightEdge.left.target.layer - rightEdge.left.delta - (rightEdge.right.target.layer - rightEdge.right.delta) == 0) {
    return false;
  }
  centerOrigin = leftEdge.right.target.origin;
  if (!instanceOf(centerOrigin, 9)) {
    return false;
  }
  centerNode = castTo(centerOrigin, 9);
  nNode = this$static.nodeReps[centerNode.id_0];
  nodeIndex = !centerNode.layer?-1:$indexOf_3(centerNode.layer.nodes, centerNode, 0);
  aboveDist = $intern_62;
  if (nodeIndex > 0) {
    above = castTo($get_7(centerNode.layer.nodes, nodeIndex - 1), 9);
    aboveRep = this$static.nodeReps[above.id_0];
    spacing = $wnd.Math.ceil($getVerticalSpacing_0(this$static.spacings, above, centerNode));
    aboveDist = nNode.head.layer - centerNode.margin.top_0 - (aboveRep.head.layer + above.size_0.y_0 + above.margin.bottom) - spacing;
  }
  belowDist = $intern_62;
  if (nodeIndex < centerNode.layer.nodes.array.length - 1) {
    below = castTo($get_7(centerNode.layer.nodes, nodeIndex + 1), 9);
    belowRep = this$static.nodeReps[below.id_0];
    spacing = $wnd.Math.ceil($getVerticalSpacing_0(this$static.spacings, below, centerNode));
    belowDist = belowRep.head.layer - below.margin.top_0 - (nNode.head.layer + centerNode.size_0.y_0 + centerNode.margin.bottom) - spacing;
  }
  if (probe && ($clinit_DoubleMath() , checkNonNegative($intern_121) , $wnd.Math.abs(aboveDist - belowDist) <= $intern_121 || aboveDist == belowDist || isNaN(aboveDist) && isNaN(belowDist))) {
    return true;
  }
  a = length_1(leftEdge.left);
  b = -length_1(leftEdge.right);
  c = -length_1(rightEdge.left);
  d = length_1(rightEdge.right);
  caseD = leftEdge.left.target.layer - leftEdge.left.delta - (leftEdge.right.target.layer - leftEdge.right.delta) > 0 && rightEdge.left.target.layer - rightEdge.left.delta - (rightEdge.right.target.layer - rightEdge.right.delta) < 0;
  caseC = leftEdge.left.target.layer - leftEdge.left.delta - (leftEdge.right.target.layer - leftEdge.right.delta) < 0 && rightEdge.left.target.layer - rightEdge.left.delta - (rightEdge.right.target.layer - rightEdge.right.delta) > 0;
  caseB = leftEdge.left.target.layer + leftEdge.right.delta < rightEdge.right.target.layer + rightEdge.left.delta;
  caseA = leftEdge.left.target.layer + leftEdge.right.delta > rightEdge.right.target.layer + rightEdge.left.delta;
  move = 0;
  !caseD && !caseC && (caseA?aboveDist + c > 0?(move = c):belowDist - a > 0 && (move = a):caseB && (aboveDist + b > 0?(move = b):belowDist - d > 0 && (move = d)));
  nNode.head.layer += move;
  nNode.isFlexible && (nNode.tail.layer += move);
  return false;
}

function $lambda$1_3(this$static, singleNode_1, p_1){
  return $put_1(this$static.portMap, p_1, singleNode_1);
}

function $lambda$10(this$static, inLayerEdge_0){
  var dummyNode, dummyRep, portRep, src_0, srcIsDummy, tgt, thePort;
  srcIsDummy = inLayerEdge_0.source.owner.type_0 != ($clinit_LNode$NodeType() , NORMAL);
  thePort = srcIsDummy?inLayerEdge_0.target:inLayerEdge_0.source;
  dummyNode = $getOther_2(inLayerEdge_0, thePort).owner;
  portRep = castTo($get_6(this$static.portMap, thePort), 115);
  dummyRep = this$static.nodeReps[dummyNode.id_0].head;
  if ($getIndex(thePort.owner) < (!dummyNode.layer?-1:$indexOf_3(dummyNode.layer.nodes, dummyNode, 0))) {
    src_0 = portRep;
    tgt = dummyRep;
  }
   else {
    src_0 = dummyRep;
    tgt = portRep;
  }
  $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 0), 4), src_0), tgt));
}

function $lambda$12_0(this$static, n_0){
  var other, sp, sp$iterator, sp$iterator0;
  for (sp$iterator0 = $getPortSideView(n_0, ($clinit_PortSide() , SOUTH_1)).iterator_0(); sp$iterator0.hasNext_0();) {
    sp = castTo(sp$iterator0.next_1(), 11);
    other = castTo($getProperty(sp, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
    !!other && $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 0), 0.1), this$static.nodeReps[n_0.id_0].tail), this$static.nodeReps[other.id_0].head));
  }
  for (sp$iterator = $getPortSideView(n_0, NORTH_1).iterator_0(); sp$iterator.hasNext_0();) {
    sp = castTo(sp$iterator.next_1(), 11);
    other = castTo($getProperty(sp, ($clinit_InternalProperties_1() , PORT_DUMMY)), 9);
    !!other && $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, 0), 0.1), this$static.nodeReps[other.id_0].tail), this$static.nodeReps[n_0.id_0].head));
  }
}

function $lambda$20_0(this$static, n_0){
  return this$static.nodeState[n_0.id_0] = getNodeState(n_0);
}

function $lambda$23(this$static, n_0){
  return this$static.nodeState[n_0.id_0] == 2;
}

function $lambda$24(this$static, paths_1, junction_1){
  var e, e$iterator, path;
  for (e$iterator = $iterator($getConnectedEdges_0(junction_1)); $hasNext_0(e$iterator);) {
    e = castTo($next_2(e$iterator), 16);
    if (!(!$isSelfLoop(e) && !(!$isSelfLoop(e) && e.source.owner.layer == e.target.owner.layer))) {
      continue;
    }
    path = $follow(this$static, e, junction_1, new NetworkSimplexPlacer$Path);
    path.array.length > 1 && (paths_1.array[paths_1.array.length] = path , true);
  }
}

function $lambda$27(this$static, left_0, right_1){
  $markCrossingEdges(this$static, left_0, right_1);
  return right_1;
}

function $markCrossingEdges(this$static, left, right){
  var edge, edge$iterator, last, node, node$iterator, node$iterator0, openEdges, openEdgesIt, port, port$iterator;
  openEdges = new ArrayList;
  for (node$iterator0 = new ArrayList$1(left.nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 9);
    for (port$iterator = $getPortSideView(node, ($clinit_PortSide() , EAST_1)).iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 11);
      for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        if (!$isSelfLoop(edge) && edge.source.owner.layer == edge.target.owner.layer || $isSelfLoop(edge) || edge.target.owner.layer != right) {
          continue;
        }
        openEdges.array[openEdges.array.length] = edge;
      }
    }
  }
  for (node$iterator = reverse_0(right.nodes).iterator_0(); node$iterator.hasNext_0();) {
    node = castTo(node$iterator.next_1(), 9);
    for (port$iterator = $getPortSideView(node, ($clinit_PortSide() , WEST_1)).iterator_0(); port$iterator.hasNext_0();) {
      port = castTo(port$iterator.next_1(), 11);
      for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
        edge = castTo($next_10(edge$iterator), 16);
        if (!$isSelfLoop(edge) && edge.source.owner.layer == edge.target.owner.layer || $isSelfLoop(edge) || edge.source.owner.layer != left) {
          continue;
        }
        openEdgesIt = new AbstractList$ListIteratorImpl(openEdges, openEdges.array.length);
        last = (checkCriticalElement(openEdgesIt.i > 0) , castTo(openEdgesIt.this$01.get_3(openEdgesIt.last = --openEdgesIt.i), 16));
        while (last != edge && openEdgesIt.i > 0) {
          this$static.crossing[last.id_0] = true;
          this$static.crossing[edge.id_0] = true;
          last = (checkCriticalElement(openEdgesIt.i > 0) , castTo(openEdgesIt.this$01.get_3(openEdgesIt.last = --openEdgesIt.i), 16));
        }
        openEdgesIt.i > 0 && $remove_9(openEdgesIt);
      }
    }
  }
}

function $postProcessTwoPaths(this$static){
  var path, q, s, tryAgain;
  q = new LinkedList;
  $addAll(q, this$static.twoPaths);
  s = new Stack;
  while (q.size_0 != 0) {
    path = castTo(q.size_0 == 0?null:(checkCriticalElement(q.size_0 != 0) , $removeNode_0(q, q.header.next_0)), 478);
    tryAgain = $improveTwoPath(this$static, path, true);
    tryAgain && $add_4(s.arrayList, path);
  }
  while (s.arrayList.array.length != 0) {
    path = castTo($pop(s), 478);
    $improveTwoPath(this$static, path, false);
  }
}

function $preferStraightEdges(this$static){
  var cur, curRep, identifiedPaths, last, oldLeftWeight, oldRightWeight, path, path$iterator, pathIt, weight, paths;
  this$static.nodeState = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.nodeCount, 15, 1);
  this$static.twoPaths = new ArrayList;
  $forEach_2($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.lGraph.layers, 16)), new NetworkSimplexPlacer$lambda$19$Type), new NetworkSimplexPlacer$lambda$20$Type(this$static));
  this$static.crossing = initUnidimensionalArray(Z_classLit, $intern_93, 23, this$static.edgeCount, 16, 1);
  $reduce_0(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.lGraph.layers, 16)), new NetworkSimplexPlacer$lambda$27$Type(this$static));
  identifiedPaths = (paths = new ArrayList , $forEach_2($filter($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.lGraph.layers, 16)), new NetworkSimplexPlacer$lambda$22$Type), new NetworkSimplexPlacer$lambda$23$Type(this$static)), new NetworkSimplexPlacer$lambda$24$Type(this$static, paths)) , paths);
  for (path$iterator = new ArrayList$1(identifiedPaths); path$iterator.i < path$iterator.this$01.array.length;) {
    path = castTo($next_10(path$iterator), 478);
    if (path.array.length <= 1) {
      continue;
    }
    if (path.array.length == 2) {
      $orderTwoPath(path);
      isFlexibleNode((checkCriticalElementIndex(0, path.array.length) , castTo(path.array[0], 16)).target.owner) || $add_4(this$static.twoPaths, path);
      continue;
    }
    if ($containsLongEdgeDummy(path) || $containsFlexibleNode(path, new NetworkSimplexPlacer$lambda$21$Type)) {
      continue;
    }
    pathIt = new ArrayList$1(path);
    last = null;
    while (pathIt.i < pathIt.this$01.array.length) {
      cur = castTo($next_10(pathIt), 16);
      curRep = this$static.edgeReps[cur.id_0];
      !last || pathIt.i >= pathIt.this$01.array.length?(weight = $getEdgeWeight(($clinit_LNode$NodeType() , NORMAL), LONG_EDGE)):(weight = $getEdgeWeight(($clinit_LNode$NodeType() , LONG_EDGE), LONG_EDGE));
      weight *= 2;
      oldLeftWeight = curRep.left.weight;
      curRep.left.weight = $wnd.Math.max(oldLeftWeight, oldLeftWeight + (weight - oldLeftWeight));
      oldRightWeight = curRep.right.weight;
      curRep.right.weight = $wnd.Math.max(oldRightWeight, oldRightWeight + (weight - oldRightWeight));
      last = cur;
    }
  }
}

function $prepare(this$static){
  var anchorMustBeInteger, e, e$iterator, edgeIdx, l, l$iterator, lNode, lNode$iterator, nodeIdx, offset, p, p$iterator, y_0, y0;
  this$static.nGraph = new NGraph;
  nodeIdx = 0;
  edgeIdx = 0;
  for (l$iterator = new ArrayList$1(this$static.lGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    for (lNode$iterator = new ArrayList$1(l.nodes); lNode$iterator.i < lNode$iterator.this$01.array.length;) {
      lNode = castTo($next_10(lNode$iterator), 9);
      lNode.id_0 = nodeIdx++;
      for (e$iterator = $iterator($getOutgoingEdges(lNode)); $hasNext_0(e$iterator);) {
        e = castTo($next_2(e$iterator), 16);
        e.id_0 = edgeIdx++;
      }
      anchorMustBeInteger = isFlexibleNode(lNode);
      for (p$iterator = new ArrayList$1(lNode.ports); p$iterator.i < p$iterator.this$01.array.length;) {
        p = castTo($next_10(p$iterator), 11);
        if (anchorMustBeInteger) {
          y0 = p.anchor.y_0;
          if (y0 != $wnd.Math.floor(y0)) {
            offset = y0 - toDouble_0(fromDouble_0($wnd.Math.round(y0)));
            p.anchor.y_0 -= offset;
          }
        }
        y_0 = p.pos.y_0 + p.anchor.y_0;
        if (y_0 != $wnd.Math.floor(y_0)) {
          offset = y_0 - toDouble_0(fromDouble_0($wnd.Math.round(y_0)));
          p.pos.y_0 -= offset;
        }
      }
    }
  }
  this$static.nodeCount = nodeIdx;
  this$static.edgeCount = edgeIdx;
  this$static.nodeReps = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$NodeRep_2_classLit, $intern_1, 429, nodeIdx, 0, 1);
  this$static.edgeReps = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$EdgeRep_2_classLit, $intern_1, 608, edgeIdx, 0, 1);
  this$static.flexibleWhereSpacePermitsEdges.map_0.clear_0();
}

function $process_70(this$static, layeredGraph, progressMonitor){
  var edge, edge$iterator, iterLimit, pm, minLayer, maxLayer, usedLayers, globalSource, globalSink;
  $begin(progressMonitor, 'Network simplex node placement', 1);
  this$static.lGraph = layeredGraph;
  this$static.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  $prepare(this$static);
  $buildInitialAuxiliaryGraph(this$static);
  $forEach_2($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.lGraph.layers, 16)), new NetworkSimplexPlacer$lambda$11$Type), new NetworkSimplexPlacer$lambda$12$Type(this$static));
  $forEach_2($filter($flatMap($filter($flatMap(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.lGraph.layers, 16)), new NetworkSimplexPlacer$lambda$6$Type), new NetworkSimplexPlacer$lambda$7$Type), new NetworkSimplexPlacer$lambda$8$Type), new NetworkSimplexPlacer$lambda$9$Type), new NetworkSimplexPlacer$lambda$10$Type(this$static));
  if (checkNotNull_1(castToBoolean($getProperty(this$static.lGraph, ($clinit_LayeredOptions() , NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_0))))) {
    pm = $subTask(progressMonitor, 1);
    $begin(pm, 'Straight Edges Pre-Processing', 1);
    $preferStraightEdges(this$static);
    $done_0(pm);
  }
  $makeConnected(this$static.nGraph);
  iterLimit = castTo($getProperty(layeredGraph, THOROUGHNESS_0), 21).value_0 * this$static.nGraph.nodes.array.length;
  $execute($withBalancing($withIterationLimit(forGraph(this$static.nGraph), iterLimit), false), $subTask(progressMonitor, 1));
  if (this$static.flexibleWhereSpacePermitsEdges.map_0.size_1() != 0) {
    pm = $subTask(progressMonitor, 1);
    $begin(pm, 'Flexible Where Space Processing', 1);
    minLayer = castTo($get_13($reduce_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.nGraph.nodes, 16)), new NetworkSimplexPlacer$lambda$13$Type), (checkCriticalNotNull(new NetworkSimplexPlacer$0methodref$compare$Type) , new BinaryOperator$lambda$1$Type))), 21).value_0;
    maxLayer = castTo($get_13($reduce_0($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.nGraph.nodes, 16)), new NetworkSimplexPlacer$lambda$14$Type), (checkCriticalNotNull(new NetworkSimplexPlacer$1methodref$compare$Type) , new BinaryOperator$lambda$0$Type))), 21).value_0;
    usedLayers = maxLayer - minLayer;
    globalSource = $create_2(new NNode$NNodeBuilder, this$static.nGraph);
    globalSink = $create_2(new NNode$NNodeBuilder, this$static.nGraph);
    $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, 20000), usedLayers), globalSource), globalSink));
    $forEach_2($filter($filter(stream_1(this$static.nodeReps), new NetworkSimplexPlacer$lambda$15$Type), new NetworkSimplexPlacer$lambda$16$Type), new NetworkSimplexPlacer$lambda$17$Type(minLayer, globalSource, usedLayers, globalSink));
    for (edge$iterator = this$static.flexibleWhereSpacePermitsEdges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
      edge = castTo(edge$iterator.next_1(), 193);
      edge.weight = 1;
    }
    $execute($withBalancing($withIterationLimit(forGraph(this$static.nGraph), iterLimit), false), $subTask(pm, 1));
    $done_0(pm);
  }
  if (checkNotNull_1(castToBoolean($getProperty(layeredGraph, NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_0)))) {
    pm = $subTask(progressMonitor, 1);
    $begin(pm, 'Straight Edges Post-Processing', 1);
    $postProcessTwoPaths(this$static);
    $done_0(pm);
  }
  $applyPositions(this$static);
  this$static.lGraph = null;
  this$static.nGraph = null;
  this$static.nodeReps = null;
  this$static.edgeReps = null;
  $reset(this$static.portMap);
  this$static.nodeState = null;
  this$static.crossing = null;
  this$static.twoPaths = null;
  this$static.flexibleWhereSpacePermitsEdges.map_0.clear_0();
  $done_0(progressMonitor);
}

function $transformEdge_0(this$static, lEdge){
  var dummy, edgeRep, left, right, srcDelta, srcOffset, srcPort, srcRep, tgtDelta, tgtOffset, tgtPort, tgtRep, weight, priority, edgeTypeWeight;
  dummy = $create_2(new NNode$NNodeBuilder, this$static.nGraph);
  srcRep = this$static.nodeReps[lEdge.source.owner.id_0];
  tgtRep = this$static.nodeReps[lEdge.target.owner.id_0];
  srcPort = lEdge.source;
  tgtPort = lEdge.target;
  srcOffset = srcPort.anchor.y_0;
  tgtOffset = tgtPort.anchor.y_0;
  srcRep.isFlexible || (srcOffset += srcPort.pos.y_0);
  tgtRep.isFlexible || (tgtOffset += tgtPort.pos.y_0);
  tgtDelta = round_int($wnd.Math.max(0, srcOffset - tgtOffset));
  srcDelta = round_int($wnd.Math.max(0, tgtOffset - srcOffset));
  weight = (priority = max_1(1, castTo($getProperty(lEdge, ($clinit_LayeredOptions() , PRIORITY_STRAIGHTNESS_0)), 21).value_0) , edgeTypeWeight = $getEdgeWeight(lEdge.source.owner.type_0, lEdge.target.owner.type_0) , priority * edgeTypeWeight);
  left = $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, weight), srcDelta), dummy), castTo($get_6(this$static.portMap, lEdge.source), 115)));
  right = $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, weight), tgtDelta), dummy), castTo($get_6(this$static.portMap, lEdge.target), 115)));
  edgeRep = new NetworkSimplexPlacer$EdgeRep(left, right);
  this$static.edgeReps[lEdge.id_0] = edgeRep;
}

function $transformLayer(this$static, layer){
  var lNode, lNode$iterator, lastRep, nodeRep, spacing, topLeft, bottomLeft, corners, minHeight, nf0, nf, sizeWeight, nodeSizeEdge, singleNode;
  lastRep = null;
  for (lNode$iterator = new ArrayList$1(layer.nodes); lNode$iterator.i < lNode$iterator.this$01.array.length;) {
    lNode = castTo($next_10(lNode$iterator), 9);
    isFlexibleNode(lNode)?(nodeRep = (topLeft = $create_2($origin_0(new NNode$NNodeBuilder, lNode), this$static.nGraph) , bottomLeft = $create_2($origin_0(new NNode$NNodeBuilder, lNode), this$static.nGraph) , corners = new NetworkSimplexPlacer$NodeRep(lNode, true, topLeft, bottomLeft) , minHeight = lNode.size_0.y_0 , nf0 = ($clinit_NodeFlexibility() , (!lNode.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):lNode.propertyMap).containsKey(($clinit_LayeredOptions() , NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0))?(nf = castTo($getProperty(lNode, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0), 184)):(nf = castTo($getProperty($getGraph(lNode), NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_0), 184)) , nf) , sizeWeight = $intern_68 , nf0 == NODE_SIZE && (sizeWeight = 1) , nodeSizeEdge = $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, sizeWeight), round_int($wnd.Math.ceil(minHeight))), topLeft), bottomLeft)) , nf0 == NODE_SIZE_WHERE_SPACE_PERMITS && $add_6(this$static.flexibleWhereSpacePermitsEdges, nodeSizeEdge) , $transformPorts(this$static, reverse_0($getPortSideView(lNode, ($clinit_PortSide() , WEST_1))), corners) , $transformPorts(this$static, $getPortSideView(lNode, EAST_1), corners) , corners)):(nodeRep = (singleNode = $create_2($origin_0(new NNode$NNodeBuilder, lNode), this$static.nGraph) , $forEach_2($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(lNode.ports, 16)), new NetworkSimplexPlacer$lambda$0$Type), new NetworkSimplexPlacer$lambda$1$Type(this$static, singleNode)) , new NetworkSimplexPlacer$NodeRep(lNode, false, singleNode, singleNode)));
    this$static.nodeReps[lNode.id_0] = nodeRep;
    if (lastRep) {
      spacing = lastRep.origin.margin.bottom + $getVerticalSpacing_0(this$static.spacings, lastRep.origin, lNode) + lNode.margin.top_0;
      lastRep.isFlexible || (spacing += lastRep.origin.size_0.y_0);
      $create_1($target($source($weight($delta(new NEdge$NEdgeBuilder, round_int($wnd.Math.ceil(spacing))), 0), lastRep.tail), nodeRep.head));
    }
    lastRep = nodeRep;
  }
}

function $transformPorts(this$static, ports, corners){
  var lastNNode, lastPort, nNode, port, port$iterator, portSpacing, portSurrounding, spacing;
  if (isEmpty_10(ports)) {
    return;
  }
  portSpacing = checkNotNull_1(castToDouble(getIndividualOrDefault(corners.origin, ($clinit_LayeredOptions() , SPACING_PORT_PORT))));
  portSurrounding = castTo(getIndividualOrDefault(corners.origin, SPACING_PORTS_SURROUNDING), 137);
  !portSurrounding && (portSurrounding = new ElkMargin);
  lastNNode = corners.head;
  lastPort = null;
  for (port$iterator = ports.iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    if (!lastPort) {
      spacing = portSurrounding.top_0;
    }
     else {
      spacing = portSpacing;
      spacing += lastPort.size_0.y_0;
    }
    nNode = $create_2($origin_0(new NNode$NNodeBuilder, port), this$static.nGraph);
    $put_1(this$static.portMap, port, nNode);
    $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, 0), round_int($wnd.Math.ceil(spacing))), lastNNode), nNode));
    lastPort = port;
    lastNNode = nNode;
  }
  $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, 0), round_int($wnd.Math.ceil(portSurrounding.bottom + lastPort.size_0.y_0))), lastNNode), corners.tail));
}

function NetworkSimplexPlacer(){
  $clinit_NetworkSimplexPlacer();
  this.portMap = ($clinit_Maps() , new HashMap);
  this.flexibleWhereSpacePermitsEdges = new HashSet;
}

function getNodeState(node){
  var inco, ouco, p, p$iterator;
  inco = 0;
  ouco = 0;
  for (p$iterator = new ArrayList$1(node.ports); p$iterator.i < p$iterator.this$01.array.length;) {
    p = castTo($next_10(p$iterator), 11);
    inco = toInt_0(add_20(inco, $count_0($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(p.incomingEdges, 16)), new NetworkSimplexPlacer$lambda$25$Type))));
    ouco = toInt_0(add_20(ouco, $count_0($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(p.outgoingEdges, 16)), new NetworkSimplexPlacer$lambda$26$Type))));
    if (inco > 1 || ouco > 1) {
      return 2;
    }
  }
  if (inco + ouco == 1) {
    return 2;
  }
  return 0;
}

function isFlexibleNode(lNode){
  var additionalPortSpacing, eastPorts, nf, nf0, pc, portSpacing, requiredEastHeight, requiredWestHeight, westPorts;
  if (lNode.type_0 != ($clinit_LNode$NodeType() , NORMAL)) {
    return false;
  }
  if (lNode.ports.array.length <= 1) {
    return false;
  }
  pc = castTo($getProperty(lNode, ($clinit_LayeredOptions() , PORT_CONSTRAINTS_0)), 83);
  if (pc == ($clinit_PortConstraints() , FIXED_POS)) {
    return false;
  }
  nf0 = ($clinit_NodeFlexibility() , (!lNode.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):lNode.propertyMap).containsKey(NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0)?(nf = castTo($getProperty(lNode, NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_0), 184)):(nf = castTo($getProperty($getGraph(lNode), NODE_PLACEMENT_NETWORK_SIMPLEX_NODE_FLEXIBILITY_DEFAULT_0), 184)) , nf);
  if (nf0 == NONE_5) {
    return false;
  }
  if (!(nf0 == NODE_SIZE_WHERE_SPACE_PERMITS || nf0 == NODE_SIZE)) {
    portSpacing = checkNotNull_1(castToDouble(getIndividualOrDefault(lNode, SPACING_PORT_PORT)));
    additionalPortSpacing = castTo($getProperty(lNode, SPACING_PORTS_SURROUNDING), 137);
    !additionalPortSpacing && (additionalPortSpacing = new ElkMargin_1(portSpacing, portSpacing, portSpacing, portSpacing));
    westPorts = $getPortSideView(lNode, ($clinit_PortSide() , WEST_1));
    requiredWestHeight = additionalPortSpacing.top_0 + additionalPortSpacing.bottom + (westPorts.size_1() - 1) * portSpacing;
    if (requiredWestHeight > lNode.size_0.y_0) {
      return false;
    }
    eastPorts = $getPortSideView(lNode, EAST_1);
    requiredEastHeight = additionalPortSpacing.top_0 + additionalPortSpacing.bottom + (eastPorts.size_1() - 1) * portSpacing;
    if (requiredEastHeight > lNode.size_0.y_0) {
      return false;
    }
  }
  return true;
}

function isHandledEdge(edge){
  $clinit_NetworkSimplexPlacer();
  return !$isSelfLoop(edge) && !(!$isSelfLoop(edge) && edge.source.owner.layer == edge.target.owner.layer);
}

function lambda$17(minLayer_0, globalSource_1, usedLayers_2, globalSink_3, nr_4){
  $clinit_NetworkSimplexPlacer();
  $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, 0), nr_4.tail.layer - minLayer_0), globalSource_1), nr_4.tail));
  $create_1($target($source($delta($weight(new NEdge$NEdgeBuilder, 0), usedLayers_2 - nr_4.head.layer), nr_4.head), globalSink_3));
}

function lambda$18(sizeDelta_0, p_1){
  $clinit_NetworkSimplexPlacer();
  return p_1.pos.y_0 += sizeDelta_0;
}

function length_1(edge){
  return abs_0(edge.source.layer - edge.target.layer) - edge.delta;
}

defineClass(1279, 1, $intern_117, NetworkSimplexPlacer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_12(graph){
  return castTo($getProperty(castTo(graph, 32), ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS_1:null;
}
;
_.process = function process_65(layeredGraph, progressMonitor){
  $process_70(this, castTo(layeredGraph, 32), progressMonitor);
}
;
_.edgeCount = 0;
_.nodeCount = 0;
var HIERARCHY_PROCESSING_ADDITIONS_1;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer', 1279);
function NetworkSimplexPlacer$0methodref$compare$Type(){
}

defineClass(1298, 1, $intern_40, NetworkSimplexPlacer$0methodref$compare$Type);
_.equals_0 = function equals_155(other){
  return this === other;
}
;
_.reversed = function reversed_56(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_64(arg0, arg1){
  return compare_6(castTo(arg0, 21).value_0, castTo(arg1, 21).value_0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$0methodref$compare$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/0methodref$compare$Type', 1298);
function NetworkSimplexPlacer$1methodref$compare$Type(){
}

defineClass(1300, 1, $intern_40, NetworkSimplexPlacer$1methodref$compare$Type);
_.equals_0 = function equals_156(other){
  return this === other;
}
;
_.reversed = function reversed_57(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_65(arg0, arg1){
  return compare_6(castTo(arg0, 21).value_0, castTo(arg1, 21).value_0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$1methodref$compare$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/1methodref$compare$Type', 1300);
function NetworkSimplexPlacer$EdgeRep(left, right){
  this.left = left;
  this.right = right;
}

defineClass(608, 1, {608:1}, NetworkSimplexPlacer$EdgeRep);
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$EdgeRep_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/EdgeRep', 608);
function NetworkSimplexPlacer$NodeRep(origin, isFlexible, top_0, bottom){
  this.origin = origin;
  this.isFlexible = isFlexible;
  this.head = top_0;
  this.tail = bottom;
}

defineClass(429, 1, {429:1}, NetworkSimplexPlacer$NodeRep);
_.isFlexible = false;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$NodeRep_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/NodeRep', 429);
function $containsFlexibleNode(this$static, p){
  var nf;
  if (this$static.array.length == 0) {
    return false;
  }
  nf = getNodeFlexibility((checkCriticalElementIndex(0, this$static.array.length) , castTo(this$static.array[0], 16)).source.owner);
  $clinit_NetworkSimplexPlacer();
  if (nf == ($clinit_NodeFlexibility() , NODE_SIZE_WHERE_SPACE_PERMITS) || nf == NODE_SIZE) {
    return true;
  }
  return $anyMatch($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static, 16)), new NetworkSimplexPlacer$Path$lambda$2$Type), new NetworkSimplexPlacer$Path$lambda$3$Type(p));
}

function $containsLongEdgeDummy(this$static){
  if (this$static.array.length == 0) {
    return false;
  }
  if ((checkCriticalElementIndex(0, this$static.array.length) , castTo(this$static.array[0], 16)).source.owner.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    return true;
  }
  return $anyMatch($map(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static, 16)), new NetworkSimplexPlacer$Path$lambda$0$Type), new NetworkSimplexPlacer$Path$lambda$1$Type);
}

function $orderTwoPath(this$static){
  var first, second;
  if (this$static.array.length != 2) {
    throw toJs(new IllegalStateException_0('Order only allowed for two paths.'));
  }
  first = (checkCriticalElementIndex(0, this$static.array.length) , castTo(this$static.array[0], 16));
  second = (checkCriticalElementIndex(1, this$static.array.length) , castTo(this$static.array[1], 16));
  if (first.target.owner != second.source.owner) {
    this$static.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    this$static.array[this$static.array.length] = second;
    this$static.array[this$static.array.length] = first;
  }
}

function NetworkSimplexPlacer$Path(){
  ArrayList.call(this);
}

defineClass(478, 12, {3:1, 4:1, 20:1, 28:1, 43:1, 12:1, 13:1, 15:1, 50:1, 478:1}, NetworkSimplexPlacer$Path);
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$Path_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/Path', 478);
function NetworkSimplexPlacer$Path$lambda$0$Type(){
}

defineClass(1280, 1, $intern_11, NetworkSimplexPlacer$Path$lambda$0$Type);
_.apply_0 = function apply_121(arg0){
  return castTo(arg0, 16).target.owner.type_0;
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$Path$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/Path/lambda$0$Type', 1280);
function NetworkSimplexPlacer$Path$lambda$1$Type(){
}

defineClass(1281, 1, $intern_90, NetworkSimplexPlacer$Path$lambda$1$Type);
_.test_0 = function test_64(arg0){
  return castTo(arg0, 243) == ($clinit_LNode$NodeType() , LONG_EDGE);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$Path$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/Path/lambda$1$Type', 1281);
function NetworkSimplexPlacer$Path$lambda$2$Type(){
}

defineClass(1282, 1, $intern_11, NetworkSimplexPlacer$Path$lambda$2$Type);
_.apply_0 = function apply_122(arg0){
  return castTo(arg0, 16).target.owner;
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$Path$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/Path/lambda$2$Type', 1282);
function NetworkSimplexPlacer$Path$lambda$3$Type(p_0){
  this.p_0 = p_0;
}

defineClass(1283, 1, $intern_90, NetworkSimplexPlacer$Path$lambda$3$Type);
_.test_0 = function test_65(arg0){
  return $test_0(getNodeFlexibility(castTo(arg0, 9)));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$Path$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/Path/lambda$3$Type', 1283);
function NetworkSimplexPlacer$lambda$0$Type(){
}

defineClass(1284, 1, $intern_90, NetworkSimplexPlacer$lambda$0$Type);
_.test_0 = function test_66(arg0){
  return $clinit_NetworkSimplexPlacer() , ($clinit_PortSide() , SIDES_EAST_WEST).contains(castTo(arg0, 11).side);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$0$Type', 1284);
function NetworkSimplexPlacer$lambda$1$Type($$outer_0, singleNode_1){
  this.$$outer_0 = $$outer_0;
  this.singleNode_1 = singleNode_1;
}

defineClass(1285, 1, {}, NetworkSimplexPlacer$lambda$1$Type);
_.accept = function accept_90(arg0){
  $lambda$1_3(this.$$outer_0, this.singleNode_1, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$1$Type', 1285);
function NetworkSimplexPlacer$lambda$10$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1294, 1, {}, NetworkSimplexPlacer$lambda$10$Type);
_.accept = function accept_91(arg0){
  $lambda$10(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$10$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$10$Type', 1294);
function NetworkSimplexPlacer$lambda$11$Type(){
}

defineClass(1295, 1, $intern_11, NetworkSimplexPlacer$lambda$11$Type);
_.apply_0 = function apply_123(arg0){
  return $clinit_NetworkSimplexPlacer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$11$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$11$Type', 1295);
function NetworkSimplexPlacer$lambda$12$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1296, 1, {}, NetworkSimplexPlacer$lambda$12$Type);
_.accept = function accept_92(arg0){
  $lambda$12_0(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$12$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$12$Type', 1296);
function NetworkSimplexPlacer$lambda$13$Type(){
}

defineClass(1297, 1, $intern_11, NetworkSimplexPlacer$lambda$13$Type);
_.apply_0 = function apply_124(arg0){
  return $clinit_NetworkSimplexPlacer() , valueOf_4(castTo(arg0, 115).layer);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$13$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$13$Type', 1297);
function NetworkSimplexPlacer$lambda$14$Type(){
}

defineClass(1299, 1, $intern_11, NetworkSimplexPlacer$lambda$14$Type);
_.apply_0 = function apply_125(arg0){
  return $clinit_NetworkSimplexPlacer() , valueOf_4(castTo(arg0, 115).layer);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$14$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$14$Type', 1299);
function NetworkSimplexPlacer$lambda$15$Type(){
}

defineClass(1301, 1, $intern_90, NetworkSimplexPlacer$lambda$15$Type);
_.test_0 = function test_67(arg0){
  return $clinit_NetworkSimplexPlacer() , castTo(arg0, 429).origin.type_0 == ($clinit_LNode$NodeType() , NORMAL);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$15$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$15$Type', 1301);
function NetworkSimplexPlacer$lambda$16$Type(){
}

defineClass(1302, 1, $intern_90, NetworkSimplexPlacer$lambda$16$Type);
_.test_0 = function test_68(arg0){
  return $clinit_NetworkSimplexPlacer() , castTo(arg0, 429).origin.ports.array.length > 1;
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$16$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$16$Type', 1302);
function NetworkSimplexPlacer$lambda$17$Type(minLayer_0, globalSource_1, usedLayers_2, globalSink_3){
  this.minLayer_0 = minLayer_0;
  this.globalSource_1 = globalSource_1;
  this.usedLayers_2 = usedLayers_2;
  this.globalSink_3 = globalSink_3;
}

defineClass(1303, 1, {}, NetworkSimplexPlacer$lambda$17$Type);
_.accept = function accept_93(arg0){
  lambda$17(this.minLayer_0, this.globalSource_1, this.usedLayers_2, this.globalSink_3, arg0);
}
;
_.minLayer_0 = 0;
_.usedLayers_2 = 0;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$17$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$17$Type', 1303);
function NetworkSimplexPlacer$lambda$18$Type(sizeDelta_0){
  this.sizeDelta_0 = sizeDelta_0;
}

defineClass(1304, 1, {}, NetworkSimplexPlacer$lambda$18$Type);
_.accept = function accept_94(arg0){
  lambda$18(this.sizeDelta_0, arg0);
}
;
_.sizeDelta_0 = 0;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$18$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$18$Type', 1304);
function NetworkSimplexPlacer$lambda$19$Type(){
}

defineClass(1305, 1, $intern_11, NetworkSimplexPlacer$lambda$19$Type);
_.apply_0 = function apply_126(arg0){
  return $clinit_NetworkSimplexPlacer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$19$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$19$Type', 1305);
function NetworkSimplexPlacer$lambda$2$Type(){
}

defineClass(1286, 1, $intern_11, NetworkSimplexPlacer$lambda$2$Type);
_.apply_0 = function apply_127(arg0){
  return $clinit_NetworkSimplexPlacer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$2$Type', 1286);
function NetworkSimplexPlacer$lambda$20$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1306, 1, {}, NetworkSimplexPlacer$lambda$20$Type);
_.accept = function accept_95(arg0){
  $lambda$20_0(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$20$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$20$Type', 1306);
function $test_0(arg0){
  return $clinit_NetworkSimplexPlacer() , $isFlexibleSizeWhereSpacePermits(castTo(arg0, 184));
}

function NetworkSimplexPlacer$lambda$21$Type(){
}

defineClass(1307, 1, $intern_90, NetworkSimplexPlacer$lambda$21$Type);
_.test_0 = function test_69(arg0){
  return $test_0(arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$21$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$21$Type', 1307);
function NetworkSimplexPlacer$lambda$22$Type(){
}

defineClass(1308, 1, $intern_11, NetworkSimplexPlacer$lambda$22$Type);
_.apply_0 = function apply_128(arg0){
  return $clinit_NetworkSimplexPlacer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$22$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$22$Type', 1308);
function NetworkSimplexPlacer$lambda$23$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1309, 1, $intern_90, NetworkSimplexPlacer$lambda$23$Type);
_.test_0 = function test_70(arg0){
  return $lambda$23(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$23$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$23$Type', 1309);
function NetworkSimplexPlacer$lambda$24$Type($$outer_0, paths_1){
  this.$$outer_0 = $$outer_0;
  this.paths_1 = paths_1;
}

defineClass(1310, 1, {}, NetworkSimplexPlacer$lambda$24$Type);
_.accept = function accept_96(arg0){
  $lambda$24(this.$$outer_0, this.paths_1, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$24$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$24$Type', 1310);
function NetworkSimplexPlacer$lambda$25$Type(){
}

defineClass(1311, 1, $intern_90, NetworkSimplexPlacer$lambda$25$Type);
_.test_0 = function test_71(arg0){
  return $clinit_NetworkSimplexPlacer() , !$isSelfLoop(castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$25$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$25$Type', 1311);
function NetworkSimplexPlacer$lambda$26$Type(){
}

defineClass(1312, 1, $intern_90, NetworkSimplexPlacer$lambda$26$Type);
_.test_0 = function test_72(arg0){
  return $clinit_NetworkSimplexPlacer() , !$isSelfLoop(castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$26$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$26$Type', 1312);
function NetworkSimplexPlacer$lambda$27$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1313, 1, {}, NetworkSimplexPlacer$lambda$27$Type);
_.apply_2 = function apply_129(arg0, arg1){
  return $lambda$27(this.$$outer_0, arg0, arg1);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$27$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$27$Type', 1313);
function NetworkSimplexPlacer$lambda$3$Type(){
}

defineClass(1287, 1, $intern_11, NetworkSimplexPlacer$lambda$3$Type);
_.apply_0 = function apply_130(arg0){
  return $clinit_NetworkSimplexPlacer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator_0($iterator($getOutgoingEdges(castTo(arg0, 9)))));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$3$Type', 1287);
function NetworkSimplexPlacer$lambda$4$Type(){
}

defineClass(1288, 1, $intern_90, NetworkSimplexPlacer$lambda$4$Type);
_.test_0 = function test_73(arg0){
  return $clinit_NetworkSimplexPlacer() , isHandledEdge(castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$4$Type', 1288);
function NetworkSimplexPlacer$lambda$5$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1289, 1, {}, NetworkSimplexPlacer$lambda$5$Type);
_.accept = function accept_97(arg0){
  $transformEdge_0(this.$$outer_0, castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$5$Type', 1289);
function NetworkSimplexPlacer$lambda$6$Type(){
}

defineClass(1290, 1, $intern_11, NetworkSimplexPlacer$lambda$6$Type);
_.apply_0 = function apply_131(arg0){
  return $clinit_NetworkSimplexPlacer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(castTo(arg0, 25).nodes, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$6$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$6$Type', 1290);
function NetworkSimplexPlacer$lambda$7$Type(){
}

defineClass(1291, 1, $intern_90, NetworkSimplexPlacer$lambda$7$Type);
_.test_0 = function test_74(arg0){
  return $clinit_NetworkSimplexPlacer() , castTo(arg0, 9).type_0 == ($clinit_LNode$NodeType() , NORMAL);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$7$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$7$Type', 1291);
function NetworkSimplexPlacer$lambda$8$Type(){
}

defineClass(1292, 1, $intern_11, NetworkSimplexPlacer$lambda$8$Type);
_.apply_0 = function apply_132(arg0){
  return $clinit_NetworkSimplexPlacer() , new Stream$StreamSource(null, new Spliterators$IteratorSpliterator_0($iterator($getConnectedEdges_0(castTo(arg0, 9)))));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$8$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$8$Type', 1292);
function NetworkSimplexPlacer$lambda$9$Type(){
}

defineClass(1293, 1, $intern_90, NetworkSimplexPlacer$lambda$9$Type);
_.test_0 = function test_75(arg0){
  return $clinit_NetworkSimplexPlacer() , $isInLayerEdge(castTo(arg0, 16));
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_NetworkSimplexPlacer$lambda$9$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'NetworkSimplexPlacer/lambda$9$Type', 1293);
function $clinit_SimpleNodePlacer(){
  $clinit_SimpleNodePlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS_2 = $addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
}

function $process_71(layeredGraph, monitor){
  var lastNode, layer, layer$iterator, layer$iterator0, layerSize, maxHeight, node, node$iterator, pos, spacings;
  $begin(monitor, 'Simple node placement', 1);
  spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  maxHeight = 0;
  for (layer$iterator0 = new ArrayList$1(layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator0), 25);
    layerSize = layer.size_0;
    layerSize.y_0 = 0;
    lastNode = null;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      !!lastNode && (layerSize.y_0 += $getLocalSpacing_0(node, lastNode, spacings.nodeTypeSpacingOptionsVertical));
      layerSize.y_0 += node.margin.top_0 + node.size_0.y_0 + node.margin.bottom;
      lastNode = node;
    }
    maxHeight = $wnd.Math.max(maxHeight, layerSize.y_0);
  }
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    layerSize = layer.size_0;
    pos = (maxHeight - layerSize.y_0) / 2;
    lastNode = null;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      !!lastNode && (pos += $getLocalSpacing_0(node, lastNode, spacings.nodeTypeSpacingOptionsVertical));
      pos += node.margin.top_0;
      node.pos.y_0 = pos;
      pos += node.size_0.y_0 + node.margin.bottom;
      lastNode = node;
    }
  }
  $done_0(monitor);
}

function SimpleNodePlacer(){
  $clinit_SimpleNodePlacer();
}

defineClass(1275, 1, $intern_117, SimpleNodePlacer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_13(graph){
  return castTo($getProperty(castTo(graph, 32), ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS_2:null;
}
;
_.process = function process_66(layeredGraph, monitor){
  $process_71(castTo(layeredGraph, 32), monitor);
}
;
var HIERARCHY_PROCESSING_ADDITIONS_2;
var Lorg_eclipse_elk_alg_layered_p4nodes_SimpleNodePlacer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes', 'SimpleNodePlacer', 1275);
function $calculateDelta(this$static, src_0, tgt){
  var srcPos, tgtPos;
  srcPos = checkNotNull_1(this$static.y_0[src_0.owner.id_0]) + checkNotNull_1(this$static.innerShift[src_0.owner.id_0]) + src_0.pos.y_0 + src_0.anchor.y_0;
  tgtPos = checkNotNull_1(this$static.y_0[tgt.owner.id_0]) + checkNotNull_1(this$static.innerShift[tgt.owner.id_0]) + tgt.pos.y_0 + tgt.anchor.y_0;
  return tgtPos - srcPos;
}

function $checkSpaceAbove(this$static, blockRoot, delta, ni){
  var availableSpace, current, maxYNeighbor, minYCurrent, neighbor, rootNode, rootNode0;
  availableSpace = delta;
  current = blockRoot;
  do {
    current = this$static.align_0[current.id_0];
    minYCurrent = (rootNode0 = this$static.root[current.id_0] , checkNotNull_1(this$static.y_0[rootNode0.id_0]) + checkNotNull_1(this$static.innerShift[current.id_0]) - current.margin.top_0);
    neighbor = $getUpperNeighbor(current, ni);
    if (neighbor) {
      maxYNeighbor = (rootNode = this$static.root[neighbor.id_0] , checkNotNull_1(this$static.y_0[rootNode.id_0]) + checkNotNull_1(this$static.innerShift[neighbor.id_0]) + neighbor.size_0.y_0 + neighbor.margin.bottom);
      availableSpace = $wnd.Math.min(availableSpace, minYCurrent - (maxYNeighbor + $getVerticalSpacing_0(this$static.spacings, current, neighbor)));
    }
  }
   while (blockRoot != current);
  return availableSpace;
}

function $checkSpaceBelow(this$static, blockRoot, delta, ni){
  var availableSpace, current, maxYCurrent, minYNeighbor, neighbor, rootNode, rootNode0;
  availableSpace = delta;
  current = blockRoot;
  do {
    current = this$static.align_0[current.id_0];
    maxYCurrent = (rootNode0 = this$static.root[current.id_0] , checkNotNull_1(this$static.y_0[rootNode0.id_0]) + checkNotNull_1(this$static.innerShift[current.id_0]) + current.size_0.y_0 + current.margin.bottom);
    neighbor = $getLowerNeighbor(current, ni);
    if (neighbor) {
      minYNeighbor = (rootNode = this$static.root[neighbor.id_0] , checkNotNull_1(this$static.y_0[rootNode.id_0]) + checkNotNull_1(this$static.innerShift[neighbor.id_0]) - neighbor.margin.top_0);
      availableSpace = $wnd.Math.min(availableSpace, minYNeighbor - (maxYCurrent + $getVerticalSpacing_0(this$static.spacings, current, neighbor)));
    }
  }
   while (blockRoot != current);
  return availableSpace;
}

function $getLowerNeighbor(n, ni){
  var l, layerIndex;
  l = n.layer;
  layerIndex = ni.nodeIndex[n.id_0];
  if (layerIndex < l.nodes.array.length - 1) {
    return castTo($get_7(l.nodes, layerIndex + 1), 9);
  }
  return null;
}

function $getUpperNeighbor(n, ni){
  var l, layerIndex;
  l = n.layer;
  layerIndex = ni.nodeIndex[n.id_0];
  if (layerIndex > 0) {
    return castTo($get_7(l.nodes, layerIndex - 1), 9);
  }
  return null;
}

function $layoutSize(this$static){
  var layer, layer$iterator, max_0, min_0, n, n$iterator, yMax, yMin;
  min_0 = $intern_62;
  max_0 = $intern_63;
  for (layer$iterator = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (n$iterator = new ArrayList$1(layer.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      yMin = checkNotNull_1(this$static.y_0[n.id_0]);
      yMax = yMin + checkNotNull_1(this$static.blockSize[this$static.root[n.id_0].id_0]);
      min_0 = $wnd.Math.min(min_0, yMin);
      max_0 = $wnd.Math.max(max_0, yMax);
    }
  }
  return max_0 - min_0;
}

function $shiftBlock(this$static, rootNode, delta){
  var current, newPos;
  current = rootNode;
  do {
    newPos = checkNotNull_1(this$static.y_0[current.id_0]) + delta;
    this$static.y_0[current.id_0] = newPos;
    current = this$static.align_0[current.id_0];
  }
   while (current != rootNode);
}

function BKAlignedLayout(layeredGraph, nodeCount, vdir, hdir){
  this.layeredGraph = layeredGraph;
  this.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  this.root = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, nodeCount, 0, 1);
  this.blockSize = initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_33, 323, nodeCount, 7, 1);
  this.align_0 = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, nodeCount, 0, 1);
  this.innerShift = initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_33, 323, nodeCount, 7, 1);
  this.sink = initUnidimensionalArray(Lorg_eclipse_elk_alg_layered_graph_LNode_2_classLit, $intern_109, 9, nodeCount, 0, 1);
  this.shift_0 = initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_33, 323, nodeCount, 7, 1);
  this.y_0 = initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_33, 323, nodeCount, 7, 1);
  this.su = initUnidimensionalArray(Ljava_lang_Boolean_2_classLit, $intern_33, 449, nodeCount, 8, 1);
  fill_3(this.su, ($clinit_Boolean() , $clinit_Boolean() , false));
  this.od = initUnidimensionalArray(Ljava_lang_Boolean_2_classLit, $intern_33, 449, nodeCount, 8, 1);
  fill_3(this.od, (null , true));
  this.vdir = vdir;
  this.hdir = hdir;
}

defineClass(167, 1, {167:1}, BKAlignedLayout);
_.toString_0 = function toString_102(){
  var result;
  result = '';
  this.hdir == ($clinit_BKAlignedLayout$HDirection() , RIGHT_2)?(result += 'RIGHT'):this.hdir == LEFT_2 && (result += 'LEFT');
  this.vdir == ($clinit_BKAlignedLayout$VDirection() , DOWN_0)?(result += 'DOWN'):this.vdir == UP_0?(result += 'UP'):(result += 'BALANCED');
  return result;
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKAlignedLayout_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'BKAlignedLayout', 167);
function $clinit_BKAlignedLayout$HDirection(){
  $clinit_BKAlignedLayout$HDirection = emptyMethod;
  RIGHT_2 = new BKAlignedLayout$HDirection('RIGHT', 0);
  LEFT_2 = new BKAlignedLayout$HDirection('LEFT', 1);
}

function BKAlignedLayout$HDirection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_62(name_0){
  $clinit_BKAlignedLayout$HDirection();
  return valueOf(($clinit_BKAlignedLayout$HDirection$Map() , $MAP_50), name_0);
}

function values_58(){
  $clinit_BKAlignedLayout$HDirection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKAlignedLayout$HDirection_2_classLit, 1), $intern_38, 486, 0, [RIGHT_2, LEFT_2]);
}

defineClass(486, 22, {3:1, 34:1, 22:1, 486:1}, BKAlignedLayout$HDirection);
var LEFT_2, RIGHT_2;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKAlignedLayout$HDirection_2_classLit = createForEnum('org.eclipse.elk.alg.layered.p4nodes.bk', 'BKAlignedLayout/HDirection', 486, Ljava_lang_Enum_2_classLit, values_58, valueOf_62);
function $clinit_BKAlignedLayout$HDirection$Map(){
  $clinit_BKAlignedLayout$HDirection$Map = emptyMethod;
  $MAP_50 = createValueOfMap(($clinit_BKAlignedLayout$HDirection() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKAlignedLayout$HDirection_2_classLit, 1), $intern_38, 486, 0, [RIGHT_2, LEFT_2])));
}

var $MAP_50;
function $clinit_BKAlignedLayout$VDirection(){
  $clinit_BKAlignedLayout$VDirection = emptyMethod;
  DOWN_0 = new BKAlignedLayout$VDirection('DOWN', 0);
  UP_0 = new BKAlignedLayout$VDirection('UP', 1);
}

function BKAlignedLayout$VDirection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_63(name_0){
  $clinit_BKAlignedLayout$VDirection();
  return valueOf(($clinit_BKAlignedLayout$VDirection$Map() , $MAP_51), name_0);
}

function values_59(){
  $clinit_BKAlignedLayout$VDirection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKAlignedLayout$VDirection_2_classLit, 1), $intern_38, 485, 0, [DOWN_0, UP_0]);
}

defineClass(485, 22, {3:1, 34:1, 22:1, 485:1}, BKAlignedLayout$VDirection);
var DOWN_0, UP_0;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKAlignedLayout$VDirection_2_classLit = createForEnum('org.eclipse.elk.alg.layered.p4nodes.bk', 'BKAlignedLayout/VDirection', 485, Ljava_lang_Enum_2_classLit, values_59, valueOf_63);
function $clinit_BKAlignedLayout$VDirection$Map(){
  $clinit_BKAlignedLayout$VDirection$Map = emptyMethod;
  $MAP_51 = createValueOfMap(($clinit_BKAlignedLayout$VDirection() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKAlignedLayout$VDirection_2_classLit, 1), $intern_38, 485, 0, [DOWN_0, UP_0])));
}

var $MAP_51;
function $insideBlockShift(bal){
  var blocks, current, edge, entry, next, nextInnerShift, outerIter, portPosDiff, root, root$iterator, spaceAbove, spaceBelow;
  blocks = getBlocks(bal);
  for (root$iterator = (outerIter = (new AbstractMap$1(blocks)).this$01.entrySet_0().iterator_0() , new AbstractMap$1$1(outerIter)); root$iterator.val$outerIter2.hasNext_0();) {
    root = (entry = castTo(root$iterator.val$outerIter2.next_1(), 39) , castTo(entry.getKey(), 9));
    spaceAbove = root.margin.top_0;
    spaceBelow = root.size_0.y_0 + root.margin.bottom;
    bal.innerShift[root.id_0] = 0;
    current = root;
    while ((next = bal.align_0[current.id_0]) != root) {
      edge = getEdge(current, next);
      bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_2)?(portPosDiff = edge.target.pos.y_0 + edge.target.anchor.y_0 - edge.source.pos.y_0 - edge.source.anchor.y_0):(portPosDiff = edge.source.pos.y_0 + edge.source.anchor.y_0 - edge.target.pos.y_0 - edge.target.anchor.y_0);
      nextInnerShift = checkNotNull_1(bal.innerShift[current.id_0]) + portPosDiff;
      bal.innerShift[next.id_0] = nextInnerShift;
      spaceAbove = $wnd.Math.max(spaceAbove, next.margin.top_0 - nextInnerShift);
      spaceBelow = $wnd.Math.max(spaceBelow, nextInnerShift + next.size_0.y_0 + next.margin.bottom);
      current = next;
    }
    current = root;
    do {
      bal.innerShift[current.id_0] = checkNotNull_1(bal.innerShift[current.id_0]) + spaceAbove;
      current = bal.align_0[current.id_0];
    }
     while (current != root);
    bal.blockSize[root.id_0] = spaceAbove + spaceBelow;
  }
}

function $verticalAlignment(this$static, bal, markedEdges){
  var d, high, layer, layer$iterator, layer$iterator0, layers, low, m, neighbors, nodes, r, u_m, u_m_pair, um, um_pair, v, v$iterator, v_i_k, v_i_k$iterator;
  for (layer$iterator0 = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator0), 25);
    for (v$iterator = new ArrayList$1(layer.nodes); v$iterator.i < v$iterator.this$01.array.length;) {
      v = castTo($next_10(v$iterator), 9);
      bal.root[v.id_0] = v;
      bal.align_0[v.id_0] = v;
      bal.innerShift[v.id_0] = 0;
    }
  }
  layers = this$static.layeredGraph.layers;
  bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_2) && (layers = instanceOf(layers, 166)?$reverse(castTo(layers, 166)):instanceOf(layers, 138)?castTo(layers, 138).forwardList:instanceOf(layers, 50)?new Lists$RandomAccessReverseList(layers):new Lists$ReverseList(layers));
  for (layer$iterator = layers.iterator_0(); layer$iterator.hasNext_0();) {
    layer = castTo(layer$iterator.next_1(), 25);
    r = -1;
    nodes = layer.nodes;
    if (bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0)) {
      r = $intern_0;
      nodes = instanceOf(nodes, 166)?$reverse(castTo(nodes, 166)):instanceOf(nodes, 138)?castTo(nodes, 138).forwardList:instanceOf(nodes, 50)?new Lists$RandomAccessReverseList(nodes):new Lists$ReverseList(nodes);
    }
    for (v_i_k$iterator = nodes.iterator_0(); v_i_k$iterator.hasNext_0();) {
      v_i_k = castTo(v_i_k$iterator.next_1(), 9);
      bal.hdir == LEFT_2?(neighbors = castTo($get_7(this$static.ni.rightNeighbors, v_i_k.id_0), 15)):(neighbors = castTo($get_7(this$static.ni.leftNeighbors, v_i_k.id_0), 15));
      if (neighbors.size_1() > 0) {
        d = neighbors.size_1();
        low = round_int($wnd.Math.floor((d + 1) / 2)) - 1;
        high = round_int($wnd.Math.ceil((d + 1) / 2)) - 1;
        if (bal.vdir == UP_0) {
          for (m = high; m >= low; m--) {
            if (bal.align_0[v_i_k.id_0] == v_i_k) {
              u_m_pair = castTo(neighbors.get_3(m), 37);
              u_m = castTo(u_m_pair.first, 9);
              if (!$contains_6(markedEdges, u_m_pair.second) && r > this$static.ni.nodeIndex[u_m.id_0]) {
                bal.align_0[u_m.id_0] = v_i_k;
                bal.root[v_i_k.id_0] = bal.root[u_m.id_0];
                bal.align_0[v_i_k.id_0] = bal.root[v_i_k.id_0];
                bal.od[bal.root[v_i_k.id_0].id_0] = ($clinit_Boolean() , checkNotNull_1(bal.od[bal.root[v_i_k.id_0].id_0]) & v_i_k.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)?true:false);
                r = this$static.ni.nodeIndex[u_m.id_0];
              }
            }
          }
        }
         else {
          for (m = low; m <= high; m++) {
            if (bal.align_0[v_i_k.id_0] == v_i_k) {
              um_pair = castTo(neighbors.get_3(m), 37);
              um = castTo(um_pair.first, 9);
              if (!$contains_6(markedEdges, um_pair.second) && r < this$static.ni.nodeIndex[um.id_0]) {
                bal.align_0[um.id_0] = v_i_k;
                bal.root[v_i_k.id_0] = bal.root[um.id_0];
                bal.align_0[v_i_k.id_0] = bal.root[v_i_k.id_0];
                bal.od[bal.root[v_i_k.id_0].id_0] = ($clinit_Boolean() , checkNotNull_1(bal.od[bal.root[v_i_k.id_0].id_0]) & v_i_k.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)?true:false);
                r = this$static.ni.nodeIndex[um.id_0];
              }
            }
          }
        }
      }
    }
  }
}

function BKAligner(layeredGraph, ni){
  this.layeredGraph = layeredGraph;
  this.ni = ni;
}

defineClass(1480, 1, {}, BKAligner);
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKAligner_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'BKAligner', 1480);
function $getOrCreateClassNode(this$static, sinkNode){
  var node;
  node = castTo($get_6(this$static.sinkNodes, sinkNode), 434);
  if (!node) {
    node = new BKCompactor$ClassNode;
    node.node = sinkNode;
    $put_1(this$static.sinkNodes, node.node, node);
  }
  return node;
}

function $horizontalCompaction(this$static, bal){
  var layer, layer$iterator, layer$iterator0, layer$iterator1, layers, node, node$iterator, nodes, sinkShift, v, v$iterator;
  for (layer$iterator0 = new ArrayList$1(this$static.layeredGraph.layers); layer$iterator0.i < layer$iterator0.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator0), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      bal.sink[node.id_0] = node;
      bal.shift_0[node.id_0] = bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0)?$intern_63:$intern_62;
    }
  }
  $reset(this$static.sinkNodes);
  layers = this$static.layeredGraph.layers;
  bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_2) && (layers = instanceOf(layers, 166)?$reverse(castTo(layers, 166)):instanceOf(layers, 138)?castTo(layers, 138).forwardList:instanceOf(layers, 50)?new Lists$RandomAccessReverseList(layers):new Lists$ReverseList(layers));
  $init_0(this$static.threshStrategy, bal, this$static.ni);
  fill_3(bal.y_0, null);
  for (layer$iterator1 = layers.iterator_0(); layer$iterator1.hasNext_0();) {
    layer = castTo(layer$iterator1.next_1(), 25);
    nodes = layer.nodes;
    bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0) && (nodes = instanceOf(nodes, 166)?$reverse(castTo(nodes, 166)):instanceOf(nodes, 138)?castTo(nodes, 138).forwardList:instanceOf(nodes, 50)?new Lists$RandomAccessReverseList(nodes):new Lists$ReverseList(nodes));
    for (v$iterator = nodes.iterator_0(); v$iterator.hasNext_0();) {
      v = castTo(v$iterator.next_1(), 9);
      bal.root[v.id_0] == v && $placeBlock(this$static, v, bal);
    }
  }
  $placeClasses(this$static, bal);
  for (layer$iterator = layers.iterator_0(); layer$iterator.hasNext_0();) {
    layer = castTo(layer$iterator.next_1(), 25);
    for (v$iterator = new ArrayList$1(layer.nodes); v$iterator.i < v$iterator.this$01.array.length;) {
      v = castTo($next_10(v$iterator), 9);
      bal.y_0[v.id_0] = bal.y_0[bal.root[v.id_0].id_0];
      if (v == bal.root[v.id_0]) {
        sinkShift = checkNotNull_1(bal.shift_0[bal.sink[v.id_0].id_0]);
        (bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0) && sinkShift > $intern_63 || bal.vdir == DOWN_0 && sinkShift < $intern_62) && (bal.y_0[v.id_0] = checkNotNull_1(bal.y_0[v.id_0]) + sinkShift);
      }
    }
  }
  this$static.threshStrategy.postProcess();
}

function $placeBlock(this$static, root, bal){
  var currentBlockPosition, currentIndexInLayer, currentLayerSize, currentNode, isInitialAssignment, neighbor, neighborRoot, neighborSink, newPosition, requiredSpace, sinkNode, spacing, thresh;
  if (bal.y_0[root.id_0] != null) {
    return;
  }
  isInitialAssignment = true;
  bal.y_0[root.id_0] = 0;
  currentNode = root;
  thresh = bal.vdir == ($clinit_BKAlignedLayout$VDirection() , DOWN_0)?$intern_63:$intern_62;
  do {
    currentIndexInLayer = this$static.ni.nodeIndex[currentNode.id_0];
    currentLayerSize = currentNode.layer.nodes.array.length;
    if (bal.vdir == DOWN_0 && currentIndexInLayer > 0 || bal.vdir == UP_0 && currentIndexInLayer < currentLayerSize - 1) {
      bal.vdir == UP_0?(neighbor = castTo($get_7(currentNode.layer.nodes, currentIndexInLayer + 1), 9)):(neighbor = castTo($get_7(currentNode.layer.nodes, currentIndexInLayer - 1), 9));
      neighborRoot = bal.root[neighbor.id_0];
      $placeBlock(this$static, neighborRoot, bal);
      thresh = this$static.threshStrategy.calculateThreshold(thresh, root, currentNode);
      bal.sink[root.id_0] == root && (bal.sink[root.id_0] = bal.sink[neighborRoot.id_0]);
      if (bal.sink[root.id_0] == bal.sink[neighborRoot.id_0]) {
        spacing = $getVerticalSpacing_0(this$static.spacings, currentNode, neighbor);
        if (bal.vdir == UP_0) {
          currentBlockPosition = checkNotNull_1(bal.y_0[root.id_0]);
          newPosition = checkNotNull_1(bal.y_0[neighborRoot.id_0]) + checkNotNull_1(bal.innerShift[neighbor.id_0]) - neighbor.margin.top_0 - spacing - currentNode.margin.bottom - currentNode.size_0.y_0 - checkNotNull_1(bal.innerShift[currentNode.id_0]);
          if (isInitialAssignment) {
            isInitialAssignment = false;
            bal.y_0[root.id_0] = $wnd.Math.min(newPosition, thresh);
          }
           else {
            bal.y_0[root.id_0] = $wnd.Math.min(currentBlockPosition, $wnd.Math.min(newPosition, thresh));
          }
        }
         else {
          currentBlockPosition = checkNotNull_1(bal.y_0[root.id_0]);
          newPosition = checkNotNull_1(bal.y_0[neighborRoot.id_0]) + checkNotNull_1(bal.innerShift[neighbor.id_0]) + neighbor.size_0.y_0 + neighbor.margin.bottom + spacing + currentNode.margin.top_0 - checkNotNull_1(bal.innerShift[currentNode.id_0]);
          if (isInitialAssignment) {
            isInitialAssignment = false;
            bal.y_0[root.id_0] = $wnd.Math.max(newPosition, thresh);
          }
           else {
            bal.y_0[root.id_0] = $wnd.Math.max(currentBlockPosition, $wnd.Math.max(newPosition, thresh));
          }
        }
      }
       else {
        spacing = checkNotNull_1(castToDouble($getProperty(this$static.layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_0))));
        sinkNode = $getOrCreateClassNode(this$static, bal.sink[root.id_0]);
        neighborSink = $getOrCreateClassNode(this$static, bal.sink[neighborRoot.id_0]);
        if (bal.vdir == UP_0) {
          requiredSpace = checkNotNull_1(bal.y_0[root.id_0]) + checkNotNull_1(bal.innerShift[currentNode.id_0]) + currentNode.size_0.y_0 + currentNode.margin.bottom + spacing - (checkNotNull_1(bal.y_0[neighborRoot.id_0]) + checkNotNull_1(bal.innerShift[neighbor.id_0]) - neighbor.margin.top_0);
          $addEdge(sinkNode, neighborSink, requiredSpace);
        }
         else {
          requiredSpace = checkNotNull_1(bal.y_0[root.id_0]) + checkNotNull_1(bal.innerShift[currentNode.id_0]) - currentNode.margin.top_0 - checkNotNull_1(bal.y_0[neighborRoot.id_0]) - checkNotNull_1(bal.innerShift[neighbor.id_0]) - neighbor.size_0.y_0 - neighbor.margin.bottom - spacing;
          $addEdge(sinkNode, neighborSink, requiredSpace);
        }
      }
    }
     else {
      thresh = this$static.threshStrategy.calculateThreshold(thresh, root, currentNode);
    }
    currentNode = bal.align_0[currentNode.id_0];
  }
   while (currentNode != root);
  $finishBlock(this$static.threshStrategy, root);
}

function $placeClasses(this$static, bal){
  var e, e$iterator, entry, n, n$iterator, n$iterator0, outerIter, outerIter0, sinks;
  sinks = new LinkedList;
  for (n$iterator0 = (outerIter0 = (new AbstractMap$2(this$static.sinkNodes)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter0)); n$iterator0.val$outerIter2.hasNext_0();) {
    n = (entry = castTo(n$iterator0.val$outerIter2.next_1(), 39) , castTo(entry.getValue(), 434));
    n.indegree == 0 && ($addNode_0(sinks, n, sinks.tail.prev, sinks.tail) , true);
  }
  while (sinks.size_0 != 0) {
    n = castTo(sinks.size_0 == 0?null:(checkCriticalElement(sinks.size_0 != 0) , $removeNode_0(sinks, sinks.header.next_0)), 434);
    n.classShift == null && (n.classShift = 0);
    for (e$iterator = new ArrayList$1(n.outgoing); e$iterator.i < e$iterator.this$01.array.length;) {
      e = castTo($next_10(e$iterator), 614);
      e.target.classShift == null?(e.target.classShift = checkNotNull_1(n.classShift) + e.separation):bal.vdir == ($clinit_BKAlignedLayout$VDirection() , DOWN_0)?(e.target.classShift = $wnd.Math.min(checkNotNull_1(e.target.classShift), checkNotNull_1(n.classShift) + e.separation)):(e.target.classShift = $wnd.Math.max(checkNotNull_1(e.target.classShift), checkNotNull_1(n.classShift) + e.separation));
      --e.target.indegree;
      e.target.indegree == 0 && $add_7(sinks, e.target);
    }
  }
  for (n$iterator = (outerIter = (new AbstractMap$2(this$static.sinkNodes)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter)); n$iterator.val$outerIter2.hasNext_0();) {
    n = (entry = castTo(n$iterator.val$outerIter2.next_1(), 39) , castTo(entry.getValue(), 434));
    bal.shift_0[n.node.id_0] = n.classShift;
  }
}

function BKCompactor(layeredGraph, ni){
  this.sinkNodes = ($clinit_Maps() , new HashMap);
  this.layeredGraph = layeredGraph;
  this.ni = ni;
  this.spacings = castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  maskUndefined($getProperty(layeredGraph, ($clinit_LayeredOptions() , NODE_PLACEMENT_BK_EDGE_STRAIGHTENING_0))) === maskUndefined(($clinit_EdgeStraighteningStrategy() , IMPROVE_STRAIGHTNESS))?(this.threshStrategy = new ThresholdStrategy$SimpleThresholdStrategy):(this.threshStrategy = new ThresholdStrategy$NullThresholdStrategy);
}

defineClass(1483, 1, {}, BKCompactor);
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKCompactor_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'BKCompactor', 1483);
function BKCompactor$ClassEdge(){
}

defineClass(614, 1, {614:1}, BKCompactor$ClassEdge);
_.separation = 0;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKCompactor$ClassEdge_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'BKCompactor/ClassEdge', 614);
function $addEdge(this$static, target, separation){
  var se;
  se = new BKCompactor$ClassEdge;
  se.target = target;
  se.separation = separation;
  ++target.indegree;
  $add_4(this$static.outgoing, se);
}

function BKCompactor$ClassNode(){
  this.outgoing = new ArrayList;
}

defineClass(434, 1, {434:1}, BKCompactor$ClassNode);
_.classShift = null;
_.indegree = 0;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKCompactor$ClassNode_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'BKCompactor/ClassNode', 434);
function $clinit_BKNodePlacer(){
  $clinit_BKNodePlacer = emptyMethod;
  HIERARCHY_PROCESSING_ADDITIONS_3 = $addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , HIERARCHICAL_PORT_POSITION_PROCESSOR));
}

function $checkOrderConstraint(this$static, layeredGraph, bal){
  var bottom, feasible, layer, layer$iterator, node, node$iterator, pos, top_0;
  feasible = true;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    pos = $intern_63;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      top_0 = checkNotNull_1(bal.y_0[node.id_0]) + checkNotNull_1(bal.innerShift[node.id_0]) - node.margin.top_0;
      bottom = checkNotNull_1(bal.y_0[node.id_0]) + checkNotNull_1(bal.innerShift[node.id_0]) + node.size_0.y_0 + node.margin.bottom;
      if (top_0 > pos && bottom > pos) {
        pos = checkNotNull_1(bal.y_0[node.id_0]) + checkNotNull_1(bal.innerShift[node.id_0]) + node.size_0.y_0 + node.margin.bottom;
      }
       else {
        feasible = false;
        this$static.debugMode && ($clinit_System() , out_0);
        break;
      }
    }
    if (!feasible) {
      break;
    }
  }
  this$static.debugMode && ($clinit_System() , out_0);
  return feasible;
}

function $createBalancedLayout(this$static, layouts, nodeCount){
  var bal, balanced, calculatedYs, i, i0, i1, i2, l, l$iterator, layer, layer$iterator, max_0, min_0, minWidthLayout, n, n$iterator, noOfLayouts, node, node$iterator, nodePosY, shift_0, width_0;
  noOfLayouts = layouts.array.length;
  balanced = new BKAlignedLayout(this$static.lGraph, nodeCount, null, null);
  width_0 = initUnidimensionalArray(D_classLit, $intern_69, 23, noOfLayouts, 15, 1);
  min_0 = initUnidimensionalArray(D_classLit, $intern_69, 23, noOfLayouts, 15, 1);
  max_0 = initUnidimensionalArray(D_classLit, $intern_69, 23, noOfLayouts, 15, 1);
  minWidthLayout = 0;
  for (i0 = 0; i0 < noOfLayouts; i0++) {
    min_0[i0] = $intern_0;
    max_0[i0] = $intern_43;
  }
  for (i1 = 0; i1 < noOfLayouts; i1++) {
    bal = (checkCriticalElementIndex(i1, layouts.array.length) , castTo(layouts.array[i1], 167));
    width_0[i1] = $layoutSize(bal);
    width_0[minWidthLayout] > width_0[i1] && (minWidthLayout = i1);
    for (l$iterator = new ArrayList$1(this$static.lGraph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
      l = castTo($next_10(l$iterator), 25);
      for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
        n = castTo($next_10(n$iterator), 9);
        nodePosY = checkNotNull_1(bal.y_0[n.id_0]) + checkNotNull_1(bal.innerShift[n.id_0]);
        min_0[i1] = $wnd.Math.min(min_0[i1], nodePosY);
        max_0[i1] = $wnd.Math.max(max_0[i1], nodePosY + n.size_0.y_0);
      }
    }
  }
  shift_0 = initUnidimensionalArray(D_classLit, $intern_69, 23, noOfLayouts, 15, 1);
  for (i2 = 0; i2 < noOfLayouts; i2++) {
    (checkCriticalElementIndex(i2, layouts.array.length) , castTo(layouts.array[i2], 167)).vdir == ($clinit_BKAlignedLayout$VDirection() , DOWN_0)?(shift_0[i2] = min_0[minWidthLayout] - min_0[i2]):(shift_0[i2] = max_0[minWidthLayout] - max_0[i2]);
  }
  calculatedYs = initUnidimensionalArray(D_classLit, $intern_69, 23, noOfLayouts, 15, 1);
  for (layer$iterator = new ArrayList$1(this$static.lGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      for (i = 0; i < noOfLayouts; i++) {
        calculatedYs[i] = checkNotNull_1((checkCriticalElementIndex(i, layouts.array.length) , castTo(layouts.array[i], 167)).y_0[node.id_0]) + checkNotNull_1((checkCriticalElementIndex(i, layouts.array.length) , castTo(layouts.array[i], 167)).innerShift[node.id_0]) + shift_0[i];
      }
      nativeNumberSort(calculatedYs);
      balanced.y_0[node.id_0] = (calculatedYs[1] + calculatedYs[2]) / 2;
      balanced.innerShift[node.id_0] = 0;
    }
  }
  return balanced;
}

function $incidentToInnerSegment(this$static, node, layer1, layer2){
  var edge, edge$iterator, source, sourceNodeType;
  if (node.type_0 == ($clinit_LNode$NodeType() , BIG_NODE)) {
    for (edge$iterator = $iterator($getIncomingEdges(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 16);
      source = edge.source.owner;
      if ((source.type_0 == BIG_NODE || checkNotNull_1(castToBoolean($getProperty(source, ($clinit_InternalProperties_1() , BIG_NODE_INITIAL))))) && this$static.ni.layerIndex[edge.source.owner.layer.id_0] == layer2 && this$static.ni.layerIndex[node.layer.id_0] == layer1) {
        return true;
      }
    }
  }
  if (node.type_0 == LONG_EDGE) {
    for (edge$iterator = $iterator($getIncomingEdges(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 16);
      sourceNodeType = edge.source.owner.type_0;
      if (sourceNodeType == LONG_EDGE && this$static.ni.layerIndex[edge.source.owner.layer.id_0] == layer2 && this$static.ni.layerIndex[node.layer.id_0] == layer1) {
        return true;
      }
    }
  }
  return false;
}

function $markConflicts(this$static, layeredGraph){
  var currentLayer, i, k, k_0, k_1, l, l_1, layer, layer$iterator, layerIndex, layerIterator, layerSize, nodeIterator, numberOfLayers, upperNeighbor, upperNeighbor$iterator, v_l, v_l_i;
  numberOfLayers = layeredGraph.layers.array.length;
  if (numberOfLayers < 3) {
    return;
  }
  layerSize = initUnidimensionalArray(I_classLit, $intern_49, 23, numberOfLayers, 15, 1);
  layerIndex = 0;
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    layerSize[layerIndex++] = layer.nodes.array.length;
  }
  layerIterator = new AbstractList$ListIteratorImpl(layeredGraph.layers, 2);
  for (i = 1; i < numberOfLayers - 1; i++) {
    currentLayer = (checkCriticalElement(layerIterator.i < layerIterator.this$01_0.size_1()) , castTo(layerIterator.this$01_0.get_3(layerIterator.last = layerIterator.i++), 25));
    nodeIterator = new ArrayList$1(currentLayer.nodes);
    k_0 = 0;
    l = 0;
    for (l_1 = 0; l_1 < layerSize[i + 1]; l_1++) {
      v_l_i = castTo($next_10(nodeIterator), 9);
      if (l_1 == layerSize[i + 1] - 1 || $incidentToInnerSegment(this$static, v_l_i, i + 1, i)) {
        k_1 = layerSize[i] - 1;
        $incidentToInnerSegment(this$static, v_l_i, i + 1, i) && (k_1 = this$static.ni.nodeIndex[castTo(castTo(castTo($get_7(this$static.ni.leftNeighbors, v_l_i.id_0), 15).get_3(0), 37).first, 9).id_0]);
        while (l <= l_1) {
          v_l = castTo($get_7(currentLayer.nodes, l), 9);
          if (!$incidentToInnerSegment(this$static, v_l, i + 1, i)) {
            for (upperNeighbor$iterator = castTo($get_7(this$static.ni.leftNeighbors, v_l.id_0), 15).iterator_0(); upperNeighbor$iterator.hasNext_0();) {
              upperNeighbor = castTo(upperNeighbor$iterator.next_1(), 37);
              k = this$static.ni.nodeIndex[castTo(upperNeighbor.first, 9).id_0];
              (k < k_0 || k > k_1) && $add_6(this$static.markedEdges, castTo(upperNeighbor.second, 16));
            }
          }
          ++l;
        }
        k_0 = k_1;
      }
    }
  }
}

function $process_72(this$static, layeredGraph, monitor){
  var align_0, aligner, bal, bal$iterator, bal$iterator0, bal$iterator1, bal$iterator2, balanced, chosenLayout, compacter, favorStraightEdges, layer, layer$iterator, layouts, leftdown, leftup, node, node$iterator, rightdown, rightup;
  $begin(monitor, 'Brandes & Koepf node placement', 1);
  this$static.lGraph = layeredGraph;
  this$static.ni = buildFor(layeredGraph);
  this$static.debugMode = checkNotNull_1(castToBoolean($getProperty(layeredGraph, ($clinit_LayeredOptions() , DEBUG_MODE))));
  align_0 = castTo($getProperty(layeredGraph, NODE_PLACEMENT_BK_FIXED_ALIGNMENT_0), 264);
  favorStraightEdges = checkNotNull_1(castToBoolean($getProperty(layeredGraph, NODE_PLACEMENT_FAVOR_STRAIGHT_EDGES_0)));
  this$static.produceBalancedLayout = align_0 == ($clinit_FixedAlignment() , NONE_1) && !favorStraightEdges || align_0 == BALANCED;
  $markConflicts(this$static, layeredGraph);
  layouts = (checkNonnegative(4, 'initialArraySize') , new ArrayList_0(4));
  switch (castTo($getProperty(layeredGraph, NODE_PLACEMENT_BK_FIXED_ALIGNMENT_0), 264).ordinal) {
    case 3:
      leftdown = new BKAlignedLayout(layeredGraph, this$static.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , DOWN_0), ($clinit_BKAlignedLayout$HDirection() , LEFT_2));
      layouts.array[layouts.array.length] = leftdown;
      break;
    case 1:
      leftup = new BKAlignedLayout(layeredGraph, this$static.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , UP_0), ($clinit_BKAlignedLayout$HDirection() , LEFT_2));
      layouts.array[layouts.array.length] = leftup;
      break;
    case 4:
      rightdown = new BKAlignedLayout(layeredGraph, this$static.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , DOWN_0), ($clinit_BKAlignedLayout$HDirection() , RIGHT_2));
      layouts.array[layouts.array.length] = rightdown;
      break;
    case 2:
      rightup = new BKAlignedLayout(layeredGraph, this$static.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , UP_0), ($clinit_BKAlignedLayout$HDirection() , RIGHT_2));
      layouts.array[layouts.array.length] = rightup;
      break;
    default:leftdown = new BKAlignedLayout(layeredGraph, this$static.ni.nodeCount, ($clinit_BKAlignedLayout$VDirection() , DOWN_0), ($clinit_BKAlignedLayout$HDirection() , LEFT_2));
      leftup = new BKAlignedLayout(layeredGraph, this$static.ni.nodeCount, UP_0, LEFT_2);
      rightdown = new BKAlignedLayout(layeredGraph, this$static.ni.nodeCount, DOWN_0, RIGHT_2);
      rightup = new BKAlignedLayout(layeredGraph, this$static.ni.nodeCount, UP_0, RIGHT_2);
      layouts.array[layouts.array.length] = rightdown;
      layouts.array[layouts.array.length] = rightup;
      layouts.array[layouts.array.length] = leftdown;
      layouts.array[layouts.array.length] = leftup;
  }
  aligner = new BKAligner(layeredGraph, this$static.ni);
  for (bal$iterator0 = new ArrayList$1(layouts); bal$iterator0.i < bal$iterator0.this$01.array.length;) {
    bal = castTo($next_10(bal$iterator0), 167);
    $verticalAlignment(aligner, bal, this$static.markedEdges);
    $insideBlockShift(bal);
  }
  compacter = new BKCompactor(layeredGraph, this$static.ni);
  for (bal$iterator1 = new ArrayList$1(layouts); bal$iterator1.i < bal$iterator1.this$01.array.length;) {
    bal = castTo($next_10(bal$iterator1), 167);
    $horizontalCompaction(compacter, bal);
  }
  if (this$static.debugMode) {
    for (bal$iterator2 = new ArrayList$1(layouts); bal$iterator2.i < bal$iterator2.this$01.array.length;) {
      bal = castTo($next_10(bal$iterator2), 167);
      $clinit_System();
      bal + ' size is ' + $layoutSize(bal);
    }
  }
  chosenLayout = null;
  if (this$static.produceBalancedLayout) {
    balanced = $createBalancedLayout(this$static, layouts, this$static.ni.nodeCount);
    $checkOrderConstraint(this$static, layeredGraph, balanced) && (chosenLayout = balanced);
  }
  if (!chosenLayout) {
    for (bal$iterator2 = new ArrayList$1(layouts); bal$iterator2.i < bal$iterator2.this$01.array.length;) {
      bal = castTo($next_10(bal$iterator2), 167);
      $checkOrderConstraint(this$static, layeredGraph, bal) && (!chosenLayout || $layoutSize(chosenLayout) > $layoutSize(bal)) && (chosenLayout = bal);
    }
  }
  !chosenLayout && (chosenLayout = (checkCriticalElementIndex(0, layouts.array.length) , castTo(layouts.array[0], 167)));
  for (layer$iterator = new ArrayList$1(layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      node.pos.y_0 = checkNotNull_1(chosenLayout.y_0[node.id_0]) + checkNotNull_1(chosenLayout.innerShift[node.id_0]);
    }
  }
  if (this$static.debugMode) {
    $clinit_System();
    'Blocks: ' + getBlocks(chosenLayout);
    'Classes: ' + getClasses(chosenLayout);
  }
  for (bal$iterator = new ArrayList$1(layouts); bal$iterator.i < bal$iterator.this$01.array.length;) {
    bal = castTo($next_10(bal$iterator), 167);
    bal.root = null;
    bal.blockSize = null;
    bal.align_0 = null;
    bal.innerShift = null;
    bal.sink = null;
    bal.shift_0 = null;
    bal.y_0 = null;
  }
  $cleanup(this$static.ni);
  this$static.markedEdges.map_0.clear_0();
  $done_0(monitor);
}

function BKNodePlacer(){
  $clinit_BKNodePlacer();
  this.markedEdges = new HashSet;
}

function getBlocks(bal){
  $clinit_BKNodePlacer();
  var blockContents, blocks, layer, layer$iterator, node, node$iterator, root;
  blocks = ($clinit_Maps() , new LinkedHashMap);
  for (layer$iterator = new ArrayList$1(bal.layeredGraph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      root = bal.root[node.id_0];
      blockContents = castTo($get_12(blocks, root), 15);
      if (!blockContents) {
        blockContents = new ArrayList;
        $put_6(blocks, root, blockContents);
      }
      blockContents.add_1(node);
    }
  }
  return blocks;
}

function getClasses(bal){
  var classContents, classes, root, root$iterator, roots, sink;
  classes = ($clinit_Maps() , new LinkedHashMap);
  roots = newLinkedHashSet(new Arrays$ArrayList(bal.root));
  for (root$iterator = roots.map_0.keySet_0().iterator_0(); root$iterator.hasNext_0();) {
    root = castTo(root$iterator.next_1(), 9);
    if (!root) {
      $clinit_System();
      break;
    }
    sink = bal.sink[root.id_0];
    classContents = castTo($get_12(classes, sink), 15);
    if (!classContents) {
      classContents = new ArrayList;
      $put_6(classes, sink, classContents);
    }
    classContents.add_1(root);
  }
  return classes;
}

function getEdge(source, target){
  $clinit_BKNodePlacer();
  var edge, edge$iterator;
  for (edge$iterator = $iterator($getConnectedEdges_0(source)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 16);
    if (edge.target.owner == target || edge.source.owner == target) {
      return edge;
    }
  }
  return null;
}

defineClass(1278, 1, $intern_117, BKNodePlacer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_14(graph){
  return castTo($getProperty(castTo(graph, 32), ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19).contains(($clinit_GraphProperties() , EXTERNAL_PORTS))?HIERARCHY_PROCESSING_ADDITIONS_3:null;
}
;
_.process = function process_67(layeredGraph, monitor){
  $process_72(this, castTo(layeredGraph, 32), monitor);
}
;
_.debugMode = false;
_.produceBalancedLayout = false;
var HIERARCHY_PROCESSING_ADDITIONS_3;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_BKNodePlacer_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'BKNodePlacer', 1278);
function $cleanup(this$static){
  this$static.layerIndex = null;
  this$static.nodeIndex = null;
  this$static.leftNeighbors.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.rightNeighbors.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.neighborComparator = null;
}

function NeighborhoodInformation(){
}

function buildFor(graph){
  var l, l$iterator, lId, lIndex, layer, layer$iterator, n, n$iterator, nId, nIndex, ni;
  ni = new NeighborhoodInformation;
  ni.nodeCount = 0;
  for (layer$iterator = new ArrayList$1(graph.layers); layer$iterator.i < layer$iterator.this$01.array.length;) {
    layer = castTo($next_10(layer$iterator), 25);
    ni.nodeCount += layer.nodes.array.length;
  }
  lId = 0;
  lIndex = 0;
  ni.layerIndex = initUnidimensionalArray(I_classLit, $intern_49, 23, graph.layers.array.length, 15, 1);
  nId = 0;
  ni.nodeIndex = initUnidimensionalArray(I_classLit, $intern_49, 23, ni.nodeCount, 15, 1);
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    l.id_0 = lId++;
    ni.layerIndex[l.id_0] = lIndex++;
    nIndex = 0;
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      n.id_0 = nId++;
      ni.nodeIndex[n.id_0] = nIndex++;
    }
  }
  ni.neighborComparator = new NeighborhoodInformation$NeighborComparator(ni);
  ni.leftNeighbors = newArrayListWithCapacity(ni.nodeCount);
  determineAllLeftNeighbors(ni, graph);
  ni.rightNeighbors = newArrayListWithCapacity(ni.nodeCount);
  determineAllRightNeighbors(ni, graph);
  return ni;
}

function determineAllLeftNeighbors(ni, graph){
  var edge, edge$iterator, edgePrio, l, l$iterator, maxPriority, n, n$iterator, result;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      result = new ArrayList;
      maxPriority = 0;
      for (edge$iterator = $iterator($getIncomingEdges(n)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        if ($isSelfLoop(edge) || !$isSelfLoop(edge) && edge.source.owner.layer == edge.target.owner.layer) {
          continue;
        }
        edgePrio = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_STRAIGHTNESS_0)), 21).value_0;
        if (edgePrio > maxPriority) {
          maxPriority = edgePrio;
          result.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
        }
        edgePrio == maxPriority && $add_4(result, new Pair(edge.source.owner, edge));
      }
      $clinit_Collections();
      $sort(result, ni.neighborComparator);
      $add_3(ni.leftNeighbors, n.id_0, result);
    }
  }
}

function determineAllRightNeighbors(ni, graph){
  var edge, edge$iterator, edgePrio, l, l$iterator, maxPriority, n, n$iterator, result;
  for (l$iterator = new ArrayList$1(graph.layers); l$iterator.i < l$iterator.this$01.array.length;) {
    l = castTo($next_10(l$iterator), 25);
    for (n$iterator = new ArrayList$1(l.nodes); n$iterator.i < n$iterator.this$01.array.length;) {
      n = castTo($next_10(n$iterator), 9);
      result = new ArrayList;
      maxPriority = 0;
      for (edge$iterator = $iterator($getOutgoingEdges(n)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 16);
        if ($isSelfLoop(edge) || !$isSelfLoop(edge) && edge.source.owner.layer == edge.target.owner.layer) {
          continue;
        }
        edgePrio = castTo($getProperty(edge, ($clinit_LayeredOptions() , PRIORITY_STRAIGHTNESS_0)), 21).value_0;
        if (edgePrio > maxPriority) {
          maxPriority = edgePrio;
          result.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
        }
        edgePrio == maxPriority && $add_4(result, new Pair(edge.target.owner, edge));
      }
      $clinit_Collections();
      $sort(result, ni.neighborComparator);
      $add_3(ni.rightNeighbors, n.id_0, result);
    }
  }
}

defineClass(1481, 1, {}, NeighborhoodInformation);
_.nodeCount = 0;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_NeighborhoodInformation_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'NeighborhoodInformation', 1481);
function $compare_20(this$static, o1, o2){
  var cmp;
  cmp = this$static.this$01.nodeIndex[castTo(o1.first, 9).id_0] - this$static.this$01.nodeIndex[castTo(o2.first, 9).id_0];
  return round_int(signum(cmp));
}

function NeighborhoodInformation$NeighborComparator(this$0){
  this.this$01 = this$0;
}

defineClass(1482, 1, $intern_40, NeighborhoodInformation$NeighborComparator);
_.compare_0 = function compare_66(o1, o2){
  return $compare_20(this, castTo(o1, 37), castTo(o2, 37));
}
;
_.equals_0 = function equals_157(other){
  return this === other;
}
;
_.reversed = function reversed_58(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_NeighborhoodInformation$NeighborComparator_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'NeighborhoodInformation/NeighborComparator', 1482);
function $finishBlock(this$static, n){
  $add_6(this$static.blockFinished, n);
}

function $getOther_3(edge, n){
  if (edge.source.owner == n) {
    return edge.target.owner;
  }
   else if (edge.target.owner == n) {
    return edge.source.owner;
  }
   else {
    throw toJs(new IllegalArgumentException_0('Node ' + n + ' is neither source nor target of edge ' + edge));
  }
}

function $init_0(this$static, theBal, theNi){
  this$static.bal = theBal;
  this$static.ni = theNi;
  this$static.blockFinished.map_0.clear_0();
  $reset_0(this$static.postProcessablesQueue);
  this$static.postProcessablesStack.arrayList.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}

function ThresholdStrategy(){
  this.blockFinished = new HashSet;
  this.postProcessablesQueue = new LinkedList;
  this.postProcessablesStack = new Stack;
}

defineClass(748, 1, {});
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_ThresholdStrategy_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'ThresholdStrategy', 748);
function ThresholdStrategy$NullThresholdStrategy(){
  ThresholdStrategy.call(this);
}

defineClass(1577, 748, {}, ThresholdStrategy$NullThresholdStrategy);
_.calculateThreshold = function calculateThreshold(oldThresh, blockRoot, currentNode){
  return this.bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0)?$intern_62:$intern_63;
}
;
_.postProcess = function postProcess_0(){
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_ThresholdStrategy$NullThresholdStrategy_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'ThresholdStrategy/NullThresholdStrategy', 1577);
function ThresholdStrategy$Postprocessable(free, isRoot){
  this.free = free;
  this.isRoot = isRoot;
}

defineClass(547, 1, {547:1}, ThresholdStrategy$Postprocessable);
_.hasEdges = false;
_.isRoot = false;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_ThresholdStrategy$Postprocessable_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'ThresholdStrategy/Postprocessable', 547);
function $getBound(this$static, blockNode, isRoot){
  var invalid, left, otherPort, otherRoot, pick, right, rootPort, threshold;
  invalid = this$static.bal.vdir == ($clinit_BKAlignedLayout$VDirection() , UP_0)?$intern_62:$intern_63;
  pick = $pickEdge(this$static, new ThresholdStrategy$Postprocessable(blockNode, isRoot));
  if (!pick.edge && pick.hasEdges) {
    $add_7(this$static.postProcessablesQueue, pick);
    return invalid;
  }
   else if (pick.edge) {
    left = pick.edge.source;
    right = pick.edge.target;
    if (isRoot) {
      rootPort = this$static.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , RIGHT_2)?right:left;
      otherPort = this$static.bal.hdir == RIGHT_2?left:right;
      otherRoot = this$static.bal.root[otherPort.owner.id_0];
      threshold = checkNotNull_1(this$static.bal.y_0[otherRoot.id_0]) + checkNotNull_1(this$static.bal.innerShift[otherPort.owner.id_0]) + otherPort.pos.y_0 + otherPort.anchor.y_0 - checkNotNull_1(this$static.bal.innerShift[rootPort.owner.id_0]) - rootPort.pos.y_0 - rootPort.anchor.y_0;
    }
     else {
      rootPort = this$static.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_2)?right:left;
      otherPort = this$static.bal.hdir == LEFT_2?left:right;
      threshold = checkNotNull_1(this$static.bal.y_0[this$static.bal.root[otherPort.owner.id_0].id_0]) + checkNotNull_1(this$static.bal.innerShift[otherPort.owner.id_0]) + otherPort.pos.y_0 + otherPort.anchor.y_0 - checkNotNull_1(this$static.bal.innerShift[rootPort.owner.id_0]) - rootPort.pos.y_0 - rootPort.anchor.y_0;
    }
    this$static.bal.su[this$static.bal.root[left.owner.id_0].id_0] = ($clinit_Boolean() , $clinit_Boolean() , true);
    this$static.bal.su[this$static.bal.root[right.owner.id_0].id_0] = (null , true);
    return threshold;
  }
  return invalid;
}

function $pickEdge(this$static, pp){
  var e, e$iterator, edges, hasEdges, onlyDummies;
  pp.isRoot?(edges = this$static.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , RIGHT_2)?$getIncomingEdges(pp.free):$getOutgoingEdges(pp.free)):(edges = this$static.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , LEFT_2)?$getIncomingEdges(pp.free):$getOutgoingEdges(pp.free));
  hasEdges = false;
  for (e$iterator = ($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(edges.val$inputs1, new Iterables$12)))); $hasNext_0(e$iterator);) {
    e = castTo($next_2(e$iterator), 16);
    onlyDummies = checkNotNull_1(this$static.bal.od[this$static.bal.root[pp.free.id_0].id_0]);
    if (!onlyDummies && !$isSelfLoop(e) && e.source.owner.layer == e.target.owner.layer) {
      continue;
    }
    if (checkNotNull_1(this$static.bal.su[this$static.bal.root[pp.free.id_0].id_0]) || checkNotNull_1(this$static.bal.su[this$static.bal.root[pp.free.id_0].id_0])) {
      continue;
    }
    hasEdges = true;
    if ($contains_6(this$static.blockFinished, this$static.bal.root[$getOther_3(e, pp.free).id_0])) {
      pp.hasEdges = true;
      pp.edge = e;
      return pp;
    }
  }
  pp.hasEdges = hasEdges;
  pp.edge = null;
  return pp;
}

function $process_73(this$static, pp){
  var availableSpace, block, delta, edge, fix;
  edge = pp.edge;
  edge.source.owner == pp.free?(fix = edge.target):(fix = edge.source);
  edge.source.owner == pp.free?(block = edge.source):(block = edge.target);
  delta = $calculateDelta(this$static.bal, fix, block);
  if (delta > 0 && delta < $intern_98) {
    availableSpace = $checkSpaceAbove(this$static.bal, block.owner, delta, this$static.ni);
    $shiftBlock(this$static.bal, block.owner, -availableSpace);
    return availableSpace > 0;
  }
   else if (delta < 0 && -delta < $intern_98) {
    availableSpace = $checkSpaceBelow(this$static.bal, block.owner, -delta, this$static.ni);
    $shiftBlock(this$static.bal, block.owner, availableSpace);
    return availableSpace > 0;
  }
  return false;
}

function ThresholdStrategy$SimpleThresholdStrategy(){
  ThresholdStrategy.call(this);
}

defineClass(1578, 748, {}, ThresholdStrategy$SimpleThresholdStrategy);
_.calculateThreshold = function calculateThreshold_0(oldThresh, blockRoot, currentNode){
  var isLast, isRoot, t;
  isRoot = blockRoot == currentNode;
  isLast = this.bal.align_0[currentNode.id_0] == blockRoot;
  if (!(isRoot || isLast)) {
    return oldThresh;
  }
  t = oldThresh;
  if (this.bal.hdir == ($clinit_BKAlignedLayout$HDirection() , RIGHT_2)) {
    isRoot && (t = $getBound(this, blockRoot, true));
    !isNaN(t) && !isFinite(t) && isLast && (t = $getBound(this, currentNode, false));
  }
   else {
    isRoot && (t = $getBound(this, blockRoot, true));
    !isNaN(t) && !isFinite(t) && isLast && (t = $getBound(this, currentNode, false));
  }
  return t;
}
;
_.postProcess = function postProcess_1(){
  var edge, moved, onlyDummies, pick, pp;
  while (this.postProcessablesQueue.size_0 != 0) {
    pp = castTo($poll(this.postProcessablesQueue), 547);
    pick = $pickEdge(this, pp);
    if (!pick.edge) {
      continue;
    }
    edge = pick.edge;
    onlyDummies = checkNotNull_1(this.bal.od[this.bal.root[pp.free.id_0].id_0]);
    if (!onlyDummies && !$isSelfLoop(edge) && edge.source.owner.layer == edge.target.owner.layer) {
      continue;
    }
    moved = $process_73(this, pp);
    moved || $push(this.postProcessablesStack, pp);
  }
  while (this.postProcessablesStack.arrayList.array.length != 0) {
    $process_73(this, castTo($pop(this.postProcessablesStack), 547));
  }
}
;
var Lorg_eclipse_elk_alg_layered_p4nodes_bk_ThresholdStrategy$SimpleThresholdStrategy_2_classLit = createForClass('org.eclipse.elk.alg.layered.p4nodes.bk', 'ThresholdStrategy/SimpleThresholdStrategy', 1578);
function $clinit_EdgeRouterFactory(){
  $clinit_EdgeRouterFactory = emptyMethod;
  factoryCache = new EnumMap(Lorg_eclipse_elk_core_options_EdgeRouting_2_classLit);
}

function $create_7(this$static){
  switch (this$static.edgeRoutingStrategy.ordinal) {
    case 1:
      return new PolylineEdgeRouter;
    case 3:
      return new SplineEdgeRouter;
    default:return new OrthogonalEdgeRouter;
  }
}

function EdgeRouterFactory(){
}

function factoryFor(edgeRoutingStrategy){
  $clinit_EdgeRouterFactory();
  var factory;
  if (!$containsKey_4(factoryCache, edgeRoutingStrategy)) {
    factory = new EdgeRouterFactory;
    factory.edgeRoutingStrategy = edgeRoutingStrategy;
    $put_3(factoryCache, edgeRoutingStrategy, factory);
  }
  return castTo($get_10(factoryCache, edgeRoutingStrategy), 599);
}

defineClass(599, 1, {599:1, 230:1, 231:1}, EdgeRouterFactory);
_.create_1 = function create_18(){
  return $create_7(this);
}
;
_.create_2 = function create_17(){
  return $create_7(this);
}
;
var factoryCache;
var Lorg_eclipse_elk_alg_layered_p5edges_EdgeRouterFactory_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'EdgeRouterFactory', 599);
function $clinit_OrthogonalEdgeRouter(){
  $clinit_OrthogonalEdgeRouter = emptyMethod;
  HYPEREDGE_PROCESSING_ADDITIONS = $addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P4_NODE_PLACEMENT), ($clinit_IntermediateProcessorStrategy() , HYPEREDGE_DUMMY_MERGER));
  INVERTED_PORT_PROCESSING_ADDITIONS = $addBefore(new LayoutProcessorConfiguration, P3_NODE_ORDERING, INVERTED_PORT_PROCESSOR);
  NORTH_SOUTH_PORT_PROCESSING_ADDITIONS = $addAfter($addBefore(new LayoutProcessorConfiguration, P3_NODE_ORDERING, NORTH_SOUTH_PORT_PREPROCESSOR), P5_EDGE_ROUTING, NORTH_SOUTH_PORT_POSTPROCESSOR);
  HIERARCHICAL_PORT_PROCESSING_ADDITIONS = $addAfter($addBefore($addBefore(new LayoutProcessorConfiguration, P3_NODE_ORDERING, HIERARCHICAL_PORT_CONSTRAINT_PROCESSOR), P4_NODE_PLACEMENT, HIERARCHICAL_PORT_DUMMY_SIZE_PROCESSOR), P5_EDGE_ROUTING, HIERARCHICAL_PORT_ORTHOGONAL_EDGE_ROUTER);
  SELF_LOOP_PROCESSING_ADDITIONS = $addBefore(new LayoutProcessorConfiguration, P3_NODE_ORDERING, SELF_LOOP_PROCESSOR);
  HYPERNODE_PROCESSING_ADDITIONS = $addAfter(new LayoutProcessorConfiguration, P5_EDGE_ROUTING, HYPERNODE_PROCESSOR);
  CENTER_EDGE_LABEL_PROCESSING_ADDITIONS = $addAfter($addBefore($addBefore($addBefore(new LayoutProcessorConfiguration, P2_LAYERING, LABEL_DUMMY_INSERTER), P4_NODE_PLACEMENT, LABEL_DUMMY_SWITCHER), P4_NODE_PLACEMENT, LABEL_SIDE_SELECTOR), P5_EDGE_ROUTING, LABEL_DUMMY_REMOVER);
  END_EDGE_LABEL_PROCESSING_ADDITIONS = $addAfter($addBefore($addBefore(new LayoutProcessorConfiguration, P4_NODE_PLACEMENT, LABEL_SIDE_SELECTOR), P4_NODE_PLACEMENT, END_LABEL_PREPROCESSOR), P5_EDGE_ROUTING, END_LABEL_POSTPROCESSOR);
}

function $getLayoutProcessorConfiguration_2(graph){
  var configuration, graphProperties;
  graphProperties = castTo($getProperty(graph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19);
  configuration = new LayoutProcessorConfiguration;
  if (graphProperties.contains(($clinit_GraphProperties() , HYPEREDGES))) {
    $addAll_4(configuration, HYPEREDGE_PROCESSING_ADDITIONS);
    $addAll_4(configuration, INVERTED_PORT_PROCESSING_ADDITIONS);
  }
  if (graphProperties.contains(NON_FREE_PORTS) || checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_LayeredOptions() , FEEDBACK_EDGES_0))))) {
    $addAll_4(configuration, INVERTED_PORT_PROCESSING_ADDITIONS);
    graphProperties.contains(NORTH_SOUTH_PORTS) && $addAll_4(configuration, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS);
  }
  graphProperties.contains(EXTERNAL_PORTS) && $addAll_4(configuration, HIERARCHICAL_PORT_PROCESSING_ADDITIONS);
  graphProperties.contains(SELF_LOOPS) && $addAll_4(configuration, SELF_LOOP_PROCESSING_ADDITIONS);
  graphProperties.contains(HYPERNODES) && $addAll_4(configuration, HYPERNODE_PROCESSING_ADDITIONS);
  graphProperties.contains(CENTER_LABELS) && $addAll_4(configuration, CENTER_EDGE_LABEL_PROCESSING_ADDITIONS);
  graphProperties.contains(END_LABELS) && $addAll_4(configuration, END_EDGE_LABEL_PROCESSING_ADDITIONS);
  return configuration;
}

function $process_74(layeredGraph, monitor){
  var edgeEdgeSpacing, edgeNodeSpacing, increment, isLeftLayerExternal, isRightLayerExternal, layerIter, leftLayer, leftLayerNodes, nodeNodeSpacing, rightLayer, rightLayerNodes, routingGenerator, slotsCount, startPos, xpos;
  $begin(monitor, 'Orthogonal edge routing', 1);
  castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , SPACINGS)), 277);
  nodeNodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_BETWEEN_LAYERS_0))));
  edgeEdgeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_EDGE_EDGE_BETWEEN_LAYERS_0)));
  edgeNodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_EDGE_NODE_BETWEEN_LAYERS_0)));
  checkNotNull_1(castToBoolean($getProperty(layeredGraph, DEBUG_MODE)));
  routingGenerator = new OrthogonalRoutingGenerator(0, edgeEdgeSpacing);
  xpos = 0;
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  leftLayer = null;
  leftLayerNodes = null;
  do {
    rightLayer = layerIter.i < layerIter.this$01_0.size_1()?(checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_3(layerIter.last = layerIter.i++), 25)):null;
    rightLayerNodes = !rightLayer?null:rightLayer.nodes;
    if (leftLayer) {
      placeNodesHorizontally(leftLayer, xpos);
      xpos += leftLayer.size_0.x_0;
    }
    startPos = !leftLayer?xpos:xpos + edgeNodeSpacing;
    slotsCount = $routeEdges_0(routingGenerator, layeredGraph, leftLayerNodes, rightLayerNodes, startPos);
    isLeftLayerExternal = !leftLayer || all_0(leftLayerNodes, ($clinit_PolylineEdgeRouter() , PRED_EXTERNAL_WEST_OR_EAST_PORT));
    isRightLayerExternal = !rightLayer || all_0(rightLayerNodes, ($clinit_PolylineEdgeRouter() , PRED_EXTERNAL_WEST_OR_EAST_PORT));
    if (slotsCount > 0) {
      increment = edgeNodeSpacing + (slotsCount - 1) * edgeEdgeSpacing;
      !!rightLayer && (increment += edgeNodeSpacing);
      increment < nodeNodeSpacing && !isLeftLayerExternal && !isRightLayerExternal && (increment = nodeNodeSpacing);
      xpos += increment;
    }
     else 
      !isLeftLayerExternal && !isRightLayerExternal && (xpos += nodeNodeSpacing);
    leftLayer = rightLayer;
    leftLayerNodes = rightLayerNodes;
  }
   while (rightLayer);
  layeredGraph.size_0.x_0 = xpos;
  $done_0(monitor);
}

function OrthogonalEdgeRouter(){
  $clinit_OrthogonalEdgeRouter();
}

defineClass(1329, 1, $intern_117, OrthogonalEdgeRouter);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_15(graph){
  return $getLayoutProcessorConfiguration_2(castTo(graph, 32));
}
;
_.process = function process_68(layeredGraph, monitor){
  $process_74(castTo(layeredGraph, 32), monitor);
}
;
var CENTER_EDGE_LABEL_PROCESSING_ADDITIONS, END_EDGE_LABEL_PROCESSING_ADDITIONS, HIERARCHICAL_PORT_PROCESSING_ADDITIONS, HYPEREDGE_PROCESSING_ADDITIONS, HYPERNODE_PROCESSING_ADDITIONS, INVERTED_PORT_PROCESSING_ADDITIONS, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS, SELF_LOOP_PROCESSING_ADDITIONS;
var Lorg_eclipse_elk_alg_layered_p5edges_OrthogonalEdgeRouter_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'OrthogonalEdgeRouter', 1329);
function $addJunctionPointIfNecessary(this$static, edge, hyperNode, pos, vertical){
  var jpoint, junctionPoints, p;
  p = vertical?pos.y_0:pos.x_0;
  if (p > hyperNode.start_0 && p < hyperNode.end || hyperNode.sourcePosis.size_0 != 0 && hyperNode.targetPosis.size_0 != 0 && ($wnd.Math.abs(p - checkNotNull_1(castToDouble($getFirst(hyperNode.sourcePosis)))) < $intern_104 && $wnd.Math.abs(p - checkNotNull_1(castToDouble($getFirst(hyperNode.targetPosis)))) < $intern_104 || $wnd.Math.abs(p - checkNotNull_1(castToDouble($getLast(hyperNode.sourcePosis)))) < $intern_104 && $wnd.Math.abs(p - checkNotNull_1(castToDouble($getLast(hyperNode.targetPosis)))) < $intern_104)) {
    if (!$contains_6(this$static.createdJunctionPoints, pos)) {
      junctionPoints = castTo($getProperty(edge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty_0(edge, JUNCTION_POINTS, junctionPoints);
      }
      jpoint = new KVector_2(pos);
      $addNode_0(junctionPoints, jpoint, junctionPoints.tail.prev, junctionPoints.tail);
      $add_6(this$static.createdJunctionPoints, jpoint);
    }
  }
}

function $createHyperNodes(this$static, nodes, portSide, hyperNodes, portToHyperNodeMap){
  var hyperNode, node, node$iterator, port, port$iterator;
  if (nodes) {
    for (node$iterator = nodes.iterator_0(); node$iterator.hasNext_0();) {
      node = castTo(node$iterator.next_1(), 9);
      for (port$iterator = $getPorts_0(node, ($clinit_PortType() , OUTPUT), portSide).iterator_0(); port$iterator.hasNext_0();) {
        port = castTo(port$iterator.next_1(), 11);
        hyperNode = castTo(getEntryValueOrNull($getEntry(portToHyperNodeMap.hashCodeMap, port)), 168);
        if (!hyperNode) {
          hyperNode = new OrthogonalRoutingGenerator$HyperNode(this$static);
          hyperNodes.array[hyperNodes.array.length] = hyperNode;
          $addPortPositions(hyperNode, port, portToHyperNodeMap);
        }
      }
    }
  }
}

function $routeEdges_0(this$static, layeredGraph, sourceLayerNodes, targetLayerNodes, startPos){
  var hyperNode1, hyperNode2, hyperNodes, iter1, iter2, node, node$iterator, portToHyperNodeMap, rankCount;
  portToHyperNodeMap = ($clinit_Maps() , new HashMap);
  hyperNodes = new ArrayList;
  $createHyperNodes(this$static, sourceLayerNodes, this$static.routingStrategy.getSourcePortSide(), hyperNodes, portToHyperNodeMap);
  $createHyperNodes(this$static, targetLayerNodes, this$static.routingStrategy.getTargetPortSide(), hyperNodes, portToHyperNodeMap);
  iter1 = new AbstractList$ListIteratorImpl(hyperNodes, 0);
  while (iter1.i < iter1.this$01_0.size_1()) {
    hyperNode1 = (checkCriticalElement(iter1.i < iter1.this$01_0.size_1()) , castTo(iter1.this$01_0.get_3(iter1.last = iter1.i++), 168));
    iter2 = new AbstractList$ListIteratorImpl(hyperNodes, iter1.i);
    while (iter2.i < iter2.this$01_0.size_1()) {
      hyperNode2 = (checkCriticalElement(iter2.i < iter2.this$01_0.size_1()) , castTo(iter2.this$01_0.get_3(iter2.last = iter2.i++), 168));
      createDependency(hyperNode1, hyperNode2, this$static.conflictThreshold);
    }
  }
  breakCycles(hyperNodes, castTo($getProperty(layeredGraph, ($clinit_InternalProperties_1() , RANDOM_0)), 221));
  topologicalNumbering(hyperNodes);
  rankCount = -1;
  for (node$iterator = new ArrayList$1(hyperNodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 168);
    if ($wnd.Math.abs(node.start_0 - node.end) < $intern_104) {
      continue;
    }
    rankCount = max_1(rankCount, node.rank);
    this$static.routingStrategy.calculateBendPoints(node, startPos);
  }
  this$static.createdJunctionPoints.map_0.clear_0();
  return rankCount + 1;
}

function OrthogonalRoutingGenerator(direction, edgeSpacing){
  this.createdJunctionPoints = new HashSet;
  switch (direction) {
    case 0:
      this.routingStrategy = new OrthogonalRoutingGenerator$WestToEastRoutingStrategy(this);
      break;
    case 1:
      this.routingStrategy = new OrthogonalRoutingGenerator$NorthToSouthRoutingStrategy(this);
      break;
    case 2:
      this.routingStrategy = new OrthogonalRoutingGenerator$SouthToNorthRoutingStrategy(this);
      break;
    default:throw toJs(new IllegalArgumentException);
  }
  this.edgeSpacing = edgeSpacing;
  this.conflictThreshold = 0.2 * edgeSpacing;
}

function breakCycles(nodes, random){
  var depIter, dependency, dependency$iterator, dependency$iterator0, entry, entryIterator, inweight, markBase, maxNode, maxNodes, maxOutflow, nextLeft, nextMark, nextRight, node, node$iterator, node$iterator0, node$iterator1, outflow, outweight, shiftBase, sink, sinks, source, source$iterator, sources, target, unprocessed;
  sources = new LinkedList;
  sinks = new LinkedList;
  nextMark = -1;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 168);
    node.mark = nextMark--;
    inweight = 0;
    outweight = 0;
    for (dependency$iterator0 = new ArrayList$1(node.outgoing); dependency$iterator0.i < dependency$iterator0.this$01.array.length;) {
      dependency = castTo($next_10(dependency$iterator0), 261);
      outweight += dependency.weight;
    }
    for (dependency$iterator = new ArrayList$1(node.incoming); dependency$iterator.i < dependency$iterator.this$01.array.length;) {
      dependency = castTo($next_10(dependency$iterator), 261);
      inweight += dependency.weight;
    }
    node.inweight = inweight;
    node.outweight = outweight;
    outweight == 0?($addNode_0(sinks, node, sinks.tail.prev, sinks.tail) , true):inweight == 0 && ($addNode_0(sources, node, sources.tail.prev, sources.tail) , true);
  }
  unprocessed = newTreeSet(nodes);
  markBase = nodes.array.length;
  nextRight = markBase - 1;
  nextLeft = markBase + 1;
  maxNodes = new ArrayList;
  while (unprocessed.map_0.size_0 != 0) {
    while (sinks.size_0 != 0) {
      sink = (checkCriticalElement(sinks.size_0 != 0) , castTo($removeNode_0(sinks, sinks.header.next_0), 168));
      $remove_26(unprocessed.map_0, sink) != null;
      sink.mark = nextRight--;
      updateNeighbors(sink, sources, sinks);
    }
    while (sources.size_0 != 0) {
      source = (checkCriticalElement(sources.size_0 != 0) , castTo($removeNode_0(sources, sources.header.next_0), 168));
      $remove_26(unprocessed.map_0, source) != null;
      source.mark = nextLeft++;
      updateNeighbors(source, sources, sinks);
    }
    maxOutflow = $intern_43;
    for (node$iterator1 = (entryIterator = new TreeMap$EntryIterator((new TreeMap$EntrySet((new AbstractNavigableMap$NavigableKeySet(unprocessed.map_0)).map_0)).this$01_0) , new AbstractNavigableMap$NavigableKeySet$1(entryIterator)); $hasNext_1(node$iterator1.val$entryIterator2.iter);) {
      node = (entry = $next_14(node$iterator1.val$entryIterator2) , castTo(entry.getKey(), 168));
      outflow = node.outweight - node.inweight;
      if (outflow >= maxOutflow) {
        if (outflow > maxOutflow) {
          maxNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
          maxOutflow = outflow;
        }
        maxNodes.array[maxNodes.array.length] = node;
      }
    }
    if (maxNodes.array.length != 0) {
      maxNode = castTo($get_7(maxNodes, $nextInt(random, maxNodes.array.length)), 168);
      $remove_26(unprocessed.map_0, maxNode) != null;
      maxNode.mark = nextLeft++;
      updateNeighbors(maxNode, sources, sinks);
      maxNodes.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    }
  }
  shiftBase = nodes.array.length + 1;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 168);
    node.mark < markBase && (node.mark += shiftBase);
  }
  for (source$iterator = new ArrayList$1(nodes); source$iterator.i < source$iterator.this$01.array.length;) {
    source = castTo($next_10(source$iterator), 168);
    depIter = new AbstractList$ListIteratorImpl(source.outgoing, 0);
    while (depIter.i < depIter.this$01_0.size_1()) {
      dependency = (checkCriticalElement(depIter.i < depIter.this$01_0.size_1()) , castTo(depIter.this$01_0.get_3(depIter.last = depIter.i++), 261));
      target = dependency.target;
      if (source.mark > target.mark) {
        $remove_9(depIter);
        $remove_13(target.incoming, dependency);
        if (dependency.weight > 0) {
          dependency.source = target;
          $add_4(target.outgoing, dependency);
          dependency.target = source;
          $add_4(source.incoming, dependency);
        }
      }
    }
  }
}

function countConflicts(posis1, posis2, minDiff){
  var conflicts, hasMore, iter1, iter2, pos1, pos2;
  conflicts = 0;
  if (posis1.size_0 != 0 && posis2.size_0 != 0) {
    iter1 = $listIterator_1(posis1, 0);
    iter2 = $listIterator_1(posis2, 0);
    pos1 = checkNotNull_1(castToDouble($next_13(iter1)));
    pos2 = checkNotNull_1(castToDouble($next_13(iter2)));
    hasMore = true;
    do {
      pos1 > pos2 - minDiff && pos1 < pos2 + minDiff && ++conflicts;
      pos1 <= pos2 && iter1.currentNode != iter1.this$01.tail?(pos1 = checkNotNull_1(castToDouble($next_13(iter1)))):pos2 <= pos1 && iter2.currentNode != iter2.this$01.tail?(pos2 = checkNotNull_1(castToDouble($next_13(iter2)))):(hasMore = false);
    }
     while (hasMore);
  }
  return conflicts;
}

function countCrossings(posis, start_0, end){
  var crossings, pos, pos$iterator;
  crossings = 0;
  for (pos$iterator = $listIterator_1(posis, 0); pos$iterator.currentNode != pos$iterator.this$01.tail;) {
    pos = checkNotNull_1(castToDouble($next_13(pos$iterator)));
    if (pos > end) {
      break;
    }
     else 
      pos >= start_0 && ++crossings;
  }
  return crossings;
}

function createDependency(hn1, hn2, minDiff){
  var conflicts1, conflicts2, crossings1, crossings2, depValue1, depValue2;
  if ($wnd.Math.abs(hn1.start_0 - hn1.end) < $intern_104 || $wnd.Math.abs(hn2.start_0 - hn2.end) < $intern_104) {
    return;
  }
  conflicts1 = countConflicts(hn1.targetPosis, hn2.sourcePosis, minDiff);
  conflicts2 = countConflicts(hn2.targetPosis, hn1.sourcePosis, minDiff);
  crossings1 = countCrossings(hn1.targetPosis, hn2.start_0, hn2.end) + countCrossings(hn2.sourcePosis, hn1.start_0, hn1.end);
  crossings2 = countCrossings(hn2.targetPosis, hn1.start_0, hn1.end) + countCrossings(hn1.sourcePosis, hn2.start_0, hn2.end);
  depValue1 = 16 * conflicts1 + crossings1;
  depValue2 = 16 * conflicts2 + crossings2;
  if (depValue1 < depValue2) {
    new OrthogonalRoutingGenerator$Dependency(hn1, hn2, depValue2 - depValue1);
  }
   else if (depValue1 > depValue2) {
    new OrthogonalRoutingGenerator$Dependency(hn2, hn1, depValue1 - depValue2);
  }
   else if (depValue1 > 0 && depValue2 > 0) {
    new OrthogonalRoutingGenerator$Dependency(hn1, hn2, 0);
    new OrthogonalRoutingGenerator$Dependency(hn2, hn1, 0);
  }
}

function insertSorted(list, value_0){
  var listIter, next;
  listIter = $listIterator_1(list, 0);
  while (listIter.currentNode != listIter.this$01.tail) {
    next = checkNotNull_1(castToDouble($next_13(listIter)));
    if (next == value_0) {
      return;
    }
     else if (next > value_0) {
      $previous_1(listIter);
      break;
    }
  }
  $add_8(listIter, value_0);
}

function topologicalNumbering(nodes){
  var dep, dep$iterator, maxRank, node, node$iterator, node$iterator0, rightwardTargets, source, sources, target;
  sources = new ArrayList;
  rightwardTargets = new ArrayList;
  for (node$iterator0 = new ArrayList$1(nodes); node$iterator0.i < node$iterator0.this$01.array.length;) {
    node = castTo($next_10(node$iterator0), 168);
    node.inweight = node.incoming.array.length;
    node.outweight = node.outgoing.array.length;
    node.inweight == 0 && (sources.array[sources.array.length] = node , true);
    node.outweight == 0 && node.sourcePosis.size_0 == 0 && (rightwardTargets.array[rightwardTargets.array.length] = node , true);
  }
  maxRank = -1;
  while (sources.array.length != 0) {
    node = castTo($remove_12(sources, 0), 168);
    for (dep$iterator = new ArrayList$1(node.outgoing); dep$iterator.i < dep$iterator.this$01.array.length;) {
      dep = castTo($next_10(dep$iterator), 261);
      target = dep.target;
      target.rank = max_1(target.rank, node.rank + 1);
      maxRank = max_1(maxRank, target.rank);
      --target.inweight;
      target.inweight == 0 && (sources.array[sources.array.length] = target , true);
    }
  }
  if (maxRank > -1) {
    for (node$iterator = new ArrayList$1(rightwardTargets); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 168);
      node.rank = maxRank;
    }
    while (rightwardTargets.array.length != 0) {
      node = castTo($remove_12(rightwardTargets, 0), 168);
      for (dep$iterator = new ArrayList$1(node.incoming); dep$iterator.i < dep$iterator.this$01.array.length;) {
        dep = castTo($next_10(dep$iterator), 261);
        source = dep.source;
        if (source.sourcePosis.size_0 > 0) {
          continue;
        }
        source.rank = min_1(source.rank, node.rank - 1);
        --source.outweight;
        source.outweight == 0 && (rightwardTargets.array[rightwardTargets.array.length] = source , true);
      }
    }
  }
}

function updateNeighbors(node, sources, sinks){
  var dep, dep$iterator, dep$iterator0;
  for (dep$iterator0 = new ArrayList$1(node.outgoing); dep$iterator0.i < dep$iterator0.this$01.array.length;) {
    dep = castTo($next_10(dep$iterator0), 261);
    if (dep.target.mark < 0 && dep.weight > 0) {
      dep.target.inweight -= dep.weight;
      dep.target.inweight <= 0 && dep.target.outweight > 0 && $add_7(sources, dep.target);
    }
  }
  for (dep$iterator = new ArrayList$1(node.incoming); dep$iterator.i < dep$iterator.this$01.array.length;) {
    dep = castTo($next_10(dep$iterator), 261);
    if (dep.source.mark < 0 && dep.weight > 0) {
      dep.source.outweight -= dep.weight;
      dep.source.outweight <= 0 && dep.source.inweight > 0 && $add_7(sinks, dep.source);
    }
  }
}

defineClass(615, 1, {}, OrthogonalRoutingGenerator);
_.conflictThreshold = 0;
_.edgeSpacing = 0;
var Lorg_eclipse_elk_alg_layered_p5edges_OrthogonalRoutingGenerator_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'OrthogonalRoutingGenerator', 615);
function OrthogonalRoutingGenerator$Dependency(thesource, thetarget, theweight){
  this.target = thetarget;
  this.source = thesource;
  this.weight = theweight;
  $add_4(this.source.outgoing, this);
  $add_4(this.target.incoming, this);
}

defineClass(261, 1, {261:1}, OrthogonalRoutingGenerator$Dependency);
_.toString_0 = function toString_103(){
  return this.source + '->' + this.target;
}
;
_.weight = 0;
var Lorg_eclipse_elk_alg_layered_p5edges_OrthogonalRoutingGenerator$Dependency_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'OrthogonalRoutingGenerator/Dependency', 261);
function $addPortPositions(this$static, port, hyperNodeMap){
  var otherPort, otherPort$iterator, pos;
  hyperNodeMap.put(port, this$static);
  $add_4(this$static.ports, port);
  pos = this$static.this$01.routingStrategy.getPortPositionOnHyperNode(port);
  isNaN_0(this$static.start_0)?(this$static.start_0 = pos):(this$static.start_0 = $wnd.Math.min(this$static.start_0, pos));
  isNaN_0(this$static.end)?(this$static.end = pos):(this$static.end = $wnd.Math.max(this$static.end, pos));
  port.side == this$static.this$01.routingStrategy.getSourcePortSide()?insertSorted(this$static.sourcePosis, pos):insertSorted(this$static.targetPosis, pos);
  for (otherPort$iterator = $iterator(concat_1(new LPort$7(port), new LPort$8(port))); $hasNext_0(otherPort$iterator);) {
    otherPort = castTo($next_2(otherPort$iterator), 11);
    hyperNodeMap.containsKey(otherPort) || $addPortPositions(this$static, otherPort, hyperNodeMap);
  }
}

function $compareTo_17(this$static, other){
  return this$static.mark - other.mark;
}

function OrthogonalRoutingGenerator$HyperNode(this$0){
  this.this$01 = this$0;
  this.ports = new ArrayList;
  this.sourcePosis = new LinkedList;
  this.targetPosis = new LinkedList;
  this.outgoing = new ArrayList;
  this.incoming = new ArrayList;
}

defineClass(168, 1, {34:1, 168:1}, OrthogonalRoutingGenerator$HyperNode);
_.compareTo_0 = function compareTo_18(other){
  return $compareTo_17(this, castTo(other, 168));
}
;
_.equals_0 = function equals_158(object){
  var other;
  if (instanceOf(object, 168)) {
    other = castTo(object, 168);
    return this.mark == other.mark;
  }
  return false;
}
;
_.hashCode_1 = function hashCode_58(){
  return this.mark;
}
;
_.toString_0 = function toString_104(){
  var builder, name_0, port, portIter;
  builder = new StringBuilder_1('{');
  portIter = new ArrayList$1(this.ports);
  while (portIter.i < portIter.this$01.array.length) {
    port = castTo($next_10(portIter), 11);
    name_0 = $getName_0(port.owner);
    name_0 == null && (name_0 = 'n' + $getIndex(port.owner));
    builder.string += '' + name_0;
    portIter.i < portIter.this$01.array.length && (builder.string += ',' , builder);
  }
  builder.string += '}';
  return builder.string;
}
;
_.end = NaN;
_.inweight = 0;
_.mark = 0;
_.outweight = 0;
_.rank = 0;
_.start_0 = NaN;
var Lorg_eclipse_elk_alg_layered_p5edges_OrthogonalRoutingGenerator$HyperNode_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'OrthogonalRoutingGenerator/HyperNode', 168);
function OrthogonalRoutingGenerator$NorthToSouthRoutingStrategy(this$0){
  this.this$01 = this$0;
}

defineClass(1487, 1, {}, OrthogonalRoutingGenerator$NorthToSouthRoutingStrategy);
_.calculateBendPoints = function calculateBendPoints(hyperNode, startPos){
  var edge, edge$iterator, point1, point2, port, port$iterator, sourcex, target, targetx, y_0;
  y_0 = startPos + hyperNode.rank * this.this$01.edgeSpacing;
  for (port$iterator = new ArrayList$1(hyperNode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    sourcex = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor])).x_0;
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 16);
      target = edge.target;
      targetx = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [target.owner.pos, target.pos, target.anchor])).x_0;
      if ($wnd.Math.abs(sourcex - targetx) > $intern_104) {
        point1 = new KVector_1(sourcex, y_0);
        $add_7(edge.bendPoints, point1);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point1, false);
        point2 = new KVector_1(targetx, y_0);
        $add_7(edge.bendPoints, point2);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point2, false);
      }
    }
  }
}
;
_.getPortPositionOnHyperNode = function getPortPositionOnHyperNode(port){
  return port.owner.pos.x_0 + port.pos.x_0 + port.anchor.x_0;
}
;
_.getSourcePortSide = function getSourcePortSide(){
  return $clinit_PortSide() , SOUTH_1;
}
;
_.getTargetPortSide = function getTargetPortSide(){
  return $clinit_PortSide() , NORTH_1;
}
;
var Lorg_eclipse_elk_alg_layered_p5edges_OrthogonalRoutingGenerator$NorthToSouthRoutingStrategy_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'OrthogonalRoutingGenerator/NorthToSouthRoutingStrategy', 1487);
function OrthogonalRoutingGenerator$SouthToNorthRoutingStrategy(this$0){
  this.this$01 = this$0;
}

defineClass(1488, 1, {}, OrthogonalRoutingGenerator$SouthToNorthRoutingStrategy);
_.calculateBendPoints = function calculateBendPoints_0(hyperNode, startPos){
  var edge, edge$iterator, point1, point2, port, port$iterator, sourcex, target, targetx, y_0;
  y_0 = startPos - hyperNode.rank * this.this$01.edgeSpacing;
  for (port$iterator = new ArrayList$1(hyperNode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    sourcex = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor])).x_0;
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 16);
      target = edge.target;
      targetx = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [target.owner.pos, target.pos, target.anchor])).x_0;
      if ($wnd.Math.abs(sourcex - targetx) > $intern_104) {
        point1 = new KVector_1(sourcex, y_0);
        $add_7(edge.bendPoints, point1);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point1, false);
        point2 = new KVector_1(targetx, y_0);
        $add_7(edge.bendPoints, point2);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point2, false);
      }
    }
  }
}
;
_.getPortPositionOnHyperNode = function getPortPositionOnHyperNode_0(port){
  return port.owner.pos.x_0 + port.pos.x_0 + port.anchor.x_0;
}
;
_.getSourcePortSide = function getSourcePortSide_0(){
  return $clinit_PortSide() , NORTH_1;
}
;
_.getTargetPortSide = function getTargetPortSide_0(){
  return $clinit_PortSide() , SOUTH_1;
}
;
var Lorg_eclipse_elk_alg_layered_p5edges_OrthogonalRoutingGenerator$SouthToNorthRoutingStrategy_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'OrthogonalRoutingGenerator/SouthToNorthRoutingStrategy', 1488);
function OrthogonalRoutingGenerator$WestToEastRoutingStrategy(this$0){
  this.this$01 = this$0;
}

defineClass(1486, 1, {}, OrthogonalRoutingGenerator$WestToEastRoutingStrategy);
_.calculateBendPoints = function calculateBendPoints_1(hyperNode, startPos){
  var edge, edge$iterator, point1, point2, port, port$iterator, sourcey, target, targety, x_0;
  x_0 = startPos + hyperNode.rank * this.this$01.edgeSpacing;
  for (port$iterator = new ArrayList$1(hyperNode.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    sourcey = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor])).y_0;
    for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
      edge = castTo($next_10(edge$iterator), 16);
      target = edge.target;
      targety = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [target.owner.pos, target.pos, target.anchor])).y_0;
      if ($wnd.Math.abs(sourcey - targety) > $intern_104) {
        point1 = new KVector_1(x_0, sourcey);
        $add_7(edge.bendPoints, point1);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point1, true);
        point2 = new KVector_1(x_0, targety);
        $add_7(edge.bendPoints, point2);
        $addJunctionPointIfNecessary(this.this$01, edge, hyperNode, point2, true);
      }
    }
  }
}
;
_.getPortPositionOnHyperNode = function getPortPositionOnHyperNode_1(port){
  return port.owner.pos.y_0 + port.pos.y_0 + port.anchor.y_0;
}
;
_.getSourcePortSide = function getSourcePortSide_1(){
  return $clinit_PortSide() , EAST_1;
}
;
_.getTargetPortSide = function getTargetPortSide_1(){
  return $clinit_PortSide() , WEST_1;
}
;
var Lorg_eclipse_elk_alg_layered_p5edges_OrthogonalRoutingGenerator$WestToEastRoutingStrategy_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'OrthogonalRoutingGenerator/WestToEastRoutingStrategy', 1486);
function $clinit_PolylineEdgeRouter(){
  $clinit_PolylineEdgeRouter = emptyMethod;
  PRED_EXTERNAL_WEST_OR_EAST_PORT = new PolylineEdgeRouter$1;
  INVERTED_PORT_PROCESSING_ADDITIONS_0 = $addBefore(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P3_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy() , INVERTED_PORT_PROCESSOR));
  NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_0 = $addAfter($addBefore(new LayoutProcessorConfiguration, P3_NODE_ORDERING, NORTH_SOUTH_PORT_PREPROCESSOR), P5_EDGE_ROUTING, NORTH_SOUTH_PORT_POSTPROCESSOR);
  CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_0 = $addAfter($addBefore($addBefore($addBefore(new LayoutProcessorConfiguration, P2_LAYERING, LABEL_DUMMY_INSERTER), P4_NODE_PLACEMENT, LABEL_DUMMY_SWITCHER), P4_NODE_PLACEMENT, LABEL_SIDE_SELECTOR), P5_EDGE_ROUTING, LABEL_DUMMY_REMOVER);
  END_EDGE_LABEL_PROCESSING_ADDITIONS_0 = $addAfter($addBefore($addBefore(new LayoutProcessorConfiguration, P4_NODE_PLACEMENT, LABEL_SIDE_SELECTOR), P4_NODE_PLACEMENT, END_LABEL_PREPROCESSOR), P5_EDGE_ROUTING, END_LABEL_POSTPROCESSOR);
}

function $addBendPoint(this$static, edge, bendPoint, addJunctionPoint, currPort){
  var jpoint, junctionPoints;
  if (!$isSelfLoop(edge) && edge.source.owner.layer == edge.target.owner.layer || !$equals_7(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [currPort.owner.pos, currPort.pos, currPort.anchor])), bendPoint)) {
    edge.source == currPort?$add_0(edge.bendPoints, 0, new KVector_2(bendPoint)):$add_7(edge.bendPoints, new KVector_2(bendPoint));
    if (addJunctionPoint && !$contains_6(this$static.createdJunctionPoints, bendPoint)) {
      junctionPoints = castTo($getProperty(edge, ($clinit_LayeredOptions() , JUNCTION_POINTS)), 74);
      if (!junctionPoints) {
        junctionPoints = new KVectorChain;
        $setProperty_0(edge, JUNCTION_POINTS, junctionPoints);
      }
      jpoint = new KVector_2(bendPoint);
      $addNode_0(junctionPoints, jpoint, junctionPoints.tail.prev, junctionPoints.tail);
      $add_6(this$static.createdJunctionPoints, jpoint);
    }
  }
}

function $calculateWestInLayerEdgeYDiff(layer){
  var maxYDiff, node, node$iterator, outgoingEdge, outgoingEdge$iterator, sourcePos, targetPos;
  maxYDiff = 0;
  for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    for (outgoingEdge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(outgoingEdge$iterator);) {
      outgoingEdge = castTo($next_2(outgoingEdge$iterator), 16);
      if (layer == outgoingEdge.target.owner.layer && outgoingEdge.source.side == ($clinit_PortSide() , WEST_1)) {
        sourcePos = $getAbsoluteAnchor(outgoingEdge.source).y_0;
        targetPos = $getAbsoluteAnchor(outgoingEdge.target).y_0;
        maxYDiff = $wnd.Math.max(maxYDiff, $wnd.Math.abs(targetPos - sourcePos));
      }
    }
  }
  return maxYDiff;
}

function $getLayoutProcessorConfiguration_3(graph){
  var configuration, graphProperties;
  graphProperties = castTo($getProperty(graph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19);
  configuration = new LayoutProcessorConfiguration;
  if (graphProperties.contains(($clinit_GraphProperties() , NON_FREE_PORTS)) || checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_LayeredOptions() , FEEDBACK_EDGES_0))))) {
    $addAll_4(configuration, INVERTED_PORT_PROCESSING_ADDITIONS_0);
    graphProperties.contains(NORTH_SOUTH_PORTS) && $addAll_4(configuration, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_0);
  }
  graphProperties.contains(CENTER_LABELS) && $addAll_4(configuration, CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_0);
  graphProperties.contains(END_LABELS) && $addAll_4(configuration, END_EDGE_LABEL_PROCESSING_ADDITIONS_0);
  return configuration;
}

function $isInLayerDummy_0(node){
  var e, e$iterator;
  if (node.type_0 == ($clinit_LNode$NodeType() , LONG_EDGE)) {
    for (e$iterator = $iterator($getConnectedEdges_0(node)); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 16);
      if (!$isSelfLoop(e) && e.source.owner.layer == e.target.owner.layer) {
        return true;
      }
    }
  }
  return false;
}

function $process_75(this$static, layeredGraph, monitor){
  var edgeSpaceFac, edgeSpacing, externalLayer, layer, layerIter, layerSpacing, maxCurrOutputYDiff, maxVertDiff, node, node$iterator, nodeSpacing, outgoingEdge, outgoingEdge$iterator, sourcePos, targetPos, xpos, yDiff;
  $begin(monitor, 'Polyline edge routing', 1);
  nodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_BETWEEN_LAYERS_0))));
  edgeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_EDGE_EDGE_BETWEEN_LAYERS_0)));
  edgeSpaceFac = $wnd.Math.min(1, edgeSpacing / nodeSpacing);
  xpos = 0;
  if (layeredGraph.layers.array.length != 0) {
    yDiff = $calculateWestInLayerEdgeYDiff(castTo($get_7(layeredGraph.layers, 0), 25));
    xpos = 0.4 * edgeSpaceFac * yDiff;
  }
  layerIter = new AbstractList$ListIteratorImpl(layeredGraph.layers, 0);
  while (layerIter.i < layerIter.this$01_0.size_1()) {
    layer = (checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_3(layerIter.last = layerIter.i++), 25));
    externalLayer = all_0(layer, PRED_EXTERNAL_WEST_OR_EAST_PORT);
    externalLayer && xpos > 0 && (xpos -= nodeSpacing);
    placeNodesHorizontally(layer, xpos);
    maxVertDiff = 0;
    for (node$iterator = new ArrayList$1(layer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      maxCurrOutputYDiff = 0;
      for (outgoingEdge$iterator = $iterator($getOutgoingEdges(node)); $hasNext_0(outgoingEdge$iterator);) {
        outgoingEdge = castTo($next_2(outgoingEdge$iterator), 16);
        sourcePos = $getAbsoluteAnchor(outgoingEdge.source).y_0;
        targetPos = $getAbsoluteAnchor(outgoingEdge.target).y_0;
        if (layer == outgoingEdge.target.owner.layer) {
          $processInLayerEdge(outgoingEdge, xpos, 0.4 * edgeSpaceFac * $wnd.Math.abs(sourcePos - targetPos));
          if (outgoingEdge.source.side == ($clinit_PortSide() , WEST_1)) {
            sourcePos = 0;
            targetPos = 0;
          }
        }
        maxCurrOutputYDiff = $wnd.Math.max(maxCurrOutputYDiff, $wnd.Math.abs(targetPos - sourcePos));
      }
      switch (node.type_0.ordinal) {
        case 0:
        case 4:
        case 1:
        case 3:
        case 6:
          $processNode_3(this$static, node, xpos);
      }
      maxVertDiff = $wnd.Math.max(maxVertDiff, maxCurrOutputYDiff);
    }
    if (layerIter.i < layerIter.this$01_0.size_1()) {
      yDiff = $calculateWestInLayerEdgeYDiff((checkCriticalElement(layerIter.i < layerIter.this$01_0.size_1()) , castTo(layerIter.this$01_0.get_3(layerIter.last = layerIter.i++), 25)));
      maxVertDiff = $wnd.Math.max(maxVertDiff, yDiff);
      checkCriticalElement(layerIter.i > 0);
      layerIter.this$01.get_3(layerIter.last = --layerIter.i);
    }
    layerSpacing = 0.4 * edgeSpaceFac * maxVertDiff;
    !externalLayer && layerIter.i < layerIter.this$01_0.size_1() && (layerSpacing += nodeSpacing);
    xpos += layer.size_0.x_0 + layerSpacing;
  }
  this$static.createdJunctionPoints.map_0.clear_0();
  layeredGraph.size_0.x_0 = xpos;
  $done_0(monitor);
}

function $processInLayerEdge(edge, layerXPos, edgeSpacing){
  var bendPoint, midY, sourcePort, targetPort;
  sourcePort = edge.source;
  targetPort = edge.target;
  midY = (sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourcePort.owner.pos, sourcePort.pos, sourcePort.anchor])).y_0 + sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).y_0) / 2;
  sourcePort.side == ($clinit_PortSide() , EAST_1)?(bendPoint = new KVector_1(layerXPos + sourcePort.owner.layer.size_0.x_0 + edgeSpacing, midY)):(bendPoint = new KVector_1(layerXPos - edgeSpacing, midY));
  $add_0(edge.bendPoints, 0, bendPoint);
}

function $processNode_3(this$static, node, layerLeftXPos){
  var absolutePortAnchor, addJunctionPoint, bendPoint, e, e$iterator, layerRightXPos, otherPort, port, port$iterator;
  layerRightXPos = layerLeftXPos + node.layer.size_0.x_0;
  for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    absolutePortAnchor = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor]));
    bendPoint = new KVector_1(0, absolutePortAnchor.y_0);
    if (port.side == ($clinit_PortSide() , EAST_1)) {
      bendPoint.x_0 = layerRightXPos;
    }
     else if (port.side == WEST_1) {
      bendPoint.x_0 = layerLeftXPos;
    }
     else {
      continue;
    }
    if (absolutePortAnchor.x_0 == bendPoint.x_0 && !$isInLayerDummy_0(node)) {
      continue;
    }
    addJunctionPoint = port.outgoingEdges.array.length + port.incomingEdges.array.length > 1;
    for (e$iterator = new LPort$CombineIter$1(port.connectedEdges); $hasNext_2(e$iterator.firstIterator) || $hasNext_2(e$iterator.secondIterator);) {
      e = castTo($hasNext_2(e$iterator.firstIterator)?$next_10(e$iterator.firstIterator):$next_10(e$iterator.secondIterator), 16);
      otherPort = e.source == port?e.target:e.source;
      $wnd.Math.abs(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [otherPort.owner.pos, otherPort.pos, otherPort.anchor])).y_0 - bendPoint.y_0) > 1 && $addBendPoint(this$static, e, bendPoint, addJunctionPoint, port);
    }
  }
}

function PolylineEdgeRouter(){
  $clinit_PolylineEdgeRouter();
  this.createdJunctionPoints = new HashSet;
}

defineClass(1322, 1, $intern_117, PolylineEdgeRouter);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_16(graph){
  return $getLayoutProcessorConfiguration_3(castTo(graph, 32));
}
;
_.process = function process_69(layeredGraph, monitor){
  $process_75(this, castTo(layeredGraph, 32), monitor);
}
;
var CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_0, END_EDGE_LABEL_PROCESSING_ADDITIONS_0, INVERTED_PORT_PROCESSING_ADDITIONS_0, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_0, PRED_EXTERNAL_WEST_OR_EAST_PORT;
var Lorg_eclipse_elk_alg_layered_p5edges_PolylineEdgeRouter_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'PolylineEdgeRouter', 1322);
function $apply_23(node){
  var extPortSide;
  extPortSide = castTo($getProperty(node, ($clinit_InternalProperties_1() , EXT_PORT_SIDE)), 71);
  return node.type_0 == ($clinit_LNode$NodeType() , EXTERNAL_PORT) && (extPortSide == ($clinit_PortSide() , WEST_1) || extPortSide == EAST_1);
}

function PolylineEdgeRouter$1(){
}

defineClass(1323, 1, $intern_91, PolylineEdgeRouter$1);
_.apply_1 = function apply_133(node){
  return $apply_23(castTo(node, 9));
}
;
_.equals_0 = function equals_159(other){
  return this === other;
}
;
_.test_0 = function test_76(input_0){
  return this.apply_1(input_0);
}
;
var Lorg_eclipse_elk_alg_layered_p5edges_PolylineEdgeRouter$1_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges', 'PolylineEdgeRouter/1', 1323);
function $addPort(this$static, port){
  if ($hasNonLoopEdge(this$static, port)) {
    $add_6(this$static.portsWithNonLoopEdge, port);
    return true;
  }
  port.side != ($clinit_PortSide() , UNDEFINED_7) && $add_6(this$static.portsWithPortSide, port);
  port.outgoingEdges.array.length == 0?$add_6(this$static.exclusiveLoopTargetPorts, port):$add_6(this$static.exclusiveLoopSourcePorts, port);
  return false;
}

function $calculateNewTextSize(this$static, edge){
  var edgeMaxTextWidth, edgeTextHeight, label_0, label$iterator;
  edgeMaxTextWidth = 0;
  edgeTextHeight = 0;
  for (label$iterator = new ArrayList$1(edge.labels); label$iterator.i < label$iterator.this$01.array.length;) {
    label_0 = castTo($next_10(label$iterator), 70);
    edgeMaxTextWidth = $wnd.Math.max(edgeMaxTextWidth, label_0.size_0.x_0);
    edgeTextHeight += label_0.size_0.y_0;
  }
  $setProperty_0(edge, ($clinit_InternalProperties_1() , SPLINE_LABEL_SIZE), new KVector_1(edgeMaxTextWidth, edgeTextHeight));
  this$static.textWidth < edgeMaxTextWidth && (this$static.textWidth = edgeMaxTextWidth);
  this$static.textHeight += edgeTextHeight;
}

function $getHidablePorts(this$static){
  var allPorts;
  allPorts = newLinkedList(this$static.exclusiveLoopSourcePorts);
  $addAll(allPorts, this$static.exclusiveLoopTargetPorts);
  $addAll(allPorts, this$static.portsWithPortSide);
  return allPorts;
}

function $getTargetLoopPortsReversed(this$static){
  var list, port, port$iterator, retVal;
  retVal = new LinkedHashSet;
  list = new ArrayList_1(this$static.exclusiveLoopTargetPorts);
  reverse_2(list);
  for (port$iterator = new ArrayList$1(list); port$iterator.i < port$iterator.this$01.array.length;) {
    port = castTo($next_10(port$iterator), 11);
    retVal.map_0.put(port, retVal);
  }
  return retVal;
}

function $hasNonLoopEdge(this$static, port){
  var edge, edge$iterator, edge$iterator0;
  for (edge$iterator0 = new ArrayList$1(port.outgoingEdges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator0), 16);
    if (edge.target.owner != this$static.owner) {
      return true;
    }
  }
  for (edge$iterator = new ArrayList$1(port.incomingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 16);
    if (edge.source.owner != this$static.owner) {
      return true;
    }
  }
  return false;
}

function $setLoopSide(this$static, side, alsoForEdges){
  var edge, edge$iterator;
  this$static.loopSide = side;
  if (alsoForEdges) {
    for (edge$iterator = this$static.edges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
      edge = castTo(edge$iterator.next_1(), 16);
      $setProperty_0(edge, ($clinit_InternalProperties_1() , SPLINE_LOOPSIDE), this$static.loopSide);
      $setSide(edge.source, side.source);
      $setSide(edge.target, side.target);
    }
  }
}

function $tryAddEdge(this$static, edge, isFixedOrder){
  var edgeMustBeHidden, source, target;
  source = edge.source;
  target = edge.target;
  edgeMustBeHidden = isFixedOrder;
  if ($add_6(this$static.edges, edge)) {
    $addPort(this$static, source) && (edgeMustBeHidden = true);
    $addPort(this$static, target) && (edgeMustBeHidden = true);
    if (edgeMustBeHidden) {
      $remove_13(edge.source.outgoingEdges, edge);
      $remove_13(edge.target.incomingEdges, edge);
      $add_6(this$static.hiddenEdges, edge);
    }
    $calculateNewTextSize(this$static, edge);
    return true;
  }
  return false;
}

function $unhideEdges(this$static){
  var edge, edge$iterator;
  for (edge$iterator = this$static.hiddenEdges.map_0.keySet_0().iterator_0(); edge$iterator.hasNext_0();) {
    edge = castTo(edge$iterator.next_1(), 16);
    $add_4(edge.source.outgoingEdges, edge);
    $add_4(edge.target.incomingEdges, edge);
  }
}

function ConnectedSelfLoopComponent(node){
  this.edges = new LinkedHashSet;
  this.hiddenEdges = new LinkedHashSet;
  this.exclusiveLoopSourcePorts = new LinkedHashSet;
  this.exclusiveLoopTargetPorts = new LinkedHashSet;
  this.portsWithNonLoopEdge = new LinkedHashSet;
  this.portsWithPortSide = new LinkedHashSet;
  this.owner = node;
}

defineClass(156, 1, {156:1}, ConnectedSelfLoopComponent);
_.toString_0 = function toString_105(){
  var port, port$iterator, retVal, text_0;
  retVal = new StringBuilder;
  !!this.loopSide && $append_11($append_11(retVal, $toString_2(this.loopSide)), ': ');
  for (port$iterator = $listIterator_1($getHidablePorts(this), 0); port$iterator.currentNode != port$iterator.this$01.tail;) {
    port = castTo($next_13(port$iterator), 11);
    $append_11($append_11($append_5($append_11(retVal, (text_0 = $getName_1(port) , text_0 == null?'p_' + port.id_0:'p_' + text_0)), 32), $toString_2(port.side)), ' / ');
  }
  return $substring(retVal, retVal.string.length - 2 - 1);
}
;
_.textHeight = 0;
_.textWidth = 0;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_ConnectedSelfLoopComponent_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'ConnectedSelfLoopComponent', 156);
function $clinit_LoopSide(){
  $clinit_LoopSide = emptyMethod;
  N = new LoopSide('N', 0, ($clinit_PortSide() , NORTH_1), NORTH_1, 0);
  EN = new LoopSide('EN', 1, EAST_1, NORTH_1, 1);
  E_0 = new LoopSide('E', 2, EAST_1, EAST_1, 0);
  SE = new LoopSide('SE', 3, SOUTH_1, EAST_1, 1);
  S = new LoopSide('S', 4, SOUTH_1, SOUTH_1, 0);
  WS = new LoopSide('WS', 5, WEST_1, SOUTH_1, 1);
  W = new LoopSide('W', 6, WEST_1, WEST_1, 0);
  NW = new LoopSide('NW', 7, NORTH_1, WEST_1, 1);
  ENW = new LoopSide('ENW', 8, EAST_1, WEST_1, 2);
  ESW = new LoopSide('ESW', 9, EAST_1, WEST_1, 2);
  SEN = new LoopSide('SEN', 10, SOUTH_1, NORTH_1, 2);
  SWN = new LoopSide('SWN', 11, SOUTH_1, NORTH_1, 2);
  UNDEFINED_1 = new LoopSide('UNDEFINED', 12, UNDEFINED_7, UNDEFINED_7, 3);
  ALL = of(N, EN, E_0, SE, S, WS, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p5edges_splines_LoopSide_2_classLit, 1), $intern_38, 132, 0, [W, NW, ENW, ESW, SEN, SWN]));
  ALL_STRAIGHTS = ($clinit_ImmutableCollection() , create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [N, E_0, S, W])));
  ALL_CORNERS = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [EN, SE, WS, NW]));
  SIDES_N = new SingletonImmutableSet(NORTH_1);
  SIDES_EN = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [EAST_1, NORTH_1]));
  SIDES_E = new SingletonImmutableSet(EAST_1);
  SIDES_SE = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [SOUTH_1, EAST_1]));
  SIDES_S = new SingletonImmutableSet(SOUTH_1);
  SIDES_WS = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [WEST_1, SOUTH_1]));
  SIDES_W = new SingletonImmutableSet(WEST_1);
  SIDES_NW = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [NORTH_1, WEST_1]));
  SIDES_ENW = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [EAST_1, NORTH_1, WEST_1]));
  SIDES_ESW = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [EAST_1, SOUTH_1, WEST_1]));
  SIDES_SWN = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [SOUTH_1, WEST_1, NORTH_1]));
  SIDES_SEN = create(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [SOUTH_1, EAST_1, NORTH_1]));
  SIDES_UNDEF = ($clinit_RegularImmutableSet() , EMPTY_0);
}

function $getMiddleSide(this$static){
  switch (this$static.ordinal) {
    case 8:
      return $clinit_PortSide() , NORTH_1;
    case 9:
      return $clinit_PortSide() , SOUTH_1;
    case 10:
      return $clinit_PortSide() , EAST_1;
    case 11:
      return $clinit_PortSide() , WEST_1;
    default:return $clinit_PortSide() , UNDEFINED_7;
  }
}

function $getPortSides(this$static){
  switch (this$static.ordinal) {
    case 0:
      return SIDES_N;
    case 1:
      return SIDES_EN;
    case 2:
      return SIDES_E;
    case 3:
      return SIDES_SE;
    case 4:
      return SIDES_S;
    case 5:
      return SIDES_WS;
    case 6:
      return SIDES_W;
    case 7:
      return SIDES_NW;
    case 8:
      return SIDES_ENW;
    case 9:
      return SIDES_ESW;
    case 11:
      return SIDES_SWN;
    case 10:
      return SIDES_SEN;
    default:return SIDES_UNDEF;
  }
}

function $left(this$static){
  switch (this$static.ordinal) {
    case 0:
      return NW;
    case 1:
      return N;
    case 2:
      return EN;
    case 3:
      return E_0;
    case 4:
      return SE;
    case 5:
      return S;
    case 6:
      return WS;
    case 7:
      return W;
    case 8:
      return ESW;
    case 9:
      return ENW;
    case 10:
      return SWN;
    case 11:
      return SEN;
    default:return UNDEFINED_1;
  }
}

function $opposite(this$static){
  switch (this$static.ordinal) {
    case 0:
      return S;
    case 1:
      return WS;
    case 2:
      return W;
    case 3:
      return NW;
    case 4:
      return N;
    case 5:
      return EN;
    case 6:
      return E_0;
    case 7:
      return SE;
    case 8:
      return ESW;
    case 9:
      return ENW;
    case 10:
      return SWN;
    case 11:
      return SEN;
    default:return UNDEFINED_1;
  }
}

function $right(this$static){
  switch (this$static.ordinal) {
    case 0:
      return EN;
    case 1:
      return E_0;
    case 2:
      return SE;
    case 3:
      return S;
    case 4:
      return WS;
    case 5:
      return W;
    case 6:
      return NW;
    case 7:
      return N;
    case 8:
      return ESW;
    case 9:
      return ENW;
    case 10:
      return SWN;
    case 11:
      return SEN;
    default:return UNDEFINED_1;
  }
}

function $viaNW(this$static){
  if (this$static == NW || this$static == ENW) {
    return true;
  }
  return false;
}

function LoopSide(enum$name, enum$ordinal, source, target, type_0){
  Enum.call(this, enum$name, enum$ordinal);
  this.source = source;
  this.target = target;
  this.type_0 = type_0;
}

function fromPortSide(side0, side1){
  $clinit_LoopSide();
  if (side0 == side1) {
    return fromPortSides(side0);
  }
  switch (side0.ordinal) {
    case 1:
      switch (side1.ordinal) {
        case 4:
          return NW;
        case 1:
          return N;
        case 2:
          return EN;
        case 3:
          return SEN;
      }

    case 2:
      switch (side1.ordinal) {
        case 1:
          return EN;
        case 2:
          return E_0;
        case 3:
          return SE;
        case 4:
          return ENW;
      }

    case 3:
      switch (side1.ordinal) {
        case 2:
          return SE;
        case 3:
          return S;
        case 4:
          return WS;
        case 1:
          return SEN;
      }

    case 4:
      switch (side1.ordinal) {
        case 3:
          return WS;
        case 4:
          return W;
        case 1:
          return NW;
        case 2:
          return ENW;
      }

  }
  return UNDEFINED_1;
}

function fromPortSides(side){
  $clinit_LoopSide();
  switch (side.ordinal) {
    case 1:
      return N;
    case 2:
      return E_0;
    case 3:
      return S;
    case 4:
      return W;
    default:return UNDEFINED_1;
  }
}

function valueOf_64(name_0){
  $clinit_LoopSide();
  return valueOf(($clinit_LoopSide$Map() , $MAP_52), name_0);
}

function values_60(){
  $clinit_LoopSide();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p5edges_splines_LoopSide_2_classLit, 1), $intern_38, 132, 0, [N, EN, E_0, SE, S, WS, W, NW, ENW, ESW, SEN, SWN, UNDEFINED_1]);
}

defineClass(132, 22, {3:1, 34:1, 22:1, 132:1}, LoopSide);
_.type_0 = 0;
var ALL, ALL_CORNERS, ALL_STRAIGHTS, E_0, EN, ENW, ESW, N, NW, S, SE, SEN, SIDES_E, SIDES_EN, SIDES_ENW, SIDES_ESW, SIDES_N, SIDES_NW, SIDES_S, SIDES_SE, SIDES_SEN, SIDES_SWN, SIDES_UNDEF, SIDES_W, SIDES_WS, SWN, UNDEFINED_1, W, WS;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_LoopSide_2_classLit = createForEnum('org.eclipse.elk.alg.layered.p5edges.splines', 'LoopSide', 132, Ljava_lang_Enum_2_classLit, values_60, valueOf_64);
function $clinit_LoopSide$Map(){
  $clinit_LoopSide$Map = emptyMethod;
  $MAP_52 = createValueOfMap(values_60());
}

var $MAP_52;
function $$init_6(this$static){
  this$static.knotVector = new ArrayList;
  this$static.controlPoints = new ArrayList;
}

function $createUniformKnotVector(this$static, size_0){
  var i, i0, i1, mySize;
  if (size_0 < 2 * this$static.dimNUBS) {
    throw toJs(new IllegalArgumentException_0('The knot vector must have at least two time the dimension elements.'));
  }
  this$static.minKnot = 0;
  this$static.maxKnot = 1;
  for (i0 = 0; i0 < this$static.dimNUBS; i0++) {
    this$static.knotVector.add_1(0);
  }
  mySize = size_0 + 1 - 2 * this$static.dimNUBS;
  for (i1 = 1; i1 < mySize; i1++) {
    this$static.knotVector.add_1(i1 / mySize);
  }
  if (this$static.isClamped) {
    for (i = 0; i < this$static.dimNUBS; i++) {
      this$static.knotVector.add_1(1);
    }
  }
}

function $getBezierCP(this$static){
  var iter, retVal;
  this$static.isBezier || $toBezier(this$static);
  retVal = new KVectorChain;
  iter = this$static.controlPoints.iterator_0();
  iter.next_1();
  while (iter.hasNext_0()) {
    $add_7(retVal, castTo(iter.next_1(), 194).cp);
  }
  checkCriticalElement(retVal.size_0 != 0);
  $removeNode_0(retVal, retVal.tail.prev);
  return retVal;
}

function $getControlPoint(this$static, i){
  return castTo(this$static.controlPoints.get_3(i), 194).cp;
}

function $getControlPoints(this$static){
  var polarCP, polarCP$iterator, retVal;
  retVal = new KVectorChain;
  for (polarCP$iterator = this$static.controlPoints.iterator_0(); polarCP$iterator.hasNext_0();) {
    polarCP = castTo(polarCP$iterator.next_1(), 194);
    $add_7(retVal, polarCP.cp);
  }
  return retVal;
}

function $getIndexInKnotVector(this$static, knot){
  var currentKnot, diff, iter;
  iter = this$static.knotVector.listIterator_0();
  while (iter.hasNext_0()) {
    currentKnot = checkNotNull_1(castToDouble(iter.next_1()));
    diff = $wnd.Math.abs(currentKnot - knot);
    if (diff < $intern_122) {
      return iter.nextIndex_0() - 1;
    }
  }
  return this$static.knotVector.size_1();
}

function $getMultiplicity(this$static, knotToCheck){
  var count, currentKnot, diff, iter;
  iter = this$static.knotVector.listIterator_0();
  count = 0;
  while (iter.hasNext_0()) {
    currentKnot = checkNotNull_1(castToDouble(iter.next_1()));
    diff = currentKnot - knotToCheck;
    if (diff > $intern_122) {
      return count;
    }
     else 
      diff > $intern_123 && ++count;
  }
  return count;
}

function $getPointOnCurve(this$static, t, modify){
  var copy, multiplicity;
  multiplicity = $getMultiplicity(this$static, t);
  if (multiplicity == this$static.dimNUBS) {
    return $getControlPoint(this$static, $getIndexInKnotVector(this$static, t));
  }
  if (modify) {
    $insertKnot(this$static, t, this$static.dimNUBS - multiplicity);
    return $getControlPoint(this$static, $getIndexInKnotVector(this$static, t));
  }
   else {
    copy = new NubSpline(this$static);
    $insertKnot(copy, t, this$static.dimNUBS - multiplicity);
    return $getControlPoint(copy, $getIndexInKnotVector(copy, t));
  }
}

function $insertKnot(this$static, knotToInsert, insertions){
  var currentKnot, i, iterCP, iterKnot;
  iterKnot = this$static.knotVector.listIterator_0();
  if (this$static.isClamped) {
    for (i = 0; i < this$static.dimNUBS; i++) {
      iterKnot.next_1();
    }
  }
   else {
    for (i = 0; i < this$static.dimNUBS - 1; i++) {
      iterKnot.next_1();
    }
  }
  iterCP = this$static.controlPoints.listIterator_0();
  currentKnot = checkNotNull_1(castToDouble(iterKnot.next_1()));
  while (currentKnot - knotToInsert < $intern_122) {
    currentKnot = checkNotNull_1(castToDouble(iterKnot.next_1()));
    iterCP.next_1();
  }
  iterKnot.previous_0();
  $insertKnotAtCurrentPosition(this$static, insertions, knotToInsert, iterCP, iterKnot);
}

function $insertKnotAtCurrentPosition(this$static, insertions, knotToInsert, iterCP, iterKnot){
  var cp, cp$iterator, firstCP, i, j, j0, j1, multiplicity, newCPs, secondCP;
  multiplicity = $getMultiplicity(this$static, knotToInsert);
  for (i = 0; i < insertions; i++) {
    iterKnot.add_2(knotToInsert);
    newCPs = new ArrayList;
    secondCP = castTo(iterCP.next_1(), 194);
    for (j0 = multiplicity + i; j0 < this$static.dimNUBS; j0++) {
      firstCP = secondCP;
      secondCP = castTo(iterCP.next_1(), 194);
      $add_4(newCPs, new NubSpline$PolarCP(firstCP, secondCP, knotToInsert));
    }
    for (j1 = multiplicity + i; j1 < this$static.dimNUBS; j1++) {
      iterCP.previous_0();
      j1 > multiplicity + i && iterCP.remove_0();
    }
    for (cp$iterator = new ArrayList$1(newCPs); cp$iterator.i < cp$iterator.this$01.array.length;) {
      cp = castTo($next_10(cp$iterator), 194);
      iterCP.add_2(cp);
    }
    if (i < insertions - 1) {
      for (j = multiplicity + i; j < this$static.dimNUBS; j++) {
        iterCP.previous_0();
      }
    }
  }
}

function $setOuterBox(this$static, outerRectange){
  this$static.outerBox = outerRectange;
}

function $toBezier(this$static){
  var currentKnot, i, iterCP, iterKnot, knotToCount, occurrence;
  iterKnot = this$static.knotVector.listIterator_0();
  iterCP = this$static.controlPoints.listIterator_0();
  if (this$static.isClamped) {
    for (i = 0; i < this$static.dimNUBS; i++) {
      iterKnot.next_1();
    }
  }
   else {
    for (i = 0; i < this$static.dimNUBS - 1; i++) {
      iterKnot.next_1();
      iterKnot.remove_0();
    }
  }
  currentKnot = checkNotNull_1(castToDouble(iterKnot.next_1()));
  while (this$static.maxKnot - currentKnot > $intern_122) {
    knotToCount = currentKnot;
    occurrence = 0;
    while ($wnd.Math.abs(currentKnot - knotToCount) < $intern_122) {
      ++occurrence;
      currentKnot = checkNotNull_1(castToDouble(iterKnot.next_1()));
      iterCP.next_1();
    }
    if (occurrence < this$static.dimNUBS) {
      iterKnot.previous_0();
      $insertKnotAtCurrentPosition(this$static, this$static.dimNUBS - occurrence, knotToCount, iterCP, iterKnot);
      iterKnot.next_1();
    }
    iterCP.previous_0();
  }
  if (!this$static.isClamped) {
    for (i = 0; i < this$static.dimNUBS - 1; i++) {
      iterKnot.next_1();
      iterKnot.remove_0();
    }
  }
  this$static.isClamped = true;
  this$static.isBezier = true;
}

function NubSpline(nubSpline){
  $$init_6(this);
  this.dimNUBS = nubSpline.dimNUBS;
  this.isUniform = nubSpline.isUniform;
  this.isClamped = nubSpline.isClamped;
  this.outerBox = nubSpline.outerBox;
  this.isBezier = nubSpline.isBezier;
  this.knotVector = newLinkedList(nubSpline.knotVector);
  this.minKnot = nubSpline.minKnot;
  this.maxKnot = nubSpline.maxKnot;
  this.controlPoints = newLinkedList(nubSpline.controlPoints);
}

function NubSpline_0(kVectors){
  var i, i0, kVector, kVector$iterator, knotIter, polarCoordinate;
  $$init_6(this);
  for (i0 = kVectors.size_1() - 1; i0 < 3; i0++) {
    kVectors.add_3(0, castTo(kVectors.get_3(0), 8));
  }
  if (kVectors.size_1() < 4) {
    throw toJs(new IllegalArgumentException_0('At (least dimension + 1) control points are necessary!'));
  }
   else {
    this.dimNUBS = 3;
    this.isClamped = true;
    this.isUniform = true;
    this.isBezier = false;
    $createUniformKnotVector(this, kVectors.size_1() + this.dimNUBS - 1);
    polarCoordinate = new ArrayList;
    knotIter = this.knotVector.iterator_0();
    for (i = 0; i < this.dimNUBS - 1; i++) {
      $add_4(polarCoordinate, castToDouble(knotIter.next_1()));
    }
    for (kVector$iterator = kVectors.iterator_0(); kVector$iterator.hasNext_0();) {
      kVector = castTo(kVector$iterator.next_1(), 8);
      $add_4(polarCoordinate, castToDouble(knotIter.next_1()));
      this.controlPoints.add_1(new NubSpline$PolarCP_0(kVector, polarCoordinate));
      checkCriticalElementIndex(0, polarCoordinate.array.length);
      polarCoordinate.array.splice(0, 1);
    }
  }
}

function NubSpline_1(clamped, uniform, bezier, dim, knotVec, polarVectors){
  $$init_6(this);
  this.isClamped = clamped;
  this.isUniform = uniform;
  this.isBezier = bezier;
  this.dimNUBS = dim;
  this.knotVector = knotVec;
  this.controlPoints = polarVectors;
  this.minKnot = checkNotNull_1(castToDouble(knotVec.iterator_0().next_1()));
  this.maxKnot = checkNotNull_1(castToDouble(getLast(knotVec)));
}

function generateDerivedNUBS(nubSpline){
  var i, i0, kVector, kVector$iterator, knotIter, newBezier, newCP, newClamped, newControlPoints, newDim, newKnotVector, newPolarVectors, newUniform, oldDim, oldKnotVector, polarCoordinate;
  newClamped = nubSpline.isClamped;
  newUniform = nubSpline.isUniform;
  newBezier = nubSpline.isBezier;
  oldDim = nubSpline.dimNUBS;
  newDim = oldDim - 1;
  oldKnotVector = nubSpline.knotVector;
  newKnotVector = newLinkedList(nubSpline.knotVector.subList(1, nubSpline.knotVector.size_1() - 1));
  newControlPoints = new ArrayList;
  for (i0 = 0; i0 < nubSpline.controlPoints.size_1() - 1; i0++) {
    newCP = $scale($sub_0($clone_0(castTo(nubSpline.controlPoints.get_3(i0 + 1), 194).cp), castTo(nubSpline.controlPoints.get_3(i0), 194).cp), oldDim / (checkNotNull_1(castToDouble(oldKnotVector.get_3(i0 + oldDim))) - checkNotNull_1(castToDouble(oldKnotVector.get_3(i0)))));
    newControlPoints.array[newControlPoints.array.length] = newCP;
  }
  polarCoordinate = new ArrayList;
  knotIter = $listIterator_1(newKnotVector, 0);
  newPolarVectors = new ArrayList;
  for (i = 0; i < newDim - 1; i++) {
    $add_4(polarCoordinate, castToDouble($next_13(knotIter)));
  }
  for (kVector$iterator = new ArrayList$1(newControlPoints); kVector$iterator.i < kVector$iterator.this$01.array.length;) {
    kVector = castTo($next_10(kVector$iterator), 8);
    $add_4(polarCoordinate, castToDouble($next_13(knotIter)));
    $add_4(newPolarVectors, new NubSpline$PolarCP_0(kVector, polarCoordinate));
    checkCriticalElementIndex(0, polarCoordinate.array.length);
    polarCoordinate.array.splice(0, 1);
  }
  return new NubSpline_1(newClamped, newUniform, newBezier, newDim, newKnotVector, newPolarVectors);
}

function generateInvertedNUBS(nubSpline){
  var i, kVector, kVector$iterator, knotIter, maxVector, newControlPoints, newKnotVector, newPolarVectors, polarCoordinate, vector, vector$iterator;
  newKnotVector = new ArrayList;
  maxVector = checkNotNull_1(castToDouble(nubSpline.knotVector.get_3(nubSpline.knotVector.size_1() - 1)));
  for (vector$iterator = nubSpline.knotVector.iterator_0(); vector$iterator.hasNext_0();) {
    vector = castToDouble(vector$iterator.next_1());
    $add_3(newKnotVector, 0, maxVector - (checkCriticalNotNull(vector) , vector));
  }
  newControlPoints = reverse_3($getControlPoints(nubSpline));
  polarCoordinate = new ArrayList;
  knotIter = new ArrayList$1(newKnotVector);
  newPolarVectors = new ArrayList;
  for (i = 0; i < nubSpline.dimNUBS - 1; i++) {
    $add_4(polarCoordinate, castToDouble($next_10(knotIter)));
  }
  for (kVector$iterator = $listIterator_1(newControlPoints, 0); kVector$iterator.currentNode != kVector$iterator.this$01.tail;) {
    kVector = castTo($next_13(kVector$iterator), 8);
    $add_4(polarCoordinate, castToDouble($next_10(knotIter)));
    $add_4(newPolarVectors, new NubSpline$PolarCP_0(kVector, polarCoordinate));
    checkCriticalElementIndex(0, polarCoordinate.array.length);
    polarCoordinate.array.splice(0, 1);
  }
  return new NubSpline_1(nubSpline.isClamped, nubSpline.isUniform, nubSpline.isBezier, nubSpline.dimNUBS, newKnotVector, newPolarVectors);
}

function getFirstHorizontalPoint(nubSpline){
  var currentAccuracy, currentVector, firstDerive, knot, loopCount;
  firstDerive = generateDerivedNUBS(nubSpline);
  currentAccuracy = $intern_62;
  loopCount = 0;
  knot = 0;
  while (currentAccuracy > 0.5 && loopCount < 50) {
    knot = getZeroYOfControlPoligon(firstDerive);
    currentVector = $getPointOnCurve(firstDerive, knot, true);
    currentAccuracy = $wnd.Math.abs(currentVector.y_0);
    ++loopCount;
  }
  return $getPointOnCurve(nubSpline, knot, false);
}

function getFirstVerticalPoint(nubSpline){
  var currentAccuracy, currentVector, firstDerive, knot, loopCount;
  firstDerive = generateDerivedNUBS(nubSpline);
  currentAccuracy = $intern_62;
  loopCount = 0;
  knot = 0;
  while (currentAccuracy > 0.5 && loopCount < 50) {
    knot = getZeroXOfControlPoligon(firstDerive);
    currentVector = $getPointOnCurve(firstDerive, knot, true);
    currentAccuracy = $wnd.Math.abs(currentVector.x_0);
    ++loopCount;
  }
  return $getPointOnCurve(nubSpline, knot, false);
}

function getLastHorizontalPoint(nubSpline){
  var currentAccuracy, currentVector, firstDerive, knot, loopCount, maxVal;
  firstDerive = generateInvertedNUBS(generateDerivedNUBS(nubSpline));
  currentAccuracy = $intern_62;
  loopCount = 0;
  knot = 0;
  while (currentAccuracy > 0.5 && loopCount < 50) {
    knot = getZeroYOfControlPoligon(firstDerive);
    currentVector = $getPointOnCurve(firstDerive, knot, true);
    currentAccuracy = $wnd.Math.abs(currentVector.y_0);
    ++loopCount;
  }
  maxVal = castToDouble($get_3(newLinkedList(nubSpline.knotVector), newLinkedList(nubSpline.knotVector).size_0 - 1));
  return $getPointOnCurve(nubSpline, (checkCriticalNotNull(maxVal) , maxVal) - knot, false);
}

function getLastVerticalPoint(nubSpline){
  var currentAccuracy, currentVector, firstDerive, knot, loopCount, maxVal;
  firstDerive = generateInvertedNUBS(generateDerivedNUBS(nubSpline));
  currentAccuracy = $intern_62;
  loopCount = 0;
  knot = 0;
  while (currentAccuracy > 0.5 && loopCount < 50) {
    knot = getZeroXOfControlPoligon(firstDerive);
    currentVector = $getPointOnCurve(firstDerive, knot, true);
    currentAccuracy = $wnd.Math.abs(currentVector.x_0);
    ++loopCount;
  }
  maxVal = castToDouble($get_3(newLinkedList(nubSpline.knotVector), newLinkedList(nubSpline.knotVector).size_0 - 1));
  return $getPointOnCurve(nubSpline, (checkCriticalNotNull(maxVal) , maxVal) - knot, false);
}

function getTFromPolar(polar){
  var sum, val, val$iterator;
  sum = 0;
  for (val$iterator = polar.iterator_0(); val$iterator.hasNext_0();) {
    val = castToDouble(val$iterator.next_1());
    sum += (checkCriticalNotNull(val) , val);
  }
  return sum / polar.size_1();
}

function getZeroXOfControlPoligon(nubSpline){
  var factor, firstCP, firstIsNegative, firstIsPositive, firstX, iter, secondCP, secondIsNegative, secondIsPositive, secondX, t1, t2;
  iter = nubSpline.controlPoints.iterator_0();
  secondCP = castTo(iter.next_1(), 194);
  secondX = secondCP.cp.x_0;
  secondIsPositive = secondX > $intern_122;
  secondIsNegative = secondX < $intern_123;
  while (iter.hasNext_0()) {
    firstCP = secondCP;
    firstX = secondX;
    firstIsPositive = secondIsPositive;
    firstIsNegative = secondIsNegative;
    secondCP = castTo(iter.next_1(), 194);
    secondX = secondCP.cp.x_0;
    secondIsPositive = secondX > $intern_122;
    secondIsNegative = secondX < $intern_123;
    if (!(secondIsPositive || secondIsNegative)) {
      return getTFromPolar(secondCP.polarCoordinate);
    }
    if (firstIsPositive && secondIsNegative || firstIsNegative && secondIsPositive) {
      factor = firstX / (firstX - secondX);
      t1 = getTFromPolar(firstCP.polarCoordinate);
      t2 = getTFromPolar(secondCP.polarCoordinate);
      return factor * t1 + (1 - factor) * t2;
    }
  }
  return 0;
}

function getZeroYOfControlPoligon(nubSpline){
  var factor, firstCP, firstIsNegative, firstIsPositive, firstY, iter, secondCP, secondIsNegative, secondIsPositive, secondY, t1, t2;
  iter = nubSpline.controlPoints.iterator_0();
  secondCP = castTo(iter.next_1(), 194);
  secondY = secondCP.cp.y_0;
  secondIsPositive = secondY > $intern_122;
  secondIsNegative = secondY < $intern_123;
  while (iter.hasNext_0()) {
    firstCP = secondCP;
    firstY = secondY;
    firstIsPositive = secondIsPositive;
    firstIsNegative = secondIsNegative;
    secondCP = castTo(iter.next_1(), 194);
    secondY = secondCP.cp.y_0;
    secondIsPositive = secondY > $intern_122;
    secondIsNegative = secondY < $intern_123;
    if (!(secondIsPositive || secondIsNegative)) {
      return getTFromPolar(secondCP.polarCoordinate);
    }
    if (firstIsPositive && secondIsNegative || firstIsNegative && secondIsPositive) {
      factor = firstY / (firstY - secondY);
      t1 = getTFromPolar(firstCP.polarCoordinate);
      t2 = getTFromPolar(secondCP.polarCoordinate);
      return factor * t1 + (1 - factor) * t2;
    }
  }
  return 0;
}

defineClass(440, 1, {}, NubSpline, NubSpline_0, NubSpline_1);
_.toString_0 = function toString_106(){
  return this.controlPoints.toString_0();
}
;
_.dimNUBS = 0;
_.isBezier = false;
_.isClamped = false;
_.isUniform = false;
_.maxKnot = 0;
_.minKnot = 0;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_NubSpline_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'NubSpline', 440);
function $setCp(this$static, cp){
  this$static.cp = cp;
}

function $setPolarCoordinate(this$static, polarCoordinate){
  this$static.polarCoordinate = polarCoordinate;
}

function NubSpline$PolarCP(firstCP, secondCP, newKnot){
  var aScaled, bScaled, firstFactor, iter, needsToBeAdded, nextKnot, secondFactor, total;
  firstFactor = checkNotNull_1(castToDouble(firstCP.polarCoordinate.iterator_0().next_1()));
  secondFactor = checkNotNull_1(castToDouble(getLast(secondCP.polarCoordinate)));
  aScaled = $scale($clone_0(firstCP.cp), secondFactor - newKnot);
  bScaled = $scale($clone_0(secondCP.cp), newKnot - firstFactor);
  total = $add_19(aScaled, bScaled);
  $scale(total, 1 / (secondFactor - firstFactor));
  this.cp = total;
  this.polarCoordinate = new ArrayList;
  needsToBeAdded = true;
  iter = firstCP.polarCoordinate.iterator_0();
  iter.next_1();
  while (iter.hasNext_0()) {
    nextKnot = checkNotNull_1(castToDouble(iter.next_1()));
    if (needsToBeAdded && nextKnot - newKnot > $intern_122) {
      this.polarCoordinate.add_1(newKnot);
      needsToBeAdded = false;
    }
    this.polarCoordinate.add_1(nextKnot);
  }
  needsToBeAdded && this.polarCoordinate.add_1(newKnot);
}

function NubSpline$PolarCP_0(controlPoint, polarCoordinate){
  $setCp(this, new KVector_1(controlPoint.x_0, controlPoint.y_0));
  $setPolarCoordinate(this, newLinkedList(polarCoordinate));
}

defineClass(194, 1, {194:1}, NubSpline$PolarCP, NubSpline$PolarCP_0);
var Lorg_eclipse_elk_alg_layered_p5edges_splines_NubSpline$PolarCP_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'NubSpline/PolarCP', 194);
function NubsSelfLoop(kVectors){
  NubSpline_0.call(this, newArrayList_1(kVectors));
  this.firstLabelPosition = new KVector;
}

function createAcrossSelfLoop(source, sourceHeight, target, targetHeight, intermediateSide, middleHeight){
  var firstCP, fourthCP, horizontal, loopHeight, middleCP, nubs, secondCP, sourceDir, sourcePos, targetDir, targetPos, thirdCP, thirdExtremum, vertical;
  sourceDir = portSideToDirection(source.side);
  targetDir = portSideToDirection(target.side);
  sourcePos = $add_19($clone_0(source.pos), source.anchor);
  targetPos = $add_19($clone_0(target.pos), target.anchor);
  firstCP = $add_19(new KVector_2(sourcePos), $scale(new KVector_0(sourceDir), sourceHeight));
  fourthCP = $add_19(new KVector_2(targetPos), $scale(new KVector_0(targetDir), targetHeight));
  loopHeight = distPortToNodeEdge(source, intermediateSide);
  intermediateSide == ($clinit_PortSide() , SOUTH_1) || intermediateSide == EAST_1?(loopHeight += middleHeight):(loopHeight -= middleHeight);
  secondCP = new KVector;
  thirdCP = new KVector;
  switch (intermediateSide.ordinal) {
    case 1:
    case 3:
      secondCP.x_0 = firstCP.x_0;
      secondCP.y_0 = sourcePos.y_0 + loopHeight;
      thirdCP.x_0 = fourthCP.x_0;
      thirdCP.y_0 = secondCP.y_0;
      break;
    case 2:
    case 4:
      secondCP.x_0 = sourcePos.x_0 + loopHeight;
      secondCP.y_0 = firstCP.y_0;
      thirdCP.x_0 = secondCP.x_0;
      thirdCP.y_0 = fourthCP.y_0;
      break;
    default:return null;
  }
  middleCP = $scale($add_19(new KVector_1(secondCP.x_0, secondCP.y_0), thirdCP), 0.5);
  nubs = new NubsSelfLoop(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourcePos, firstCP, secondCP, middleCP, thirdCP, fourthCP, targetPos]));
  horizontal = getFirstHorizontalPoint(nubs);
  vertical = getFirstVerticalPoint(nubs);
  switch (intermediateSide.ordinal) {
    case 1:
    case 3:
      nubs.firstLabelPosition = horizontal;
      thirdExtremum = getLastVerticalPoint(nubs);
      break;
    case 2:
    case 4:
      nubs.firstLabelPosition = vertical;
      thirdExtremum = getLastHorizontalPoint(nubs);
      break;
    default:return null;
  }
  $setOuterBox(nubs, new Rectangle_3(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [horizontal, vertical, thirdExtremum, sourcePos, targetPos])));
  return nubs;
}

function createCornerSelfLoop(source, target, sourceHeight, targetHeight, textLength){
  var cornerX, cornerY, dist, firstCP, horizontal, nubs, secondCP, sourceDir, sourcePos, targetDir, targetPos, thirdCP, vertical;
  sourceDir = portSideToDirection(source.side);
  targetDir = portSideToDirection(target.side);
  sourcePos = $add_19($clone_0(source.pos), source.anchor);
  targetPos = $add_19($clone_0(target.pos), target.anchor);
  firstCP = $add_19(new KVector_1(sourcePos.x_0, sourcePos.y_0), $scale(new KVector_0(sourceDir), 1.3 * sourceHeight));
  thirdCP = $add_19(new KVector_1(targetPos.x_0, targetPos.y_0), $scale(new KVector_0(targetDir), 1.3 * targetHeight));
  dist = $wnd.Math.abs(firstCP.x_0 - thirdCP.x_0);
  dist < textLength && (source.side == ($clinit_PortSide() , WEST_1) || source.side == EAST_1?firstCP.x_0 < thirdCP.x_0?(firstCP.x_0 = thirdCP.x_0 - textLength):(firstCP.x_0 = thirdCP.x_0 + textLength):firstCP.x_0 < thirdCP.x_0?(thirdCP.x_0 = firstCP.x_0 + textLength):(thirdCP.x_0 = firstCP.x_0 - textLength));
  cornerX = 0;
  cornerY = 0;
  switch (source.side.ordinal) {
    case 4:
      cornerX = 2 * (sourcePos.x_0 - sourceHeight) - 0.5 * (firstCP.x_0 + thirdCP.x_0);
      break;
    case 2:
      cornerX = 2 * (sourcePos.x_0 + sourceHeight) - 0.5 * (firstCP.x_0 + thirdCP.x_0);
      break;
    case 1:
      cornerY = 2 * (sourcePos.y_0 - sourceHeight) - 0.5 * (firstCP.y_0 + thirdCP.y_0);
      break;
    case 3:
      cornerY = 2 * (sourcePos.y_0 + sourceHeight) - 0.5 * (firstCP.y_0 + thirdCP.y_0);
  }
  switch (target.side.ordinal) {
    case 4:
      cornerX = 2 * (targetPos.x_0 - targetHeight) - 0.5 * (thirdCP.x_0 + firstCP.x_0);
      break;
    case 2:
      cornerX = 2 * (targetPos.x_0 + targetHeight) - 0.5 * (thirdCP.x_0 + firstCP.x_0);
      break;
    case 1:
      cornerY = 2 * (targetPos.y_0 - targetHeight) - 0.5 * (thirdCP.y_0 + firstCP.y_0);
      break;
    case 3:
      cornerY = 2 * (targetPos.y_0 + targetHeight) - 0.5 * (thirdCP.y_0 + firstCP.y_0);
  }
  secondCP = new KVector_1(cornerX, cornerY);
  nubs = new NubsSelfLoop(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourcePos, firstCP, secondCP, thirdCP, targetPos]));
  horizontal = getFirstHorizontalPoint(nubs);
  vertical = getFirstVerticalPoint(nubs);
  nubs.firstLabelPosition = horizontal;
  $setOuterBox(nubs, new Rectangle_3(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [horizontal, vertical, sourcePos, targetPos])));
  return nubs;
}

function createSideSelfLoop(source, target, length_0){
  var direction, firstCP, labelPos, mid, nubs, secondCP, sourcePos, targetPos, thirdCP;
  direction = portSideToDirection(source.side);
  sourcePos = $add_19($clone_0(source.pos), source.anchor);
  targetPos = $add_19($clone_0(target.pos), target.anchor);
  firstCP = $add_19(new KVector_2(sourcePos), $scale(new KVector_0(direction), length_0));
  thirdCP = $add_19(new KVector_2(targetPos), $scale(new KVector_0(direction), length_0));
  mid = $scale($sub_0(new KVector_2(firstCP), thirdCP), 0.5);
  secondCP = $add_19($add_19(new KVector_2(thirdCP), mid), $scale(new KVector_0(direction), $wnd.Math.sqrt(mid.x_0 * mid.x_0 + mid.y_0 * mid.y_0)));
  nubs = new NubsSelfLoop(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [sourcePos, firstCP, secondCP, thirdCP, targetPos]));
  labelPos = $getPointOnCurve(nubs, 0.5, false);
  nubs.firstLabelPosition = labelPos;
  $setOuterBox(nubs, new Rectangle_3(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [labelPos, sourcePos, targetPos])));
  return nubs;
}

defineClass(620, 440, {}, NubsSelfLoop);
var Lorg_eclipse_elk_alg_layered_p5edges_splines_NubsSelfLoop_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'NubsSelfLoop', 620);
function $$init_7(this$static){
}

function $enlarge(this$static){
  this$static.top_0 = this$static.top_0 - 15;
  this$static.left = this$static.left - 15;
  this$static.right = this$static.right + 15;
  this$static.bottom = this$static.bottom + 15;
}

function $union(this$static, rectangle){
  this$static.top_0 = $wnd.Math.min(this$static.top_0, rectangle.top_0);
  this$static.right = $wnd.Math.max(this$static.right, rectangle.right);
  this$static.bottom = $wnd.Math.max(this$static.bottom, rectangle.bottom);
  this$static.left = $wnd.Math.min(this$static.left, rectangle.left);
}

function Rectangle(right, bottom){
  $$init_7(this);
  if (0 > bottom) {
    throw toJs(new IllegalArgumentException_0('Top must be smaller or equal to bottom.'));
  }
   else if (0 > right) {
    throw toJs(new IllegalArgumentException_0('Left must be smaller or equal to right.'));
  }
  this.top_0 = 0;
  this.right = right;
  this.bottom = bottom;
  this.left = 0;
}

function Rectangle_0(vectors){
  var vector, vector$iterator;
  if (isEmpty_10(vectors)) {
    throw toJs(new IllegalArgumentException_0('The list of vectors may not be empty.'));
  }
  for (vector$iterator = $listIterator_1(vectors, 0); vector$iterator.currentNode != vector$iterator.this$01.tail;) {
    vector = castTo($next_13(vector$iterator), 8);
    this.top_0 = $wnd.Math.min(this.top_0, vector.y_0);
    this.right = $wnd.Math.max(this.right, vector.x_0);
    this.bottom = $wnd.Math.max(this.bottom, vector.y_0);
    this.left = $wnd.Math.min(this.left, vector.x_0);
  }
}

function Rectangle_1(shape_0){
  var extend, position;
  $$init_7(this);
  position = shape_0.pos;
  extend = $add_19(new KVector_1(position.x_0, position.y_0), shape_0.size_0);
  this.top_0 = $wnd.Math.min(position.y_0, extend.y_0);
  this.bottom = $wnd.Math.max(position.y_0, extend.y_0);
  this.left = $wnd.Math.min(position.x_0, extend.x_0);
  this.right = $wnd.Math.max(position.x_0, extend.x_0);
}

function Rectangle_2(rectangle){
  $$init_7(this);
  this.top_0 = rectangle.top_0;
  this.right = rectangle.right;
  this.bottom = rectangle.bottom;
  this.left = rectangle.left;
}

function Rectangle_3(vectors){
  var vector, vector$index, vector$max;
  $$init_7(this);
  if (vectors.length == 0) {
    throw toJs(new IllegalArgumentException_0('The list of vectors may not be empty.'));
  }
  for (vector$index = 0 , vector$max = vectors.length; vector$index < vector$max; ++vector$index) {
    vector = vectors[vector$index];
    this.top_0 = $wnd.Math.min(this.top_0, vector.y_0);
    this.right = $wnd.Math.max(this.right, vector.x_0);
    this.bottom = $wnd.Math.max(this.bottom, vector.y_0);
    this.left = $wnd.Math.min(this.left, vector.x_0);
  }
}

function union(rectangle1, rectangle2){
  var retVal;
  retVal = new Rectangle_2(rectangle1);
  $union(retVal, rectangle2);
  return retVal;
}

defineClass(247, 1, {}, Rectangle, Rectangle_0, Rectangle_1, Rectangle_2, Rectangle_3);
_.bottom = $intern_124;
_.left = $intern_98;
_.right = $intern_124;
_.top_0 = $intern_98;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_Rectangle_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'Rectangle', 247);
function $clinit_SplineEdgeRouter(){
  $clinit_SplineEdgeRouter = emptyMethod;
  BASELINE_PROCESSING_ADDITIONS = $addAfter(new LayoutProcessorConfiguration, ($clinit_LayeredPhases() , P5_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy() , FINAL_SPLINE_BENDPOINTS_CALCULATOR));
  SELF_LOOP_PROCESSING_ADDITIONS_0 = $add_17($add_17($before($addBefore(new LayoutProcessorConfiguration, P1_CYCLE_BREAKING, SPLINE_SELF_LOOP_PREPROCESSOR), P4_NODE_PLACEMENT), SPLINE_SELF_LOOP_POSITIONER), SPLINE_SELF_LOOP_ROUTER);
  CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_1 = $addAfter($addBefore($addBefore($addBefore(new LayoutProcessorConfiguration, P2_LAYERING, LABEL_DUMMY_INSERTER), P4_NODE_PLACEMENT, LABEL_DUMMY_SWITCHER), P4_NODE_PLACEMENT, LABEL_SIDE_SELECTOR), P5_EDGE_ROUTING, LABEL_DUMMY_REMOVER);
  INVERTED_PORT_PROCESSING_ADDITIONS_1 = $addBefore(new LayoutProcessorConfiguration, P3_NODE_ORDERING, INVERTED_PORT_PROCESSOR);
  NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_1 = $addBefore($addBefore(new LayoutProcessorConfiguration, P3_NODE_ORDERING, NORTH_SOUTH_PORT_PREPROCESSOR), P5_EDGE_ROUTING, NORTH_SOUTH_PORT_POSTPROCESSOR);
  END_EDGE_LABEL_PROCESSING_ADDITIONS_1 = $addAfter($addBefore($addBefore(new LayoutProcessorConfiguration, P4_NODE_PLACEMENT, LABEL_SIDE_SELECTOR), P4_NODE_PLACEMENT, END_LABEL_PREPROCESSOR), P5_EDGE_ROUTING, END_LABEL_POSTPROCESSOR);
}

function $clearThenFillMappings(this$static, leftLayer, rightLayer){
  var edge, edge$iterator, node, node$iterator, nt, port, port$iterator, sourcePort, sourcePort$iterator, targetLayer, targetPort;
  this$static.leftPortsLayer.map_0.clear_0();
  this$static.rightPortsLayer.map_0.clear_0();
  this$static.edgesRemainingLayer.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.splineSegmentsLayer.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.selfLoopsLayer.map_0.clear_0();
  if (leftLayer) {
    for (node$iterator = new ArrayList$1(leftLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      for (sourcePort$iterator = $getPorts_1(node, ($clinit_PortSide() , EAST_1)).iterator_0(); sourcePort$iterator.hasNext_0();) {
        sourcePort = castTo(sourcePort$iterator.next_1(), 11);
        $add_6(this$static.leftPortsLayer, sourcePort);
        for (edge$iterator = new ArrayList$1(sourcePort.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator), 16);
          if ($isSelfLoop(edge)) {
            continue;
          }
          $add_4(this$static.edgesRemainingLayer, edge);
          $findAndAddSuccessor(this$static, edge);
          nt = edge.source.owner.type_0;
          (nt == ($clinit_LNode$NodeType() , NORMAL) || nt == NORTH_SOUTH_PORT || nt == EXTERNAL_PORT || nt == BIG_NODE || nt == BREAKING_POINT) && $add_4(this$static.startEdges, edge);
          targetPort = edge.target;
          targetLayer = targetPort.owner.layer;
          targetLayer == rightLayer?$add_6(this$static.rightPortsLayer, targetPort):targetLayer == leftLayer?$add_6(this$static.leftPortsLayer, targetPort):$remove_13(this$static.edgesRemainingLayer, edge);
        }
      }
    }
  }
  if (rightLayer) {
    for (node$iterator = new ArrayList$1(rightLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
      node = castTo($next_10(node$iterator), 9);
      for (port$iterator = new ArrayList$1(node.ports); port$iterator.i < port$iterator.this$01.array.length;) {
        port = castTo($next_10(port$iterator), 11);
        for (edge$iterator = new ArrayList$1(port.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator), 16);
          $isSelfLoop(edge) && $add_6(this$static.selfLoopsLayer, edge);
        }
      }
      for (sourcePort$iterator = $getPorts_1(node, ($clinit_PortSide() , WEST_1)).iterator_0(); sourcePort$iterator.hasNext_0();) {
        sourcePort = castTo(sourcePort$iterator.next_1(), 11);
        $add_6(this$static.rightPortsLayer, sourcePort);
        for (edge$iterator = new ArrayList$1(sourcePort.outgoingEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
          edge = castTo($next_10(edge$iterator), 16);
          if ($isSelfLoop(edge)) {
            continue;
          }
          $add_4(this$static.edgesRemainingLayer, edge);
          $findAndAddSuccessor(this$static, edge);
          nt = edge.source.owner.type_0;
          (nt == ($clinit_LNode$NodeType() , NORMAL) || nt == NORTH_SOUTH_PORT || nt == EXTERNAL_PORT || nt == BIG_NODE || nt == BREAKING_POINT) && $add_4(this$static.startEdges, edge);
          targetPort = edge.target;
          targetLayer = targetPort.owner.layer;
          targetLayer == rightLayer?$add_6(this$static.rightPortsLayer, targetPort):targetLayer == leftLayer?$add_6(this$static.leftPortsLayer, targetPort):$remove_13(this$static.edgesRemainingLayer, edge);
        }
      }
    }
  }
}

function $computeSloppySpacing(rightLayer, edgeEdgeSpacing, nodeNodeSpacing, sloppyLayerSpacingFactor){
  var incomingEdge, incomingEdge$iterator, layerSpacing, maxCurrInputYDiff, maxVertDiff, node, node$iterator, sourcePos, targetPos;
  maxVertDiff = 0;
  for (node$iterator = new ArrayList$1(rightLayer.nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 9);
    maxCurrInputYDiff = 0;
    for (incomingEdge$iterator = $iterator($getIncomingEdges(node)); $hasNext_0(incomingEdge$iterator);) {
      incomingEdge = castTo($next_2(incomingEdge$iterator), 16);
      sourcePos = $getAbsoluteAnchor(incomingEdge.source).y_0;
      targetPos = $getAbsoluteAnchor(incomingEdge.target).y_0;
      maxCurrInputYDiff = $wnd.Math.max(maxCurrInputYDiff, $wnd.Math.abs(targetPos - sourcePos));
    }
    maxVertDiff = $wnd.Math.max(maxVertDiff, maxCurrInputYDiff);
  }
  layerSpacing = sloppyLayerSpacingFactor * $wnd.Math.min(1, edgeEdgeSpacing / nodeNodeSpacing) * maxVertDiff;
  return layerSpacing;
}

function $createDependency(edge0, edge1){
  var edge0Counter, edge1Counter, port, port$iterator, port$iterator0, port$iterator1, port$iterator2;
  if (edge0.hyperEdgeTopYPos > edge1.hyperEdgeBottomYPos || edge1.hyperEdgeTopYPos > edge0.hyperEdgeBottomYPos) {
    return;
  }
  edge0Counter = 0;
  edge1Counter = 0;
  for (port$iterator0 = edge0.rightPorts.map_0.keySet_0().iterator_0(); port$iterator0.hasNext_0();) {
    port = castTo(port$iterator0.next_1(), 11);
    isBetween(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor])).y_0, edge1.hyperEdgeTopYPos, edge1.hyperEdgeBottomYPos) && ++edge0Counter;
  }
  for (port$iterator1 = edge0.leftPorts.map_0.keySet_0().iterator_0(); port$iterator1.hasNext_0();) {
    port = castTo(port$iterator1.next_1(), 11);
    isBetween(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor])).y_0, edge1.hyperEdgeTopYPos, edge1.hyperEdgeBottomYPos) && --edge0Counter;
  }
  for (port$iterator2 = edge1.rightPorts.map_0.keySet_0().iterator_0(); port$iterator2.hasNext_0();) {
    port = castTo(port$iterator2.next_1(), 11);
    isBetween(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor])).y_0, edge0.hyperEdgeTopYPos, edge0.hyperEdgeBottomYPos) && ++edge1Counter;
  }
  for (port$iterator = edge1.leftPorts.map_0.keySet_0().iterator_0(); port$iterator.hasNext_0();) {
    port = castTo(port$iterator.next_1(), 11);
    isBetween(sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [port.owner.pos, port.pos, port.anchor])).y_0, edge0.hyperEdgeTopYPos, edge0.hyperEdgeBottomYPos) && --edge1Counter;
  }
  if (edge0Counter < edge1Counter) {
    new SplineEdgeRouter$Dependency(edge0, edge1, edge1Counter - edge0Counter);
  }
   else if (edge1Counter < edge0Counter) {
    new SplineEdgeRouter$Dependency(edge1, edge0, edge0Counter - edge1Counter);
  }
   else {
    new SplineEdgeRouter$Dependency(edge1, edge0, 0);
    new SplineEdgeRouter$Dependency(edge0, edge1, 0);
  }
}

function $createSegmentsAndComputeRanking(this$static){
  var hyperEdge1, hyperEdge2, sourceIter, targetIter;
  $createSplineSegmentsForHyperEdges(this$static, this$static.leftPortsLayer, this$static.rightPortsLayer, ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_3), true, this$static.edgesRemainingLayer, this$static.splineSegmentsLayer);
  $createSplineSegmentsForHyperEdges(this$static, this$static.leftPortsLayer, this$static.rightPortsLayer, LEFT_3, false, this$static.edgesRemainingLayer, this$static.splineSegmentsLayer);
  $createSplineSegmentsForHyperEdges(this$static, this$static.leftPortsLayer, this$static.rightPortsLayer, RIGHT_3, true, this$static.edgesRemainingLayer, this$static.splineSegmentsLayer);
  $createSplineSegmentsForHyperEdges(this$static, this$static.leftPortsLayer, this$static.rightPortsLayer, RIGHT_3, false, this$static.edgesRemainingLayer, this$static.splineSegmentsLayer);
  $createSplineSegments(this$static, this$static.edgesRemainingLayer, this$static.leftPortsLayer, this$static.rightPortsLayer, this$static.splineSegmentsLayer);
  sourceIter = new AbstractList$ListIteratorImpl(this$static.splineSegmentsLayer, 0);
  while (sourceIter.i < sourceIter.this$01_0.size_1()) {
    hyperEdge1 = (checkCriticalElement(sourceIter.i < sourceIter.this$01_0.size_1()) , castTo(sourceIter.this$01_0.get_3(sourceIter.last = sourceIter.i++), 121));
    targetIter = new AbstractList$ListIteratorImpl(this$static.splineSegmentsLayer, sourceIter.i);
    while (targetIter.i < targetIter.this$01_0.size_1()) {
      hyperEdge2 = (checkCriticalElement(targetIter.i < targetIter.this$01_0.size_1()) , castTo(targetIter.this$01_0.get_3(targetIter.last = targetIter.i++), 121));
      $createDependency(hyperEdge1, hyperEdge2);
    }
  }
  breakCycles_0(this$static.splineSegmentsLayer, castTo($getProperty(this$static.lGraph, ($clinit_InternalProperties_1() , RANDOM_0)), 221));
  topologicalNumbering_0(this$static.splineSegmentsLayer);
}

function $createSplineSegments(this$static, edges, leftPorts, rightPorts, hyperEdges){
  var edge, edge$iterator, seg, sourcePort, sourceSide, targetPort, targetSide;
  for (edge$iterator = new ArrayList$1(edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 16);
    sourcePort = edge.source;
    if (leftPorts.map_0.containsKey(sourcePort)) {
      sourceSide = ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_3);
    }
     else if (rightPorts.map_0.containsKey(sourcePort)) {
      sourceSide = ($clinit_SplineEdgeRouter$SideToProcess() , RIGHT_3);
    }
     else {
      throw toJs(new IllegalArgumentException_0('Source port must be in one of the port sets.'));
    }
    targetPort = edge.target;
    if (leftPorts.map_0.containsKey(targetPort)) {
      targetSide = ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_3);
    }
     else if (rightPorts.map_0.containsKey(targetPort)) {
      targetSide = ($clinit_SplineEdgeRouter$SideToProcess() , RIGHT_3);
    }
     else {
      throw toJs(new IllegalArgumentException_0('Target port must be in one of the port sets.'));
    }
    seg = new SplineSegment(edge, sourceSide, targetSide);
    $put_1(this$static.edgeToSegmentMap, edge, seg);
    hyperEdges.array[hyperEdges.array.length] = seg;
  }
}

function $createSplineSegmentsForHyperEdges(this$static, leftPorts, rightPorts, sideToProcess, reversed, edgesRemaining, hyperEdges){
  var downEdges, edge, edge$iterator, pair, pair$iterator, portsToProcess, seg, singlePort, singlePort$iterator, singlePortPosition, targetPort, targetPortPosition, upEdges;
  portsToProcess = null;
  sideToProcess == ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_3)?(portsToProcess = leftPorts):sideToProcess == RIGHT_3 && (portsToProcess = rightPorts);
  for (singlePort$iterator = portsToProcess.map_0.keySet_0().iterator_0(); singlePort$iterator.hasNext_0();) {
    singlePort = castTo(singlePort$iterator.next_1(), 11);
    singlePortPosition = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [singlePort.owner.pos, singlePort.pos, singlePort.anchor])).y_0;
    upEdges = new HashSet;
    downEdges = new HashSet;
    for (edge$iterator = new LPort$CombineIter$1(singlePort.connectedEdges); $hasNext_2(edge$iterator.firstIterator) || $hasNext_2(edge$iterator.secondIterator);) {
      edge = castTo($hasNext_2(edge$iterator.firstIterator)?$next_10(edge$iterator.firstIterator):$next_10(edge$iterator.secondIterator), 16);
      if (checkNotNull_1(castToBoolean($getProperty(edge, ($clinit_InternalProperties_1() , REVERSED)))) != reversed) {
        continue;
      }
      if ($indexOf_3(edgesRemaining, edge, 0) != -1) {
        edge.target == singlePort?(targetPort = edge.source):(targetPort = edge.target);
        targetPortPosition = sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [targetPort.owner.pos, targetPort.pos, targetPort.anchor])).y_0;
        if ($wnd.Math.abs(targetPortPosition - singlePortPosition) < 0.2) {
          continue;
        }
        targetPortPosition < singlePortPosition?leftPorts.map_0.containsKey(targetPort)?$add_6(upEdges, new Pair(LEFT_3, edge)):$add_6(upEdges, new Pair(RIGHT_3, edge)):leftPorts.map_0.containsKey(targetPort)?$add_6(downEdges, new Pair(LEFT_3, edge)):$add_6(downEdges, new Pair(RIGHT_3, edge));
      }
    }
    if (upEdges.map_0.size_1() > 1) {
      seg = new SplineSegment_0(singlePort, upEdges, sideToProcess);
      $forEach(upEdges, new SplineEdgeRouter$lambda$2$Type(this$static, seg));
      hyperEdges.array[hyperEdges.array.length] = seg;
      for (pair$iterator = upEdges.map_0.keySet_0().iterator_0(); pair$iterator.hasNext_0();) {
        pair = castTo(pair$iterator.next_1(), 37);
        $remove_13(edgesRemaining, pair.second);
      }
    }
    if (downEdges.map_0.size_1() > 1) {
      seg = new SplineSegment_0(singlePort, downEdges, sideToProcess);
      $forEach(downEdges, new SplineEdgeRouter$lambda$3$Type(this$static, seg));
      hyperEdges.array[hyperEdges.array.length] = seg;
      for (pair$iterator = downEdges.map_0.keySet_0().iterator_0(); pair$iterator.hasNext_0();) {
        pair = castTo(pair$iterator.next_1(), 37);
        $remove_13(edgesRemaining, pair.second);
      }
    }
  }
}

function $findAndAddSuccessor(this$static, edge){
  var iter, nt, targetNode;
  targetNode = edge.target.owner;
  nt = targetNode.type_0;
  if (nt == ($clinit_LNode$NodeType() , NORMAL) || nt == BIG_NODE || nt == BREAKING_POINT) {
    return;
  }
  iter = $iterator($getOutgoingEdges(targetNode));
  $hasNext_0(iter) && $put_1(this$static.successingEdge, edge, castTo($next_2(iter), 16));
}

function $getEdgeChain(this$static, start_0){
  var current, edgeChain;
  edgeChain = new ArrayList;
  current = start_0;
  do {
    edgeChain.array[edgeChain.array.length] = current;
    current = castTo($get_6(this$static.successingEdge, current), 16);
  }
   while (current);
  return edgeChain;
}

function $getLayoutProcessorConfiguration_4(graph){
  var configuration, graphProperties;
  configuration = new LayoutProcessorConfiguration;
  $addAll_4(configuration, BASELINE_PROCESSING_ADDITIONS);
  graphProperties = castTo($getProperty(graph, ($clinit_InternalProperties_1() , GRAPH_PROPERTIES)), 19);
  graphProperties.contains(($clinit_GraphProperties() , SELF_LOOPS)) && $addAll_4(configuration, SELF_LOOP_PROCESSING_ADDITIONS_0);
  graphProperties.contains(CENTER_LABELS) && $addAll_4(configuration, CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_1);
  if (graphProperties.contains(NON_FREE_PORTS) || checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_LayeredOptions() , FEEDBACK_EDGES_0))))) {
    $addAll_4(configuration, INVERTED_PORT_PROCESSING_ADDITIONS_1);
    graphProperties.contains(NORTH_SOUTH_PORTS) && $addAll_4(configuration, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_1);
  }
  graphProperties.contains(END_LABELS) && $addAll_4(configuration, END_EDGE_LABEL_PROCESSING_ADDITIONS_1);
  return configuration;
}

function $getSplinePath(this$static, start_0){
  var current, initialSegment, lastSegment, segment, segmentChain;
  segmentChain = new ArrayList;
  current = start_0;
  do {
    segment = castTo($get_6(this$static.edgeToSegmentMap, current), 121);
    segment.sourcePort = current.source;
    segment.targetPort = current.target;
    segmentChain.array[segmentChain.array.length] = segment;
    current = castTo($get_6(this$static.successingEdge, current), 16);
  }
   while (current);
  initialSegment = (checkCriticalElementIndex(0, segmentChain.array.length) , castTo(segmentChain.array[0], 121));
  initialSegment.initialSegment = true;
  initialSegment.sourceNode = castTo(initialSegment.edges.map_0.keySet_0().iterator_0().next_1(), 16).source.owner;
  lastSegment = castTo($get_7(segmentChain, segmentChain.array.length - 1), 121);
  lastSegment.lastSegment = true;
  lastSegment.targetNode = castTo(lastSegment.edges.map_0.keySet_0().iterator_0().next_1(), 16).target.owner;
  return segmentChain;
}

function $handleSelfloops(this$static){
  var label_0, label$iterator, offset, selfLoop, selfLoop$iterator;
  for (selfLoop$iterator = this$static.selfLoopsLayer.map_0.keySet_0().iterator_0(); selfLoop$iterator.hasNext_0();) {
    selfLoop = castTo(selfLoop$iterator.next_1(), 16);
    offset = selfLoop.source.owner.pos;
    $offset_2(selfLoop.bendPoints, offset);
    for (label$iterator = new ArrayList$1(selfLoop.labels); label$iterator.i < label$iterator.this$01.array.length;) {
      label_0 = castTo($next_10(label$iterator), 70);
      $add_19(label_0.pos, offset);
    }
  }
}

function $lambda$2_2(this$static, seg_1, e_1){
  return $put_1(this$static.edgeToSegmentMap, castTo(e_1.second, 16), seg_1);
}

function $lambda$3_0(this$static, seg_1, e_1){
  return $put_1(this$static.edgeToSegmentMap, castTo(e_1.second, 16), seg_1);
}

function $process_76(this$static, layeredGraph, monitor){
  var edge, edge$iterator, edgeChain, edgeEdgeSpacing, edgeNodeSpacing, firstLayer, increment, isLeftLayerExternal, isRightLayerExternal, isSpecialLeftLayer, isSpecialRightLayer, lastLayer, layerIterator, leftLayer, mode, nodeNodeSpacing, rightLayer, rightLayerPosition, segment, segment$iterator, sloppyLayerSpacingFactor, sloppyRouting, slotCount, spline, xSegmentDelta, xpos;
  $begin(monitor, 'Spline edge routing', 1);
  if (layeredGraph.layers.array.length == 0) {
    layeredGraph.size_0.x_0 = 0;
    $done_0(monitor);
    return;
  }
  nodeNodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, ($clinit_LayeredOptions() , SPACING_NODE_NODE_BETWEEN_LAYERS_0))));
  edgeNodeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_EDGE_NODE_BETWEEN_LAYERS_0)));
  edgeEdgeSpacing = checkNotNull_1(castToDouble($getProperty(layeredGraph, SPACING_EDGE_EDGE_BETWEEN_LAYERS_0)));
  mode = castTo($getProperty(layeredGraph, EDGE_ROUTING_SPLINES_MODE_0), 327);
  sloppyRouting = mode == ($clinit_SplineRoutingMode() , SLOPPY);
  sloppyLayerSpacingFactor = checkNotNull_1(castToDouble($getProperty(layeredGraph, EDGE_ROUTING_SPLINES_SLOPPY_LAYER_SPACING_FACTOR_0)));
  this$static.lGraph = layeredGraph;
  this$static.startEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.allSplineSegments.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $reset(this$static.successingEdge);
  firstLayer = castTo($get_7(layeredGraph.layers, 0), 25);
  isLeftLayerExternal = all_0(firstLayer.nodes, ($clinit_PolylineEdgeRouter() , PRED_EXTERNAL_WEST_OR_EAST_PORT));
  lastLayer = castTo($get_7(layeredGraph.layers, layeredGraph.layers.array.length - 1), 25);
  isRightLayerExternal = all_0(lastLayer.nodes, PRED_EXTERNAL_WEST_OR_EAST_PORT);
  layerIterator = new ArrayList$1(layeredGraph.layers);
  leftLayer = null;
  xpos = 0;
  do {
    rightLayer = layerIterator.i < layerIterator.this$01.array.length?castTo($next_10(layerIterator), 25):null;
    $clearThenFillMappings(this$static, leftLayer, rightLayer);
    $createSegmentsAndComputeRanking(this$static);
    slotCount = $orElse_0($max_0($mapToInt($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.splineSegmentsLayer, 16)), new SplineEdgeRouter$lambda$0$Type), new SplineEdgeRouter$lambda$1$Type)));
    xSegmentDelta = 0;
    rightLayerPosition = xpos;
    isSpecialLeftLayer = !leftLayer || isLeftLayerExternal;
    isSpecialRightLayer = !rightLayer || isRightLayerExternal;
    if (slotCount > 0) {
      increment = 0;
      !!leftLayer && (increment += edgeNodeSpacing);
      increment += (slotCount - 1) * edgeEdgeSpacing;
      !!rightLayer && (increment += edgeNodeSpacing);
      sloppyRouting && !!rightLayer && (increment = $wnd.Math.max(increment, $computeSloppySpacing(rightLayer, edgeEdgeSpacing, nodeNodeSpacing, sloppyLayerSpacingFactor)));
      if (increment < nodeNodeSpacing && !isSpecialLeftLayer && !isSpecialRightLayer) {
        xSegmentDelta = (nodeNodeSpacing - increment) / 2;
        increment = nodeNodeSpacing;
      }
      rightLayerPosition += increment;
    }
     else 
      !isSpecialLeftLayer && !isSpecialRightLayer && (rightLayerPosition += nodeNodeSpacing);
    !!rightLayer && placeNodesHorizontally(rightLayer, rightLayerPosition);
    $handleSelfloops(this$static);
    for (segment$iterator = new ArrayList$1(this$static.splineSegmentsLayer); segment$iterator.i < segment$iterator.this$01.array.length;) {
      segment = castTo($next_10(segment$iterator), 121);
      segment.boundingBox.x_0 = xpos;
      segment.boundingBox.width_0 = rightLayerPosition - xpos;
      segment.xDelta = xSegmentDelta;
      segment.isWestOfInitialLayer = !leftLayer;
    }
    $addAll_2(this$static.allSplineSegments, this$static.splineSegmentsLayer);
    xpos = rightLayerPosition;
    !!rightLayer && (xpos += rightLayer.size_0.x_0);
    leftLayer = rightLayer;
  }
   while (rightLayer);
  for (edge$iterator = new ArrayList$1(this$static.startEdges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 16);
    edgeChain = $getEdgeChain(this$static, edge);
    $setProperty_0(edge, ($clinit_InternalProperties_1() , SPLINE_EDGE_CHAIN), edgeChain);
    spline = $getSplinePath(this$static, edge);
    $setProperty_0(edge, SPLINE_ROUTE_START, spline);
  }
  layeredGraph.size_0.x_0 = xpos;
  this$static.lGraph = null;
  $done_0(monitor);
}

function SplineEdgeRouter(){
  $clinit_SplineEdgeRouter();
  this.edgesRemainingLayer = new ArrayList;
  this.splineSegmentsLayer = new ArrayList;
  this.leftPortsLayer = new LinkedHashSet;
  this.rightPortsLayer = new LinkedHashSet;
  this.selfLoopsLayer = new LinkedHashSet;
  this.startEdges = new ArrayList;
  this.allSplineSegments = new ArrayList;
  this.edgeToSegmentMap = ($clinit_Maps() , new HashMap);
  this.successingEdge = new HashMap;
}

function breakCycles_0(edges, random){
  var depIter, dependency, dependency$iterator, dependency$iterator0, edge, edge$iterator, edge$iterator0, edge$iterator1, inweight, markBase, maxEdge, maxEdges, maxOutflow, nextLeft, nextMark, nextRight, outflow, outweight, shiftBase, sink, sinks, source, source$iterator, sources, target, unprocessed;
  sources = new LinkedList;
  sinks = new LinkedList;
  nextMark = -1;
  for (edge$iterator0 = new ArrayList$1(edges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator0), 121);
    edge.mark = nextMark--;
    inweight = 0;
    outweight = 0;
    for (dependency$iterator0 = new ArrayList$1(edge.outgoing); dependency$iterator0.i < dependency$iterator0.this$01.array.length;) {
      dependency = castTo($next_10(dependency$iterator0), 258);
      outweight += dependency.weight;
    }
    for (dependency$iterator = new ArrayList$1(edge.incoming); dependency$iterator.i < dependency$iterator.this$01.array.length;) {
      dependency = castTo($next_10(dependency$iterator), 258);
      inweight += dependency.weight;
    }
    edge.inweight = inweight;
    edge.outweight = outweight;
    outweight == 0?($addNode_0(sinks, edge, sinks.tail.prev, sinks.tail) , true):inweight == 0 && ($addNode_0(sources, edge, sources.tail.prev, sources.tail) , true);
  }
  unprocessed = newLinkedHashSet(edges);
  markBase = edges.array.length;
  nextLeft = markBase + 1;
  nextRight = markBase - 1;
  maxEdges = new ArrayList;
  while (unprocessed.map_0.size_1() != 0) {
    while (sinks.size_0 != 0) {
      sink = (checkCriticalElement(sinks.size_0 != 0) , castTo($removeNode_0(sinks, sinks.header.next_0), 121));
      unprocessed.map_0.remove(sink) != null;
      sink.mark = nextRight--;
      updateNeighbors_0(sink, sources, sinks);
    }
    while (sources.size_0 != 0) {
      source = (checkCriticalElement(sources.size_0 != 0) , castTo($removeNode_0(sources, sources.header.next_0), 121));
      unprocessed.map_0.remove(source) != null;
      source.mark = nextLeft++;
      updateNeighbors_0(source, sources, sinks);
    }
    maxOutflow = $intern_43;
    for (edge$iterator1 = unprocessed.map_0.keySet_0().iterator_0(); edge$iterator1.hasNext_0();) {
      edge = castTo(edge$iterator1.next_1(), 121);
      outflow = edge.outweight - edge.inweight;
      if (outflow >= maxOutflow) {
        if (outflow > maxOutflow) {
          maxEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
          maxOutflow = outflow;
        }
        maxEdges.array[maxEdges.array.length] = edge;
      }
    }
    if (maxEdges.array.length != 0) {
      maxEdge = castTo($get_7(maxEdges, $nextInt(random, maxEdges.array.length)), 121);
      unprocessed.map_0.remove(maxEdge) != null;
      maxEdge.mark = nextLeft++;
      updateNeighbors_0(maxEdge, sources, sinks);
      maxEdges.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
    }
  }
  shiftBase = edges.array.length + 1;
  for (edge$iterator = new ArrayList$1(edges); edge$iterator.i < edge$iterator.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator), 121);
    edge.mark < markBase && (edge.mark += shiftBase);
  }
  for (source$iterator = new ArrayList$1(edges); source$iterator.i < source$iterator.this$01.array.length;) {
    source = castTo($next_10(source$iterator), 121);
    depIter = new AbstractList$ListIteratorImpl(source.outgoing, 0);
    while (depIter.i < depIter.this$01_0.size_1()) {
      dependency = (checkCriticalElement(depIter.i < depIter.this$01_0.size_1()) , castTo(depIter.this$01_0.get_3(depIter.last = depIter.i++), 258));
      target = dependency.target;
      if (source.mark > target.mark) {
        $remove_9(depIter);
        $remove_13(target.incoming, dependency);
        if (dependency.weight > 0) {
          dependency.source = target;
          $add_4(target.outgoing, dependency);
          dependency.target = source;
          $add_4(source.incoming, dependency);
        }
      }
    }
  }
}

function topologicalNumbering_0(edges){
  var dep, dep$iterator, edge, edge$iterator, edge$iterator0, maxRank, rightwardTargets, source, sources, target;
  sources = new LinkedList;
  rightwardTargets = new LinkedList;
  for (edge$iterator0 = new ArrayList$1(edges); edge$iterator0.i < edge$iterator0.this$01.array.length;) {
    edge = castTo($next_10(edge$iterator0), 121);
    edge.rank = 0;
    edge.inweight = edge.incoming.array.length;
    edge.outweight = edge.outgoing.array.length;
    edge.inweight == 0 && ($addNode_0(sources, edge, sources.tail.prev, sources.tail) , true);
    edge.outweight == 0 && edge.leftPorts.map_0.size_1() == 0 && ($addNode_0(rightwardTargets, edge, rightwardTargets.tail.prev, rightwardTargets.tail) , true);
  }
  maxRank = -1;
  while (sources.size_0 != 0) {
    edge = castTo($remove_5(sources, 0), 121);
    for (dep$iterator = new ArrayList$1(edge.outgoing); dep$iterator.i < dep$iterator.this$01.array.length;) {
      dep = castTo($next_10(dep$iterator), 258);
      target = dep.target;
      target.rank = max_1(target.rank, edge.rank + 1);
      maxRank = max_1(maxRank, target.rank);
      --target.inweight;
      target.inweight == 0 && ($addNode_0(sources, target, sources.tail.prev, sources.tail) , true);
    }
  }
  if (maxRank > -1) {
    for (edge$iterator = $listIterator_1(rightwardTargets, 0); edge$iterator.currentNode != edge$iterator.this$01.tail;) {
      edge = castTo($next_13(edge$iterator), 121);
      edge.rank = maxRank;
    }
    while (rightwardTargets.size_0 != 0) {
      edge = castTo($remove_5(rightwardTargets, 0), 121);
      for (dep$iterator = new ArrayList$1(edge.incoming); dep$iterator.i < dep$iterator.this$01.array.length;) {
        dep = castTo($next_10(dep$iterator), 258);
        source = dep.source;
        if (source.leftPorts.map_0.size_1() != 0) {
          continue;
        }
        source.rank = min_1(source.rank, edge.rank - 1);
        --source.outweight;
        source.outweight == 0 && ($addNode_0(rightwardTargets, source, rightwardTargets.tail.prev, rightwardTargets.tail) , true);
      }
    }
  }
}

function updateNeighbors_0(edge, sources, sinks){
  var dep, dep$iterator, dep$iterator0;
  for (dep$iterator0 = new ArrayList$1(edge.outgoing); dep$iterator0.i < dep$iterator0.this$01.array.length;) {
    dep = castTo($next_10(dep$iterator0), 258);
    if (dep.target.mark < 0 && dep.weight > 0) {
      dep.target.inweight -= dep.weight;
      dep.target.inweight <= 0 && dep.target.outweight > 0 && $add_7(sources, dep.target);
    }
  }
  for (dep$iterator = new ArrayList$1(edge.incoming); dep$iterator.i < dep$iterator.this$01.array.length;) {
    dep = castTo($next_10(dep$iterator), 258);
    if (dep.source.mark < 0 && dep.weight > 0) {
      dep.source.outweight -= dep.weight;
      dep.source.outweight <= 0 && dep.source.inweight > 0 && $add_7(sinks, dep.source);
    }
  }
}

defineClass(1324, 1, $intern_117, SplineEdgeRouter);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_17(graph){
  return $getLayoutProcessorConfiguration_4(castTo(graph, 32));
}
;
_.process = function process_70(layeredGraph, monitor){
  $process_76(this, castTo(layeredGraph, 32), monitor);
}
;
var BASELINE_PROCESSING_ADDITIONS, CENTER_EDGE_LABEL_PROCESSING_ADDITIONS_1, END_EDGE_LABEL_PROCESSING_ADDITIONS_1, INVERTED_PORT_PROCESSING_ADDITIONS_1, NORTH_SOUTH_PORT_PROCESSING_ADDITIONS_1, SELF_LOOP_PROCESSING_ADDITIONS_0;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineEdgeRouter', 1324);
function SplineEdgeRouter$Dependency(source, target, weight){
  this.source = source;
  this.target = target;
  this.weight = weight;
  $add_4(source.outgoing, this);
  $add_4(target.incoming, this);
}

defineClass(258, 1, {258:1}, SplineEdgeRouter$Dependency);
_.toString_0 = function toString_107(){
  return this.source + ' ->(' + this.weight + ') ' + this.target;
}
;
_.weight = 0;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter$Dependency_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineEdgeRouter/Dependency', 258);
function $clinit_SplineEdgeRouter$SideToProcess(){
  $clinit_SplineEdgeRouter$SideToProcess = emptyMethod;
  LEFT_3 = new SplineEdgeRouter$SideToProcess('LEFT', 0);
  RIGHT_3 = new SplineEdgeRouter$SideToProcess('RIGHT', 1);
}

function SplineEdgeRouter$SideToProcess(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_65(name_0){
  $clinit_SplineEdgeRouter$SideToProcess();
  return valueOf(($clinit_SplineEdgeRouter$SideToProcess$Map() , $MAP_53), name_0);
}

function values_61(){
  $clinit_SplineEdgeRouter$SideToProcess();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter$SideToProcess_2_classLit, 1), $intern_38, 430, 0, [LEFT_3, RIGHT_3]);
}

defineClass(430, 22, {3:1, 34:1, 22:1, 430:1}, SplineEdgeRouter$SideToProcess);
var LEFT_3, RIGHT_3;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter$SideToProcess_2_classLit = createForEnum('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineEdgeRouter/SideToProcess', 430, Ljava_lang_Enum_2_classLit, values_61, valueOf_65);
function $clinit_SplineEdgeRouter$SideToProcess$Map(){
  $clinit_SplineEdgeRouter$SideToProcess$Map = emptyMethod;
  $MAP_53 = createValueOfMap(($clinit_SplineEdgeRouter$SideToProcess() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter$SideToProcess_2_classLit, 1), $intern_38, 430, 0, [LEFT_3, RIGHT_3])));
}

var $MAP_53;
function SplineEdgeRouter$lambda$0$Type(){
}

defineClass(1325, 1, $intern_90, SplineEdgeRouter$lambda$0$Type);
_.test_0 = function test_77(arg0){
  return $clinit_SplineEdgeRouter() , !castTo(arg0, 121).isStraight;
}
;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineEdgeRouter/lambda$0$Type', 1325);
function SplineEdgeRouter$lambda$1$Type(){
}

defineClass(1326, 1, {}, SplineEdgeRouter$lambda$1$Type);
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineEdgeRouter/lambda$1$Type', 1326);
function SplineEdgeRouter$lambda$2$Type($$outer_0, seg_1){
  this.$$outer_0 = $$outer_0;
  this.seg_1 = seg_1;
}

defineClass(1327, 1, {}, SplineEdgeRouter$lambda$2$Type);
_.accept = function accept_98(arg0){
  $lambda$2_2(this.$$outer_0, this.seg_1, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineEdgeRouter/lambda$2$Type', 1327);
function SplineEdgeRouter$lambda$3$Type($$outer_0, seg_1){
  this.$$outer_0 = $$outer_0;
  this.seg_1 = seg_1;
}

defineClass(1328, 1, {}, SplineEdgeRouter$lambda$3$Type);
_.accept = function accept_99(arg0){
  $lambda$3_0(this.$$outer_0, this.seg_1, arg0);
}
;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineEdgeRouter$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineEdgeRouter/lambda$3$Type', 1328);
function $$init_8(this$static){
  this$static.leftPorts = new HashSet;
  this$static.rightPorts = new HashSet;
  this$static.outgoing = new ArrayList;
  this$static.incoming = new ArrayList;
  this$static.edges = new HashSet;
  this$static.boundingBox = new ElkRectangle;
  this$static.edgeInformation = ($clinit_Maps() , new HashMap);
}

function $addEdge_0(this$static, edge){
  var ei, nt, nt0;
  $add_6(this$static.edges, edge);
  ei = new SplineSegment$EdgeInformation;
  $put_1(this$static.edgeInformation, edge, ei);
  ei.startY = $anchorY(edge.source);
  ei.endY = $anchorY(edge.target);
  ei.normalSourceNode = ($clinit_SplineEdgeRouter() , nt0 = edge.source.owner.type_0 , nt0 == ($clinit_LNode$NodeType() , NORMAL) || nt0 == BIG_NODE || nt0 == BREAKING_POINT);
  ei.normalTargetNode = (nt = edge.target.owner.type_0 , nt == NORMAL || nt == BIG_NODE || nt == BREAKING_POINT);
  ei.invertedLeft = edge.source.side == ($clinit_PortSide() , WEST_1);
  ei.invertedRight = edge.target.side == EAST_1;
}

function $anchorY(p){
  return ($clinit_PortSide() , SIDES_NORTH_SOUTH).contains(p.side)?checkNotNull_1(castToDouble($getProperty(p, ($clinit_InternalProperties_1() , SPLINE_NS_PORT_Y_COORD)))):sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [p.owner.pos, p.pos, p.anchor])).y_0;
}

function $compareTo_18(this$static, other){
  return this$static.mark - other.mark;
}

function $setRelevantPositions(this$static, sourceY, targetYMin, targetYMax){
  this$static.boundingBox.y_0 = $wnd.Math.min(sourceY, targetYMin);
  this$static.boundingBox.height = $wnd.Math.max(sourceY, targetYMax) - this$static.boundingBox.y_0;
  if (sourceY < targetYMin) {
    this$static.centerControlPointY = 0.5 * (sourceY + targetYMin);
    this$static.hyperEdgeTopYPos = $intern_125 * this$static.centerControlPointY + 0.9 * sourceY;
    this$static.hyperEdgeBottomYPos = $intern_125 * this$static.centerControlPointY + 0.9 * targetYMin;
  }
   else {
    this$static.centerControlPointY = 0.5 * (sourceY + targetYMax);
    this$static.hyperEdgeTopYPos = $intern_125 * this$static.centerControlPointY + 0.9 * targetYMax;
    this$static.hyperEdgeBottomYPos = $intern_125 * this$static.centerControlPointY + 0.9 * sourceY;
  }
}

function SplineSegment(edge, sourceSide, targetSide){
  var sourceY, targetY;
  $$init_8(this);
  sourceSide == ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_3)?$add_6(this.leftPorts, edge.source):$add_6(this.rightPorts, edge.source);
  targetSide == LEFT_3?$add_6(this.leftPorts, edge.target):$add_6(this.rightPorts, edge.target);
  $addEdge_0(this, edge);
  sourceY = $anchorY(edge.source);
  targetY = $anchorY(edge.target);
  $setRelevantPositions(this, sourceY, targetY, targetY);
  this.isStraight = ($clinit_SplineEdgeRouter() , $wnd.Math.abs(sourceY - targetY) < 0.2);
}

function SplineSegment_0(singlePort, edges, sourceSide){
  var edge, pair, pair$iterator, pair$iterator0, side, tgtPort, yMaxPosOfTarget, yMinPosOfTarget, yPosOfSingleSide, yPosOfTarget;
  $$init_8(this);
  sourceSide == ($clinit_SplineEdgeRouter$SideToProcess() , LEFT_3)?$add_6(this.leftPorts, singlePort):$add_6(this.rightPorts, singlePort);
  yMinPosOfTarget = $intern_62;
  yMaxPosOfTarget = $intern_63;
  for (pair$iterator0 = edges.map_0.keySet_0().iterator_0(); pair$iterator0.hasNext_0();) {
    pair = castTo(pair$iterator0.next_1(), 37);
    side = castTo(pair.first, 430);
    edge = castTo(pair.second, 16);
    tgtPort = edge.source;
    tgtPort == singlePort && (tgtPort = edge.target);
    side == LEFT_3?$add_6(this.leftPorts, tgtPort):$add_6(this.rightPorts, tgtPort);
    yPosOfTarget = ($clinit_PortSide() , SIDES_NORTH_SOUTH).contains(tgtPort.side)?checkNotNull_1(castToDouble($getProperty(tgtPort, ($clinit_InternalProperties_1() , SPLINE_NS_PORT_Y_COORD)))):sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [tgtPort.owner.pos, tgtPort.pos, tgtPort.anchor])).y_0;
    yMinPosOfTarget = $wnd.Math.min(yMinPosOfTarget, yPosOfTarget);
    yMaxPosOfTarget = $wnd.Math.max(yMaxPosOfTarget, yPosOfTarget);
  }
  yPosOfSingleSide = ($clinit_PortSide() , SIDES_NORTH_SOUTH).contains(singlePort.side)?checkNotNull_1(castToDouble($getProperty(singlePort, ($clinit_InternalProperties_1() , SPLINE_NS_PORT_Y_COORD)))):sum_0(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, 1), $intern_33, 8, 0, [singlePort.owner.pos, singlePort.pos, singlePort.anchor])).y_0;
  $setRelevantPositions(this, yPosOfSingleSide, yMinPosOfTarget, yMaxPosOfTarget);
  for (pair$iterator = edges.map_0.keySet_0().iterator_0(); pair$iterator.hasNext_0();) {
    pair = castTo(pair$iterator.next_1(), 37);
    $addEdge_0(this, castTo(pair.second, 16));
  }
  this.isStraight = false;
}

defineClass(121, 1, {34:1, 121:1}, SplineSegment, SplineSegment_0);
_.compareTo_0 = function compareTo_19(other){
  return $compareTo_18(this, castTo(other, 121));
}
;
_.centerControlPointY = 0;
_.handled = false;
_.hyperEdgeBottomYPos = 0;
_.hyperEdgeTopYPos = 0;
_.initialSegment = false;
_.inverseOrder = false;
_.inweight = 0;
_.isStraight = false;
_.isWestOfInitialLayer = false;
_.lastSegment = false;
_.mark = 0;
_.outweight = 0;
_.rank = 0;
_.xDelta = 0;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineSegment_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineSegment', 121);
function SplineSegment$EdgeInformation(){
}

defineClass(435, 1, {435:1}, SplineSegment$EdgeInformation);
_.endY = 0;
_.invertedLeft = false;
_.invertedRight = false;
_.normalSourceNode = false;
_.normalTargetNode = false;
_.startY = 0;
var Lorg_eclipse_elk_alg_layered_p5edges_splines_SplineSegment$EdgeInformation_2_classLit = createForClass('org.eclipse.elk.alg.layered.p5edges.splines', 'SplineSegment/EdgeInformation', 435);
function distPortToNodeEdge(port, side){
  var nodeSize, portPos;
  portPos = $add_19($clone_0(port.pos), port.anchor);
  nodeSize = port.owner.size_0;
  switch (side.ordinal) {
    case 1:
      return -portPos.y_0;
    case 2:
      return -portPos.x_0 + nodeSize.x_0;
    case 3:
      return -portPos.y_0 + nodeSize.y_0;
    case 4:
      return -portPos.x_0;
    default:return 0;
  }
}

function isBetween(value_0, boundary0, boundary1){
  if ($wnd.Math.abs(boundary0 - value_0) < $intern_113 || $wnd.Math.abs(boundary1 - value_0) < $intern_113) {
    return true;
  }
  return boundary0 - value_0 > $intern_113?value_0 - boundary1 > $intern_113:boundary1 - value_0 > $intern_113;
}

function isBetween_0(value_0, boundary0, boundary1){
  return value_0 < boundary0?boundary1 <= value_0:value_0 <= boundary1 || value_0 == boundary0;
}

function portSideToDirection(side){
  switch (side.ordinal) {
    case 1:
      return $intern_126;
    default:case 2:
      return 0;
    case 3:
      return $intern_101;
    case 4:
      return $intern_127;
  }
}

function $dfs_5(this$static, node, graph){
  var component, edge, edge$iterator;
  if (!this$static.visited[node.id_0]) {
    this$static.visited[node.id_0] = true;
    component = graph;
    !graph && (component = new TGraph);
    $add_7(component.nodes, node);
    for (edge$iterator = this$static.incidence[node.id_0].iterator_0(); edge$iterator.hasNext_0();) {
      edge = castTo(edge$iterator.next_1(), 174);
      edge.source != node && $dfs_5(this$static, edge.source, component);
      edge.target != node && $dfs_5(this$static, edge.target, component);
      $add_7(component.edges, edge);
    }
    return component;
  }
  return null;
}

function $initialize_4(this$static, graph){
  var edge, edge$iterator, n, node, node$iterator;
  n = graph.nodes.size_0;
  this$static.incidence = initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, n, 0, 1);
  this$static.visited = initUnidimensionalArray(Z_classLit, $intern_93, 23, n, 16, 1);
  for (node$iterator = $listIterator_1(graph.nodes, 0); node$iterator.currentNode != node$iterator.this$01.tail;) {
    node = castTo($next_13(node$iterator), 78);
    this$static.incidence[node.id_0] = new LinkedList;
  }
  for (edge$iterator = $listIterator_1(graph.edges, 0); edge$iterator.currentNode != edge$iterator.this$01.tail;) {
    edge = castTo($next_13(edge$iterator), 174);
    this$static.incidence[edge.source.id_0].add_1(edge);
    this$static.incidence[edge.target.id_0].add_1(edge);
  }
}

function $moveGraph_1(destGraph, sourceGraph, offsetx, offsety){
  var bendpoint, bendpoint$iterator, edge, edge$iterator, graphOffset, node, node$iterator;
  graphOffset = new KVector_1(offsetx, offsety);
  $sub_0(graphOffset, castTo($getProperty(sourceGraph, ($clinit_InternalProperties_2() , BB_UPLEFT_0)), 8));
  for (node$iterator = $listIterator_1(sourceGraph.nodes, 0); node$iterator.currentNode != node$iterator.this$01.tail;) {
    node = castTo($next_13(node$iterator), 78);
    $add_19(node.pos, graphOffset);
    $add_7(destGraph.nodes, node);
  }
  for (edge$iterator = $listIterator_1(sourceGraph.edges, 0); edge$iterator.currentNode != edge$iterator.this$01.tail;) {
    edge = castTo($next_13(edge$iterator), 174);
    for (bendpoint$iterator = $listIterator_1(edge.bendPoints, 0); bendpoint$iterator.currentNode != bendpoint$iterator.this$01.tail;) {
      bendpoint = castTo($next_13(bendpoint$iterator), 8);
      $add_19(bendpoint, graphOffset);
    }
    $add_7(destGraph.edges, edge);
  }
}

function $pack(components){
  var broadestRow, debug, debugMode, entry, entry$iterator, graph, graph$iterator, graph$iterator0, graph$iterator1, highestBox, maxRowWidth, maxx, maxy, minx, miny, node, node$iterator, priority, propComp, propMerge, result, size_0, spacing, tGraph, tGraph$iterator, totalArea, xpos, ypos;
  if (components.array.length == 1) {
    return checkCriticalElementIndex(0, components.array.length) , castTo(components.array[0], 131);
  }
   else if (components.array.length <= 0) {
    return new TGraph;
  }
  for (graph$iterator0 = new ArrayList$1(components); graph$iterator0.i < graph$iterator0.this$01.array.length;) {
    graph = castTo($next_10(graph$iterator0), 131);
    priority = 0;
    minx = $intern_0;
    miny = $intern_0;
    maxx = $intern_43;
    maxy = $intern_43;
    for (node$iterator = $listIterator_1(graph.nodes, 0); node$iterator.currentNode != node$iterator.this$01.tail;) {
      node = castTo($next_13(node$iterator), 78);
      priority += castTo($getProperty(node, ($clinit_MrTreeOptions() , PRIORITY_1)), 21).value_0;
      minx = $wnd.Math.min(minx, node.pos.x_0);
      miny = $wnd.Math.min(miny, node.pos.y_0);
      maxx = $wnd.Math.max(maxx, node.pos.x_0 + node.size_0.x_0);
      maxy = $wnd.Math.max(maxy, node.pos.y_0 + node.size_0.y_0);
    }
    $setProperty_0(graph, ($clinit_MrTreeOptions() , PRIORITY_1), valueOf_4(priority));
    $setProperty_0(graph, ($clinit_InternalProperties_2() , BB_UPLEFT_0), new KVector_1(minx, miny));
    $setProperty_0(graph, BB_LOWRIGHT_0, new KVector_1(maxx, maxy));
  }
  $clinit_Collections();
  $sort(components, new ComponentsProcessor$1_0);
  result = new TGraph;
  $copyProperties(result, (checkCriticalElementIndex(0, components.array.length) , castTo(components.array[0], 94)));
  maxRowWidth = 0;
  totalArea = 0;
  for (graph$iterator1 = new ArrayList$1(components); graph$iterator1.i < graph$iterator1.this$01.array.length;) {
    graph = castTo($next_10(graph$iterator1), 131);
    size_0 = $sub_0($clone_0(castTo($getProperty(graph, ($clinit_InternalProperties_2() , BB_LOWRIGHT_0)), 8)), castTo($getProperty(graph, BB_UPLEFT_0), 8));
    maxRowWidth = $wnd.Math.max(maxRowWidth, size_0.x_0);
    totalArea += size_0.x_0 * size_0.y_0;
  }
  maxRowWidth = $wnd.Math.max(maxRowWidth, $wnd.Math.sqrt(totalArea) * checkNotNull_1(castToDouble($getProperty(result, ($clinit_MrTreeOptions() , ASPECT_RATIO_2)))));
  spacing = checkNotNull_1(castToDouble($getProperty(result, SPACING_NODE_NODE_1)));
  xpos = 0;
  ypos = 0;
  highestBox = 0;
  broadestRow = spacing;
  for (graph$iterator = new ArrayList$1(components); graph$iterator.i < graph$iterator.this$01.array.length;) {
    graph = castTo($next_10(graph$iterator), 131);
    size_0 = $sub_0($clone_0(castTo($getProperty(graph, ($clinit_InternalProperties_2() , BB_LOWRIGHT_0)), 8)), castTo($getProperty(graph, BB_UPLEFT_0), 8));
    if (xpos + size_0.x_0 > maxRowWidth) {
      xpos = 0;
      ypos += highestBox + spacing;
      highestBox = 0;
    }
    $moveGraph_1(result, graph, xpos, ypos);
    broadestRow = $wnd.Math.max(broadestRow, xpos + size_0.x_0);
    highestBox = $wnd.Math.max(highestBox, size_0.y_0);
    xpos += size_0.x_0 + spacing;
  }
  propMerge = new HashMap;
  debug = new HashMap;
  for (tGraph$iterator = new ArrayList$1(components); tGraph$iterator.i < tGraph$iterator.this$01.array.length;) {
    tGraph = castTo($next_10(tGraph$iterator), 131);
    debugMode = checkNotNull_1(castToBoolean($getProperty(tGraph, ($clinit_CoreOptions() , DEBUG_MODE_3))));
    propComp = !tGraph.propertyMap?(null , EMPTY_MAP):tGraph.propertyMap;
    for (entry$iterator = propComp.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
      entry = castTo(entry$iterator.next_1(), 39);
      if ($containsKey_2(propMerge, entry.getKey())) {
        if (maskUndefined(castTo(entry.getKey(), 169).getDefault()) !== maskUndefined(entry.getValue())) {
          if (debugMode && $containsKey_2(debug, entry.getKey())) {
            $clinit_System();
            'Found different values for property ' + castTo(entry.getKey(), 169).getId() + ' in components.';
          }
           else {
            $put_1(propMerge, castTo(entry.getKey(), 169), entry.getValue());
            $setProperty_0(result, castTo(entry.getKey(), 169), entry.getValue());
            debugMode && $put_1(debug, castTo(entry.getKey(), 169), entry.getValue());
          }
        }
      }
       else {
        $put_1(propMerge, castTo(entry.getKey(), 169), entry.getValue());
        $setProperty_0(result, castTo(entry.getKey(), 169), entry.getValue());
      }
    }
  }
  return result;
}

function $split_4(this$static, graph){
  var comp, comp$iterator, components, id_0, node, node$iterator, node$iterator0, separate;
  separate = castToBoolean($getProperty(graph, ($clinit_MrTreeOptions() , SEPARATE_CONNECTED_COMPONENTS_1)));
  if (separate == null || (checkCriticalNotNull(separate) , separate)) {
    $initialize_4(this$static, graph);
    components = new ArrayList;
    for (node$iterator0 = $listIterator_1(graph.nodes, 0); node$iterator0.currentNode != node$iterator0.this$01.tail;) {
      node = castTo($next_13(node$iterator0), 78);
      comp = $dfs_5(this$static, node, null);
      if (comp) {
        $copyProperties(comp, graph);
        components.array[components.array.length] = comp;
      }
    }
    this$static.incidence = null;
    this$static.visited = null;
    if (components.array.length > 1) {
      for (comp$iterator = new ArrayList$1(components); comp$iterator.i < comp$iterator.this$01.array.length;) {
        comp = castTo($next_10(comp$iterator), 131);
        id_0 = 0;
        for (node$iterator = $listIterator_1(comp.nodes, 0); node$iterator.currentNode != node$iterator.this$01.tail;) {
          node = castTo($next_13(node$iterator), 78);
          node.id_0 = id_0++;
        }
      }
    }
    return components;
  }
  return newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_graph_TGraph_2_classLit, 1), $intern_103, 131, 0, [graph]));
}

function ComponentsProcessor_1(){
}

defineClass(1061, 1, {}, ComponentsProcessor_1);
var Lorg_eclipse_elk_alg_mrtree_ComponentsProcessor_2_classLit = createForClass('org.eclipse.elk.alg.mrtree', 'ComponentsProcessor', 1061);
function $compare_21(graph1, graph2){
  var prio, size1, size2;
  prio = castTo($getProperty(graph2, ($clinit_MrTreeOptions() , PRIORITY_1)), 21).value_0 - castTo($getProperty(graph1, PRIORITY_1), 21).value_0;
  if (prio == 0) {
    size1 = $sub_0($clone_0(castTo($getProperty(graph1, ($clinit_InternalProperties_2() , BB_LOWRIGHT_0)), 8)), castTo($getProperty(graph1, BB_UPLEFT_0), 8));
    size2 = $sub_0($clone_0(castTo($getProperty(graph2, BB_LOWRIGHT_0), 8)), castTo($getProperty(graph2, BB_UPLEFT_0), 8));
    return compare_5(size1.x_0 * size1.y_0, size2.x_0 * size2.y_0);
  }
  return prio;
}

function ComponentsProcessor$1_0(){
}

defineClass(1062, 1, $intern_40, ComponentsProcessor$1_0);
_.compare_0 = function compare_67(graph1, graph2){
  return $compare_21(castTo(graph1, 131), castTo(graph2, 131));
}
;
_.equals_0 = function equals_160(other){
  return this === other;
}
;
_.reversed = function reversed_59(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_alg_mrtree_ComponentsProcessor$1_2_classLit = createForClass('org.eclipse.elk.alg.mrtree', 'ComponentsProcessor/1', 1062);
function $applyLayout_4(tGraph){
  var bendPoints, edgeSection, elkedge, elkgraph, elknode, height, maxXPos, maxYPos, minXPos, minYPos, nodePos, object, offset, padding, pos, size_0, sourcePoint, tEdge, tEdge$iterator, tNode, tNode$iterator, tNode$iterator0, targetPoint, width_0;
  elkgraph = castTo($getProperty(tGraph, ($clinit_InternalProperties_2() , ORIGIN_1)), 35);
  minXPos = $intern_0;
  minYPos = $intern_0;
  maxXPos = $intern_43;
  maxYPos = $intern_43;
  for (tNode$iterator0 = $listIterator_1(tGraph.nodes, 0); tNode$iterator0.currentNode != tNode$iterator0.this$01.tail;) {
    tNode = castTo($next_13(tNode$iterator0), 78);
    pos = tNode.pos;
    size_0 = tNode.size_0;
    minXPos = $wnd.Math.min(minXPos, pos.x_0 - size_0.x_0 / 2);
    minYPos = $wnd.Math.min(minYPos, pos.y_0 - size_0.y_0 / 2);
    maxXPos = $wnd.Math.max(maxXPos, pos.x_0 + size_0.x_0 / 2);
    maxYPos = $wnd.Math.max(maxYPos, pos.y_0 + size_0.y_0 / 2);
  }
  padding = castTo($getProperty_0(elkgraph, ($clinit_MrTreeOptions() , PADDING_2)), 116);
  offset = new KVector_1(padding.left - minXPos, padding.top_0 - minYPos);
  for (tNode$iterator = $listIterator_1(tGraph.nodes, 0); tNode$iterator.currentNode != tNode$iterator.this$01.tail;) {
    tNode = castTo($next_13(tNode$iterator), 78);
    object = $getProperty(tNode, ORIGIN_1);
    if (instanceOf(object, 240)) {
      elknode = castTo(object, 35);
      nodePos = $add_19(tNode.pos, offset);
      $setLocation(elknode, nodePos.x_0 - elknode.width_0 / 2, nodePos.y_0 - elknode.height / 2);
    }
  }
  for (tEdge$iterator = $listIterator_1(tGraph.edges, 0); tEdge$iterator.currentNode != tEdge$iterator.this$01.tail;) {
    tEdge = castTo($next_13(tEdge$iterator), 174);
    elkedge = castTo($getProperty(tEdge, ORIGIN_1), 100);
    if (elkedge) {
      bendPoints = tEdge.bendPoints;
      sourcePoint = new KVector_2(tEdge.source.pos);
      $addNode_0(bendPoints, sourcePoint, bendPoints.header, bendPoints.header.next_0);
      targetPoint = new KVector_2(tEdge.target.pos);
      $addNode_0(bendPoints, targetPoint, bendPoints.tail.prev, bendPoints.tail);
      toNodeBorder(sourcePoint, castTo($get_3(bendPoints, 1), 8), tEdge.source.size_0);
      toNodeBorder(targetPoint, castTo($get_3(bendPoints, bendPoints.size_0 - 2), 8), tEdge.target.size_0);
      edgeSection = firstEdgeSection(elkedge, true, true);
      applyVectorChain(bendPoints, edgeSection);
    }
  }
  width_0 = maxXPos - minXPos + (padding.left + padding.right);
  height = maxYPos - minYPos + (padding.top_0 + padding.bottom);
  resizeNode_1(elkgraph, width_0, height, false, false);
}

function $transformEdges_1(parentNode, tGraph, elemMap){
  var elkedge, elkedge$iterator, elknode, elknode$iterator, newEdge, source, target;
  for (elknode$iterator = new AbstractEList$EIterator((!parentNode.children && (parentNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parentNode, 10, 11)) , parentNode.children)); elknode$iterator.cursor != elknode$iterator.this$01_2.size_1();) {
    elknode = castTo($doNext(elknode$iterator), 35);
    for (elkedge$iterator = $iterator(allOutgoingEdges(elknode)); $hasNext_0(elkedge$iterator);) {
      elkedge = castTo($next_2(elkedge$iterator), 100);
      if (!$isHierarchical(elkedge) && !$isHierarchical(elkedge) && !$isSelfloop(elkedge)) {
        source = castTo(getEntryValueOrNull($getEntry(elemMap.hashCodeMap, elknode)), 78);
        target = castTo($get_6(elemMap, connectableShapeToNode(castTo($get_16((!elkedge.targets && (elkedge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, elkedge, 5, 8)) , elkedge.targets), 0), 97))), 78);
        if (!!source && !!target) {
          newEdge = new TEdge_0(source, target);
          $setProperty_0(newEdge, ($clinit_InternalProperties_2() , ORIGIN_1), elkedge);
          $copyProperties(newEdge, elkedge);
          $add_7(source.outgoingEdges, newEdge);
          $add_7(target.incomingEdges, newEdge);
          $add_7(tGraph.edges, newEdge);
        }
      }
    }
  }
}

function $transformNodes_1(parentNode, tGraph, elemMap){
  var elknode, elknode$iterator, index_0, label_0, newNode;
  index_0 = 0;
  for (elknode$iterator = new AbstractEList$EIterator((!parentNode.children && (parentNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parentNode, 10, 11)) , parentNode.children)); elknode$iterator.cursor != elknode$iterator.this$01_2.size_1();) {
    elknode = castTo($doNext(elknode$iterator), 35);
    label_0 = '';
    (!elknode.labels && (elknode.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, elknode, 1, 7)) , elknode.labels).size_0 == 0 || (label_0 = castTo(castTo($get_16((!elknode.labels && (elknode.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, elknode, 1, 7)) , elknode.labels), 0), 135), 241).text_0);
    newNode = new TNode(index_0++, tGraph, label_0);
    $copyProperties(newNode, elknode);
    $setProperty_0(newNode, ($clinit_InternalProperties_2() , ORIGIN_1), elknode);
    newNode.pos.y_0 = elknode.y_0 + elknode.height / 2;
    newNode.size_0.x_0 = $wnd.Math.max(elknode.width_0, 1);
    newNode.pos.x_0 = elknode.x_0 + elknode.width_0 / 2;
    newNode.size_0.y_0 = $wnd.Math.max(elknode.height, 1);
    $add_7(tGraph.nodes, newNode);
    $put_4(elemMap.hashCodeMap, elknode, newNode);
  }
}

function toNodeBorder(center, next, size_0){
  var absx, absy, hh, scale, wh, xscale, yscale;
  wh = size_0.x_0 / 2;
  hh = size_0.y_0 / 2;
  absx = $wnd.Math.abs(next.x_0 - center.x_0);
  absy = $wnd.Math.abs(next.y_0 - center.y_0);
  xscale = 1;
  yscale = 1;
  absx > wh && (xscale = wh / absx);
  absy > hh && (yscale = hh / absy);
  scale = $wnd.Math.min(xscale, yscale);
  center.x_0 += scale * (next.x_0 - center.x_0);
  center.y_0 += scale * (next.y_0 - center.y_0);
}

function $doLayout_0(this$static, tgraph, progressMonitor){
  $begin(progressMonitor, 'Tree layout', 1);
  $reset_4(this$static.algorithmAssembler);
  $setPhase(this$static.algorithmAssembler, ($clinit_TreeLayoutPhases() , P1_TREEIFICATION), P1_TREEIFICATION);
  $setPhase(this$static.algorithmAssembler, P2_NODE_ORDERING, P2_NODE_ORDERING);
  $setPhase(this$static.algorithmAssembler, P3_NODE_PLACEMENT, P3_NODE_PLACEMENT);
  $setPhase(this$static.algorithmAssembler, P4_EDGE_ROUTING, P4_EDGE_ROUTING);
  this$static.algorithm = $build(this$static.algorithmAssembler, tgraph);
  $layout_2(this$static, tgraph, $subTask(progressMonitor, 1));
  $done_0(progressMonitor);
  return tgraph;
}

function $layout_2(this$static, graph, themonitor){
  var i, monitor, processor, processor$iterator, slot;
  monitor = themonitor;
  !themonitor && (monitor = new BasicProgressMonitor);
  $begin(monitor, 'Layout', this$static.algorithm.array.length);
  if (checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_MrTreeOptions() , DEBUG_MODE_0))))) {
    $clinit_System();
    for (i = 0; i < this$static.algorithm.array.length; i++) {
      slot = (i < 10?'0':'') + i++;
      '   Slot ' + slot + ': ' + $getName(getClass__Ljava_lang_Class___devirtual$(castTo($get_7(this$static.algorithm, i), 45)));
    }
  }
  for (processor$iterator = new ArrayList$1(this$static.algorithm); processor$iterator.i < processor$iterator.this$01.array.length;) {
    processor = castTo($next_10(processor$iterator), 45);
    processor.process(graph, $subTask(monitor, 1));
  }
  $done_0(monitor);
}

function MrTree(){
  this.algorithmAssembler = new AlgorithmAssembler(Lorg_eclipse_elk_alg_mrtree_TreeLayoutPhases_2_classLit);
}

defineClass(1060, 1, {}, MrTree);
var Lorg_eclipse_elk_alg_mrtree_MrTree_2_classLit = createForClass('org.eclipse.elk.alg.mrtree', 'MrTree', 1060);
function $clinit_TreeLayoutPhases(){
  $clinit_TreeLayoutPhases = emptyMethod;
  P1_TREEIFICATION = new TreeLayoutPhases('P1_TREEIFICATION', 0);
  P2_NODE_ORDERING = new TreeLayoutPhases('P2_NODE_ORDERING', 1);
  P3_NODE_PLACEMENT = new TreeLayoutPhases('P3_NODE_PLACEMENT', 2);
  P4_EDGE_ROUTING = new TreeLayoutPhases('P4_EDGE_ROUTING', 3);
}

function $create_8(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new DFSTreeifyer;
    case 1:
      return new NodeOrderer;
    case 2:
      return new NodePlacer;
    case 3:
      return new EdgeRouter;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout phase ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function TreeLayoutPhases(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_66(name_0){
  $clinit_TreeLayoutPhases();
  return valueOf(($clinit_TreeLayoutPhases$Map() , $MAP_54), name_0);
}

function values_62(){
  $clinit_TreeLayoutPhases();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_TreeLayoutPhases_2_classLit, 1), $intern_38, 374, 0, [P1_TREEIFICATION, P2_NODE_ORDERING, P3_NODE_PLACEMENT, P4_EDGE_ROUTING]);
}

defineClass(374, 22, {3:1, 34:1, 22:1, 374:1, 230:1, 231:1}, TreeLayoutPhases);
_.create_1 = function create_20(){
  return $create_8(this);
}
;
_.create_2 = function create_19(){
  return $create_8(this);
}
;
var P1_TREEIFICATION, P2_NODE_ORDERING, P3_NODE_PLACEMENT, P4_EDGE_ROUTING;
var Lorg_eclipse_elk_alg_mrtree_TreeLayoutPhases_2_classLit = createForEnum('org.eclipse.elk.alg.mrtree', 'TreeLayoutPhases', 374, Ljava_lang_Enum_2_classLit, values_62, valueOf_66);
function $clinit_TreeLayoutPhases$Map(){
  $clinit_TreeLayoutPhases$Map = emptyMethod;
  $MAP_54 = createValueOfMap(($clinit_TreeLayoutPhases() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_TreeLayoutPhases_2_classLit, 1), $intern_38, 374, 0, [P1_TREEIFICATION, P2_NODE_ORDERING, P3_NODE_PLACEMENT, P4_EDGE_ROUTING])));
}

var $MAP_54;
function TreeLayoutProvider(){
  this.klayTree = new MrTree;
  this.componentsProcessor = new ComponentsProcessor_1;
}

defineClass(998, 197, $intern_100, TreeLayoutProvider);
_.layout = function layout_3(kgraph, progressMonitor){
  var comp, comp$iterator, components, tGraph, tGraph_0, elemMap;
  tGraph = (tGraph_0 = new TGraph , $copyProperties(tGraph_0, kgraph) , $setProperty_0(tGraph_0, ($clinit_InternalProperties_2() , ORIGIN_1), kgraph) , elemMap = new HashMap , $transformNodes_1(kgraph, tGraph_0, elemMap) , $transformEdges_1(kgraph, tGraph_0, elemMap) , tGraph_0);
  components = $split_4(this.componentsProcessor, tGraph);
  for (comp$iterator = new ArrayList$1(components); comp$iterator.i < comp$iterator.this$01.array.length;) {
    comp = castTo($next_10(comp$iterator), 131);
    $doLayout_0(this.klayTree, comp, $subTask(progressMonitor, 1 / components.array.length));
  }
  tGraph = $pack(components);
  $applyLayout_4(tGraph);
}
;
var Lorg_eclipse_elk_alg_mrtree_TreeLayoutProvider_2_classLit = createForClass('org.eclipse.elk.alg.mrtree', 'TreeLayoutProvider', 998);
function getLeftMost(currentlevel, depth){
  var cN, cN$iterator, d, nextLevel;
  if (0 < (instanceOf(currentlevel, 13)?castTo(currentlevel, 13).size_1():size_16(currentlevel.iterator_0()))) {
    d = depth;
    if (1 < depth) {
      --d;
      nextLevel = new TreeUtil$1;
      for (cN$iterator = currentlevel.iterator_0(); cN$iterator.hasNext_0();) {
        cN = castTo(cN$iterator.next_1(), 78);
        nextLevel = concat_1(nextLevel, new TNode$2(cN));
      }
      return getLeftMost(nextLevel, d);
    }
    if (depth < 0) {
      nextLevel = new TreeUtil$2;
      for (cN$iterator = currentlevel.iterator_0(); cN$iterator.hasNext_0();) {
        cN = castTo(cN$iterator.next_1(), 78);
        nextLevel = concat_1(nextLevel, new TNode$2(cN));
      }
      if (0 < (instanceOf(nextLevel, 13)?castTo(nextLevel, 13).size_1():size_16(nextLevel.iterator_0()))) {
        return getLeftMost(nextLevel, depth);
      }
    }
  }
  return castTo(getNext(currentlevel.iterator_0()), 78);
}

function TreeUtil$1(){
}

defineClass(1635, 1, $intern_27, TreeUtil$1);
_.forEach_0 = function forEach_25(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_65(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4;
}
;
var Lorg_eclipse_elk_alg_mrtree_TreeUtil$1_2_classLit = createForClass('org.eclipse.elk.alg.mrtree', 'TreeUtil/1', 1635);
function TreeUtil$2(){
}

defineClass(1636, 1, $intern_27, TreeUtil$2);
_.forEach_0 = function forEach_26(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_66(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4;
}
;
var Lorg_eclipse_elk_alg_mrtree_TreeUtil$2_2_classLit = createForClass('org.eclipse.elk.alg.mrtree', 'TreeUtil/2', 1636);
defineClass(470, 130, {3:1, 470:1, 94:1, 130:1});
_.id_0 = 0;
var Lorg_eclipse_elk_alg_mrtree_graph_TGraphElement_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.graph', 'TGraphElement', 470);
function TEdge_0(source, target){
  new LinkedList;
  this.bendPoints = new KVectorChain;
  this.source = source;
  this.target = target;
}

defineClass(174, 470, {3:1, 174:1, 470:1, 94:1, 130:1}, TEdge_0);
_.toString_0 = function toString_108(){
  return !!this.source && !!this.target?$toString_11(this.source) + '->' + $toString_11(this.target):'e_' + hashCode__I__devirtual$(this);
}
;
var Lorg_eclipse_elk_alg_mrtree_graph_TEdge_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.graph', 'TEdge', 174);
function TGraph(){
  this.nodes = new LinkedList;
  this.edges = new LinkedList;
  this.nodes = new LinkedList;
  this.edges = new LinkedList;
}

defineClass(131, 130, {3:1, 131:1, 94:1, 130:1}, TGraph);
_.toString_0 = function toString_109(){
  var tEdge, tEdge$iterator, tNode, tNode$iterator, tmp;
  tmp = null;
  for (tNode$iterator = $listIterator_1(this.nodes, 0); tNode$iterator.currentNode != tNode$iterator.this$01.tail;) {
    tNode = castTo($next_13(tNode$iterator), 78);
    tmp += (tNode.label_0 == null || tNode.label_0.length == 0?'n_' + tNode.id_0:'n_' + tNode.label_0) + '\n';
  }
  for (tEdge$iterator = $listIterator_1(this.edges, 0); tEdge$iterator.currentNode != tEdge$iterator.this$01.tail;) {
    tEdge = castTo($next_13(tEdge$iterator), 174);
    tmp += (!!tEdge.source && !!tEdge.target?$toString_11(tEdge.source) + '->' + $toString_11(tEdge.target):'e_' + hashCode__I__devirtual$(tEdge)) + '\n';
  }
  return tmp;
}
;
var Lorg_eclipse_elk_alg_mrtree_graph_TGraph_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.graph', 'TGraph', 131);
defineClass(597, 470, {3:1, 470:1, 597:1, 94:1, 130:1});
var Lorg_eclipse_elk_alg_mrtree_graph_TShape_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.graph', 'TShape', 597);
function $getChildrenCopy(this$static){
  var children, iEdge, iEdge$iterator;
  children = new LinkedList;
  for (iEdge$iterator = $listIterator_1(this$static.outgoingEdges, 0); iEdge$iterator.currentNode != iEdge$iterator.this$01.tail;) {
    iEdge = castTo($next_13(iEdge$iterator), 174);
    $add_7(children, iEdge.target);
  }
  return children;
}

function $getParent(this$static){
  var edges;
  edges = this$static.incomingEdges;
  if (edges.size_0 == 0) {
    return null;
  }
  return castTo($get_3(edges, 0), 174).source;
}

function $toString_11(this$static){
  return this$static.label_0 == null || this$static.label_0.length == 0?'n_' + this$static.id_0:'n_' + this$static.label_0;
}

function TNode(id_0, graph, label_0){
  this.id_0 = id_0;
  this.pos = new KVector;
  this.size_0 = new KVector;
  this.outgoingEdges = new LinkedList;
  this.incomingEdges = new LinkedList;
  this.graph_0 = graph;
  this.label_0 = label_0;
}

defineClass(78, 597, {3:1, 470:1, 78:1, 597:1, 94:1, 130:1}, TNode);
_.toString_0 = function toString_110(){
  return $toString_11(this);
}
;
var Lorg_eclipse_elk_alg_mrtree_graph_TNode_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.graph', 'TNode', 78);
function TNode$2(this$0){
  this.this$01 = this$0;
}

defineClass(242, 1, $intern_27, TNode$2);
_.forEach_0 = function forEach_27(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_67(){
  var edgesIter;
  return edgesIter = $listIterator_1(this.this$01.outgoingEdges, 0) , new TNode$2$1(edgesIter);
}
;
var Lorg_eclipse_elk_alg_mrtree_graph_TNode$2_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.graph', 'TNode/2', 242);
function TNode$2$1(val$edgesIter){
  this.val$edgesIter2 = val$edgesIter;
}

defineClass(345, 1, $intern_4, TNode$2$1);
_.forEachRemaining = function forEachRemaining_44(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_41(){
  return castTo($next_13(this.val$edgesIter2), 174).target;
}
;
_.hasNext_0 = function hasNext_40(){
  return $hasNext_4(this.val$edgesIter2);
}
;
_.remove_0 = function remove_93(){
  $remove_24(this.val$edgesIter2);
}
;
var Lorg_eclipse_elk_alg_mrtree_graph_TNode$2$1_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.graph', 'TNode/2/1', 345);
function $calculateFan(this$static, currentLevel){
  var blockSize, digits, edgesIter, gloValue, i, id_0, index_0, key, locEntry, locEntry$iterator, locFanMap, nextLevel, pId, tChild, tChild$iterator, tNode, tNode$iterator, tNode$iterator0;
  if (currentLevel.size_0 != 0) {
    nextLevel = new LinkedList;
    id_0 = null;
    pId = null;
    digits = round_int($wnd.Math.floor($wnd.Math.log(currentLevel.size_0) * $wnd.Math.LOG10E) + 1);
    index_0 = 0;
    for (tNode$iterator0 = $listIterator_1(currentLevel, 0); tNode$iterator0.currentNode != tNode$iterator0.this$01.tail;) {
      tNode = castTo($next_13(tNode$iterator0), 78);
      if (maskUndefined(pId) !== maskUndefined($getProperty(tNode, ($clinit_InternalProperties_2() , ID)))) {
        pId = castToString($getProperty(tNode, ID));
        index_0 = 0;
      }
      pId != null?(id_0 = pId + formatRight(index_0++, digits)):(id_0 = formatRight(index_0++, digits));
      $setProperty_0(tNode, ID, id_0);
      for (tChild$iterator = (edgesIter = $listIterator_1((new TNode$2(tNode)).this$01.outgoingEdges, 0) , new TNode$2$1(edgesIter)); $hasNext_4(tChild$iterator.val$edgesIter2);) {
        tChild = castTo($next_13(tChild$iterator.val$edgesIter2), 174).target;
        $addNode_0(nextLevel, tChild, nextLevel.tail.prev, nextLevel.tail);
        $setProperty_0(tChild, ID, id_0);
      }
    }
    locFanMap = new HashMap;
    for (i = 0; i < id_0.length - digits; i++) {
      for (tNode$iterator = $listIterator_1(currentLevel, 0); tNode$iterator.currentNode != tNode$iterator.this$01.tail;) {
        tNode = castTo($next_13(tNode$iterator), 78);
        key = $substring_1(castToString($getProperty(tNode, ($clinit_InternalProperties_2() , ID))), 0, i + 1);
        blockSize = (key == null?getEntryValueOrNull($getEntry(locFanMap.hashCodeMap, null)):$get_11(locFanMap.stringMap, key)) != null?castTo(key == null?getEntryValueOrNull($getEntry(locFanMap.hashCodeMap, null)):$get_11(locFanMap.stringMap, key), 21).value_0 + 1:1;
        $putStringValue(locFanMap, key, valueOf_4(blockSize));
      }
    }
    for (locEntry$iterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(locFanMap)).this$01); locEntry$iterator.hasNext;) {
      locEntry = $next_7(locEntry$iterator);
      gloValue = valueOf_4($get_6(this$static.gloDescMap, locEntry.getKey()) != null?castTo($get_6(this$static.gloDescMap, locEntry.getKey()), 21).value_0:0);
      $putStringValue(this$static.gloDescMap, castToString(locEntry.getKey()), valueOf_4(castTo(locEntry.getValue(), 21).value_0 + gloValue.value_0));
      gloValue = castTo($get_6(this$static.gloFanMap, locEntry.getKey()), 21);
      (!gloValue || gloValue.value_0 < castTo(locEntry.getValue(), 21).value_0) && $putStringValue(this$static.gloFanMap, castToString(locEntry.getKey()), castTo(locEntry.getValue(), 21));
    }
    $calculateFan(this$static, nextLevel);
  }
}

function $process_77(this$static, tGraph, progressMonitor){
  var desc, fan, it, key, root, rootLevel, tNode, tNode$iterator;
  $begin(progressMonitor, 'Processor compute fanout', 1);
  $reset(this$static.gloFanMap);
  $reset(this$static.gloDescMap);
  root = null;
  it = $listIterator_1(tGraph.nodes, 0);
  while (!root && it.currentNode != it.this$01.tail) {
    tNode = castTo($next_13(it), 78);
    checkNotNull_1(castToBoolean($getProperty(tNode, ($clinit_InternalProperties_2() , ROOT_0)))) && (root = tNode);
  }
  rootLevel = new LinkedList;
  $addNode_0(rootLevel, root, rootLevel.tail.prev, rootLevel.tail);
  $calculateFan(this$static, rootLevel);
  for (tNode$iterator = $listIterator_1(tGraph.nodes, 0); tNode$iterator.currentNode != tNode$iterator.this$01.tail;) {
    tNode = castTo($next_13(tNode$iterator), 78);
    key = castToString($getProperty(tNode, ($clinit_InternalProperties_2() , ID)));
    fan = $getStringValue(this$static.gloFanMap, key) != null?castTo($getStringValue(this$static.gloFanMap, key), 21).value_0:0;
    $setProperty_0(tNode, FAN, valueOf_4(fan));
    desc = 1 + ($getStringValue(this$static.gloDescMap, key) != null?castTo($getStringValue(this$static.gloDescMap, key), 21).value_0:0);
    $setProperty_0(tNode, DESCENDANTS, valueOf_4(desc));
  }
  $done_0(progressMonitor);
}

function FanProcessor(){
  this.gloFanMap = new HashMap;
  this.gloDescMap = new HashMap;
}

function formatRight(value_0, len){
  var s;
  s = value_0 + '';
  while (s.length < len) {
    s = '0' + s;
  }
  return s;
}

defineClass(1628, 1, $intern_108, FanProcessor);
_.process = function process_71(tGraph, progressMonitor){
  $process_77(this, castTo(tGraph, 131), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_mrtree_intermediate_FanProcessor_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.intermediate', 'FanProcessor', 1628);
function $clinit_IntermediateProcessorStrategy_0(){
  $clinit_IntermediateProcessorStrategy_0 = emptyMethod;
  ROOT_PROC = new IntermediateProcessorStrategy_0('ROOT_PROC', 0);
  FAN_PROC = new IntermediateProcessorStrategy_0('FAN_PROC', 1);
  NEIGHBORS_PROC = new IntermediateProcessorStrategy_0('NEIGHBORS_PROC', 2);
  LEVEL_HEIGHT = new IntermediateProcessorStrategy_0('LEVEL_HEIGHT', 3);
  NODE_POSITION_PROC = new IntermediateProcessorStrategy_0('NODE_POSITION_PROC', 4);
  DETREEIFYING_PROC = new IntermediateProcessorStrategy_0('DETREEIFYING_PROC', 5);
}

function IntermediateProcessorStrategy_0(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_67(name_0){
  $clinit_IntermediateProcessorStrategy_0();
  return valueOf(($clinit_IntermediateProcessorStrategy$Map_0() , $MAP_55), name_0);
}

function values_63(){
  $clinit_IntermediateProcessorStrategy_0();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_intermediate_IntermediateProcessorStrategy_2_classLit, 1), $intern_38, 315, 0, [ROOT_PROC, FAN_PROC, NEIGHBORS_PROC, LEVEL_HEIGHT, NODE_POSITION_PROC, DETREEIFYING_PROC]);
}

defineClass(315, 22, {3:1, 34:1, 22:1, 315:1, 231:1}, IntermediateProcessorStrategy_0);
_.create_1 = function create_21(){
  switch (this.ordinal) {
    case 0:
      return new RootProcessor;
    case 1:
      return new FanProcessor;
    case 2:
      return new NeighborsProcessor;
    case 3:
      return new LevelHeightProcessor;
    case 4:
      return new NodePositionProcessor;
    case 5:
      return new Untreeifyer;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout processor ' + (this.name_0 != null?this.name_0:'' + this.ordinal)));
  }
}
;
var DETREEIFYING_PROC, FAN_PROC, LEVEL_HEIGHT, NEIGHBORS_PROC, NODE_POSITION_PROC, ROOT_PROC;
var Lorg_eclipse_elk_alg_mrtree_intermediate_IntermediateProcessorStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.mrtree.intermediate', 'IntermediateProcessorStrategy', 315, Ljava_lang_Enum_2_classLit, values_63, valueOf_67);
function $clinit_IntermediateProcessorStrategy$Map_0(){
  $clinit_IntermediateProcessorStrategy$Map_0 = emptyMethod;
  $MAP_55 = createValueOfMap(($clinit_IntermediateProcessorStrategy_0() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_intermediate_IntermediateProcessorStrategy_2_classLit, 1), $intern_38, 315, 0, [ROOT_PROC, FAN_PROC, NEIGHBORS_PROC, LEVEL_HEIGHT, NODE_POSITION_PROC, DETREEIFYING_PROC])));
}

var $MAP_55;
function $process_78(this$static, tGraph, progressMonitor){
  var it, root, tNode;
  $begin(progressMonitor, 'Processor determine the height for each level', 1);
  this$static.numberOfNodes = tGraph.nodes.size_0 == 0?1:tGraph.nodes.size_0;
  root = null;
  it = $listIterator_1(tGraph.nodes, 0);
  while (!root && it.currentNode != it.this$01.tail) {
    tNode = castTo($next_13(it), 78);
    checkNotNull_1(castToBoolean($getProperty(tNode, ($clinit_InternalProperties_2() , ROOT_0)))) && (root = tNode);
  }
  !!root && $setNeighbors(this$static, newArrayList_1(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_graph_TNode_2_classLit, 1), $intern_103, 78, 0, [root])), progressMonitor);
  $done_0(progressMonitor);
}

function $setNeighbors(this$static, currentLevel, progressMonitor){
  var cN, cN$iterator, cN$iterator0, height, nextLevel, sT;
  if (!isEmpty_10(currentLevel)) {
    sT = $subTask(progressMonitor, (instanceOf(currentLevel, 13)?castTo(currentLevel, 13).size_1():size_16(currentLevel.iterator_0())) / this$static.numberOfNodes | 0);
    $begin(sT, 'Set neighbors in level', 1);
    nextLevel = new LevelHeightProcessor$1;
    height = 0;
    for (cN$iterator0 = currentLevel.iterator_0(); cN$iterator0.hasNext_0();) {
      cN = castTo(cN$iterator0.next_1(), 78);
      nextLevel = concat_1(nextLevel, new TNode$2(cN));
      height < cN.size_0.y_0 && (height = cN.size_0.y_0);
    }
    for (cN$iterator = currentLevel.iterator_0(); cN$iterator.hasNext_0();) {
      cN = castTo(cN$iterator.next_1(), 78);
      $setProperty_0(cN, ($clinit_InternalProperties_2() , LEVELHEIGHT), height);
    }
    $done_0(sT);
    $setNeighbors(this$static, nextLevel, progressMonitor);
  }
}

function LevelHeightProcessor(){
}

defineClass(1631, 1, $intern_108, LevelHeightProcessor);
_.process = function process_72(tGraph, progressMonitor){
  $process_78(this, castTo(tGraph, 131), progressMonitor);
}
;
_.numberOfNodes = 0;
var Lorg_eclipse_elk_alg_mrtree_intermediate_LevelHeightProcessor_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.intermediate', 'LevelHeightProcessor', 1631);
function LevelHeightProcessor$1(){
}

defineClass(1632, 1, $intern_27, LevelHeightProcessor$1);
_.forEach_0 = function forEach_28(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_68(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4;
}
;
var Lorg_eclipse_elk_alg_mrtree_intermediate_LevelHeightProcessor$1_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.intermediate', 'LevelHeightProcessor/1', 1632);
function $process_79(this$static, tGraph, progressMonitor){
  var it, root, tNode;
  $begin(progressMonitor, 'Processor set neighbors', 1);
  this$static.numberOfNodes = tGraph.nodes.size_0 == 0?1:tGraph.nodes.size_0;
  root = null;
  it = $listIterator_1(tGraph.nodes, 0);
  while (!root && it.currentNode != it.this$01.tail) {
    tNode = castTo($next_13(it), 78);
    checkNotNull_1(castToBoolean($getProperty(tNode, ($clinit_InternalProperties_2() , ROOT_0)))) && (root = tNode);
  }
  !!root && $setNeighbors_0(this$static, new TNode$2(root), progressMonitor);
  $done_0(progressMonitor);
}

function $setNeighbors_0(this$static, currentLevel, progressMonitor){
  var cN, cN$iterator, lN, nextLevel, sT;
  if (!isEmpty_10(currentLevel)) {
    sT = $subTask(progressMonitor, (instanceOf(currentLevel, 13)?castTo(currentLevel, 13).size_1():size_16(currentLevel.iterator_0())) / this$static.numberOfNodes | 0);
    $begin(sT, 'Set neighbors in level', 1);
    nextLevel = new NeighborsProcessor$1;
    lN = null;
    for (cN$iterator = currentLevel.iterator_0(); cN$iterator.hasNext_0();) {
      cN = castTo(cN$iterator.next_1(), 78);
      nextLevel = concat_1(nextLevel, new TNode$2(cN));
      if (lN) {
        $setProperty_0(lN, ($clinit_InternalProperties_2() , RIGHTNEIGHBOR), cN);
        $setProperty_0(cN, LEFTNEIGHBOR, lN);
        if ($getParent(cN) == $getParent(lN)) {
          $setProperty_0(lN, RIGHTSIBLING, cN);
          $setProperty_0(cN, LEFTSIBLING, lN);
        }
      }
      lN = cN;
    }
    $done_0(sT);
    $setNeighbors_0(this$static, nextLevel, progressMonitor);
  }
}

function NeighborsProcessor(){
}

defineClass(1629, 1, $intern_108, NeighborsProcessor);
_.process = function process_73(tGraph, progressMonitor){
  $process_79(this, castTo(tGraph, 131), progressMonitor);
}
;
_.numberOfNodes = 0;
var Lorg_eclipse_elk_alg_mrtree_intermediate_NeighborsProcessor_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.intermediate', 'NeighborsProcessor', 1629);
function NeighborsProcessor$1(){
}

defineClass(1630, 1, $intern_27, NeighborsProcessor$1);
_.forEach_0 = function forEach_29(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_69(){
  return $clinit_Collections() , $clinit_Collections$EmptyListIterator() , INSTANCE_4;
}
;
var Lorg_eclipse_elk_alg_mrtree_intermediate_NeighborsProcessor$1_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.intermediate', 'NeighborsProcessor/1', 1630);
function $process_80(this$static, tGraph, progressMonitor){
  var it, pos, root, tNode;
  $begin(progressMonitor, 'Processor set coordinates', 1);
  this$static.numberOfNodes = tGraph.nodes.size_0 == 0?1:tGraph.nodes.size_0;
  root = null;
  it = $listIterator_1(tGraph.nodes, 0);
  while (!root && it.currentNode != it.this$01.tail) {
    tNode = castTo($next_13(it), 78);
    if (checkNotNull_1(castToBoolean($getProperty(tNode, ($clinit_InternalProperties_2() , ROOT_0))))) {
      root = tNode;
      pos = tNode.pos;
      pos.x_0 = castTo($getProperty(tNode, XCOOR), 21).value_0;
      pos.y_0 = 0;
    }
  }
  $setCoordinates(this$static, $getChildrenCopy(root), $subTask(progressMonitor, 1));
  $done_0(progressMonitor);
}

function $setCoordinates(this$static, currentLevel, progressMonitor){
  var nextLevel, pos, tNode, tNode$iterator;
  if (currentLevel.size_0 != 0) {
    nextLevel = new LinkedList;
    for (tNode$iterator = $listIterator_1(currentLevel, 0); tNode$iterator.currentNode != tNode$iterator.this$01.tail;) {
      tNode = castTo($next_13(tNode$iterator), 78);
      $addAll(nextLevel, $getChildrenCopy(tNode));
      pos = tNode.pos;
      pos.x_0 = castTo($getProperty(tNode, ($clinit_InternalProperties_2() , XCOOR)), 21).value_0;
      pos.y_0 = castTo($getProperty(tNode, YCOOR), 21).value_0;
    }
    $setCoordinates(this$static, nextLevel, $subTask(progressMonitor, nextLevel.size_0 / this$static.numberOfNodes | 0));
  }
}

function NodePositionProcessor(){
}

defineClass(1633, 1, $intern_108, NodePositionProcessor);
_.process = function process_74(tGraph, progressMonitor){
  $process_80(this, castTo(tGraph, 131), progressMonitor);
}
;
_.numberOfNodes = 0;
var Lorg_eclipse_elk_alg_mrtree_intermediate_NodePositionProcessor_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.intermediate', 'NodePositionProcessor', 1633);
function $process_81(this$static, tGraph){
  var node, node$iterator, root, superRoot, tRoot, tRoot$iterator, newEdge;
  this$static.roots.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  for (node$iterator = $listIterator_1(tGraph.nodes, 0); node$iterator.currentNode != node$iterator.this$01.tail;) {
    node = castTo($next_13(node$iterator), 78);
    if (node.incomingEdges.size_0 == 0) {
      $setProperty_0(node, ($clinit_InternalProperties_2() , ROOT_0), ($clinit_Boolean() , $clinit_Boolean() , true));
      $add_4(this$static.roots, node);
    }
  }
  switch (this$static.roots.array.length) {
    case 0:
      root = new TNode(0, tGraph, 'DUMMY_ROOT');
      $setProperty_0(root, ($clinit_InternalProperties_2() , ROOT_0), ($clinit_Boolean() , $clinit_Boolean() , true));
      $setProperty_0(root, DUMMY, (null , true));
      $add_7(tGraph.nodes, root);
      break;
    case 1:
      break;
    default:superRoot = new TNode(0, tGraph, 'SUPER_ROOT');
      for (tRoot$iterator = new ArrayList$1(this$static.roots); tRoot$iterator.i < tRoot$iterator.this$01.array.length;) {
        tRoot = castTo($next_10(tRoot$iterator), 78);
        newEdge = new TEdge_0(superRoot, tRoot);
        $setProperty_0(newEdge, ($clinit_InternalProperties_2() , DUMMY), ($clinit_Boolean() , $clinit_Boolean() , true));
        $add_7(superRoot.graph_0.edges, newEdge);
        $add_7(superRoot.outgoingEdges, newEdge);
        $add_7(tRoot.incomingEdges, newEdge);
        $setProperty_0(tRoot, ROOT_0, (null , false));
      }

      $setProperty_0(superRoot, ($clinit_InternalProperties_2() , ROOT_0), ($clinit_Boolean() , $clinit_Boolean() , true));
      $setProperty_0(superRoot, DUMMY, (null , true));
      $add_7(tGraph.nodes, superRoot);
  }
}

function RootProcessor(){
  this.roots = new ArrayList;
}

defineClass(1627, 1, $intern_108, RootProcessor);
_.process = function process_75(tGraph, progressMonitor){
  $process_81(this, castTo(tGraph, 131));
}
;
var Lorg_eclipse_elk_alg_mrtree_intermediate_RootProcessor_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.intermediate', 'RootProcessor', 1627);
function $process_82(tGraph){
  var edges, tEdge, tEdge$iterator;
  edges = castTo($getProperty(tGraph, ($clinit_InternalProperties_2() , REMOVABLE_EDGES)), 15);
  for (tEdge$iterator = edges.iterator_0(); tEdge$iterator.hasNext_0();) {
    tEdge = castTo(tEdge$iterator.next_1(), 174);
    $add_7(tEdge.source.outgoingEdges, tEdge);
    $add_7(tEdge.target.incomingEdges, tEdge);
  }
}

function Untreeifyer(){
}

defineClass(1634, 1, $intern_108, Untreeifyer);
_.process = function process_76(tGraph, progressMonitor){
  $process_82(castTo(tGraph, 131));
}
;
var Lorg_eclipse_elk_alg_mrtree_intermediate_Untreeifyer_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.intermediate', 'Untreeifyer', 1634);
function $clinit_InternalProperties_2(){
  $clinit_InternalProperties_2 = emptyMethod;
  ORIGIN_1 = new Property('origin');
  new Property('random');
  new Property_0('DEPTH', valueOf_4(0));
  FAN = new Property_0('FAN', valueOf_4(0));
  DESCENDANTS = new Property_0('DESCENDANTS', valueOf_4(0));
  ROOT_0 = new Property_0('ROOT', ($clinit_Boolean() , $clinit_Boolean() , false));
  LEFTNEIGHBOR = new Property_0('LEFTNEIGHBOR', null);
  RIGHTNEIGHBOR = new Property_0('RIGHTNEIGHBOR', null);
  LEFTSIBLING = new Property_0('LEFTSIBLING', null);
  RIGHTSIBLING = new Property_0('RIGHTSIBLING', null);
  DUMMY = new Property_0('DUMMY', (null , false));
  new Property_0('LEVEL', valueOf_4(0));
  REMOVABLE_EDGES = new Property_0('REMOVABLE_EDGES', new LinkedList);
  XCOOR = new Property_0('XCOOR', valueOf_4(0));
  YCOOR = new Property_0('YCOOR', valueOf_4(0));
  LEVELHEIGHT = new Property_0('LEVELHEIGHT', 0);
  ID = new Property_0('ID', '');
  POSITION_0 = new Property_0('POSITION', valueOf_4(0));
  PRELIM = new Property_0('PRELIM', 0);
  MODIFIER = new Property_0('MODIFIER', 0);
  BB_UPLEFT_0 = new Property('boundingBox.upLeft');
  BB_LOWRIGHT_0 = new Property('boundingBox.lowRight');
}

var BB_LOWRIGHT_0, BB_UPLEFT_0, DESCENDANTS, DUMMY, FAN, ID, LEFTNEIGHBOR, LEFTSIBLING, LEVELHEIGHT, MODIFIER, ORIGIN_1, POSITION_0, PRELIM, REMOVABLE_EDGES, RIGHTNEIGHBOR, RIGHTSIBLING, ROOT_0, XCOOR, YCOOR;
function $clinit_MrTreeMetaDataProvider(){
  $clinit_MrTreeMetaDataProvider = emptyMethod;
  WEIGHTING_DEFAULT = ($clinit_OrderWeighting() , DESCENDANTS_0);
  WEIGHTING = new Property_1('org.eclipse.elk.mrtree.weighting', WEIGHTING_DEFAULT);
  SEARCH_ORDER_DEFAULT = ($clinit_TreeifyingOrder() , DFS);
  SEARCH_ORDER = new Property_1('org.eclipse.elk.mrtree.searchOrder', SEARCH_ORDER_DEFAULT);
}

function MrTreeMetaDataProvider(){
  $clinit_MrTreeMetaDataProvider();
}

defineClass(781, 1, $intern_92, MrTreeMetaDataProvider);
_.apply_3 = function apply_134(registry){
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.mrtree.weighting'), ''), 'Weighting of Nodes'), 'Which weighting to use when computing a node order.'), WEIGHTING_DEFAULT), ($clinit_LayoutOptionData$Type() , ENUM)), Lorg_eclipse_elk_alg_mrtree_options_OrderWeighting_2_classLit), of_0(($clinit_LayoutOptionData$Target() , PARENTS)))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.mrtree.searchOrder'), ''), 'Search Order'), 'Which search order to use when computing a spanning tree.'), SEARCH_ORDER_DEFAULT), ENUM), Lorg_eclipse_elk_alg_mrtree_options_TreeifyingOrder_2_classLit), of_0(PARENTS))));
  $apply_24((new MrTreeOptions , registry));
}
;
var SEARCH_ORDER, SEARCH_ORDER_DEFAULT, WEIGHTING, WEIGHTING_DEFAULT;
var Lorg_eclipse_elk_alg_mrtree_options_MrTreeMetaDataProvider_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.options', 'MrTreeMetaDataProvider', 781);
function $clinit_MrTreeOptions(){
  $clinit_MrTreeOptions = emptyMethod;
  PADDING_DEFAULT_1 = new ElkPadding_0(20);
  PADDING_2 = new Property_2(($clinit_CoreOptions() , PADDING_5), PADDING_DEFAULT_1);
  SPACING_NODE_NODE_1 = new Property_2(SPACING_NODE_NODE_5, 20);
  ASPECT_RATIO_2 = new Property_2(ASPECT_RATIO_4, $intern_105);
  PRIORITY_1 = new Property_2(PRIORITY_3, valueOf_4(1));
  SEPARATE_CONNECTED_COMPONENTS_1 = new Property_2(SEPARATE_CONNECTED_COMPONENTS_2, ($clinit_Boolean() , $clinit_Boolean() , true));
  DEBUG_MODE_0 = DEBUG_MODE_3;
  WEIGHTING_0 = ($clinit_MrTreeMetaDataProvider() , WEIGHTING);
  SEARCH_ORDER_0 = SEARCH_ORDER;
}

function $apply_24(registry){
  $register(registry, new LayoutAlgorithmData($supportedFeatures($category($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.mrtree'), 'ELK Mr. Tree'), "Tree-based algorithm provided by the Eclipse Layout Kernel. Computes a spanning tree of the input graph and arranges all nodes according to the resulting parent-children hierarchy. I pity the fool who doesn't use Mr. Tree Layout."), new MrTreeOptions$MrtreeFactory), 'org.eclipse.elk.tree'), of_0(($clinit_GraphFeature() , DISCONNECTED)))));
  $addOptionSupport(registry, 'org.eclipse.elk.mrtree', 'org.eclipse.elk.padding', PADDING_DEFAULT_1);
  $addOptionSupport(registry, 'org.eclipse.elk.mrtree', 'org.eclipse.elk.spacing.nodeNode', 20);
  $addOptionSupport(registry, 'org.eclipse.elk.mrtree', 'org.eclipse.elk.aspectRatio', $intern_105);
  $addOptionSupport(registry, 'org.eclipse.elk.mrtree', 'org.eclipse.elk.priority', valueOf_4(1));
  $addOptionSupport(registry, 'org.eclipse.elk.mrtree', 'org.eclipse.elk.separateConnectedComponents', ($clinit_Boolean() , $clinit_Boolean() , true));
  $addOptionSupport(registry, 'org.eclipse.elk.mrtree', 'org.eclipse.elk.debugMode', $getDefault(DEBUG_MODE_0));
  $addOptionSupport(registry, 'org.eclipse.elk.mrtree', 'org.eclipse.elk.mrtree.weighting', $getDefault(WEIGHTING_0));
  $addOptionSupport(registry, 'org.eclipse.elk.mrtree', 'org.eclipse.elk.mrtree.searchOrder', $getDefault(SEARCH_ORDER_0));
}

function MrTreeOptions(){
  $clinit_MrTreeOptions();
}

defineClass(920, 1, $intern_92, MrTreeOptions);
_.apply_3 = function apply_135(registry){
  $apply_24(registry);
}
;
var ASPECT_RATIO_2, DEBUG_MODE_0, PADDING_2, PADDING_DEFAULT_1, PRIORITY_1, SEARCH_ORDER_0, SEPARATE_CONNECTED_COMPONENTS_1, SPACING_NODE_NODE_1, WEIGHTING_0;
var Lorg_eclipse_elk_alg_mrtree_options_MrTreeOptions_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.options', 'MrTreeOptions', 920);
function MrTreeOptions$MrtreeFactory(){
}

defineClass(921, 1, {}, MrTreeOptions$MrtreeFactory);
_.create_0 = function create_22(){
  var provider;
  return provider = new TreeLayoutProvider , provider;
}
;
_.destroy = function destroy_3(obj){
}
;
var Lorg_eclipse_elk_alg_mrtree_options_MrTreeOptions$MrtreeFactory_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.options', 'MrTreeOptions/MrtreeFactory', 921);
function $clinit_OrderWeighting(){
  $clinit_OrderWeighting = emptyMethod;
  DESCENDANTS_0 = new OrderWeighting('DESCENDANTS', 0);
  FAN_0 = new OrderWeighting('FAN', 1);
}

function OrderWeighting(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_68(name_0){
  $clinit_OrderWeighting();
  return valueOf(($clinit_OrderWeighting$Map() , $MAP_56), name_0);
}

function values_64(){
  $clinit_OrderWeighting();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_options_OrderWeighting_2_classLit, 1), $intern_38, 453, 0, [DESCENDANTS_0, FAN_0]);
}

defineClass(453, 22, {3:1, 34:1, 22:1, 453:1}, OrderWeighting);
var DESCENDANTS_0, FAN_0;
var Lorg_eclipse_elk_alg_mrtree_options_OrderWeighting_2_classLit = createForEnum('org.eclipse.elk.alg.mrtree.options', 'OrderWeighting', 453, Ljava_lang_Enum_2_classLit, values_64, valueOf_68);
function $clinit_OrderWeighting$Map(){
  $clinit_OrderWeighting$Map = emptyMethod;
  $MAP_56 = createValueOfMap(($clinit_OrderWeighting() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_options_OrderWeighting_2_classLit, 1), $intern_38, 453, 0, [DESCENDANTS_0, FAN_0])));
}

var $MAP_56;
function $clinit_TreeifyingOrder(){
  $clinit_TreeifyingOrder = emptyMethod;
  DFS = new TreeifyingOrder('DFS', 0);
  BFS = new TreeifyingOrder('BFS', 1);
}

function TreeifyingOrder(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_69(name_0){
  $clinit_TreeifyingOrder();
  return valueOf(($clinit_TreeifyingOrder$Map() , $MAP_57), name_0);
}

function values_65(){
  $clinit_TreeifyingOrder();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_options_TreeifyingOrder_2_classLit, 1), $intern_38, 404, 0, [DFS, BFS]);
}

defineClass(404, 22, {3:1, 34:1, 22:1, 404:1}, TreeifyingOrder);
var BFS, DFS;
var Lorg_eclipse_elk_alg_mrtree_options_TreeifyingOrder_2_classLit = createForEnum('org.eclipse.elk.alg.mrtree.options', 'TreeifyingOrder', 404, Ljava_lang_Enum_2_classLit, values_65, valueOf_69);
function $clinit_TreeifyingOrder$Map(){
  $clinit_TreeifyingOrder$Map = emptyMethod;
  $MAP_57 = createValueOfMap(($clinit_TreeifyingOrder() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_mrtree_options_TreeifyingOrder_2_classLit, 1), $intern_38, 404, 0, [DFS, BFS])));
}

var $MAP_57;
function $clinit_DFSTreeifyer(){
  $clinit_DFSTreeifyer = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIG = $addAfter(new LayoutProcessorConfiguration, ($clinit_TreeLayoutPhases() , P4_EDGE_ROUTING), ($clinit_IntermediateProcessorStrategy_0() , DETREEIFYING_PROC));
}

function $bfs(this$static, startNode){
  var node, nodeQueue, tEdge, tEdge$iterator, target;
  nodeQueue = new LinkedList;
  $addNode_0(nodeQueue, startNode, nodeQueue.tail.prev, nodeQueue.tail);
  do {
    node = (checkCriticalElement(nodeQueue.size_0 != 0) , castTo($removeNode_0(nodeQueue, nodeQueue.header.next_0), 78));
    this$static.visited[node.id_0] = 1;
    for (tEdge$iterator = $listIterator_1(node.outgoingEdges, 0); tEdge$iterator.currentNode != tEdge$iterator.this$01.tail;) {
      tEdge = castTo($next_13(tEdge$iterator), 174);
      target = tEdge.target;
      this$static.visited[target.id_0] == 1?$add_7(this$static.eliminated, tEdge):this$static.visited[target.id_0] == 2?(this$static.visited[target.id_0] = 1):$addNode_0(nodeQueue, target, nodeQueue.tail.prev, nodeQueue.tail);
    }
  }
   while (nodeQueue.size_0 != 0);
}

function $collectEdges(this$static, tGraph){
  var tEdge, tEdge$iterator, tNode, tNode$iterator, treeifyingOrder;
  treeifyingOrder = castTo($getProperty(tGraph, ($clinit_MrTreeOptions() , SEARCH_ORDER_0)), 404);
  for (tNode$iterator = $listIterator_1(tGraph.nodes, 0); tNode$iterator.currentNode != tNode$iterator.this$01.tail;) {
    tNode = castTo($next_13(tNode$iterator), 78);
    if (this$static.visited[tNode.id_0] == 0) {
      switch (treeifyingOrder.ordinal) {
        case 0:
          $dfs_6(this$static, tNode);
          break;
        case 1:
          $bfs(this$static, tNode);
      }
      this$static.visited[tNode.id_0] = 2;
    }
  }
  for (tEdge$iterator = $listIterator_1(this$static.eliminated, 0); tEdge$iterator.currentNode != tEdge$iterator.this$01.tail;) {
    tEdge = castTo($next_13(tEdge$iterator), 174);
    $advanceToFind(tEdge.source.outgoingEdges, tEdge, true);
    $advanceToFind(tEdge.target.incomingEdges, tEdge, true);
  }
  $setProperty_0(tGraph, ($clinit_InternalProperties_2() , REMOVABLE_EDGES), this$static.eliminated);
}

function $dfs_6(this$static, tNode){
  var tEdge, tEdge$iterator, target;
  this$static.visited[tNode.id_0] = 1;
  for (tEdge$iterator = $listIterator_1(tNode.outgoingEdges, 0); tEdge$iterator.currentNode != tEdge$iterator.this$01.tail;) {
    tEdge = castTo($next_13(tEdge$iterator), 174);
    target = tEdge.target;
    this$static.visited[target.id_0] == 1?$add_7(this$static.eliminated, tEdge):this$static.visited[target.id_0] == 2?(this$static.visited[target.id_0] = 1):$dfs_6(this$static, target);
  }
}

function $init_1(this$static, tGraph){
  var id_0, node, node$iterator, size_0;
  size_0 = tGraph.nodes.size_0;
  this$static.eliminated = new LinkedList;
  this$static.visited = initUnidimensionalArray(I_classLit, $intern_49, 23, size_0, 15, 1);
  id_0 = 0;
  for (node$iterator = $listIterator_1(tGraph.nodes, 0); node$iterator.currentNode != node$iterator.this$01.tail;) {
    node = castTo($next_13(node$iterator), 78);
    node.id_0 = id_0++;
  }
}

function $process_83(this$static, tGraph, progressMonitor){
  $begin(progressMonitor, 'DFS Treeifying phase', 1);
  $init_1(this$static, tGraph);
  $collectEdges(this$static, tGraph);
  this$static.eliminated = null;
  this$static.visited = null;
  $done_0(progressMonitor);
}

function DFSTreeifyer(){
  $clinit_DFSTreeifyer();
}

defineClass(1330, 1, $intern_117, DFSTreeifyer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_18(graph){
  return castTo(graph, 131) , INTERMEDIATE_PROCESSING_CONFIG;
}
;
_.process = function process_77(tGraph, progressMonitor){
  $process_83(this, castTo(tGraph, 131), progressMonitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIG;
var Lorg_eclipse_elk_alg_mrtree_p1treeify_DFSTreeifyer_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.p1treeify', 'DFSTreeifyer', 1330);
function $clinit_NodeOrderer(){
  $clinit_NodeOrderer = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIG_0 = $add_17($add_17($before(new LayoutProcessorConfiguration, ($clinit_TreeLayoutPhases() , P2_NODE_ORDERING)), ($clinit_IntermediateProcessorStrategy_0() , ROOT_PROC)), FAN_PROC);
}

function $orderLevel(this$static, currentLevel, progressMonitor){
  var children, fillGap, firstOcc, inners, it, leaves, notNull, pos, size_0, sortedOutEdges, tENode, tENode$iterator, tEdge, tEdge$iterator, tNode, tNode$iterator, tPNode, tPNode$iterator, tmp;
  $begin(progressMonitor, 'Processor arrange level', 1);
  pos = 0;
  $clinit_Collections();
  $sort_0(currentLevel, new PropertyHolderComparator(($clinit_InternalProperties_2() , FAN)));
  firstOcc = currentLevel.size_0;
  it = $listIterator_1(currentLevel, currentLevel.size_0);
  notNull = true;
  while (notNull && it.currentNode.prev != it.this$01.header) {
    tNode = castTo($previous_1(it), 78);
    castTo($getProperty(tNode, FAN), 21).value_0 == 0?--firstOcc:(notNull = false);
  }
  tmp = new AbstractList$SubList(currentLevel, 0, firstOcc);
  inners = new LinkedList_0(tmp);
  tmp = new AbstractList$SubList(currentLevel, firstOcc, currentLevel.size_0);
  leaves = new LinkedList_0(tmp);
  if (inners.size_0 == 0) {
    for (tENode$iterator = $listIterator_1(leaves, 0); tENode$iterator.currentNode != tENode$iterator.this$01.tail;) {
      tENode = castTo($next_13(tENode$iterator), 78);
      $setProperty_0(tENode, POSITION_0, valueOf_4(pos++));
    }
  }
   else {
    size_0 = inners.size_0;
    for (tPNode$iterator = $listIterator_1(inners, 0); tPNode$iterator.currentNode != tPNode$iterator.this$01.tail;) {
      tPNode = castTo($next_13(tPNode$iterator), 78);
      $setProperty_0(tPNode, POSITION_0, valueOf_4(pos++));
      children = $getChildrenCopy(tPNode);
      $orderLevel(this$static, children, $subTask(progressMonitor, 1 / size_0 | 0));
      $sort_0(children, reverseOrder(new PropertyHolderComparator(POSITION_0)));
      sortedOutEdges = new LinkedList;
      for (tNode$iterator = $listIterator_1(children, 0); tNode$iterator.currentNode != tNode$iterator.this$01.tail;) {
        tNode = castTo($next_13(tNode$iterator), 78);
        for (tEdge$iterator = $listIterator_1(tPNode.outgoingEdges, 0); tEdge$iterator.currentNode != tEdge$iterator.this$01.tail;) {
          tEdge = castTo($next_13(tEdge$iterator), 174);
          tEdge.target == tNode && ($addNode_0(sortedOutEdges, tEdge, sortedOutEdges.tail.prev, sortedOutEdges.tail) , true);
        }
      }
      $reset_0(tPNode.outgoingEdges);
      $addAll(tPNode.outgoingEdges, sortedOutEdges);
      it = $listIterator_1(leaves, leaves.size_0);
      fillGap = tPNode.outgoingEdges.size_0;
      notNull = true;
      while (0 < fillGap && notNull && it.currentNode.prev != it.this$01.header) {
        tNode = castTo($previous_1(it), 78);
        if (castTo($getProperty(tNode, FAN), 21).value_0 == 0) {
          $setProperty_0(tNode, POSITION_0, valueOf_4(pos++));
          --fillGap;
          $remove_24(it);
        }
         else {
          notNull = false;
        }
      }
    }
  }
  $done_0(progressMonitor);
}

function $process_84(this$static, tGraph, progressMonitor){
  var it, root, roots, tNode;
  $begin(progressMonitor, 'Processor arrange node', 1);
  root = null;
  roots = new LinkedList;
  it = $listIterator_1(tGraph.nodes, 0);
  while (!root && it.currentNode != it.this$01.tail) {
    tNode = castTo($next_13(it), 78);
    checkNotNull_1(castToBoolean($getProperty(tNode, ($clinit_InternalProperties_2() , ROOT_0)))) && (root = tNode);
  }
  $addNode_0(roots, root, roots.tail.prev, roots.tail);
  $orderLevel(this$static, roots, $subTask(progressMonitor, 1));
  $done_0(progressMonitor);
}

function NodeOrderer(){
  $clinit_NodeOrderer();
}

defineClass(1331, 1, $intern_117, NodeOrderer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_19(graph){
  return castTo(graph, 131) , INTERMEDIATE_PROCESSING_CONFIG_0;
}
;
_.process = function process_78(tGraph, progressMonitor){
  $process_84(this, castTo(tGraph, 131), progressMonitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIG_0;
var Lorg_eclipse_elk_alg_mrtree_p2order_NodeOrderer_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.p2order', 'NodeOrderer', 1331);
function $clinit_NodePlacer(){
  $clinit_NodePlacer = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIG_1 = $addBefore($add_17($add_17($before($addBefore(new LayoutProcessorConfiguration, ($clinit_TreeLayoutPhases() , P2_NODE_ORDERING), ($clinit_IntermediateProcessorStrategy_0() , ROOT_PROC)), P3_NODE_PLACEMENT), LEVEL_HEIGHT), NEIGHBORS_PROC), P4_EDGE_ROUTING, NODE_POSITION_PROC);
}

function $apportion(this$static, cN){
  var ancestorLeftmost, ancestorNeighbor, compareDepth, edgesIter, edgesIter0, i, leftModSum, leftSibling, leftSiblings, leftmost, mean, moveDistance, neighbor, newMod, newPr, portion, prL, prN, rightModSum;
  leftmost = castTo(getNext((edgesIter0 = $listIterator_1((new TNode$2(cN)).this$01.outgoingEdges, 0) , new TNode$2$1(edgesIter0))), 78);
  neighbor = leftmost?castTo($getProperty(leftmost, ($clinit_InternalProperties_2() , LEFTNEIGHBOR)), 78):null;
  compareDepth = 1;
  while (!!leftmost && !!neighbor) {
    leftModSum = 0;
    rightModSum = 0;
    ancestorLeftmost = leftmost;
    ancestorNeighbor = neighbor;
    for (i = 0; i < compareDepth; i++) {
      ancestorLeftmost = $getParent(ancestorLeftmost);
      ancestorNeighbor = $getParent(ancestorNeighbor);
      rightModSum += checkNotNull_1(castToDouble($getProperty(ancestorLeftmost, ($clinit_InternalProperties_2() , MODIFIER))));
      leftModSum += checkNotNull_1(castToDouble($getProperty(ancestorNeighbor, MODIFIER)));
    }
    prN = checkNotNull_1(castToDouble($getProperty(neighbor, ($clinit_InternalProperties_2() , PRELIM))));
    prL = checkNotNull_1(castToDouble($getProperty(leftmost, PRELIM)));
    mean = $meanNodeWidth(leftmost, neighbor);
    moveDistance = prN + leftModSum + this$static.spacing + mean - prL - rightModSum;
    if (0 < moveDistance) {
      leftSibling = cN;
      leftSiblings = 0;
      while (!!leftSibling && leftSibling != ancestorNeighbor) {
        ++leftSiblings;
        leftSibling = castTo($getProperty(leftSibling, LEFTSIBLING), 78);
      }
      if (leftSibling) {
        portion = moveDistance / leftSiblings;
        leftSibling = cN;
        while (leftSibling != ancestorNeighbor) {
          newPr = checkNotNull_1(castToDouble($getProperty(leftSibling, PRELIM))) + moveDistance;
          $setProperty_0(leftSibling, PRELIM, newPr);
          newMod = checkNotNull_1(castToDouble($getProperty(leftSibling, MODIFIER))) + moveDistance;
          $setProperty_0(leftSibling, MODIFIER, newMod);
          moveDistance -= portion;
          leftSibling = castTo($getProperty(leftSibling, LEFTSIBLING), 78);
        }
      }
       else {
        return;
      }
    }
    ++compareDepth;
    leftmost.outgoingEdges.size_0 == 0?(leftmost = getLeftMost(new TNode$2(cN), compareDepth)):(leftmost = castTo(getNext((edgesIter = $listIterator_1((new TNode$2(leftmost)).this$01.outgoingEdges, 0) , new TNode$2$1(edgesIter))), 78));
    neighbor = leftmost?castTo($getProperty(leftmost, LEFTNEIGHBOR), 78):null;
  }
}

function $firstWalk(this$static, cN){
  var child, child$iterator, edgesIter, edgesIter0, edgesIter1, lM, lS, midPoint, p, rM;
  $setProperty_0(cN, ($clinit_InternalProperties_2() , MODIFIER), 0);
  lS = castTo($getProperty(cN, LEFTSIBLING), 78);
  if (cN.outgoingEdges.size_0 == 0) {
    if (lS) {
      p = checkNotNull_1(castToDouble($getProperty(lS, PRELIM))) + this$static.spacing + $meanNodeWidth(lS, cN);
      $setProperty_0(cN, PRELIM, p);
    }
     else {
      $setProperty_0(cN, PRELIM, 0);
    }
  }
   else {
    for (child$iterator = (edgesIter0 = $listIterator_1((new TNode$2(cN)).this$01.outgoingEdges, 0) , new TNode$2$1(edgesIter0)); $hasNext_4(child$iterator.val$edgesIter2);) {
      child = castTo($next_13(child$iterator.val$edgesIter2), 174).target;
      $firstWalk(this$static, child);
    }
    lM = castTo(getNext((edgesIter1 = $listIterator_1((new TNode$2(cN)).this$01.outgoingEdges, 0) , new TNode$2$1(edgesIter1))), 78);
    rM = castTo(getLast_1((edgesIter = $listIterator_1((new TNode$2(cN)).this$01.outgoingEdges, 0) , new TNode$2$1(edgesIter))), 78);
    midPoint = (checkNotNull_1(castToDouble($getProperty(rM, PRELIM))) + checkNotNull_1(castToDouble($getProperty(lM, PRELIM)))) / 2;
    if (lS) {
      p = checkNotNull_1(castToDouble($getProperty(lS, PRELIM))) + this$static.spacing + $meanNodeWidth(lS, cN);
      $setProperty_0(cN, PRELIM, p);
      $setProperty_0(cN, MODIFIER, checkNotNull_1(castToDouble($getProperty(cN, PRELIM))) - midPoint);
      $apportion(this$static, cN);
    }
     else {
      $setProperty_0(cN, PRELIM, midPoint);
    }
  }
}

function $meanNodeWidth(leftNode, rightNode){
  var nodeWidth;
  nodeWidth = 0;
  !!leftNode && (nodeWidth += leftNode.size_0.x_0 / 2);
  !!rightNode && (nodeWidth += rightNode.size_0.x_0 / 2);
  return nodeWidth;
}

function $process_85(this$static, tGraph, progressMonitor){
  var root, roots, tNode, tNode$iterator;
  $begin(progressMonitor, 'Processor order nodes', 2);
  this$static.spacing = checkNotNull_1(castToDouble($getProperty(tGraph, ($clinit_MrTreeOptions() , SPACING_NODE_NODE_1))));
  roots = new LinkedList;
  for (tNode$iterator = $listIterator_1(tGraph.nodes, 0); tNode$iterator.currentNode != tNode$iterator.this$01.tail;) {
    tNode = castTo($next_13(tNode$iterator), 78);
    checkNotNull_1(castToBoolean($getProperty(tNode, ($clinit_InternalProperties_2() , ROOT_0)))) && ($addNode_0(roots, tNode, roots.tail.prev, roots.tail) , true);
  }
  root = (checkCriticalElement(roots.size_0 != 0) , castTo(roots.header.next_0.value_0, 78));
  $firstWalk(this$static, root);
  !progressMonitor.closed_0 && $internalWorked(progressMonitor, 1);
  $secondWalk(this$static, root, 0 - checkNotNull_1(castToDouble($getProperty(root, ($clinit_InternalProperties_2() , LEVELHEIGHT)))) / 2, 0);
  !progressMonitor.closed_0 && $internalWorked(progressMonitor, 1);
  $done_0(progressMonitor);
}

function $secondWalk(this$static, tNode, yCoor, modsum){
  var edgesIter, xTemp, yTemp;
  if (tNode) {
    xTemp = checkNotNull_1(castToDouble($getProperty(tNode, ($clinit_InternalProperties_2() , PRELIM)))) + modsum;
    yTemp = yCoor + checkNotNull_1(castToDouble($getProperty(tNode, LEVELHEIGHT))) / 2;
    $setProperty_0(tNode, XCOOR, valueOf_4(toInt_0(fromDouble_0($wnd.Math.round(xTemp)))));
    $setProperty_0(tNode, YCOOR, valueOf_4(toInt_0(fromDouble_0($wnd.Math.round(yTemp)))));
    tNode.outgoingEdges.size_0 == 0 || $secondWalk(this$static, castTo(getNext((edgesIter = $listIterator_1((new TNode$2(tNode)).this$01.outgoingEdges, 0) , new TNode$2$1(edgesIter))), 78), yCoor + checkNotNull_1(castToDouble($getProperty(tNode, LEVELHEIGHT))) + this$static.spacing, modsum + checkNotNull_1(castToDouble($getProperty(tNode, MODIFIER))));
    $getProperty(tNode, RIGHTSIBLING) != null && $secondWalk(this$static, castTo($getProperty(tNode, RIGHTSIBLING), 78), yCoor, modsum);
  }
}

function NodePlacer(){
  $clinit_NodePlacer();
}

defineClass(1332, 1, $intern_117, NodePlacer);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_20(graph){
  return castTo(graph, 131) , INTERMEDIATE_PROCESSING_CONFIG_1;
}
;
_.process = function process_79(tGraph, progressMonitor){
  $process_85(this, castTo(tGraph, 131), progressMonitor);
}
;
_.spacing = 0;
var INTERMEDIATE_PROCESSING_CONFIG_1;
var Lorg_eclipse_elk_alg_mrtree_p3place_NodePlacer_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.p3place', 'NodePlacer', 1332);
function $clinit_EdgeRouter(){
  $clinit_EdgeRouter = emptyMethod;
  INTERMEDIATE_PROCESSING_CONFIG_2 = new LayoutProcessorConfiguration;
}

function $process_86(tGraph, progressMonitor){
  var tedge, tedge$iterator, tnode, tnode$iterator;
  $begin(progressMonitor, 'Dull edge routing', 1);
  for (tnode$iterator = $listIterator_1(tGraph.nodes, 0); tnode$iterator.currentNode != tnode$iterator.this$01.tail;) {
    tnode = castTo($next_13(tnode$iterator), 78);
    for (tedge$iterator = $listIterator_1(tnode.outgoingEdges, 0); tedge$iterator.currentNode != tedge$iterator.this$01.tail;) {
      tedge = castTo($next_13(tedge$iterator), 174);
      $reset_0(tedge.bendPoints);
    }
  }
}

function EdgeRouter(){
  $clinit_EdgeRouter();
}

defineClass(1333, 1, $intern_117, EdgeRouter);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_21(graph){
  return castTo(graph, 131) , INTERMEDIATE_PROCESSING_CONFIG_2;
}
;
_.process = function process_80(tGraph, progressMonitor){
  $process_86(castTo(tGraph, 131), progressMonitor);
}
;
var INTERMEDIATE_PROCESSING_CONFIG_2;
var Lorg_eclipse_elk_alg_mrtree_p4route_EdgeRouter_2_classLit = createForClass('org.eclipse.elk.alg.mrtree.p4route', 'EdgeRouter', 1333);
function $clinit_InternalProperties_3(){
  $clinit_InternalProperties_3 = emptyMethod;
  ROOT_NODE = new Property('root');
}

var ROOT_NODE;
function $clinit_RadialLayoutPhases(){
  $clinit_RadialLayoutPhases = emptyMethod;
  P1_NODE_PLACEMENT = new RadialLayoutPhases('P1_NODE_PLACEMENT', 0);
  P2_EDGE_ROUTING = new RadialLayoutPhases('P2_EDGE_ROUTING', 1);
}

function $create_9(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new EadesRadial;
    case 1:
      return new StraightLineEdgeRouter;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout processor ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function RadialLayoutPhases(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_70(name_0){
  $clinit_RadialLayoutPhases();
  return valueOf(($clinit_RadialLayoutPhases$Map() , $MAP_58), name_0);
}

function values_66(){
  $clinit_RadialLayoutPhases();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_RadialLayoutPhases_2_classLit, 1), $intern_38, 462, 0, [P1_NODE_PLACEMENT, P2_EDGE_ROUTING]);
}

defineClass(462, 22, {3:1, 34:1, 22:1, 462:1, 230:1, 231:1}, RadialLayoutPhases);
_.create_1 = function create_24(){
  return $create_9(this);
}
;
_.create_2 = function create_23(){
  return $create_9(this);
}
;
var P1_NODE_PLACEMENT, P2_EDGE_ROUTING;
var Lorg_eclipse_elk_alg_radial_RadialLayoutPhases_2_classLit = createForEnum('org.eclipse.elk.alg.radial', 'RadialLayoutPhases', 462, Ljava_lang_Enum_2_classLit, values_66, valueOf_70);
function $clinit_RadialLayoutPhases$Map(){
  $clinit_RadialLayoutPhases$Map = emptyMethod;
  $MAP_58 = createValueOfMap(($clinit_RadialLayoutPhases() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_RadialLayoutPhases_2_classLit, 1), $intern_38, 462, 0, [P1_NODE_PLACEMENT, P2_EDGE_ROUTING])));
}

var $MAP_58;
function $assembleAlgorithm(this$static, layoutGraph){
  var algorithm, configuration;
  $reset_4(this$static.algorithmAssembler);
  $setPhase(this$static.algorithmAssembler, ($clinit_RadialLayoutPhases() , P1_NODE_PLACEMENT), P1_NODE_PLACEMENT);
  $setPhase(this$static.algorithmAssembler, P2_EDGE_ROUTING, P2_EDGE_ROUTING);
  configuration = new LayoutProcessorConfiguration;
  $addBefore(configuration, P2_EDGE_ROUTING, ($clinit_IntermediateProcessorStrategy_1() , OVERLAP_REMOVAL));
  maskUndefined($getProperty_0(layoutGraph, ($clinit_RadialOptions() , COMPACTOR_0))) !== maskUndefined(($clinit_CompactionStrategy_0() , NONE_7)) && $addBefore(configuration, P2_EDGE_ROUTING, COMPACTION);
  $addBefore(configuration, P2_EDGE_ROUTING, GRAPH_SIZE_CALCULATION);
  $addProcessorConfiguration(this$static.algorithmAssembler, configuration);
  algorithm = $build(this$static.algorithmAssembler, layoutGraph);
  return algorithm;
}

function RadialLayoutProvider(){
  this.algorithmAssembler = new AlgorithmAssembler(Lorg_eclipse_elk_alg_radial_RadialLayoutPhases_2_classLit);
}

defineClass(999, 197, $intern_100, RadialLayoutProvider);
_.layout = function layout_4(layoutGraph, progressMonitor){
  var adapter, algorithm, calcu, layoutRadius, processor, processor$iterator, root;
  algorithm = $assembleAlgorithm(this, layoutGraph);
  $begin(progressMonitor, 'Radial layout', algorithm.array.length);
  root = findRoot(layoutGraph);
  $setProperty_1(layoutGraph, ($clinit_InternalProperties_3() , ROOT_NODE), root);
  if (!root) {
    throw toJs(new IllegalArgumentException_0('The given graph is not a tree!'));
  }
  layoutRadius = checkNotNull_1(castToDouble($getProperty_0(layoutGraph, ($clinit_RadialOptions() , RADIUS_0))));
  layoutRadius == 0 && (layoutRadius = findLargestNodeInGraph(layoutGraph));
  $setProperty_1(layoutGraph, RADIUS_0, layoutRadius);
  adapter = new ElkGraphAdapters$ElkGraphAdapter(layoutGraph);
  $forEach_0($getNodes_0(adapter), new NodeLabelAndSizeCalculator$lambda$0$Type);
  calcu = new NodeMarginCalculator(adapter);
  $process(calcu);
  for (processor$iterator = new ArrayList$1($assembleAlgorithm(this, layoutGraph)); processor$iterator.i < processor$iterator.this$01.array.length;) {
    processor = castTo($next_10(processor$iterator), 45);
    processor.process(layoutGraph, $subTask(progressMonitor, 1));
  }
  $done_0(progressMonitor);
}
;
var Lorg_eclipse_elk_alg_radial_RadialLayoutProvider_2_classLit = createForClass('org.eclipse.elk.alg.radial', 'RadialLayoutProvider', 999);
function findLargestNodeInGraph(graph){
  var child, child$iterator, diameter, height, largestChild, largestChildSize, width_0;
  largestChildSize = 0;
  for (child$iterator = new AbstractEList$EIterator((!graph.children && (graph.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, graph, 10, 11)) , graph.children)); child$iterator.cursor != child$iterator.this$01_2.size_1();) {
    child = castTo($doNext(child$iterator), 35);
    width_0 = child.width_0;
    height = child.height;
    diameter = $wnd.Math.sqrt(width_0 * width_0 + height * height);
    largestChildSize = $wnd.Math.max(diameter, largestChildSize);
    largestChild = findLargestNodeInGraph(child);
    largestChildSize = $wnd.Math.max(largestChild, largestChildSize);
  }
  return largestChildSize;
}

function findRoot(graph){
  var child, child$iterator, incomingEdges;
  for (child$iterator = new AbstractEList$EIterator((!graph.children && (graph.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, graph, 10, 11)) , graph.children)); child$iterator.cursor != child$iterator.this$01_2.size_1();) {
    child = castTo($doNext(child$iterator), 35);
    incomingEdges = allIncomingEdges(child);
    if (!$hasNext_0(($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(incomingEdges.val$inputs1, new Iterables$12)))))) {
      return child;
    }
  }
  return null;
}

function findRootOfNode(elkNode){
  var parent_0;
  parent_0 = getTreeParent(elkNode);
  return !parent_0?elkNode:findRootOfNode(parent_0);
}

function getNextLevelNodes(nodes){
  var nextLevelNodes, node, node$iterator, successors;
  successors = new ArrayList;
  for (node$iterator = nodes.iterator_0(); node$iterator.hasNext_0();) {
    node = castTo(node$iterator.next_1(), 35);
    nextLevelNodes = getSuccessors(node);
    $addAll_2(successors, nextLevelNodes);
  }
  return successors;
}

function getNumberOfLeaves(node){
  var child, child$iterator, leafs, successors;
  leafs = 0;
  successors = getSuccessors(node);
  if (successors.array.length == 0) {
    return 1;
  }
   else {
    for (child$iterator = new ArrayList$1(successors); child$iterator.i < child$iterator.this$01.array.length;) {
      child = castTo($next_10(child$iterator), 35);
      leafs += getNumberOfLeaves(child);
    }
  }
  return leafs;
}

function getSuccessors(node){
  var children, outgoingEdge, outgoingEdge$iterator, successors, target;
  successors = new ArrayList;
  children = new HashSet_1((!node.children && (node.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, node, 10, 11)) , node.children));
  for (outgoingEdge$iterator = $iterator(allOutgoingEdges(node)); $hasNext_0(outgoingEdge$iterator);) {
    outgoingEdge = castTo($next_2(outgoingEdge$iterator), 100);
    if (!instanceOf($get_16((!outgoingEdge.sources && (outgoingEdge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, outgoingEdge, 4, 7)) , outgoingEdge.sources), 0), 187)) {
      target = connectableShapeToNode(castTo($get_16((!outgoingEdge.targets && (outgoingEdge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, outgoingEdge, 5, 8)) , outgoingEdge.targets), 0), 97));
      children.map_0.containsKey(target) || (successors.array[successors.array.length] = target , true);
    }
  }
  return successors;
}

function getTreeParent(node){
  var edgeFromParent, iterator;
  iterator = allIncomingEdges(node);
  if (isEmpty_10(iterator)) {
    return null;
  }
   else {
    edgeFromParent = (checkNotNull(iterator) , castTo(get_13(($clinit_Iterators() , new Iterators$ConcatenatedIterator($iterator_1(transform_2(iterator.val$inputs1, new Iterables$12))))), 100));
    return connectableShapeToNode(castTo($get_16((!edgeFromParent.sources && (edgeFromParent.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edgeFromParent, 4, 7)) , edgeFromParent.sources), 0), 97));
  }
}

function lambda$0_12(nodeOffsetY_0, radialOffset_2, node1_2, node2_3){
  var arc1, arc2, position1, position2, xPos1, xPos2, yPos1, yPos2;
  position1 = castTo($getProperty_0(node1_2, ($clinit_CoreOptions() , POSITION_2)), 8);
  xPos1 = position1.x_0;
  yPos1 = position1.y_0 + nodeOffsetY_0;
  arc1 = $wnd.Math.atan2(yPos1, xPos1);
  arc1 < 0 && (arc1 += $intern_128);
  arc1 += radialOffset_2;
  arc1 > $intern_128 && (arc1 -= $intern_128);
  position2 = castTo($getProperty_0(node2_3, POSITION_2), 8);
  xPos2 = position2.x_0;
  yPos2 = position2.y_0 + nodeOffsetY_0;
  arc2 = $wnd.Math.atan2(yPos2, xPos2);
  arc2 < 0 && (arc2 += $intern_128);
  arc2 += radialOffset_2;
  arc2 > $intern_128 && (arc2 -= $intern_128);
  return $clinit_DoubleMath() , checkNonNegative(1.0E-10) , $wnd.Math.abs(arc1 - arc2) <= 1.0E-10 || arc1 == arc2 || isNaN(arc1) && isNaN(arc2)?0:arc1 < arc2?-1:arc1 > arc2?1:compare_1(isNaN(arc1), isNaN(arc2));
}

function RadialUtil$lambda$0$Type(radialOffset_2){
  this.nodeOffsetY_0 = 0;
  this.radialOffset_2 = radialOffset_2;
}

defineClass(513, 1, $intern_40, RadialUtil$lambda$0$Type);
_.equals_0 = function equals_161(other){
  return this === other;
}
;
_.reversed = function reversed_60(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_68(arg0, arg1){
  return lambda$0_12(this.nodeOffsetY_0, this.radialOffset_2, arg0, arg1);
}
;
_.nodeOffsetY_0 = 0;
_.radialOffset_2 = 0;
var Lorg_eclipse_elk_alg_radial_RadialUtil$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.radial', 'RadialUtil/lambda$0$Type', 513);
function $process_87(graph){
  var height, height0, margins, maxXPos, maxYPos, minXPos, minYPos, node, node$iterator, node$iterator0, offset, padding, posX, posY, width_0, width0;
  minXPos = $intern_98;
  minYPos = $intern_98;
  maxXPos = $intern_97;
  maxYPos = $intern_97;
  for (node$iterator0 = new AbstractEList$EIterator((!graph.children && (graph.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, graph, 10, 11)) , graph.children)); node$iterator0.cursor != node$iterator0.this$01_2.size_1();) {
    node = castTo($doNext(node$iterator0), 35);
    posX = node.x_0;
    posY = node.y_0;
    width0 = node.width_0;
    height0 = node.height;
    margins = castTo($getProperty_0(node, ($clinit_CoreOptions() , MARGINS_0)), 137);
    minXPos = $wnd.Math.min(minXPos, posX - margins.left);
    minYPos = $wnd.Math.min(minYPos, posY - margins.top_0);
    maxXPos = $wnd.Math.max(maxXPos, posX + width0 + margins.right);
    maxYPos = $wnd.Math.max(maxYPos, posY + height0 + margins.bottom);
  }
  padding = castTo($getProperty_0(graph, ($clinit_CoreOptions() , PADDING_5)), 116);
  offset = new KVector_1(minXPos - padding.left, minYPos - padding.top_0);
  for (node$iterator = new AbstractEList$EIterator((!graph.children && (graph.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, graph, 10, 11)) , graph.children)); node$iterator.cursor != node$iterator.this$01_2.size_1();) {
    node = castTo($doNext(node$iterator), 35);
    $setX_1(node, node.x_0 - offset.x_0);
    $setY_1(node, node.y_0 - offset.y_0);
  }
  width_0 = maxXPos - minXPos + (padding.left + padding.right);
  height = maxYPos - minYPos + (padding.top_0 + padding.bottom);
  $setWidth_0(graph, width_0);
  $setHeight_0(graph, height);
}

function CalculateGraphSize(){
}

defineClass(1254, 1, $intern_108, CalculateGraphSize);
_.process = function process_81(graph, progressMonitor){
  $process_87(castTo(graph, 35));
}
;
var Lorg_eclipse_elk_alg_radial_intermediate_CalculateGraphSize_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate', 'CalculateGraphSize', 1254);
function $clinit_IntermediateProcessorStrategy_1(){
  $clinit_IntermediateProcessorStrategy_1 = emptyMethod;
  OVERLAP_REMOVAL = new IntermediateProcessorStrategy_1('OVERLAP_REMOVAL', 0);
  COMPACTION = new IntermediateProcessorStrategy_1('COMPACTION', 1);
  GRAPH_SIZE_CALCULATION = new IntermediateProcessorStrategy_1('GRAPH_SIZE_CALCULATION', 2);
}

function IntermediateProcessorStrategy_1(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_71(name_0){
  $clinit_IntermediateProcessorStrategy_1();
  return valueOf(($clinit_IntermediateProcessorStrategy$Map_1() , $MAP_59), name_0);
}

function values_67(){
  $clinit_IntermediateProcessorStrategy_1();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_intermediate_IntermediateProcessorStrategy_2_classLit, 1), $intern_38, 421, 0, [OVERLAP_REMOVAL, COMPACTION, GRAPH_SIZE_CALCULATION]);
}

defineClass(421, 22, {3:1, 34:1, 22:1, 421:1, 231:1}, IntermediateProcessorStrategy_1);
_.create_1 = function create_25(){
  switch (this.ordinal) {
    case 0:
      return new RadiusExtensionOverlapRemoval;
    case 1:
      return new GeneralCompactor;
    case 2:
      return new CalculateGraphSize;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout processor ' + (this.name_0 != null?this.name_0:'' + this.ordinal)));
  }
}
;
var COMPACTION, GRAPH_SIZE_CALCULATION, OVERLAP_REMOVAL;
var Lorg_eclipse_elk_alg_radial_intermediate_IntermediateProcessorStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.radial.intermediate', 'IntermediateProcessorStrategy', 421, Ljava_lang_Enum_2_classLit, values_67, valueOf_71);
function $clinit_IntermediateProcessorStrategy$Map_1(){
  $clinit_IntermediateProcessorStrategy$Map_1 = emptyMethod;
  $MAP_59 = createValueOfMap(($clinit_IntermediateProcessorStrategy_1() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_intermediate_IntermediateProcessorStrategy_2_classLit, 1), $intern_38, 421, 0, [OVERLAP_REMOVAL, COMPACTION, GRAPH_SIZE_CALCULATION])));
}

var $MAP_59;
function $contractLayer(this$static, layerNodes, isContracting){
  var length_0, node, node$iterator, parentX, parentY, treeParent, x_0, xPos, y_0, yPos;
  for (node$iterator = layerNodes.iterator_0(); node$iterator.hasNext_0();) {
    node = castTo(node$iterator.next_1(), 35);
    xPos = node.x_0 + node.width_0 / 2;
    yPos = node.y_0 + node.height / 2;
    treeParent = this$static.root_0;
    parentX = treeParent.x_0 + treeParent.width_0 / 2;
    parentY = treeParent.y_0 + treeParent.height / 2;
    x_0 = xPos - parentX;
    y_0 = yPos - parentY;
    length_0 = $wnd.Math.sqrt(x_0 * x_0 + y_0 * y_0);
    x_0 *= this$static.compactionStep / length_0;
    y_0 *= this$static.compactionStep / length_0;
    if (isContracting) {
      xPos -= x_0;
      yPos -= y_0;
    }
     else {
      xPos += x_0;
      yPos += y_0;
    }
    $setX_1(node, xPos - node.width_0 / 2);
    $setY_1(node, yPos - node.height / 2);
  }
}

function $overlap_1(this$static, node1, node2){
  var height1, height2, width1, width2, x1, x2, y1, y2;
  x1 = node1.x_0 - this$static.spacing / 2;
  x2 = node2.x_0 - this$static.spacing / 2;
  y1 = node1.y_0 - this$static.spacing / 2;
  y2 = node2.y_0 - this$static.spacing / 2;
  width1 = node1.width_0 + this$static.spacing / 2;
  width2 = node2.width_0 + this$static.spacing / 2;
  height1 = node1.height + this$static.spacing / 2;
  height2 = node2.height + this$static.spacing / 2;
  if (x1 < x2 + width2 && x2 < x1 && y1 < y2 + height2 && y2 < y1) {
    return true;
  }
   else if (x2 < x1 + width1 && x1 < x2 && y2 < y1 + height1 && y1 < y2) {
    return true;
  }
   else if (x1 < x2 + width2 && x2 < x1 && y1 < y2 && y2 < y1 + height1) {
    return true;
  }
   else if (x2 < x1 + width1 && x1 < x2 && y1 < y2 + height2 && y2 < y1) {
    return true;
  }
  return false;
}

function $overlapLayer(this$static, nodes){
  var i, overlapping;
  overlapping = false;
  if (nodes.size_1() < 2) {
    return false;
  }
  for (i = 0; i < nodes.size_1(); i++) {
    i < nodes.size_1() - 1?(overlapping = overlapping | $overlap_1(this$static, castTo(nodes.get_3(i), 35), castTo(nodes.get_3(i + 1), 35))):(overlapping = overlapping | $overlap_1(this$static, castTo(nodes.get_3(i), 35), castTo(nodes.get_3(0), 35)));
  }
  return overlapping;
}

function $setCompactionStep(this$static, compactionStep){
  this$static.compactionStep = compactionStep;
}

function $setRoot(this$static, root){
  this$static.root_0 = root;
}

function $setSpacing(this$static, spacing){
  this$static.spacing = spacing;
}

defineClass(607, 1, {});
_.compactionStep = 1;
_.spacing = 0;
var Lorg_eclipse_elk_alg_radial_intermediate_compaction_AbstractRadiusExtensionCompaction_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate.compaction', 'AbstractRadiusExtensionCompaction', 607);
function $constructContour(this$static, nodes){
  var node, node$iterator, successors;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 35);
    $put(this$static.leftContour, node, node);
    $put(this$static.rightContour, node, node);
    successors = getSuccessors(node);
    if (successors.array.length != 0) {
      !!this$static.sorter && this$static.sorter.sort_1(successors);
      $put(this$static.leftContour, node, (checkCriticalElementIndex(0, successors.array.length) , castTo(successors.array[0], 35)));
      $put(this$static.rightContour, node, castTo($get_7(successors, successors.array.length - 1), 35));
      while (getNextLevelNodes(successors).array.length != 0) {
        successors = getNextLevelNodes(successors);
        !!this$static.sorter && this$static.sorter.sort_1(successors);
        $put(this$static.leftContour, node, (checkCriticalElementIndex(0, successors.array.length) , castTo(successors.array[0], 35)));
        $put(this$static.rightContour, node, castTo($get_7(successors, successors.array.length - 1), 35));
      }
    }
  }
}

function $contourOverlap(this$static, neighbourWedgeParent, node, left){
  var contour, contourNode, contourNode$iterator;
  contour = left?castTo($get_0(this$static.leftContour, neighbourWedgeParent), 19):castTo($get_0(this$static.rightContour, neighbourWedgeParent), 19);
  for (contourNode$iterator = contour.iterator_0(); contourNode$iterator.hasNext_0();) {
    contourNode = castTo(contourNode$iterator.next_1(), 35);
    if ($overlap_1(this$static, node, contourNode)) {
      return true;
    }
  }
  return false;
}

function $contractWedge(this$static, predecessors, radialPredecessor, radialSuccessor, currentRadiusNodes){
  var isOverlapping, nextLevelNodes, wasContracted;
  isOverlapping = $overlapping(this$static, predecessors, radialPredecessor, radialSuccessor, currentRadiusNodes);
  wasContracted = false;
  while (!isOverlapping) {
    $contractLayer(this$static, currentRadiusNodes, true);
    wasContracted = true;
    isOverlapping = $overlapping(this$static, predecessors, radialPredecessor, radialSuccessor, currentRadiusNodes);
  }
  wasContracted && $contractLayer(this$static, currentRadiusNodes, false);
  nextLevelNodes = getNextLevelNodes(currentRadiusNodes);
  if (nextLevelNodes.array.length != 0) {
    !!this$static.sorter && this$static.sorter.sort_1(nextLevelNodes);
    $contractWedge(this$static, currentRadiusNodes, radialPredecessor, radialSuccessor, nextLevelNodes);
  }
}

function $overlapping(this$static, predecessors, leftParent, rightParent, layerNodes){
  var firstNode, lastNode, predecessor, predecessor$iterator, sortedNode, sortedNode$iterator;
  !!this$static.sorter && this$static.sorter.sort_1(layerNodes);
  firstNode = castTo(layerNodes.get_3(0), 35);
  if ($contourOverlap(this$static, leftParent, firstNode, false)) {
    return true;
  }
  lastNode = castTo(layerNodes.get_3(layerNodes.size_1() - 1), 35);
  if ($contourOverlap(this$static, rightParent, lastNode, true)) {
    return true;
  }
  if ($overlapLayer(this$static, layerNodes)) {
    return true;
  }
  for (sortedNode$iterator = layerNodes.iterator_0(); sortedNode$iterator.hasNext_0();) {
    sortedNode = castTo(sortedNode$iterator.next_1(), 35);
    for (predecessor$iterator = predecessors.iterator_0(); predecessor$iterator.hasNext_0();) {
      predecessor = castTo(predecessor$iterator.next_1(), 35);
      if ($overlap_1(this$static, sortedNode, predecessor)) {
        return true;
      }
    }
  }
  return false;
}

function AnnulusWedgeCompaction(){
  this.leftContour = new HashMultimap;
  this.rightContour = new HashMultimap;
}

defineClass(1586, 607, {}, AnnulusWedgeCompaction);
_.compact_0 = function compact_2(graph){
  var i, k, leftParent, nodeAsList, rightParent, rootList, spacing, stepSize, successors;
  this.root = castTo($getProperty_0(graph, ($clinit_InternalProperties_3() , ROOT_NODE)), 35);
  $setRoot(this, this.root);
  this.sorter = $create_13(castTo($getProperty_0(graph, ($clinit_RadialOptions() , SORTER_0)), 285));
  stepSize = castTo($getProperty_0(graph, COMPACTION_STEP_SIZE_0), 21);
  !!stepSize && $setCompactionStep(this, stepSize.value_0);
  spacing = castToDouble($getProperty_0(graph, ($clinit_CoreOptions() , SPACING_NODE_NODE_5)));
  $setSpacing(this, (checkCriticalNotNull(spacing) , spacing));
  successors = getSuccessors(this.root);
  !!this.sorter && this.sorter.sort_1(successors);
  $constructContour(this, successors);
  rootList = new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_graph_ElkNode_2_classLit, 1), $intern_129, 35, 0, [this.root]));
  for (k = 0; k < 2; k++) {
    for (i = 0; i < successors.array.length; i++) {
      nodeAsList = new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_graph_ElkNode_2_classLit, 1), $intern_129, 35, 0, [(checkCriticalElementIndex(i, successors.array.length) , castTo(successors.array[i], 35))]));
      rightParent = i < successors.array.length - 1?(checkCriticalElementIndex(i + 1, successors.array.length) , castTo(successors.array[i + 1], 35)):(checkCriticalElementIndex(0, successors.array.length) , castTo(successors.array[0], 35));
      leftParent = i == 0?castTo($get_7(successors, successors.array.length - 1), 35):(checkCriticalElementIndex(i - 1, successors.array.length) , castTo(successors.array[i - 1], 35));
      $contractWedge(this, (checkCriticalElementIndex(i, successors.array.length) , castTo(successors.array[i], 35) , rootList), leftParent, rightParent, nodeAsList);
    }
  }
}
;
var Lorg_eclipse_elk_alg_radial_intermediate_compaction_AnnulusWedgeCompaction_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate.compaction', 'AnnulusWedgeCompaction', 1586);
function $process_88(graph){
  var compactor;
  compactor = $create_11(castTo($getProperty_0(graph, ($clinit_RadialOptions() , COMPACTOR_0)), 361));
  compactor.compact_0(graph);
}

function GeneralCompactor(){
}

defineClass(1253, 1, $intern_108, GeneralCompactor);
_.process = function process_82(graph, progressMonitor){
  $process_88(castTo(graph, 35));
}
;
var Lorg_eclipse_elk_alg_radial_intermediate_compaction_GeneralCompactor_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate.compaction', 'GeneralCompactor', 1253);
function $calculateRadius(this$static, node){
  var radius, root, rootX, rootY, vectorX, vectorY, xPos, yPos;
  xPos = node.x_0;
  yPos = node.y_0;
  root = this$static.root_0;
  rootX = root.x_0;
  rootY = root.y_0;
  vectorX = xPos - rootX;
  vectorY = yPos - rootY;
  radius = $wnd.Math.sqrt(vectorX * vectorX + vectorY * vectorY);
  return radius;
}

function $contract(this$static, nodes){
  var isOverlapping, nextLevelNodes, wasContracted;
  if (nodes.array.length != 0) {
    isOverlapping = $overlapping_0(this$static, nodes);
    wasContracted = false;
    while (!isOverlapping) {
      $contractLayer(this$static, nodes, true);
      wasContracted = true;
      isOverlapping = $overlapping_0(this$static, nodes);
    }
    wasContracted && $contractLayer(this$static, nodes, false);
    nextLevelNodes = getNextLevelNodes(nodes);
    !!this$static.sorter && this$static.sorter.sort_1(nextLevelNodes);
    this$static.lastRadius = $calculateRadius(this$static, (checkCriticalElementIndex(0, nodes.array.length) , castTo(nodes.array[0], 35)));
    $contract(this$static, nextLevelNodes);
  }
}

function $overlapping_0(this$static, nodes){
  var node, node$iterator, parent_0;
  if ($overlapLayer(this$static, nodes)) {
    return true;
  }
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 35);
    parent_0 = getTreeParent(node);
    if ($overlap_1(this$static, node, parent_0)) {
      return true;
    }
    if ($calculateRadius(this$static, node) - this$static.spacing <= this$static.lastRadius) {
      return true;
    }
  }
  return false;
}

function RadialCompaction(){
}

defineClass(1585, 607, {}, RadialCompaction);
_.compact_0 = function compact_3(graph){
  var firstLevelNodes, root, spacing, stepSize;
  root = castTo($getProperty_0(graph, ($clinit_InternalProperties_3() , ROOT_NODE)), 35);
  this.root_0 = root;
  this.sorter = $create_13(castTo($getProperty_0(graph, ($clinit_RadialOptions() , SORTER_0)), 285));
  stepSize = castTo($getProperty_0(graph, COMPACTION_STEP_SIZE_0), 21);
  !!stepSize && $setCompactionStep(this, stepSize.value_0);
  spacing = castToDouble($getProperty_0(graph, ($clinit_CoreOptions() , SPACING_NODE_NODE_5)));
  $setSpacing(this, (checkCriticalNotNull(spacing) , spacing));
  firstLevelNodes = getSuccessors(root);
  !!this.sorter && this.sorter.sort_1(firstLevelNodes);
  $contract(this, firstLevelNodes);
}
;
_.lastRadius = 0;
var Lorg_eclipse_elk_alg_radial_intermediate_compaction_RadialCompaction_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate.compaction', 'RadialCompaction', 1585);
function $isCrossing(this$static, node1, node2){
  var b1, b2, m1, m2, node1Vector, node2Vector, position1, position2, rootX, rootY, xCut, xPos1, xPos2, yPos1, yPos2;
  rootX = this$static.root.x_0 + this$static.root.width_0 / 2;
  rootY = this$static.root.x_0 + this$static.root.width_0 / 2;
  xPos1 = node1.x_0 + node1.width_0 / 2;
  yPos1 = node1.y_0 + node1.height / 2;
  node1Vector = new KVector_1(xPos1, yPos1);
  position1 = castTo($getProperty_0(node1, ($clinit_CoreOptions() , POSITION_2)), 8);
  position1.x_0 = position1.x_0 + rootX;
  position1.y_0 = position1.y_0 + rootY;
  m1 = (node1Vector.y_0 - position1.y_0) / (node1Vector.x_0 - position1.x_0);
  b1 = node1Vector.y_0 - m1 * node1Vector.x_0;
  xPos2 = node2.x_0 + node2.width_0 / 2;
  yPos2 = node2.y_0 + node2.height / 2;
  node2Vector = new KVector_1(xPos2, yPos2);
  position2 = castTo($getProperty_0(node2, POSITION_2), 8);
  position2.x_0 = position2.x_0 + rootX;
  position2.y_0 = position2.y_0 + rootY;
  m2 = (node2Vector.y_0 - position2.y_0) / (node2Vector.x_0 - position2.x_0);
  b2 = node2Vector.y_0 - m2 * node2Vector.x_0;
  xCut = (b1 - b2) / (m2 - m1);
  if (position1.x_0 < xCut && node1Vector.x_0 < xCut || xCut < position1.x_0 && xCut < node1Vector.x_0) {
    return false;
  }
   else if (position2.x_0 < xCut && node2Vector.x_0 < xCut || xCut < position2.x_0 && xCut < node2Vector.x_0) {
    return false;
  }
  return true;
}

function CrossingMinimizationPosition(){
}

defineClass(1593, 1, {}, CrossingMinimizationPosition);
_.evaluate = function evaluate(rootNode){
  var crossings, i, k, node1, node1$iterator, nodes;
  this.root = rootNode;
  crossings = 0;
  nodes = getSuccessors(rootNode);
  k = 0;
  for (node1$iterator = new ArrayList$1(nodes); node1$iterator.i < node1$iterator.this$01.array.length;) {
    node1 = castTo($next_10(node1$iterator), 35);
    ++k;
    for (i = k; i < nodes.array.length; i++) {
      $isCrossing(this, node1, (checkCriticalElementIndex(i, nodes.array.length) , castTo(nodes.array[i], 35))) && (crossings += 1);
    }
  }
  return crossings;
}
;
var Lorg_eclipse_elk_alg_radial_intermediate_optimization_CrossingMinimizationPosition_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate.optimization', 'CrossingMinimizationPosition', 1593);
function EdgeLengthOptimization(){
}

defineClass(1591, 1, {}, EdgeLengthOptimization);
_.evaluate = function evaluate_0(root){
  var edge, edge$iterator, edgeLength, rootX, rootY, sourceClip, target, targetClip, targetX, targetY, vector, vectorX, vectorY;
  edgeLength = 0;
  for (edge$iterator = $iterator(allOutgoingEdges(root)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 100);
    target = connectableShapeToNode(castTo($get_16((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets), 0), 97));
    targetX = target.x_0 + target.width_0 / 2;
    targetY = target.y_0 + target.height / 2;
    rootX = root.x_0 + root.width_0 / 2;
    rootY = root.y_0 + root.height / 2;
    vector = new KVector;
    vector.x_0 = targetX - rootX;
    vector.y_0 = targetY - rootY;
    sourceClip = new KVector_1(vector.x_0, vector.y_0);
    clipVector(sourceClip, root.width_0, root.height);
    vector.x_0 -= sourceClip.x_0;
    vector.y_0 -= sourceClip.y_0;
    rootX = targetX - vector.x_0;
    rootY = targetY - vector.y_0;
    targetClip = new KVector_1(vector.x_0, vector.y_0);
    clipVector(targetClip, target.width_0, target.height);
    vector.x_0 -= targetClip.x_0;
    vector.y_0 -= targetClip.y_0;
    targetX = rootX + vector.x_0;
    targetY = rootY + vector.y_0;
    vectorX = targetX - rootX;
    vectorY = targetY - rootY;
    edgeLength += $wnd.Math.sqrt(vectorX * vectorX + vectorY * vectorY);
  }
  return edgeLength;
}
;
var Lorg_eclipse_elk_alg_radial_intermediate_optimization_EdgeLengthOptimization_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate.optimization', 'EdgeLengthOptimization', 1591);
function EdgeLengthPositionOptimization(){
}

defineClass(1592, 1, {}, EdgeLengthPositionOptimization);
_.evaluate = function evaluate_1(root){
  var edge, edge$iterator, edgeLength, position, rootX, rootY, target, targetX, targetY, vectorX, vectorY;
  edgeLength = 0;
  for (edge$iterator = $iterator(allOutgoingEdges(root)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 100);
    target = connectableShapeToNode(castTo($get_16((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets), 0), 97));
    targetX = target.x_0 + target.width_0 / 2;
    targetY = target.y_0 + target.height / 2;
    position = castTo($getProperty_0(target, ($clinit_CoreOptions() , POSITION_2)), 8);
    rootX = root.x_0 + position.x_0 + root.width_0 / 2;
    rootY = root.y_0 + position.y_0 + root.height;
    vectorX = targetX - rootX;
    vectorY = targetY - rootY;
    edgeLength += $wnd.Math.sqrt(vectorX * vectorX + vectorY * vectorY);
  }
  return edgeLength;
}
;
var Lorg_eclipse_elk_alg_radial_intermediate_optimization_EdgeLengthPositionOptimization_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate.optimization', 'EdgeLengthPositionOptimization', 1592);
function $extend(this$static, nodes){
  var nextLevelNodes;
  if (nodes.array.length != 0) {
    while ($overlapLayer(this$static, nodes)) {
      $contractLayer(this$static, nodes, false);
    }
    nextLevelNodes = getNextLevelNodes(nodes);
    if (this$static.sorter) {
      this$static.sorter.sort_1(nextLevelNodes);
      $extend(this$static, nextLevelNodes);
    }
  }
}

function $removeOverlaps_1(this$static, graph){
  var root, spacing, successors;
  root = castTo($getProperty_0(graph, ($clinit_InternalProperties_3() , ROOT_NODE)), 35);
  this$static.root_0 = root;
  this$static.sorter = $create_13(castTo($getProperty_0(graph, ($clinit_RadialOptions() , SORTER_0)), 285));
  spacing = castToDouble($getProperty_0(graph, ($clinit_CoreOptions() , SPACING_NODE_NODE_5)));
  $setSpacing(this$static, (checkCriticalNotNull(spacing) , spacing));
  successors = getSuccessors(root);
  $extend(this$static, successors);
}

function RadiusExtensionOverlapRemoval(){
}

defineClass(1252, 607, $intern_108, RadiusExtensionOverlapRemoval);
_.process = function process_83(graph, progressMonitor){
  $removeOverlaps_1(this, castTo(graph, 35));
}
;
var Lorg_eclipse_elk_alg_radial_intermediate_overlaps_RadiusExtensionOverlapRemoval_2_classLit = createForClass('org.eclipse.elk.alg.radial.intermediate.overlaps', 'RadiusExtensionOverlapRemoval', 1252);
function $clinit_AnnulusWedgeCriteria(){
  $clinit_AnnulusWedgeCriteria = emptyMethod;
  LEAF_NUMBER = new AnnulusWedgeCriteria('LEAF_NUMBER', 0);
  NODE_SIZE_0 = new AnnulusWedgeCriteria('NODE_SIZE', 1);
}

function $create_10(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new AnnulusWedgeByLeafs;
    case 1:
      return new AnnulusWedgeByNodeSpace;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout option ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function AnnulusWedgeCriteria(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_72(name_0){
  $clinit_AnnulusWedgeCriteria();
  return valueOf(($clinit_AnnulusWedgeCriteria$Map() , $MAP_60), name_0);
}

function values_68(){
  $clinit_AnnulusWedgeCriteria();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_options_AnnulusWedgeCriteria_2_classLit, 1), $intern_38, 405, 0, [LEAF_NUMBER, NODE_SIZE_0]);
}

defineClass(405, 22, {3:1, 34:1, 22:1, 405:1}, AnnulusWedgeCriteria);
var LEAF_NUMBER, NODE_SIZE_0;
var Lorg_eclipse_elk_alg_radial_options_AnnulusWedgeCriteria_2_classLit = createForEnum('org.eclipse.elk.alg.radial.options', 'AnnulusWedgeCriteria', 405, Ljava_lang_Enum_2_classLit, values_68, valueOf_72);
function $clinit_AnnulusWedgeCriteria$Map(){
  $clinit_AnnulusWedgeCriteria$Map = emptyMethod;
  $MAP_60 = createValueOfMap(($clinit_AnnulusWedgeCriteria() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_options_AnnulusWedgeCriteria_2_classLit, 1), $intern_38, 405, 0, [LEAF_NUMBER, NODE_SIZE_0])));
}

var $MAP_60;
function $clinit_CompactionStrategy_0(){
  $clinit_CompactionStrategy_0 = emptyMethod;
  NONE_7 = new CompactionStrategy_0('NONE', 0);
  RADIAL_COMPACTION = new CompactionStrategy_0('RADIAL_COMPACTION', 1);
  WEDGE_COMPACTION = new CompactionStrategy_0('WEDGE_COMPACTION', 2);
}

function $create_11(this$static){
  switch (this$static.ordinal) {
    case 1:
      return new RadialCompaction;
    case 2:
      return new AnnulusWedgeCompaction;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout option ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function CompactionStrategy_0(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_73(name_0){
  $clinit_CompactionStrategy_0();
  return valueOf(($clinit_CompactionStrategy$Map_0() , $MAP_61), name_0);
}

function values_69(){
  $clinit_CompactionStrategy_0();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_options_CompactionStrategy_2_classLit, 1), $intern_38, 361, 0, [NONE_7, RADIAL_COMPACTION, WEDGE_COMPACTION]);
}

defineClass(361, 22, {3:1, 34:1, 22:1, 361:1}, CompactionStrategy_0);
var NONE_7, RADIAL_COMPACTION, WEDGE_COMPACTION;
var Lorg_eclipse_elk_alg_radial_options_CompactionStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.radial.options', 'CompactionStrategy', 361, Ljava_lang_Enum_2_classLit, values_69, valueOf_73);
function $clinit_CompactionStrategy$Map_0(){
  $clinit_CompactionStrategy$Map_0 = emptyMethod;
  $MAP_61 = createValueOfMap(($clinit_CompactionStrategy_0() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_options_CompactionStrategy_2_classLit, 1), $intern_38, 361, 0, [NONE_7, RADIAL_COMPACTION, WEDGE_COMPACTION])));
}

var $MAP_61;
function $clinit_RadialMetaDataProvider(){
  $clinit_RadialMetaDataProvider = emptyMethod;
  ORDER_ID = new Property_1('org.eclipse.elk.radial.orderId', valueOf_4(0));
  RADIUS = new Property_1('org.eclipse.elk.radial.radius', 0);
  COMPACTOR_DEFAULT = ($clinit_CompactionStrategy_0() , NONE_7);
  COMPACTOR = new Property_1('org.eclipse.elk.radial.compactor', COMPACTOR_DEFAULT);
  valueOf_4(0);
  COMPACTION_STEP_SIZE = new Property_1('org.eclipse.elk.radial.compactionStepSize', valueOf_4(1));
  SORTER_DEFAULT = ($clinit_SortingStrategy() , NONE_9);
  SORTER = new Property_1('org.eclipse.elk.radial.sorter', SORTER_DEFAULT);
  WEDGE_CRITERIA_DEFAULT = ($clinit_AnnulusWedgeCriteria() , NODE_SIZE_0);
  WEDGE_CRITERIA = new Property_1('org.eclipse.elk.radial.wedgeCriteria', WEDGE_CRITERIA_DEFAULT);
  OPTIMIZATION_CRITERIA_DEFAULT = ($clinit_RadialTranslationStrategy() , NONE_8);
  OPTIMIZATION_CRITERIA = new Property_1('org.eclipse.elk.radial.optimizationCriteria', OPTIMIZATION_CRITERIA_DEFAULT);
}

function RadialMetaDataProvider(){
  $clinit_RadialMetaDataProvider();
}

defineClass(782, 1, $intern_92, RadialMetaDataProvider);
_.apply_3 = function apply_136(registry){
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.radial.orderId'), ''), 'Order ID'), 'The id can be used to define an order for nodes of one radius. This can be used to sort them in the layer accordingly.'), valueOf_4(0)), ($clinit_LayoutOptionData$Type() , INT)), Ljava_lang_Integer_2_classLit), of_0(($clinit_LayoutOptionData$Target() , NODES)))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.radial.radius'), ''), 'Radius'), 'The radius option can be used to set the initial radius for the radial layouter.'), 0), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.radial.compactor'), ''), 'Compaction'), 'With the compacter option it can be determined how compaction on the graph is done. It can be chosen between none, the radial compaction or the compaction of wedges separately.'), COMPACTOR_DEFAULT), ENUM), Lorg_eclipse_elk_alg_radial_options_CompactionStrategy_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.radial.compactionStepSize'), ''), 'Compaction Step Size'), 'Determine the size of steps with which the compaction is done. Step size 1 correlates to a compaction of 1 pixel per Iteration.'), valueOf_4(1)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.radial.compactionStepSize', 'org.eclipse.elk.radial.compactor', null);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.radial.sorter'), ''), 'Sorter'), 'Sort the nodes per radius according to the sorting algorithm. The strategies are none, by the given order id, or sorting them by polar coordinates.'), SORTER_DEFAULT), ENUM), Lorg_eclipse_elk_alg_radial_options_SortingStrategy_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.radial.wedgeCriteria'), ''), 'Annulus Wedge Criteria'), 'Determine how the wedge for the node placement is calculated. It can be chosen between wedge determination by the number of leaves or by the maximum sum of diagonals.'), WEDGE_CRITERIA_DEFAULT), ENUM), Lorg_eclipse_elk_alg_radial_options_AnnulusWedgeCriteria_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.radial.optimizationCriteria'), ''), 'Translation Optimization'), 'Find the optimal translation of the nodes of the first radii according to this criteria. For example edge crossings can be minimized.'), OPTIMIZATION_CRITERIA_DEFAULT), ENUM), Lorg_eclipse_elk_alg_radial_options_RadialTranslationStrategy_2_classLit), of_0(PARENTS))));
  $apply_25((new RadialOptions , registry));
}
;
var COMPACTION_STEP_SIZE, COMPACTOR, COMPACTOR_DEFAULT, OPTIMIZATION_CRITERIA, OPTIMIZATION_CRITERIA_DEFAULT, ORDER_ID, RADIUS, SORTER, SORTER_DEFAULT, WEDGE_CRITERIA, WEDGE_CRITERIA_DEFAULT;
var Lorg_eclipse_elk_alg_radial_options_RadialMetaDataProvider_2_classLit = createForClass('org.eclipse.elk.alg.radial.options', 'RadialMetaDataProvider', 782);
function $clinit_RadialOptions(){
  $clinit_RadialOptions = emptyMethod;
  POSITION_1 = ($clinit_CoreOptions() , POSITION_2);
  SPACING_NODE_NODE_2 = SPACING_NODE_NODE_5;
  COMPACTION_STEP_SIZE_0 = ($clinit_RadialMetaDataProvider() , COMPACTION_STEP_SIZE);
  COMPACTOR_0 = COMPACTOR;
  OPTIMIZATION_CRITERIA_0 = OPTIMIZATION_CRITERIA;
  ORDER_ID_0 = ORDER_ID;
  RADIUS_0 = RADIUS;
  SORTER_0 = SORTER;
  WEDGE_CRITERIA_0 = WEDGE_CRITERIA;
}

function $apply_25(registry){
  $register(registry, new LayoutAlgorithmData($category($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.radial'), 'ELK Radial'), 'A radial layout provider which is based on the algorithm of Peter Eades published in "Drawing free trees.", published by International Institute for Advanced Study of Social Information Science, Fujitsu Limited in 1991. The radial layouter takes a tree and places the nodes in radial order around the root. The nodes of the same tree level are placed on the same radius.'), new RadialOptions$RadialFactory), 'org.eclipse.elk.radial')));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.position', $getDefault(POSITION_1));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.spacing.nodeNode', $getDefault(SPACING_NODE_NODE_2));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.radial.compactionStepSize', $getDefault(COMPACTION_STEP_SIZE_0));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.radial.compactor', $getDefault(COMPACTOR_0));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.radial.optimizationCriteria', $getDefault(OPTIMIZATION_CRITERIA_0));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.radial.orderId', $getDefault(ORDER_ID_0));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.radial.radius', $getDefault(RADIUS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.radial.sorter', $getDefault(SORTER_0));
  $addOptionSupport(registry, 'org.eclipse.elk.radial', 'org.eclipse.elk.radial.wedgeCriteria', $getDefault(WEDGE_CRITERIA_0));
}

function RadialOptions(){
  $clinit_RadialOptions();
}

defineClass(922, 1, $intern_92, RadialOptions);
_.apply_3 = function apply_137(registry){
  $apply_25(registry);
}
;
var COMPACTION_STEP_SIZE_0, COMPACTOR_0, OPTIMIZATION_CRITERIA_0, ORDER_ID_0, POSITION_1, RADIUS_0, SORTER_0, SPACING_NODE_NODE_2, WEDGE_CRITERIA_0;
var Lorg_eclipse_elk_alg_radial_options_RadialOptions_2_classLit = createForClass('org.eclipse.elk.alg.radial.options', 'RadialOptions', 922);
function RadialOptions$RadialFactory(){
}

defineClass(923, 1, {}, RadialOptions$RadialFactory);
_.create_0 = function create_26(){
  var provider;
  return provider = new RadialLayoutProvider , provider;
}
;
_.destroy = function destroy_4(obj){
}
;
var Lorg_eclipse_elk_alg_radial_options_RadialOptions$RadialFactory_2_classLit = createForClass('org.eclipse.elk.alg.radial.options', 'RadialOptions/RadialFactory', 923);
function $clinit_RadialTranslationStrategy(){
  $clinit_RadialTranslationStrategy = emptyMethod;
  NONE_8 = new RadialTranslationStrategy('NONE', 0);
  EDGE_LENGTH_0 = new RadialTranslationStrategy('EDGE_LENGTH', 1);
  EDGE_LENGTH_BY_POSITION = new RadialTranslationStrategy('EDGE_LENGTH_BY_POSITION', 2);
  CROSSING_MINIMIZATION_BY_POSITION = new RadialTranslationStrategy('CROSSING_MINIMIZATION_BY_POSITION', 3);
}

function $create_12(this$static){
  switch (this$static.ordinal) {
    case 1:
      return new EdgeLengthOptimization;
    case 2:
      return new EdgeLengthPositionOptimization;
    case 3:
      return new CrossingMinimizationPosition;
    case 0:
      return null;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout option ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function RadialTranslationStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_74(name_0){
  $clinit_RadialTranslationStrategy();
  return valueOf(($clinit_RadialTranslationStrategy$Map() , $MAP_62), name_0);
}

function values_70(){
  $clinit_RadialTranslationStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_options_RadialTranslationStrategy_2_classLit, 1), $intern_38, 330, 0, [NONE_8, EDGE_LENGTH_0, EDGE_LENGTH_BY_POSITION, CROSSING_MINIMIZATION_BY_POSITION]);
}

defineClass(330, 22, {3:1, 34:1, 22:1, 330:1}, RadialTranslationStrategy);
var CROSSING_MINIMIZATION_BY_POSITION, EDGE_LENGTH_0, EDGE_LENGTH_BY_POSITION, NONE_8;
var Lorg_eclipse_elk_alg_radial_options_RadialTranslationStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.radial.options', 'RadialTranslationStrategy', 330, Ljava_lang_Enum_2_classLit, values_70, valueOf_74);
function $clinit_RadialTranslationStrategy$Map(){
  $clinit_RadialTranslationStrategy$Map = emptyMethod;
  $MAP_62 = createValueOfMap(($clinit_RadialTranslationStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_options_RadialTranslationStrategy_2_classLit, 1), $intern_38, 330, 0, [NONE_8, EDGE_LENGTH_0, EDGE_LENGTH_BY_POSITION, CROSSING_MINIMIZATION_BY_POSITION])));
}

var $MAP_62;
function $clinit_SortingStrategy(){
  $clinit_SortingStrategy = emptyMethod;
  NONE_9 = new SortingStrategy('NONE', 0);
  POLAR_COORDINATE = new SortingStrategy('POLAR_COORDINATE', 1);
  ID_0 = new SortingStrategy('ID', 2);
}

function $create_13(this$static){
  switch (this$static.ordinal) {
    case 0:
      return null;
    case 1:
      return new PolarCoordinateSorter;
    case 2:
      return new IDSorter;
    default:throw toJs(new IllegalArgumentException_0('No implementation is available for the layout option ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function SortingStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_75(name_0){
  $clinit_SortingStrategy();
  return valueOf(($clinit_SortingStrategy$Map() , $MAP_63), name_0);
}

function values_71(){
  $clinit_SortingStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_options_SortingStrategy_2_classLit, 1), $intern_38, 285, 0, [NONE_9, POLAR_COORDINATE, ID_0]);
}

defineClass(285, 22, {3:1, 34:1, 22:1, 285:1}, SortingStrategy);
var ID_0, NONE_9, POLAR_COORDINATE;
var Lorg_eclipse_elk_alg_radial_options_SortingStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.radial.options', 'SortingStrategy', 285, Ljava_lang_Enum_2_classLit, values_71, valueOf_75);
function $clinit_SortingStrategy$Map(){
  $clinit_SortingStrategy$Map = emptyMethod;
  $MAP_63 = createValueOfMap(($clinit_SortingStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_radial_options_SortingStrategy_2_classLit, 1), $intern_38, 285, 0, [NONE_9, POLAR_COORDINATE, ID_0])));
}

var $MAP_63;
function $positionNodes(this$static, node, currentRadius, minAlpha, maxAlpha, optimalOffset){
  var alpha_0, alphaPoint, child, child$iterator, numberOfChildLeafs, numberOfLeafs, s, successors, tau, xPos, yPos, xPosition, yPosition;
  alphaPoint = (minAlpha + maxAlpha) / 2 + optimalOffset;
  xPos = currentRadius * $wnd.Math.cos(alphaPoint);
  yPos = currentRadius * $wnd.Math.sin(alphaPoint);
  xPosition = xPos - node.width_0 / 2;
  yPosition = yPos - node.height / 2;
  $setX_1(node, xPosition);
  $setY_1(node, yPosition);
  numberOfLeafs = this$static.annulusWedgeCriteria.calculateWedgeSpace(node);
  tau = 2 * $wnd.Math.acos(currentRadius / currentRadius + this$static.radius);
  if (tau < maxAlpha - minAlpha) {
    s = tau / numberOfLeafs;
    alpha_0 = (minAlpha + maxAlpha - tau) / 2;
  }
   else {
    s = (maxAlpha - minAlpha) / numberOfLeafs;
    alpha_0 = minAlpha;
  }
  successors = getSuccessors(node);
  if (this$static.sorter) {
    this$static.sorter.initialize_0(this$static.root);
    this$static.sorter.sort_1(successors);
  }
  for (child$iterator = new ArrayList$1(successors); child$iterator.i < child$iterator.this$01.array.length;) {
    child = castTo($next_10(child$iterator), 35);
    numberOfChildLeafs = this$static.annulusWedgeCriteria.calculateWedgeSpace(child);
    $positionNodes(this$static, child, currentRadius + this$static.radius, alpha_0, alpha_0 + s * numberOfChildLeafs, optimalOffset);
    alpha_0 += s * numberOfChildLeafs;
  }
}

function $process_89(this$static, graph){
  this$static.root = castTo($getProperty_0(graph, ($clinit_InternalProperties_3() , ROOT_NODE)), 35);
  this$static.radius = checkNotNull_1(castToDouble($getProperty_0(graph, ($clinit_RadialOptions() , RADIUS_0))));
  this$static.sorter = $create_13(castTo($getProperty_0(graph, SORTER_0), 285));
  this$static.annulusWedgeCriteria = $create_10(castTo($getProperty_0(graph, WEDGE_CRITERIA_0), 405));
  this$static.optimizer = $create_12(castTo($getProperty_0(graph, OPTIMIZATION_CRITERIA_0), 330));
  $translate_0(this$static);
}

function $translate_0(this$static){
  var i, offset, optimalOffset, optimalValue, translatedValue;
  optimalOffset = 0;
  optimalValue = $intern_98;
  if (this$static.optimizer) {
    for (i = 0; i < 360; i++) {
      offset = i * 0.017453292519943295;
      $positionNodes(this$static, this$static.root, 0, 0, $intern_128, offset);
      translatedValue = this$static.optimizer.evaluate(this$static.root);
      if (translatedValue < optimalValue) {
        optimalOffset = offset;
        optimalValue = translatedValue;
      }
    }
  }
  $positionNodes(this$static, this$static.root, 0, 0, $intern_128, optimalOffset);
}

function EadesRadial(){
}

defineClass(1320, 1, $intern_117, EadesRadial);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_22(graph){
  return castTo(graph, 35) , null;
}
;
_.process = function process_84(graph, progressMonitor){
  $process_89(this, castTo(graph, 35));
}
;
_.radius = 0;
var Lorg_eclipse_elk_alg_radial_p1position_EadesRadial_2_classLit = createForClass('org.eclipse.elk.alg.radial.p1position', 'EadesRadial', 1320);
function AnnulusWedgeByLeafs(){
}

defineClass(1589, 1, {}, AnnulusWedgeByLeafs);
_.calculateWedgeSpace = function calculateWedgeSpace(node){
  return getNumberOfLeaves(node);
}
;
var Lorg_eclipse_elk_alg_radial_p1position_wedge_AnnulusWedgeByLeafs_2_classLit = createForClass('org.eclipse.elk.alg.radial.p1position.wedge', 'AnnulusWedgeByLeafs', 1589);
function $calculateWedgeSpace(this$static, node){
  var child, child$iterator, childSpace, height, nodeSize, successors, width_0;
  successors = getSuccessors(node);
  height = node.height;
  width_0 = node.width_0;
  nodeSize = $wnd.Math.sqrt(height * height + width_0 * width_0);
  childSpace = 0;
  for (child$iterator = new ArrayList$1(successors); child$iterator.i < child$iterator.this$01.array.length;) {
    child = castTo($next_10(child$iterator), 35);
    childSpace += $calculateWedgeSpace(this$static, child);
  }
  return $wnd.Math.max(childSpace, nodeSize);
}

function AnnulusWedgeByNodeSpace(){
}

defineClass(1590, 1, {}, AnnulusWedgeByNodeSpace);
_.calculateWedgeSpace = function calculateWedgeSpace_0(node){
  return $calculateWedgeSpace(this, node);
}
;
var Lorg_eclipse_elk_alg_radial_p1position_wedge_AnnulusWedgeByNodeSpace_2_classLit = createForClass('org.eclipse.elk.alg.radial.p1position.wedge', 'AnnulusWedgeByNodeSpace', 1590);
function $process_90(this$static, graph){
  var root;
  root = castTo($getProperty_0(graph, ($clinit_InternalProperties_3() , ROOT_NODE)), 35);
  $routeEdges_1(this$static, root);
}

function $routeEdges_1(this$static, node){
  var edge, edge$iterator, section, sourceClip, sourceX, sourceY, target, targetClip, targetX, targetY, vector;
  for (edge$iterator = $iterator(allOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
    edge = castTo($next_2(edge$iterator), 100);
    if (!instanceOf($get_16((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources), 0), 187)) {
      target = connectableShapeToNode(castTo($get_16((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets), 0), 97));
      if (!$isHierarchical(edge)) {
        sourceX = node.x_0 + node.width_0 / 2;
        sourceY = node.y_0 + node.height / 2;
        targetX = target.x_0 + target.width_0 / 2;
        targetY = target.y_0 + target.height / 2;
        vector = new KVector;
        vector.x_0 = targetX - sourceX;
        vector.y_0 = targetY - sourceY;
        sourceClip = new KVector_1(vector.x_0, vector.y_0);
        clipVector(sourceClip, node.width_0, node.height);
        vector.x_0 -= sourceClip.x_0;
        vector.y_0 -= sourceClip.y_0;
        sourceX = targetX - vector.x_0;
        sourceY = targetY - vector.y_0;
        targetClip = new KVector_1(vector.x_0, vector.y_0);
        clipVector(targetClip, target.width_0, target.height);
        vector.x_0 -= targetClip.x_0;
        vector.y_0 -= targetClip.y_0;
        targetX = sourceX + vector.x_0;
        targetY = sourceY + vector.y_0;
        section = firstEdgeSection(edge, true, true);
        $setStartX(section, sourceX);
        $setStartY(section, sourceY);
        $setEndX(section, targetX);
        $setEndY(section, targetY);
        $routeEdges_1(this$static, target);
      }
    }
  }
}

function StraightLineEdgeRouter(){
}

defineClass(1321, 1, $intern_117, StraightLineEdgeRouter);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_23(graph){
  return castTo(graph, 35) , null;
}
;
_.process = function process_85(graph, progressMonitor){
  $process_90(this, castTo(graph, 35));
}
;
var Lorg_eclipse_elk_alg_radial_p2routing_StraightLineEdgeRouter_2_classLit = createForClass('org.eclipse.elk.alg.radial.p2routing', 'StraightLineEdgeRouter', 1321);
function $sort_1(this$static, nodes){
  nodes.sort_0(this$static.idSorter);
}

function IDSorter(){
  this.idSorter = new IDSorter$lambda$0$Type;
}

defineClass(751, 1, {}, IDSorter);
_.initialize_0 = function initialize_2(root){
}
;
_.sort_1 = function sort_10(nodes){
  $sort_1(this, nodes);
}
;
var Lorg_eclipse_elk_alg_radial_sorting_IDSorter_2_classLit = createForClass('org.eclipse.elk.alg.radial.sorting', 'IDSorter', 751);
function IDSorter$lambda$0$Type(){
}

defineClass(1588, 1, $intern_40, IDSorter$lambda$0$Type);
_.equals_0 = function equals_162(other){
  return this === other;
}
;
_.reversed = function reversed_61(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_69(arg0, arg1){
  var orderID1, orderID2;
  return orderID1 = castTo($getProperty_0(arg0, ($clinit_RadialOptions() , ORDER_ID_0)), 21) , orderID2 = castTo($getProperty_0(arg1, ORDER_ID_0), 21) , compare_6(orderID1.value_0, orderID2.value_0);
}
;
var Lorg_eclipse_elk_alg_radial_sorting_IDSorter$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.radial.sorting', 'IDSorter/lambda$0$Type', 1588);
function $initialize_5(this$static, root){
  var successors;
  this$static.idSorter = new IDSorter;
  successors = getSuccessors(root);
  $sort(successors, this$static.compRight);
  $setIDForNodes(this$static, successors, 0);
}

function $setIDForNodes(this$static, nodes, idOffset){
  var arc, id_0, nextLayerId, node, node$iterator, nodeSuccessors;
  id_0 = idOffset;
  nextLayerId = 0;
  for (node$iterator = new ArrayList$1(nodes); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 35);
    $setProperty_1(node, ($clinit_RadialOptions() , ORDER_ID_0), valueOf_4(id_0++));
    nodeSuccessors = getSuccessors(node);
    arc = $wnd.Math.atan2(node.y_0 + node.height / 2, node.x_0 + node.width_0 / 2);
    arc += arc < 0?$intern_128:0;
    arc < 0.7853981633974483 || arc > $intern_130?$sort(nodeSuccessors, this$static.compLeft):arc <= $intern_130 && arc > $intern_131?$sort(nodeSuccessors, this$static.compTop):arc <= $intern_131 && arc > $intern_132?$sort(nodeSuccessors, this$static.compRight):arc <= $intern_132 && $sort(nodeSuccessors, this$static.compBottom);
    nextLayerId = $setIDForNodes(this$static, nodeSuccessors, nextLayerId);
  }
  return id_0;
}

function PolarCoordinateSorter(){
  this.compRight = new RadialUtil$lambda$0$Type(0);
  this.compLeft = new RadialUtil$lambda$0$Type($intern_127);
  this.compTop = new RadialUtil$lambda$0$Type($intern_126);
  this.compBottom = new RadialUtil$lambda$0$Type($intern_101);
}

defineClass(1587, 1, {}, PolarCoordinateSorter);
_.initialize_0 = function initialize_3(root){
  $initialize_5(this, root);
}
;
_.sort_1 = function sort_11(nodes){
  var root;
  if (!nodes.isEmpty()) {
    if (!this.idSorter) {
      root = findRootOfNode(castTo(nodes.get_3(0), 35));
      $initialize_5(this, root);
    }
    $sort_1(this.idSorter, nodes);
  }
}
;
var Lorg_eclipse_elk_alg_radial_sorting_PolarCoordinateSorter_2_classLit = createForClass('org.eclipse.elk.alg.radial.sorting', 'PolarCoordinateSorter', 1587);
function $applyPositions_0(this$static, g){
  var e, e$iterator, elkNode, endLocation, kedgeSection, maxX, maxY, minX, minY, node, node$iterator, padding, source, startLocation, target, uv, vu;
  minX = $intern_62;
  minY = $intern_62;
  maxX = $intern_63;
  maxY = $intern_63;
  for (node$iterator = new ArrayList$1(g.vertices); node$iterator.i < node$iterator.this$01.array.length;) {
    node = castTo($next_10(node$iterator), 58);
    elkNode = castTo(castTo($get_6(this$static.nodeMap, node.originalVertex), 37).second, 35);
    $setLocation(elkNode, node.rect.x_0, node.rect.y_0);
    minX = $wnd.Math.min(minX, elkNode.x_0);
    minY = $wnd.Math.min(minY, elkNode.y_0);
    maxX = $wnd.Math.max(maxX, elkNode.x_0 + elkNode.width_0);
    maxY = $wnd.Math.max(maxY, elkNode.y_0 + elkNode.height);
  }
  padding = castTo($getProperty_0(this$static.elkGraph, ($clinit_SporeCompactionOptions() , PADDING_3)), 116);
  resizeNode_1(this$static.elkGraph, maxX - minX + (padding.left + padding.right), maxY - minY + (padding.top_0 + padding.bottom), true, true);
  translate_0(this$static.elkGraph, -minX + padding.left, -minY + padding.top_0);
  for (e$iterator = new AbstractEList$EIterator($getContainedEdges(this$static.elkGraph)); e$iterator.cursor != e$iterator.this$01_2.size_1();) {
    e = castTo($doNext(e$iterator), 100);
    kedgeSection = firstEdgeSection(e, true, true);
    source = getSourceNode(e);
    target = getTargetNode(e);
    startLocation = new KVector_1(source.x_0 + source.width_0 / 2, source.y_0 + source.height / 2);
    endLocation = new KVector_1(target.x_0 + target.width_0 / 2, target.y_0 + target.height / 2);
    uv = $sub_0(new KVector_1(endLocation.x_0, endLocation.y_0), startLocation);
    clipVector(uv, source.width_0, source.height);
    $add_19(startLocation, uv);
    vu = $sub_0(new KVector_1(startLocation.x_0, startLocation.y_0), endLocation);
    clipVector(vu, target.width_0, target.height);
    $add_19(endLocation, vu);
    $setStartLocation(kedgeSection, startLocation.x_0, startLocation.y_0);
    $setEndLocation(kedgeSection, endLocation.x_0, endLocation.y_0);
  }
}

function $importGraph_2(this$static, inputGraph){
  var adapter, calcu, center, closest, compactionStrategy, costFunction, costFunctionID, distance, elkNode, elkNode$iterator, halfHeight, halfWidth, id_0, margin, node, node$iterator, node$iterator0, preferredRootID, rootSelection, treeConstructionStrategy, vertex;
  this$static.elkGraph = inputGraph;
  this$static.nodeMap = ($clinit_Maps() , new HashMap);
  adapter = new ElkGraphAdapters$ElkGraphAdapter(this$static.elkGraph);
  calcu = new NodeMarginCalculator(adapter);
  $process(calcu);
  preferredRootID = castToString($getProperty_0(this$static.elkGraph, ($clinit_SporeCompactionOptions() , PROCESSING_ORDER_PREFERRED_ROOT)));
  costFunctionID = castTo($getProperty_0(this$static.elkGraph, PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION), 302);
  treeConstructionStrategy = castTo($getProperty_0(this$static.elkGraph, PROCESSING_ORDER_TREE_CONSTRUCTION), 408);
  compactionStrategy = castTo($getProperty_0(this$static.elkGraph, COMPACTION_COMPACTION_STRATEGY), 455);
  rootSelection = castTo($getProperty_0(this$static.elkGraph, PROCESSING_ORDER_ROOT_SELECTION), 409);
  this$static.spacingNodeNode = checkNotNull_1(castToDouble($getProperty_0(this$static.elkGraph, SPACING_NODE_NODE_3)));
  switch (costFunctionID.ordinal) {
    case 0:
      costFunction = this$static.centerDistance;
      break;
    case 1:
      costFunction = this$static.circleUnderlap;
      break;
    case 2:
      costFunction = this$static.rectangleUnderlap;
      break;
    case 3:
      costFunction = this$static.invertedOverlap;
      break;
    case 4:
      costFunction = this$static.minimumRootDistance;
      break;
    default:throw toJs(new IllegalArgumentException_0('No implementation available for ' + (costFunctionID.name_0 != null?costFunctionID.name_0:'' + costFunctionID.ordinal)));
  }
  this$static.graph_0 = new Graph(costFunction, treeConstructionStrategy, compactionStrategy);
  $setProperty_0(this$static.graph_0, ($clinit_InternalProperties() , DEBUG_SVG), castToBoolean($getProperty_0(this$static.elkGraph, DEBUG_MODE_1)));
  this$static.graph_0.orthogonalCompaction = checkNotNull_1(castToBoolean($getProperty_0(this$static.elkGraph, COMPACTION_ORTHOGONAL)));
  if ($getChildren(this$static.elkGraph).size_0 == 0) {
    return this$static.graph_0;
  }
  for (elkNode$iterator = new AbstractEList$EIterator($getChildren(this$static.elkGraph)); elkNode$iterator.cursor != elkNode$iterator.this$01_2.size_1();) {
    elkNode = castTo($doNext(elkNode$iterator), 35);
    halfWidth = elkNode.width_0 / 2;
    halfHeight = elkNode.height / 2;
    vertex = new KVector_1(elkNode.x_0 + halfWidth, elkNode.y_0 + halfHeight);
    while ($containsKey_2(this$static.nodeMap, vertex)) {
      $add_18(vertex, ($wnd.Math.random() - 0.5) * $intern_104, ($wnd.Math.random() - 0.5) * $intern_104);
    }
    margin = castTo($getProperty_0(elkNode, ($clinit_CoreOptions() , MARGINS_0)), 137);
    node = new Node_0(vertex, new ElkRectangle_0(vertex.x_0 - halfWidth - this$static.spacingNodeNode / 2 - margin.left, vertex.y_0 - halfHeight - this$static.spacingNodeNode / 2 - margin.top_0, elkNode.width_0 + this$static.spacingNodeNode + (margin.left + margin.right), elkNode.height + this$static.spacingNodeNode + (margin.top_0 + margin.bottom)));
    $add_4(this$static.graph_0.vertices, node);
    $put_1(this$static.nodeMap, vertex, new Pair(node, elkNode));
  }
  switch (rootSelection.ordinal) {
    case 0:
      if (preferredRootID == null) {
        this$static.graph_0.preferredRoot = castTo($get_7(this$static.graph_0.vertices, 0), 58);
      }
       else {
        for (node$iterator0 = new ArrayList$1(this$static.graph_0.vertices); node$iterator0.i < node$iterator0.this$01.array.length;) {
          node = castTo($next_10(node$iterator0), 58);
          id_0 = castTo(castTo($get_6(this$static.nodeMap, node.originalVertex), 37).second, 35).getIdentifier();
          id_0 != null && $equals_4(id_0, preferredRootID) && (this$static.graph_0.preferredRoot = node);
        }
      }

      break;
    case 1:
      center = new KVector_1(this$static.elkGraph.width_0, this$static.elkGraph.height);
      center.x_0 *= 0.5;
      center.y_0 *= 0.5;
      $add_18(center, this$static.elkGraph.x_0, this$static.elkGraph.y_0);
      closest = $intern_62;
      for (node$iterator = new ArrayList$1(this$static.graph_0.vertices); node$iterator.i < node$iterator.this$01.array.length;) {
        node = castTo($next_10(node$iterator), 58);
        distance = $distance_0(node.originalVertex, center);
        if (distance < closest) {
          closest = distance;
          this$static.graph_0.preferredRoot = node;
        }
      }

      break;
    default:throw toJs(new IllegalArgumentException_0('No implementation available for ' + (rootSelection.name_0 != null?rootSelection.name_0:'' + rootSelection.ordinal)));
  }
  return this$static.graph_0;
}

function $lambda$1_4(this$static, e_0){
  return $wnd.Math.min($distance_0(e_0.u, this$static.graph_0.preferredRoot.vertex), $distance_0(e_0.v, this$static.graph_0.preferredRoot.vertex));
}

function $lambda$2_3(this$static, e_0){
  var n1, n2;
  n1 = castTo(castTo($get_6(this$static.nodeMap, e_0.u), 37).first, 58);
  n2 = castTo(castTo($get_6(this$static.nodeMap, e_0.v), 37).first, 58);
  return $distance_0(e_0.u, e_0.v) - $distance_0(e_0.u, $getPosition(n1.rect)) - $distance_0(e_0.v, $getPosition(n2.rect));
}

function $lambda$3_1(this$static, e_0){
  var n1, n2;
  n1 = castTo(castTo($get_6(this$static.nodeMap, e_0.u), 37).first, 58);
  n2 = castTo(castTo($get_6(this$static.nodeMap, e_0.v), 37).first, 58);
  return $underlap(n1, n2);
}

function $lambda$4_0(this$static, e_0){
  var dist, n1, n2, r1, r2, s;
  n1 = castTo(castTo($get_6(this$static.nodeMap, e_0.u), 37).first, 58);
  n2 = castTo(castTo($get_6(this$static.nodeMap, e_0.v), 37).first, 58);
  r1 = n1.rect;
  r2 = n2.rect;
  dist = shortestDistance_0(r1, r2);
  if (dist >= 0) {
    return dist;
  }
  s = $length($sub_0(new KVector_1(r2.x_0 + r2.width_0 / 2, r2.y_0 + r2.height / 2), new KVector_1(r1.x_0 + r1.width_0 / 2, r1.y_0 + r1.height / 2)));
  return -(overlap(r1, r2) - 1) * s;
}

function $updateGraph(this$static, g){
  var n, n$iterator, original, updatedNodeMap;
  updatedNodeMap = ($clinit_Maps() , new HashMap);
  g.tEdges = null;
  g.tree = null;
  for (n$iterator = new ArrayList$1(g.vertices); n$iterator.i < n$iterator.this$01.array.length;) {
    n = castTo($next_10(n$iterator), 58);
    original = castTo($get_6(this$static.nodeMap, n.originalVertex), 37);
    n.originalVertex = $getCenter(n.rect);
    $put_1(updatedNodeMap, n.originalVertex, original);
  }
  this$static.nodeMap = updatedNodeMap;
}

function ElkGraphImporter_0(){
  this.centerDistance = new ElkGraphImporter$lambda$0$Type_0;
  this.minimumRootDistance = new ElkGraphImporter$lambda$1$Type_0(this);
  this.circleUnderlap = new ElkGraphImporter$lambda$2$Type_0(this);
  this.rectangleUnderlap = new ElkGraphImporter$lambda$3$Type_0(this);
  this.invertedOverlap = new ElkGraphImporter$lambda$4$Type_0(this);
}

defineClass(696, 1, {}, ElkGraphImporter_0);
_.spacingNodeNode = 0;
var Lorg_eclipse_elk_alg_spore_ElkGraphImporter_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'ElkGraphImporter', 696);
function ElkGraphImporter$lambda$0$Type_0(){
}

defineClass(1073, 1, {}, ElkGraphImporter$lambda$0$Type_0);
_.cost = function cost_0(arg0){
  return $distance_0(arg0.u, arg0.v);
}
;
var Lorg_eclipse_elk_alg_spore_ElkGraphImporter$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'ElkGraphImporter/lambda$0$Type', 1073);
function ElkGraphImporter$lambda$1$Type_0($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1074, 1, {}, ElkGraphImporter$lambda$1$Type_0);
_.cost = function cost_1(arg0){
  return $lambda$1_4(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_spore_ElkGraphImporter$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'ElkGraphImporter/lambda$1$Type', 1074);
function ElkGraphImporter$lambda$2$Type_0($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1075, 1, {}, ElkGraphImporter$lambda$2$Type_0);
_.cost = function cost_2(arg0){
  return $lambda$2_3(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_spore_ElkGraphImporter$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'ElkGraphImporter/lambda$2$Type', 1075);
function ElkGraphImporter$lambda$3$Type_0($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1076, 1, {}, ElkGraphImporter$lambda$3$Type_0);
_.cost = function cost_3(arg0){
  return $lambda$3_1(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_spore_ElkGraphImporter$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'ElkGraphImporter/lambda$3$Type', 1076);
function ElkGraphImporter$lambda$4$Type_0($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1077, 1, {}, ElkGraphImporter$lambda$4$Type_0);
_.cost = function cost_4(arg0){
  return $lambda$4_0(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_spore_ElkGraphImporter$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'ElkGraphImporter/lambda$4$Type', 1077);
function OverlapRemovalLayoutProvider(){
  this.algorithmAssembler = new AlgorithmAssembler(Lorg_eclipse_elk_alg_spore_SPOrEPhases_2_classLit);
}

function lambda$0_13(overlapEdges_0, n1_1, n2_2){
  return $add_6(overlapEdges_0, new TEdge(n1_1.originalVertex, n2_2.originalVertex));
}

defineClass(1001, 197, $intern_100, OverlapRemovalLayoutProvider);
_.layout = function layout_5(layoutGraph, progressMonitor){
  var graph, graphImporter, iteration, lad, layoutProvider, maxIterations, overlapEdges, overlapHandler, overlapsExisted, processor, processor$iterator, requestedAlgorithm;
  if ($hasProperty_0(layoutGraph, ($clinit_SporeCompactionOptions() , UNDERLYING_LAYOUT_ALGORITHM))) {
    requestedAlgorithm = castToString($getProperty_0(layoutGraph, ($clinit_SporeOverlapRemovalOptions() , UNDERLYING_LAYOUT_ALGORITHM_1)));
    lad = $getAlgorithmDataBySuffix(getInstance(), requestedAlgorithm);
    if (lad) {
      layoutProvider = castTo($fetch(lad.providerPool), 197);
      layoutProvider.layout(layoutGraph, $subTask(progressMonitor, 1));
    }
  }
  $setProperty_1(layoutGraph, PROCESSING_ORDER_ROOT_SELECTION, ($clinit_RootSelection() , CENTER_NODE));
  $setProperty_1(layoutGraph, PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION, ($clinit_SpanningTreeCostFunction() , INVERTED_OVERLAP));
  $setProperty_1(layoutGraph, PROCESSING_ORDER_TREE_CONSTRUCTION, ($clinit_TreeConstructionStrategy() , MINIMUM_SPANNING_TREE));
  maxIterations = castTo($getProperty_0(layoutGraph, ($clinit_SporeOverlapRemovalOptions() , OVERLAP_REMOVAL_MAX_ITERATIONS_0)), 21).value_0;
  $begin(progressMonitor, 'Overlap removal', 1);
  checkNotNull_1(castToBoolean($getProperty_0(layoutGraph, DEBUG_MODE_2))) && 'null45scanlineOverlaps';
  overlapEdges = new HashSet;
  overlapHandler = new OverlapRemovalLayoutProvider$lambda$0$Type(overlapEdges);
  graphImporter = new ElkGraphImporter_0;
  graph = $importGraph_2(graphImporter, layoutGraph);
  overlapsExisted = true;
  iteration = 0;
  while (iteration < maxIterations && overlapsExisted) {
    if (checkNotNull_1(castToBoolean($getProperty_0(layoutGraph, OVERLAP_REMOVAL_RUN_SCANLINE_0)))) {
      overlapEdges.map_0.clear_0();
      $sweep_0(new ScanlineOverlapCheck(overlapHandler), graph.vertices);
      if (overlapEdges.map_0.size_1() == 0) {
        break;
      }
      graph.tEdges = overlapEdges;
    }
    $reset_4(this.algorithmAssembler);
    $setPhase(this.algorithmAssembler, ($clinit_SPOrEPhases() , P1_STRUCTURE), ($clinit_StructureExtractionStrategy() , DELAUNAY_TRIANGULATION));
    $setPhase(this.algorithmAssembler, P2_PROCESSING_ORDER, graph.treeConstructionStrategy);
    $setPhase(this.algorithmAssembler, P3_EXECUTION, ($clinit_OverlapRemovalStrategy() , GROW_TREE));
    this.algorithm = $build(this.algorithmAssembler, graph);
    for (processor$iterator = new ArrayList$1(this.algorithm); processor$iterator.i < processor$iterator.this$01.array.length;) {
      processor = castTo($next_10(processor$iterator), 45);
      processor.process(graph, $subTask(progressMonitor, 1));
    }
    $updateGraph(graphImporter, graph);
    overlapsExisted = checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_InternalProperties() , OVERLAPS_EXISTED))));
    ++iteration;
  }
  $applyPositions_0(graphImporter, graph);
  $done_0(progressMonitor);
}
;
var Lorg_eclipse_elk_alg_spore_OverlapRemovalLayoutProvider_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'OverlapRemovalLayoutProvider', 1001);
function $handle_4(this$static, arg0, arg1){
  lambda$0_13(this$static.overlapEdges_0, arg0, arg1);
}

function OverlapRemovalLayoutProvider$lambda$0$Type(overlapEdges_0){
  this.overlapEdges_0 = overlapEdges_0;
}

defineClass(1002, 1, {}, OverlapRemovalLayoutProvider$lambda$0$Type);
var Lorg_eclipse_elk_alg_spore_OverlapRemovalLayoutProvider$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'OverlapRemovalLayoutProvider/lambda$0$Type', 1002);
function $clinit_SPOrEPhases(){
  $clinit_SPOrEPhases = emptyMethod;
  P1_STRUCTURE = new SPOrEPhases('P1_STRUCTURE', 0);
  P2_PROCESSING_ORDER = new SPOrEPhases('P2_PROCESSING_ORDER', 1);
  P3_EXECUTION = new SPOrEPhases('P3_EXECUTION', 2);
}

function SPOrEPhases(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_76(name_0){
  $clinit_SPOrEPhases();
  return valueOf(($clinit_SPOrEPhases$Map() , $MAP_64), name_0);
}

function values_72(){
  $clinit_SPOrEPhases();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_SPOrEPhases_2_classLit, 1), $intern_38, 413, 0, [P1_STRUCTURE, P2_PROCESSING_ORDER, P3_EXECUTION]);
}

defineClass(413, 22, {3:1, 34:1, 22:1, 413:1}, SPOrEPhases);
var P1_STRUCTURE, P2_PROCESSING_ORDER, P3_EXECUTION;
var Lorg_eclipse_elk_alg_spore_SPOrEPhases_2_classLit = createForEnum('org.eclipse.elk.alg.spore', 'SPOrEPhases', 413, Ljava_lang_Enum_2_classLit, values_72, valueOf_76);
function $clinit_SPOrEPhases$Map(){
  $clinit_SPOrEPhases$Map = emptyMethod;
  $MAP_64 = createValueOfMap(($clinit_SPOrEPhases() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_SPOrEPhases_2_classLit, 1), $intern_38, 413, 0, [P1_STRUCTURE, P2_PROCESSING_ORDER, P3_EXECUTION])));
}

var $MAP_64;
function $shrink(this$static, graph, progressMonitor){
  var processor, processor$iterator;
  $reset_4(this$static.algorithmAssembler);
  $setPhase(this$static.algorithmAssembler, ($clinit_SPOrEPhases() , P1_STRUCTURE), ($clinit_StructureExtractionStrategy() , DELAUNAY_TRIANGULATION));
  $setPhase(this$static.algorithmAssembler, P2_PROCESSING_ORDER, graph.treeConstructionStrategy);
  $setPhase(this$static.algorithmAssembler, P3_EXECUTION, graph.compactionStrategy);
  this$static.algorithm = $build(this$static.algorithmAssembler, graph);
  $begin(progressMonitor, 'Compaction by shrinking a tree', this$static.algorithm.array.length);
  if (graph.vertices.array.length > 1) {
    for (processor$iterator = new ArrayList$1(this$static.algorithm); processor$iterator.i < processor$iterator.this$01.array.length;) {
      processor = castTo($next_10(processor$iterator), 45);
      processor.process(graph, $subTask(progressMonitor, 1));
    }
  }
  $done_0(progressMonitor);
}

function ShrinkTree(){
  this.algorithmAssembler = new AlgorithmAssembler(Lorg_eclipse_elk_alg_spore_SPOrEPhases_2_classLit);
}

defineClass(1083, 1, {}, ShrinkTree);
var Lorg_eclipse_elk_alg_spore_ShrinkTree_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'ShrinkTree', 1083);
function ShrinkTreeLayoutProvider(){
  this.shrinktree = new ShrinkTree;
}

defineClass(1003, 197, $intern_100, ShrinkTreeLayoutProvider);
_.layout = function layout_6(layoutGraph, progressMonitor){
  var graph, graphImporter, lad, layoutProvider, requestedAlgorithm;
  if ($hasProperty_0(layoutGraph, ($clinit_SporeCompactionOptions() , UNDERLYING_LAYOUT_ALGORITHM))) {
    requestedAlgorithm = castToString($getProperty_0(layoutGraph, UNDERLYING_LAYOUT_ALGORITHM));
    lad = $getAlgorithmDataBySuffix(getInstance(), requestedAlgorithm);
    if (lad) {
      layoutProvider = castTo($fetch(lad.providerPool), 197);
      layoutProvider.layout(layoutGraph, $subTask(progressMonitor, 1));
    }
  }
  graphImporter = new ElkGraphImporter_0;
  graph = $importGraph_2(graphImporter, layoutGraph);
  $shrink(this.shrinktree, graph, $subTask(progressMonitor, 1));
  $applyPositions_0(graphImporter, graph);
}
;
var Lorg_eclipse_elk_alg_spore_ShrinkTreeLayoutProvider_2_classLit = createForClass('org.eclipse.elk.alg.spore', 'ShrinkTreeLayoutProvider', 1003);
function Graph(costFun, treeStrategy, compStrategy){
  this.vertices = new ArrayList;
  this.costFunction = costFun;
  this.treeConstructionStrategy = treeStrategy;
  this.compactionStrategy = compStrategy;
}

defineClass(289, 130, {3:1, 289:1, 94:1, 130:1}, Graph);
_.orthogonalCompaction = false;
var Lorg_eclipse_elk_alg_spore_graph_Graph_2_classLit = createForClass('org.eclipse.elk.alg.spore.graph', 'Graph', 289);
function $clinit_CompactionStrategy_1(){
  $clinit_CompactionStrategy_1 = emptyMethod;
  DEPTH_FIRST_0 = new CompactionStrategy_1;
}

function $create_14(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new ShrinkTreeCompactionPhase;
    default:throw toJs(new IllegalArgumentException_0('No implementation available for ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function CompactionStrategy_1(){
  Enum.call(this, 'DEPTH_FIRST', 0);
}

function valueOf_77(name_0){
  $clinit_CompactionStrategy_1();
  return valueOf(($clinit_CompactionStrategy$Map_1() , $MAP_65), name_0);
}

function values_73(){
  $clinit_CompactionStrategy_1();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_CompactionStrategy_2_classLit, 1), $intern_38, 455, 0, [DEPTH_FIRST_0]);
}

defineClass(455, 22, {3:1, 34:1, 22:1, 455:1, 230:1, 231:1}, CompactionStrategy_1);
_.create_1 = function create_28(){
  return $create_14(this);
}
;
_.create_2 = function create_27(){
  return $create_14(this);
}
;
var DEPTH_FIRST_0;
var Lorg_eclipse_elk_alg_spore_options_CompactionStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.spore.options', 'CompactionStrategy', 455, Ljava_lang_Enum_2_classLit, values_73, valueOf_77);
function $clinit_CompactionStrategy$Map_1(){
  $clinit_CompactionStrategy$Map_1 = emptyMethod;
  $MAP_65 = createValueOfMap(($clinit_CompactionStrategy_1() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_CompactionStrategy_2_classLit, 1), $intern_38, 455, 0, [DEPTH_FIRST_0])));
}

var $MAP_65;
function $clinit_OverlapRemovalStrategy(){
  $clinit_OverlapRemovalStrategy = emptyMethod;
  GROW_TREE = new OverlapRemovalStrategy;
}

function OverlapRemovalStrategy(){
  Enum.call(this, 'GROW_TREE', 0);
}

function valueOf_78(name_0){
  $clinit_OverlapRemovalStrategy();
  return valueOf(($clinit_OverlapRemovalStrategy$Map() , $MAP_66), name_0);
}

function values_74(){
  $clinit_OverlapRemovalStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_OverlapRemovalStrategy_2_classLit, 1), $intern_38, 516, 0, [GROW_TREE]);
}

defineClass(516, 22, {3:1, 34:1, 22:1, 516:1, 230:1, 231:1}, OverlapRemovalStrategy);
_.create_1 = function create_30(){
  return new GrowTreePhase;
}
;
_.create_2 = function create_29(){
  return new GrowTreePhase;
}
;
var GROW_TREE;
var Lorg_eclipse_elk_alg_spore_options_OverlapRemovalStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.spore.options', 'OverlapRemovalStrategy', 516, Ljava_lang_Enum_2_classLit, values_74, valueOf_78);
function $clinit_OverlapRemovalStrategy$Map(){
  $clinit_OverlapRemovalStrategy$Map = emptyMethod;
  $MAP_66 = createValueOfMap(($clinit_OverlapRemovalStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_OverlapRemovalStrategy_2_classLit, 1), $intern_38, 516, 0, [GROW_TREE])));
}

var $MAP_66;
function $clinit_RootSelection(){
  $clinit_RootSelection = emptyMethod;
  FIXED_1 = new RootSelection('FIXED', 0);
  CENTER_NODE = new RootSelection('CENTER_NODE', 1);
}

function RootSelection(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_79(name_0){
  $clinit_RootSelection();
  return valueOf(($clinit_RootSelection$Map() , $MAP_67), name_0);
}

function values_75(){
  $clinit_RootSelection();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_RootSelection_2_classLit, 1), $intern_38, 409, 0, [FIXED_1, CENTER_NODE]);
}

defineClass(409, 22, {3:1, 34:1, 22:1, 409:1}, RootSelection);
var CENTER_NODE, FIXED_1;
var Lorg_eclipse_elk_alg_spore_options_RootSelection_2_classLit = createForEnum('org.eclipse.elk.alg.spore.options', 'RootSelection', 409, Ljava_lang_Enum_2_classLit, values_75, valueOf_79);
function $clinit_RootSelection$Map(){
  $clinit_RootSelection$Map = emptyMethod;
  $MAP_67 = createValueOfMap(($clinit_RootSelection() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_RootSelection_2_classLit, 1), $intern_38, 409, 0, [FIXED_1, CENTER_NODE])));
}

var $MAP_67;
function $clinit_SpanningTreeCostFunction(){
  $clinit_SpanningTreeCostFunction = emptyMethod;
  CENTER_DISTANCE = new SpanningTreeCostFunction('CENTER_DISTANCE', 0);
  CIRCLE_UNDERLAP = new SpanningTreeCostFunction('CIRCLE_UNDERLAP', 1);
  RECTANGLE_UNDERLAP = new SpanningTreeCostFunction('RECTANGLE_UNDERLAP', 2);
  INVERTED_OVERLAP = new SpanningTreeCostFunction('INVERTED_OVERLAP', 3);
  MINIMUM_ROOT_DISTANCE = new SpanningTreeCostFunction('MINIMUM_ROOT_DISTANCE', 4);
}

function SpanningTreeCostFunction(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_80(name_0){
  $clinit_SpanningTreeCostFunction();
  return valueOf(($clinit_SpanningTreeCostFunction$Map() , $MAP_68), name_0);
}

function values_76(){
  $clinit_SpanningTreeCostFunction();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_SpanningTreeCostFunction_2_classLit, 1), $intern_38, 302, 0, [CENTER_DISTANCE, CIRCLE_UNDERLAP, RECTANGLE_UNDERLAP, INVERTED_OVERLAP, MINIMUM_ROOT_DISTANCE]);
}

defineClass(302, 22, {3:1, 34:1, 22:1, 302:1}, SpanningTreeCostFunction);
var CENTER_DISTANCE, CIRCLE_UNDERLAP, INVERTED_OVERLAP, MINIMUM_ROOT_DISTANCE, RECTANGLE_UNDERLAP;
var Lorg_eclipse_elk_alg_spore_options_SpanningTreeCostFunction_2_classLit = createForEnum('org.eclipse.elk.alg.spore.options', 'SpanningTreeCostFunction', 302, Ljava_lang_Enum_2_classLit, values_76, valueOf_80);
function $clinit_SpanningTreeCostFunction$Map(){
  $clinit_SpanningTreeCostFunction$Map = emptyMethod;
  $MAP_68 = createValueOfMap(($clinit_SpanningTreeCostFunction() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_SpanningTreeCostFunction_2_classLit, 1), $intern_38, 302, 0, [CENTER_DISTANCE, CIRCLE_UNDERLAP, RECTANGLE_UNDERLAP, INVERTED_OVERLAP, MINIMUM_ROOT_DISTANCE])));
}

var $MAP_68;
function $clinit_SporeCompactionOptions(){
  $clinit_SporeCompactionOptions = emptyMethod;
  UNDERLYING_LAYOUT_ALGORITHM = ($clinit_SporeMetaDataProvider() , UNDERLYING_LAYOUT_ALGORITHM_0);
  PROCESSING_ORDER_TREE_CONSTRUCTION = PROCESSING_ORDER_TREE_CONSTRUCTION_0;
  PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION = PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION_0;
  PROCESSING_ORDER_PREFERRED_ROOT = PROCESSING_ORDER_PREFERRED_ROOT_0;
  PROCESSING_ORDER_ROOT_SELECTION = PROCESSING_ORDER_ROOT_SELECTION_0;
  PADDING_DEFAULT_2 = new ElkPadding_0(8);
  PADDING_3 = new Property_2(($clinit_CoreOptions() , PADDING_5), PADDING_DEFAULT_2);
  SPACING_NODE_NODE_3 = new Property_2(SPACING_NODE_NODE_5, 8);
  STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY = STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_0;
  COMPACTION_COMPACTION_STRATEGY = COMPACTION_COMPACTION_STRATEGY_0;
  COMPACTION_ORTHOGONAL = COMPACTION_ORTHOGONAL_0;
  DEBUG_MODE_1 = new Property_2(DEBUG_MODE_3, ($clinit_Boolean() , $clinit_Boolean() , false));
}

function $apply_26(registry){
  $register(registry, new LayoutAlgorithmData($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.sporeCompaction'), 'ELK SPOrE Compaction'), 'ShrinkTree is a compaction algorithm that maintains the topology of a layout. The relocation of diagram elements is based on contracting a spanning tree.'), new SporeCompactionOptions$SporeCompactionFactory)));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.underlyingLayoutAlgorithm', $getDefault(UNDERLYING_LAYOUT_ALGORITHM));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.processingOrder.treeConstruction', $getDefault(PROCESSING_ORDER_TREE_CONSTRUCTION));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.processingOrder.spanningTreeCostFunction', $getDefault(PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.processingOrder.preferredRoot', $getDefault(PROCESSING_ORDER_PREFERRED_ROOT));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.processingOrder.rootSelection', $getDefault(PROCESSING_ORDER_ROOT_SELECTION));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.padding', PADDING_DEFAULT_2);
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.spacing.nodeNode', 8);
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.structure.structureExtractionStrategy', $getDefault(STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.compaction.compactionStrategy', $getDefault(COMPACTION_COMPACTION_STRATEGY));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.compaction.orthogonal', $getDefault(COMPACTION_ORTHOGONAL));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeCompaction', 'org.eclipse.elk.debugMode', ($clinit_Boolean() , $clinit_Boolean() , false));
}

function SporeCompactionOptions(){
  $clinit_SporeCompactionOptions();
}

defineClass(928, 1, $intern_92, SporeCompactionOptions);
_.apply_3 = function apply_138(registry){
  $apply_26(registry);
}
;
var COMPACTION_COMPACTION_STRATEGY, COMPACTION_ORTHOGONAL, DEBUG_MODE_1, PADDING_3, PADDING_DEFAULT_2, PROCESSING_ORDER_PREFERRED_ROOT, PROCESSING_ORDER_ROOT_SELECTION, PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION, PROCESSING_ORDER_TREE_CONSTRUCTION, SPACING_NODE_NODE_3, STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY, UNDERLYING_LAYOUT_ALGORITHM;
var Lorg_eclipse_elk_alg_spore_options_SporeCompactionOptions_2_classLit = createForClass('org.eclipse.elk.alg.spore.options', 'SporeCompactionOptions', 928);
function SporeCompactionOptions$SporeCompactionFactory(){
}

defineClass(929, 1, {}, SporeCompactionOptions$SporeCompactionFactory);
_.create_0 = function create_31(){
  var provider;
  return provider = new ShrinkTreeLayoutProvider , provider;
}
;
_.destroy = function destroy_5(obj){
}
;
var Lorg_eclipse_elk_alg_spore_options_SporeCompactionOptions$SporeCompactionFactory_2_classLit = createForClass('org.eclipse.elk.alg.spore.options', 'SporeCompactionOptions/SporeCompactionFactory', 929);
function $clinit_SporeMetaDataProvider(){
  $clinit_SporeMetaDataProvider = emptyMethod;
  UNDERLYING_LAYOUT_ALGORITHM_0 = new Property('org.eclipse.elk.underlyingLayoutAlgorithm');
  STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_DEFAULT = ($clinit_StructureExtractionStrategy() , DELAUNAY_TRIANGULATION);
  STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_0 = new Property_1('org.eclipse.elk.structure.structureExtractionStrategy', STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_DEFAULT);
  PROCESSING_ORDER_TREE_CONSTRUCTION_DEFAULT = ($clinit_TreeConstructionStrategy() , MINIMUM_SPANNING_TREE);
  PROCESSING_ORDER_TREE_CONSTRUCTION_0 = new Property_1('org.eclipse.elk.processingOrder.treeConstruction', PROCESSING_ORDER_TREE_CONSTRUCTION_DEFAULT);
  PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION_DEFAULT = ($clinit_SpanningTreeCostFunction() , CIRCLE_UNDERLAP);
  PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION_0 = new Property_1('org.eclipse.elk.processingOrder.spanningTreeCostFunction', PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION_DEFAULT);
  PROCESSING_ORDER_PREFERRED_ROOT_0 = new Property_1('org.eclipse.elk.processingOrder.preferredRoot', null);
  PROCESSING_ORDER_ROOT_SELECTION_DEFAULT = ($clinit_RootSelection() , CENTER_NODE);
  PROCESSING_ORDER_ROOT_SELECTION_0 = new Property_1('org.eclipse.elk.processingOrder.rootSelection', PROCESSING_ORDER_ROOT_SELECTION_DEFAULT);
  COMPACTION_COMPACTION_STRATEGY_DEFAULT = ($clinit_CompactionStrategy_1() , DEPTH_FIRST_0);
  COMPACTION_COMPACTION_STRATEGY_0 = new Property_1('org.eclipse.elk.compaction.compactionStrategy', COMPACTION_COMPACTION_STRATEGY_DEFAULT);
  COMPACTION_ORTHOGONAL_0 = new Property_1('org.eclipse.elk.compaction.orthogonal', ($clinit_Boolean() , $clinit_Boolean() , false));
  OVERLAP_REMOVAL_MAX_ITERATIONS = new Property_1('org.eclipse.elk.overlapRemoval.maxIterations', valueOf_4(64));
  OVERLAP_REMOVAL_RUN_SCANLINE = new Property_1('org.eclipse.elk.overlapRemoval.runScanline', (null , true));
  PROCESSING_ORDER_PREFERRED_ROOT_DEP_PROCESSING_ORDER_ROOT_SELECTION_0 = FIXED_1;
}

function SporeMetaDataProvider(){
  $clinit_SporeMetaDataProvider();
}

defineClass(785, 1, $intern_92, SporeMetaDataProvider);
_.apply_3 = function apply_139(registry){
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.underlyingLayoutAlgorithm'), ''), 'Underlying Layout Algorithm'), 'A layout algorithm that is applied to the graph before it is compacted. If this is null, nothing is applied before compaction.'), ($clinit_LayoutOptionData$Type() , STRING)), Ljava_lang_String_2_classLit), of_0(($clinit_LayoutOptionData$Target() , PARENTS)))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.structure.structureExtractionStrategy'), 'structure'), 'Structure Extraction Strategy'), 'This option defines what kind of triangulation or other partitioning of the plane is applied to the vertices.'), STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_spore_options_StructureExtractionStrategy_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.processingOrder.treeConstruction'), 'processingOrder'), 'Tree Construction Strategy'), 'Whether a minimum spanning tree or a maximum spanning tree should be constructed.'), PROCESSING_ORDER_TREE_CONSTRUCTION_DEFAULT), ENUM), Lorg_eclipse_elk_alg_spore_options_TreeConstructionStrategy_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.processingOrder.spanningTreeCostFunction'), 'processingOrder'), 'Cost Function for Spanning Tree'), 'The cost function is used in the creation of the spanning tree.'), PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION_DEFAULT), ENUM), Lorg_eclipse_elk_alg_spore_options_SpanningTreeCostFunction_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.processingOrder.preferredRoot'), 'processingOrder'), 'Root node for spanning tree construction'), 'The identifier of the node that is preferred as the root of the spanning tree. If this is null, the first node is chosen.'), null), STRING), Ljava_lang_String_2_classLit), of_0(PARENTS))));
  $addDependency(registry, 'org.eclipse.elk.processingOrder.preferredRoot', 'org.eclipse.elk.processingOrder.rootSelection', PROCESSING_ORDER_PREFERRED_ROOT_DEP_PROCESSING_ORDER_ROOT_SELECTION_0);
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.processingOrder.rootSelection'), 'processingOrder'), 'Root selection for spanning tree'), 'This sets the method used to select a root node for the construction of a spanning tree'), PROCESSING_ORDER_ROOT_SELECTION_DEFAULT), ENUM), Lorg_eclipse_elk_alg_spore_options_RootSelection_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.compaction.compactionStrategy'), 'compaction'), 'Compaction Strategy'), 'This option defines how the compaction is applied.'), COMPACTION_COMPACTION_STRATEGY_DEFAULT), ENUM), Lorg_eclipse_elk_alg_spore_options_CompactionStrategy_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.compaction.orthogonal'), 'compaction'), 'Orthogonal Compaction'), 'Restricts the translation of nodes to orthogonal directions in the compaction phase.'), ($clinit_Boolean() , $clinit_Boolean() , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.overlapRemoval.maxIterations'), 'overlapRemoval'), 'Upper limit for iterations of overlap removal'), null), valueOf_4(64)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.overlapRemoval.runScanline'), 'overlapRemoval'), 'Whether to run a supplementary scanline overlap check.'), null), (null , true)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $apply_27((new SporeOverlapRemovalOptions , registry));
  $apply_26((new SporeCompactionOptions , registry));
}
;
var COMPACTION_COMPACTION_STRATEGY_0, COMPACTION_COMPACTION_STRATEGY_DEFAULT, COMPACTION_ORTHOGONAL_0, OVERLAP_REMOVAL_MAX_ITERATIONS, OVERLAP_REMOVAL_RUN_SCANLINE, PROCESSING_ORDER_PREFERRED_ROOT_0, PROCESSING_ORDER_PREFERRED_ROOT_DEP_PROCESSING_ORDER_ROOT_SELECTION_0, PROCESSING_ORDER_ROOT_SELECTION_0, PROCESSING_ORDER_ROOT_SELECTION_DEFAULT, PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION_0, PROCESSING_ORDER_SPANNING_TREE_COST_FUNCTION_DEFAULT, PROCESSING_ORDER_TREE_CONSTRUCTION_0, PROCESSING_ORDER_TREE_CONSTRUCTION_DEFAULT, STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_0, STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_DEFAULT, UNDERLYING_LAYOUT_ALGORITHM_0;
var Lorg_eclipse_elk_alg_spore_options_SporeMetaDataProvider_2_classLit = createForClass('org.eclipse.elk.alg.spore.options', 'SporeMetaDataProvider', 785);
function $clinit_SporeOverlapRemovalOptions(){
  $clinit_SporeOverlapRemovalOptions = emptyMethod;
  UNDERLYING_LAYOUT_ALGORITHM_1 = ($clinit_SporeMetaDataProvider() , UNDERLYING_LAYOUT_ALGORITHM_0);
  PADDING_DEFAULT_3 = new ElkPadding_0(8);
  new Property_2(($clinit_CoreOptions() , PADDING_5), PADDING_DEFAULT_3);
  new Property_2(SPACING_NODE_NODE_5, 8);
  STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_1 = STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_0;
  OVERLAP_REMOVAL_MAX_ITERATIONS_0 = OVERLAP_REMOVAL_MAX_ITERATIONS;
  OVERLAP_REMOVAL_RUN_SCANLINE_0 = OVERLAP_REMOVAL_RUN_SCANLINE;
  DEBUG_MODE_2 = new Property_2(DEBUG_MODE_3, ($clinit_Boolean() , $clinit_Boolean() , false));
}

function $apply_27(registry){
  $register(registry, new LayoutAlgorithmData($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.sporeOverlap'), 'ELK SPOrE Overlap Removal'), 'A node overlap removal algorithm proposed by Nachmanson et al. in "Node overlap removal by growing a tree".'), new SporeOverlapRemovalOptions$SporeOverlapFactory)));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeOverlap', 'org.eclipse.elk.underlyingLayoutAlgorithm', $getDefault(UNDERLYING_LAYOUT_ALGORITHM_1));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeOverlap', 'org.eclipse.elk.padding', PADDING_DEFAULT_3);
  $addOptionSupport(registry, 'org.eclipse.elk.sporeOverlap', 'org.eclipse.elk.spacing.nodeNode', 8);
  $addOptionSupport(registry, 'org.eclipse.elk.sporeOverlap', 'org.eclipse.elk.structure.structureExtractionStrategy', $getDefault(STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_1));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeOverlap', 'org.eclipse.elk.overlapRemoval.maxIterations', $getDefault(OVERLAP_REMOVAL_MAX_ITERATIONS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeOverlap', 'org.eclipse.elk.overlapRemoval.runScanline', $getDefault(OVERLAP_REMOVAL_RUN_SCANLINE_0));
  $addOptionSupport(registry, 'org.eclipse.elk.sporeOverlap', 'org.eclipse.elk.debugMode', ($clinit_Boolean() , $clinit_Boolean() , false));
}

function SporeOverlapRemovalOptions(){
  $clinit_SporeOverlapRemovalOptions();
}

defineClass(926, 1, $intern_92, SporeOverlapRemovalOptions);
_.apply_3 = function apply_140(registry){
  $apply_27(registry);
}
;
var DEBUG_MODE_2, OVERLAP_REMOVAL_MAX_ITERATIONS_0, OVERLAP_REMOVAL_RUN_SCANLINE_0, PADDING_DEFAULT_3, STRUCTURE_STRUCTURE_EXTRACTION_STRATEGY_1, UNDERLYING_LAYOUT_ALGORITHM_1;
var Lorg_eclipse_elk_alg_spore_options_SporeOverlapRemovalOptions_2_classLit = createForClass('org.eclipse.elk.alg.spore.options', 'SporeOverlapRemovalOptions', 926);
function SporeOverlapRemovalOptions$SporeOverlapFactory(){
}

defineClass(927, 1, {}, SporeOverlapRemovalOptions$SporeOverlapFactory);
_.create_0 = function create_32(){
  var provider;
  return provider = new OverlapRemovalLayoutProvider , provider;
}
;
_.destroy = function destroy_6(obj){
}
;
var Lorg_eclipse_elk_alg_spore_options_SporeOverlapRemovalOptions$SporeOverlapFactory_2_classLit = createForClass('org.eclipse.elk.alg.spore.options', 'SporeOverlapRemovalOptions/SporeOverlapFactory', 927);
function $clinit_StructureExtractionStrategy(){
  $clinit_StructureExtractionStrategy = emptyMethod;
  DELAUNAY_TRIANGULATION = new StructureExtractionStrategy;
}

function $create_15(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new DelaunayTriangulationPhase;
    default:throw toJs(new IllegalArgumentException_0('No implementation available for ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function StructureExtractionStrategy(){
  Enum.call(this, 'DELAUNAY_TRIANGULATION', 0);
}

function valueOf_81(name_0){
  $clinit_StructureExtractionStrategy();
  return valueOf(($clinit_StructureExtractionStrategy$Map() , $MAP_69), name_0);
}

function values_77(){
  $clinit_StructureExtractionStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_StructureExtractionStrategy_2_classLit, 1), $intern_38, 498, 0, [DELAUNAY_TRIANGULATION]);
}

defineClass(498, 22, {3:1, 34:1, 22:1, 498:1, 230:1, 231:1}, StructureExtractionStrategy);
_.create_1 = function create_34(){
  return $create_15(this);
}
;
_.create_2 = function create_33(){
  return $create_15(this);
}
;
var DELAUNAY_TRIANGULATION;
var Lorg_eclipse_elk_alg_spore_options_StructureExtractionStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.spore.options', 'StructureExtractionStrategy', 498, Ljava_lang_Enum_2_classLit, values_77, valueOf_81);
function $clinit_StructureExtractionStrategy$Map(){
  $clinit_StructureExtractionStrategy$Map = emptyMethod;
  $MAP_69 = createValueOfMap(($clinit_StructureExtractionStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_StructureExtractionStrategy_2_classLit, 1), $intern_38, 498, 0, [DELAUNAY_TRIANGULATION])));
}

var $MAP_69;
function $clinit_TreeConstructionStrategy(){
  $clinit_TreeConstructionStrategy = emptyMethod;
  MINIMUM_SPANNING_TREE = new TreeConstructionStrategy('MINIMUM_SPANNING_TREE', 0);
  MAXIMUM_SPANNING_TREE = new TreeConstructionStrategy('MAXIMUM_SPANNING_TREE', 1);
}

function $create_16(this$static){
  switch (this$static.ordinal) {
    case 0:
      return new MinSTPhase;
    case 1:
      return new MaxSTPhase;
    default:throw toJs(new IllegalArgumentException_0('No implementation available for ' + (this$static.name_0 != null?this$static.name_0:'' + this$static.ordinal)));
  }
}

function TreeConstructionStrategy(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_82(name_0){
  $clinit_TreeConstructionStrategy();
  return valueOf(($clinit_TreeConstructionStrategy$Map() , $MAP_70), name_0);
}

function values_78(){
  $clinit_TreeConstructionStrategy();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_TreeConstructionStrategy_2_classLit, 1), $intern_38, 408, 0, [MINIMUM_SPANNING_TREE, MAXIMUM_SPANNING_TREE]);
}

defineClass(408, 22, {3:1, 34:1, 22:1, 408:1, 230:1, 231:1}, TreeConstructionStrategy);
_.create_1 = function create_36(){
  return $create_16(this);
}
;
_.create_2 = function create_35(){
  return $create_16(this);
}
;
var MAXIMUM_SPANNING_TREE, MINIMUM_SPANNING_TREE;
var Lorg_eclipse_elk_alg_spore_options_TreeConstructionStrategy_2_classLit = createForEnum('org.eclipse.elk.alg.spore.options', 'TreeConstructionStrategy', 408, Ljava_lang_Enum_2_classLit, values_78, valueOf_82);
function $clinit_TreeConstructionStrategy$Map(){
  $clinit_TreeConstructionStrategy$Map = emptyMethod;
  $MAP_70 = createValueOfMap(($clinit_TreeConstructionStrategy() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_alg_spore_options_TreeConstructionStrategy_2_classLit, 1), $intern_38, 408, 0, [MINIMUM_SPANNING_TREE, MAXIMUM_SPANNING_TREE])));
}

var $MAP_70;
function $process_91(graph, progressMonitor){
  var vertices;
  $begin(progressMonitor, 'Delaunay triangulation', 1);
  vertices = new ArrayList;
  $forEach_0(graph.vertices, new DelaunayTriangulationPhase$lambda$0$Type(vertices));
  checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_InternalProperties() , DEBUG_SVG)))) && 'null10bw';
  !graph.tEdges?(graph.tEdges = triangulate(vertices)):$addAll(graph.tEdges, triangulate(vertices));
  $done_0(progressMonitor);
}

function DelaunayTriangulationPhase(){
}

defineClass(1314, 1, $intern_117, DelaunayTriangulationPhase);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_24(graph){
  return castTo(graph, 289) , new LayoutProcessorConfiguration;
}
;
_.process = function process_86(graph, progressMonitor){
  $process_91(castTo(graph, 289), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_spore_p1structure_DelaunayTriangulationPhase_2_classLit = createForClass('org.eclipse.elk.alg.spore.p1structure', 'DelaunayTriangulationPhase', 1314);
function DelaunayTriangulationPhase$lambda$0$Type(vertices_0){
  this.vertices_0 = vertices_0;
}

defineClass(1315, 1, {}, DelaunayTriangulationPhase$lambda$0$Type);
_.accept = function accept_100(arg0){
  $add_4(this.vertices_0, castTo(arg0, 58).originalVertex);
}
;
var Lorg_eclipse_elk_alg_spore_p1structure_DelaunayTriangulationPhase$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore.p1structure', 'DelaunayTriangulationPhase/lambda$0$Type', 1315);
function $addNode_1(this$static, s, t){
  var child, tTree, tTree$iterator;
  for (tTree$iterator = new ArrayList$1(t.children); tTree$iterator.i < tTree$iterator.this$01.array.length;) {
    tTree = castTo($next_10(tTree$iterator), 257);
    child = new Tree(castTo($get_6(this$static.nodeMap, tTree.node), 58));
    $add_4(s.children, child);
    $addNode_1(this$static, child, tTree);
  }
}

function $convert(this$static, tTree, graph){
  var root;
  $reset(this$static.nodeMap);
  $forEach_0(graph.vertices, new MinSTPhase$lambda$0$Type(this$static));
  root = new Tree(castTo($get_6(this$static.nodeMap, tTree.node), 58));
  $addNode_1(this$static, root, tTree);
  graph.tree = root;
}

function $lambda$0_9(this$static, n_0){
  return $put_1(this$static.nodeMap, n_0.originalVertex, n_0);
}

function MinSTPhase(){
  this.nodeMap = ($clinit_Maps() , new HashMap);
}

defineClass(724, 1, $intern_117, MinSTPhase);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_25(graph){
  return castTo(graph, 289) , new LayoutProcessorConfiguration;
}
;
_.process = function process_87(graph, progressMonitor){
  this.process_0(castTo(graph, 289), progressMonitor);
}
;
_.process_0 = function process_88(graph, progressMonitor){
  var lastArg, root, tTree;
  $begin(progressMonitor, 'Minimum spanning tree construction', 1);
  graph.preferredRoot?(root = graph.preferredRoot.originalVertex):(root = castTo($get_7(graph.vertices, 0), 58).originalVertex);
  checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_InternalProperties() , DEBUG_SVG))))?(tTree = createSpanningTree(graph.tEdges, root, (lastArg = graph.costFunction , lastArg))):(tTree = createSpanningTree(graph.tEdges, root, graph.costFunction));
  $convert(this, tTree, graph);
  $done_0(progressMonitor);
}
;
var Lorg_eclipse_elk_alg_spore_p2processingorder_MinSTPhase_2_classLit = createForClass('org.eclipse.elk.alg.spore.p2processingorder', 'MinSTPhase', 724);
function MaxSTPhase(){
  MinSTPhase.call(this);
}

function lambda$0_14(graph_0, e_1){
  return -graph_0.costFunction.cost(e_1);
}

defineClass(1317, 724, $intern_117, MaxSTPhase);
_.process_0 = function process_89(graph, progressMonitor){
  var invertedCF, root, tree;
  $begin(progressMonitor, 'Maximum spanning tree construction', 1);
  invertedCF = new MaxSTPhase$lambda$0$Type(graph);
  graph.preferredRoot?(root = graph.preferredRoot.vertex):(root = castTo($get_7(graph.vertices, 0), 58).vertex);
  checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_InternalProperties() , DEBUG_SVG))))?(tree = createSpanningTree(graph.tEdges, root, invertedCF)):(tree = createSpanningTree(graph.tEdges, root, invertedCF));
  $convert(this, tree, graph);
  $done_0(progressMonitor);
}
;
var Lorg_eclipse_elk_alg_spore_p2processingorder_MaxSTPhase_2_classLit = createForClass('org.eclipse.elk.alg.spore.p2processingorder', 'MaxSTPhase', 1317);
function MaxSTPhase$lambda$0$Type(graph_0){
  this.graph_0 = graph_0;
}

defineClass(1318, 1, {}, MaxSTPhase$lambda$0$Type);
_.cost = function cost_5(arg0){
  return lambda$0_14(this.graph_0, arg0);
}
;
var Lorg_eclipse_elk_alg_spore_p2processingorder_MaxSTPhase$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore.p2processingorder', 'MaxSTPhase/lambda$0$Type', 1318);
function MinSTPhase$lambda$0$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(1316, 1, {}, MinSTPhase$lambda$0$Type);
_.accept = function accept_101(arg0){
  $lambda$0_9(this.$$outer_0, arg0);
}
;
var Lorg_eclipse_elk_alg_spore_p2processingorder_MinSTPhase$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore.p2processingorder', 'MinSTPhase/lambda$0$Type', 1316);
function $debugOut(this$static, c){
  $drawTree(this$static, this$static.root, this$static.svg);
  castTo(this$static.root.node, 58);
  !!c && castTo(c.node, 58).rect;
}

function $drawTree(this$static, t, img){
  castTo(t.node, 58);
  $forEach_0(t.children, new GrowTreePhase$lambda$0$Type(this$static, img, t));
}

function $growAt(this$static, r){
  var c, c$iterator, t;
  for (c$iterator = new ArrayList$1(r.children); c$iterator.i < c$iterator.this$01.array.length;) {
    c = castTo($next_10(c$iterator), 257);
    $translate(castTo(c.node, 58), $sub_0($clone_0(castTo(r.node, 58).vertex), castTo(r.node, 58).originalVertex));
    t = overlap(castTo(r.node, 58).rect, castTo(c.node, 58).rect);
    t > 1 && (this$static.overlapsExisted = true);
    $setCenterPosition(castTo(c.node, 58), $add_19($clone_0(castTo(r.node, 58).vertex), $scale($sub_0($clone_0(castTo(c.node, 58).originalVertex), castTo(r.node, 58).originalVertex), t)));
    $debugOut(this$static, r);
    $growAt(this$static, c);
  }
}

function $lambda$0_10(this$static, img_1, t_2, c_2){
  castTo(t_2.node, 58);
  castTo(t_2.node, 58);
  castTo(c_2.node, 58);
  castTo(c_2.node, 58);
  castTo(c_2.node, 58);
  $forEach_0(c_2.children, new GrowTreePhase$lambda$0$Type(this$static, img_1, c_2));
}

function $process_92(this$static, graph, progressMonitor){
  $begin(progressMonitor, 'Grow Tree', 1);
  this$static.root = graph.tree;
  if (checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_InternalProperties() , DEBUG_SVG))))) {
    this$static.svg = new SVGImage;
    $debugOut(this$static, null);
  }
   else {
    this$static.svg = new SVGImage;
  }
  this$static.overlapsExisted = false;
  $growAt(this$static, graph.tree);
  $setProperty_0(graph, OVERLAPS_EXISTED, ($clinit_Boolean() , this$static.overlapsExisted?true:false));
  $done_0(progressMonitor);
}

function GrowTreePhase(){
}

defineClass(726, 1, $intern_117, GrowTreePhase);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_26(graph){
  return castTo(graph, 289) , new LayoutProcessorConfiguration;
}
;
_.process = function process_90(graph, progressMonitor){
  $process_92(this, castTo(graph, 289), progressMonitor);
}
;
_.overlapsExisted = false;
var Lorg_eclipse_elk_alg_spore_p3execution_GrowTreePhase_2_classLit = createForClass('org.eclipse.elk.alg.spore.p3execution', 'GrowTreePhase', 726);
function GrowTreePhase$lambda$0$Type($$outer_0, img_1, t_2){
  this.$$outer_0 = $$outer_0;
  this.img_1 = img_1;
  this.t_2 = t_2;
}

defineClass(727, 1, {}, GrowTreePhase$lambda$0$Type);
_.accept = function accept_102(arg0){
  $lambda$0_10(this.$$outer_0, this.img_1, this.t_2, arg0);
}
;
var Lorg_eclipse_elk_alg_spore_p3execution_GrowTreePhase$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore.p3execution', 'GrowTreePhase/lambda$0$Type', 727);
function $debugOut_0(this$static, tree){
  var svg;
  svg = new SVGImage;
  castTo(tree.node, 58);
  castTo(tree.node, 58);
  castTo(tree.node, 58);
  $forEach_0(tree.children, new ShrinkTreeCompactionPhase$lambda$0$Type(this$static, svg, tree));
}

function $lambda$0_11(this$static, svg_1, t_2, c_2){
  var cv;
  castTo(t_2.node, 58);
  castTo(t_2.node, 58);
  castTo(c_2.node, 58);
  castTo(c_2.node, 58);
  cv = $sub_0($clone_0(castTo(t_2.node, 58).vertex), castTo(c_2.node, 58).vertex);
  $scaleToLength(cv, $distance(castTo(t_2.node, 58), castTo(c_2.node, 58), cv));
  castTo(c_2.node, 58);
  castTo(c_2.node, 58);
  castTo(c_2.node, 58);
  $forEach_0(c_2.children, new ShrinkTreeCompactionPhase$lambda$0$Type(this$static, svg_1, c_2));
}

function $process_93(this$static, graph, progressMonitor){
  var lastArg;
  $begin(progressMonitor, 'Shrinking tree compaction', 1);
  if (checkNotNull_1(castToBoolean($getProperty(graph, ($clinit_InternalProperties() , DEBUG_SVG))))) {
    $debugOut_0(this$static, graph.tree);
    compact_0(graph.tree, (lastArg = graph.orthogonalCompaction , lastArg));
  }
   else {
    compact_0(graph.tree, graph.orthogonalCompaction);
  }
  $done_0(progressMonitor);
}

function ShrinkTreeCompactionPhase(){
}

defineClass(1319, 1, $intern_117, ShrinkTreeCompactionPhase);
_.getLayoutProcessorConfiguration = function getLayoutProcessorConfiguration_27(graph){
  return castTo(graph, 289) , new LayoutProcessorConfiguration;
}
;
_.process = function process_91(graph, progressMonitor){
  $process_93(this, castTo(graph, 289), progressMonitor);
}
;
var Lorg_eclipse_elk_alg_spore_p3execution_ShrinkTreeCompactionPhase_2_classLit = createForClass('org.eclipse.elk.alg.spore.p3execution', 'ShrinkTreeCompactionPhase', 1319);
function ShrinkTreeCompactionPhase$lambda$0$Type($$outer_0, svg_1, t_2){
  this.$$outer_0 = $$outer_0;
  this.svg_1 = svg_1;
  this.t_2 = t_2;
}

defineClass(725, 1, {}, ShrinkTreeCompactionPhase$lambda$0$Type);
_.accept = function accept_103(arg0){
  $lambda$0_11(this.$$outer_0, this.svg_1, this.t_2, arg0);
}
;
var Lorg_eclipse_elk_alg_spore_p3execution_ShrinkTreeCompactionPhase$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.alg.spore.p3execution', 'ShrinkTreeCompactionPhase/lambda$0$Type', 725);
var Lorg_eclipse_elk_core_util_IGraphElementVisitor_2_classLit = createForInterface('org.eclipse.elk.core.util', 'IGraphElementVisitor');
function $clinit_LayoutConfigurator(){
  $clinit_LayoutConfigurator = emptyMethod;
  new Property('org.eclipse.elk.addLayoutConfig');
  NO_OVERWRITE = new LayoutConfigurator$lambda$0$Type;
}

function $addFilter(this$static, filter){
  $add_4(this$static.optionFilters, filter);
  return this$static;
}

function $applyProperties(this$static, element, properties){
  var accept, entry, entry$iterator;
  if (this$static.optionFilters.array.length == 0) {
    element.copyProperties(properties);
  }
   else {
    for (entry$iterator = (!properties.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):properties.propertyMap).entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
      entry = castTo(entry$iterator.next_1(), 39);
      accept = $findFirst($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(this$static.optionFilters, 16)), new Predicate$lambda$0$Type(new LayoutConfigurator$lambda$1$Type(element, entry)))).ref == null;
      accept && element.setProperty(castTo(entry.getKey(), 169), entry.getValue());
    }
  }
}

function $configure(this$static, elementClass){
  var result;
  result = castTo($get_6(this$static.classOptionMap, elementClass), 130);
  if (!result) {
    result = new MapPropertyHolder;
    $put_1(this$static.classOptionMap, elementClass, result);
  }
  return result;
}

function $findClassOptions(this$static, element){
  var combined;
  combined = new MapPropertyHolder;
  !!element && $copyProperties(combined, castTo($get_6(this$static.classOptionMap, Lorg_eclipse_elk_graph_ElkGraphElement_2_classLit), 94));
  instanceOf(element, 444) && $copyProperties(combined, castTo($get_6(this$static.classOptionMap, Lorg_eclipse_elk_graph_ElkShape_2_classLit), 94));
  if (instanceOf(element, 241)) {
    $copyProperties(combined, castTo($get_6(this$static.classOptionMap, Lorg_eclipse_elk_graph_ElkLabel_2_classLit), 94));
    return combined;
  }
  instanceOf(element, 97) && $copyProperties(combined, castTo($get_6(this$static.classOptionMap, Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit), 94));
  if (instanceOf(element, 240)) {
    $copyProperties(combined, castTo($get_6(this$static.classOptionMap, Lorg_eclipse_elk_graph_ElkNode_2_classLit), 94));
    return combined;
  }
  if (instanceOf(element, 187)) {
    $copyProperties(combined, castTo($get_6(this$static.classOptionMap, Lorg_eclipse_elk_graph_ElkPort_2_classLit), 94));
    return combined;
  }
  instanceOf(element, 173) && $copyProperties(combined, castTo($get_6(this$static.classOptionMap, Lorg_eclipse_elk_graph_ElkEdge_2_classLit), 94));
  return combined;
}

function LayoutConfigurator(){
  $clinit_LayoutConfigurator();
  this.elementOptionMap = ($clinit_Maps() , new HashMap);
  this.classOptionMap = new HashMap;
  this.optionFilters = new ArrayList;
}

defineClass(789, 1, {641:1}, LayoutConfigurator);
_.visit = function visit(element){
  var combined;
  combined = $findClassOptions(this, element);
  $copyProperties(combined, castTo($get_6(this.elementOptionMap, element), 94));
  $applyProperties(this, element, combined);
}
;
var NO_OVERWRITE;
var Lorg_eclipse_elk_core_LayoutConfigurator_2_classLit = createForClass('org.eclipse.elk.core', 'LayoutConfigurator', 789);
function $accept_5(e, p){
  return $clinit_LayoutConfigurator() , !e.hasProperty(p);
}

function LayoutConfigurator$lambda$0$Type(){
}

defineClass(863, 1, {}, LayoutConfigurator$lambda$0$Type);
var Lorg_eclipse_elk_core_LayoutConfigurator$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.core', 'LayoutConfigurator/lambda$0$Type', 863);
function LayoutConfigurator$lambda$1$Type(element_0, entry_1){
  this.element_0 = element_0;
  this.entry_1 = entry_1;
}

defineClass(864, 1, $intern_90, LayoutConfigurator$lambda$1$Type);
_.test_0 = function test_78(arg0){
  return $clinit_LayoutConfigurator() , $accept_5(this.element_0, castTo(this.entry_1.getKey(), 169));
}
;
var Lorg_eclipse_elk_core_LayoutConfigurator$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.core', 'LayoutConfigurator/lambda$1$Type', 864);
function $countNodesRecursively(this$static, layoutNode, countAncestors){
  var childNode, childNode$iterator, count, parent_0;
  count = (!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children).size_0;
  for (childNode$iterator = new AbstractEList$EIterator((!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children)); childNode$iterator.cursor != childNode$iterator.this$01_2.size_1();) {
    childNode = castTo($doNext(childNode$iterator), 35);
    (!childNode.children && (childNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, childNode, 10, 11)) , childNode.children).size_0 == 0 || (count += $countNodesRecursively(this$static, childNode, false));
  }
  if (countAncestors) {
    parent_0 = $getParent_2(layoutNode);
    while (parent_0) {
      count += (!parent_0.children && (parent_0.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parent_0, 10, 11)) , parent_0.children).size_0;
      parent_0 = $getParent_2(parent_0);
    }
  }
  return count;
}

function $countNodesWithHierarchy(this$static, parentNode){
  var childData, childNode, childNode$iterator, count, parentData;
  count = (!parentNode.children && (parentNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parentNode, 10, 11)) , parentNode.children).size_0;
  for (childNode$iterator = new AbstractEList$EIterator((!parentNode.children && (parentNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parentNode, 10, 11)) , parentNode.children)); childNode$iterator.cursor != childNode$iterator.this$01_2.size_1();) {
    childNode = castTo($doNext(childNode$iterator), 35);
    if (maskUndefined($getProperty_0(childNode, ($clinit_CoreOptions() , HIERARCHY_HANDLING_0))) !== maskUndefined(($clinit_HierarchyHandling() , SEPARATE_CHILDREN))) {
      parentData = castTo($getProperty_0(parentNode, RESOLVED_ALGORITHM), 153);
      childData = castTo($getProperty_0(childNode, RESOLVED_ALGORITHM), 153);
      (parentData == childData || !!parentData && $equals_6(parentData, childData)) && (!childNode.children && (childNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, childNode, 10, 11)) , childNode.children).size_0 != 0 && (count += $countNodesWithHierarchy(this$static, childNode));
    }
  }
  return count;
}

function $evaluateHierarchyHandlingInheritance(layoutNode){
  var parentHandling;
  if (maskUndefined($getProperty_0(layoutNode, ($clinit_CoreOptions() , HIERARCHY_HANDLING_0))) === maskUndefined(($clinit_HierarchyHandling() , INHERIT))) {
    if (!$getParent_2(layoutNode)) {
      $setProperty_1(layoutNode, HIERARCHY_HANDLING_0, SEPARATE_CHILDREN);
    }
     else {
      parentHandling = castTo($getProperty_0($getParent_2(layoutNode), HIERARCHY_HANDLING_0), 324);
      $setProperty_1(layoutNode, HIERARCHY_HANDLING_0, parentHandling);
    }
  }
}

function $executeAlgorithm(layoutNode, algorithmData, progressMonitor){
  var exception, layoutProvider;
  layoutProvider = castTo($fetch(algorithmData.providerPool), 197);
  try {
    layoutProvider.layout(layoutNode, progressMonitor);
    $release(algorithmData.providerPool, layoutProvider);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 102)) {
      exception = $e0;
      throw toJs(exception);
    }
     else 
      throw toJs($e0);
  }
}

function $gatherInsideSelfLoops(node){
  var edge, edge$iterator, insideSelfLoops;
  if (checkNotNull_1(castToBoolean($getProperty_0(node, ($clinit_CoreOptions() , INSIDE_SELF_LOOPS_ACTIVATE_0))))) {
    insideSelfLoops = new ArrayList;
    for (edge$iterator = $iterator(allOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 100);
      $isSelfloop(edge) && checkNotNull_1(castToBoolean($getProperty_0(edge, INSIDE_SELF_LOOPS_YO_0))) && (insideSelfLoops.array[insideSelfLoops.array.length] = edge , true);
    }
    return insideSelfLoops;
  }
   else {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
}

function $layout_3(this$static, layoutGraph, progressMonitor){
  var nodeCount;
  nodeCount = $countNodesRecursively(this$static, layoutGraph, true);
  $begin(progressMonitor, 'Recursive Graph Layout', nodeCount);
  $hasProperty_0(layoutGraph, ($clinit_CoreOptions() , RESOLVED_ALGORITHM)) || applyVisitors(layoutGraph, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_util_IGraphElementVisitor_2_classLit, 1), $intern_1, 641, 0, [new LayoutAlgorithmResolver]));
  $layoutRecursively(this$static, layoutGraph, progressMonitor);
  $done_0(progressMonitor);
}

function $layoutRecursively(this$static, layoutNode, progressMonitor){
  var algorithmData, child, child$iterator, childLayoutSelfLoops, childrenInsideSelfLoops, hasChildren, hasInsideSelfLoops, insideSelfLoops, node, nodeCount, nodeQueue, selfLoop, selfLoop$iterator, stopHierarchy, supportsInsideSelfLoops;
  if (checkNotNull_1(castToBoolean($getProperty_0(layoutNode, ($clinit_CoreOptions() , NO_LAYOUT_0))))) {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
  hasChildren = (!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children).size_0 != 0;
  insideSelfLoops = $gatherInsideSelfLoops(layoutNode);
  hasInsideSelfLoops = !insideSelfLoops.isEmpty();
  if (hasChildren || hasInsideSelfLoops) {
    algorithmData = castTo($getProperty_0(layoutNode, RESOLVED_ALGORITHM), 153);
    if (!algorithmData) {
      throw toJs(new UnsupportedConfigurationException_0('Resolved algorithm is not set; apply a LayoutAlgorithmResolver before computing layout.'));
    }
    supportsInsideSelfLoops = $supportsFeature(algorithmData, ($clinit_GraphFeature() , INSIDE_SELF_LOOPS));
    $evaluateHierarchyHandlingInheritance(layoutNode);
    if (!hasChildren && hasInsideSelfLoops && !supportsInsideSelfLoops) {
      return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
    }
    childrenInsideSelfLoops = new ArrayList;
    if (maskUndefined($getProperty_0(layoutNode, HIERARCHY_HANDLING_0)) === maskUndefined(($clinit_HierarchyHandling() , INCLUDE_CHILDREN)) && ($supportsFeature(algorithmData, COMPOUND) || $supportsFeature(algorithmData, CLUSTERS))) {
      nodeCount = $countNodesWithHierarchy(this$static, layoutNode);
      nodeQueue = new LinkedList;
      $addAll(nodeQueue, (!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children));
      while (nodeQueue.size_0 != 0) {
        node = castTo(nodeQueue.size_0 == 0?null:(checkCriticalElement(nodeQueue.size_0 != 0) , $removeNode_0(nodeQueue, nodeQueue.header.next_0)), 35);
        $evaluateHierarchyHandlingInheritance(node);
        stopHierarchy = maskUndefined($getProperty_0(node, HIERARCHY_HANDLING_0)) === maskUndefined(SEPARATE_CHILDREN);
        if (stopHierarchy || $hasProperty_0(node, ALGORITHM) && !$equals_6(algorithmData, $getProperty_0(node, RESOLVED_ALGORITHM))) {
          childLayoutSelfLoops = $layoutRecursively(this$static, node, progressMonitor);
          $addAll_2(childrenInsideSelfLoops, childLayoutSelfLoops);
          $setProperty_1(node, HIERARCHY_HANDLING_0, SEPARATE_CHILDREN);
          applyConfiguredNodeScaling(node);
        }
         else {
          $addAll(nodeQueue, (!node.children && (node.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, node, 10, 11)) , node.children));
        }
      }
    }
     else {
      nodeCount = (!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children).size_0;
      for (child$iterator = new AbstractEList$EIterator((!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children)); child$iterator.cursor != child$iterator.this$01_2.size_1();) {
        child = castTo($doNext(child$iterator), 35);
        childLayoutSelfLoops = $layoutRecursively(this$static, child, progressMonitor);
        $addAll_2(childrenInsideSelfLoops, childLayoutSelfLoops);
        applyConfiguredNodeScaling(child);
      }
    }
    for (selfLoop$iterator = new ArrayList$1(childrenInsideSelfLoops); selfLoop$iterator.i < selfLoop$iterator.this$01.array.length;) {
      selfLoop = castTo($next_10(selfLoop$iterator), 100);
      $setProperty_1(selfLoop, NO_LAYOUT_0, ($clinit_Boolean() , $clinit_Boolean() , true));
    }
    $executeAlgorithm(layoutNode, algorithmData, $subTask(progressMonitor, nodeCount));
    $postProcessInsideSelfLoops(childrenInsideSelfLoops);
    return hasInsideSelfLoops && supportsInsideSelfLoops?insideSelfLoops:($clinit_Collections() , $clinit_Collections() , EMPTY_LIST);
  }
   else {
    return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
  }
}

function $postProcessInsideSelfLoops(insideSelfLoops){
  var bend, bend$iterator, node, section, selfLoop, selfLoop$iterator, xOffset, yOffset;
  for (selfLoop$iterator = new ArrayList$1(insideSelfLoops); selfLoop$iterator.i < selfLoop$iterator.this$01.array.length;) {
    selfLoop = castTo($next_10(selfLoop$iterator), 100);
    node = connectableShapeToNode(castTo($get_16((!selfLoop.sources && (selfLoop.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, selfLoop, 4, 7)) , selfLoop.sources), 0), 97));
    xOffset = node.x_0;
    yOffset = node.y_0;
    section = castTo($get_16((!selfLoop.sections && (selfLoop.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, selfLoop, 6, 6)) , selfLoop.sections), 0), 228);
    $setStartLocation(section, section.startX + xOffset, section.startY + yOffset);
    $setEndLocation(section, section.endX + xOffset, section.endY + yOffset);
    for (bend$iterator = new AbstractEList$EIterator((!section.bendPoints && (section.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, section, 5)) , section.bendPoints)); bend$iterator.cursor != bend$iterator.this$01_2.size_1();) {
      bend = castTo($doNext(bend$iterator), 556);
      $set_7(bend, bend.x_0 + xOffset, bend.y_0 + yOffset);
    }
    $offset_1(castTo($getProperty_0(selfLoop, ($clinit_CoreOptions() , JUNCTION_POINTS_0)), 74), xOffset, yOffset);
  }
}

function RecursiveGraphLayoutEngine(){
}

defineClass(787, 1, {}, RecursiveGraphLayoutEngine);
var Lorg_eclipse_elk_core_RecursiveGraphLayoutEngine_2_classLit = createForClass('org.eclipse.elk.core', 'RecursiveGraphLayoutEngine', 787);
function UnsupportedConfigurationException(){
  RuntimeException.call(this);
}

function UnsupportedConfigurationException_0(message){
  RuntimeException_0.call(this, message);
}

defineClass(335, 54, $intern_44, UnsupportedConfigurationException, UnsupportedConfigurationException_0);
var Lorg_eclipse_elk_core_UnsupportedConfigurationException_2_classLit = createForClass('org.eclipse.elk.core', 'UnsupportedConfigurationException', 335);
function UnsupportedGraphException(message){
  RuntimeException_0.call(this, message);
}

defineClass(537, 54, $intern_44, UnsupportedGraphException);
var Lorg_eclipse_elk_core_UnsupportedGraphException_2_classLit = createForClass('org.eclipse.elk.core', 'UnsupportedGraphException', 537);
function $ensureListSize(this$static, size_0){
  var i;
  for (i = this$static.list.array.length; i < size_0; i++) {
    $add_4(this$static.list, this$static.provideDefault());
  }
}

function $getListItem(this$static, index_0){
  if (index_0 < 0) {
    throw toJs(new IndexOutOfBoundsException_0('Invalid index: ' + index_0));
  }
  $ensureListSize(this$static, index_0 + 1);
  return $get_7(this$static.list, index_0);
}

function $setListItem(this$static, index_0, value_0){
  if (index_0 < 0) {
    throw toJs(new IndexOutOfBoundsException_0('Invalid index: ' + index_0));
  }
  if (index_0 < this$static.list.array.length) {
    $set_1(this$static.list, index_0, value_0);
  }
   else {
    $ensureListSize(this$static, index_0);
    $add_4(this$static.list, value_0);
  }
}

function AbstractRandomListAccessor(){
  this.list = new ArrayList;
}

defineClass(694, 1, {});
var Lorg_eclipse_elk_core_alg_AbstractRandomListAccessor_2_classLit = createForClass('org.eclipse.elk.core.alg', 'AbstractRandomListAccessor', 694);
function $addProcessorConfiguration(this$static, config){
  $addAll_4(this$static.additionalProcessors, config);
  return this$static;
}

function $build(this$static, graph){
  var algorithm, phase, phase$index, phase$index0, phase$max, phase$max0, phaseEnumConstants, phaseFactory, phaseImplementation, phaseImplementations, processorConfiguration;
  if (this$static.failOnMissingPhase && this$static.configuredPhases.size_0 < this$static.numberOfPhases) {
    throw toJs(new IllegalStateException_0('Expected ' + this$static.numberOfPhases + ' phases to be configured; ' + 'only found ' + this$static.configuredPhases.size_0));
  }
  phaseEnumConstants = castTo($getEnumConstants(this$static.phasesEnumClass), 10);
  phaseImplementations = newArrayListWithCapacity(this$static.numberOfPhases);
  for (phase$index0 = 0 , phase$max0 = phaseEnumConstants.length; phase$index0 < phase$max0; ++phase$index0) {
    phase = phaseEnumConstants[phase$index0];
    phaseFactory = castTo($getListItem(this$static, phase.ordinal), 230);
    phaseFactory?$add_4(phaseImplementations, castTo($retrieveProcessor(this$static, phaseFactory), 126)):(phaseImplementations.array[phaseImplementations.array.length] = null , true);
  }
  processorConfiguration = new LayoutProcessorConfiguration;
  $forEach_2($filter($map($filter(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(phaseImplementations, 16)), new AlgorithmAssembler$lambda$0$Type), new AlgorithmAssembler$lambda$1$Type(graph)), new AlgorithmAssembler$lambda$2$Type), new AlgorithmAssembler$lambda$3$Type(processorConfiguration));
  $addAll_4(processorConfiguration, this$static.additionalProcessors);
  algorithm = new ArrayList;
  for (phase$index = 0 , phase$max = phaseEnumConstants.length; phase$index < phase$max; ++phase$index) {
    phase = phaseEnumConstants[phase$index];
    $addAll_2(algorithm, $retrieveProcessors(this$static, newHashSet(castTo($getListItem(processorConfiguration, phase.ordinal), 20))));
    phaseImplementation = castTo($get_7(phaseImplementations, phase.ordinal), 126);
    !!phaseImplementation && (algorithm.array[algorithm.array.length] = phaseImplementation , true);
  }
  $addAll_2(algorithm, $retrieveProcessors(this$static, newHashSet(castTo($getListItem(processorConfiguration, phaseEnumConstants[phaseEnumConstants.length - 1].ordinal + 1), 20))));
  return algorithm;
}

function $lambda$4_1(this$static, processors_1, factory_1){
  return $add_4(processors_1, $retrieveProcessor(this$static, factory_1));
}

function $reset_4(this$static){
  this$static.list.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  $clear_1(this$static.configuredPhases);
  $clear_8(this$static.additionalProcessors);
  return this$static;
}

function $retrieveProcessor(this$static, factory){
  var processor;
  if (this$static.enableCaching) {
    if ($containsKey_2(this$static.cache, factory)) {
      return castTo($get_6(this$static.cache, factory), 45);
    }
     else {
      processor = factory.create_1();
      $put_1(this$static.cache, factory, processor);
      return processor;
    }
  }
   else {
    return factory.create_1();
  }
}

function $retrieveProcessors(this$static, factories){
  var processors;
  processors = newArrayListWithCapacity(factories.map_0.size_1());
  $forEach_2($sorted(new Stream$StreamSource(null, new Spliterators$IteratorSpliterator(factories, 1)), this$static.processorComparator), new AlgorithmAssembler$lambda$4$Type(this$static, processors));
  return processors;
}

function $setPhase(this$static, phase, phaseFactory){
  $setListItem(this$static, phase.ordinal, phaseFactory);
  $add_5(this$static.configuredPhases, phase);
  return this$static;
}

function AlgorithmAssembler(phaseEnum){
  var all;
  AbstractRandomListAccessor.call(this);
  this.processorComparator = new EnumBasedFactoryComparator;
  this.phasesEnumClass = phaseEnum;
  this.numberOfPhases = castTo(phaseEnum.enumConstantsFunc && phaseEnum.enumConstantsFunc(), 10).length;
  if (this.numberOfPhases == 0) {
    throw toJs(new IllegalArgumentException_0('There must be at least one phase in the phase enumeration.'));
  }
  this.configuredPhases = (all = castTo($getEnumConstants(this.phasesEnumClass), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  this.additionalProcessors = new LayoutProcessorConfiguration;
  this.cache = ($clinit_Maps() , new HashMap);
}

function lambda$1_5(graph_0, phase_1){
  return phase_1.getLayoutProcessorConfiguration(graph_0);
}

defineClass(468, 694, {}, AlgorithmAssembler);
_.provideDefault = function provideDefault(){
  return null;
}
;
_.enableCaching = true;
_.failOnMissingPhase = true;
_.numberOfPhases = 0;
var Lorg_eclipse_elk_core_alg_AlgorithmAssembler_2_classLit = createForClass('org.eclipse.elk.core.alg', 'AlgorithmAssembler', 468);
function AlgorithmAssembler$lambda$0$Type(){
}

defineClass(1063, 1, $intern_90, AlgorithmAssembler$lambda$0$Type);
_.test_0 = function test_79(arg0){
  return !!castTo(arg0, 126);
}
;
var Lorg_eclipse_elk_core_alg_AlgorithmAssembler$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.core.alg', 'AlgorithmAssembler/lambda$0$Type', 1063);
function AlgorithmAssembler$lambda$1$Type(graph_0){
  this.graph_0 = graph_0;
}

defineClass(1064, 1, $intern_11, AlgorithmAssembler$lambda$1$Type);
_.apply_0 = function apply_141(arg0){
  return lambda$1_5(this.graph_0, arg0);
}
;
var Lorg_eclipse_elk_core_alg_AlgorithmAssembler$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.core.alg', 'AlgorithmAssembler/lambda$1$Type', 1064);
function AlgorithmAssembler$lambda$2$Type(){
}

defineClass(1065, 1, $intern_90, AlgorithmAssembler$lambda$2$Type);
_.test_0 = function test_80(arg0){
  return !!castTo(arg0, 75);
}
;
var Lorg_eclipse_elk_core_alg_AlgorithmAssembler$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.core.alg', 'AlgorithmAssembler/lambda$2$Type', 1065);
function AlgorithmAssembler$lambda$3$Type(processorConfiguration_0){
  this.processorConfiguration_0 = processorConfiguration_0;
}

defineClass(1066, 1, {}, AlgorithmAssembler$lambda$3$Type);
_.accept = function accept_104(arg0){
  $addAll_4(this.processorConfiguration_0, castTo(arg0, 75));
}
;
var Lorg_eclipse_elk_core_alg_AlgorithmAssembler$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.core.alg', 'AlgorithmAssembler/lambda$3$Type', 1066);
function AlgorithmAssembler$lambda$4$Type($$outer_0, processors_1){
  this.$$outer_0 = $$outer_0;
  this.processors_1 = processors_1;
}

defineClass(1067, 1, {}, AlgorithmAssembler$lambda$4$Type);
_.accept = function accept_105(arg0){
  $lambda$4_1(this.$$outer_0, this.processors_1, arg0);
}
;
var Lorg_eclipse_elk_core_alg_AlgorithmAssembler$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.core.alg', 'AlgorithmAssembler/lambda$4$Type', 1067);
function $compare_22(factory1, factory2){
  getClass__Ljava_lang_Class___devirtual$(factory1);
  getClass__Ljava_lang_Class___devirtual$(factory2);
  return $compareTo(castTo(factory1, 22), castTo(factory2, 22));
}

function EnumBasedFactoryComparator(){
}

defineClass(1213, 1, $intern_40, EnumBasedFactoryComparator);
_.compare_0 = function compare_70(factory1, factory2){
  return $compare_22(castTo(factory1, 231), castTo(factory2, 231));
}
;
_.equals_0 = function equals_163(other){
  return this === other;
}
;
_.reversed = function reversed_62(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_core_alg_EnumBasedFactoryComparator_2_classLit = createForClass('org.eclipse.elk.core.alg', 'EnumBasedFactoryComparator', 1213);
function $add_17(this$static, processor){
  if (this$static.currentIndex < 0) {
    throw toJs(new IllegalStateException_0('Did not call before(...) or after(...) before calling add(...).'));
  }
  $doAdd(this$static, this$static.currentIndex, processor);
  return this$static;
}

function $addAfter(this$static, phase, processor){
  this$static.currentIndex = -1;
  $doAdd(this$static, phase.ordinal + 1, processor);
  return this$static;
}

function $addAll_4(this$static, configuration){
  var i;
  for (i = 0; i < configuration.list.array.length; i++) {
    castTo($getListItem(this$static, i), 19).addAll(castTo($getListItem(configuration, i), 13));
  }
  return this$static;
}

function $addBefore(this$static, phase, processor){
  this$static.currentIndex = -1;
  $doAdd(this$static, phase.ordinal, processor);
  return this$static;
}

function $after(this$static, phase){
  this$static.currentIndex = phase.ordinal + 1;
  return this$static;
}

function $before(this$static, phase){
  this$static.currentIndex = phase.ordinal;
  return this$static;
}

function $clear_8(this$static){
  this$static.list.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this$static.currentIndex = -1;
  return this$static;
}

function $doAdd(this$static, index_0, processor){
  castTo($getListItem(this$static, index_0), 19).add_1(processor);
}

function LayoutProcessorConfiguration(){
  AbstractRandomListAccessor.call(this);
  this.list.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  this.currentIndex = -1;
}

function createFrom_0(source){
  return $addAll_4(new LayoutProcessorConfiguration, source);
}

defineClass(75, 694, {75:1}, LayoutProcessorConfiguration);
_.provideDefault = function provideDefault_0(){
  return new HashSet;
}
;
_.currentIndex = 0;
var Lorg_eclipse_elk_core_alg_LayoutProcessorConfiguration_2_classLit = createForClass('org.eclipse.elk.core.alg', 'LayoutProcessorConfiguration', 75);
function $addKnownOption(this$static, property, defaultValue){
  $putStringValue(this$static.knownOptions, property.id_0, defaultValue);
}

function $equals_6(this$static, obj){
  if (instanceOf(obj, 153)) {
    return $equals_4(this$static.id_0, castTo(obj, 153).id_0);
  }
  return false;
}

function $supportsFeature(this$static, graphFeature){
  return $containsEnum(this$static.supportedFeatures, graphFeature);
}

function LayoutAlgorithmData(builder){
  var all;
  this.knownOptions = ($clinit_Maps() , new HashMap);
  this.id_0 = builder.id_0;
  this.name_0 = builder.name_0;
  this.description = builder.description;
  this.providerPool = new InstancePool(builder.providerFactory);
  this.category = builder.category;
  !builder.supportedFeatures?(this.supportedFeatures = (all = castTo($getEnumConstants(Lorg_eclipse_elk_graph_properties_GraphFeature_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0))):(this.supportedFeatures = builder.supportedFeatures);
}

defineClass(153, 1, {643:1, 153:1}, LayoutAlgorithmData);
_.equals_0 = function equals_164(obj){
  return $equals_6(this, obj);
}
;
_.getDescription = function getDescription(){
  return this.description;
}
;
_.getId = function getId(){
  return this.id_0;
}
;
_.getName = function getName_0(){
  return this.name_0;
}
;
_.hashCode_1 = function hashCode_59(){
  return getHashCode_1(this.id_0);
}
;
_.toString_0 = function toString_111(){
  return 'Layout Algorithm: ' + this.id_0;
}
;
var Lorg_eclipse_elk_core_data_LayoutAlgorithmData_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutAlgorithmData', 153);
function $category(this$static, acategory){
  this$static.category = acategory;
  return this$static;
}

function $description(this$static, adescription){
  this$static.description = adescription;
  return this$static;
}

function $id(this$static, aid){
  this$static.id_0 = aid;
  return this$static;
}

function $name(this$static, aname){
  this$static.name_0 = aname;
  return this$static;
}

function $providerFactory(this$static, aproviderFactory){
  this$static.providerFactory = aproviderFactory;
  return this$static;
}

function $supportedFeatures(this$static, asupportedFeatures){
  this$static.supportedFeatures = asupportedFeatures;
  return this$static;
}

function LayoutAlgorithmData$Builder(){
}

defineClass(269, 1, {}, LayoutAlgorithmData$Builder);
var Lorg_eclipse_elk_core_data_LayoutAlgorithmData$Builder_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutAlgorithmData/Builder', 269);
function $resolveAlgorithm(node){
  var algorithmId, data_0, message;
  algorithmId = castToString($getProperty_0(node, ($clinit_CoreOptions() , ALGORITHM)));
  data_0 = $getAlgorithmDataBySuffixOrDefault(getInstance(), algorithmId);
  if (data_0) {
    $setProperty_1(node, RESOLVED_ALGORITHM, data_0);
  }
   else if (!$hasProperty_0(node, RESOLVED_ALGORITHM) && (!node.children && (node.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, node, 10, 11)) , node.children).size_0 != 0) {
    if (algorithmId == null || algorithmId.length == 0) {
      message = new StringBuilder_1('No layout algorithm has been specified for ');
      printElementPath(node, message);
      throw toJs(new UnsupportedConfigurationException_0(message.string));
    }
     else {
      message = new StringBuilder_1("Layout algorithm '");
      message.string += '' + algorithmId;
      message.string += "' not found for ";
      printElementPath(node, message);
      throw toJs(new UnsupportedConfigurationException_0(message.string));
    }
  }
}

function LayoutAlgorithmResolver(){
}

defineClass(907, 1, {641:1}, LayoutAlgorithmResolver);
_.visit = function visit_0(element){
  instanceOf(element, 240) && !checkNotNull_1(castToBoolean(element.getProperty(($clinit_CoreOptions() , NO_LAYOUT_0)))) && $resolveAlgorithm(castTo(element, 35));
}
;
var Lorg_eclipse_elk_core_data_LayoutAlgorithmResolver_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutAlgorithmResolver', 907);
function LayoutCategoryData(builder){
  this.layouters = new LinkedList;
  this.id_0 = builder.id_0;
  this.name_0 = builder.name_0;
  this.description = builder.description;
}

defineClass(207, 1, {643:1, 207:1}, LayoutCategoryData);
_.equals_0 = function equals_165(obj){
  if (instanceOf(obj, 207)) {
    return $equals_4(this.id_0, castTo(obj, 207).id_0);
  }
  return false;
}
;
_.getDescription = function getDescription_0(){
  return this.description;
}
;
_.getId = function getId_0(){
  return this.id_0;
}
;
_.getName = function getName_1(){
  return this.name_0;
}
;
_.hashCode_1 = function hashCode_60(){
  return getHashCode_1(this.id_0);
}
;
_.toString_0 = function toString_112(){
  return 'Layout Type: ' + this.id_0;
}
;
var Lorg_eclipse_elk_core_data_LayoutCategoryData_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutCategoryData', 207);
function $description_0(this$static, adescription){
  this$static.description = adescription;
  return this$static;
}

function $id_0(this$static, aid){
  this$static.id_0 = aid;
  return this$static;
}

function $name_0(this$static, aname){
  this$static.name_0 = aname;
  return this$static;
}

function LayoutCategoryData$Builder(){
}

defineClass(333, 1, {}, LayoutCategoryData$Builder);
var Lorg_eclipse_elk_core_data_LayoutCategoryData$Builder_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutCategoryData/Builder', 333);
function $getAlgorithmData(this$static, id_0){
  return castTo($get_12(this$static.layoutAlgorithmMap, id_0), 153);
}

function $getAlgorithmDataBySuffix(this$static, suffix){
  var d, d$iterator, data_0, entry, id_0, outerIter, suffixlength;
  if (suffix == null || suffix.length == 0) {
    return null;
  }
  data_0 = castTo($getStringValue(this$static.algorithmSuffixMap, suffix), 153);
  if (!data_0) {
    for (d$iterator = (outerIter = (new AbstractMap$2(this$static.layoutAlgorithmMap)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter)); d$iterator.val$outerIter2.hasNext_0();) {
      d = (entry = castTo(d$iterator.val$outerIter2.next_1(), 39) , castTo(entry.getValue(), 153));
      id_0 = d.id_0;
      suffixlength = suffix.length;
      if ($equals_4(id_0.substr(id_0.length - suffixlength, suffixlength), suffix) && (suffix.length == id_0.length || $charAt(id_0, id_0.length - suffix.length - 1) == 46)) {
        if (data_0) {
          return null;
        }
        data_0 = d;
      }
    }
    !!data_0 && $putStringValue(this$static.algorithmSuffixMap, suffix, data_0);
  }
  return data_0;
}

function $getAlgorithmDataBySuffixOrDefault(this$static, algorithmId){
  var algorithmIdData, defaultIdData;
  if (algorithmId != null && $trim(algorithmId).length != 0) {
    algorithmIdData = $getAlgorithmDataBySuffix(this$static, algorithmId);
    if (algorithmIdData) {
      return algorithmIdData;
    }
  }
  if ('org.eclipse.elk.layered'.length != 0) {
    defaultIdData = $getAlgorithmDataBySuffix(this$static, 'org.eclipse.elk.layered');
    if (defaultIdData) {
      return defaultIdData;
    }
  }
  return null;
}

function $getCategoryData(this$static, id_0){
  return castTo($get_12(this$static.layoutCategoryMap, id_0), 207);
}

function $getOptionData(this$static, id_0){
  var data_0;
  data_0 = castTo($get_12(this$static.layoutOptionMap, id_0), 24);
  return data_0?data_0:castTo($get_12(this$static.legacyLayoutOptionMap, id_0), 24);
}

function $getOptionDataBySuffix(this$static, suffix){
  var d, d$iterator, d$iterator0, data_0, entry, id_0, id$index, id$max, legacyIds, outerIter, outerIter0, suffixlength;
  if (suffix == null || suffix.length == 0) {
    return null;
  }
  data_0 = castTo($getStringValue(this$static.optionSuffixMap, suffix), 24);
  if (!data_0) {
    for (d$iterator0 = (outerIter0 = (new AbstractMap$2(this$static.layoutOptionMap)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter0)); d$iterator0.val$outerIter2.hasNext_0();) {
      d = (entry = castTo(d$iterator0.val$outerIter2.next_1(), 39) , castTo(entry.getValue(), 24));
      id_0 = d.id_0;
      suffixlength = suffix.length;
      if ($equals_4(id_0.substr(id_0.length - suffixlength, suffixlength), suffix) && (suffix.length == id_0.length || $charAt(id_0, id_0.length - suffix.length - 1) == 46)) {
        if (data_0) {
          return null;
        }
        data_0 = d;
      }
    }
    if (!data_0) {
      for (d$iterator = (outerIter = (new AbstractMap$2(this$static.layoutOptionMap)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter)); d$iterator.val$outerIter2.hasNext_0();) {
        d = (entry = castTo(d$iterator.val$outerIter2.next_1(), 39) , castTo(entry.getValue(), 24));
        legacyIds = d.legacyIds;
        if (legacyIds != null) {
          for (id$index = 0 , id$max = legacyIds.length; id$index < id$max; ++id$index) {
            id_0 = legacyIds[id$index];
            suffixlength = suffix.length;
            if ($equals_4(id_0.substr(id_0.length - suffixlength, suffixlength), suffix) && (suffix.length == id_0.length || $charAt(id_0, id_0.length - suffix.length - 1) == 46)) {
              if (data_0) {
                return null;
              }
              data_0 = d;
            }
          }
        }
      }
    }
    !!data_0 && $putStringValue(this$static.optionSuffixMap, suffix, data_0);
  }
  return data_0;
}

function $registerLayoutMetaDataProviders(this$static, providers){
  var provider, provider$index, provider$max, registry;
  for (provider$index = 0 , provider$max = providers.length; provider$index < provider$max; ++provider$index) {
    provider = providers[provider$index];
    registry = new LayoutMetaDataService$Registry(this$static);
    provider.apply_3(registry);
    $applyDependencies(registry);
  }
}

function LayoutMetaDataService(){
  this.layoutAlgorithmMap = ($clinit_Maps() , new LinkedHashMap);
  this.layoutOptionMap = new LinkedHashMap;
  this.legacyLayoutOptionMap = new LinkedHashMap;
  this.layoutCategoryMap = new LinkedHashMap;
  this.algorithmSuffixMap = new HashMap;
  this.optionSuffixMap = new HashMap;
  register(Lorg_eclipse_elk_core_math_KVector_2_classLit, new LayoutMetaDataService$lambda$0$Type, new LayoutMetaDataService$lambda$1$Type);
  register(Lorg_eclipse_elk_core_math_KVectorChain_2_classLit, new LayoutMetaDataService$lambda$2$Type, new LayoutMetaDataService$lambda$3$Type);
  register(Lorg_eclipse_elk_core_math_ElkMargin_2_classLit, new LayoutMetaDataService$lambda$4$Type, new LayoutMetaDataService$lambda$5$Type);
  register(Lorg_eclipse_elk_core_math_ElkPadding_2_classLit, new LayoutMetaDataService$lambda$6$Type, new LayoutMetaDataService$lambda$7$Type);
  register(Ljava_util_ArrayList_2_classLit, new LayoutMetaDataService$lambda$8$Type, new LayoutMetaDataService$lambda$9$Type);
  register(Ljava_util_LinkedList_2_classLit, new LayoutMetaDataService$lambda$10$Type, new LayoutMetaDataService$lambda$11$Type);
  register(Ljava_util_HashSet_2_classLit, new LayoutMetaDataService$lambda$12$Type, new LayoutMetaDataService$lambda$13$Type);
  register(Ljava_util_LinkedHashSet_2_classLit, new LayoutMetaDataService$lambda$14$Type, new LayoutMetaDataService$lambda$15$Type);
  register(Ljava_util_TreeSet_2_classLit, new LayoutMetaDataService$lambda$16$Type, new LayoutMetaDataService$lambda$17$Type);
}

function getInstance(){
  if (!instance_2) {
    instance_2 = new LayoutMetaDataService;
    $registerLayoutMetaDataProviders(instance_2, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit, 1), $intern_1, 141, 0, [new CoreOptions]));
  }
  return instance_2;
}

defineClass(796, 1, {}, LayoutMetaDataService);
var instance_2;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService', 796);
function $addDependency(this$static, sourceOption, targetOption, requiredValue){
  var dep;
  dep = new LayoutMetaDataService$Registry$Triple;
  dep.firstId = sourceOption;
  dep.secondId = targetOption;
  dep.value_0 = requiredValue;
  $add_7(this$static.optionDependencies, dep);
}

function $addOptionSupport(this$static, algorithm, option, defaultValue){
  var sup_0;
  sup_0 = new LayoutMetaDataService$Registry$Triple;
  sup_0.firstId = algorithm;
  sup_0.secondId = option;
  sup_0.value_0 = defaultValue;
  $add_7(this$static.optionSupport, sup_0);
}

function $applyDependencies(this$static){
  var algorithm, algorithm$iterator, category, categoryId, dep, dep$iterator, entry, option, outerIter, source, sup_0, sup$iterator, target;
  for (algorithm$iterator = (outerIter = (new AbstractMap$2(this$static.this$01.layoutAlgorithmMap)).this$01.entrySet_0().iterator_0() , new AbstractMap$2$1(outerIter)); algorithm$iterator.val$outerIter2.hasNext_0();) {
    algorithm = (entry = castTo(algorithm$iterator.val$outerIter2.next_1(), 39) , castTo(entry.getValue(), 153));
    categoryId = algorithm.category;
    categoryId == null && (categoryId = '');
    category = $getCategoryData(this$static.this$01, categoryId);
    !category && categoryId.length == 0 && (category = $retrieveBackupCategory(this$static));
    !!category && !$advanceToFind(category.layouters, algorithm, false) && $add_7(category.layouters, algorithm);
  }
  for (dep$iterator = $listIterator_1(this$static.optionDependencies, 0); dep$iterator.currentNode != dep$iterator.this$01.tail;) {
    dep = castTo($next_13(dep$iterator), 451);
    source = $getOptionData(this$static.this$01, dep.firstId);
    target = $getOptionData(this$static.this$01, dep.secondId);
    !!source && !!target && $add_7(source.dependencies, new Pair(target, dep.value_0));
  }
  $reset_0(this$static.optionDependencies);
  for (sup$iterator = $listIterator_1(this$static.optionSupport, 0); sup$iterator.currentNode != sup$iterator.this$01.tail;) {
    sup_0 = castTo($next_13(sup$iterator), 451);
    algorithm = $getAlgorithmData(this$static.this$01, sup_0.firstId);
    option = $getOptionData(this$static.this$01, sup_0.secondId);
    !!algorithm && !!option && $addKnownOption(algorithm, option, sup_0.value_0);
  }
  $reset_0(this$static.optionSupport);
}

function $register(this$static, algorithmData){
  $put_6(this$static.this$01.layoutAlgorithmMap, algorithmData.id_0, algorithmData);
}

function $register_0(this$static, categoryData){
  $put_6(this$static.this$01.layoutCategoryMap, categoryData.id_0, categoryData);
}

function $register_1(this$static, optionData){
  var id_0, legacyId, legacyId$array, legacyId$index, legacyId$max;
  id_0 = optionData.id_0;
  $put_6(this$static.this$01.layoutOptionMap, id_0, optionData);
  if (optionData.legacyIds != null) {
    for (legacyId$array = optionData.legacyIds , legacyId$index = 0 , legacyId$max = legacyId$array.length; legacyId$index < legacyId$max; ++legacyId$index) {
      legacyId = legacyId$array[legacyId$index];
      $put_6(this$static.this$01.legacyLayoutOptionMap, legacyId, optionData);
    }
  }
}

function $retrieveBackupCategory(this$static){
  var otherCategory;
  otherCategory = castTo($get_12(this$static.this$01.layoutCategoryMap, ''), 207);
  if (!otherCategory) {
    otherCategory = new LayoutCategoryData($name_0($id_0(new LayoutCategoryData$Builder, ''), 'Other'));
    $put_6(this$static.this$01.layoutCategoryMap, '', otherCategory);
  }
  return otherCategory;
}

function LayoutMetaDataService$Registry(this$0){
  this.this$01 = this$0;
  this.optionDependencies = new LinkedList;
  this.optionSupport = new LinkedList;
}

defineClass(797, 1, {}, LayoutMetaDataService$Registry);
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$Registry_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/Registry', 797);
function LayoutMetaDataService$Registry$Triple(){
}

defineClass(451, 1, {451:1}, LayoutMetaDataService$Registry$Triple);
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$Registry$Triple_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/Registry/Triple', 451);
function LayoutMetaDataService$lambda$0$Type(){
}

defineClass(798, 1, $intern_133, LayoutMetaDataService$lambda$0$Type);
_.newInstance = function newInstance_0(){
  return new KVector;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$0$Type', 798);
function LayoutMetaDataService$lambda$1$Type(){
}

defineClass(799, 1, $intern_134, LayoutMetaDataService$lambda$1$Type);
_.clone = function clone_1(arg0){
  return $clone_0(castTo(arg0, 8));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$1$Type', 799);
function LayoutMetaDataService$lambda$10$Type(){
}

defineClass(808, 1, $intern_133, LayoutMetaDataService$lambda$10$Type);
_.newInstance = function newInstance_1(){
  return new LinkedList;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$10$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$10$Type', 808);
function LayoutMetaDataService$lambda$11$Type(){
}

defineClass(809, 1, $intern_134, LayoutMetaDataService$lambda$11$Type);
_.clone = function clone_2(arg0){
  return newLinkedList(castTo(arg0, 68));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$11$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$11$Type', 809);
function LayoutMetaDataService$lambda$12$Type(){
}

defineClass(810, 1, $intern_133, LayoutMetaDataService$lambda$12$Type);
_.newInstance = function newInstance_2(){
  return new HashSet;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$12$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$12$Type', 810);
function LayoutMetaDataService$lambda$13$Type(){
}

defineClass(811, 1, $intern_134, LayoutMetaDataService$lambda$13$Type);
_.clone = function clone_3(arg0){
  return newHashSet(castTo(arg0, 65));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$13$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$13$Type', 811);
function LayoutMetaDataService$lambda$14$Type(){
}

defineClass(812, 1, $intern_133, LayoutMetaDataService$lambda$14$Type);
_.newInstance = function newInstance_3(){
  return new LinkedHashSet;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$14$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$14$Type', 812);
function LayoutMetaDataService$lambda$15$Type(){
}

defineClass(813, 1, $intern_134, LayoutMetaDataService$lambda$15$Type);
_.clone = function clone_4(arg0){
  return newLinkedHashSet(castTo(arg0, 65));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$15$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$15$Type', 813);
function LayoutMetaDataService$lambda$16$Type(){
}

defineClass(814, 1, $intern_133, LayoutMetaDataService$lambda$16$Type);
_.newInstance = function newInstance_4(){
  return new TreeSet;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$16$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$16$Type', 814);
function LayoutMetaDataService$lambda$17$Type(){
}

defineClass(815, 1, $intern_134, LayoutMetaDataService$lambda$17$Type);
_.clone = function clone_5(arg0){
  return newTreeSet(castTo(arg0, 203));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$17$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$17$Type', 815);
function LayoutMetaDataService$lambda$2$Type(){
}

defineClass(800, 1, $intern_133, LayoutMetaDataService$lambda$2$Type);
_.newInstance = function newInstance_5(){
  return new KVectorChain;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$2$Type', 800);
function LayoutMetaDataService$lambda$3$Type(){
}

defineClass(801, 1, $intern_134, LayoutMetaDataService$lambda$3$Type);
_.clone = function clone_6(arg0){
  return new KVectorChain_0(castTo(arg0, 74));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$3$Type', 801);
function LayoutMetaDataService$lambda$4$Type(){
}

defineClass(802, 1, $intern_133, LayoutMetaDataService$lambda$4$Type);
_.newInstance = function newInstance_6(){
  return new ElkMargin;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$4$Type', 802);
function LayoutMetaDataService$lambda$5$Type(){
}

defineClass(803, 1, $intern_134, LayoutMetaDataService$lambda$5$Type);
_.clone = function clone_7(arg0){
  return new ElkMargin_2(castTo(arg0, 137));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$5$Type', 803);
function LayoutMetaDataService$lambda$6$Type(){
}

defineClass(804, 1, $intern_133, LayoutMetaDataService$lambda$6$Type);
_.newInstance = function newInstance_7(){
  return new ElkPadding;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$6$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$6$Type', 804);
function LayoutMetaDataService$lambda$7$Type(){
}

defineClass(805, 1, $intern_134, LayoutMetaDataService$lambda$7$Type);
_.clone = function clone_8(arg0){
  return new ElkPadding_1(castTo(arg0, 116));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$7$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$7$Type', 805);
function LayoutMetaDataService$lambda$8$Type(){
}

defineClass(806, 1, $intern_133, LayoutMetaDataService$lambda$8$Type);
_.newInstance = function newInstance_8(){
  return new ArrayList;
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$8$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$8$Type', 806);
function LayoutMetaDataService$lambda$9$Type(){
}

defineClass(807, 1, $intern_134, LayoutMetaDataService$lambda$9$Type);
_.clone = function clone_9(arg0){
  return new ArrayList_1(castTo(arg0, 12));
}
;
var Lorg_eclipse_elk_core_data_LayoutMetaDataService$lambda$9$Type_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutMetaDataService/lambda$9$Type', 807);
var Lorg_eclipse_elk_graph_properties_IProperty_2_classLit = createForInterface('org.eclipse.elk.graph.properties', 'IProperty');
function $checkEnumClass(this$static){
  if (!this$static.clazz || (this$static.clazz.modifiers & 8) == 0) {
    throw toJs(new IllegalStateException_0('Enumeration class expected for layout option ' + this$static.id_0));
  }
}

function $compareTo_19(this$static, other){
  return $compareTo_9(this$static.id_0, other.getId());
}

function $createDataInstance(this$static){
  var instance;
  if (!this$static.clazz) {
    throw toJs(new IllegalStateException_0('IDataType class expected for layout option ' + this$static.id_0));
  }
  instance = newInstance_9(this$static.clazz);
  if (instance == null) {
    throw toJs(new IllegalStateException_0("Couldn't create new instance of property '" + this$static.id_0 + "'. " + "Make sure it's type is registered with the " + ($ensureNamesAreInitialized(Lorg_eclipse_elk_graph_util_ElkReflect_2_classLit) , Lorg_eclipse_elk_graph_util_ElkReflect_2_classLit.simpleName) + ' utility class.'));
  }
  return castTo(instance, 443);
}

function $enumForString(this$static, leString){
  var constants, index_0, value_0;
  try {
    value_0 = valueOf_0(this$static.clazz, leString);
    return value_0;
  }
   catch ($e1) {
    $e1 = toJava($e1);
    if (instanceOf($e1, 30)) {
      try {
        index_0 = __parseAndValidateInt(leString, $intern_43, $intern_0);
        constants = $getEnumConstants(this$static.clazz);
        if (index_0 >= 0 && index_0 < constants.length) {
          return constants[index_0];
        }
      }
       catch ($e0) {
        $e0 = toJava($e0);
        if (!instanceOf($e0, 120))
          throw toJs($e0);
      }
      return null;
    }
     else 
      throw toJs($e1);
  }
}

function $enumSetForStringArray(this$static, leClazz, leString){
  var all, component, component$index, component$max, components, o, set_0;
  set_0 = (all = castTo(leClazz.enumConstantsFunc && leClazz.enumConstantsFunc(), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  components = $split_0(leString, '[\\[\\]\\s,]+');
  for (component$index = 0 , component$max = components.length; component$index < component$max; ++component$index) {
    component = components[component$index];
    if ($trim(component).length == 0) {
      continue;
    }
    o = $enumForString(this$static, component);
    if (o == null) {
      return null;
    }
     else {
      $add_5(set_0, castTo(o, 22));
    }
  }
  return set_0;
}

function $parseValue(this$static, valueString){
  var value_0;
  if (valueString == null || $equals_4(valueString, 'null')) {
    return null;
  }
  if (valueString.length == 0 && this$static.type_0 != ($clinit_LayoutOptionData$Type() , ENUMSET)) {
    return null;
  }
  switch (this$static.type_0.ordinal) {
    case 1:
      return $equalsIgnoreCase(valueString, 'true')?($clinit_Boolean() , TRUE_0):$equalsIgnoreCase(valueString, 'false')?($clinit_Boolean() , FALSE_0):null;
    case 2:
      try {
        return valueOf_4(__parseAndValidateInt(valueString, $intern_43, $intern_0));
      }
       catch ($e0) {
        $e0 = toJava($e0);
        if (instanceOf($e0, 120)) {
          return null;
        }
         else 
          throw toJs($e0);
      }

    case 4:
      try {
        return __parseAndValidateDouble(valueString);
      }
       catch ($e1) {
        $e1 = toJava($e1);
        if (instanceOf($e1, 120)) {
          return null;
        }
         else 
          throw toJs($e1);
      }

    case 3:
      return valueString;
    case 5:
      $checkEnumClass(this$static);
      return $enumForString(this$static, valueString);
    case 6:
      $checkEnumClass(this$static);
      return $enumSetForStringArray(this$static, this$static.clazz, valueString);
    case 7:
      try {
        value_0 = $createDataInstance(this$static);
        value_0.parse_0(valueString);
        return value_0;
      }
       catch ($e2) {
        $e2 = toJava($e2);
        if (instanceOf($e2, 30)) {
          return null;
        }
         else 
          throw toJs($e2);
      }

    default:throw toJs(new IllegalStateException_0('Invalid type set for this layout option.'));
  }
}

function LayoutOptionData(builder){
  var all;
  this.dependencies = new LinkedList;
  this.id_0 = builder.id_0;
  this.group = builder.group;
  this.name_0 = builder.name_0;
  this.description = builder.description;
  this.defaultValue = builder.defaultValue;
  this.type_0 = builder.type_0;
  this.clazz = builder.clazz;
  !builder.targets?(this.targets = (all = castTo($getEnumConstants(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0))):(this.targets = builder.targets);
  this.legacyIds = builder.legacyIds;
}

defineClass(24, 1, {34:1, 643:1, 24:1, 169:1}, LayoutOptionData);
_.compareTo_0 = function compareTo_20(other){
  return $compareTo_19(this, castTo(other, 169));
}
;
_.equals_0 = function equals_166(obj){
  return instanceOf(obj, 24)?$equals_4(this.id_0, castTo(obj, 24).id_0):instanceOf(obj, 169) && $equals_4(this.id_0, castTo(obj, 169).getId());
}
;
_.getDefault = function getDefault(){
  var clone;
  if (instanceOf(this.defaultValue, 4)) {
    clone = clone_10(this.defaultValue);
    if (clone == null) {
      throw toJs(new IllegalStateException_0("Couldn't clone property '" + this.id_0 + "'. " + "Make sure it's type is registered with the " + ($ensureNamesAreInitialized(Lorg_eclipse_elk_graph_util_ElkReflect_2_classLit) , Lorg_eclipse_elk_graph_util_ElkReflect_2_classLit.simpleName) + ' utility class.'));
    }
    return clone;
  }
   else {
    return this.defaultValue;
  }
}
;
_.getDescription = function getDescription_1(){
  return this.description;
}
;
_.getId = function getId_1(){
  return this.id_0;
}
;
_.getName = function getName_2(){
  return this.name_0;
}
;
_.hashCode_1 = function hashCode_61(){
  return getHashCode_1(this.id_0);
}
;
_.toString_0 = function toString_113(){
  return 'Layout Option: ' + this.id_0;
}
;
var Lorg_eclipse_elk_core_data_LayoutOptionData_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutOptionData', 24);
function $defaultValue(this$static, adefaultValue){
  this$static.defaultValue = adefaultValue;
  return this$static;
}

function $description_1(this$static, adescription){
  this$static.description = adescription;
  return this$static;
}

function $group(this$static, agroup){
  this$static.group = agroup;
  return this$static;
}

function $id_1(this$static, aid){
  this$static.id_0 = aid;
  return this$static;
}

function $legacyIds(this$static, alegacyIds){
  this$static.legacyIds = alegacyIds;
  return this$static;
}

function $name_1(this$static, aname){
  this$static.name_0 = aname;
  return this$static;
}

function $optionClass(this$static, aclazz){
  this$static.clazz = aclazz;
  return this$static;
}

function $targets(this$static, atargets){
  this$static.targets = atargets;
  return this$static;
}

function $type(this$static, atype){
  this$static.type_0 = atype;
  return this$static;
}

function LayoutOptionData$Builder(){
}

defineClass(27, 1, {}, LayoutOptionData$Builder);
var Lorg_eclipse_elk_core_data_LayoutOptionData$Builder_2_classLit = createForClass('org.eclipse.elk.core.data', 'LayoutOptionData/Builder', 27);
function $clinit_LayoutOptionData$Target(){
  $clinit_LayoutOptionData$Target = emptyMethod;
  PARENTS = new LayoutOptionData$Target('PARENTS', 0);
  NODES = new LayoutOptionData$Target('NODES', 1);
  EDGES = new LayoutOptionData$Target('EDGES', 2);
  PORTS = new LayoutOptionData$Target('PORTS', 3);
  LABELS = new LayoutOptionData$Target('LABELS', 4);
}

function LayoutOptionData$Target(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_83(name_0){
  $clinit_LayoutOptionData$Target();
  return valueOf(($clinit_LayoutOptionData$Target$Map() , $MAP_71), name_0);
}

function values_79(){
  $clinit_LayoutOptionData$Target();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [PARENTS, NODES, EDGES, PORTS, LABELS]);
}

defineClass(165, 22, {3:1, 34:1, 22:1, 165:1}, LayoutOptionData$Target);
var EDGES, LABELS, NODES, PARENTS, PORTS;
var Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit = createForEnum('org.eclipse.elk.core.data', 'LayoutOptionData/Target', 165, Ljava_lang_Enum_2_classLit, values_79, valueOf_83);
function $clinit_LayoutOptionData$Target$Map(){
  $clinit_LayoutOptionData$Target$Map = emptyMethod;
  $MAP_71 = createValueOfMap(($clinit_LayoutOptionData$Target() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [PARENTS, NODES, EDGES, PORTS, LABELS])));
}

var $MAP_71;
function $clinit_LayoutOptionData$Type(){
  $clinit_LayoutOptionData$Type = emptyMethod;
  UNDEFINED_2 = new LayoutOptionData$Type('UNDEFINED', 0);
  BOOLEAN = new LayoutOptionData$Type('BOOLEAN', 1);
  INT = new LayoutOptionData$Type('INT', 2);
  STRING = new LayoutOptionData$Type('STRING', 3);
  DOUBLE = new LayoutOptionData$Type('DOUBLE', 4);
  ENUM = new LayoutOptionData$Type('ENUM', 5);
  ENUMSET = new LayoutOptionData$Type('ENUMSET', 6);
  OBJECT = new LayoutOptionData$Type('OBJECT', 7);
}

function LayoutOptionData$Type(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_84(name_0){
  $clinit_LayoutOptionData$Type();
  return valueOf(($clinit_LayoutOptionData$Type$Map() , $MAP_72), name_0);
}

function values_80(){
  $clinit_LayoutOptionData$Type();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Type_2_classLit, 1), $intern_38, 268, 0, [UNDEFINED_2, BOOLEAN, INT, STRING, DOUBLE, ENUM, ENUMSET, OBJECT]);
}

defineClass(268, 22, {3:1, 34:1, 22:1, 268:1}, LayoutOptionData$Type);
var BOOLEAN, DOUBLE, ENUM, ENUMSET, INT, OBJECT, STRING, UNDEFINED_2;
var Lorg_eclipse_elk_core_data_LayoutOptionData$Type_2_classLit = createForEnum('org.eclipse.elk.core.data', 'LayoutOptionData/Type', 268, Ljava_lang_Enum_2_classLit, values_80, valueOf_84);
function $clinit_LayoutOptionData$Type$Map(){
  $clinit_LayoutOptionData$Type$Map = emptyMethod;
  $MAP_72 = createValueOfMap(($clinit_LayoutOptionData$Type() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Type_2_classLit, 1), $intern_38, 268, 0, [UNDEFINED_2, BOOLEAN, INT, STRING, DOUBLE, ENUM, ENUMSET, OBJECT])));
}

var $MAP_72;
function $clinit_LabelManagementOptions(){
  $clinit_LabelManagementOptions = emptyMethod;
  LABEL_MANAGER = new Property('org.eclipse.elk.labels.labelManager');
}

var LABEL_MANAGER;
function $clinit_ElkMath(){
  $clinit_ElkMath = emptyMethod;
  FACT_TABLE = stampJavaTypeInfo(getClassLiteralForArray(J_classLit, 1), $intern_65, 23, 14, [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600, 6227020800, 87178291200, 1307674368000, {l:3506176, m:794077, h:1}, {l:884736, m:916411, h:20}, {l:3342336, m:3912489, h:363}, {l:589824, m:3034138, h:6914}, {l:3407872, m:1962506, h:138294}]);
  $wnd.Math.pow(2, -65);
}

function approximateBezierSegment(controlPoints){
  $clinit_ElkMath();
  var factor, i, j, n, p, result, t, v;
  result = initUnidimensionalArray(Lorg_eclipse_elk_core_math_KVector_2_classLit, $intern_33, 8, 2, 0, 1);
  n = controlPoints.length - 1;
  t = 0;
  for (i = 0; i < 2; i++) {
    t += 0.5;
    v = new KVector;
    for (j = 0; j <= n; j++) {
      p = controlPoints[j];
      factor = binomiald(n, j) * powd(1 - t, n - j) * powd(t, j);
      v.x_0 += p.x_0 * factor;
      v.y_0 += p.y_0 * factor;
    }
    result[i] = v;
  }
  return result;
}

function binomiald(n, k){
  if (n < 0 || k < 0) {
    throw toJs(new IllegalArgumentException_0('k and n must be positive'));
  }
   else if (k > n) {
    throw toJs(new IllegalArgumentException_0('k must be smaller than n'));
  }
   else 
    return k == 0 || k == n?1:n == 0?0:factd(n) / (factd(k) * factd(n - k));
}

function clipVector(v, width_0, height){
  $clinit_ElkMath();
  var absx, absy, hh, wh, xscale, yscale;
  wh = width_0 / 2;
  hh = height / 2;
  absx = $wnd.Math.abs(v.x_0);
  absy = $wnd.Math.abs(v.y_0);
  xscale = 1;
  yscale = 1;
  absx > wh && (xscale = wh / absx);
  absy > hh && (yscale = hh / absy);
  $scale(v, $wnd.Math.min(xscale, yscale));
  return v;
}

function contains_43(rect, p){
  var maxX, maxY, minX, minY;
  minX = rect.x_0;
  maxX = rect.x_0 + rect.width_0;
  minY = rect.y_0;
  maxY = rect.y_0 + rect.height;
  return p.x_0 > minX && p.x_0 < maxX && p.y_0 > minY && p.y_0 < maxY;
}

function contains_44(rect, p1, p2){
  $clinit_ElkMath();
  return contains_43(rect, p1) && contains_43(rect, p2);
}

function contains_45(rect, path){
  $clinit_ElkMath();
  var first, p1, p2, pathIt;
  if (path.size_0 < 2) {
    return false;
  }
  pathIt = $listIterator_1(path, 0);
  first = castTo($next_13(pathIt), 8);
  p1 = first;
  while (pathIt.currentNode != pathIt.this$01.tail) {
    p2 = castTo($next_13(pathIt), 8);
    if (!(contains_43(rect, p1) && contains_43(rect, p2))) {
      return false;
    }
    p1 = p2;
  }
  if (!(contains_43(rect, p1) && contains_43(rect, first))) {
    return false;
  }
  return true;
}

function distance_0(a1, a2, b1, b2, v){
  $clinit_ElkMath();
  return $wnd.Math.min(traceRays(a1, a2, b1, b2, v), traceRays(b1, b2, a1, a2, $negate(new KVector_1(v.x_0, v.y_0))));
}

function factd(x_0){
  if (x_0 < 0) {
    throw toJs(new IllegalArgumentException_0('The input must be positive'));
  }
   else 
    return x_0 < FACT_TABLE.length?toDouble_0(FACT_TABLE[x_0]):$wnd.Math.sqrt($intern_128 * x_0) * (powf(x_0, x_0) / powd(2.718281828459045, x_0));
}

function intersects_0(rect, p1, p2){
  $clinit_ElkMath();
  if (contains_43(rect, p1) && contains_43(rect, p2)) {
    return false;
  }
  return intersects_2(new KVector_1(rect.x_0, rect.y_0), new KVector_1(rect.x_0 + rect.width_0, rect.y_0), p1, p2) || intersects_2(new KVector_1(rect.x_0 + rect.width_0, rect.y_0), new KVector_1(rect.x_0 + rect.width_0, rect.y_0 + rect.height), p1, p2) || intersects_2(new KVector_1(rect.x_0 + rect.width_0, rect.y_0 + rect.height), new KVector_1(rect.x_0, rect.y_0 + rect.height), p1, p2) || intersects_2(new KVector_1(rect.x_0, rect.y_0 + rect.height), new KVector_1(rect.x_0, rect.y_0), p1, p2);
}

function intersects_1(rect, path){
  $clinit_ElkMath();
  var first, p1, p2, pathIt;
  if (path.size_0 < 2) {
    return false;
  }
  pathIt = $listIterator_1(path, 0);
  first = castTo($next_13(pathIt), 8);
  p1 = first;
  while (pathIt.currentNode != pathIt.this$01.tail) {
    p2 = castTo($next_13(pathIt), 8);
    if (intersects_0(rect, p1, p2)) {
      return true;
    }
    p1 = p2;
  }
  if (intersects_0(rect, p1, first)) {
    return true;
  }
  return false;
}

function intersects_2(l11, l12, l21, l22){
  var d, s, t, v0, v1, x00, x01, x10, x11, y00, y01, y10, y11;
  v0 = $sub_0(new KVector_1(l12.x_0, l12.y_0), l11);
  v1 = $sub_0(new KVector_1(l22.x_0, l22.y_0), l21);
  x00 = l11.x_0;
  y00 = l11.y_0;
  x10 = l21.x_0;
  y10 = l21.y_0;
  x01 = v0.x_0;
  y01 = v0.y_0;
  x11 = v1.x_0;
  y11 = v1.y_0;
  d = x11 * y01 - x01 * y11;
  $clinit_DoubleMath();
  checkNonNegative($intern_121);
  if ($wnd.Math.abs(0 - d) <= $intern_121 || 0 == d || isNaN(0) && isNaN(d)) {
    return false;
  }
  s = 1 / d * ((x00 - x10) * y01 - (y00 - y10) * x01);
  t = 1 / d * -(-(x00 - x10) * y11 + (y00 - y10) * x11);
  return 0 < s && s < 1 && 0 < t && t < 1;
}

function intersects2(p, r, q, s){
  var center, d1, d2, l, pq, pqXr, rXs, t, u;
  pq = $sub_0(new KVector_1(q.x_0, q.y_0), p);
  pqXr = pq.x_0 * r.y_0 - pq.y_0 * r.x_0;
  rXs = r.x_0 * s.y_0 - r.y_0 * s.x_0;
  t = (pq.x_0 * s.y_0 - pq.y_0 * s.x_0) / rXs;
  u = pqXr / rXs;
  if (rXs == 0) {
    if (pqXr == 0) {
      center = $add_19(new KVector_1(q.x_0, q.y_0), $scale(new KVector_1(s.x_0, s.y_0), 0.5));
      d1 = $distance_0(p, center);
      d2 = $distance_0($add_19(new KVector_1(p.x_0, p.y_0), r), center);
      l = $wnd.Math.sqrt(s.x_0 * s.x_0 + s.y_0 * s.y_0) * 0.5;
      if (d1 < d2 && d1 <= l) {
        return new KVector_1(p.x_0, p.y_0);
      }
      if (d2 <= l) {
        return $add_19(new KVector_1(p.x_0, p.y_0), r);
      }
      return null;
    }
     else {
      return null;
    }
  }
   else {
    return t >= 0 && t <= 1 && u >= 0 && u <= 1?$add_19(new KVector_1(p.x_0, p.y_0), $scale(new KVector_1(r.x_0, r.y_0), t)):null;
  }
}

function maxd(values){
  $clinit_ElkMath();
  var i, max_0;
  max_0 = $intern_124;
  for (i = 0; i < values.length; i++) {
    values[i] > max_0 && (max_0 = values[i]);
  }
  return max_0;
}

function powd(a, b){
  var base, exp_0, result;
  result = 1;
  base = a;
  exp_0 = b >= 0?b:-b;
  while (exp_0 > 0) {
    if (exp_0 % 2 == 0) {
      base *= base;
      exp_0 = exp_0 / 2 | 0;
    }
     else {
      result *= base;
      exp_0 -= 1;
    }
  }
  return b < 0?1 / result:result;
}

function powf(a, b){
  var base, exp_0, result;
  result = 1;
  base = a;
  exp_0 = b >= 0?b:-b;
  while (exp_0 > 0) {
    if (exp_0 % 2 == 0) {
      base *= base;
      exp_0 = exp_0 / 2 | 0;
    }
     else {
      result *= base;
      exp_0 -= 1;
    }
  }
  return b < 0?1 / result:result;
}

function shortestDistance_0(r1, r2){
  $clinit_ElkMath();
  var bottomDist, horzDist, leftDist, rightDist, topDist, vertDist;
  rightDist = r2.x_0 - (r1.x_0 + r1.width_0);
  leftDist = r1.x_0 - (r2.x_0 + r2.width_0);
  topDist = r1.y_0 - (r2.y_0 + r2.height);
  bottomDist = r2.y_0 - (r1.y_0 + r1.height);
  horzDist = $wnd.Math.max(leftDist, rightDist);
  vertDist = $wnd.Math.max(topDist, bottomDist);
  $clinit_DoubleMath();
  checkNonNegative($intern_121);
  if (($wnd.Math.abs(horzDist) <= $intern_121 || horzDist == 0 || isNaN(horzDist) && isNaN(0)?0:horzDist < 0?-1:horzDist > 0?1:compare_1(isNaN(horzDist), isNaN(0))) >= 0 ^ (null , checkNonNegative($intern_121) , ($wnd.Math.abs(vertDist) <= $intern_121 || vertDist == 0 || isNaN(vertDist) && isNaN(0)?0:vertDist < 0?-1:vertDist > 0?1:compare_1(isNaN(vertDist), isNaN(0))) >= 0)) {
    return $wnd.Math.max(vertDist, horzDist);
  }
  checkNonNegative($intern_121);
  if (($wnd.Math.abs(horzDist) <= $intern_121 || horzDist == 0 || isNaN(horzDist) && isNaN(0)?0:horzDist < 0?-1:horzDist > 0?1:compare_1(isNaN(horzDist), isNaN(0))) > 0) {
    return $wnd.Math.sqrt(vertDist * vertDist + horzDist * horzDist);
  }
  return -$wnd.Math.sqrt(vertDist * vertDist + horzDist * horzDist);
}

function traceRays(a1, a2, b1, b2, v){
  var edgeCase, endpointHit, intersection, result;
  result = $intern_62;
  endpointHit = false;
  intersection = intersects2(a1, $sub_0(new KVector_1(a2.x_0, a2.y_0), a1), $add_19(new KVector_1(b1.x_0, b1.y_0), v), $sub_0(new KVector_1(b2.x_0, b2.y_0), b1));
  edgeCase = !!intersection && !($wnd.Math.abs(intersection.x_0 - a1.x_0) <= $intern_135 && $wnd.Math.abs(intersection.y_0 - a1.y_0) <= $intern_135 || $wnd.Math.abs(intersection.x_0 - a2.x_0) <= $intern_135 && $wnd.Math.abs(intersection.y_0 - a2.y_0) <= $intern_135);
  intersection = intersects2(a1, $sub_0(new KVector_1(a2.x_0, a2.y_0), a1), b1, v);
  !!intersection && (($wnd.Math.abs(intersection.x_0 - a1.x_0) <= $intern_135 && $wnd.Math.abs(intersection.y_0 - a1.y_0) <= $intern_135) == ($wnd.Math.abs(intersection.x_0 - a2.x_0) <= $intern_135 && $wnd.Math.abs(intersection.y_0 - a2.y_0) <= $intern_135) || edgeCase?(result = $wnd.Math.min($intern_62, $length($sub_0(intersection, b1)))):(endpointHit = true));
  intersection = intersects2(a1, $sub_0(new KVector_1(a2.x_0, a2.y_0), a1), b2, v);
  !!intersection && (endpointHit || ($wnd.Math.abs(intersection.x_0 - a1.x_0) <= $intern_135 && $wnd.Math.abs(intersection.y_0 - a1.y_0) <= $intern_135) == ($wnd.Math.abs(intersection.x_0 - a2.x_0) <= $intern_135 && $wnd.Math.abs(intersection.y_0 - a2.y_0) <= $intern_135) || edgeCase) && (result = $wnd.Math.min(result, $length($sub_0(intersection, b2))));
  return result;
}

var FACT_TABLE;
function $getBottomLeft(this$static){
  return new KVector_1(this$static.x_0, this$static.y_0 + this$static.height);
}

function $getBottomRight(this$static){
  return new KVector_1(this$static.x_0 + this$static.width_0, this$static.y_0 + this$static.height);
}

function $getCenter(this$static){
  return new KVector_1(this$static.x_0 + this$static.width_0 / 2, this$static.y_0 + this$static.height / 2);
}

function $getPosition(this$static){
  return new KVector_1(this$static.x_0, this$static.y_0);
}

function $getTopLeft(this$static){
  return new KVector_1(this$static.x_0, this$static.y_0);
}

function $setRect(this$static, nx, ny, nw, nh){
  this$static.x_0 = nx;
  this$static.y_0 = ny;
  this$static.width_0 = nw;
  this$static.height = nh;
}

function $union_0(this$static, other){
  var t, x1, x2, y1, y2;
  x1 = $wnd.Math.min(this$static.x_0, other.x_0);
  y1 = $wnd.Math.min(this$static.y_0, other.y_0);
  x2 = $wnd.Math.max(this$static.x_0 + this$static.width_0, other.x_0 + other.width_0);
  y2 = $wnd.Math.max(this$static.y_0 + this$static.height, other.y_0 + other.height);
  if (x2 < x1) {
    t = x1;
    x1 = x2;
    x2 = t;
  }
  if (y2 < y1) {
    t = y1;
    y1 = y2;
    y2 = t;
  }
  $setRect(this$static, x1, y1, x2 - x1, y2 - y1);
}

function ElkRectangle(){
  ElkRectangle_0.call(this, 0, 0, 0, 0);
}

function ElkRectangle_0(x_0, y_0, w, h){
  this.x_0 = x_0;
  this.y_0 = y_0;
  this.width_0 = w;
  this.height = h;
}

function ElkRectangle_1(rect){
  this.x_0 = rect.x_0;
  this.y_0 = rect.y_0;
  this.width_0 = rect.width_0;
  this.height = rect.height;
}

defineClass(114, 1, {114:1}, ElkRectangle, ElkRectangle_0, ElkRectangle_1);
_.equals_0 = function equals_167(obj){
  var other;
  if (obj == null || !instanceOf(obj, 114)) {
    return false;
  }
  other = castTo(obj, 114);
  return equals_56(this.x_0, other.x_0) && equals_56(this.y_0, other.y_0) && equals_56(this.width_0, other.width_0) && equals_56(this.height, other.height);
}
;
_.hashCode_1 = function hashCode_62(){
  return hashCode_43(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [this.x_0, this.y_0, this.width_0, this.height]));
}
;
_.toString_0 = function toString_114(){
  return 'Rect[x=' + this.x_0 + ',y=' + this.y_0 + ',w=' + this.width_0 + ',h=' + this.height + ']';
}
;
_.height = 0;
_.width_0 = 0;
_.x_0 = 0;
_.y_0 = 0;
var Lorg_eclipse_elk_core_math_ElkRectangle_2_classLit = createForClass('org.eclipse.elk.core.math', 'ElkRectangle', 114);
function $add_18(this$static, dx, dy){
  this$static.x_0 += dx;
  this$static.y_0 += dy;
  return this$static;
}

function $add_19(this$static, v){
  this$static.x_0 += v.x_0;
  this$static.y_0 += v.y_0;
  return this$static;
}

function $bound(this$static, lowx, lowy, highx, highy){
  if (highx < lowx || highy < lowy) {
    throw toJs(new IllegalArgumentException_0('The highx must be bigger then lowx and the highy must be bigger then lowy'));
  }
  this$static.x_0 < lowx?(this$static.x_0 = lowx):this$static.x_0 > highx && (this$static.x_0 = highx);
  this$static.y_0 < lowy?(this$static.y_0 = lowy):this$static.y_0 > highy && (this$static.y_0 = highy);
  return this$static;
}

function $clone_0(this$static){
  return new KVector_1(this$static.x_0, this$static.y_0);
}

function $distance_0(this$static, v2){
  var dx, dy;
  dx = this$static.x_0 - v2.x_0;
  dy = this$static.y_0 - v2.y_0;
  return $wnd.Math.sqrt(dx * dx + dy * dy);
}

function $equals_7(this$static, obj){
  var other;
  if (instanceOf(obj, 8)) {
    other = castTo(obj, 8);
    return this$static.x_0 == other.x_0 && this$static.y_0 == other.y_0;
  }
   else {
    return false;
  }
}

function $length(this$static){
  return $wnd.Math.sqrt(this$static.x_0 * this$static.x_0 + this$static.y_0 * this$static.y_0);
}

function $negate(this$static){
  this$static.x_0 = -this$static.x_0;
  this$static.y_0 = -this$static.y_0;
  return this$static;
}

function $normalize_0(this$static){
  var length_0;
  length_0 = $wnd.Math.sqrt(this$static.x_0 * this$static.x_0 + this$static.y_0 * this$static.y_0);
  if (length_0 > 0) {
    this$static.x_0 /= length_0;
    this$static.y_0 /= length_0;
  }
  return this$static;
}

function $reset_5(this$static){
  this$static.x_0 = 0;
  this$static.y_0 = 0;
  return this$static;
}

function $scale(this$static, scale){
  this$static.x_0 *= scale;
  this$static.y_0 *= scale;
  return this$static;
}

function $scale_0(this$static, scalex, scaley){
  this$static.x_0 *= scalex;
  this$static.y_0 *= scaley;
  return this$static;
}

function $scaleToLength(this$static, length_0){
  $normalize_0(this$static);
  this$static.x_0 *= length_0;
  this$static.y_0 *= length_0;
  return this$static;
}

function $sub(this$static, dx, dy){
  this$static.x_0 -= dx;
  this$static.y_0 -= dy;
  return this$static;
}

function $sub_0(this$static, v){
  this$static.x_0 -= v.x_0;
  this$static.y_0 -= v.y_0;
  return this$static;
}

function KVector(){
  this.x_0 = 0;
  this.y_0 = 0;
}

function KVector_0(angle){
  this.x_0 = $wnd.Math.cos(angle);
  this.y_0 = $wnd.Math.sin(angle);
}

function KVector_1(thex, they){
  this.x_0 = thex;
  this.y_0 = they;
}

function KVector_2(v){
  this.x_0 = v.x_0;
  this.y_0 = v.y_0;
}

function isdelim_0(c, delims){
  var i;
  for (i = 0; i < delims.length; i++) {
    if (c == delims.charCodeAt(i)) {
      return true;
    }
  }
  return false;
}

function sum_0(vs){
  var sum, v, v$index, v$max;
  sum = new KVector;
  for (v$index = 0 , v$max = vs.length; v$index < v$max; ++v$index) {
    v = vs[v$index];
    sum.x_0 += v.x_0;
    sum.y_0 += v.y_0;
  }
  return sum;
}

defineClass(8, 1, {3:1, 4:1, 8:1, 443:1}, KVector, KVector_0, KVector_1, KVector_2);
_.equals_0 = function equals_168(obj){
  return $equals_7(this, obj);
}
;
_.hashCode_1 = function hashCode_63(){
  return round_int(checkNotNull_1(this.x_0)) + reverse_1(round_int(checkNotNull_1(this.y_0)));
}
;
_.parse_0 = function parse_1(string){
  var end, exception, start_0, tokens;
  start_0 = 0;
  while (start_0 < string.length && isdelim_0(string.charCodeAt(start_0), '([{"\' \t\r\n')) {
    ++start_0;
  }
  end = string.length;
  while (end > 0 && isdelim_0(string.charCodeAt(end - 1), ')]}"\' \t\r\n')) {
    --end;
  }
  if (start_0 >= end) {
    throw toJs(new IllegalArgumentException_0('The given string does not contain any numbers.'));
  }
  tokens = $split_0(string.substr(start_0, end - start_0), ',|;|\r|\n');
  if (tokens.length != 2) {
    throw toJs(new IllegalArgumentException_0('Exactly two numbers are expected, ' + tokens.length + ' were found.'));
  }
  try {
    this.x_0 = __parseAndValidateDouble($trim(tokens[0]));
    this.y_0 = __parseAndValidateDouble($trim(tokens[1]));
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 120)) {
      exception = $e0;
      throw toJs(new IllegalArgumentException_0('The given string contains parts that cannot be parsed as numbers.' + exception));
    }
     else 
      throw toJs($e0);
  }
}
;
_.toString_0 = function toString_115(){
  return '(' + this.x_0 + ',' + this.y_0 + ')';
}
;
_.x_0 = 0;
_.y_0 = 0;
var Lorg_eclipse_elk_core_math_KVector_2_classLit = createForClass('org.eclipse.elk.core.math', 'KVector', 8);
function $addAll_5(this$static, vectors){
  var vector, vector$index, vector$max;
  for (vector$index = 0 , vector$max = vectors.length; vector$index < vector$max; ++vector$index) {
    vector = vectors[vector$index];
    $addNode_0(this$static, vector, this$static.tail.prev, this$static.tail);
  }
}

function $addAllAsCopies(this$static, index_0, chain){
  var copies, v, v$iterator;
  copies = new LinkedList;
  for (v$iterator = $listIterator_1(chain, 0); v$iterator.currentNode != v$iterator.this$01.tail;) {
    v = castTo($next_13(v$iterator), 8);
    $add_7(copies, new KVector_2(v));
  }
  $addAll_0(this$static, index_0, copies);
}

function $offset_1(this$static, dx, dy){
  var vector, vector$iterator;
  for (vector$iterator = $listIterator_1(this$static, 0); vector$iterator.currentNode != vector$iterator.this$01.tail;) {
    vector = castTo($next_13(vector$iterator), 8);
    vector.x_0 += dx;
    vector.y_0 += dy;
  }
  return this$static;
}

function $offset_2(this$static, offset){
  var vector, vector$iterator;
  for (vector$iterator = $listIterator_1(this$static, 0); vector$iterator.currentNode != vector$iterator.this$01.tail;) {
    vector = castTo($next_13(vector$iterator), 8);
    vector.x_0 += offset.x_0;
    vector.y_0 += offset.y_0;
  }
  return this$static;
}

function KVectorChain(){
  LinkedList.call(this);
}

function KVectorChain_0(collection){
  LinkedList_0.call(this, collection);
}

function reverse_3(chain){
  var result, vector, vector$iterator;
  result = new KVectorChain;
  for (vector$iterator = $listIterator_1(chain, 0); vector$iterator.currentNode != vector$iterator.this$01.tail;) {
    vector = castTo($next_13(vector$iterator), 8);
    $add_0(result, 0, new KVector_2(vector));
  }
  return result;
}

defineClass(74, 68, {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 68:1, 15:1, 74:1, 443:1}, KVectorChain, KVectorChain_0);
_.parse_0 = function parse_2(string){
  var exception, i, tokens, x_0, xy, y_0;
  tokens = $split_0(string, ',|;|\\(|\\)|\\[|\\]|\\{|\\}| |\t|\n');
  $reset_0(this);
  try {
    i = 0;
    xy = 0;
    x_0 = 0;
    y_0 = 0;
    while (i < tokens.length) {
      if (tokens[i] != null && $trim(tokens[i]).length > 0) {
        xy % 2 == 0?(x_0 = __parseAndValidateDouble(tokens[i])):(y_0 = __parseAndValidateDouble(tokens[i]));
        xy > 0 && xy % 2 != 0 && $add_7(this, new KVector_1(x_0, y_0));
        ++xy;
      }
      ++i;
    }
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 120)) {
      exception = $e0;
      throw toJs(new IllegalArgumentException_0('The given string does not match the expected format for vectors.' + exception));
    }
     else 
      throw toJs($e0);
  }
}
;
_.toString_0 = function toString_116(){
  var builder, iter, vector;
  builder = new StringBuilder_1('(');
  iter = $listIterator_1(this, 0);
  while (iter.currentNode != iter.this$01.tail) {
    vector = castTo($next_13(iter), 8);
    $append_11(builder, vector.x_0 + ',' + vector.y_0);
    iter.currentNode != iter.this$01.tail && (builder.string += '; ' , builder);
  }
  return (builder.string += ')' , builder).string;
}
;
var Lorg_eclipse_elk_core_math_KVectorChain_2_classLit = createForClass('org.eclipse.elk.core.math', 'KVectorChain', 74);
function $clinit_Alignment(){
  $clinit_Alignment = emptyMethod;
  AUTOMATIC = new Alignment('AUTOMATIC', 0);
  LEFT_4 = new Alignment('LEFT', 1);
  RIGHT_4 = new Alignment('RIGHT', 2);
  TOP_1 = new Alignment('TOP', 3);
  BOTTOM_1 = new Alignment('BOTTOM', 4);
  CENTER_3 = new Alignment('CENTER', 5);
}

function Alignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_85(name_0){
  $clinit_Alignment();
  return valueOf(($clinit_Alignment$Map() , $MAP_73), name_0);
}

function values_81(){
  $clinit_Alignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_Alignment_2_classLit, 1), $intern_38, 234, 0, [AUTOMATIC, LEFT_4, RIGHT_4, TOP_1, BOTTOM_1, CENTER_3]);
}

defineClass(234, 22, {3:1, 34:1, 22:1, 234:1}, Alignment);
var AUTOMATIC, BOTTOM_1, CENTER_3, LEFT_4, RIGHT_4, TOP_1;
var Lorg_eclipse_elk_core_options_Alignment_2_classLit = createForEnum('org.eclipse.elk.core.options', 'Alignment', 234, Ljava_lang_Enum_2_classLit, values_81, valueOf_85);
function $clinit_Alignment$Map(){
  $clinit_Alignment$Map = emptyMethod;
  $MAP_73 = createValueOfMap(($clinit_Alignment() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_Alignment_2_classLit, 1), $intern_38, 234, 0, [AUTOMATIC, LEFT_4, RIGHT_4, TOP_1, BOTTOM_1, CENTER_3])));
}

var $MAP_73;
function $clinit_BoxLayouterOptions(){
  $clinit_BoxLayouterOptions = emptyMethod;
  PADDING_DEFAULT_4 = new ElkPadding_0(15);
  PADDING_4 = new Property_2(($clinit_CoreOptions() , PADDING_5), PADDING_DEFAULT_4);
  SPACING_NODE_NODE_4 = new Property_2(SPACING_NODE_NODE_5, 15);
  PRIORITY_2 = new Property_2(PRIORITY_3, valueOf_4(0));
  EXPAND_NODES = EXPAND_NODES_0;
  NODE_SIZE_CONSTRAINTS_0 = NODE_SIZE_CONSTRAINTS_1;
  NODE_SIZE_OPTIONS_0 = NODE_SIZE_OPTIONS_1;
  ASPECT_RATIO_3 = new Property_2(ASPECT_RATIO_4, $intern_136);
  INTERACTIVE_5 = INTERACTIVE_6;
  NODE_SIZE_MINIMUM_0 = NODE_SIZE_MINIMUM_1;
  BOX_PACKING_MODE = BOX_PACKING_MODE_0;
}

function $apply_28(registry){
  $register(registry, new LayoutAlgorithmData($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.box'), 'Box Layout'), 'Algorithm for packing of unconnected boxes, i.e. graphs without edges.'), new BoxLayouterOptions$BoxFactory)));
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.padding', PADDING_DEFAULT_4);
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.spacing.nodeNode', 15);
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.priority', valueOf_4(0));
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.expandNodes', $getDefault(EXPAND_NODES));
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.nodeSize.constraints', $getDefault(NODE_SIZE_CONSTRAINTS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.nodeSize.options', $getDefault(NODE_SIZE_OPTIONS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.aspectRatio', $intern_136);
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.interactive', $getDefault(INTERACTIVE_5));
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.nodeSize.minimum', $getDefault(NODE_SIZE_MINIMUM_0));
  $addOptionSupport(registry, 'org.eclipse.elk.box', 'org.eclipse.elk.box.packingMode', $getDefault(BOX_PACKING_MODE));
}

function BoxLayouterOptions(){
  $clinit_BoxLayouterOptions();
}

defineClass(888, 1, $intern_92, BoxLayouterOptions);
_.apply_3 = function apply_142(registry){
  $apply_28(registry);
}
;
var ASPECT_RATIO_3, BOX_PACKING_MODE, EXPAND_NODES, INTERACTIVE_5, NODE_SIZE_CONSTRAINTS_0, NODE_SIZE_MINIMUM_0, NODE_SIZE_OPTIONS_0, PADDING_4, PADDING_DEFAULT_4, PRIORITY_2, SPACING_NODE_NODE_4;
var Lorg_eclipse_elk_core_options_BoxLayouterOptions_2_classLit = createForClass('org.eclipse.elk.core.options', 'BoxLayouterOptions', 888);
function BoxLayouterOptions$BoxFactory(){
}

defineClass(889, 1, {}, BoxLayouterOptions$BoxFactory);
_.create_0 = function create_37(){
  var provider;
  return provider = new BoxLayoutProvider , provider;
}
;
_.destroy = function destroy_7(obj){
}
;
var Lorg_eclipse_elk_core_options_BoxLayouterOptions$BoxFactory_2_classLit = createForClass('org.eclipse.elk.core.options', 'BoxLayouterOptions/BoxFactory', 889);
function $clinit_CoreOptions(){
  $clinit_CoreOptions = emptyMethod;
  var all, all0;
  ALGORITHM = new Property('org.eclipse.elk.algorithm');
  RESOLVED_ALGORITHM = new Property('org.eclipse.elk.resolvedAlgorithm');
  ALIGNMENT_DEFAULT = ($clinit_Alignment() , AUTOMATIC);
  ALIGNMENT_0 = new Property_1('org.eclipse.elk.alignment', ALIGNMENT_DEFAULT);
  new ExclusiveBounds$ExclusiveLowerBound;
  ASPECT_RATIO_4 = new Property_1('org.eclipse.elk.aspectRatio', null);
  BEND_POINTS = new Property('org.eclipse.elk.bendPoints');
  DEBUG_MODE_3 = new Property_1('org.eclipse.elk.debugMode', ($clinit_Boolean() , $clinit_Boolean() , false));
  DIRECTION_DEFAULT_0 = ($clinit_Direction_0() , UNDEFINED_3);
  DIRECTION_0 = new Property_1('org.eclipse.elk.direction', DIRECTION_DEFAULT_0);
  EDGE_ROUTING_DEFAULT_0 = ($clinit_EdgeRouting() , UNDEFINED_5);
  EDGE_ROUTING_0 = new Property_1('org.eclipse.elk.edgeRouting', EDGE_ROUTING_DEFAULT_0);
  EXPAND_NODES_0 = new Property_1('org.eclipse.elk.expandNodes', (null , false));
  HIERARCHY_HANDLING_DEFAULT = ($clinit_HierarchyHandling() , INHERIT);
  HIERARCHY_HANDLING_0 = new Property_1('org.eclipse.elk.hierarchyHandling', HIERARCHY_HANDLING_DEFAULT);
  PADDING_DEFAULT_5 = new ElkPadding_0(12);
  PADDING_5 = new Property_1('org.eclipse.elk.padding', PADDING_DEFAULT_5);
  INTERACTIVE_6 = new Property_1('org.eclipse.elk.interactive', (null , false));
  PORT_CONSTRAINTS_DEFAULT = ($clinit_PortConstraints() , UNDEFINED_6);
  PORT_CONSTRAINTS_1 = new Property_1('org.eclipse.elk.portConstraints', PORT_CONSTRAINTS_DEFAULT);
  POSITION_2 = new Property('org.eclipse.elk.position');
  PRIORITY_3 = new Property('org.eclipse.elk.priority');
  RANDOM_SEED_1 = new Property('org.eclipse.elk.randomSeed');
  SEPARATE_CONNECTED_COMPONENTS_2 = new Property('org.eclipse.elk.separateConnectedComponents');
  JUNCTION_POINTS_DEFAULT = new KVectorChain;
  JUNCTION_POINTS_0 = new Property_1('org.eclipse.elk.junctionPoints', JUNCTION_POINTS_DEFAULT);
  COMMENT_BOX_0 = new Property_1('org.eclipse.elk.commentBox', (null , false));
  HYPERNODE_0 = new Property_1('org.eclipse.elk.hypernode', (null , false));
  new Property('org.eclipse.elk.labelManager');
  MARGINS_DEFAULT = new ElkMargin;
  MARGINS_0 = new Property_1('org.eclipse.elk.margins', MARGINS_DEFAULT);
  NO_LAYOUT_0 = new Property_1('org.eclipse.elk.noLayout', (null , false));
  new ExclusiveBounds$ExclusiveLowerBound;
  SCALE_FACTOR = new Property_1('org.eclipse.elk.scaleFactor', 1);
  new Property_1('org.eclipse.elk.animate', (null , true));
  valueOf_4(0);
  new Property_1('org.eclipse.elk.animTimeFactor', valueOf_4(100));
  new Property_1('org.eclipse.elk.layoutAncestors', (null , false));
  valueOf_4(0);
  new Property_1('org.eclipse.elk.maxAnimTime', valueOf_4(4000));
  valueOf_4(0);
  new Property_1('org.eclipse.elk.minAnimTime', valueOf_4(400));
  new Property_1('org.eclipse.elk.progressBar', (null , false));
  new Property_1('org.eclipse.elk.validateGraph', (null , false));
  new Property_1('org.eclipse.elk.validateOptions', (null , true));
  new Property_1('org.eclipse.elk.zoomToFit', (null , false));
  BOX_PACKING_MODE_DEFAULT = ($clinit_BoxLayoutProvider$PackingMode() , SIMPLE_0);
  BOX_PACKING_MODE_0 = new Property_1('org.eclipse.elk.box.packingMode', BOX_PACKING_MODE_DEFAULT);
  SPACING_COMPONENT_COMPONENT_1 = new Property_1('org.eclipse.elk.spacing.componentComponent', 20);
  SPACING_EDGE_EDGE_0 = new Property_1('org.eclipse.elk.spacing.edgeEdge', 10);
  SPACING_EDGE_LABEL_1 = new Property_1('org.eclipse.elk.spacing.edgeLabel', 2);
  SPACING_EDGE_NODE_0 = new Property_1('org.eclipse.elk.spacing.edgeNode', 10);
  SPACING_LABEL_LABEL_0 = new Property_1('org.eclipse.elk.spacing.labelLabel', 0);
  SPACING_LABEL_NODE_0 = new Property_1('org.eclipse.elk.spacing.labelNode', 5);
  SPACING_LABEL_PORT_0 = new Property_1('org.eclipse.elk.spacing.labelPort', 1);
  SPACING_NODE_NODE_5 = new Property_1('org.eclipse.elk.spacing.nodeNode', 20);
  SPACING_PORT_PORT_0 = new Property_1('org.eclipse.elk.spacing.portPort', 10);
  SPACING_INDIVIDUAL_OVERRIDE_0 = new Property('org.eclipse.elk.spacing.individualOverride');
  SPACING_PORTS_SURROUNDING_DEFAULT = new ElkMargin_0;
  SPACING_PORTS_SURROUNDING_0 = new Property_1('org.eclipse.elk.spacing.portsSurrounding', SPACING_PORTS_SURROUNDING_DEFAULT);
  PARTITIONING_PARTITION_0 = new Property('org.eclipse.elk.partitioning.partition');
  PARTITIONING_ACTIVATE_DEFAULT = (null , false);
  PARTITIONING_ACTIVATE_0 = new Property_1('org.eclipse.elk.partitioning.activate', PARTITIONING_ACTIVATE_DEFAULT);
  NODE_LABELS_PADDING_DEFAULT = new ElkPadding_0(5);
  NODE_LABELS_PADDING = new Property_1('org.eclipse.elk.nodeLabels.padding', NODE_LABELS_PADDING_DEFAULT);
  NODE_LABELS_PLACEMENT_DEFAULT = ($clinit_NodeLabelPlacement() , all0 = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit), 10) , new EnumSet$EnumSetImpl(all0, castTo(createFrom(all0, all0.length), 10), 0));
  NODE_LABELS_PLACEMENT_0 = new Property_1('org.eclipse.elk.nodeLabels.placement', NODE_LABELS_PLACEMENT_DEFAULT);
  PORT_ALIGNMENT_DEFAULT_DEFAULT_0 = ($clinit_PortAlignment() , DISTRIBUTED);
  PORT_ALIGNMENT_DEFAULT = new Property_1('org.eclipse.elk.portAlignment.default', PORT_ALIGNMENT_DEFAULT_DEFAULT_0);
  PORT_ALIGNMENT_NORTH_0 = new Property('org.eclipse.elk.portAlignment.north');
  PORT_ALIGNMENT_SOUTH_0 = new Property('org.eclipse.elk.portAlignment.south');
  PORT_ALIGNMENT_WEST_0 = new Property('org.eclipse.elk.portAlignment.west');
  PORT_ALIGNMENT_EAST_0 = new Property('org.eclipse.elk.portAlignment.east');
  NODE_SIZE_CONSTRAINTS_DEFAULT = (all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_SizeConstraint_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0));
  NODE_SIZE_CONSTRAINTS_1 = new Property_1('org.eclipse.elk.nodeSize.constraints', NODE_SIZE_CONSTRAINTS_DEFAULT);
  NODE_SIZE_OPTIONS_DEFAULT = of_0(($clinit_SizeOptions() , DEFAULT_MINIMUM_SIZE));
  NODE_SIZE_OPTIONS_1 = new Property_1('org.eclipse.elk.nodeSize.options', NODE_SIZE_OPTIONS_DEFAULT);
  NODE_SIZE_MINIMUM_DEFAULT = new KVector_1(0, 0);
  NODE_SIZE_MINIMUM_1 = new Property_1('org.eclipse.elk.nodeSize.minimum', NODE_SIZE_MINIMUM_DEFAULT);
  EDGE_LABELS_PLACEMENT_DEFAULT = ($clinit_EdgeLabelPlacement() , UNDEFINED_4);
  EDGE_LABELS_PLACEMENT_0 = new Property_1('org.eclipse.elk.edgeLabels.placement', EDGE_LABELS_PLACEMENT_DEFAULT);
  EDGE_LABELS_INLINE_0 = new Property_1('org.eclipse.elk.edgeLabels.inline', (null , false));
  new Property('org.eclipse.elk.font.name');
  valueOf_4(1);
  new Property_1('org.eclipse.elk.font.size', null);
  PORT_ANCHOR_0 = new Property('org.eclipse.elk.port.anchor');
  PORT_INDEX_0 = new Property('org.eclipse.elk.port.index');
  PORT_SIDE_DEFAULT = ($clinit_PortSide() , UNDEFINED_7);
  PORT_SIDE_0 = new Property_1('org.eclipse.elk.port.side', PORT_SIDE_DEFAULT);
  PORT_BORDER_OFFSET_0 = new Property('org.eclipse.elk.port.borderOffset');
  PORT_LABELS_PLACEMENT_DEFAULT = ($clinit_PortLabelPlacement() , OUTSIDE_0);
  PORT_LABELS_PLACEMENT_0 = new Property_1('org.eclipse.elk.portLabels.placement', PORT_LABELS_PLACEMENT_DEFAULT);
  PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE_0 = new Property_1('org.eclipse.elk.portLabels.nextToPortIfPossible', (null , false));
  INSIDE_SELF_LOOPS_ACTIVATE_0 = new Property_1('org.eclipse.elk.insideSelfLoops.activate', (null , false));
  INSIDE_SELF_LOOPS_YO_0 = new Property_1('org.eclipse.elk.insideSelfLoops.yo', (null , false));
  EDGE_THICKNESS_1 = new Property_1('org.eclipse.elk.edge.thickness', 1);
  EDGE_TYPE_DEFAULT = ($clinit_EdgeType() , NONE_10);
  new Property_1('org.eclipse.elk.edge.type', EDGE_TYPE_DEFAULT);
}

function CoreOptions(){
  $clinit_CoreOptions();
}

defineClass(817, 1, $intern_92, CoreOptions);
_.apply_3 = function apply_143(registry){
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.algorithm'), ''), 'Layout Algorithm'), 'Select a specific layout algorithm.'), ($clinit_LayoutOptionData$Type() , STRING)), Ljava_lang_String_2_classLit), of_0(($clinit_LayoutOptionData$Target() , PARENTS)))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.resolvedAlgorithm'), ''), 'Resolved Layout Algorithm'), 'Meta data associated with the selected algorithm.'), OBJECT), Lorg_eclipse_elk_core_data_LayoutAlgorithmData_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.alignment'), ''), 'Alignment'), 'Alignment of the selected node relative to other nodes; the exact meaning depends on the used algorithm.'), ALIGNMENT_DEFAULT), ENUM), Lorg_eclipse_elk_core_options_Alignment_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.alignment']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.aspectRatio'), ''), 'Aspect Ratio'), 'The desired aspect ratio of the drawing, that is the quotient of width by height.'), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.aspectRatio']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.bendPoints'), ''), 'Bend Points'), "A fixed list of bend points for the edge. This is used by the 'Fixed Layout' algorithm to specify a pre-defined routing for an edge. The vector chain must include the source point, any bend points, and the target point, so it must have at least two points."), OBJECT), Lorg_eclipse_elk_core_math_KVectorChain_2_classLit), of_0(EDGES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.bendPoints']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.debugMode'), ''), 'Debug Mode'), 'Whether additional debug information shall be generated.'), ($clinit_Boolean() , $clinit_Boolean() , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.debugMode']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.direction'), ''), 'Direction'), 'Overall direction of edges: horizontal (right / left) or vertical (down / up).'), DIRECTION_DEFAULT_0), ENUM), Lorg_eclipse_elk_core_options_Direction_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.direction']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.edgeRouting'), ''), 'Edge Routing'), 'What kind of edge routing style should be applied for the content of a parent node. Algorithms may also set this option to single edges in order to mark them as splines. The bend point list of edges with this option set to SPLINES must be interpreted as control points for a piecewise cubic spline.'), EDGE_ROUTING_DEFAULT_0), ENUM), Lorg_eclipse_elk_core_options_EdgeRouting_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.edgeRouting']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.expandNodes'), ''), 'Expand Nodes'), 'If active, nodes are expanded to fill the area of their parent.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.expandNodes']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.hierarchyHandling'), ''), 'Hierarchy Handling'), 'If this option is set to SEPARATE_CHILDREN, each hierarchy level of the graph is processed independently, possibly by different layout algorithms, beginning with the lowest level. If it is set to INCLUDE_CHILDREN, the algorithm is responsible to process all hierarchy levels that are contained in the associated parent node. If the root node is set to inherit (or not set at all), the default behavior is SEPARATE_CHILDREN.'), HIERARCHY_HANDLING_DEFAULT), ENUM), Lorg_eclipse_elk_core_options_HierarchyHandling_2_classLit), of_1(PARENTS, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [NODES]))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.hierarchyHandling']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.padding'), ''), 'Padding'), "The padding to be left to a parent element's border when placing child elements. This can also serve as an output option of a layout algorithm if node size calculation is setup appropriately."), PADDING_DEFAULT_5), OBJECT), Lorg_eclipse_elk_core_math_ElkPadding_2_classLit), of_1(PARENTS, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [NODES])))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.interactive'), ''), 'Interactive'), 'Whether the algorithm should be run in interactive mode for the content of a parent node. What this means exactly depends on how the specific algorithm interprets this option. Usually in the interactive mode algorithms try to modify the current layout as little as possible.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.portConstraints'), ''), 'Port Constraints'), 'Defines constraints of the position of the ports of a node.'), PORT_CONSTRAINTS_DEFAULT), ENUM), Lorg_eclipse_elk_core_options_PortConstraints_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portConstraints']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.position'), ''), 'Position'), "The position of a node, port, or label. This is used by the 'Fixed Layout' algorithm to specify a pre-defined position."), OBJECT), Lorg_eclipse_elk_core_math_KVector_2_classLit), of_1(NODES, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [PORTS, LABELS]))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.position']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.priority'), ''), 'Priority'), 'Defines the priority of an object; its meaning depends on the specific layout algorithm and the context where it is used.'), INT), Ljava_lang_Integer_2_classLit), of_1(NODES, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [EDGES]))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.priority']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.randomSeed'), ''), 'Randomization Seed'), 'Seed used for pseudo-random number generators to control the layout algorithm. If the value is 0, the seed shall be determined pseudo-randomly (e.g. from the system time).'), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.randomSeed']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.separateConnectedComponents'), ''), 'Separate Connected Components'), 'Whether each connected component should be processed separately.'), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.separateConnComp']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.junctionPoints'), ''), 'Junction Points'), 'This option is not used as option, but as output of the layout algorithms. It is attached to edges and determines the points where junction symbols should be drawn in order to represent hyperedges with orthogonal routing. Whether such points are computed depends on the chosen layout algorithm and edge routing style. The points are put into the vector chain with no specific order.'), JUNCTION_POINTS_DEFAULT), OBJECT), Lorg_eclipse_elk_core_math_KVectorChain_2_classLit), of_0(EDGES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.junctionPoints']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.commentBox'), ''), 'Comment Box'), 'Whether the node should be regarded as a comment box instead of a regular node. In that case its placement should be similar to how labels are handled. Any edges incident to a comment box specify to which graph elements the comment is related.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.commentBox']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.hypernode'), ''), 'Hypernode'), 'Whether the node should be handled as a hypernode.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.hypernode']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.labelManager'), ''), 'Label Manager'), "Label managers can shorten labels upon a layout algorithm's request."), OBJECT), Lorg_eclipse_elk_core_labels_ILabelManager_2_classLit), of_1(PARENTS, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [LABELS])))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.margins'), ''), 'Margins'), "Margins define additional space around the actual bounds of a graph element. For instance, ports or labels being placed on the outside of a node's border might introduce such a margin. The margin is used to guarantee non-overlap of other graph elements with those ports or labels."), MARGINS_DEFAULT), OBJECT), Lorg_eclipse_elk_core_math_ElkMargin_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.margins']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.noLayout'), ''), 'No Layout'), "No layout is done for the associated element. This is used to mark parts of a diagram to avoid their inclusion in the layout graph, or to mark parts of the layout graph to prevent layout engines from processing them. If you wish to exclude the contents of a compound node from automatic layout, while the node itself is still considered on its own layer, use the 'Fixed Layout' algorithm for that node."), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_1(NODES, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [EDGES, PORTS, LABELS]))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.noLayout']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.scaleFactor'), ''), 'Scale Factor'), "The scaling factor to be applied to the corresponding node in recursive layout. It causes the corresponding node's size to be adjusted, and its ports and labels to be sized and placed accordingly after the layout of that node has been determined (and before the node itself and its siblings are arranged). The scaling is not reverted afterwards, so the resulting layout graph contains the adjusted size and position data. This option is currently not supported if 'Layout Hierarchy' is set."), 1), DOUBLE), Ljava_lang_Double_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.scaleFactor']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.animate'), ''), 'Animate'), 'Whether the shift from the old layout to the new computed layout shall be animated.'), (null , true)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.animate']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.animTimeFactor'), ''), 'Animation Time Factor'), "Factor for computation of animation time. The higher the value, the longer the animation time. If the value is 0, the resulting time is always equal to the minimum defined by 'Minimal Animation Time'."), valueOf_4(100)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.animTimeFactor']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.layoutAncestors'), ''), 'Layout Ancestors'), 'Whether the hierarchy levels on the path from the selected element to the root of the diagram shall be included in the layout process.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.layoutAncestors']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.maxAnimTime'), ''), 'Maximal Animation Time'), 'The maximal time for animations, in milliseconds.'), valueOf_4(4000)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.maxAnimTime']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.minAnimTime'), ''), 'Minimal Animation Time'), 'The minimal time for animations, in milliseconds.'), valueOf_4(400)), INT), Ljava_lang_Integer_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.minAnimTime']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.progressBar'), ''), 'Progress Bar'), 'Whether a progress bar shall be displayed during layout computations.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.progressBar']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.validateGraph'), ''), 'Validate Graph'), 'Whether the graph shall be validated before any layout algorithm is applied. If this option is enabled and at least one error is found, the layout process is aborted and a message is shown to the user.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.validateOptions'), ''), 'Validate Options'), 'Whether layout options shall be validated before any layout algorithm is applied. If this option is enabled and at least one error is found, the layout process is aborted and a message is shown to the user.'), (null , true)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.zoomToFit'), ''), 'Zoom to Fit'), 'Whether the zoom level shall be set to view the whole diagram after layout.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.zoomToFit']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.box.packingMode'), 'box'), 'Box Layout Mode'), 'Configures the packing mode used by the {@link BoxLayoutProvider}. If SIMPLE is not required (neither priorities are used nor the interactive mode), GROUP_DEC can improve the packing and decrease the area. GROUP_MIXED and GROUP_INC may, in very specific scenarios, work better.'), BOX_PACKING_MODE_DEFAULT), ENUM), Lorg_eclipse_elk_core_util_BoxLayoutProvider$PackingMode_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.componentComponent'), 'spacing'), 'Components Spacing'), "Spacing to be preserved between pairs of connected components. This option is only relevant if 'separateConnectedComponents' is activated."), 20), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.borderSpacing']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.edgeEdge'), 'spacing'), 'Edge Spacing'), 'Spacing to be preserved between any two edges. Note that while this can somewhat easily be satisfied for the segments of orthogonally drawn edges, it is harder for general polylines or splines.'), 10), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.edgeLabel'), 'spacing'), 'Edge Label Spacing'), "The minimal distance to be preserved between a label and the edge it is associated with. Note that the placement of a label is influenced by the 'edgelabels.placement' option."), 2), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.edgeNode'), 'spacing'), 'Edge Node Spacing'), 'Spacing to be preserved between nodes and edges.'), 10), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.labelLabel'), 'spacing'), 'Label Spacing'), 'Determines the amount of space to be left between two labels of the same graph element.'), 0), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.labelSpacing']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.labelNode'), 'spacing'), 'Label Node Spacing'), "Spacing to be preserved between labels and the border of node they are associated with. Note that the placement of a label is influenced by the 'nodelabels.placement' option."), 5), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.labelSpacing']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.labelPort'), 'spacing'), 'Label Port Spacing'), "Spacing to be preserved between labels and the ports they are associated with. Note that the placement of a label is influenced by the 'portlabels.placement' option."), 1), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.nodeNode'), 'spacing'), 'Node Spacing'), 'The minimal distance to be preserved between each two nodes.'), 20), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.spacing']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.portPort'), 'spacing'), 'Port Spacing'), 'Spacing between pairs of ports of the same node.'), 10), DOUBLE), Ljava_lang_Double_2_classLit), of_1(PARENTS, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [NODES]))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portSpacing']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.individualOverride'), 'spacing'), 'Individual Spacing Override'), 'In general spacing values apply to the children of the hierarchical node (possibly the root node) for which the values are actually specified. Hereby, the children include ports, edges, and labels.'), OBJECT), Lorg_eclipse_elk_core_util_IndividualSpacings_2_classLit), of_1(NODES, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [EDGES, PORTS, LABELS])))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.spacing.portsSurrounding'), 'spacing'), 'Additional Port Space'), 'Additional space around the sets of ports on each node side. For each side of a node, this option can reserve additional space before and after the ports on each side. For example, a top spacing of 20 makes sure that the first port on the western and eastern side is 20 units away from the northern border.'), SPACING_PORTS_SURROUNDING_DEFAULT), OBJECT), Lorg_eclipse_elk_core_math_ElkMargin_2_classLit), of_0(PARENTS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.partitioning.partition'), 'partitioning'), 'Layout Partition'), "Partition to which the node belongs to. If 'layoutPartitions' is true, all nodes are expected to have a partition."), INT), Ljava_lang_Integer_2_classLit), of_1(PARENTS, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [NODES]))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.partition']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.partitioning.activate'), 'partitioning'), 'Layout Partitioning'), 'Whether to activate partitioned layout.'), PARTITIONING_ACTIVATE_DEFAULT), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(PARENTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.layoutPartitions']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.nodeLabels.padding'), 'nodeLabels'), 'Node Label Padding'), 'Define padding for node labels that are placed inside of a node.'), NODE_LABELS_PADDING_DEFAULT), OBJECT), Lorg_eclipse_elk_core_math_ElkPadding_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.nodeLabelInset']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.nodeLabels.placement'), 'nodeLabels'), 'Node Label Placement'), "Hints for where node labels are to be placed; if empty, the node label's position is not modified."), NODE_LABELS_PLACEMENT_DEFAULT), ENUMSET), Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit), of_1(NODES, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_LayoutOptionData$Target_2_classLit, 1), $intern_38, 165, 0, [LABELS]))), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.nodeLabelPlacement']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.portAlignment.default'), 'portAlignment'), 'Port Alignment'), 'Defines the default port distribution for a node. May be overridden for each side individually.'), PORT_ALIGNMENT_DEFAULT_DEFAULT_0), ENUM), Lorg_eclipse_elk_core_options_PortAlignment_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portAlignment']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.portAlignment.north'), 'portAlignment'), 'Port Alignment (North)'), "Defines how ports on the northern side are placed, overriding the node's general port alignment."), ENUM), Lorg_eclipse_elk_core_options_PortAlignment_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portAlignment.north']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.portAlignment.south'), 'portAlignment'), 'Port Alignment (South)'), "Defines how ports on the southern side are placed, overriding the node's general port alignment."), ENUM), Lorg_eclipse_elk_core_options_PortAlignment_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portAlignment.south']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.portAlignment.west'), 'portAlignment'), 'Port Alignment (West)'), "Defines how ports on the western side are placed, overriding the node's general port alignment."), ENUM), Lorg_eclipse_elk_core_options_PortAlignment_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portAlignment.west']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.portAlignment.east'), 'portAlignment'), 'Port Alignment (East)'), "Defines how ports on the eastern side are placed, overriding the node's general port alignment."), ENUM), Lorg_eclipse_elk_core_options_PortAlignment_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portAlignment.east']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.nodeSize.constraints'), 'nodeSize'), 'Node Size Constraints'), 'Constraints for determining node sizes. Each member of the set specifies something that should be taken into account when calculating node sizes. The empty set corresponds to node sizes being fixed.'), NODE_SIZE_CONSTRAINTS_DEFAULT), ENUMSET), Lorg_eclipse_elk_core_options_SizeConstraint_2_classLit), of_0(NODES))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.nodeSize.options'), 'nodeSize'), 'Node Size Options'), 'Options modifying the behavior of the size constraints set on a node. Each member of the set specifies something that should be taken into account when calculating node sizes. The empty set corresponds to no further modifications.'), NODE_SIZE_OPTIONS_DEFAULT), ENUMSET), Lorg_eclipse_elk_core_options_SizeOptions_2_classLit), of_0(NODES))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.nodeSize.minimum'), 'nodeSize'), 'Node Size Minimum'), 'The minimal size to which a node can be reduced.'), NODE_SIZE_MINIMUM_DEFAULT), OBJECT), Lorg_eclipse_elk_core_math_KVector_2_classLit), of_0(NODES))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.edgeLabels.placement'), 'edgeLabels'), 'Edge Label Placement'), 'Gives a hint on where to put edge labels.'), EDGE_LABELS_PLACEMENT_DEFAULT), ENUM), Lorg_eclipse_elk_core_options_EdgeLabelPlacement_2_classLit), of_0(LABELS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.edgeLabelPlacement']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.edgeLabels.inline'), 'edgeLabels'), 'Inline Edge Labels'), "If true, an edge label is placed directly on its edge. May only apply to center edge labels. This kind of label placement is only advisable if the label's rendering is such that it is not crossed by its edge and thus stays legible."), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(LABELS))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.font.name'), 'font'), 'Font Name'), 'Font name used for a label.'), STRING), Ljava_lang_String_2_classLit), of_0(LABELS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.fontName']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.font.size'), 'font'), 'Font Size'), 'Font size used for a label.'), INT), Ljava_lang_Integer_2_classLit), of_0(LABELS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.fontSize']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.port.anchor'), 'port'), 'Port Anchor Offset'), 'The offset to the port position where connections shall be attached.'), OBJECT), Lorg_eclipse_elk_core_math_KVector_2_classLit), of_0(PORTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portAnchor']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.port.index'), 'port'), 'Port Index'), "The index of a port in the fixed order around a node. The order is assumed as clockwise, starting with the leftmost port on the top side. This option must be set if 'Port Constraints' is set to FIXED_ORDER and no specific positions are given for the ports. Additionally, the option 'Port Side' must be defined in this case."), INT), Ljava_lang_Integer_2_classLit), of_0(PORTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portIndex']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.port.side'), 'port'), 'Port Side'), "The side of a node on which a port is situated. This option must be set if 'Port Constraints' is set to FIXED_SIDE or FIXED_ORDER and no specific positions are given for the ports."), PORT_SIDE_DEFAULT), ENUM), Lorg_eclipse_elk_core_options_PortSide_2_classLit), of_0(PORTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portSide']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.port.borderOffset'), 'port'), 'Port Border Offset'), "The offset of ports on the node border. With a positive offset the port is moved outside of the node, while with a negative offset the port is moved towards the inside. An offset of 0 means that the port is placed directly on the node border, i.e. if the port side is north, the port's south border touches the nodes's north border; if the port side is east, the port's west border touches the nodes's east border; if the port side is south, the port's north border touches the node's south border; if the port side is west, the port's east border touches the node's west border."), DOUBLE), Ljava_lang_Double_2_classLit), of_0(PORTS)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.offset']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.portLabels.placement'), 'portLabels'), 'Port Label Placement'), 'Decides on a placement method for port labels.'), PORT_LABELS_PLACEMENT_DEFAULT), ENUM), Lorg_eclipse_elk_core_options_PortLabelPlacement_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.portLabelPlacement']))));
  $register_1(registry, new LayoutOptionData($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.portLabels.nextToPortIfPossible'), 'portLabels'), 'Port Labels Next to Port'), "Usually, inside port labels of hierarchical nodes are placed not next to their port, but with an offset to avoid edge-label crossings. The offset is not necessary if the port has no connections that would cross the label, but is usually applied anyway to keep things uniform. Setting this option to true places labels next to their ports if they won't be crossed by edges."), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(NODES))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.insideSelfLoops.activate'), 'insideSelfLoops'), 'Activate Inside Self Loops'), "Whether this node allows to route self loops inside of it instead of around it. If set to true, this will make the node a compound node if it isn't already, and will require the layout algorithm to support compound nodes with hierarchical ports."), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(NODES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.selfLoopInside']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.insideSelfLoops.yo'), 'insideSelfLoops'), 'Inside Self Loop'), 'Whether a self loop should be routed inside a node instead of around that node.'), (null , false)), BOOLEAN), Ljava_lang_Boolean_2_classLit), of_0(EDGES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.selfLoopInside']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.edge.thickness'), 'edge'), 'Edge Thickness'), 'The thickness of an edge. This is a hint on the line width used to draw an edge, possibly requiring more space to be reserved for it.'), 1), DOUBLE), Ljava_lang_Double_2_classLit), of_0(EDGES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.thickness']))));
  $register_1(registry, new LayoutOptionData($legacyIds($targets($optionClass($type($defaultValue($description_1($name_1($group($id_1(new LayoutOptionData$Builder, 'org.eclipse.elk.edge.type'), 'edge'), 'Edge Type'), 'The type of an edge. This is usually used for UML class diagrams, where associations must be handled differently from generalizations.'), EDGE_TYPE_DEFAULT), ENUM), Lorg_eclipse_elk_core_options_EdgeType_2_classLit), of_0(EDGES)), stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['de.cau.cs.kieler.edgeType']))));
  $register_0(registry, new LayoutCategoryData($description_0($name_0($id_0(new LayoutCategoryData$Builder, 'org.eclipse.elk.layered'), 'Layered'), 'The layer-based method was introduced by Sugiyama, Tagawa and Toda in 1981. It emphasizes the direction of edges by pointing as many edges as possible into the same direction. The nodes are arranged in layers, which are sometimes called "hierarchies", and then reordered such that the number of edge crossings is minimized. Afterwards, concrete coordinates are computed for the nodes and edge bend points.')));
  $register_0(registry, new LayoutCategoryData($description_0($name_0($id_0(new LayoutCategoryData$Builder, 'org.eclipse.elk.orthogonal'), 'Orthogonal'), 'Orthogonal methods that follow the "topology-shape-metrics" approach by Batini, Nardelli and Tamassia \'86. The first phase determines the topology of the drawing by applying a planarization technique, which results in a planar representation of the graph. The orthogonal shape is computed in the second phase, which aims at minimizing the number of edge bends, and is called orthogonalization. The third phase leads to concrete coordinates for nodes and edge bend points by applying a compaction method, thus defining the metrics.')));
  $register_0(registry, new LayoutCategoryData($description_0($name_0($id_0(new LayoutCategoryData$Builder, 'org.eclipse.elk.force'), 'Force'), 'Layout algorithms that follow physical analogies by simulating a system of attractive and repulsive forces. The first successful method of this kind was proposed by Eades in 1984.')));
  $register_0(registry, new LayoutCategoryData($description_0($name_0($id_0(new LayoutCategoryData$Builder, 'org.eclipse.elk.circle'), 'Circle'), 'Circular layout algorithms emphasize cycles or biconnected components of a graph by arranging them in circles. This is useful if a drawing is desired where such components are clearly grouped, or where cycles are shown as prominent OPTIONS of the graph.')));
  $register_0(registry, new LayoutCategoryData($description_0($name_0($id_0(new LayoutCategoryData$Builder, 'org.eclipse.elk.tree'), 'Tree'), 'Specialized layout methods for trees, i.e. acyclic graphs. The regular structure of graphs that have no undirected cycles can be emphasized using an algorithm of this type.')));
  $register_0(registry, new LayoutCategoryData($description_0($name_0($id_0(new LayoutCategoryData$Builder, 'org.eclipse.elk.planar'), 'Planar'), 'Algorithms that require a planar or upward planar graph. Most of these algorithms are theoretically interesting, but not practically usable.')));
  $register_0(registry, new LayoutCategoryData($description_0($name_0($id_0(new LayoutCategoryData$Builder, 'org.eclipse.elk.radial'), 'Radial'), 'Radial layout algorithms usually position the nodes of the graph on concentric circles.')));
  $apply_29((new FixedLayouterOptions , registry));
  $apply_28((new BoxLayouterOptions , registry));
  $apply_30((new RandomLayouterOptions , registry));
}
;
var ALGORITHM, ALIGNMENT_0, ALIGNMENT_DEFAULT, ASPECT_RATIO_4, BEND_POINTS, BOX_PACKING_MODE_0, BOX_PACKING_MODE_DEFAULT, COMMENT_BOX_0, DEBUG_MODE_3, DIRECTION_0, DIRECTION_DEFAULT_0, EDGE_LABELS_INLINE_0, EDGE_LABELS_PLACEMENT_0, EDGE_LABELS_PLACEMENT_DEFAULT, EDGE_ROUTING_0, EDGE_ROUTING_DEFAULT_0, EDGE_THICKNESS_1, EDGE_TYPE_DEFAULT, EXPAND_NODES_0, HIERARCHY_HANDLING_0, HIERARCHY_HANDLING_DEFAULT, HYPERNODE_0, INSIDE_SELF_LOOPS_ACTIVATE_0, INSIDE_SELF_LOOPS_YO_0, INTERACTIVE_6, JUNCTION_POINTS_0, JUNCTION_POINTS_DEFAULT, MARGINS_0, MARGINS_DEFAULT, NODE_LABELS_PADDING, NODE_LABELS_PADDING_DEFAULT, NODE_LABELS_PLACEMENT_0, NODE_LABELS_PLACEMENT_DEFAULT, NODE_SIZE_CONSTRAINTS_1, NODE_SIZE_CONSTRAINTS_DEFAULT, NODE_SIZE_MINIMUM_1, NODE_SIZE_MINIMUM_DEFAULT, NODE_SIZE_OPTIONS_1, NODE_SIZE_OPTIONS_DEFAULT, NO_LAYOUT_0, PADDING_5, PADDING_DEFAULT_5, PARTITIONING_ACTIVATE_0, PARTITIONING_ACTIVATE_DEFAULT, PARTITIONING_PARTITION_0, PORT_ALIGNMENT_DEFAULT, PORT_ALIGNMENT_DEFAULT_DEFAULT_0, PORT_ALIGNMENT_EAST_0, PORT_ALIGNMENT_NORTH_0, PORT_ALIGNMENT_SOUTH_0, PORT_ALIGNMENT_WEST_0, PORT_ANCHOR_0, PORT_BORDER_OFFSET_0, PORT_CONSTRAINTS_1, PORT_CONSTRAINTS_DEFAULT, PORT_INDEX_0, PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE_0, PORT_LABELS_PLACEMENT_0, PORT_LABELS_PLACEMENT_DEFAULT, PORT_SIDE_0, PORT_SIDE_DEFAULT, POSITION_2, PRIORITY_3, RANDOM_SEED_1, RESOLVED_ALGORITHM, SCALE_FACTOR, SEPARATE_CONNECTED_COMPONENTS_2, SPACING_COMPONENT_COMPONENT_1, SPACING_EDGE_EDGE_0, SPACING_EDGE_LABEL_1, SPACING_EDGE_NODE_0, SPACING_INDIVIDUAL_OVERRIDE_0, SPACING_LABEL_LABEL_0, SPACING_LABEL_NODE_0, SPACING_LABEL_PORT_0, SPACING_NODE_NODE_5, SPACING_PORTS_SURROUNDING_0, SPACING_PORTS_SURROUNDING_DEFAULT, SPACING_PORT_PORT_0;
var Lorg_eclipse_elk_core_options_CoreOptions_2_classLit = createForClass('org.eclipse.elk.core.options', 'CoreOptions', 817);
function $clinit_Direction_0(){
  $clinit_Direction_0 = emptyMethod;
  UNDEFINED_3 = new Direction_0('UNDEFINED', 0);
  RIGHT_5 = new Direction_0('RIGHT', 1);
  LEFT_5 = new Direction_0('LEFT', 2);
  DOWN_1 = new Direction_0('DOWN', 3);
  UP_1 = new Direction_0('UP', 4);
}

function $isHorizontal(this$static){
  return this$static == LEFT_5 || this$static == RIGHT_5;
}

function $isVertical(this$static){
  return this$static == UP_1 || this$static == DOWN_1;
}

function $opposite_0(this$static){
  switch (this$static.ordinal) {
    case 2:
      return RIGHT_5;
    case 1:
      return LEFT_5;
    case 4:
      return DOWN_1;
    case 3:
      return UP_1;
    default:return UNDEFINED_3;
  }
}

function Direction_0(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_86(name_0){
  $clinit_Direction_0();
  return valueOf(($clinit_Direction$Map_0() , $MAP_74), name_0);
}

function values_82(){
  $clinit_Direction_0();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_Direction_2_classLit, 1), $intern_38, 107, 0, [UNDEFINED_3, RIGHT_5, LEFT_5, DOWN_1, UP_1]);
}

defineClass(107, 22, {3:1, 34:1, 22:1, 107:1}, Direction_0);
var DOWN_1, LEFT_5, RIGHT_5, UNDEFINED_3, UP_1;
var Lorg_eclipse_elk_core_options_Direction_2_classLit = createForEnum('org.eclipse.elk.core.options', 'Direction', 107, Ljava_lang_Enum_2_classLit, values_82, valueOf_86);
function $clinit_Direction$Map_0(){
  $clinit_Direction$Map_0 = emptyMethod;
  $MAP_74 = createValueOfMap(($clinit_Direction_0() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_Direction_2_classLit, 1), $intern_38, 107, 0, [UNDEFINED_3, RIGHT_5, LEFT_5, DOWN_1, UP_1])));
}

var $MAP_74;
function $clinit_EdgeLabelPlacement(){
  $clinit_EdgeLabelPlacement = emptyMethod;
  UNDEFINED_4 = new EdgeLabelPlacement('UNDEFINED', 0);
  CENTER_4 = new EdgeLabelPlacement('CENTER', 1);
  HEAD = new EdgeLabelPlacement('HEAD', 2);
  TAIL = new EdgeLabelPlacement('TAIL', 3);
}

function EdgeLabelPlacement(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_87(name_0){
  $clinit_EdgeLabelPlacement();
  return valueOf(($clinit_EdgeLabelPlacement$Map() , $MAP_75), name_0);
}

function values_83(){
  $clinit_EdgeLabelPlacement();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_EdgeLabelPlacement_2_classLit, 1), $intern_38, 236, 0, [UNDEFINED_4, CENTER_4, HEAD, TAIL]);
}

defineClass(236, 22, {3:1, 34:1, 22:1, 236:1}, EdgeLabelPlacement);
var CENTER_4, HEAD, TAIL, UNDEFINED_4;
var Lorg_eclipse_elk_core_options_EdgeLabelPlacement_2_classLit = createForEnum('org.eclipse.elk.core.options', 'EdgeLabelPlacement', 236, Ljava_lang_Enum_2_classLit, values_83, valueOf_87);
function $clinit_EdgeLabelPlacement$Map(){
  $clinit_EdgeLabelPlacement$Map = emptyMethod;
  $MAP_75 = createValueOfMap(($clinit_EdgeLabelPlacement() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_EdgeLabelPlacement_2_classLit, 1), $intern_38, 236, 0, [UNDEFINED_4, CENTER_4, HEAD, TAIL])));
}

var $MAP_75;
function $clinit_EdgeRouting(){
  $clinit_EdgeRouting = emptyMethod;
  UNDEFINED_5 = new EdgeRouting('UNDEFINED', 0);
  POLYLINE = new EdgeRouting('POLYLINE', 1);
  ORTHOGONAL = new EdgeRouting('ORTHOGONAL', 2);
  SPLINES = new EdgeRouting('SPLINES', 3);
}

function EdgeRouting(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_88(name_0){
  $clinit_EdgeRouting();
  return valueOf(($clinit_EdgeRouting$Map() , $MAP_76), name_0);
}

function values_84(){
  $clinit_EdgeRouting();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_EdgeRouting_2_classLit, 1), $intern_38, 204, 0, [UNDEFINED_5, POLYLINE, ORTHOGONAL, SPLINES]);
}

defineClass(204, 22, {3:1, 34:1, 22:1, 204:1}, EdgeRouting);
var ORTHOGONAL, POLYLINE, SPLINES, UNDEFINED_5;
var Lorg_eclipse_elk_core_options_EdgeRouting_2_classLit = createForEnum('org.eclipse.elk.core.options', 'EdgeRouting', 204, Ljava_lang_Enum_2_classLit, values_84, valueOf_88);
function $clinit_EdgeRouting$Map(){
  $clinit_EdgeRouting$Map = emptyMethod;
  $MAP_76 = createValueOfMap(($clinit_EdgeRouting() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_EdgeRouting_2_classLit, 1), $intern_38, 204, 0, [UNDEFINED_5, POLYLINE, ORTHOGONAL, SPLINES])));
}

var $MAP_76;
function $clinit_EdgeType(){
  $clinit_EdgeType = emptyMethod;
  NONE_10 = new EdgeType('NONE', 0);
  DIRECTED = new EdgeType('DIRECTED', 1);
  UNDIRECTED = new EdgeType('UNDIRECTED', 2);
  ASSOCIATION = new EdgeType('ASSOCIATION', 3);
  GENERALIZATION = new EdgeType('GENERALIZATION', 4);
  DEPENDENCY = new EdgeType('DEPENDENCY', 5);
}

function EdgeType(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_89(name_0){
  $clinit_EdgeType();
  return valueOf(($clinit_EdgeType$Map() , $MAP_77), name_0);
}

function values_85(){
  $clinit_EdgeType();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_EdgeType_2_classLit, 1), $intern_38, 298, 0, [NONE_10, DIRECTED, UNDIRECTED, ASSOCIATION, GENERALIZATION, DEPENDENCY]);
}

defineClass(298, 22, {3:1, 34:1, 22:1, 298:1}, EdgeType);
var ASSOCIATION, DEPENDENCY, DIRECTED, GENERALIZATION, NONE_10, UNDIRECTED;
var Lorg_eclipse_elk_core_options_EdgeType_2_classLit = createForEnum('org.eclipse.elk.core.options', 'EdgeType', 298, Ljava_lang_Enum_2_classLit, values_85, valueOf_89);
function $clinit_EdgeType$Map(){
  $clinit_EdgeType$Map = emptyMethod;
  $MAP_77 = createValueOfMap(($clinit_EdgeType() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_EdgeType_2_classLit, 1), $intern_38, 298, 0, [NONE_10, DIRECTED, UNDIRECTED, ASSOCIATION, GENERALIZATION, DEPENDENCY])));
}

var $MAP_77;
function $clinit_FixedLayouterOptions(){
  $clinit_FixedLayouterOptions = emptyMethod;
  PADDING_DEFAULT_6 = new ElkPadding_0(15);
  PADDING_6 = new Property_2(($clinit_CoreOptions() , PADDING_5), PADDING_DEFAULT_6);
  POSITION_3 = POSITION_2;
  BEND_POINTS_0 = BEND_POINTS;
  NODE_SIZE_CONSTRAINTS_2 = NODE_SIZE_CONSTRAINTS_1;
  NODE_SIZE_MINIMUM_2 = NODE_SIZE_MINIMUM_1;
}

function $apply_29(registry){
  $register(registry, new LayoutAlgorithmData($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.fixed'), 'Fixed Layout'), 'Keeps the current layout as it is, without any automatic modification. Optional coordinates can be given for nodes and edge bend points.'), new FixedLayouterOptions$FixedFactory)));
  $addOptionSupport(registry, 'org.eclipse.elk.fixed', 'org.eclipse.elk.padding', PADDING_DEFAULT_6);
  $addOptionSupport(registry, 'org.eclipse.elk.fixed', 'org.eclipse.elk.position', $getDefault(POSITION_3));
  $addOptionSupport(registry, 'org.eclipse.elk.fixed', 'org.eclipse.elk.bendPoints', $getDefault(BEND_POINTS_0));
  $addOptionSupport(registry, 'org.eclipse.elk.fixed', 'org.eclipse.elk.nodeSize.constraints', $getDefault(NODE_SIZE_CONSTRAINTS_2));
  $addOptionSupport(registry, 'org.eclipse.elk.fixed', 'org.eclipse.elk.nodeSize.minimum', $getDefault(NODE_SIZE_MINIMUM_2));
}

function FixedLayouterOptions(){
  $clinit_FixedLayouterOptions();
}

defineClass(886, 1, $intern_92, FixedLayouterOptions);
_.apply_3 = function apply_144(registry){
  $apply_29(registry);
}
;
var BEND_POINTS_0, NODE_SIZE_CONSTRAINTS_2, NODE_SIZE_MINIMUM_2, PADDING_6, PADDING_DEFAULT_6, POSITION_3;
var Lorg_eclipse_elk_core_options_FixedLayouterOptions_2_classLit = createForClass('org.eclipse.elk.core.options', 'FixedLayouterOptions', 886);
function FixedLayouterOptions$FixedFactory(){
}

defineClass(887, 1, {}, FixedLayouterOptions$FixedFactory);
_.create_0 = function create_38(){
  var provider;
  return provider = new FixedLayoutProvider , provider;
}
;
_.destroy = function destroy_8(obj){
}
;
var Lorg_eclipse_elk_core_options_FixedLayouterOptions$FixedFactory_2_classLit = createForClass('org.eclipse.elk.core.options', 'FixedLayouterOptions/FixedFactory', 887);
function $clinit_HierarchyHandling(){
  $clinit_HierarchyHandling = emptyMethod;
  INHERIT = new HierarchyHandling('INHERIT', 0);
  INCLUDE_CHILDREN = new HierarchyHandling('INCLUDE_CHILDREN', 1);
  SEPARATE_CHILDREN = new HierarchyHandling('SEPARATE_CHILDREN', 2);
}

function HierarchyHandling(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_90(name_0){
  $clinit_HierarchyHandling();
  return valueOf(($clinit_HierarchyHandling$Map() , $MAP_78), name_0);
}

function values_86(){
  $clinit_HierarchyHandling();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_HierarchyHandling_2_classLit, 1), $intern_38, 324, 0, [INHERIT, INCLUDE_CHILDREN, SEPARATE_CHILDREN]);
}

defineClass(324, 22, {3:1, 34:1, 22:1, 324:1}, HierarchyHandling);
var INCLUDE_CHILDREN, INHERIT, SEPARATE_CHILDREN;
var Lorg_eclipse_elk_core_options_HierarchyHandling_2_classLit = createForEnum('org.eclipse.elk.core.options', 'HierarchyHandling', 324, Ljava_lang_Enum_2_classLit, values_86, valueOf_90);
function $clinit_HierarchyHandling$Map(){
  $clinit_HierarchyHandling$Map = emptyMethod;
  $MAP_78 = createValueOfMap(($clinit_HierarchyHandling() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_HierarchyHandling_2_classLit, 1), $intern_38, 324, 0, [INHERIT, INCLUDE_CHILDREN, SEPARATE_CHILDREN])));
}

var $MAP_78;
function $clinit_LabelSide(){
  $clinit_LabelSide = emptyMethod;
  UNKNOWN = new LabelSide('UNKNOWN', 0);
  ABOVE = new LabelSide('ABOVE', 1);
  BELOW = new LabelSide('BELOW', 2);
  INLINE = new LabelSide('INLINE', 3);
  new Property_0('org.eclipse.elk.labelSide', UNKNOWN);
}

function $opposite_1(this$static){
  switch (this$static.ordinal) {
    case 1:
      return BELOW;
    case 2:
      return ABOVE;
    case 3:
      return INLINE;
    default:return UNKNOWN;
  }
}

function LabelSide(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_91(name_0){
  $clinit_LabelSide();
  return valueOf(($clinit_LabelSide$Map() , $MAP_79), name_0);
}

function values_87(){
  $clinit_LabelSide();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_LabelSide_2_classLit, 1), $intern_38, 276, 0, [UNKNOWN, ABOVE, BELOW, INLINE]);
}

defineClass(276, 22, {3:1, 34:1, 22:1, 276:1}, LabelSide);
var ABOVE, BELOW, INLINE, UNKNOWN;
var Lorg_eclipse_elk_core_options_LabelSide_2_classLit = createForEnum('org.eclipse.elk.core.options', 'LabelSide', 276, Ljava_lang_Enum_2_classLit, values_87, valueOf_91);
function $clinit_LabelSide$Map(){
  $clinit_LabelSide$Map = emptyMethod;
  $MAP_79 = createValueOfMap(($clinit_LabelSide() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_LabelSide_2_classLit, 1), $intern_38, 276, 0, [UNKNOWN, ABOVE, BELOW, INLINE])));
}

var $MAP_79;
function $clinit_NodeLabelPlacement(){
  $clinit_NodeLabelPlacement = emptyMethod;
  H_LEFT_0 = new NodeLabelPlacement('H_LEFT', 0);
  H_CENTER_0 = new NodeLabelPlacement('H_CENTER', 1);
  H_RIGHT_0 = new NodeLabelPlacement('H_RIGHT', 2);
  V_TOP_0 = new NodeLabelPlacement('V_TOP', 3);
  V_CENTER_0 = new NodeLabelPlacement('V_CENTER', 4);
  V_BOTTOM_0 = new NodeLabelPlacement('V_BOTTOM', 5);
  INSIDE = new NodeLabelPlacement('INSIDE', 6);
  OUTSIDE = new NodeLabelPlacement('OUTSIDE', 7);
  H_PRIORITY = new NodeLabelPlacement('H_PRIORITY', 8);
}

function NodeLabelPlacement(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_92(name_0){
  $clinit_NodeLabelPlacement();
  return valueOf(($clinit_NodeLabelPlacement$Map() , $MAP_80), name_0);
}

function values_88(){
  $clinit_NodeLabelPlacement();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_LEFT_0, H_CENTER_0, H_RIGHT_0, V_TOP_0, V_CENTER_0, V_BOTTOM_0, INSIDE, OUTSIDE, H_PRIORITY]);
}

defineClass(88, 22, {3:1, 34:1, 22:1, 88:1}, NodeLabelPlacement);
var H_CENTER_0, H_LEFT_0, H_PRIORITY, H_RIGHT_0, INSIDE, OUTSIDE, V_BOTTOM_0, V_CENTER_0, V_TOP_0;
var Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit = createForEnum('org.eclipse.elk.core.options', 'NodeLabelPlacement', 88, Ljava_lang_Enum_2_classLit, values_88, valueOf_92);
function $clinit_NodeLabelPlacement$Map(){
  $clinit_NodeLabelPlacement$Map = emptyMethod;
  $MAP_80 = createValueOfMap(($clinit_NodeLabelPlacement() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_NodeLabelPlacement_2_classLit, 1), $intern_38, 88, 0, [H_LEFT_0, H_CENTER_0, H_RIGHT_0, V_TOP_0, V_CENTER_0, V_BOTTOM_0, INSIDE, OUTSIDE, H_PRIORITY])));
}

var $MAP_80;
function $clinit_PortAlignment(){
  $clinit_PortAlignment = emptyMethod;
  DISTRIBUTED = new PortAlignment('DISTRIBUTED', 0);
  JUSTIFIED = new PortAlignment('JUSTIFIED', 1);
  BEGIN_0 = new PortAlignment('BEGIN', 2);
  CENTER_5 = new PortAlignment('CENTER', 3);
  END_0 = new PortAlignment('END', 4);
}

function PortAlignment(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_93(name_0){
  $clinit_PortAlignment();
  return valueOf(($clinit_PortAlignment$Map() , $MAP_81), name_0);
}

function values_89(){
  $clinit_PortAlignment();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortAlignment_2_classLit, 1), $intern_38, 235, 0, [DISTRIBUTED, JUSTIFIED, BEGIN_0, CENTER_5, END_0]);
}

defineClass(235, 22, {3:1, 34:1, 22:1, 235:1}, PortAlignment);
var BEGIN_0, CENTER_5, DISTRIBUTED, END_0, JUSTIFIED;
var Lorg_eclipse_elk_core_options_PortAlignment_2_classLit = createForEnum('org.eclipse.elk.core.options', 'PortAlignment', 235, Ljava_lang_Enum_2_classLit, values_89, valueOf_93);
function $clinit_PortAlignment$Map(){
  $clinit_PortAlignment$Map = emptyMethod;
  $MAP_81 = createValueOfMap(($clinit_PortAlignment() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortAlignment_2_classLit, 1), $intern_38, 235, 0, [DISTRIBUTED, JUSTIFIED, BEGIN_0, CENTER_5, END_0])));
}

var $MAP_81;
function $clinit_PortConstraints(){
  $clinit_PortConstraints = emptyMethod;
  UNDEFINED_6 = new PortConstraints('UNDEFINED', 0);
  FREE = new PortConstraints('FREE', 1);
  FIXED_SIDE = new PortConstraints('FIXED_SIDE', 2);
  FIXED_ORDER = new PortConstraints('FIXED_ORDER', 3);
  FIXED_RATIO = new PortConstraints('FIXED_RATIO', 4);
  FIXED_POS = new PortConstraints('FIXED_POS', 5);
}

function $isOrderFixed(this$static){
  return this$static == FIXED_ORDER || this$static == FIXED_RATIO || this$static == FIXED_POS;
}

function $isSideFixed(this$static){
  return this$static != FREE && this$static != UNDEFINED_6;
}

function PortConstraints(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_94(name_0){
  $clinit_PortConstraints();
  return valueOf(($clinit_PortConstraints$Map() , $MAP_82), name_0);
}

function values_90(){
  $clinit_PortConstraints();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortConstraints_2_classLit, 1), $intern_38, 83, 0, [UNDEFINED_6, FREE, FIXED_SIDE, FIXED_ORDER, FIXED_RATIO, FIXED_POS]);
}

defineClass(83, 22, {3:1, 34:1, 22:1, 83:1}, PortConstraints);
var FIXED_ORDER, FIXED_POS, FIXED_RATIO, FIXED_SIDE, FREE, UNDEFINED_6;
var Lorg_eclipse_elk_core_options_PortConstraints_2_classLit = createForEnum('org.eclipse.elk.core.options', 'PortConstraints', 83, Ljava_lang_Enum_2_classLit, values_90, valueOf_94);
function $clinit_PortConstraints$Map(){
  $clinit_PortConstraints$Map = emptyMethod;
  $MAP_82 = createValueOfMap(($clinit_PortConstraints() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortConstraints_2_classLit, 1), $intern_38, 83, 0, [UNDEFINED_6, FREE, FIXED_SIDE, FIXED_ORDER, FIXED_RATIO, FIXED_POS])));
}

var $MAP_82;
function $clinit_PortLabelPlacement(){
  $clinit_PortLabelPlacement = emptyMethod;
  OUTSIDE_0 = new PortLabelPlacement('OUTSIDE', 0);
  INSIDE_0 = new PortLabelPlacement('INSIDE', 1);
  FIXED_2 = new PortLabelPlacement('FIXED', 2);
}

function PortLabelPlacement(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_95(name_0){
  $clinit_PortLabelPlacement();
  return valueOf(($clinit_PortLabelPlacement$Map() , $MAP_83), name_0);
}

function values_91(){
  $clinit_PortLabelPlacement();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortLabelPlacement_2_classLit, 1), $intern_38, 284, 0, [OUTSIDE_0, INSIDE_0, FIXED_2]);
}

defineClass(284, 22, {3:1, 34:1, 22:1, 284:1}, PortLabelPlacement);
var FIXED_2, INSIDE_0, OUTSIDE_0;
var Lorg_eclipse_elk_core_options_PortLabelPlacement_2_classLit = createForEnum('org.eclipse.elk.core.options', 'PortLabelPlacement', 284, Ljava_lang_Enum_2_classLit, values_91, valueOf_95);
function $clinit_PortLabelPlacement$Map(){
  $clinit_PortLabelPlacement$Map = emptyMethod;
  $MAP_83 = createValueOfMap(($clinit_PortLabelPlacement() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortLabelPlacement_2_classLit, 1), $intern_38, 284, 0, [OUTSIDE_0, INSIDE_0, FIXED_2])));
}

var $MAP_83;
function $clinit_PortSide(){
  $clinit_PortSide = emptyMethod;
  var all;
  UNDEFINED_7 = new PortSide('UNDEFINED', 0);
  NORTH_1 = new PortSide('NORTH', 1);
  EAST_1 = new PortSide('EAST', 2);
  SOUTH_1 = new PortSide('SOUTH', 3);
  WEST_1 = new PortSide('WEST', 4);
  SIDES_NONE = ($clinit_Collections() , new Collections$UnmodifiableSet((all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_PortSide_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0))));
  SIDES_NORTH = asImmutable(of_1(NORTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [])));
  SIDES_EAST = asImmutable(of_1(EAST_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [])));
  SIDES_SOUTH = asImmutable(of_1(SOUTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [])));
  SIDES_WEST = asImmutable(of_1(WEST_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [])));
  SIDES_NORTH_SOUTH = asImmutable(of_1(NORTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [SOUTH_1])));
  SIDES_EAST_WEST = asImmutable(of_1(EAST_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [WEST_1])));
  SIDES_NORTH_WEST = asImmutable(of_1(NORTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [WEST_1])));
  SIDES_NORTH_EAST = asImmutable(of_1(NORTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [EAST_1])));
  SIDES_SOUTH_WEST = asImmutable(of_1(SOUTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [WEST_1])));
  SIDES_EAST_SOUTH = asImmutable(of_1(EAST_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [SOUTH_1])));
  SIDES_NORTH_EAST_WEST = asImmutable(of_1(NORTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [EAST_1, WEST_1])));
  SIDES_EAST_SOUTH_WEST = asImmutable(of_1(EAST_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [SOUTH_1, WEST_1])));
  SIDES_NORTH_SOUTH_WEST = asImmutable(of_1(NORTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [SOUTH_1, WEST_1])));
  SIDES_NORTH_EAST_SOUTH = asImmutable(of_1(NORTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [EAST_1, SOUTH_1])));
  SIDES_NORTH_EAST_SOUTH_WEST = asImmutable(of_1(NORTH_1, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [EAST_1, SOUTH_1, WEST_1])));
}

function $opposed(this$static){
  switch (this$static.ordinal) {
    case 1:
      return SOUTH_1;
    case 2:
      return WEST_1;
    case 3:
      return NORTH_1;
    case 4:
      return EAST_1;
    default:return UNDEFINED_7;
  }
}

function PortSide(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function fromDirection(direction){
  $clinit_PortSide();
  switch (direction.ordinal) {
    case 4:
      return NORTH_1;
    case 1:
      return EAST_1;
    case 3:
      return SOUTH_1;
    case 2:
      return WEST_1;
    default:return UNDEFINED_7;
  }
}

function valueOf_96(name_0){
  $clinit_PortSide();
  return valueOf(($clinit_PortSide$Map() , $MAP_84), name_0);
}

function values_92(){
  $clinit_PortSide();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [UNDEFINED_7, NORTH_1, EAST_1, SOUTH_1, WEST_1]);
}

defineClass(71, 22, {3:1, 34:1, 22:1, 71:1}, PortSide);
var EAST_1, NORTH_1, SIDES_EAST, SIDES_EAST_SOUTH, SIDES_EAST_SOUTH_WEST, SIDES_EAST_WEST, SIDES_NONE, SIDES_NORTH, SIDES_NORTH_EAST, SIDES_NORTH_EAST_SOUTH, SIDES_NORTH_EAST_SOUTH_WEST, SIDES_NORTH_EAST_WEST, SIDES_NORTH_SOUTH, SIDES_NORTH_SOUTH_WEST, SIDES_NORTH_WEST, SIDES_SOUTH, SIDES_SOUTH_WEST, SIDES_WEST, SOUTH_1, UNDEFINED_7, WEST_1;
var Lorg_eclipse_elk_core_options_PortSide_2_classLit = createForEnum('org.eclipse.elk.core.options', 'PortSide', 71, Ljava_lang_Enum_2_classLit, values_92, valueOf_96);
function $clinit_PortSide$Map(){
  $clinit_PortSide$Map = emptyMethod;
  $MAP_84 = createValueOfMap(($clinit_PortSide() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_PortSide_2_classLit, 1), $intern_38, 71, 0, [UNDEFINED_7, NORTH_1, EAST_1, SOUTH_1, WEST_1])));
}

var $MAP_84;
function $clinit_RandomLayouterOptions(){
  $clinit_RandomLayouterOptions = emptyMethod;
  PADDING_DEFAULT_7 = new ElkPadding_0(15);
  PADDING_7 = new Property_2(($clinit_CoreOptions() , PADDING_5), PADDING_DEFAULT_7);
  SPACING_NODE_NODE_6 = new Property_2(SPACING_NODE_NODE_5, 15);
  RANDOM_SEED_2 = new Property_2(RANDOM_SEED_1, valueOf_4(0));
  ASPECT_RATIO_5 = new Property_2(ASPECT_RATIO_4, $intern_105);
}

function $apply_30(registry){
  $register(registry, new LayoutAlgorithmData($providerFactory($description($name($id(new LayoutAlgorithmData$Builder, 'org.eclipse.elk.random'), 'Randomizer'), 'Distributes the nodes randomly on the plane, leading to very obfuscating layouts. Can be useful to demonstrate the power of "real" layout algorithms.'), new RandomLayouterOptions$RandomFactory)));
  $addOptionSupport(registry, 'org.eclipse.elk.random', 'org.eclipse.elk.padding', PADDING_DEFAULT_7);
  $addOptionSupport(registry, 'org.eclipse.elk.random', 'org.eclipse.elk.spacing.nodeNode', 15);
  $addOptionSupport(registry, 'org.eclipse.elk.random', 'org.eclipse.elk.randomSeed', valueOf_4(0));
  $addOptionSupport(registry, 'org.eclipse.elk.random', 'org.eclipse.elk.aspectRatio', $intern_105);
}

function RandomLayouterOptions(){
  $clinit_RandomLayouterOptions();
}

defineClass(890, 1, $intern_92, RandomLayouterOptions);
_.apply_3 = function apply_145(registry){
  $apply_30(registry);
}
;
var ASPECT_RATIO_5, PADDING_7, PADDING_DEFAULT_7, RANDOM_SEED_2, SPACING_NODE_NODE_6;
var Lorg_eclipse_elk_core_options_RandomLayouterOptions_2_classLit = createForClass('org.eclipse.elk.core.options', 'RandomLayouterOptions', 890);
function RandomLayouterOptions$RandomFactory(){
}

defineClass(891, 1, {}, RandomLayouterOptions$RandomFactory);
_.create_0 = function create_39(){
  var provider;
  return provider = new RandomLayoutProvider , provider;
}
;
_.destroy = function destroy_9(obj){
}
;
var Lorg_eclipse_elk_core_options_RandomLayouterOptions$RandomFactory_2_classLit = createForClass('org.eclipse.elk.core.options', 'RandomLayouterOptions/RandomFactory', 891);
function $clinit_SizeConstraint(){
  $clinit_SizeConstraint = emptyMethod;
  PORTS_0 = new SizeConstraint('PORTS', 0);
  PORT_LABELS = new SizeConstraint('PORT_LABELS', 1);
  NODE_LABELS = new SizeConstraint('NODE_LABELS', 2);
  MINIMUM_SIZE = new SizeConstraint('MINIMUM_SIZE', 3);
}

function SizeConstraint(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_97(name_0){
  $clinit_SizeConstraint();
  return valueOf(($clinit_SizeConstraint$Map() , $MAP_85), name_0);
}

function values_93(){
  $clinit_SizeConstraint();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_SizeConstraint_2_classLit, 1), $intern_38, 357, 0, [PORTS_0, PORT_LABELS, NODE_LABELS, MINIMUM_SIZE]);
}

defineClass(357, 22, {3:1, 34:1, 22:1, 357:1}, SizeConstraint);
var MINIMUM_SIZE, NODE_LABELS, PORTS_0, PORT_LABELS;
var Lorg_eclipse_elk_core_options_SizeConstraint_2_classLit = createForEnum('org.eclipse.elk.core.options', 'SizeConstraint', 357, Ljava_lang_Enum_2_classLit, values_93, valueOf_97);
function $clinit_SizeConstraint$Map(){
  $clinit_SizeConstraint$Map = emptyMethod;
  $MAP_85 = createValueOfMap(($clinit_SizeConstraint() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_SizeConstraint_2_classLit, 1), $intern_38, 357, 0, [PORTS_0, PORT_LABELS, NODE_LABELS, MINIMUM_SIZE])));
}

var $MAP_85;
function $clinit_SizeOptions(){
  $clinit_SizeOptions = emptyMethod;
  DEFAULT_MINIMUM_SIZE = new SizeOptions('DEFAULT_MINIMUM_SIZE', 0);
  MINIMUM_SIZE_ACCOUNTS_FOR_PADDING = new SizeOptions('MINIMUM_SIZE_ACCOUNTS_FOR_PADDING', 1);
  COMPUTE_PADDING = new SizeOptions('COMPUTE_PADDING', 2);
  OUTSIDE_NODE_LABELS_OVERHANG = new SizeOptions('OUTSIDE_NODE_LABELS_OVERHANG', 3);
  PORTS_OVERHANG = new SizeOptions('PORTS_OVERHANG', 4);
  UNIFORM_PORT_SPACING = new SizeOptions('UNIFORM_PORT_SPACING', 5);
  SPACE_EFFICIENT_PORT_LABELS = new SizeOptions('SPACE_EFFICIENT_PORT_LABELS', 6);
  FORCE_TABULAR_NODE_LABELS = new SizeOptions('FORCE_TABULAR_NODE_LABELS', 7);
  ASYMMETRICAL = new SizeOptions('ASYMMETRICAL', 8);
}

function SizeOptions(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_98(name_0){
  $clinit_SizeOptions();
  return valueOf(($clinit_SizeOptions$Map() , $MAP_86), name_0);
}

function values_94(){
  $clinit_SizeOptions();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_SizeOptions_2_classLit, 1), $intern_38, 250, 0, [DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]);
}

defineClass(250, 22, {3:1, 34:1, 22:1, 250:1}, SizeOptions);
var ASYMMETRICAL, COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING;
var Lorg_eclipse_elk_core_options_SizeOptions_2_classLit = createForEnum('org.eclipse.elk.core.options', 'SizeOptions', 250, Ljava_lang_Enum_2_classLit, values_94, valueOf_98);
function $clinit_SizeOptions$Map(){
  $clinit_SizeOptions$Map = emptyMethod;
  $MAP_86 = createValueOfMap(($clinit_SizeOptions() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_options_SizeOptions_2_classLit, 1), $intern_38, 250, 0, [DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL])));
}

var $MAP_86;
function $$init_9(this$static){
  this$static.children = new LinkedList;
}

function $begin(this$static, name_0, thetotalWork){
  if (this$static.closed_0) {
    throw toJs(new IllegalStateException_0('The task is already done.'));
  }
   else if (this$static.taskName != null) {
    return false;
  }
   else {
    this$static.taskName = name_0;
    this$static.totalWork = thetotalWork;
    return true;
  }
}

function $doSubTask(maxHierarchyLevels, measureExecTime){
  return maxHierarchyLevels > 0?new BasicProgressMonitor_1(maxHierarchyLevels - 1, measureExecTime):new BasicProgressMonitor_1(maxHierarchyLevels, measureExecTime);
}

function $done_0(this$static){
  if (this$static.taskName == null) {
    throw toJs(new IllegalStateException_0('The task has not begun yet.'));
  }
  if (!this$static.closed_0) {
    this$static.completedWork < this$static.totalWork && $internalWorked(this$static, this$static.totalWork - this$static.completedWork);
    this$static.closed_0 = true;
  }
}

function $internalWorked(this$static, work){
  if (this$static.totalWork > 0 && this$static.completedWork < this$static.totalWork) {
    this$static.completedWork += work;
    !!this$static.parentMonitor && this$static.parentMonitor.currentChildWork > 0 && this$static.maxLevels != 0 && $internalWorked(this$static.parentMonitor, work / this$static.totalWork * this$static.parentMonitor.currentChildWork);
  }
}

function $subTask(this$static, work){
  var subMonitor;
  if (this$static.closed_0) {
    return null;
  }
   else {
    subMonitor = $doSubTask(this$static.maxLevels, this$static.measureExecutionTime);
    $add_7(this$static.children, subMonitor);
    subMonitor.parentMonitor = this$static;
    this$static.currentChildWork = work;
    return subMonitor;
  }
}

function BasicProgressMonitor(){
  $$init_9(this);
  this.maxLevels = -1;
  this.measureExecutionTime = true;
}

function BasicProgressMonitor_0(){
  $$init_9(this);
  this.maxLevels = 0;
  this.measureExecutionTime = true;
}

function BasicProgressMonitor_1(maxLevels, measureExecutionTime){
  $$init_9(this);
  this.maxLevels = maxLevels;
  this.measureExecutionTime = measureExecutionTime;
}

defineClass(321, 1, {}, BasicProgressMonitor, BasicProgressMonitor_0, BasicProgressMonitor_1);
_.closed_0 = false;
_.completedWork = 0;
_.currentChildWork = -1;
_.maxLevels = 0;
_.measureExecutionTime = false;
_.totalWork = 0;
var Lorg_eclipse_elk_core_util_BasicProgressMonitor_2_classLit = createForClass('org.eclipse.elk.core.util', 'BasicProgressMonitor', 321);
function $areaStdDev(boxes, mean){
  var box, box$iterator, stddev, variance;
  variance = 0;
  for (box$iterator = $listIterator_1(boxes, 0); box$iterator.currentNode != box$iterator.this$01.tail;) {
    box = castTo($next_13(box$iterator), 35);
    variance += $wnd.Math.pow(box.width_0 * box.height - mean, 2);
  }
  stddev = $wnd.Math.sqrt(variance / (boxes.size_0 - 1));
  return stddev;
}

function $areaStdDev2(boxes, mean){
  var box, box$iterator, stddev, variance;
  variance = 0;
  for (box$iterator = new ArrayList$1(boxes); box$iterator.i < box$iterator.this$01.array.length;) {
    box = castTo($next_10(box$iterator), 148);
    variance += $wnd.Math.pow($getWidth(box) * $getHeight(box) - mean, 2);
  }
  stddev = $wnd.Math.sqrt(variance / (boxes.array.length - 1));
  return stddev;
}

function $mergeAndPlaceDec(groups, objSpacing, minWidth, minHeight, expandNodes){
  var box, boxQueue, boxToBeat, collectedArea, groupSize, innerAspectRatio, innerGroup, maybeGroup, toBePlaced;
  $clinit_Collections();
  $sort_0(groups, new BoxLayoutProvider$lambda$0$Type);
  boxQueue = newLinkedList(groups);
  toBePlaced = new ArrayList;
  maybeGroup = new ArrayList;
  boxToBeat = null;
  collectedArea = 0;
  while (boxQueue.size_0 != 0) {
    box = castTo(boxQueue.size_0 == 0?null:(checkCriticalElement(boxQueue.size_0 != 0) , $removeNode_0(boxQueue, boxQueue.header.next_0)), 148);
    if (!boxToBeat || $getWidth(boxToBeat) * $getHeight(boxToBeat) / 2 < $getWidth(box) * $getHeight(box)) {
      boxToBeat = box;
      toBePlaced.array[toBePlaced.array.length] = box;
    }
     else {
      collectedArea += $getWidth(box) * $getHeight(box);
      maybeGroup.array[maybeGroup.array.length] = box;
      if (maybeGroup.array.length > 1 && (collectedArea > $getWidth(boxToBeat) * $getHeight(boxToBeat) / 2 || boxQueue.size_0 == 0)) {
        innerGroup = new BoxLayoutProvider$Group(maybeGroup);
        innerAspectRatio = $getWidth(boxToBeat) / $getHeight(boxToBeat);
        groupSize = $placeInnerBoxes(innerGroup, objSpacing, new ElkPadding, minWidth, minHeight, expandNodes, innerAspectRatio);
        $add_19($reset_5(innerGroup.size_0), groupSize);
        boxToBeat = innerGroup;
        toBePlaced.array[toBePlaced.array.length] = innerGroup;
        collectedArea = 0;
        maybeGroup.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      }
    }
  }
  $addAll_2(toBePlaced, maybeGroup);
  return toBePlaced;
}

function $mergeAndPlaceInc(groups, objSpacing, minWidth, minHeight, expandNodes){
  var commonArea, g, groupIterator, groupSize, innerAspectRatio, merged, toBePlaced;
  $clinit_Collections();
  $sort_0(groups, new BoxLayoutProvider$lambda$2$Type);
  groupIterator = $listIterator_1(groups, 0);
  toBePlaced = new ArrayList;
  commonArea = 0;
  while (groupIterator.currentNode != groupIterator.this$01.tail) {
    g = castTo($next_13(groupIterator), 148);
    if (toBePlaced.array.length != 0 && $getWidth(g) * $getHeight(g) > commonArea * 2) {
      merged = new BoxLayoutProvider$Group(toBePlaced);
      innerAspectRatio = $getWidth(g) / $getHeight(g);
      groupSize = $placeInnerBoxes(merged, objSpacing, new ElkPadding, minWidth, minHeight, expandNodes, innerAspectRatio);
      $add_19($reset_5(merged.size_0), groupSize);
      toBePlaced.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      toBePlaced.array[toBePlaced.array.length] = merged;
      toBePlaced.array[toBePlaced.array.length] = g;
      commonArea = $getWidth(merged) * $getHeight(merged) + $getWidth(g) * $getHeight(g);
    }
     else {
      toBePlaced.array[toBePlaced.array.length] = g;
      commonArea += $getWidth(g) * $getHeight(g);
    }
  }
  return toBePlaced;
}

function $mergeAndPlaceMixed(groups, objSpacing, minWidth, minHeight, expandNodes){
  var anIndex, box, cumAreaArray, groupSize, index_0, innerAspectRatio, innerGroup, pq, remain, select, toBePlaced, value_0;
  cumAreaArray = initUnidimensionalArray(D_classLit, $intern_69, 23, groups.size_0, 15, 1);
  pq = new PriorityQueue(new BoxLayoutProvider$lambda$1$Type);
  $addAll_3(pq, groups);
  index_0 = 0;
  toBePlaced = new ArrayList;
  while (pq.heap.array.length != 0) {
    box = castTo(pq.heap.array.length == 0?null:$get_7(pq.heap, 0), 148);
    if (index_0 > 1 && $getWidth(box) * $getHeight(box) / 2 > cumAreaArray[0]) {
      anIndex = 0;
      while (anIndex < toBePlaced.array.length - 1 && $getWidth(box) * $getHeight(box) / 2 > cumAreaArray[anIndex]) {
        ++anIndex;
      }
      select = new AbstractList$SubList(toBePlaced, 0, anIndex + 1);
      innerGroup = new BoxLayoutProvider$Group(select);
      innerAspectRatio = $getWidth(box) / $getHeight(box);
      groupSize = $placeInnerBoxes(innerGroup, objSpacing, new ElkPadding, minWidth, minHeight, expandNodes, innerAspectRatio);
      $add_19($reset_5(innerGroup.size_0), groupSize);
      checkCriticalState_0($offer(pq, innerGroup));
      remain = new AbstractList$SubList(toBePlaced, anIndex + 1, toBePlaced.array.length);
      $addAll_3(pq, remain);
      toBePlaced.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      index_0 = 0;
      fill0_0(cumAreaArray, cumAreaArray.length, 0);
    }
     else {
      value_0 = pq.heap.array.length == 0?null:$get_7(pq.heap, 0);
      value_0 != null && $removeAtIndex_0(pq, 0);
      index_0 > 0 && (cumAreaArray[index_0] = cumAreaArray[index_0 - 1]);
      cumAreaArray[index_0] += $getWidth(box) * $getHeight(box);
      ++index_0;
      toBePlaced.array[toBePlaced.array.length] = box;
    }
  }
  return toBePlaced;
}

function $placeBoxes(sortedBoxes, minSpacing, padding, minTotalWidth, minTotalHeight, expandNodes, aspectRatio){
  var box, box$iterator, boxIter, broadestRow, height, highestBox, maxRowWidth, mean, newWidth, nextRowIndex, oldWidth, rowHeight, rowHeightIter, rowHeights, rowIndexIter, rowIndices, stddev, totalArea, totalHeight, width_0, xpos, ypos;
  maxRowWidth = 0;
  totalArea = 0;
  for (box$iterator = $listIterator_1(sortedBoxes, 0); box$iterator.currentNode != box$iterator.this$01.tail;) {
    box = castTo($next_13(box$iterator), 35);
    resizeNode_0(box);
    maxRowWidth = $wnd.Math.max(maxRowWidth, box.width_0);
    totalArea += box.width_0 * box.height;
  }
  mean = totalArea / sortedBoxes.size_0;
  stddev = $areaStdDev(sortedBoxes, mean);
  totalArea += sortedBoxes.size_0 * stddev;
  maxRowWidth = $wnd.Math.max(maxRowWidth, $wnd.Math.sqrt(totalArea * aspectRatio)) + padding.left;
  xpos = padding.left;
  ypos = padding.top_0;
  highestBox = 0;
  broadestRow = padding.left + padding.right;
  rowIndices = new LinkedList;
  $add_7(rowIndices, valueOf_4(0));
  rowHeights = new LinkedList;
  boxIter = $listIterator_1(sortedBoxes, 0);
  while (boxIter.currentNode != boxIter.this$01.tail) {
    box = castTo($next_13(boxIter), 35);
    width_0 = box.width_0;
    height = box.height;
    if (xpos + width_0 > maxRowWidth) {
      if (expandNodes) {
        $addLast_0(rowHeights, highestBox);
        $addLast_0(rowIndices, valueOf_4(boxIter.currentIndex - 1));
      }
      xpos = padding.left;
      ypos += highestBox + minSpacing;
      highestBox = 0;
      broadestRow = $wnd.Math.max(broadestRow, padding.left + padding.right + width_0);
    }
    $setX_1(box, xpos);
    $setY_1(box, ypos);
    broadestRow = $wnd.Math.max(broadestRow, xpos + width_0 + padding.right);
    highestBox = $wnd.Math.max(highestBox, height);
    xpos += width_0 + minSpacing;
  }
  broadestRow = $wnd.Math.max(broadestRow, minTotalWidth);
  totalHeight = ypos + highestBox + padding.bottom;
  if (totalHeight < minTotalHeight) {
    highestBox += minTotalHeight - totalHeight;
    totalHeight = minTotalHeight;
  }
  if (expandNodes) {
    xpos = padding.left;
    boxIter = $listIterator_1(sortedBoxes, 0);
    $addLast_0(rowIndices, valueOf_4(sortedBoxes.size_0));
    rowIndexIter = $listIterator_1(rowIndices, 0);
    nextRowIndex = castTo($next_13(rowIndexIter), 21).value_0;
    $addLast_0(rowHeights, highestBox);
    rowHeightIter = $listIterator_1(rowHeights, 0);
    rowHeight = 0;
    while (boxIter.currentNode != boxIter.this$01.tail) {
      if (boxIter.currentIndex == nextRowIndex) {
        xpos = padding.left;
        rowHeight = checkNotNull_1(castToDouble($next_13(rowHeightIter)));
        nextRowIndex = castTo($next_13(rowIndexIter), 21).value_0;
      }
      box = castTo($next_13(boxIter), 35);
      $setHeight_0(box, rowHeight);
      if (boxIter.currentIndex == nextRowIndex) {
        newWidth = broadestRow - xpos - padding.right;
        oldWidth = box.width_0;
        $setWidth_0(box, newWidth);
        translate_0(box, (newWidth - oldWidth) / 2, 0);
      }
      xpos += box.width_0 + minSpacing;
    }
  }
  return new KVector_1(broadestRow, totalHeight);
}

function $placeBoxesGrouping(parentNode, objSpacing, padding, expandNodes){
  var aspectRatio, finalGroup, g, groups, minSize, mode, node, node$iterator, parentSize, toBePlaced;
  minSize = castTo($getProperty_0(parentNode, ($clinit_BoxLayouterOptions() , NODE_SIZE_MINIMUM_0)), 8);
  minSize.x_0 = $wnd.Math.max(minSize.x_0 - padding.left - padding.right, 0);
  minSize.y_0 = $wnd.Math.max(minSize.y_0 - padding.top_0 - padding.bottom, 0);
  aspectRatio = castToDouble($getProperty_0(parentNode, ASPECT_RATIO_3));
  (aspectRatio == null || (checkCriticalNotNull(aspectRatio) , aspectRatio) <= 0) && (aspectRatio = 1.3);
  groups = new LinkedList;
  for (node$iterator = new AbstractEList$EIterator((!parentNode.children && (parentNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parentNode, 10, 11)) , parentNode.children)); node$iterator.cursor != node$iterator.this$01_2.size_1();) {
    node = castTo($doNext(node$iterator), 35);
    g = new BoxLayoutProvider$Group_0(node);
    $addNode_0(groups, g, groups.tail.prev, groups.tail);
  }
  mode = castTo($getProperty_0(parentNode, BOX_PACKING_MODE), 297);
  switch (mode.ordinal) {
    case 3:
      toBePlaced = $mergeAndPlaceInc(groups, objSpacing, minSize.x_0, minSize.y_0, (checkCriticalNotNull(aspectRatio) , aspectRatio , expandNodes));
      break;
    case 1:
      toBePlaced = $mergeAndPlaceDec(groups, objSpacing, minSize.x_0, minSize.y_0, (checkCriticalNotNull(aspectRatio) , aspectRatio , expandNodes));
      break;
    default:toBePlaced = $mergeAndPlaceMixed(groups, objSpacing, minSize.x_0, minSize.y_0, (checkCriticalNotNull(aspectRatio) , aspectRatio , expandNodes));
  }
  finalGroup = new BoxLayoutProvider$Group(toBePlaced);
  parentSize = $placeInnerBoxes(finalGroup, objSpacing, padding, minSize.x_0, minSize.y_0, expandNodes, (checkCriticalNotNull(aspectRatio) , aspectRatio));
  resizeNode_1(parentNode, parentSize.x_0, parentSize.y_0, false, true);
}

function $placeInnerBoxes(group, minSpacing, padding, minTotalWidth, minTotalHeight, expandNodes, aspectRatio){
  var bottoms, box, box$iterator, boxIter, broadestRow, height, highestBox, last, maxRowWidth, mean, newWidth, nextRowIndex, oldWidth, rowHeight, rowHeightIter, rowHeights, rowIndexIter, rowIndices, stddev, totalArea, totalHeight, width_0, xpos, ypos;
  maxRowWidth = 0;
  totalArea = 0;
  for (box$iterator = new ArrayList$1(group.groups); box$iterator.i < box$iterator.this$01.array.length;) {
    box = castTo($next_10(box$iterator), 148);
    !!box.node && resizeNode_0(box.node);
    maxRowWidth = $wnd.Math.max(maxRowWidth, $getWidth(box));
    totalArea += $getWidth(box) * $getHeight(box);
  }
  mean = totalArea / group.groups.array.length;
  stddev = $areaStdDev2(group.groups, mean);
  totalArea += group.groups.array.length * stddev;
  maxRowWidth = $wnd.Math.max(maxRowWidth, $wnd.Math.sqrt(totalArea * aspectRatio)) + padding.left;
  xpos = padding.left;
  ypos = padding.top_0;
  highestBox = 0;
  broadestRow = padding.left + padding.right;
  rowIndices = new LinkedList;
  $add_7(rowIndices, valueOf_4(0));
  rowHeights = new LinkedList;
  boxIter = new AbstractList$ListIteratorImpl(group.groups, 0);
  last = null;
  bottoms = new ArrayList;
  while (boxIter.i < boxIter.this$01_0.size_1()) {
    box = (checkCriticalElement(boxIter.i < boxIter.this$01_0.size_1()) , castTo(boxIter.this$01_0.get_3(boxIter.last = boxIter.i++), 148));
    width_0 = $getWidth(box);
    height = $getHeight(box);
    if (xpos + width_0 > maxRowWidth) {
      if (expandNodes) {
        $addLast_0(rowHeights, highestBox);
        $addLast_0(rowIndices, valueOf_4(boxIter.i - 1));
        $add_4(group.right, last);
        bottoms.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
      }
      xpos = padding.left;
      ypos += highestBox + minSpacing;
      highestBox = 0;
      broadestRow = $wnd.Math.max(broadestRow, padding.left + padding.right + width_0);
    }
    bottoms.array[bottoms.array.length] = box;
    $translate_1(box, xpos, ypos);
    broadestRow = $wnd.Math.max(broadestRow, xpos + width_0 + padding.right);
    highestBox = $wnd.Math.max(highestBox, height);
    xpos += width_0 + minSpacing;
    last = box;
  }
  $addAll_2(group.bottom, bottoms);
  $add_4(group.right, castTo($get_7(bottoms, bottoms.array.length - 1), 148));
  broadestRow = $wnd.Math.max(broadestRow, minTotalWidth);
  totalHeight = ypos + highestBox + padding.bottom;
  if (totalHeight < minTotalHeight) {
    highestBox += minTotalHeight - totalHeight;
    totalHeight = minTotalHeight;
  }
  if (expandNodes) {
    xpos = padding.left;
    boxIter = new AbstractList$ListIteratorImpl(group.groups, 0);
    $addLast_0(rowIndices, valueOf_4(group.groups.array.length));
    rowIndexIter = $listIterator_1(rowIndices, 0);
    nextRowIndex = castTo($next_13(rowIndexIter), 21).value_0;
    $addLast_0(rowHeights, highestBox);
    rowHeightIter = $listIterator_1(rowHeights, 0);
    rowHeight = 0;
    while (boxIter.i < boxIter.this$01_0.size_1()) {
      if (boxIter.i == nextRowIndex) {
        xpos = padding.left;
        rowHeight = checkNotNull_1(castToDouble($next_13(rowHeightIter)));
        nextRowIndex = castTo($next_13(rowIndexIter), 21).value_0;
      }
      box = (checkCriticalElement(boxIter.i < boxIter.this$01_0.size_1()) , castTo(boxIter.this$01_0.get_3(boxIter.last = boxIter.i++), 148));
      $setHeight(box, rowHeight);
      if (boxIter.i == nextRowIndex) {
        newWidth = broadestRow - xpos - padding.right;
        oldWidth = $getWidth(box);
        $setWidth(box, newWidth);
        $translateInnerNodes(box, (newWidth - oldWidth) / 2, 0);
      }
      xpos += $getWidth(box) + minSpacing;
    }
  }
  return new KVector_1(broadestRow, totalHeight);
}

function BoxLayoutProvider(){
}

defineClass(881, 197, $intern_100, BoxLayoutProvider);
_.layout = function layout_7(layoutNode, progressMonitor){
  var expandNodes, interactive, mode, objSpacing, padding, sortedBoxes, sortedBoxes_0, minSize, aspectRatio, parentSize;
  $begin(progressMonitor, 'Box layout', 2);
  objSpacing = checkNotNull_1(castToDouble($getProperty_0(layoutNode, ($clinit_BoxLayouterOptions() , SPACING_NODE_NODE_4))));
  padding = castTo($getProperty_0(layoutNode, PADDING_4), 116);
  expandNodes = checkNotNull_1(castToBoolean($getProperty_0(layoutNode, EXPAND_NODES)));
  interactive = checkNotNull_1(castToBoolean($getProperty_0(layoutNode, INTERACTIVE_5)));
  mode = castTo($getProperty_0(layoutNode, BOX_PACKING_MODE), 297);
  switch (mode.ordinal) {
    case 0:
      sortedBoxes = (sortedBoxes_0 = new LinkedList_0((!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children)) , $clinit_Collections() , $sort_0(sortedBoxes_0, new BoxLayoutProvider$1(interactive)) , sortedBoxes_0);
      minSize = castTo($getProperty_0(layoutNode, NODE_SIZE_MINIMUM_0), 8);
      minSize.x_0 = $wnd.Math.max(minSize.x_0 - padding.left - padding.right, 0);
      minSize.y_0 = $wnd.Math.max(minSize.y_0 - padding.top_0 - padding.bottom, 0);
      aspectRatio = castToDouble($getProperty_0(layoutNode, ASPECT_RATIO_3));
      (aspectRatio == null || (checkCriticalNotNull(aspectRatio) , aspectRatio) <= 0) && (aspectRatio = 1.3);
      parentSize = $placeBoxes(sortedBoxes, objSpacing, padding, minSize.x_0, minSize.y_0, expandNodes, (checkCriticalNotNull(aspectRatio) , aspectRatio));
      resizeNode_1(layoutNode, parentSize.x_0, parentSize.y_0, false, true);
      break;
    default:$placeBoxesGrouping(layoutNode, objSpacing, padding, expandNodes);
  }
  $done_0(progressMonitor);
}
;
var Lorg_eclipse_elk_core_util_BoxLayoutProvider_2_classLit = createForClass('org.eclipse.elk.core.util', 'BoxLayoutProvider', 881);
function $compare_23(this$static, child1, child2){
  var c, prio1, prio2, size1, size2;
  prio1 = castTo($getProperty_0(child1, ($clinit_BoxLayouterOptions() , PRIORITY_2)), 21);
  !prio1 && (prio1 = valueOf_4(0));
  prio2 = castTo($getProperty_0(child2, PRIORITY_2), 21);
  !prio2 && (prio2 = valueOf_4(0));
  if (prio1.value_0 > prio2.value_0) {
    return -1;
  }
   else if (prio1.value_0 < prio2.value_0) {
    return 1;
  }
   else {
    if (this$static.val$interactive2) {
      c = compare_5(child1.y_0, child2.y_0);
      if (c != 0) {
        return c;
      }
      c = compare_5(child1.x_0, child2.x_0);
      if (c != 0) {
        return c;
      }
    }
    size1 = child1.width_0 * child1.height;
    size2 = child2.width_0 * child2.height;
    return compare_5(size1, size2);
  }
}

function BoxLayoutProvider$1(val$interactive){
  this.val$interactive2 = val$interactive;
}

defineClass(882, 1, $intern_40, BoxLayoutProvider$1);
_.compare_0 = function compare_71(child1, child2){
  return $compare_23(this, castTo(child1, 35), castTo(child2, 35));
}
;
_.equals_0 = function equals_169(other){
  return this === other;
}
;
_.reversed = function reversed_63(){
  return new Comparators$ReversedComparator(this);
}
;
_.val$interactive2 = false;
var Lorg_eclipse_elk_core_util_BoxLayoutProvider$1_2_classLit = createForClass('org.eclipse.elk.core.util', 'BoxLayoutProvider/1', 882);
function $area(this$static){
  return $getWidth(this$static) * $getHeight(this$static);
}

function $getHeight(this$static){
  if (this$static.node) {
    return this$static.node.height;
  }
  return this$static.size_0.y_0;
}

function $getWidth(this$static){
  if (this$static.node) {
    return this$static.node.width_0;
  }
  return this$static.size_0.x_0;
}

function $setHeight(this$static, h){
  var delta, g, g$iterator;
  if (this$static.node) {
    $setHeight_0(this$static.node, h);
  }
   else {
    delta = h - $getHeight(this$static);
    for (g$iterator = new ArrayList$1(this$static.bottom); g$iterator.i < g$iterator.this$01.array.length;) {
      g = castTo($next_10(g$iterator), 148);
      $setHeight(g, $getHeight(g) + delta);
    }
  }
}

function $setWidth(this$static, w){
  var delta, g, g$iterator;
  if (this$static.node) {
    $setWidth_0(this$static.node, w);
  }
   else {
    delta = w - $getWidth(this$static);
    for (g$iterator = new ArrayList$1(this$static.right); g$iterator.i < g$iterator.this$01.array.length;) {
      g = castTo($next_10(g$iterator), 148);
      $setWidth(g, $getWidth(g) + delta);
    }
  }
}

function $translate_1(this$static, x_0, y_0){
  var g, g$iterator;
  if (this$static.node) {
    $setX_1(this$static.node, this$static.node.x_0 + x_0);
    $setY_1(this$static.node, this$static.node.y_0 + y_0);
  }
   else {
    for (g$iterator = new ArrayList$1(this$static.groups); g$iterator.i < g$iterator.this$01.array.length;) {
      g = castTo($next_10(g$iterator), 148);
      $translate_1(g, x_0, y_0);
    }
  }
}

function $translateInnerNodes(this$static, x_0, y_0){
  var g, g$iterator;
  if (this$static.node) {
    translate_0(this$static.node, x_0, y_0);
  }
   else {
    for (g$iterator = new ArrayList$1(this$static.groups); g$iterator.i < g$iterator.this$01.array.length;) {
      g = castTo($next_10(g$iterator), 148);
      $translateInnerNodes(g, x_0, y_0);
    }
  }
}

function BoxLayoutProvider$Group(groups){
  this.groups = (checkNotNull(groups) , new ArrayList_1(($clinit_Collections2() , groups)));
  this.bottom = new ArrayList;
  this.right = new ArrayList;
  this.size_0 = new KVector;
}

function BoxLayoutProvider$Group_0(node){
  this.node = node;
  $setX_1(node, 0);
  $setY_1(node, 0);
}

defineClass(148, 1, {148:1}, BoxLayoutProvider$Group, BoxLayoutProvider$Group_0);
_.toString_0 = function toString_117(){
  return this.node?$toString_19(this.node):$toString_1(this.groups);
}
;
var Lorg_eclipse_elk_core_util_BoxLayoutProvider$Group_2_classLit = createForClass('org.eclipse.elk.core.util', 'BoxLayoutProvider/Group', 148);
function $clinit_BoxLayoutProvider$PackingMode(){
  $clinit_BoxLayoutProvider$PackingMode = emptyMethod;
  SIMPLE_0 = new BoxLayoutProvider$PackingMode('SIMPLE', 0);
  GROUP_DEC = new BoxLayoutProvider$PackingMode('GROUP_DEC', 1);
  GROUP_MIXED = new BoxLayoutProvider$PackingMode('GROUP_MIXED', 2);
  GROUP_INC = new BoxLayoutProvider$PackingMode('GROUP_INC', 3);
}

function BoxLayoutProvider$PackingMode(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_99(name_0){
  $clinit_BoxLayoutProvider$PackingMode();
  return valueOf(($clinit_BoxLayoutProvider$PackingMode$Map() , $MAP_87), name_0);
}

function values_95(){
  $clinit_BoxLayoutProvider$PackingMode();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_util_BoxLayoutProvider$PackingMode_2_classLit, 1), $intern_38, 297, 0, [SIMPLE_0, GROUP_DEC, GROUP_MIXED, GROUP_INC]);
}

defineClass(297, 22, {3:1, 34:1, 22:1, 297:1}, BoxLayoutProvider$PackingMode);
var GROUP_DEC, GROUP_INC, GROUP_MIXED, SIMPLE_0;
var Lorg_eclipse_elk_core_util_BoxLayoutProvider$PackingMode_2_classLit = createForEnum('org.eclipse.elk.core.util', 'BoxLayoutProvider/PackingMode', 297, Ljava_lang_Enum_2_classLit, values_95, valueOf_99);
function $clinit_BoxLayoutProvider$PackingMode$Map(){
  $clinit_BoxLayoutProvider$PackingMode$Map = emptyMethod;
  $MAP_87 = createValueOfMap(($clinit_BoxLayoutProvider$PackingMode() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_util_BoxLayoutProvider$PackingMode_2_classLit, 1), $intern_38, 297, 0, [SIMPLE_0, GROUP_DEC, GROUP_MIXED, GROUP_INC])));
}

var $MAP_87;
function BoxLayoutProvider$lambda$0$Type(){
}

defineClass(883, 1, $intern_40, BoxLayoutProvider$lambda$0$Type);
_.equals_0 = function equals_170(other){
  return this === other;
}
;
_.reversed = function reversed_64(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_72(arg0, arg1){
  return -compare_5($area(castTo(arg0, 148)), $area(castTo(arg1, 148)));
}
;
var Lorg_eclipse_elk_core_util_BoxLayoutProvider$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.core.util', 'BoxLayoutProvider/lambda$0$Type', 883);
function BoxLayoutProvider$lambda$1$Type(){
}

defineClass(884, 1, $intern_40, BoxLayoutProvider$lambda$1$Type);
_.equals_0 = function equals_171(other){
  return this === other;
}
;
_.reversed = function reversed_65(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_73(arg0, arg1){
  return compare_5($area(castTo(arg0, 148)), $area(castTo(arg1, 148)));
}
;
var Lorg_eclipse_elk_core_util_BoxLayoutProvider$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.core.util', 'BoxLayoutProvider/lambda$1$Type', 884);
function BoxLayoutProvider$lambda$2$Type(){
}

defineClass(885, 1, $intern_40, BoxLayoutProvider$lambda$2$Type);
_.equals_0 = function equals_172(other){
  return this === other;
}
;
_.reversed = function reversed_66(){
  return new Comparators$ReversedComparator(this);
}
;
_.compare_0 = function compare_74(arg0, arg1){
  return compare_5($area(castTo(arg0, 148)), $area(castTo(arg1, 148)));
}
;
var Lorg_eclipse_elk_core_util_BoxLayoutProvider$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.core.util', 'BoxLayoutProvider/lambda$2$Type', 885);
function applyConfiguredNodeScaling(node){
  var anchor, scalingFactor, shape_0, shape$iterator;
  scalingFactor = checkNotNull_1(castToDouble($getProperty_0(node, ($clinit_CoreOptions() , SCALE_FACTOR))));
  if (scalingFactor == 1) {
    return;
  }
  $setDimensions_0(node, scalingFactor * node.width_0, scalingFactor * node.height);
  for (shape$iterator = $iterator(concat_1((!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports), (!node.labels && (node.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, node, 1, 7)) , node.labels))); $hasNext_0(shape$iterator);) {
    shape_0 = castTo($next_2(shape$iterator), 444);
    shape_0.setLocation(scalingFactor * shape_0.getX(), scalingFactor * shape_0.getY());
    shape_0.setDimensions(scalingFactor * shape_0.getWidth(), scalingFactor * shape_0.getHeight());
    anchor = castTo(shape_0.getProperty(PORT_ANCHOR_0), 8);
    if (anchor) {
      anchor.x_0 *= scalingFactor;
      anchor.y_0 *= scalingFactor;
    }
  }
}

function applyVectorChain(vectorChain, section){
  var bendpoint, elkBendPoint, firstPoint, lastPoint, newPointIter, nextPoint, oldPointIter;
  if (vectorChain.size_0 < 2) {
    throw toJs(new IllegalArgumentException_0('The vector chain must contain at least a source and a target point.'));
  }
  firstPoint = (checkCriticalElement(vectorChain.size_0 != 0) , castTo(vectorChain.header.next_0.value_0, 8));
  $setStartLocation(section, firstPoint.x_0, firstPoint.y_0);
  oldPointIter = new AbstractEList$EListIterator((!section.bendPoints && (section.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, section, 5)) , section.bendPoints));
  newPointIter = $listIterator_1(vectorChain, 1);
  while (newPointIter.currentIndex < vectorChain.size_0 - 1) {
    nextPoint = castTo($next_13(newPointIter), 8);
    if (oldPointIter.cursor != oldPointIter.this$01_2.size_1()) {
      bendpoint = castTo($doNext(oldPointIter), 556);
    }
     else {
      bendpoint = ($clinit_ElkGraphFactory() , elkBendPoint = new ElkBendPointImpl , elkBendPoint);
      $doAdd_0(oldPointIter, bendpoint);
    }
    $set_7(bendpoint, nextPoint.x_0, nextPoint.y_0);
  }
  while (oldPointIter.cursor != oldPointIter.this$01_2.size_1()) {
    $doNext(oldPointIter);
    $remove_35(oldPointIter);
  }
  lastPoint = (checkCriticalElement(vectorChain.size_0 != 0) , castTo(vectorChain.tail.prev.value_0, 8));
  $setEndLocation(section, lastPoint.x_0, lastPoint.y_0);
}

function applyVisitors(graph, visitors){
  var allElements, graphElement, i, nextElement;
  allElements = new ElkGraphUtil$PropertiesSkippingTreeIterator(graph);
  while (allElements.data_0 == null && !allElements.includeRoot?$hasAnyChildren(allElements):allElements.data_0 == null || allElements.size_0 != 0 && castTo(allElements.data_0[allElements.size_0 - 1], 47).hasNext_0()) {
    nextElement = castTo($next_16(allElements), 51);
    if (instanceOf(nextElement, 202)) {
      graphElement = castTo(nextElement, 202);
      for (i = 0; i < visitors.length; i++) {
        visitors[i].visit(graphElement);
      }
    }
  }
}

function calcPortOffset_0(port, side){
  var node;
  if (!$getParent_3(port)) {
    throw toJs(new IllegalStateException_0('port must have a parent node to calculate the port side'));
  }
  node = $getParent_3(port);
  switch (side.ordinal) {
    case 1:
      return -(port.y_0 + port.height);
    case 2:
      return port.x_0 - node.width_0;
    case 3:
      return port.y_0 - node.height;
    case 4:
      return -(port.x_0 + port.width_0);
  }
  return 0;
}

function calcPortSide_0(port, direction){
  var heightPercent, node, nodeHeight, nodeWidth, widthPercent, xpos, ypos;
  if (!$getParent_3(port)) {
    throw toJs(new IllegalStateException_0('port must have a parent node to calculate the port side'));
  }
  node = $getParent_3(port);
  nodeWidth = node.width_0;
  nodeHeight = node.height;
  if (nodeWidth <= 0 && nodeHeight <= 0) {
    return $clinit_PortSide() , UNDEFINED_7;
  }
  xpos = port.x_0;
  ypos = port.y_0;
  switch (direction.ordinal) {
    case 2:
    case 1:
      if (xpos < 0) {
        return $clinit_PortSide() , WEST_1;
      }
       else if (xpos + port.width_0 > nodeWidth) {
        return $clinit_PortSide() , EAST_1;
      }

      break;
    case 4:
    case 3:
      if (ypos < 0) {
        return $clinit_PortSide() , NORTH_1;
      }
       else if (ypos + port.height > nodeHeight) {
        return $clinit_PortSide() , SOUTH_1;
      }

  }
  widthPercent = (xpos + port.width_0 / 2) / nodeWidth;
  heightPercent = (ypos + port.height / 2) / nodeHeight;
  return widthPercent + heightPercent <= 1 && widthPercent - heightPercent <= 0?($clinit_PortSide() , WEST_1):widthPercent + heightPercent >= 1 && widthPercent - heightPercent >= 0?($clinit_PortSide() , EAST_1):heightPercent < 0.5?($clinit_PortSide() , NORTH_1):($clinit_PortSide() , SOUTH_1);
}

function createVectorChain(edgeSection){
  var bendPoint, bendPoint$iterator, chain;
  chain = new KVectorChain;
  $add_7(chain, new KVector_1(edgeSection.startX, edgeSection.startY));
  for (bendPoint$iterator = new AbstractEList$EIterator((!edgeSection.bendPoints && (edgeSection.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, edgeSection, 5)) , edgeSection.bendPoints)); bendPoint$iterator.cursor != bendPoint$iterator.this$01_2.size_1();) {
    bendPoint = castTo($doNext(bendPoint$iterator), 556);
    $add_7(chain, new KVector_1(bendPoint.x_0, bendPoint.y_0));
  }
  $add_7(chain, new KVector_1(edgeSection.endX, edgeSection.endY));
  return chain;
}

function determineJunctionPoints(edge){
  var junctionPoints;
  if ((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0 != 1) {
    throw toJs(new IllegalArgumentException_0('The edge needs to have exactly one edge section. Found: ' + (!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0));
  }
  junctionPoints = new KVectorChain;
  !!connectableShapeToPort(castTo($get_16((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources), 0), 97)) && $addAll(junctionPoints, determineJunctionPoints_0(edge, connectableShapeToPort(castTo($get_16((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources), 0), 97)), false));
  !!connectableShapeToPort(castTo($get_16((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets), 0), 97)) && $addAll(junctionPoints, determineJunctionPoints_0(edge, connectableShapeToPort(castTo($get_16((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets), 0), 97)), true));
  return junctionPoints;
}

function determineJunctionPoints_0(edge, port, reverse){
  var allConnectedSections, allSectIter, dx2, dx3, dy2, dy3, i, junctionPoints, offset, offsetMap, otherEdge, otherEdge$iterator, otherPoints, otherSection, p1, p2, p3, pointsMap, section, sectionPoints;
  section = castTo($get_16((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), 0), 228);
  junctionPoints = new KVectorChain;
  pointsMap = ($clinit_Maps() , new HashMap);
  sectionPoints = getPoints(section);
  $put_4(pointsMap.hashCodeMap, section, sectionPoints);
  offsetMap = new HashMap;
  allConnectedSections = new LinkedList;
  for (otherEdge$iterator = $iterator(concat_1((!port.incomingEdges && (port.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, port, 8, 5)) , port.incomingEdges), (!port.outgoingEdges && (port.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, port, 7, 4)) , port.outgoingEdges))); $hasNext_0(otherEdge$iterator);) {
    otherEdge = castTo($next_2(otherEdge$iterator), 100);
    if ((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0 != 1) {
      throw toJs(new IllegalArgumentException_0('The edge needs to have exactly one edge section. Found: ' + (!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0));
    }
    if (otherEdge != edge) {
      otherSection = castTo($get_16((!otherEdge.sections && (otherEdge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, otherEdge, 6, 6)) , otherEdge.sections), 0), 228);
      $addNode_0(allConnectedSections, otherSection, allConnectedSections.tail.prev, allConnectedSections.tail);
      otherPoints = castTo(getEntryValueOrNull($getEntry(pointsMap.hashCodeMap, otherSection)), 12);
      if (!otherPoints) {
        otherPoints = getPoints(otherSection);
        $put_4(pointsMap.hashCodeMap, otherSection, otherPoints);
      }
      offset = reverse?$sub_0(new KVector_2(castTo($get_7(sectionPoints, sectionPoints.array.length - 1), 8)), castTo($get_7(otherPoints, otherPoints.array.length - 1), 8)):$sub_0(new KVector_2((checkCriticalElementIndex(0, sectionPoints.array.length) , castTo(sectionPoints.array[0], 8))), (checkCriticalElementIndex(0, otherPoints.array.length) , castTo(otherPoints.array[0], 8)));
      $put_4(offsetMap.hashCodeMap, otherSection, offset);
    }
  }
  if (allConnectedSections.size_0 != 0) {
    p1 = castTo($get_7(sectionPoints, reverse?sectionPoints.array.length - 1:0), 8);
    for (i = 1; i < sectionPoints.array.length; i++) {
      p2 = castTo($get_7(sectionPoints, reverse?sectionPoints.array.length - 1 - i:i), 8);
      allSectIter = $listIterator_1(allConnectedSections, 0);
      while (allSectIter.currentNode != allSectIter.this$01.tail) {
        otherSection = castTo($next_13(allSectIter), 228);
        otherPoints = castTo(getEntryValueOrNull($getEntry(pointsMap.hashCodeMap, otherSection)), 12);
        if (otherPoints.array.length <= i) {
          $remove_24(allSectIter);
        }
         else {
          p3 = $add_19(new KVector_2(castTo($get_7(otherPoints, reverse?otherPoints.array.length - 1 - i:i), 8)), castTo(getEntryValueOrNull($getEntry(offsetMap.hashCodeMap, otherSection)), 8));
          if (p2.x_0 != p3.x_0 || p2.y_0 != p3.y_0) {
            dx2 = p2.x_0 - p1.x_0;
            dy2 = p2.y_0 - p1.y_0;
            dx3 = p3.x_0 - p1.x_0;
            dy3 = p3.y_0 - p1.y_0;
            dx3 * dy2 == dy3 * dx2 && (dx2 == 0 || isNaN(dx2)?dx2:dx2 < 0?-1:1) == (dx3 == 0 || isNaN(dx3)?dx3:dx3 < 0?-1:1) && (dy2 == 0 || isNaN(dy2)?dy2:dy2 < 0?-1:1) == (dy3 == 0 || isNaN(dy3)?dy3:dy3 < 0?-1:1)?($wnd.Math.abs(dx2) < $wnd.Math.abs(dx3) || $wnd.Math.abs(dy2) < $wnd.Math.abs(dy3)) && ($addNode_0(junctionPoints, p2, junctionPoints.tail.prev, junctionPoints.tail) , true):i > 1 && ($addNode_0(junctionPoints, p1, junctionPoints.tail.prev, junctionPoints.tail) , true);
            $remove_24(allSectIter);
          }
        }
      }
      p1 = p2;
    }
  }
  return junctionPoints;
}

function getPoints(section){
  var i, n, p1, p2, p3, points;
  n = (!section.bendPoints && (section.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, section, 5)) , section.bendPoints).size_0 + 2;
  points = new ArrayList_0(n);
  $add_4(points, new KVector_1(section.startX, section.startY));
  $forEach_2(new Stream$StreamSource(null, (!section.bendPoints && (section.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, section, 5)) , new Spliterators$IteratorSpliterator(section.bendPoints, 16))), new ElkUtil$lambda$3$Type(points));
  $add_4(points, new KVector_1(section.endX, section.endY));
  i = 1;
  while (i < points.array.length - 1) {
    p1 = (checkCriticalElementIndex(i - 1, points.array.length) , castTo(points.array[i - 1], 8));
    p2 = (checkCriticalElementIndex(i, points.array.length) , castTo(points.array[i], 8));
    p3 = (checkCriticalElementIndex(i + 1, points.array.length) , castTo(points.array[i + 1], 8));
    p1.x_0 == p2.x_0 && p2.x_0 == p3.x_0 || p1.y_0 == p2.y_0 && p2.y_0 == p3.y_0?$remove_12(points, i):++i;
  }
  return points;
}

function lambda$0_15(xoffset_0, yoffset_2, edge_2){
  var junctionPoints;
  $forEach_2(new Stream$StreamSource(null, (!edge_2.sections && (edge_2.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge_2, 6, 6)) , new Spliterators$IteratorSpliterator(edge_2.sections, 16))), new ElkUtil$lambda$1$Type(xoffset_0, yoffset_2));
  $forEach_2(new Stream$StreamSource(null, (!edge_2.labels && (edge_2.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, edge_2, 1, 7)) , new Spliterators$IteratorSpliterator(edge_2.labels, 16))), new ElkUtil$lambda$2$Type(xoffset_0, yoffset_2));
  junctionPoints = castTo($getProperty_0(edge_2, ($clinit_CoreOptions() , JUNCTION_POINTS_0)), 74);
  !!junctionPoints && $offset_1(junctionPoints, xoffset_0, yoffset_2);
}

function lambda$1_6(xoffset_0, yoffset_2, s_2){
  translate(s_2, xoffset_0, yoffset_2);
}

function lambda$2_5(xoffset_0, yoffset_2, label_2){
  $setLocation(label_2, label_2.x_0 + xoffset_0, label_2.y_0 + yoffset_2);
}

function lambda$3_4(points_0, bendPoint_1){
  return $add_4(points_0, new KVector_1(bendPoint_1.x_0, bendPoint_1.y_0));
}

function printElementPath(element, builder){
  var className, edge, identifier, label_0, label$iterator, sourceIter, targetIter, text_0;
  if (instanceOf(element.eContainer_0(), 202)) {
    printElementPath(castTo(element.eContainer_0(), 202), builder);
    builder.string += ' > ';
  }
   else {
    builder.string += 'Root ';
  }
  className = element.eClass_0().name_0;
  $equals_4(className.substr(0, 3), 'Elk')?$append_11(builder, className.substr(3, className.length - 3)):(builder.string += '' + className , builder);
  identifier = element.getIdentifier();
  if (identifier) {
    $append_11((builder.string += ' ' , builder), identifier);
    return;
  }
  if (instanceOf(element, 241)) {
    text_0 = castTo(castTo(element, 135), 241).text_0;
    if (text_0) {
      $append_11((builder.string += ' ' , builder), text_0);
      return;
    }
  }
  for (label$iterator = new AbstractEList$EIterator(element.getLabels_0()); label$iterator.cursor != label$iterator.this$01_2.size_1();) {
    label_0 = castTo($doNext(label$iterator), 135);
    text_0 = label_0.text_0;
    if (text_0) {
      $append_11((builder.string += ' ' , builder), text_0);
      return;
    }
  }
  if (instanceOf(element, 173)) {
    edge = castTo(element, 100);
    !edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7));
    if (edge.sources.size_0 != 0 && (!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets.size_0 != 0)) {
      builder.string += ' (';
      sourceIter = new AbstractEList$EListIterator((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources));
      while (sourceIter.cursor != sourceIter.this$01_2.size_1()) {
        sourceIter.cursor > 0 && (builder.string += ', ' , builder);
        printElementPath(castTo($doNext(sourceIter), 202), builder);
      }
      builder.string += ' -> ';
      targetIter = new AbstractEList$EListIterator((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets));
      while (targetIter.cursor != targetIter.this$01_2.size_1()) {
        targetIter.cursor > 0 && (builder.string += ', ' , builder);
        printElementPath(castTo($doNext(targetIter), 202), builder);
      }
      builder.string += ')';
    }
  }
}

function resizeNode_0(node){
  var direction, minEast, minNorth, minSouth, minWest, newHeight, newWidth, port, port$iterator, portConstraints, portSide, sizeConstraint;
  sizeConstraint = castTo($getProperty_0(node, ($clinit_CoreOptions() , NODE_SIZE_CONSTRAINTS_1)), 19);
  if (sizeConstraint.isEmpty()) {
    return null;
  }
  newWidth = 0;
  newHeight = 0;
  if (sizeConstraint.contains(($clinit_SizeConstraint() , PORTS_0))) {
    portConstraints = castTo($getProperty_0(node, PORT_CONSTRAINTS_1), 83);
    minNorth = 2;
    minEast = 2;
    minSouth = 2;
    minWest = 2;
    direction = !$getParent_2(node)?castTo($getProperty_0(node, DIRECTION_0), 107):castTo($getProperty_0($getParent_2(node), DIRECTION_0), 107);
    for (port$iterator = new AbstractEList$EIterator((!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports)); port$iterator.cursor != port$iterator.this$01_2.size_1();) {
      port = castTo($doNext(port$iterator), 123);
      portSide = castTo($getProperty_0(port, PORT_SIDE_0), 71);
      if (portSide == ($clinit_PortSide() , UNDEFINED_7)) {
        portSide = calcPortSide_0(port, direction);
        $setProperty_1(port, PORT_SIDE_0, portSide);
      }
      if (portConstraints == ($clinit_PortConstraints() , FIXED_POS)) {
        switch (portSide.ordinal) {
          case 1:
            minNorth = $wnd.Math.max(minNorth, port.x_0 + port.width_0);
            break;
          case 2:
            minEast = $wnd.Math.max(minEast, port.y_0 + port.height);
            break;
          case 3:
            minSouth = $wnd.Math.max(minSouth, port.x_0 + port.width_0);
            break;
          case 4:
            minWest = $wnd.Math.max(minWest, port.y_0 + port.height);
        }
      }
       else {
        switch (portSide.ordinal) {
          case 1:
            minNorth += port.width_0 + 2;
            break;
          case 2:
            minEast += port.height + 2;
            break;
          case 3:
            minSouth += port.width_0 + 2;
            break;
          case 4:
            minWest += port.height + 2;
        }
      }
    }
    newWidth = $wnd.Math.max(minNorth, minSouth);
    newHeight = $wnd.Math.max(minEast, minWest);
  }
  return resizeNode_1(node, newWidth, newHeight, true, true);
}

function resizeNode_1(node, newWidth, newHeight, movePorts, moveLabels){
  var all, direction, fixedPorts, heightDiff, heightPercent, heightRatio, label_0, label$iterator, midx, midy, minSize, newSize, oldSize, port, port$iterator, portSide, sizeConstraint, sizeOptions, widthDiff, widthPercent, widthRatio;
  sizeConstraint = castTo($getProperty_0(node, ($clinit_CoreOptions() , NODE_SIZE_CONSTRAINTS_1)), 19);
  oldSize = new KVector_1(node.width_0, node.height);
  if (sizeConstraint.contains(($clinit_SizeConstraint() , MINIMUM_SIZE))) {
    sizeOptions = castTo($getProperty_0(node, NODE_SIZE_OPTIONS_1), 19);
    minSize = castTo($getProperty_0(node, NODE_SIZE_MINIMUM_1), 8);
    if (sizeOptions.contains(($clinit_SizeOptions() , DEFAULT_MINIMUM_SIZE))) {
      minSize.x_0 <= 0 && (minSize.x_0 = 20);
      minSize.y_0 <= 0 && (minSize.y_0 = 20);
    }
    newSize = new KVector_1($wnd.Math.max(newWidth, minSize.x_0), $wnd.Math.max(newHeight, minSize.y_0));
  }
   else {
    newSize = new KVector_1(newWidth, newHeight);
  }
  widthRatio = newSize.x_0 / oldSize.x_0;
  heightRatio = newSize.y_0 / oldSize.y_0;
  widthDiff = newSize.x_0 - oldSize.x_0;
  heightDiff = newSize.y_0 - oldSize.y_0;
  if (movePorts) {
    direction = !$getParent_2(node)?castTo($getProperty_0(node, DIRECTION_0), 107):castTo($getProperty_0($getParent_2(node), DIRECTION_0), 107);
    fixedPorts = maskUndefined($getProperty_0(node, PORT_CONSTRAINTS_1)) === maskUndefined(($clinit_PortConstraints() , FIXED_POS));
    for (port$iterator = new AbstractEList$EIterator((!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports)); port$iterator.cursor != port$iterator.this$01_2.size_1();) {
      port = castTo($doNext(port$iterator), 123);
      portSide = castTo($getProperty_0(port, PORT_SIDE_0), 71);
      if (portSide == ($clinit_PortSide() , UNDEFINED_7)) {
        portSide = calcPortSide_0(port, direction);
        $setProperty_1(port, PORT_SIDE_0, portSide);
      }
      switch (portSide.ordinal) {
        case 1:
          fixedPorts || $setX_1(port, port.x_0 * widthRatio);
          break;
        case 2:
          $setX_1(port, port.x_0 + widthDiff);
          fixedPorts || $setY_1(port, port.y_0 * heightRatio);
          break;
        case 3:
          fixedPorts || $setX_1(port, port.x_0 * widthRatio);
          $setY_1(port, port.y_0 + heightDiff);
          break;
        case 4:
          fixedPorts || $setY_1(port, port.y_0 * heightRatio);
      }
    }
  }
  $setDimensions_0(node, newSize.x_0, newSize.y_0);
  if (moveLabels) {
    for (label$iterator = new AbstractEList$EIterator((!node.labels && (node.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, node, 1, 7)) , node.labels)); label$iterator.cursor != label$iterator.this$01_2.size_1();) {
      label_0 = castTo($doNext(label$iterator), 135);
      midx = label_0.x_0 + label_0.width_0 / 2;
      midy = label_0.y_0 + label_0.height / 2;
      widthPercent = midx / oldSize.x_0;
      heightPercent = midy / oldSize.y_0;
      if (widthPercent + heightPercent >= 1) {
        if (widthPercent - heightPercent > 0 && midy >= 0) {
          $setX_1(label_0, label_0.x_0 + widthDiff);
          $setY_1(label_0, label_0.y_0 + heightDiff * heightPercent);
        }
         else if (widthPercent - heightPercent < 0 && midx >= 0) {
          $setX_1(label_0, label_0.x_0 + widthDiff * widthPercent);
          $setY_1(label_0, label_0.y_0 + heightDiff);
        }
      }
    }
  }
  $setProperty_1(node, NODE_SIZE_CONSTRAINTS_1, (all = castTo($getEnumConstants(Lorg_eclipse_elk_core_options_SizeConstraint_2_classLit), 10) , new EnumSet$EnumSetImpl(all, castTo(createFrom(all, all.length), 10), 0)));
  return new KVector_1(widthRatio, heightRatio);
}

function toAbsolute(point, parent_0){
  var node;
  node = parent_0;
  while (node) {
    $add_18(point, node.x_0, node.y_0);
    node = $getParent_2(node);
  }
  return point;
}

function toRelative(point, parent_0){
  var node;
  node = parent_0;
  while (node) {
    $add_18(point, -node.x_0, -node.y_0);
    node = $getParent_2(node);
  }
  return point;
}

function translate(section, xoffset, yoffset){
  var bendPoint, bendPoint$iterator;
  $setStartLocation(section, section.startX + xoffset, section.startY + yoffset);
  for (bendPoint$iterator = new AbstractEList$EIterator((!section.bendPoints && (section.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, section, 5)) , section.bendPoints)); bendPoint$iterator.cursor != bendPoint$iterator.this$01_2.size_1();) {
    bendPoint = castTo($doNext(bendPoint$iterator), 556);
    $set_7(bendPoint, bendPoint.x_0 + xoffset, bendPoint.y_0 + yoffset);
  }
  $setEndLocation(section, section.endX + xoffset, section.endY + yoffset);
}

function translate_0(parent_0, xoffset, yoffset){
  var child, child$iterator;
  for (child$iterator = new AbstractEList$EIterator((!parent_0.children && (parent_0.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parent_0, 10, 11)) , parent_0.children)); child$iterator.cursor != child$iterator.this$01_2.size_1();) {
    child = castTo($doNext(child$iterator), 35);
    $setLocation(child, child.x_0 + xoffset, child.y_0 + yoffset);
  }
  $forEach((!parent_0.containedEdges && (parent_0.containedEdges = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, parent_0, 12, 3)) , parent_0.containedEdges), new ElkUtil$lambda$0$Type(xoffset, yoffset));
}

function ElkUtil$lambda$0$Type(xoffset_0, yoffset_2){
  this.xoffset_0 = xoffset_0;
  this.yoffset_2 = yoffset_2;
}

defineClass(865, 1, {}, ElkUtil$lambda$0$Type);
_.accept = function accept_106(arg0){
  lambda$0_15(this.xoffset_0, this.yoffset_2, arg0);
}
;
_.xoffset_0 = 0;
_.yoffset_2 = 0;
var Lorg_eclipse_elk_core_util_ElkUtil$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.core.util', 'ElkUtil/lambda$0$Type', 865);
function ElkUtil$lambda$1$Type(xoffset_0, yoffset_2){
  this.xoffset_0 = xoffset_0;
  this.yoffset_2 = yoffset_2;
}

defineClass(866, 1, {}, ElkUtil$lambda$1$Type);
_.accept = function accept_107(arg0){
  lambda$1_6(this.xoffset_0, this.yoffset_2, arg0);
}
;
_.xoffset_0 = 0;
_.yoffset_2 = 0;
var Lorg_eclipse_elk_core_util_ElkUtil$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.core.util', 'ElkUtil/lambda$1$Type', 866);
function ElkUtil$lambda$2$Type(xoffset_0, yoffset_2){
  this.xoffset_0 = xoffset_0;
  this.yoffset_2 = yoffset_2;
}

defineClass(867, 1, {}, ElkUtil$lambda$2$Type);
_.accept = function accept_108(arg0){
  lambda$2_5(this.xoffset_0, this.yoffset_2, arg0);
}
;
_.xoffset_0 = 0;
_.yoffset_2 = 0;
var Lorg_eclipse_elk_core_util_ElkUtil$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.core.util', 'ElkUtil/lambda$2$Type', 867);
function ElkUtil$lambda$3$Type(points_0){
  this.points_0 = points_0;
}

defineClass(868, 1, {}, ElkUtil$lambda$3$Type);
_.accept = function accept_109(arg0){
  lambda$3_4(this.points_0, arg0);
}
;
var Lorg_eclipse_elk_core_util_ElkUtil$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.core.util', 'ElkUtil/lambda$3$Type', 868);
function $compareTo_20(this$static, x_0){
  return this$static.exclusiveLowerBound < doubleValue__D__devirtual$(x_0)?-1:1;
}

function ExclusiveBounds$ExclusiveLowerBound(){
  this.exclusiveLowerBound = 0;
}

defineClass(332, 1, {34:1, 332:1}, ExclusiveBounds$ExclusiveLowerBound);
_.compareTo_0 = function compareTo_21(x_0){
  return $compareTo_20(this, castTo(x_0, 217));
}
;
_.equals_0 = function equals_173(obj){
  var other;
  if (instanceOf(obj, 332)) {
    other = castTo(obj, 332);
    return this.exclusiveLowerBound == other.exclusiveLowerBound;
  }
  return false;
}
;
_.hashCode_1 = function hashCode_64(){
  return round_int(this.exclusiveLowerBound);
}
;
_.toString_0 = function toString_118(){
  return this.exclusiveLowerBound + ' (exclusive)';
}
;
_.exclusiveLowerBound = 0;
var Lorg_eclipse_elk_core_util_ExclusiveBounds$ExclusiveLowerBound_2_classLit = createForClass('org.eclipse.elk.core.util', 'ExclusiveBounds/ExclusiveLowerBound', 332);
function $processEdge(edge){
  var bendPoints, edgeSection, edgeSection$iterator, elkEdgeSection, label_0, label$iterator, maxv, point, point$iterator, pos, sameHierarchy, sections, sourceParent, targetParent;
  sourceParent = $getParent_2(connectableShapeToNode(castTo($get_16((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources), 0), 97)));
  targetParent = $getParent_2(connectableShapeToNode(castTo($get_16((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets), 0), 97)));
  sameHierarchy = sourceParent == targetParent;
  maxv = new KVector;
  bendPoints = castTo($getProperty_0(edge, ($clinit_FixedLayouterOptions() , BEND_POINTS_0)), 74);
  if (!!bendPoints && bendPoints.size_0 >= 2) {
    if ((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0 == 0) {
      edgeSection = ($clinit_ElkGraphFactory() , elkEdgeSection = new ElkEdgeSectionImpl , elkEdgeSection);
      $add_21((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), edgeSection);
    }
     else if ((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0 > 1) {
      sections = new AbstractEList$EListIterator((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections));
      while (sections.cursor != sections.this$01_2.size_1()) {
        $remove_35(sections);
      }
    }
    applyVectorChain(bendPoints, castTo($get_16((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), 0), 228));
  }
  if (sameHierarchy) {
    for (edgeSection$iterator = new AbstractEList$EIterator((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections)); edgeSection$iterator.cursor != edgeSection$iterator.this$01_2.size_1();) {
      edgeSection = castTo($doNext(edgeSection$iterator), 228);
      for (point$iterator = new AbstractEList$EIterator((!edgeSection.bendPoints && (edgeSection.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, edgeSection, 5)) , edgeSection.bendPoints)); point$iterator.cursor != point$iterator.this$01_2.size_1();) {
        point = castTo($doNext(point$iterator), 556);
        maxv.x_0 = $wnd.Math.max(maxv.x_0, point.x_0);
        maxv.y_0 = $wnd.Math.max(maxv.y_0, point.y_0);
      }
    }
  }
  for (label$iterator = new AbstractEList$EIterator((!edge.labels && (edge.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, edge, 1, 7)) , edge.labels)); label$iterator.cursor != label$iterator.this$01_2.size_1();) {
    label_0 = castTo($doNext(label$iterator), 135);
    pos = castTo($getProperty_0(label_0, POSITION_3), 8);
    !!pos && $setLocation(label_0, pos.x_0, pos.y_0);
    if (sameHierarchy) {
      maxv.x_0 = $wnd.Math.max(maxv.x_0, label_0.x_0 + label_0.width_0);
      maxv.y_0 = $wnd.Math.max(maxv.y_0, label_0.y_0 + label_0.height);
    }
  }
  return maxv;
}

function FixedLayoutProvider(){
}

defineClass(1004, 197, $intern_100, FixedLayoutProvider);
_.layout = function layout_8(layoutNode, progressMonitor){
  var edge, edge$iterator, edge$iterator0, edgeRouting, junctionPoints, label_0, label$iterator, label$iterator0, maxv, maxx, maxy, minSize, newHeight, newWidth, node, node$iterator, node$iterator0, padding, port, port$iterator, portx, porty, pos;
  $begin(progressMonitor, 'Fixed Layout', 1);
  edgeRouting = castTo($getProperty_0(layoutNode, ($clinit_CoreOptions() , EDGE_ROUTING_0)), 204);
  maxx = 0;
  maxy = 0;
  for (node$iterator0 = new AbstractEList$EIterator((!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children)); node$iterator0.cursor != node$iterator0.this$01_2.size_1();) {
    node = castTo($doNext(node$iterator0), 35);
    pos = castTo($getProperty_0(node, ($clinit_FixedLayouterOptions() , POSITION_3)), 8);
    if (pos) {
      $setLocation(node, pos.x_0, pos.y_0);
      if (castTo($getProperty_0(node, NODE_SIZE_CONSTRAINTS_2), 190).contains(($clinit_SizeConstraint() , MINIMUM_SIZE))) {
        minSize = castTo($getProperty_0(node, NODE_SIZE_MINIMUM_2), 8);
        minSize.x_0 > 0 && minSize.y_0 > 0 && resizeNode_1(node, minSize.x_0, minSize.y_0, true, true);
      }
    }
    maxx = $wnd.Math.max(maxx, node.x_0 + node.width_0);
    maxy = $wnd.Math.max(maxy, node.y_0 + node.height);
    for (label$iterator0 = new AbstractEList$EIterator((!node.labels && (node.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, node, 1, 7)) , node.labels)); label$iterator0.cursor != label$iterator0.this$01_2.size_1();) {
      label_0 = castTo($doNext(label$iterator0), 135);
      pos = castTo($getProperty_0(label_0, POSITION_3), 8);
      !!pos && $setLocation(label_0, pos.x_0, pos.y_0);
      maxx = $wnd.Math.max(maxx, node.x_0 + label_0.x_0 + label_0.width_0);
      maxy = $wnd.Math.max(maxy, node.y_0 + label_0.y_0 + label_0.height);
    }
    for (port$iterator = new AbstractEList$EIterator((!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports)); port$iterator.cursor != port$iterator.this$01_2.size_1();) {
      port = castTo($doNext(port$iterator), 123);
      pos = castTo($getProperty_0(port, POSITION_3), 8);
      !!pos && $setLocation(port, pos.x_0, pos.y_0);
      portx = node.x_0 + port.x_0;
      porty = node.y_0 + port.y_0;
      maxx = $wnd.Math.max(maxx, portx + port.width_0);
      maxy = $wnd.Math.max(maxy, porty + port.height);
      for (label$iterator = new AbstractEList$EIterator((!port.labels && (port.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, port, 1, 7)) , port.labels)); label$iterator.cursor != label$iterator.this$01_2.size_1();) {
        label_0 = castTo($doNext(label$iterator), 135);
        pos = castTo($getProperty_0(label_0, POSITION_3), 8);
        !!pos && $setLocation(label_0, pos.x_0, pos.y_0);
        maxx = $wnd.Math.max(maxx, portx + label_0.x_0 + label_0.width_0);
        maxy = $wnd.Math.max(maxy, porty + label_0.y_0 + label_0.height);
      }
    }
    for (edge$iterator0 = $iterator(allOutgoingEdges(node)); $hasNext_0(edge$iterator0);) {
      edge = castTo($next_2(edge$iterator0), 100);
      maxv = $processEdge(edge);
      maxx = $wnd.Math.max(maxx, maxv.x_0);
      maxy = $wnd.Math.max(maxy, maxv.y_0);
    }
    for (edge$iterator = $iterator(allIncomingEdges(node)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 100);
      if ($getParent_2(getSourceNode(edge)) != layoutNode) {
        maxv = $processEdge(edge);
        maxx = $wnd.Math.max(maxx, maxv.x_0);
        maxy = $wnd.Math.max(maxy, maxv.y_0);
      }
    }
  }
  if (edgeRouting == ($clinit_EdgeRouting() , ORTHOGONAL)) {
    for (node$iterator = new AbstractEList$EIterator((!layoutNode.children && (layoutNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, layoutNode, 10, 11)) , layoutNode.children)); node$iterator.cursor != node$iterator.this$01_2.size_1();) {
      node = castTo($doNext(node$iterator), 35);
      for (edge$iterator = $iterator(allOutgoingEdges(node)); $hasNext_0(edge$iterator);) {
        edge = castTo($next_2(edge$iterator), 100);
        junctionPoints = determineJunctionPoints(edge);
        junctionPoints.size_0 == 0?$setProperty_1(edge, JUNCTION_POINTS_0, null):$setProperty_1(edge, JUNCTION_POINTS_0, junctionPoints);
      }
    }
  }
  padding = castTo($getProperty_0(layoutNode, ($clinit_FixedLayouterOptions() , PADDING_6)), 116);
  newWidth = maxx + padding.left + padding.right;
  newHeight = maxy + padding.top_0 + padding.bottom;
  resizeNode_1(layoutNode, newWidth, newHeight, true, true);
  $done_0(progressMonitor);
}
;
var Lorg_eclipse_elk_core_util_FixedLayoutProvider_2_classLit = createForClass('org.eclipse.elk.core.util', 'FixedLayoutProvider', 1004);
function IndividualSpacings(){
}

function getIndividualOrInherited(node, property){
  var individualSpacings, result;
  result = null;
  if (node.hasProperty(($clinit_CoreOptions() , SPACING_INDIVIDUAL_OVERRIDE_0))) {
    individualSpacings = castTo(node.getProperty(SPACING_INDIVIDUAL_OVERRIDE_0), 94);
    individualSpacings.hasProperty(property) && (result = individualSpacings.getProperty(property));
  }
  result == null && !!node.getGraph() && (result = node.getGraph().getProperty(property));
  result == null && (result = $getDefault(property));
  return result;
}

defineClass(818, 130, $intern_99, IndividualSpacings);
var Lorg_eclipse_elk_core_util_IndividualSpacings_2_classLit = createForClass('org.eclipse.elk.core.util', 'IndividualSpacings', 818);
function $fetch(this$static){
  if (this$static.instances.size_0 == 0) {
    return this$static.factory.create_0();
  }
  return $removeFirst_0(this$static.instances);
}

function $release(this$static, obj){
  this$static.limit < 0 || this$static.instances.size_0 < this$static.limit?$addLast_0(this$static.instances, obj):this$static.factory.destroy(obj);
}

function InstancePool(thefactory){
  this.instances = new LinkedList;
  this.factory = thefactory;
  this.limit = -1;
}

defineClass(657, 1, {}, InstancePool);
_.limit = 0;
var Lorg_eclipse_elk_core_util_InstancePool_2_classLit = createForClass('org.eclipse.elk.core.util', 'InstancePool', 657);
function Pair(thefirst, thesecond){
  this.first = thefirst;
  this.second = thesecond;
}

defineClass(37, 1, {20:1, 37:1}, Pair);
_.forEach_0 = function forEach_30(action){
  $forEach(this, action);
}
;
_.equals_0 = function equals_174(obj){
  var firstEqual, other, secondEqual;
  if (instanceOf(obj, 37)) {
    other = castTo(obj, 37);
    firstEqual = this.first == null?other.first == null:equals_Ljava_lang_Object__Z__devirtual$(this.first, other.first);
    secondEqual = this.second == null?other.second == null:equals_Ljava_lang_Object__Z__devirtual$(this.second, other.second);
    return firstEqual && secondEqual;
  }
   else {
    return false;
  }
}
;
_.hashCode_1 = function hashCode_65(){
  var first1, first2, firstCode, second1, second2, secondCode;
  firstCode = this.first == null?0:hashCode__I__devirtual$(this.first);
  first1 = firstCode & $intern_47;
  first2 = firstCode & -65536;
  secondCode = this.second == null?0:hashCode__I__devirtual$(this.second);
  second1 = secondCode & $intern_47;
  second2 = secondCode & -65536;
  return first1 ^ second2 >> 16 & $intern_47 | first2 ^ second1 << 16;
}
;
_.iterator_0 = function iterator_70(){
  return new Pair$1(this);
}
;
_.toString_0 = function toString_119(){
  return this.first == null && this.second == null?'pair(null,null)':this.first == null?'pair(null,' + toString_41(this.second) + ')':this.second == null?'pair(' + toString_41(this.first) + ',null)':'pair(' + toString_41(this.first) + ',' + toString_41(this.second) + ')';
}
;
var Lorg_eclipse_elk_core_util_Pair_2_classLit = createForClass('org.eclipse.elk.core.util', 'Pair', 37);
function Pair$1(this$0){
  this.this$01 = this$0;
}

defineClass(892, 1, $intern_4, Pair$1);
_.forEachRemaining = function forEachRemaining_45(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_41(){
  return !this.visitedSecond && (!this.visitedFirst && this.this$01.first != null || this.this$01.second != null);
}
;
_.next_1 = function next_42(){
  if (!this.visitedSecond && !this.visitedFirst && this.this$01.first != null) {
    this.visitedFirst = true;
    return this.this$01.first;
  }
   else if (!this.visitedSecond && this.this$01.second != null) {
    this.visitedSecond = true;
    return this.this$01.second;
  }
  throw toJs(new NoSuchElementException);
}
;
_.remove_0 = function remove_94(){
  this.visitedSecond && this.this$01.second != null?(this.this$01.second = null):this.visitedFirst && this.this$01.first != null && (this.this$01.first = null);
  throw toJs(new IllegalStateException);
}
;
_.visitedFirst = false;
_.visitedSecond = false;
var Lorg_eclipse_elk_core_util_Pair$1_2_classLit = createForClass('org.eclipse.elk.core.util', 'Pair/1', 892);
function Quadruple(a, b, c, d){
  this.first = a;
  this.second = b;
  this.third = c;
  this.fourth = d;
}

defineClass(422, 1, {422:1}, Quadruple);
_.equals_0 = function equals_175(obj){
  return equals_56(this.first, castTo(obj, 422).first) && equals_56(this.second, castTo(obj, 422).second) && equals_56(this.third, castTo(obj, 422).third) && equals_56(this.fourth, castTo(obj, 422).fourth);
}
;
_.hashCode_1 = function hashCode_66(){
  return hashCode_43(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [this.first, this.second, this.third, this.fourth]));
}
;
_.toString_0 = function toString_120(){
  return '(' + this.first + ', ' + this.second + ', ' + this.third + ', ' + this.fourth + ')';
}
;
var Lorg_eclipse_elk_core_util_Quadruple_2_classLit = createForClass('org.eclipse.elk.core.util', 'Quadruple', 422);
function $randomize(edge, random, drawWidth, drawHeight){
  var bendPoint, bendsNum, edgeSection, edgeSection0, elkBendPoint, elkEdgeSection, i, maxRand, randx, randy, sections, sourceHeight, sourcePX, sourcePY, sourcePort, sourceShape, sourceWidth, sourceX, sourceY, targetHeight, targetPX, targetPY, targetPort, targetShape, targetWidth, targetX, targetY, totalDist, x_0, xdiff, xincr, y_0, ydiff, yincr;
  sourceShape = castTo($get_16((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources), 0), 97);
  sourceX = sourceShape.getX();
  sourceY = sourceShape.getY();
  sourceWidth = sourceShape.getWidth() / 2;
  sourceHeight = sourceShape.getHeight() / 2;
  if (instanceOf(sourceShape, 187)) {
    sourcePort = castTo(sourceShape, 123);
    sourceX += $getParent_3(sourcePort).x_0;
    sourceX += $getParent_3(sourcePort).x_0;
  }
  sourceX += sourceWidth;
  sourceY += sourceHeight;
  targetShape = castTo($get_16((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources), 0), 97);
  targetX = targetShape.getX();
  targetY = targetShape.getY();
  targetWidth = targetShape.getWidth() / 2;
  targetHeight = targetShape.getHeight() / 2;
  if (instanceOf(targetShape, 187)) {
    targetPort = castTo(targetShape, 123);
    targetX += $getParent_3(targetPort).x_0;
    targetX += $getParent_3(targetPort).x_0;
  }
  targetX += targetWidth;
  targetY += targetHeight;
  if ((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0 == 0) {
    edgeSection0 = ($clinit_ElkGraphFactory() , elkEdgeSection = new ElkEdgeSectionImpl , elkEdgeSection);
    $add_21((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), edgeSection0);
  }
   else if ((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0 > 1) {
    sections = new AbstractEList$EListIterator((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections));
    while (sections.cursor != sections.this$01_2.size_1()) {
      $remove_35(sections);
    }
  }
  edgeSection = castTo($get_16((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), 0), 228);
  sourcePX = targetX;
  targetX > sourceX + sourceWidth?(sourcePX = sourceX + sourceWidth):targetX < sourceX - sourceWidth && (sourcePX = sourceX - sourceWidth);
  sourcePY = targetY;
  targetY > sourceY + sourceHeight?(sourcePY = sourceY + sourceHeight):targetY < sourceY - sourceHeight && (sourcePY = sourceY - sourceHeight);
  sourcePX > sourceX - sourceWidth && sourcePX < sourceX + sourceWidth && sourcePY > sourceY - sourceHeight && sourcePY < sourceY + sourceHeight && (sourcePX = sourceX + sourceWidth);
  $setStartX(edgeSection, sourcePX);
  $setStartY(edgeSection, sourcePY);
  targetPX = sourceX;
  sourceX > targetX + targetWidth?(targetPX = targetX + targetWidth):sourceX < targetX - targetWidth && (targetPX = targetX - targetWidth);
  targetPY = sourceY;
  sourceY > targetY + targetHeight?(targetPY = targetY + targetHeight):sourceY < targetY - targetHeight && (targetPY = targetY - targetHeight);
  targetPX > targetX - targetWidth && targetPX < targetX + targetWidth && targetPY > targetY - targetHeight && targetPY < targetY + targetHeight && (targetPY = targetY + targetHeight);
  $setEndX(edgeSection, targetPX);
  $setEndY(edgeSection, targetPY);
  $clear_11((!edgeSection.bendPoints && (edgeSection.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, edgeSection, 5)) , edgeSection.bendPoints));
  bendsNum = $nextInt(random, 5);
  sourceShape == targetShape && ++bendsNum;
  xdiff = targetPX - sourcePX;
  ydiff = targetPY - sourcePY;
  totalDist = $wnd.Math.sqrt(xdiff * xdiff + ydiff * ydiff);
  maxRand = totalDist * 0.20000000298023224;
  xincr = xdiff / (bendsNum + 1);
  yincr = ydiff / (bendsNum + 1);
  x_0 = sourcePX;
  y_0 = sourcePY;
  for (i = 0; i < bendsNum; i++) {
    x_0 += xincr;
    y_0 += yincr;
    randx = x_0 + $nextInternal(random, 24) * $intern_84 * maxRand - maxRand / 2;
    randx < 0?(randx = 1):randx > drawWidth && (randx = drawWidth - 1);
    randy = y_0 + $nextInternal(random, 24) * $intern_84 * maxRand - maxRand / 2;
    randy < 0?(randy = 1):randy > drawHeight && (randy = drawHeight - 1);
    bendPoint = ($clinit_ElkGraphFactory() , elkBendPoint = new ElkBendPointImpl , elkBendPoint);
    $setX_0(bendPoint, randx);
    $setY_0(bendPoint, randy);
    $add_21((!edgeSection.bendPoints && (edgeSection.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, edgeSection, 5)) , edgeSection.bendPoints), bendPoint);
  }
}

function $randomize_0(parent_0, random, aspectRatio, spacing, padding){
  var areaSqrt, drawArea, drawHeight, drawWidth, edge, edge$iterator, height, m, maxHeight, maxWidth, n, node, node$iterator, node$iterator0, nodesArea, source, source$iterator, totalHeight, totalWidth, width_0, x_0, y_0;
  nodesArea = 0;
  maxWidth = 0;
  maxHeight = 0;
  m = 1;
  for (node$iterator0 = new AbstractEList$EIterator((!parent_0.children && (parent_0.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parent_0, 10, 11)) , parent_0.children)); node$iterator0.cursor != node$iterator0.this$01_2.size_1();) {
    node = castTo($doNext(node$iterator0), 35);
    m += size_15(allOutgoingEdges(node));
    width_0 = node.width_0;
    maxWidth = $wnd.Math.max(maxWidth, width_0);
    height = node.height;
    maxHeight = $wnd.Math.max(maxHeight, height);
    nodesArea += width_0 * height;
  }
  n = (!parent_0.children && (parent_0.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parent_0, 10, 11)) , parent_0.children).size_0;
  drawArea = nodesArea + 2 * spacing * spacing * m * n;
  areaSqrt = $wnd.Math.sqrt(drawArea);
  drawWidth = $wnd.Math.max(areaSqrt * aspectRatio, maxWidth);
  drawHeight = $wnd.Math.max(areaSqrt / aspectRatio, maxHeight);
  for (node$iterator = new AbstractEList$EIterator((!parent_0.children && (parent_0.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parent_0, 10, 11)) , parent_0.children)); node$iterator.cursor != node$iterator.this$01_2.size_1();) {
    node = castTo($doNext(node$iterator), 35);
    x_0 = padding.left + ($nextInternal(random, 26) * $intern_81 + $nextInternal(random, 27) * $intern_82) * (drawWidth - node.width_0);
    y_0 = padding.left + ($nextInternal(random, 26) * $intern_81 + $nextInternal(random, 27) * $intern_82) * (drawHeight - node.height);
    $setX_1(node, x_0);
    $setY_1(node, y_0);
  }
  totalWidth = drawWidth + (padding.left + padding.right);
  totalHeight = drawHeight + (padding.top_0 + padding.bottom);
  for (source$iterator = new AbstractEList$EIterator((!parent_0.children && (parent_0.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parent_0, 10, 11)) , parent_0.children)); source$iterator.cursor != source$iterator.this$01_2.size_1();) {
    source = castTo($doNext(source$iterator), 35);
    for (edge$iterator = $iterator(allOutgoingEdges(source)); $hasNext_0(edge$iterator);) {
      edge = castTo($next_2(edge$iterator), 100);
      $isHierarchical(edge) || $randomize(edge, random, totalWidth, totalHeight);
    }
  }
  totalWidth += padding.left + padding.right;
  totalHeight += padding.top_0 + padding.bottom;
  resizeNode_1(parent_0, totalWidth, totalHeight, false, true);
}

function RandomLayoutProvider(){
}

defineClass(995, 197, $intern_100, RandomLayoutProvider);
_.layout = function layout_9(parentNode, progressMonitor){
  var aspectRatio, padding, random, randomSeed, spacing;
  $begin(progressMonitor, 'Random Layout', 1);
  if ((!parentNode.children && (parentNode.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, parentNode, 10, 11)) , parentNode.children).size_0 == 0) {
    $done_0(progressMonitor);
    return;
  }
  randomSeed = castTo($getProperty_0(parentNode, ($clinit_RandomLayouterOptions() , RANDOM_SEED_2)), 21);
  !!randomSeed && randomSeed.value_0 != 0?(random = new Random_0(randomSeed.value_0)):(random = new Random);
  aspectRatio = checkNotNull_1(castToDouble($getProperty_0(parentNode, ASPECT_RATIO_5)));
  spacing = checkNotNull_1(castToDouble($getProperty_0(parentNode, SPACING_NODE_NODE_6)));
  padding = castTo($getProperty_0(parentNode, PADDING_7), 116);
  $randomize_0(parentNode, random, aspectRatio, spacing, padding);
  $done_0(progressMonitor);
}
;
var Lorg_eclipse_elk_core_util_RandomLayoutProvider_2_classLit = createForClass('org.eclipse.elk.core.util', 'RandomLayoutProvider', 995);
function $clinit_ElkGraphAdapters$AbstractElkGraphElementAdapter(){
  $clinit_ElkGraphAdapters$AbstractElkGraphElementAdapter = emptyMethod;
  OFFSET_PROXY = new Property_2(($clinit_CoreOptions() , PORT_BORDER_OFFSET_0), 0);
}

defineClass(510, 1, {});
_.getPosition = function getPosition_1(){
  return new KVector_1(this.element.x_0, this.element.y_0);
}
;
_.getProperty = function getProperty_2(prop){
  if ($equals_8(prop, ($clinit_CoreOptions() , PORT_BORDER_OFFSET_0))) {
    return $getProperty_0(this.element, OFFSET_PROXY);
  }
  return $getProperty_0(this.element, prop);
}
;
_.getSize = function getSize_1(){
  return new KVector_1(this.element.width_0, this.element.height);
}
;
_.getVolatileId = function getVolatileId_1(){
  return this.id_0;
}
;
_.hasProperty = function hasProperty_2(prop){
  return $hasProperty_0(this.element, prop);
}
;
_.setPosition = function setPosition_1(pos){
  $setX_1(this.element, pos.x_0);
  $setY_1(this.element, pos.y_0);
}
;
_.setSize = function setSize_1(size_0){
  $setWidth_0(this.element, size_0.x_0);
  $setHeight_0(this.element, size_0.y_0);
}
;
_.setVolatileId = function setVolatileId_1(volatileId){
  this.id_0 = volatileId;
}
;
_.id_0 = 0;
var OFFSET_PROXY;
var Lorg_eclipse_elk_core_util_adapters_ElkGraphAdapters$AbstractElkGraphElementAdapter_2_classLit = createForClass('org.eclipse.elk.core.util.adapters', 'ElkGraphAdapters/AbstractElkGraphElementAdapter', 510);
function ElkGraphAdapters$ElkEdgeAdapter(edge){
  this.element = edge;
}

defineClass(512, 1, {771:1}, ElkGraphAdapters$ElkEdgeAdapter);
_.getLabels = function getLabels_2(){
  var l, l$iterator;
  if (!this.labelAdapters) {
    this.labelAdapters = newArrayListWithExpectedSize($getLabels_1(this.element).size_0);
    for (l$iterator = new AbstractEList$EIterator($getLabels_1(this.element)); l$iterator.cursor != l$iterator.this$01_2.size_1();) {
      l = castTo($doNext(l$iterator), 135);
      $add_4(this.labelAdapters, new ElkGraphAdapters$ElkLabelAdapter(l));
    }
  }
  return this.labelAdapters;
}
;
_.labelAdapters = null;
var Lorg_eclipse_elk_core_util_adapters_ElkGraphAdapters$ElkEdgeAdapter_2_classLit = createForClass('org.eclipse.elk.core.util.adapters', 'ElkGraphAdapters/ElkEdgeAdapter', 512);
function $getNodes_0(this$static){
  var n, n$iterator;
  if (!this$static.childNodes) {
    this$static.childNodes = newArrayListWithExpectedSize($getChildren(castTo(this$static.element, 35)).size_0);
    for (n$iterator = new AbstractEList$EIterator($getChildren(castTo(this$static.element, 35))); n$iterator.cursor != n$iterator.this$01_2.size_1();) {
      n = castTo($doNext(n$iterator), 35);
      $add_4(this$static.childNodes, new ElkGraphAdapters$ElkNodeAdapter(this$static, n));
    }
  }
  return this$static.childNodes;
}

function ElkGraphAdapters$ElkGraphAdapter(node){
  $clinit_ElkGraphAdapters$AbstractElkGraphElementAdapter();
  this.element = node;
}

defineClass(511, 510, {}, ElkGraphAdapters$ElkGraphAdapter);
_.getNodes = function getNodes_0(){
  return $getNodes_0(this);
}
;
_.childNodes = null;
var Lorg_eclipse_elk_core_util_adapters_ElkGraphAdapters$ElkGraphAdapter_2_classLit = createForClass('org.eclipse.elk.core.util.adapters', 'ElkGraphAdapters/ElkGraphAdapter', 511);
function ElkGraphAdapters$ElkLabelAdapter(label_0){
  $clinit_ElkGraphAdapters$AbstractElkGraphElementAdapter();
  this.element = label_0;
}

defineClass(593, 510, {281:1}, ElkGraphAdapters$ElkLabelAdapter);
var Lorg_eclipse_elk_core_util_adapters_ElkGraphAdapters$ElkLabelAdapter_2_classLit = createForClass('org.eclipse.elk.core.util.adapters', 'ElkGraphAdapters/ElkLabelAdapter', 593);
function $getLabels(this$static){
  var l, l$iterator;
  if (!this$static.labelAdapters) {
    this$static.labelAdapters = newArrayListWithExpectedSize(castTo(this$static.element, 35).getLabels_0().size_0);
    for (l$iterator = new AbstractEList$EIterator(castTo(this$static.element, 35).getLabels_0()); l$iterator.cursor != l$iterator.this$01_2.size_1();) {
      l = castTo($doNext(l$iterator), 135);
      $add_4(this$static.labelAdapters, new ElkGraphAdapters$ElkLabelAdapter(l));
    }
  }
  return this$static.labelAdapters;
}

function $getPorts_2(this$static){
  var p, p$iterator;
  if (!this$static.portAdapters) {
    this$static.portAdapters = newArrayListWithExpectedSize($getPorts_3(castTo(this$static.element, 35)).size_0);
    for (p$iterator = new AbstractEList$EIterator($getPorts_3(castTo(this$static.element, 35))); p$iterator.cursor != p$iterator.this$01_2.size_1();) {
      p = castTo($doNext(p$iterator), 123);
      $add_4(this$static.portAdapters, new ElkGraphAdapters$ElkPortAdapter(p));
    }
  }
  return this$static.portAdapters;
}

function ElkGraphAdapters$ElkNodeAdapter(parent_0, node){
  $clinit_ElkGraphAdapters$AbstractElkGraphElementAdapter();
  this.element = node;
  this.parentGraphAdapter = parent_0;
}

defineClass(592, 510, {769:1}, ElkGraphAdapters$ElkNodeAdapter);
_.getLabels = function getLabels_3(){
  return $getLabels(this);
}
;
_.getMargin = function getMargin_0(){
  var margins;
  return margins = castTo($getProperty_0(this.element, ($clinit_CoreOptions() , MARGINS_0)), 137) , !margins && (margins = new ElkMargin) , margins;
}
;
_.getPorts = function getPorts_0(){
  return $getPorts_2(this);
}
;
_.setMargin = function setMargin_0(margin){
  var newMargin;
  newMargin = new ElkMargin_2(margin);
  $setProperty_1(this.element, ($clinit_CoreOptions() , MARGINS_0), newMargin);
}
;
_.setPadding = function setPadding_0(padding){
  $setProperty_1(this.element, ($clinit_CoreOptions() , PADDING_5), new ElkPadding_1(padding));
}
;
_.getGraph = function getGraph_0(){
  return this.parentGraphAdapter;
}
;
_.getIncomingEdges = function getIncomingEdges_1(){
  var e, e$iterator;
  if (!this.incomingEdgeAdapters) {
    this.incomingEdgeAdapters = new ArrayList;
    for (e$iterator = $iterator(allIncomingEdges(castTo(this.element, 35))); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 100);
      $add_4(this.incomingEdgeAdapters, new ElkGraphAdapters$ElkEdgeAdapter(e));
    }
  }
  return this.incomingEdgeAdapters;
}
;
_.getOutgoingEdges = function getOutgoingEdges_1(){
  var e, e$iterator;
  if (!this.outgoingEdgeAdapters) {
    this.outgoingEdgeAdapters = new ArrayList;
    for (e$iterator = $iterator(allOutgoingEdges(castTo(this.element, 35))); $hasNext_0(e$iterator);) {
      e = castTo($next_2(e$iterator), 100);
      $add_4(this.outgoingEdgeAdapters, new ElkGraphAdapters$ElkEdgeAdapter(e));
    }
  }
  return this.outgoingEdgeAdapters;
}
;
_.isCompoundNode = function isCompoundNode_0(){
  return $getChildren(castTo(this.element, 35)).size_0 != 0 || checkNotNull_1(castToBoolean(castTo(this.element, 35).getProperty(($clinit_CoreOptions() , INSIDE_SELF_LOOPS_ACTIVATE_0))));
}
;
_.incomingEdgeAdapters = null;
_.labelAdapters = null;
_.outgoingEdgeAdapters = null;
_.parentGraphAdapter = null;
_.portAdapters = null;
var Lorg_eclipse_elk_core_util_adapters_ElkGraphAdapters$ElkNodeAdapter_2_classLit = createForClass('org.eclipse.elk.core.util.adapters', 'ElkGraphAdapters/ElkNodeAdapter', 592);
function $getLabels_0(this$static){
  var l, l$iterator;
  if (!this$static.labelAdapters) {
    this$static.labelAdapters = newArrayListWithExpectedSize(castTo(this$static.element, 123).getLabels_0().size_0);
    for (l$iterator = new AbstractEList$EIterator(castTo(this$static.element, 123).getLabels_0()); l$iterator.cursor != l$iterator.this$01_2.size_1();) {
      l = castTo($doNext(l$iterator), 135);
      $add_4(this$static.labelAdapters, new ElkGraphAdapters$ElkLabelAdapter(l));
    }
  }
  return this$static.labelAdapters;
}

function ElkGraphAdapters$ElkPortAdapter(port){
  this.element = port;
}

defineClass(1068, 510, {770:1}, ElkGraphAdapters$ElkPortAdapter);
_.getLabels = function getLabels_4(){
  return $getLabels_0(this);
}
;
_.getIncomingEdges = function getIncomingEdges_2(){
  var e, e$iterator;
  if (!this.incomingEdgeAdapters) {
    this.incomingEdgeAdapters = newArrayListWithCapacity(castTo(this.element, 123).getIncomingEdges_0().size_0);
    for (e$iterator = new AbstractEList$EIterator(castTo(this.element, 123).getIncomingEdges_0()); e$iterator.cursor != e$iterator.this$01_2.size_1();) {
      e = castTo($doNext(e$iterator), 100);
      $add_4(this.incomingEdgeAdapters, new ElkGraphAdapters$ElkEdgeAdapter(e));
    }
  }
  return this.incomingEdgeAdapters;
}
;
_.getOutgoingEdges = function getOutgoingEdges_2(){
  var e, e$iterator;
  if (!this.outgoingEdgeAdapters) {
    this.outgoingEdgeAdapters = newArrayListWithCapacity(castTo(this.element, 123).getOutgoingEdges_0().size_0);
    for (e$iterator = new AbstractEList$EIterator(castTo(this.element, 123).getOutgoingEdges_0()); e$iterator.cursor != e$iterator.this$01_2.size_1();) {
      e = castTo($doNext(e$iterator), 100);
      $add_4(this.outgoingEdgeAdapters, new ElkGraphAdapters$ElkEdgeAdapter(e));
    }
  }
  return this.outgoingEdgeAdapters;
}
;
_.getSide = function getSide_0(){
  return castTo(castTo(this.element, 123).getProperty(($clinit_CoreOptions() , PORT_SIDE_0)), 71);
}
;
_.hasCompoundConnections = function hasCompoundConnections_0(){
  var edge, edge$iterator, edge$iterator0, node, source, source$iterator, target, target$iterator;
  node = $getParent_3(castTo(this.element, 123));
  for (edge$iterator0 = new AbstractEList$EIterator(castTo(this.element, 123).getOutgoingEdges_0()); edge$iterator0.cursor != edge$iterator0.this$01_2.size_1();) {
    edge = castTo($doNext(edge$iterator0), 100);
    for (target$iterator = new AbstractEList$EIterator((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets)); target$iterator.cursor != target$iterator.this$01_2.size_1();) {
      target = castTo($doNext(target$iterator), 97);
      if (isDescendant_0(connectableShapeToNode(target), node)) {
        return true;
      }
       else if (connectableShapeToNode(target) == node && checkNotNull_1(castToBoolean($getProperty_0(edge, ($clinit_CoreOptions() , INSIDE_SELF_LOOPS_YO_0))))) {
        return true;
      }
    }
  }
  for (edge$iterator = new AbstractEList$EIterator(castTo(this.element, 123).getIncomingEdges_0()); edge$iterator.cursor != edge$iterator.this$01_2.size_1();) {
    edge = castTo($doNext(edge$iterator), 100);
    for (source$iterator = new AbstractEList$EIterator((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources)); source$iterator.cursor != source$iterator.this$01_2.size_1();) {
      source = castTo($doNext(source$iterator), 97);
      if (isDescendant_0(connectableShapeToNode(source), node)) {
        return true;
      }
    }
  }
  return false;
}
;
_.incomingEdgeAdapters = null;
_.labelAdapters = null;
_.outgoingEdgeAdapters = null;
var Lorg_eclipse_elk_core_util_adapters_ElkGraphAdapters$ElkPortAdapter_2_classLit = createForClass('org.eclipse.elk.core.util.adapters', 'ElkGraphAdapters/ElkPortAdapter', 1068);
var Lorg_eclipse_emf_ecore_EObject_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EObject');
var Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit = createForInterface('org.eclipse.elk.graph', 'EMapPropertyHolder');
var Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkBendPoint');
var Lorg_eclipse_elk_graph_ElkGraphElement_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkGraphElement');
var Lorg_eclipse_elk_graph_ElkShape_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkShape');
var Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkConnectableShape');
var Lorg_eclipse_elk_graph_ElkEdge_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkEdge');
var Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkEdgeSection');
var Lorg_eclipse_emf_ecore_EModelElement_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EModelElement');
var Lorg_eclipse_emf_ecore_EFactory_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EFactory');
function $clinit_ElkGraphFactory(){
  $clinit_ElkGraphFactory = emptyMethod;
  eINSTANCE = init_1();
}

var eINSTANCE;
var Lorg_eclipse_emf_ecore_ENamedElement_2_classLit = createForInterface('org.eclipse.emf.ecore', 'ENamedElement');
var Lorg_eclipse_emf_ecore_EPackage_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EPackage');
function $clinit_ElkGraphPackage(){
  $clinit_ElkGraphPackage = emptyMethod;
  eINSTANCE_0 = init_2();
}

var eINSTANCE_0;
function $clinit_ElkGraphPackage$Literals(){
  $clinit_ElkGraphPackage$Literals = emptyMethod;
  $clinit_ElkGraphPackage();
  EMAP_PROPERTY_HOLDER = eINSTANCE_0.eMapPropertyHolderEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.eMapPropertyHolderEClass), 0), 17);
  ELK_GRAPH_ELEMENT = eINSTANCE_0.elkGraphElementEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkGraphElementEClass), 0), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkGraphElementEClass), 1), 29);
  ELK_SHAPE = eINSTANCE_0.elkShapeEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkShapeEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkShapeEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkShapeEClass), 2), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkShapeEClass), 3), 29);
  ELK_LABEL = eINSTANCE_0.elkLabelEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkLabelEClass), 0), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkLabelEClass), 1), 29);
  ELK_CONNECTABLE_SHAPE = eINSTANCE_0.elkConnectableShapeEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkConnectableShapeEClass), 0), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkConnectableShapeEClass), 1), 17);
  ELK_NODE = eINSTANCE_0.elkNodeEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkNodeEClass), 0), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkNodeEClass), 1), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkNodeEClass), 2), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkNodeEClass), 3), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkNodeEClass), 4), 29);
  ELK_PORT = eINSTANCE_0.elkPortEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkPortEClass), 0), 17);
  ELK_EDGE = eINSTANCE_0.elkEdgeEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeEClass), 0), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeEClass), 1), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeEClass), 2), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeEClass), 3), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeEClass), 4), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeEClass), 5), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeEClass), 6), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeEClass), 7), 29);
  ELK_BEND_POINT = eINSTANCE_0.elkBendPointEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkBendPointEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkBendPointEClass), 1), 29);
  ELK_EDGE_SECTION = eINSTANCE_0.elkEdgeSectionEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 2), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 3), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 4), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 5), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 6), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 7), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 8), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 9), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkEdgeSectionEClass), 10), 29);
  ELK_PROPERTY_TO_VALUE_MAP_ENTRY = eINSTANCE_0.elkPropertyToValueMapEntryEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkPropertyToValueMapEntryEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_0.elkPropertyToValueMapEntryEClass), 1), 29);
}

var ELK_BEND_POINT, ELK_CONNECTABLE_SHAPE, ELK_EDGE, ELK_EDGE_SECTION, ELK_GRAPH_ELEMENT, ELK_LABEL, ELK_NODE, ELK_PORT, ELK_PROPERTY_TO_VALUE_MAP_ENTRY, ELK_SHAPE, EMAP_PROPERTY_HOLDER;
var Lorg_eclipse_elk_graph_ElkLabel_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkLabel');
var Lorg_eclipse_elk_graph_ElkNode_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkNode');
var Lorg_eclipse_elk_graph_ElkPort_2_classLit = createForInterface('org.eclipse.elk.graph', 'ElkPort');
function $eNotify(this$static, notification){
  var eAdapters, i, size_0;
  eAdapters = this$static.eBasicAdapterArray();
  if (eAdapters != null && this$static.eDeliver()) {
    for (i = 0 , size_0 = eAdapters.length; i < size_0; ++i) {
      eAdapters[i].notifyChanged(notification);
    }
  }
}

defineClass(89, 1, $intern_137);
_.eBasicAdapterArray = function eBasicAdapterArray(){
  this.eBasicAdapters();
  return null;
}
;
_.eBasicAdapters = function eBasicAdapters(){
  return null;
}
;
_.eBasicHasAdapters = function eBasicHasAdapters(){
  return this.eBasicAdapters() , false;
}
;
_.eDeliver = function eDeliver(){
  return false;
}
;
_.eNotify = function eNotify(notification){
  $eNotify(this, notification);
}
;
var Lorg_eclipse_emf_common_notify_impl_BasicNotifierImpl_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'BasicNotifierImpl', 89);
function $eAttribute(eClass, name_0){
  var eStructuralFeature;
  eStructuralFeature = $getEStructuralFeature_0(eClass, name_0);
  if (instanceOf(eStructuralFeature, 348)) {
    return castTo(eStructuralFeature, 29);
  }
  throw toJs(new IllegalArgumentException_0("The feature '" + name_0 + "' is not a valid attribute"));
}

function $eBasicSetContainer(this$static, newContainer, newContainerFeatureID, msgs){
  var newResource, notification, oldContainer, oldContainerFeatureID, oldResource;
  oldContainer = this$static.eInternalContainer();
  oldResource = this$static.eDirectResource();
  newResource = null;
  if (oldResource) {
    if (!!newContainer && (eContainmentFeature(this$static, newContainer, newContainerFeatureID).eFlags & $intern_66) == 0) {
      msgs = $basicRemove_0(oldResource.getContents(), this$static, msgs);
      this$static.eSetDirectResource(null);
      newResource = newContainer.eInternalResource();
    }
     else {
      oldResource = null;
    }
  }
   else {
    !!oldContainer && (oldResource = oldContainer.eInternalResource());
    !!newContainer && (newResource = newContainer.eInternalResource());
  }
  oldResource != newResource && !!oldResource && oldResource.detached(this$static);
  oldContainerFeatureID = this$static.eContainerFeatureID_0();
  this$static.eBasicSetContainer(newContainer, newContainerFeatureID);
  oldResource != newResource && !!newResource && newResource.attached(this$static);
  if (this$static.eBasicHasAdapters() && this$static.eDeliver()) {
    if (!!oldContainer && oldContainerFeatureID >= 0 && oldContainerFeatureID != newContainerFeatureID) {
      notification = new ENotificationImpl_1(this$static, 1, oldContainerFeatureID, oldContainer, null);
      !msgs?(msgs = notification):msgs.add_4(notification);
    }
    if (newContainerFeatureID >= 0) {
      notification = new ENotificationImpl_1(this$static, 1, newContainerFeatureID, oldContainerFeatureID == newContainerFeatureID?oldContainer:null, newContainer);
      !msgs?(msgs = notification):msgs.add_4(notification);
    }
  }
  return msgs;
}

function $eContainer(this$static){
  var eContainerFeatureID, eContainerFeatureID0, notificationChain, resolved, result;
  result = this$static.eInternalContainer();
  if (result) {
    if (result.eIsProxy()) {
      resolved = $eResolveProxy(this$static, result);
      if (resolved != result) {
        eContainerFeatureID0 = this$static.eContainerFeatureID_0();
        notificationChain = (eContainerFeatureID = this$static.eContainerFeatureID_0() , eContainerFeatureID >= 0?this$static.eBasicRemoveFromContainerFeature(null):this$static.eInternalContainer().eInverseRemove(this$static, -1 - eContainerFeatureID, null, null));
        this$static.eBasicSetContainer(castTo(resolved, 46), eContainerFeatureID0);
        !!notificationChain && notificationChain.dispatch_0();
        this$static.eBasicHasAdapters() && this$static.eDeliver() && eContainerFeatureID0 > -1 && $eNotify(this$static, new ENotificationImpl_1(this$static, 9, eContainerFeatureID0, result, resolved));
        return resolved;
      }
    }
  }
  return result;
}

function $eDynamicGet(this$static, dynamicFeatureID, eFeature, resolve, coreType){
  return dynamicFeatureID < 0?$eOpenGet(this$static, eFeature, resolve):castTo(eFeature, 63).getSettingDelegate().dynamicGet_0(this$static, this$static.eSettings_0(), dynamicFeatureID, resolve, coreType);
}

function $eDynamicIsSet(this$static, dynamicFeatureID, eFeature){
  return dynamicFeatureID < 0?$eOpenIsSet(this$static, eFeature):castTo(eFeature, 63).getSettingDelegate().dynamicIsSet(this$static, this$static.eSettings_0(), dynamicFeatureID);
}

function $eDynamicSet(this$static, dynamicFeatureID, eFeature, newValue){
  if (dynamicFeatureID < 0) {
    $eOpenSet(this$static, eFeature, newValue);
  }
   else {
    if (!eFeature.isChangeable()) {
      throw toJs(new IllegalArgumentException_0("The feature '" + eFeature.getName() + "' is not a valid changeable feature"));
    }
    castTo(eFeature, 63).getSettingDelegate().dynamicSet_0(this$static, this$static.eSettings_0(), dynamicFeatureID, newValue);
  }
}

function $eGet(this$static, featureID0, resolve, coreType){
  var dynamicFeatureID, eFeature, featureID;
  eFeature = $getEStructuralFeature(this$static.eClass_0(), featureID0);
  dynamicFeatureID = featureID0 - this$static.eStaticFeatureCount();
  return dynamicFeatureID < 0?(featureID = this$static.eDerivedStructuralFeatureID_0(eFeature) , featureID >= 0?this$static.eGet(featureID, resolve, true):$eOpenGet(this$static, eFeature, resolve)):castTo(eFeature, 63).getSettingDelegate().dynamicGet_0(this$static, this$static.eSettings_0(), dynamicFeatureID, resolve, coreType);
}

function $eGet_0(this$static, eFeature){
  var featureID;
  return featureID = this$static.eDerivedStructuralFeatureID_0(eFeature) , featureID >= 0?this$static.eGet(featureID, true, true):$eOpenGet(this$static, eFeature, true);
}

function $eGet_1(this$static, eFeature, resolve){
  var featureID;
  return featureID = this$static.eDerivedStructuralFeatureID_0(eFeature) , featureID >= 0?this$static.eGet(featureID, resolve, true):$eOpenGet(this$static, eFeature, resolve);
}

function $eGet_2(this$static, eFeature){
  var featureID;
  featureID = $getFeatureID(this$static.eClass, eFeature);
  return featureID >= 0?$eGet(this$static, featureID, true, true):$eOpenGet(this$static, eFeature, true);
}

function $eInternalResource(this$static){
  var count, eContainer, result;
  result = this$static.eDirectResource();
  if (!result) {
    count = 0;
    for (eContainer = this$static.eInternalContainer(); eContainer; eContainer = eContainer.eInternalContainer()) {
      if (++count > $intern_70) {
        return eContainer.eInternalResource();
      }
      result = eContainer.eDirectResource();
      if (!!result || eContainer == this$static) {
        break;
      }
    }
  }
  return result;
}

function $eInverseAdd(this$static, otherEnd, featureID, msgs){
  var eContainerFeatureID;
  if (featureID >= 0) {
    return this$static.eInverseAdd_0(otherEnd, featureID, msgs);
  }
   else {
    !!this$static.eInternalContainer() && (msgs = (eContainerFeatureID = this$static.eContainerFeatureID_0() , eContainerFeatureID >= 0?this$static.eBasicRemoveFromContainerFeature(msgs):this$static.eInternalContainer().eInverseRemove(this$static, -1 - eContainerFeatureID, null, msgs)));
    return this$static.eBasicSetContainer_0(otherEnd, featureID, msgs);
  }
}

function $eInverseRemove(this$static, otherEnd, featureID, msgs){
  return featureID >= 0?this$static.eInverseRemove_0(otherEnd, featureID, msgs):this$static.eBasicSetContainer_0(null, featureID, msgs);
}

function $eIsSet(this$static, featureID0){
  var dynamicFeatureID, eFeature, featureID;
  eFeature = $getEStructuralFeature(this$static.eClass_0(), featureID0);
  dynamicFeatureID = featureID0 - this$static.eStaticFeatureCount();
  return dynamicFeatureID < 0?(featureID = this$static.eDerivedStructuralFeatureID_0(eFeature) , featureID >= 0?this$static.eIsSet(featureID):$eOpenIsSet(this$static, eFeature)):dynamicFeatureID < 0?$eOpenIsSet(this$static, eFeature):castTo(eFeature, 63).getSettingDelegate().dynamicIsSet(this$static, this$static.eSettings_0(), dynamicFeatureID);
}

function $eNotificationRequired(this$static){
  return this$static.eBasicHasAdapters() && this$static.eDeliver();
}

function $eObjectForURIFragmentPredicate(this$static, predicate, eReference){
  var eAttribute, eDataType, eFactory, eReferenceType, end, featureMapEntries, i, index_0, length_0, values;
  featureMapEntries = new ArrayList;
  length_0 = predicate.length;
  eReferenceType = $getEReferenceType(eReference);
  for (i = 0; i < length_0; ++i) {
    index_0 = $indexOf_2(predicate, fromCodePoint(61), i);
    eAttribute = $eAttribute(eReferenceType, predicate.substr(i, index_0 - i));
    eDataType = $getEAttributeType(eAttribute);
    eFactory = eDataType.getEPackage().getEFactoryInstance();
    switch ($charAt(predicate, ++index_0)) {
      case 39:
        {
          end = $indexOf_0(predicate, 39, ++index_0);
          $add_4(featureMapEntries, new BasicEObjectImpl$1(eAttribute, eDecodeValue(predicate.substr(index_0, end - index_0), eFactory, eDataType)));
          i = end + 1;
          break;
        }

      case 34:
        {
          end = $indexOf_0(predicate, 34, ++index_0);
          $add_4(featureMapEntries, new BasicEObjectImpl$1(eAttribute, eDecodeValue(predicate.substr(index_0, end - index_0), eFactory, eDataType)));
          i = end + 1;
          break;
        }

      case 91:
        {
          values = new ArrayList;
          $add_4(featureMapEntries, new BasicEObjectImpl$1(eAttribute, values));
          LOOP: for (;;) {
            switch ($charAt(predicate, ++index_0)) {
              case 39:
                {
                  end = $indexOf_0(predicate, 39, ++index_0);
                  $add_4(values, eDecodeValue(predicate.substr(index_0, end - index_0), eFactory, eDataType));
                  index_0 = end + 1;
                  break;
                }

              case 34:
                {
                  end = $indexOf_0(predicate, 34, ++index_0);
                  $add_4(values, eDecodeValue(predicate.substr(index_0, end - index_0), eFactory, eDataType));
                  index_0 = end + 1;
                  break;
                }

              case 110:
                {
                  ++index_0;
                  if (predicate.indexOf('ull', index_0) == index_0) {
                    values.array[values.array.length] = null;
                  }
                   else {
                    throw toJs(new RuntimeException_0('Expecting null'));
                  }
                  index_0 += 3;
                  break;
                }

            }
            if (index_0 < length_0) {
              switch (predicate.charCodeAt(index_0)) {
                case 44:
                  {
                    break;
                  }

                case 93:
                  {
                    break LOOP;
                  }

                default:{
                    throw toJs(new RuntimeException_0('Expecting , or ]'));
                  }

              }
            }
             else {
              break;
            }
          }
          i = index_0 + 1;
          break;
        }

      case 110:
        {
          ++index_0;
          if (predicate.indexOf('ull', index_0) == index_0) {
            $add_4(featureMapEntries, new BasicEObjectImpl$1(eAttribute, null));
          }
           else {
            throw toJs(new RuntimeException_0('Expecting null'));
          }
          i = index_0 + 3;
          break;
        }

    }
    if (i < length_0) {
      if (predicate.charCodeAt(i) != 44) {
        throw toJs(new RuntimeException_0('Expecting ,'));
      }
    }
     else {
      break;
    }
  }
  return $eObjectForURIFragmentPredicate_0(this$static, featureMapEntries, eReference);
}

function $eObjectForURIFragmentPredicate_0(this$static, predicate, eReference){
  var actualValue, eObject, eObject$iterator, entry, entryFeature, entryValue, featureID, i, list, size_0;
  size_0 = predicate.array.length;
  list = (featureID = this$static.eDerivedStructuralFeatureID_0(eReference) , castTo(featureID >= 0?this$static.eGet(featureID, false, true):$eOpenGet(this$static, eReference, false), 52));
  LOOP: for (eObject$iterator = list.iterator_0(); eObject$iterator.hasNext_0();) {
    eObject = castTo(eObject$iterator.next_1(), 51);
    for (i = 0; i < size_0; ++i) {
      entry = (checkCriticalElementIndex(i, predicate.array.length) , castTo(predicate.array[i], 76));
      entryValue = entry.getValue();
      entryFeature = entry.getEStructuralFeature();
      actualValue = eObject.eGet_1(entryFeature, false);
      if (entryValue == null?actualValue != null:!equals_Ljava_lang_Object__Z__devirtual$(entryValue, actualValue)) {
        continue LOOP;
      }
    }
    return eObject;
  }
  return null;
}

function $eObjectForURIFragmentSegment(this$static, uriFragmentSegment){
  var dotIndex, eList, eReference, exception, index_0, lastChar, lastIndex, position, predicate, result;
  lastIndex = uriFragmentSegment.length - 1;
  lastChar = uriFragmentSegment.charCodeAt(lastIndex);
  if (lastChar == 93) {
    index_0 = $indexOf_1(uriFragmentSegment, fromCodePoint(91));
    if (index_0 >= 0) {
      eReference = $eReference(this$static, uriFragmentSegment.substr(1, index_0 - 1));
      predicate = uriFragmentSegment.substr(index_0 + 1, lastIndex - (index_0 + 1));
      return $eObjectForURIFragmentPredicate(this$static, predicate, eReference);
    }
  }
   else {
    dotIndex = -1;
    if (/\d/.test(String.fromCharCode(lastChar))) {
      dotIndex = $lastIndexOf_0(uriFragmentSegment, fromCodePoint(46), lastIndex - 1);
      if (dotIndex >= 0) {
        eList = castTo($eGet_1(this$static, $eStructuralFeature(this$static, uriFragmentSegment.substr(1, dotIndex - 1)), false), 52);
        try {
          position = __parseAndValidateInt(uriFragmentSegment.substr(dotIndex + 1, uriFragmentSegment.length - (dotIndex + 1)), $intern_43, $intern_0);
        }
         catch ($e0) {
          $e0 = toJava($e0);
          if (instanceOf($e0, 120)) {
            exception = $e0;
            throw toJs(new WrappedException(exception));
          }
           else 
            throw toJs($e0);
        }
        if (position < eList.size_1()) {
          result = eList.get_3(position);
          instanceOf(result, 76) && (result = castTo(result, 76).getValue());
          return castTo(result, 51);
        }
      }
    }
    if (dotIndex < 0) {
      return castTo($eGet_1(this$static, $eStructuralFeature(this$static, uriFragmentSegment.substr(1, uriFragmentSegment.length - 1)), false), 51);
    }
  }
  return null;
}

function $eOpenGet(this$static, eFeature, resolve){
  var featureID, featureMap, openFeature;
  openFeature = $getAffiliation(($clinit_ExtendedMetaData() , INSTANCE_11), this$static.eClass_0(), eFeature);
  if (openFeature) {
    $clinit_FeatureMapUtil();
    castTo(openFeature, 63).isFeatureMap_0() || (openFeature = $getGroup($getExtendedMetaData_1(INSTANCE_11, openFeature)));
    featureMap = (featureID = this$static.eDerivedStructuralFeatureID_0(openFeature) , castTo(featureID >= 0?this$static.eGet(featureID, true, true):$eOpenGet(this$static, openFeature, true), 188));
    return castTo(featureMap, 248).get_7(eFeature, resolve);
  }
   else {
    throw toJs(new IllegalArgumentException_0("The feature '" + eFeature.getName() + "' is not a valid feature"));
  }
}

function $eOpenIsSet(this$static, eFeature){
  var featureID, featureMap, openFeature;
  openFeature = $getAffiliation(($clinit_ExtendedMetaData() , INSTANCE_11), this$static.eClass_0(), eFeature);
  if (openFeature) {
    $clinit_FeatureMapUtil();
    castTo(openFeature, 63).isFeatureMap_0() || (openFeature = $getGroup($getExtendedMetaData_1(INSTANCE_11, openFeature)));
    featureMap = (featureID = this$static.eDerivedStructuralFeatureID_0(openFeature) , castTo(featureID >= 0?this$static.eGet(featureID, true, true):$eOpenGet(this$static, openFeature, true), 188));
    return castTo(featureMap, 248).isSet_1(eFeature);
  }
   else {
    throw toJs(new IllegalArgumentException_0("The feature '" + eFeature.getName() + "' is not a valid feature"));
  }
}

function $eOpenSet(this$static, eFeature, newValue){
  var featureID, featureMap, openFeature;
  openFeature = $getAffiliation(($clinit_ExtendedMetaData() , INSTANCE_11), this$static.eClass_0(), eFeature);
  if (openFeature) {
    $clinit_FeatureMapUtil();
    if (!castTo(openFeature, 63).isFeatureMap_0()) {
      openFeature = $getGroup($getExtendedMetaData_1(INSTANCE_11, openFeature));
      if (!openFeature) {
        throw toJs(new IllegalArgumentException_0("The feature '" + eFeature.getName() + "' is not a valid changeable feature"));
      }
    }
    featureMap = (featureID = this$static.eDerivedStructuralFeatureID_0(openFeature) , castTo(featureID >= 0?this$static.eGet(featureID, true, true):$eOpenGet(this$static, openFeature, true), 188));
    castTo(featureMap, 248).set_3(eFeature, newValue);
  }
   else {
    throw toJs(new IllegalArgumentException_0("The feature '" + eFeature.getName() + "' is not a valid changeable feature"));
  }
}

function $eReference(this$static, name_0){
  var eStructuralFeature;
  eStructuralFeature = $getEStructuralFeature_0(this$static.eClass_0(), name_0);
  if (instanceOf(eStructuralFeature, 66)) {
    return castTo(eStructuralFeature, 17);
  }
  throw toJs(new IllegalArgumentException_0("The feature '" + name_0 + "' is not a valid reference"));
}

function $eResolveProxy(this$static, proxy){
  var eResource, resourceContext, result;
  result = (resourceContext = $eInternalResource(this$static) , resolve_20((resourceContext?resourceContext.getResourceSet():null , proxy)));
  if (result == proxy) {
    eResource = $eInternalResource(this$static);
    !!eResource && eResource.getResourceSet();
  }
  return result;
}

function $eSet(this$static, featureID0, newValue){
  var dynamicFeatureID, eFeature, featureID;
  eFeature = $getEStructuralFeature(this$static.eClass_0(), featureID0);
  dynamicFeatureID = featureID0 - this$static.eStaticFeatureCount();
  if (dynamicFeatureID < 0) {
    if (!eFeature) {
      throw toJs(new IllegalArgumentException_0('The feature ID' + featureID0 + ' is not a valid feature ID'));
    }
     else if (eFeature.isChangeable()) {
      featureID = this$static.eDerivedStructuralFeatureID_0(eFeature);
      featureID >= 0?this$static.eSet(featureID, newValue):$eOpenSet(this$static, eFeature, newValue);
    }
     else {
      throw toJs(new IllegalArgumentException_0("The feature '" + eFeature.getName() + "' is not a valid changeable feature"));
    }
  }
   else {
    $eDynamicSet(this$static, dynamicFeatureID, eFeature, newValue);
  }
}

function $eSet_0(this$static, eFeature, newValue){
  var featureID;
  featureID = $getFeatureID(this$static.eClass, eFeature);
  featureID >= 0?$eSet(this$static, featureID, newValue):$eOpenSet(this$static, eFeature, newValue);
}

function $eSettings(this$static){
  var size_0;
  if (!this$static.eHasSettings()) {
    size_0 = $getFeatureCount(this$static.eClass_0()) - this$static.eStaticFeatureCount();
    this$static.eProperties_0().allocateSettings(size_0);
  }
  return this$static.eBasicProperties();
}

function $eStructuralFeature(this$static, name_0){
  var eStructuralFeature;
  eStructuralFeature = $getEStructuralFeature_0(this$static.eClass_0(), name_0);
  if (!eStructuralFeature) {
    throw toJs(new IllegalArgumentException_0("The feature '" + name_0 + "' is not a valid feature"));
  }
  return eStructuralFeature;
}

function $toString_12(this$static){
  var result;
  result = new StringBuilder_1($getName(this$static.___clazz));
  result.string += '@';
  $append_11(result, (hashCode__I__devirtual$(this$static) >>> 0).toString(16));
  if (this$static.eIsProxy()) {
    result.string += ' (eProxyURI: ';
    $append_10(result, this$static.eProxyURI_0());
    if (this$static.eDynamicClass()) {
      result.string += ' eClass: ';
      $append_10(result, this$static.eDynamicClass());
    }
    result.string += ')';
  }
   else if (this$static.eDynamicClass()) {
    result.string += ' (eClass: ';
    $append_10(result, this$static.eDynamicClass());
    result.string += ')';
  }
  return result.string;
}

function eContainmentFeature(eObject, eContainer, eContainerFeatureID){
  var eFeature, entryFeature, entryReference, featureMap, i, size_0;
  if (!eContainer) {
    return null;
  }
   else {
    if (eContainerFeatureID <= -1) {
      eFeature = $getEStructuralFeature(eContainer.eClass_0(), -1 - eContainerFeatureID);
      if (instanceOf(eFeature, 66)) {
        return castTo(eFeature, 17);
      }
       else {
        featureMap = castTo(eContainer.eGet_0(eFeature), 188);
        for (i = 0 , size_0 = featureMap.size_1(); i < size_0; ++i) {
          if (featureMap.getValue_0(i) === eObject) {
            entryFeature = featureMap.getEStructuralFeature_0(i);
            if (instanceOf(entryFeature, 66)) {
              entryReference = castTo(entryFeature, 17);
              if ((entryReference.eFlags & $intern_138) != 0) {
                return entryReference;
              }
            }
          }
        }
        throw toJs(new IllegalStateException_0('The containment feature could not be located'));
      }
    }
     else {
      return $getEOpposite(castTo($getEStructuralFeature(eObject.eClass_0(), eContainerFeatureID), 17));
    }
  }
}

function eDecodeValue(encodedValue, eFactory, eDataType){
  var literal, value_0;
  literal = decode(encodedValue);
  value_0 = eFactory.createFromString(eDataType, literal);
  return value_0;
}

defineClass(93, 89, $intern_139);
_.eNotificationRequired = function eNotificationRequired(){
  return $eNotificationRequired(this);
}
;
_.eBaseStructuralFeatureID = function eBaseStructuralFeatureID(derivedFeatureID, baseClass){
  return derivedFeatureID;
}
;
_.eBasicProperties = function eBasicProperties(){
  throw toJs(new UnsupportedOperationException);
}
;
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature(msgs){
  var inverseFeature;
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature(this.eClass_0(), this.eContainerFeatureID_0()), 17)) , this.eInternalContainer().eInverseRemove(this, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}
;
_.eBasicSetContainer = function eBasicSetContainer(newContainer, newContainerFeatureID){
  throw toJs(new UnsupportedOperationException);
}
;
_.eBasicSetContainer_0 = function eBasicSetContainer_0(newContainer, newContainerFeatureID, msgs){
  return $eBasicSetContainer(this, newContainer, newContainerFeatureID, msgs);
}
;
_.eClass_0 = function eClass_0(){
  var result;
  if (this.eBasicProperties()) {
    result = this.eBasicProperties().getEClass();
    if (result) {
      return result;
    }
  }
  return this.eStaticClass();
}
;
_.eContainer_0 = function eContainer_0(){
  return $eContainer(this);
}
;
_.eContainerFeatureID_0 = function eContainerFeatureID_0(){
  throw toJs(new UnsupportedOperationException);
}
;
_.eContents_0 = function eContents_0(){
  var eStructuralFeatures, result;
  result = this.eProperties_0().getEContents();
  !result && this.eBasicProperties().setEContents(result = ($clinit_EContentsEList() , eStructuralFeatures = $containments($getEAllStructuralFeatures(this.eClass_0())) , eStructuralFeatures == null?EMPTY_CONTENTS_ELIST:new EContentsEList(this, eStructuralFeatures)));
  return result;
}
;
_.eDerivedStructuralFeatureID = function eDerivedStructuralFeatureID(baseFeatureID, baseClass){
  return baseFeatureID;
}
;
_.eDerivedStructuralFeatureID_0 = function eDerivedStructuralFeatureID_0(eStructuralFeature){
  var containerClass;
  containerClass = eStructuralFeature.getContainerClass();
  return !containerClass?$getFeatureID(this.eClass_0(), eStructuralFeature):eStructuralFeature.getFeatureID_0();
}
;
_.eDirectResource = function eDirectResource(){
  var eProperties;
  eProperties = this.eBasicProperties();
  return !eProperties?null:eProperties.getEResource();
}
;
_.eDynamicClass = function eDynamicClass(){
  return !this.eBasicProperties()?null:this.eBasicProperties().getEClass();
}
;
_.eGet = function eGet(featureID, resolve, coreType){
  return $eGet(this, featureID, resolve, coreType);
}
;
_.eGet_0 = function eGet_0(eFeature){
  return $eGet_0(this, eFeature);
}
;
_.eGet_1 = function eGet_1(eFeature, resolve){
  return $eGet_1(this, eFeature, resolve);
}
;
_.eHasSettings = function eHasSettings(){
  var eProperties;
  eProperties = this.eBasicProperties();
  return !!eProperties && eProperties.hasSettings();
}
;
_.eInternalContainer = function eInternalContainer_0(){
  throw toJs(new UnsupportedOperationException);
}
;
_.eInternalResource = function eInternalResource(){
  return $eInternalResource(this);
}
;
_.eInverseAdd = function eInverseAdd(otherEnd, featureID, baseClass, msgs){
  return $eInverseAdd(this, otherEnd, featureID, msgs);
}
;
_.eInverseAdd_0 = function eInverseAdd_0(otherEnd, featureID, msgs){
  var feature;
  return feature = castTo($getEStructuralFeature(this.eClass_0(), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, this.eSettings_0(), featureID - this.eStaticFeatureCount(), otherEnd, msgs);
}
;
_.eInverseRemove = function eInverseRemove(otherEnd, featureID, baseClass, msgs){
  return $eInverseRemove(this, otherEnd, featureID, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_0(otherEnd, featureID, msgs){
  var feature;
  return feature = castTo($getEStructuralFeature(this.eClass_0(), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, this.eSettings_0(), featureID - this.eStaticFeatureCount(), otherEnd, msgs);
}
;
_.eIsProxy = function eIsProxy(){
  return !!this.eBasicProperties() && (this.eBasicProperties().getEProxyURI() , false);
}
;
_.eIsSet = function eIsSet(featureID){
  return $eIsSet(this, featureID);
}
;
_.eIsSet_0 = function eIsSet_0(eFeature){
  var featureID;
  return featureID = this.eDerivedStructuralFeatureID_0(eFeature) , featureID >= 0?this.eIsSet(featureID):$eOpenIsSet(this, eFeature);
}
;
_.eObjectForURIFragmentSegment = function eObjectForURIFragmentSegment(uriFragmentSegment){
  return $eObjectForURIFragmentSegment(this, uriFragmentSegment);
}
;
_.eProperties_0 = function eProperties_0(){
  throw toJs(new UnsupportedOperationException);
}
;
_.eProxyURI_0 = function eProxyURI(){
  return !this.eBasicProperties()?null:this.eBasicProperties().getEProxyURI();
}
;
_.eResource_0 = function eResource_0(){
  return $eInternalResource(this);
}
;
_.eSet = function eSet(featureID, newValue){
  $eSet(this, featureID, newValue);
}
;
_.eSetClass = function eSetClass(eClass){
  this.eProperties_0().setEClass(eClass);
}
;
_.eSetDirectResource = function eSetDirectResource(resource){
  this.eProperties_0().setEResource(resource);
}
;
_.eSetResource = function eSetResource(resource, notifications){
  var eContainerFeatureID, oldContainer, oldContainerResource, oldResource;
  oldResource = this.eDirectResource();
  if (!!oldResource && !!resource) {
    notifications = $basicRemove_0(oldResource.getContents(), this, notifications);
    oldResource.detached(this);
  }
  oldContainer = this.eInternalContainer();
  if (oldContainer) {
    if ((eContainmentFeature(this, this.eInternalContainer(), this.eContainerFeatureID_0()).eFlags & $intern_66) != 0) {
      oldContainerResource = oldContainer.eInternalResource();
      !!oldContainerResource && (!resource?oldContainerResource.attached(this):!oldResource && oldContainerResource.detached(this));
    }
     else {
      notifications = (eContainerFeatureID = this.eContainerFeatureID_0() , eContainerFeatureID >= 0?this.eBasicRemoveFromContainerFeature(notifications):this.eInternalContainer().eInverseRemove(this, -1 - eContainerFeatureID, null, notifications));
      notifications = this.eBasicSetContainer_0(null, -1, notifications);
    }
  }
  this.eSetDirectResource(resource);
  return notifications;
}
;
_.eSettings_0 = function eSettings(){
  return $eSettings(this);
}
;
_.eStaticClass = function eStaticClass(){
  return ($clinit_EcorePackage() , eINSTANCE_2).eObjectEClass;
}
;
_.eStaticFeatureCount = function eStaticFeatureCount(){
  return $getFeatureCount(this.eStaticClass());
}
;
_.toString_0 = function toString_121(){
  return $toString_12(this);
}
;
var Lorg_eclipse_emf_ecore_impl_BasicEObjectImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'BasicEObjectImpl', 93);
function $clinit_EStructuralFeature$Internal$DynamicValueHolder(){
  $clinit_EStructuralFeature$Internal$DynamicValueHolder = emptyMethod;
  NIL = new EStructuralFeature$Internal$DynamicValueHolder$1;
}

var NIL;
function $addField(this$static, field, value_0){
  var bit, fieldCount, fieldIndex, oldStorage, result, sourceIndex, targetIndex;
  fieldCount = bitCount(this$static.eFlags_0 & 254);
  if (fieldCount == 0) {
    this$static.eStorage = value_0;
  }
   else {
    if (fieldCount == 1) {
      result = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 2, 5, 1);
      fieldIndex = $fieldIndex(this$static, field);
      if (fieldIndex == 0) {
        result[0] = value_0;
        result[1] = this$static.eStorage;
      }
       else {
        result[0] = this$static.eStorage;
        result[1] = value_0;
      }
    }
     else {
      result = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, fieldCount + 1, 5, 1);
      oldStorage = castToArray(this$static.eStorage);
      for (bit = 2 , sourceIndex = 0 , targetIndex = 0; bit <= 128; bit <<= 1) {
        bit == field?(result[targetIndex++] = value_0):(this$static.eFlags_0 & bit) != 0 && (result[targetIndex++] = oldStorage[sourceIndex++]);
      }
    }
    this$static.eStorage = result;
  }
  this$static.eFlags_0 |= field;
}

function $eClass(this$static){
  var eClass;
  eClass = castTo($getField(this$static, 16), 26);
  return !eClass?this$static.eStaticClass():eClass;
}

function $eDynamicSettings(this$static){
  var settings;
  settings = castToArray($getField(this$static, 32));
  if (settings == null) {
    $eSettings_0(this$static);
    settings = castToArray($getField(this$static, 32));
  }
  return settings;
}

function $eSettings_0(this$static){
  var eClass, size_0;
  if ((this$static.eFlags_0 & 32) == 0) {
    size_0 = (eClass = castTo($getField(this$static, 16), 26) , $getFeatureCount(!eClass?this$static.eStaticClass():eClass) - $getFeatureCount(this$static.eStaticClass()));
    size_0 != 0 && $setField(this$static, 32, initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, size_0, 5, 1));
  }
  return this$static;
}

function $fieldIndex(this$static, field){
  var bit, bit0, result;
  result = 0;
  for (bit0 = 2; bit0 < field; bit0 <<= 1) {
    (this$static.eFlags_0 & bit0) != 0 && ++result;
  }
  if (result == 0) {
    for (bit = field <<= 1; bit <= 128; bit <<= 1) {
      if ((this$static.eFlags_0 & bit) != 0) {
        return 0;
      }
    }
    return -1;
  }
   else {
    return result;
  }
}

function $getField(this$static, field){
  var fieldIndex;
  if ((this$static.eFlags_0 & field) != 0) {
    fieldIndex = $fieldIndex(this$static, field);
    return fieldIndex == -1?this$static.eStorage:castToArray(this$static.eStorage)[fieldIndex];
  }
   else {
    return null;
  }
}

function $removeField(this$static, field){
  var bit, fieldCount, fieldIndex, oldStorage, result, sourceIndex, targetIndex;
  fieldCount = bitCount(this$static.eFlags_0 & 254);
  if (fieldCount == 1) {
    this$static.eStorage = null;
  }
   else {
    oldStorage = castToArray(this$static.eStorage);
    if (fieldCount == 2) {
      fieldIndex = $fieldIndex(this$static, field);
      this$static.eStorage = oldStorage[fieldIndex == 0?1:0];
    }
     else {
      result = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, fieldCount - 1, 5, 1);
      for (bit = 2 , sourceIndex = 0 , targetIndex = 0; bit <= 128; bit <<= 1) {
        bit == field?++sourceIndex:(this$static.eFlags_0 & bit) != 0 && (result[targetIndex++] = oldStorage[sourceIndex++]);
      }
      this$static.eStorage = result;
    }
  }
  this$static.eFlags_0 &= ~field;
}

function $setField(this$static, field, value_0){
  var fieldIndex;
  if ((this$static.eFlags_0 & field) != 0) {
    if (value_0 == null) {
      $removeField(this$static, field);
    }
     else {
      fieldIndex = $fieldIndex(this$static, field);
      fieldIndex == -1?(this$static.eStorage = value_0):setCheck(castToArray(this$static.eStorage), fieldIndex, value_0);
    }
  }
   else 
    value_0 != null && $addField(this$static, field, value_0);
}

defineClass(109, 93, {98:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1});
_.dynamicGet = function dynamicGet(dynamicFeatureID){
  var settings;
  settings = $eDynamicSettings(this);
  return settings[dynamicFeatureID];
}
;
_.dynamicSet = function dynamicSet(dynamicFeatureID, newValue){
  var settings;
  settings = $eDynamicSettings(this);
  setCheck(settings, dynamicFeatureID, newValue);
}
;
_.dynamicUnset = function dynamicUnset(dynamicFeatureID){
  var settings;
  settings = $eDynamicSettings(this);
  setCheck(settings, dynamicFeatureID, null);
}
;
_.eBasicAdapterArray = function eBasicAdapterArray_0(){
  return castTo($getField(this, 4), 119);
}
;
_.eBasicAdapters = function eBasicAdapters_0(){
  throw toJs(new UnsupportedOperationException);
}
;
_.eBasicHasAdapters = function eBasicHasAdapters_0(){
  return (this.eFlags_0 & 4) != 0;
}
;
_.eBasicProperties = function eBasicProperties_0(){
  throw toJs(new UnsupportedOperationException);
}
;
_.eBasicSetContainer_1 = function eBasicSetContainer_1(newContainer){
  $setField(this, 2, newContainer);
}
;
_.eBasicSetContainer = function eBasicSetContainer_2(newContainer, newContainerFeatureID){
  this.eFlags_0 = newContainerFeatureID << 16 | this.eFlags_0 & 255;
  this.eBasicSetContainer_1(newContainer);
}
;
_.eClass_0 = function eClass_1(){
  return $eClass(this);
}
;
_.eContainerFeatureID_0 = function eContainerFeatureID_1(){
  return this.eFlags_0 >> 16;
}
;
_.eContents_0 = function eContents_1(){
  var eClass, eStructuralFeatures;
  return $clinit_EContentsEList() , eStructuralFeatures = $containments($getEAllStructuralFeatures((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass))) , eStructuralFeatures == null?(null , EMPTY_CONTENTS_ELIST):new EContentsEList(this, eStructuralFeatures);
}
;
_.eDeliver = function eDeliver_0(){
  return (this.eFlags_0 & 1) == 0;
}
;
_.eDirectResource = function eDirectResource_0(){
  return castTo($getField(this, 128), 1714);
}
;
_.eDynamicClass = function eDynamicClass_0(){
  return castTo($getField(this, 16), 26);
}
;
_.eHasSettings = function eHasSettings_0(){
  return (this.eFlags_0 & 32) != 0;
}
;
_.eInternalContainer = function eInternalContainer_1(){
  return castTo($getField(this, 2), 46);
}
;
_.eIsProxy = function eIsProxy_0(){
  return (this.eFlags_0 & 64) != 0;
}
;
_.eProperties_0 = function eProperties_1(){
  throw toJs(new UnsupportedOperationException);
}
;
_.eProxyURI_0 = function eProxyURI_0(){
  return castTo($getField(this, 64), 273);
}
;
_.eSetClass = function eSetClass_0(eClass){
  $setField(this, 16, eClass);
}
;
_.eSetDirectResource = function eSetDirectResource_0(resource){
  $setField(this, 128, resource);
}
;
_.eSettings_0 = function eSettings_0(){
  return $eSettings_0(this);
}
;
_.eFlags_0 = 0;
var Lorg_eclipse_emf_ecore_impl_MinimalEObjectImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'MinimalEObjectImpl', 109);
defineClass(110, 109, {98:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1});
_.eBasicSetContainer_1 = function eBasicSetContainer_3(newContainer){
  this.eContainer = newContainer;
}
;
_.eInternalContainer = function eInternalContainer_2(){
  return this.eContainer;
}
;
var Lorg_eclipse_emf_ecore_impl_MinimalEObjectImpl$Container_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'MinimalEObjectImpl/Container', 110);
function $eGet_3(this$static, featureID, resolve, coreType){
  if (featureID == 0) {
    return coreType?(!this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , this$static.properties):(!this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , $map_0(this$static.properties));
  }
  return $eGet(this$static, featureID, resolve, coreType);
}

function $eInverseRemove_0(this$static, otherEnd, featureID, msgs){
  var eClass, feature;
  if (featureID == 0) {
    return !this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , $basicRemove_1(this$static.properties, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?this$static.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this$static, $eSettings_0(this$static), featureID - $getFeatureCount(this$static.eStaticClass()), otherEnd, msgs);
}

function $eIsSet_0(this$static, featureID){
  if (featureID == 0) {
    return !!this$static.properties && this$static.properties.size_0 != 0;
  }
  return $eIsSet(this$static, featureID);
}

function $eSet_1(this$static, featureID, newValue){
  switch (featureID) {
    case 0:
      !this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0));
      $set_11(this$static.properties, newValue);
      return;
  }
  $eSet(this$static, featureID, newValue);
}

function $getAllProperties_0(this$static){
  var entry, entry$iterator, props;
  props = (!this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , this$static.properties);
  for (entry$iterator = props.delegateEList.iterator_0(); entry$iterator.cursor != entry$iterator.this$01_2.size_1();) {
    entry = castTo(entry$iterator.doNext(), 39);
    entry.getValue();
  }
  return $map_0(props);
}

function $getProperty_0(this$static, property){
  var defaultValue, value_0;
  value_0 = (!this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , $get_17(this$static.properties, property));
  if (value_0 != null) {
    return value_0;
  }
  defaultValue = property.getDefault();
  instanceOf(defaultValue, 4) && (defaultValue == null?(!this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , $removeKey(this$static.properties, property)):(!this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , $put_8(this$static.properties, property, defaultValue)) , this$static);
  return defaultValue;
}

function $hasProperty_0(this$static, property){
  return !this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , $containsKey_5(this$static.properties, property);
}

function $setProperty_1(this$static, property, value_0){
  value_0 == null?(!this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , $removeKey(this$static.properties, property)):(!this$static.properties && (this$static.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this$static, 0)) , $put_8(this$static.properties, property, value_0));
  return this$static;
}

defineClass(1760, 110, {98:1, 392:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1});
_.copyProperties = function copyProperties_0(source){
  !this.properties && (this.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, this, 0));
  $putAll_0(this.properties, !source.propertyMap?($clinit_Collections() , $clinit_Collections() , EMPTY_MAP):source.propertyMap);
  return this;
}
;
_.eGet = function eGet_2(featureID, resolve, coreType){
  return $eGet_3(this, featureID, resolve, coreType);
}
;
_.eInverseRemove_0 = function eInverseRemove_1(otherEnd, featureID, msgs){
  return $eInverseRemove_0(this, otherEnd, featureID, msgs);
}
;
_.eIsSet = function eIsSet_1(featureID){
  return $eIsSet_0(this, featureID);
}
;
_.eSet = function eSet_0(featureID, newValue){
  $eSet_1(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_0(){
  return $clinit_ElkGraphPackage$Literals() , EMAP_PROPERTY_HOLDER;
}
;
_.getAllProperties = function getAllProperties_0(){
  return $getAllProperties_0(this);
}
;
_.getProperty = function getProperty_3(property){
  return $getProperty_0(this, property);
}
;
_.hasProperty = function hasProperty_3(property){
  return $hasProperty_0(this, property);
}
;
_.setProperty = function setProperty_0(property, value_0){
  return $setProperty_1(this, property, value_0);
}
;
var Lorg_eclipse_elk_graph_impl_EMapPropertyHolderImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'EMapPropertyHolderImpl', 1760);
function $set_7(this$static, x_0, y_0){
  $setX_0(this$static, x_0);
  $setY_0(this$static, y_0);
}

function $setX_0(this$static, newX){
  var oldX;
  oldX = this$static.x_0;
  this$static.x_0 = newX;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 0, oldX, this$static.x_0));
}

function $setY_0(this$static, newY){
  var oldY;
  oldY = this$static.y_0;
  this$static.y_0 = newY;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 1, oldY, this$static.y_0));
}

function ElkBendPointImpl(){
}

defineClass(531, 110, {98:1, 556:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1}, ElkBendPointImpl);
_.eGet = function eGet_3(featureID, resolve, coreType){
  switch (featureID) {
    case 0:
      return this.x_0;
    case 1:
      return this.y_0;
  }
  return $eGet(this, featureID, resolve, coreType);
}
;
_.eIsSet = function eIsSet_2(featureID){
  switch (featureID) {
    case 0:
      return this.x_0 != 0;
    case 1:
      return this.y_0 != 0;
  }
  return $eIsSet(this, featureID);
}
;
_.eSet = function eSet_1(featureID, newValue){
  switch (featureID) {
    case 0:
      $setX_0(this, checkNotNull_1(castToDouble(newValue)));
      return;
    case 1:
      $setY_0(this, checkNotNull_1(castToDouble(newValue)));
      return;
  }
  $eSet(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_1(){
  return $clinit_ElkGraphPackage$Literals() , ELK_BEND_POINT;
}
;
_.toString_0 = function toString_122(){
  var result;
  if ((this.eFlags_0 & 64) != 0)
    return $toString_12(this);
  result = new StringBuffer_1($toString_12(this));
  result.string += ' (x: ';
  $append_0(result, this.x_0);
  result.string += ', y: ';
  $append_0(result, this.y_0);
  result.string += ')';
  return result.string;
}
;
_.x_0 = 0;
_.y_0 = 0;
var Lorg_eclipse_elk_graph_impl_ElkBendPointImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkBendPointImpl', 531);
function $eGet_4(this$static, featureID, resolve, coreType){
  switch (featureID) {
    case 1:
      return !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7)) , this$static.labels;
    case 2:
      return this$static.identifier;
  }
  return $eGet_3(this$static, featureID, resolve, coreType);
}

function $eInverseAdd_0(this$static, otherEnd, featureID, msgs){
  var eClass, feature;
  if (featureID == 1) {
    return !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7)) , $basicAdd_0(this$static.labels, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?this$static.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this$static, $eSettings_0(this$static), featureID - $getFeatureCount(this$static.eStaticClass()), otherEnd, msgs);
}

function $eInverseRemove_1(this$static, otherEnd, featureID, msgs){
  if (featureID == 1) {
    return !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7)) , $basicRemove_0(this$static.labels, otherEnd, msgs);
  }
  return $eInverseRemove_0(this$static, otherEnd, featureID, msgs);
}

function $eIsSet_1(this$static, featureID){
  switch (featureID) {
    case 1:
      return !!this$static.labels && this$static.labels.size_0 != 0;
    case 2:
      return this$static.identifier != null;
  }
  return $eIsSet_0(this$static, featureID);
}

function $eSet_2(this$static, featureID, newValue){
  switch (featureID) {
    case 1:
      !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7));
      $clear_11(this$static.labels);
      !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7));
      $addAll_6(this$static.labels, castTo(newValue, 13));
      return;
    case 2:
      $setIdentifier(this$static, castToString(newValue));
      return;
  }
  $eSet_1(this$static, featureID, newValue);
}

function $getLabels_1(this$static){
  !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7));
  return this$static.labels;
}

function $setIdentifier(this$static, newIdentifier){
  var oldIdentifier;
  oldIdentifier = this$static.identifier;
  this$static.identifier = newIdentifier;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 2, oldIdentifier, this$static.identifier));
}

function $toString_13(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_12(this$static);
  result = new StringBuffer_1($toString_12(this$static));
  result.string += ' (identifier: ';
  $append_3(result, this$static.identifier);
  result.string += ')';
  return result.string;
}

defineClass(670, 1760, {98:1, 392:1, 202:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1});
_.eGet = function eGet_4(featureID, resolve, coreType){
  return $eGet_4(this, featureID, resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_1(otherEnd, featureID, msgs){
  return $eInverseAdd_0(this, otherEnd, featureID, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_2(otherEnd, featureID, msgs){
  return $eInverseRemove_1(this, otherEnd, featureID, msgs);
}
;
_.eIsSet = function eIsSet_3(featureID){
  return $eIsSet_1(this, featureID);
}
;
_.eSet = function eSet_2(featureID, newValue){
  $eSet_2(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_2(){
  return $clinit_ElkGraphPackage$Literals() , ELK_GRAPH_ELEMENT;
}
;
_.getIdentifier = function getIdentifier(){
  return this.identifier;
}
;
_.getLabels_0 = function getLabels_5(){
  return $getLabels_1(this);
}
;
_.toString_0 = function toString_123(){
  return $toString_13(this);
}
;
_.identifier = null;
var Lorg_eclipse_elk_graph_impl_ElkGraphElementImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkGraphElementImpl', 670);
function $eGet_5(this$static, featureID, resolve, coreType){
  switch (featureID) {
    case 3:
      return this$static.height;
    case 4:
      return this$static.width_0;
    case 5:
      return this$static.x_0;
    case 6:
      return this$static.y_0;
  }
  return $eGet_4(this$static, featureID, resolve, coreType);
}

function $eIsSet_2(this$static, featureID){
  switch (featureID) {
    case 3:
      return this$static.height != 0;
    case 4:
      return this$static.width_0 != 0;
    case 5:
      return this$static.x_0 != 0;
    case 6:
      return this$static.y_0 != 0;
  }
  return $eIsSet_1(this$static, featureID);
}

function $eSet_3(this$static, featureID, newValue){
  switch (featureID) {
    case 3:
      $setHeight_0(this$static, checkNotNull_1(castToDouble(newValue)));
      return;
    case 4:
      $setWidth_0(this$static, checkNotNull_1(castToDouble(newValue)));
      return;
    case 5:
      $setX_1(this$static, checkNotNull_1(castToDouble(newValue)));
      return;
    case 6:
      $setY_1(this$static, checkNotNull_1(castToDouble(newValue)));
      return;
  }
  $eSet_2(this$static, featureID, newValue);
}

function $setDimensions_0(this$static, width_0, height){
  $setWidth_0(this$static, width_0);
  $setHeight_0(this$static, height);
}

function $setHeight_0(this$static, newHeight){
  var oldHeight;
  oldHeight = this$static.height;
  this$static.height = newHeight;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 3, oldHeight, this$static.height));
}

function $setLocation(this$static, x_0, y_0){
  $setX_1(this$static, x_0);
  $setY_1(this$static, y_0);
}

function $setWidth_0(this$static, newWidth){
  var oldWidth;
  oldWidth = this$static.width_0;
  this$static.width_0 = newWidth;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 4, oldWidth, this$static.width_0));
}

function $setX_1(this$static, newX){
  var oldX;
  oldX = this$static.x_0;
  this$static.x_0 = newX;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 5, oldX, this$static.x_0));
}

function $setY_1(this$static, newY){
  var oldY;
  oldY = this$static.y_0;
  this$static.y_0 = newY;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 6, oldY, this$static.y_0));
}

function $toString_14(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_13(this$static);
  result = new StringBuffer_1($toString_13(this$static));
  result.string += ' (height: ';
  $append_0(result, this$static.height);
  result.string += ', width: ';
  $append_0(result, this$static.width_0);
  result.string += ', x: ';
  $append_0(result, this$static.x_0);
  result.string += ', y: ';
  $append_0(result, this$static.y_0);
  result.string += ')';
  return result.string;
}

defineClass(671, 670, {98:1, 392:1, 202:1, 444:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1});
_.eGet = function eGet_5(featureID, resolve, coreType){
  return $eGet_5(this, featureID, resolve, coreType);
}
;
_.eIsSet = function eIsSet_4(featureID){
  return $eIsSet_2(this, featureID);
}
;
_.eSet = function eSet_3(featureID, newValue){
  $eSet_3(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_3(){
  return $clinit_ElkGraphPackage$Literals() , ELK_SHAPE;
}
;
_.getHeight = function getHeight(){
  return this.height;
}
;
_.getWidth = function getWidth(){
  return this.width_0;
}
;
_.getX = function getX(){
  return this.x_0;
}
;
_.getY = function getY(){
  return this.y_0;
}
;
_.setDimensions = function setDimensions(width_0, height){
  $setDimensions_0(this, width_0, height);
}
;
_.setLocation = function setLocation(x_0, y_0){
  $setLocation(this, x_0, y_0);
}
;
_.setX = function setX(newX){
  $setX_1(this, newX);
}
;
_.setY = function setY(newY){
  $setY_1(this, newY);
}
;
_.toString_0 = function toString_124(){
  return $toString_14(this);
}
;
_.height = 0;
_.width_0 = 0;
_.x_0 = 0;
_.y_0 = 0;
var Lorg_eclipse_elk_graph_impl_ElkShapeImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkShapeImpl', 671);
function $eGet_6(this$static, featureID, resolve, coreType){
  switch (featureID) {
    case 7:
      return !this$static.outgoingEdges && (this$static.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 7, 4)) , this$static.outgoingEdges;
    case 8:
      return !this$static.incomingEdges && (this$static.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 8, 5)) , this$static.incomingEdges;
  }
  return $eGet_5(this$static, featureID, resolve, coreType);
}

function $eInverseAdd_1(this$static, otherEnd, featureID, msgs){
  switch (featureID) {
    case 7:
      return !this$static.outgoingEdges && (this$static.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 7, 4)) , $basicAdd_0(this$static.outgoingEdges, otherEnd, msgs);
    case 8:
      return !this$static.incomingEdges && (this$static.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 8, 5)) , $basicAdd_0(this$static.incomingEdges, otherEnd, msgs);
  }
  return $eInverseAdd_0(this$static, otherEnd, featureID, msgs);
}

function $eInverseRemove_2(this$static, otherEnd, featureID, msgs){
  switch (featureID) {
    case 7:
      return !this$static.outgoingEdges && (this$static.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 7, 4)) , $basicRemove_0(this$static.outgoingEdges, otherEnd, msgs);
    case 8:
      return !this$static.incomingEdges && (this$static.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 8, 5)) , $basicRemove_0(this$static.incomingEdges, otherEnd, msgs);
  }
  return $eInverseRemove_1(this$static, otherEnd, featureID, msgs);
}

function $eIsSet_3(this$static, featureID){
  switch (featureID) {
    case 7:
      return !!this$static.outgoingEdges && this$static.outgoingEdges.size_0 != 0;
    case 8:
      return !!this$static.incomingEdges && this$static.incomingEdges.size_0 != 0;
  }
  return $eIsSet_2(this$static, featureID);
}

function $eSet_4(this$static, featureID, newValue){
  switch (featureID) {
    case 7:
      !this$static.outgoingEdges && (this$static.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 7, 4));
      $clear_11(this$static.outgoingEdges);
      !this$static.outgoingEdges && (this$static.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 7, 4));
      $addAll_6(this$static.outgoingEdges, castTo(newValue, 13));
      return;
    case 8:
      !this$static.incomingEdges && (this$static.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 8, 5));
      $clear_11(this$static.incomingEdges);
      !this$static.incomingEdges && (this$static.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 8, 5));
      $addAll_6(this$static.incomingEdges, castTo(newValue, 13));
      return;
  }
  $eSet_3(this$static, featureID, newValue);
}

function ElkConnectableShapeImpl(){
}

defineClass(672, 671, {98:1, 392:1, 97:1, 202:1, 444:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1});
_.eGet = function eGet_6(featureID, resolve, coreType){
  return $eGet_6(this, featureID, resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_2(otherEnd, featureID, msgs){
  return $eInverseAdd_1(this, otherEnd, featureID, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_3(otherEnd, featureID, msgs){
  return $eInverseRemove_2(this, otherEnd, featureID, msgs);
}
;
_.eIsSet = function eIsSet_5(featureID){
  return $eIsSet_3(this, featureID);
}
;
_.eSet = function eSet_4(featureID, newValue){
  $eSet_4(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_4(){
  return $clinit_ElkGraphPackage$Literals() , ELK_CONNECTABLE_SHAPE;
}
;
_.getIncomingEdges_0 = function getIncomingEdges_3(){
  return !this.incomingEdges && (this.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this, 8, 5)) , this.incomingEdges;
}
;
_.getOutgoingEdges_0 = function getOutgoingEdges_3(){
  return !this.outgoingEdges && (this.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this, 7, 4)) , this.outgoingEdges;
}
;
var Lorg_eclipse_elk_graph_impl_ElkConnectableShapeImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkConnectableShapeImpl', 672);
function $basicSetContainingNode(this$static, newContainingNode, msgs){
  msgs = $eBasicSetContainer(this$static, newContainingNode, 3, msgs);
  return msgs;
}

function $eBasicRemoveFromContainerFeature(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 3) {
    return this$static.eContainer.eInverseRemove(this$static, 12, Lorg_eclipse_elk_graph_ElkNode_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_ElkGraphPackage$Literals() , ELK_EDGE):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getContainingNode(this$static){
  if (this$static.eFlags_0 >> 16 != 3)
    return null;
  return castTo(this$static.eContainer, 35);
}

function $getSources(this$static){
  !this$static.sources && (this$static.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this$static, 4, 7));
  return this$static.sources;
}

function $getTargets(this$static){
  !this$static.targets && (this$static.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this$static, 5, 8));
  return this$static.targets;
}

function $isHierarchical(this$static){
  var commonRepresentingNode, incidentShape, incidentShape$iterator, shapeNode;
  commonRepresentingNode = null;
  for (incidentShape$iterator = $iterator(concat_1((!this$static.sources && (this$static.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this$static, 4, 7)) , this$static.sources), (!this$static.targets && (this$static.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this$static, 5, 8)) , this$static.targets))); $hasNext_0(incidentShape$iterator);) {
    incidentShape = castTo($next_2(incidentShape$iterator), 97);
    shapeNode = connectableShapeToNode(incidentShape);
    if (!commonRepresentingNode) {
      commonRepresentingNode = $getParent_2(shapeNode);
    }
     else if (commonRepresentingNode != $getParent_2(shapeNode)) {
      return true;
    }
  }
  return false;
}

function $isSelfloop(this$static){
  var commonNode, incidentShape, incidentShape$iterator, shapeNode;
  commonNode = null;
  for (incidentShape$iterator = $iterator(concat_1((!this$static.sources && (this$static.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this$static, 4, 7)) , this$static.sources), (!this$static.targets && (this$static.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this$static, 5, 8)) , this$static.targets))); $hasNext_0(incidentShape$iterator);) {
    incidentShape = castTo($next_2(incidentShape$iterator), 97);
    shapeNode = connectableShapeToNode(incidentShape);
    if (!commonNode) {
      commonNode = shapeNode;
    }
     else if (commonNode != shapeNode) {
      return false;
    }
  }
  return true;
}

function $setContainingNode(this$static, newContainingNode){
  var eContainerFeatureID, msgs;
  if (newContainingNode != this$static.eContainer || this$static.eFlags_0 >> 16 != 3 && !!newContainingNode) {
    if (isAncestor(this$static, newContainingNode))
      throw toJs(new IllegalArgumentException_0('Recursive containment not allowed for ' + $toString_15(this$static)));
    msgs = null;
    !!this$static.eContainer && (msgs = (eContainerFeatureID = this$static.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature(this$static, null):this$static.eContainer.eInverseRemove(this$static, -1 - eContainerFeatureID, null, null)));
    !!newContainingNode && (msgs = $eInverseAdd(newContainingNode, this$static, 12, msgs));
    msgs = $basicSetContainingNode(this$static, newContainingNode, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 3, newContainingNode, newContainingNode));
}

function $toString_15(this$static){
  var builder, hyperedge, id_0, text_0;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_13(this$static);
  builder = new StringBuilder_1('ElkEdge');
  id_0 = this$static.identifier;
  if (!id_0) {
    !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7));
    if (this$static.labels.size_0 > 0) {
      text_0 = (!this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7)) , castTo(castTo($get_16(this$static.labels, 0), 135), 241)).text_0;
      !text_0 || $append_11($append_11((builder.string += ' "' , builder), text_0), '"');
    }
  }
   else {
    $append_11($append_11((builder.string += ' "' , builder), id_0), '"');
  }
  hyperedge = (!this$static.sources && (this$static.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this$static, 4, 7)) , !(this$static.sources.size_0 <= 1 && (!this$static.targets && (this$static.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this$static, 5, 8)) , this$static.targets.size_0 <= 1)));
  hyperedge?(builder.string += ' [' , builder):(builder.string += ' ' , builder);
  $append_11(builder, $join(new Joiner(', '), new AbstractEList$EIterator(this$static.sources)));
  hyperedge && (builder.string += ']' , builder);
  builder.string += ' -> ';
  hyperedge && (builder.string += '[' , builder);
  $append_11(builder, $join(new Joiner(', '), new AbstractEList$EIterator(this$static.targets)));
  hyperedge && (builder.string += ']' , builder);
  return builder.string;
}

function ElkEdgeImpl(){
}

defineClass(173, 670, {98:1, 392:1, 100:1, 202:1, 173:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1}, ElkEdgeImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_0(msgs){
  return $eBasicRemoveFromContainerFeature(this, msgs);
}
;
_.eGet = function eGet_7(featureID, resolve, coreType){
  switch (featureID) {
    case 3:
      return $getContainingNode(this);
    case 4:
      return !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7)) , this.sources;
    case 5:
      return !this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8)) , this.targets;
    case 6:
      return !this.sections && (this.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 6, 6)) , this.sections;
    case 7:
      return $clinit_Boolean() , !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7)) , this.sources.size_0 <= 1 && (!this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8)) , this.targets.size_0 <= 1)?false:true;
    case 8:
      return $clinit_Boolean() , $isHierarchical(this)?true:false;
    case 9:
      return $clinit_Boolean() , $isSelfloop(this)?true:false;
    case 10:
      return $clinit_Boolean() , !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7)) , this.sources.size_0 != 0 && (!this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8)) , this.targets.size_0 != 0)?true:false;
  }
  return $eGet_4(this, featureID, resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_3(otherEnd, featureID, msgs){
  var eContainerFeatureID;
  switch (featureID) {
    case 3:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $basicSetContainingNode(this, castTo(otherEnd, 35), msgs);
    case 4:
      return !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7)) , $basicAdd_0(this.sources, otherEnd, msgs);
    case 5:
      return !this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8)) , $basicAdd_0(this.targets, otherEnd, msgs);
    case 6:
      return !this.sections && (this.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 6, 6)) , $basicAdd_0(this.sections, otherEnd, msgs);
  }
  return $eInverseAdd_0(this, otherEnd, featureID, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_4(otherEnd, featureID, msgs){
  switch (featureID) {
    case 3:
      return $basicSetContainingNode(this, null, msgs);
    case 4:
      return !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7)) , $basicRemove_0(this.sources, otherEnd, msgs);
    case 5:
      return !this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8)) , $basicRemove_0(this.targets, otherEnd, msgs);
    case 6:
      return !this.sections && (this.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 6, 6)) , $basicRemove_0(this.sections, otherEnd, msgs);
  }
  return $eInverseRemove_1(this, otherEnd, featureID, msgs);
}
;
_.eIsSet = function eIsSet_6(featureID){
  switch (featureID) {
    case 3:
      return !!$getContainingNode(this);
    case 4:
      return !!this.sources && this.sources.size_0 != 0;
    case 5:
      return !!this.targets && this.targets.size_0 != 0;
    case 6:
      return !!this.sections && this.sections.size_0 != 0;
    case 7:
      return !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7)) , !(this.sources.size_0 <= 1 && (!this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8)) , this.targets.size_0 <= 1));
    case 8:
      return $isHierarchical(this);
    case 9:
      return $isSelfloop(this);
    case 10:
      return !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7)) , this.sources.size_0 != 0 && (!this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8)) , this.targets.size_0 != 0);
  }
  return $eIsSet_1(this, featureID);
}
;
_.eSet = function eSet_5(featureID, newValue){
  switch (featureID) {
    case 3:
      $setContainingNode(this, castTo(newValue, 35));
      return;
    case 4:
      !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7));
      $clear_11(this.sources);
      !this.sources && (this.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 4, 7));
      $addAll_6(this.sources, castTo(newValue, 13));
      return;
    case 5:
      !this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8));
      $clear_11(this.targets);
      !this.targets && (this.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, this, 5, 8));
      $addAll_6(this.targets, castTo(newValue, 13));
      return;
    case 6:
      !this.sections && (this.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 6, 6));
      $clear_11(this.sections);
      !this.sections && (this.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 6, 6));
      $addAll_6(this.sections, castTo(newValue, 13));
      return;
  }
  $eSet_2(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_5(){
  return $clinit_ElkGraphPackage$Literals() , ELK_EDGE;
}
;
_.toString_0 = function toString_125(){
  return $toString_15(this);
}
;
var Lorg_eclipse_elk_graph_impl_ElkEdgeImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkEdgeImpl', 173);
function $basicSetParent(this$static, newParent, msgs){
  msgs = $eBasicSetContainer(this$static, newParent, 6, msgs);
  return msgs;
}

function $eBasicRemoveFromContainerFeature_0(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 6) {
    return this$static.eContainer.eInverseRemove(this$static, 6, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_ElkGraphPackage$Literals() , ELK_EDGE_SECTION):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getIncomingShape(this$static){
  var oldIncomingShape;
  if (!!this$static.incomingShape && this$static.incomingShape.eIsProxy()) {
    oldIncomingShape = castTo(this$static.incomingShape, 46);
    this$static.incomingShape = castTo($eResolveProxy(this$static, oldIncomingShape), 97);
    this$static.incomingShape != oldIncomingShape && (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 9, 8, oldIncomingShape, this$static.incomingShape));
  }
  return this$static.incomingShape;
}

function $getOutgoingShape(this$static){
  var oldOutgoingShape;
  if (!!this$static.outgoingShape && this$static.outgoingShape.eIsProxy()) {
    oldOutgoingShape = castTo(this$static.outgoingShape, 46);
    this$static.outgoingShape = castTo($eResolveProxy(this$static, oldOutgoingShape), 97);
    this$static.outgoingShape != oldOutgoingShape && (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 9, 7, oldOutgoingShape, this$static.outgoingShape));
  }
  return this$static.outgoingShape;
}

function $getParent_0(this$static){
  if (this$static.eFlags_0 >> 16 != 6)
    return null;
  return castTo(this$static.eContainer, 100);
}

function $setEndLocation(this$static, x_0, y_0){
  $setEndX(this$static, x_0);
  $setEndY(this$static, y_0);
}

function $setEndX(this$static, newEndX){
  var oldEndX;
  oldEndX = this$static.endX;
  this$static.endX = newEndX;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 3, oldEndX, this$static.endX));
}

function $setEndY(this$static, newEndY){
  var oldEndY;
  oldEndY = this$static.endY;
  this$static.endY = newEndY;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 4, oldEndY, this$static.endY));
}

function $setIdentifier_0(this$static, newIdentifier){
  var oldIdentifier;
  oldIdentifier = this$static.identifier;
  this$static.identifier = newIdentifier;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 11, oldIdentifier, this$static.identifier));
}

function $setIncomingShape(this$static, newIncomingShape){
  var oldIncomingShape;
  oldIncomingShape = this$static.incomingShape;
  this$static.incomingShape = newIncomingShape;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 8, oldIncomingShape, this$static.incomingShape));
}

function $setOutgoingShape(this$static, newOutgoingShape){
  var oldOutgoingShape;
  oldOutgoingShape = this$static.outgoingShape;
  this$static.outgoingShape = newOutgoingShape;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 7, oldOutgoingShape, this$static.outgoingShape));
}

function $setParent(this$static, newParent){
  var eContainerFeatureID, msgs;
  if (newParent != this$static.eContainer || this$static.eFlags_0 >> 16 != 6 && !!newParent) {
    if (isAncestor(this$static, newParent))
      throw toJs(new IllegalArgumentException_0('Recursive containment not allowed for ' + $toString_16(this$static)));
    msgs = null;
    !!this$static.eContainer && (msgs = (eContainerFeatureID = this$static.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_0(this$static, null):this$static.eContainer.eInverseRemove(this$static, -1 - eContainerFeatureID, null, null)));
    !!newParent && (msgs = $eInverseAdd(newParent, this$static, 6, msgs));
    msgs = $basicSetParent(this$static, newParent, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 6, newParent, newParent));
}

function $setStartLocation(this$static, x_0, y_0){
  $setStartX(this$static, x_0);
  $setStartY(this$static, y_0);
}

function $setStartX(this$static, newStartX){
  var oldStartX;
  oldStartX = this$static.startX;
  this$static.startX = newStartX;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 1, oldStartX, this$static.startX));
}

function $setStartY(this$static, newStartY){
  var oldStartY;
  oldStartY = this$static.startY;
  this$static.startY = newStartY;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl(this$static, 2, oldStartY, this$static.startY));
}

function $toString_16(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_12(this$static);
  result = new StringBuffer_1($toString_12(this$static));
  result.string += ' (startX: ';
  $append_0(result, this$static.startX);
  result.string += ', startY: ';
  $append_0(result, this$static.startY);
  result.string += ', endX: ';
  $append_0(result, this$static.endX);
  result.string += ', endY: ';
  $append_0(result, this$static.endY);
  result.string += ', identifier: ';
  $append_3(result, this$static.identifier);
  result.string += ')';
  return result.string;
}

function ElkEdgeSectionImpl(){
}

defineClass(418, 1760, {98:1, 392:1, 228:1, 418:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1}, ElkEdgeSectionImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_1(msgs){
  return $eBasicRemoveFromContainerFeature_0(this, msgs);
}
;
_.eGet = function eGet_8(featureID, resolve, coreType){
  switch (featureID) {
    case 1:
      return this.startX;
    case 2:
      return this.startY;
    case 3:
      return this.endX;
    case 4:
      return this.endY;
    case 5:
      return !this.bendPoints && (this.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, this, 5)) , this.bendPoints;
    case 6:
      return $getParent_0(this);
    case 7:
      if (resolve)
        return $getOutgoingShape(this);
      return this.outgoingShape;
    case 8:
      if (resolve)
        return $getIncomingShape(this);
      return this.incomingShape;
    case 9:
      return !this.outgoingSections && (this.outgoingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 9, 10)) , this.outgoingSections;
    case 10:
      return !this.incomingSections && (this.incomingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 10, 9)) , this.incomingSections;
    case 11:
      return this.identifier;
  }
  return $eGet_3(this, featureID, resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_4(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 6:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_0(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $basicSetParent(this, castTo(otherEnd, 100), msgs);
    case 9:
      return !this.outgoingSections && (this.outgoingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 9, 10)) , $basicAdd_0(this.outgoingSections, otherEnd, msgs);
    case 10:
      return !this.incomingSections && (this.incomingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 10, 9)) , $basicAdd_0(this.incomingSections, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_ElkGraphPackage$Literals() , ELK_EDGE_SECTION):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_ElkGraphPackage$Literals() , ELK_EDGE_SECTION)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_5(otherEnd, featureID, msgs){
  switch (featureID) {
    case 5:
      return !this.bendPoints && (this.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, this, 5)) , $basicRemove_0(this.bendPoints, otherEnd, msgs);
    case 6:
      return $basicSetParent(this, null, msgs);
    case 9:
      return !this.outgoingSections && (this.outgoingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 9, 10)) , $basicRemove_0(this.outgoingSections, otherEnd, msgs);
    case 10:
      return !this.incomingSections && (this.incomingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 10, 9)) , $basicRemove_0(this.incomingSections, otherEnd, msgs);
  }
  return $eInverseRemove_0(this, otherEnd, featureID, msgs);
}
;
_.eIsSet = function eIsSet_7(featureID){
  switch (featureID) {
    case 1:
      return this.startX != 0;
    case 2:
      return this.startY != 0;
    case 3:
      return this.endX != 0;
    case 4:
      return this.endY != 0;
    case 5:
      return !!this.bendPoints && this.bendPoints.size_0 != 0;
    case 6:
      return !!$getParent_0(this);
    case 7:
      return !!this.outgoingShape;
    case 8:
      return !!this.incomingShape;
    case 9:
      return !!this.outgoingSections && this.outgoingSections.size_0 != 0;
    case 10:
      return !!this.incomingSections && this.incomingSections.size_0 != 0;
    case 11:
      return this.identifier != null;
  }
  return $eIsSet_0(this, featureID);
}
;
_.eSet = function eSet_6(featureID, newValue){
  switch (featureID) {
    case 1:
      $setStartX(this, checkNotNull_1(castToDouble(newValue)));
      return;
    case 2:
      $setStartY(this, checkNotNull_1(castToDouble(newValue)));
      return;
    case 3:
      $setEndX(this, checkNotNull_1(castToDouble(newValue)));
      return;
    case 4:
      $setEndY(this, checkNotNull_1(castToDouble(newValue)));
      return;
    case 5:
      !this.bendPoints && (this.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, this, 5));
      $clear_11(this.bendPoints);
      !this.bendPoints && (this.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, this, 5));
      $addAll_6(this.bendPoints, castTo(newValue, 13));
      return;
    case 6:
      $setParent(this, castTo(newValue, 100));
      return;
    case 7:
      $setOutgoingShape(this, castTo(newValue, 97));
      return;
    case 8:
      $setIncomingShape(this, castTo(newValue, 97));
      return;
    case 9:
      !this.outgoingSections && (this.outgoingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 9, 10));
      $clear_11(this.outgoingSections);
      !this.outgoingSections && (this.outgoingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 9, 10));
      $addAll_6(this.outgoingSections, castTo(newValue, 13));
      return;
    case 10:
      !this.incomingSections && (this.incomingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 10, 9));
      $clear_11(this.incomingSections);
      !this.incomingSections && (this.incomingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, this, 10, 9));
      $addAll_6(this.incomingSections, castTo(newValue, 13));
      return;
    case 11:
      $setIdentifier_0(this, castToString(newValue));
      return;
  }
  $eSet_1(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_6(){
  return $clinit_ElkGraphPackage$Literals() , ELK_EDGE_SECTION;
}
;
_.toString_0 = function toString_126(){
  return $toString_16(this);
}
;
_.endX = 0;
_.endY = 0;
_.identifier = null;
_.startX = 0;
_.startY = 0;
var Lorg_eclipse_elk_graph_impl_ElkEdgeSectionImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkEdgeSectionImpl', 418);
function $eObjectForURIFragmentSegment_0(this$static, uriFragmentSegment){
  var count, count0, eAnnotation, eNamedElement, encodedSource, exception, firstCharacter, hasCount, index_0, index0, length_0, name_0, object, object$iterator, object$iterator0, otherName, otherSource, source;
  length_0 = uriFragmentSegment.length;
  if (length_0 > 0) {
    firstCharacter = uriFragmentSegment.charCodeAt(0);
    if (firstCharacter != 64) {
      if (firstCharacter == 37) {
        index0 = uriFragmentSegment.lastIndexOf('%');
        hasCount = false;
        if (index0 != 0 && (index0 == length_0 - 1 || (hasCount = uriFragmentSegment.charCodeAt(index0 + 1) == 46))) {
          encodedSource = uriFragmentSegment.substr(1, index0 - 1);
          source = $equals_4('%', encodedSource)?null:decode(encodedSource);
          count0 = 0;
          if (hasCount) {
            try {
              count0 = __parseAndValidateInt(uriFragmentSegment.substr(index0 + 2, uriFragmentSegment.length - (index0 + 2)), $intern_43, $intern_0);
            }
             catch ($e0) {
              $e0 = toJava($e0);
              if (instanceOf($e0, 120)) {
                exception = $e0;
                throw toJs(new WrappedException(exception));
              }
               else 
                throw toJs($e0);
            }
          }
          for (object$iterator0 = $iterator_4(this$static.eContents_0()); object$iterator0.hasNext_0();) {
            object = $next_17(object$iterator0);
            if (instanceOf(object, 483)) {
              eAnnotation = castTo(object, 628);
              otherSource = eAnnotation.source;
              if ((source == null?otherSource == null:$equals_4(source, otherSource)) && count0-- == 0) {
                return eAnnotation;
              }
            }
          }
          return null;
        }
      }
      index_0 = uriFragmentSegment.lastIndexOf('.');
      name_0 = index_0 == -1?uriFragmentSegment:uriFragmentSegment.substr(0, index_0);
      count = 0;
      if (index_0 != -1) {
        try {
          count = __parseAndValidateInt(uriFragmentSegment.substr(index_0 + 1, uriFragmentSegment.length - (index_0 + 1)), $intern_43, $intern_0);
        }
         catch ($e1) {
          $e1 = toJava($e1);
          if (instanceOf($e1, 120)) {
            name_0 = uriFragmentSegment;
          }
           else 
            throw toJs($e1);
        }
      }
      name_0 = $equals_4('%', name_0)?null:decode(name_0);
      for (object$iterator = $iterator_4(this$static.eContents_0()); object$iterator.hasNext_0();) {
        object = $next_17(object$iterator);
        if (instanceOf(object, 179)) {
          eNamedElement = castTo(object, 179);
          otherName = eNamedElement.getName();
          if ((name_0 == null?otherName == null:$equals_4(name_0, otherName)) && count-- == 0) {
            return eNamedElement;
          }
        }
      }
      return null;
    }
  }
  return $eObjectForURIFragmentSegment(this$static, uriFragmentSegment);
}

function $freeze(eModelElement){
  instanceOf(eModelElement, 145) && castTo(eModelElement, 145).freeze();
}

function $getEAnnotation(this$static, source){
  var eAnnotation, eAnnotation$iterator, eAnnotationArray, i, size_0;
  if (this$static.eAnnotations) {
    if (this$static.eAnnotations) {
      size_0 = this$static.eAnnotations.size_0;
      if (size_0 > 0) {
        eAnnotationArray = castTo(this$static.eAnnotations.data_0, 1713);
        if (source == null) {
          for (i = 0; i < size_0; ++i) {
            eAnnotation = eAnnotationArray[i];
            if (eAnnotation.source == null) {
              return eAnnotation;
            }
          }
        }
         else {
          for (i = 0; i < size_0; ++i) {
            eAnnotation = eAnnotationArray[i];
            if ($equals_4(source, eAnnotation.source)) {
              return eAnnotation;
            }
          }
        }
      }
    }
     else {
      if (source == null) {
        for (eAnnotation$iterator = new AbstractEList$EIterator(this$static.eAnnotations); eAnnotation$iterator.cursor != eAnnotation$iterator.this$01_2.size_1();) {
          eAnnotation = castTo($doNext(eAnnotation$iterator), 628);
          if (eAnnotation.source == null) {
            return eAnnotation;
          }
        }
      }
       else {
        for (eAnnotation$iterator = new AbstractEList$EIterator(this$static.eAnnotations); eAnnotation$iterator.cursor != eAnnotation$iterator.this$01_2.size_1();) {
          eAnnotation = castTo($doNext(eAnnotation$iterator), 628);
          if ($equals_4(source, eAnnotation.source)) {
            return eAnnotation;
          }
        }
      }
    }
  }
  return null;
}

defineClass(145, 110, {98:1, 92:1, 89:1, 143:1, 51:1, 106:1, 46:1, 93:1, 145:1, 109:1, 110:1});
_.eGet = function eGet_9(featureID, resolve, coreType){
  var eClass;
  if (featureID == 0) {
    return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_5(otherEnd, featureID, msgs){
  var eClass, feature;
  if (featureID == 0) {
    return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(this.eStaticClass()), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_6(otherEnd, featureID, msgs){
  var eClass, feature;
  if (featureID == 0) {
    return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(this.eStaticClass()), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_8(featureID){
  var eClass;
  if (featureID == 0) {
    return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID));
}
;
_.eObjectForURIFragmentSegment = function eObjectForURIFragmentSegment_0(uriFragmentSegment){
  return $eObjectForURIFragmentSegment_0(this, uriFragmentSegment);
}
;
_.eSet = function eSet_7(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), newValue);
}
;
_.eSetDirectResource = function eSetDirectResource_1(resource){
  $setField(this, 128, resource);
}
;
_.eStaticClass = function eStaticClass_7(){
  return $clinit_EcorePackage$Literals() , EMODEL_ELEMENT;
}
;
_.freeze = function freeze(){
  this.eFlags |= 1;
}
;
_.getEAnnotation = function getEAnnotation(source){
  return $getEAnnotation(this, source);
}
;
_.eFlags = 0;
var Lorg_eclipse_emf_ecore_impl_EModelElementImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EModelElementImpl', 145);
function $clinit_EFactoryImpl(){
  $clinit_EFactoryImpl = emptyMethod;
  HEX_DIGITS = stampJavaTypeInfo(getClassLiteralForArray(C_classLit, 1), $intern_45, 23, 15, [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70]);
  WHITE_SPACE = new RegExp('[ \t\n\r\f]+');
  try {
    EDATE_FORMATS = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_impl_EFactoryImpl$InternalEDateTimeFormat_2_classLit, 1), $intern_1, 1783, 0, [new EFactoryImpl$1ClientInternalEDateTimeFormat(($clinit_DateTimeFormat_0() , getFormat("yyyy-MM-dd'T'HH:mm:ss'.'SSSZ", $getDateTimeFormatInfo(($clinit_LocaleInfo() , $clinit_LocaleInfo() , instance_0))))), new EFactoryImpl$1ClientInternalEDateTimeFormat(getFormat("yyyy-MM-dd'T'HH:mm:ss'.'SSS", $getDateTimeFormatInfo((null , instance_0)))), new EFactoryImpl$1ClientInternalEDateTimeFormat(getFormat("yyyy-MM-dd'T'HH:mm:ss", $getDateTimeFormatInfo((null , instance_0)))), new EFactoryImpl$1ClientInternalEDateTimeFormat(getFormat("yyyy-MM-dd'T'HH:mm", $getDateTimeFormatInfo((null , instance_0)))), new EFactoryImpl$1ClientInternalEDateTimeFormat(getFormat('yyyy-MM-dd', $getDateTimeFormatInfo((null , instance_0))))]);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (!instanceOf($e0, 79))
      throw toJs($e0);
  }
}

function $basicSetEPackage(this$static, newEPackage, msgs){
  var notification, oldEPackage;
  oldEPackage = this$static.ePackage;
  this$static.ePackage = newEPackage;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 1, oldEPackage, newEPackage);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  return msgs;
}

function $bytesToHexString(bytes, count){
  var high, i, j, low, result;
  if (bytes == null) {
    return null;
  }
   else {
    result = initUnidimensionalArray(C_classLit, $intern_45, 23, 2 * count, 15, 1);
    for (i = 0 , j = 0; i < count; ++i) {
      high = bytes[i] >> 4 & 15;
      low = bytes[i] & 15;
      result[j++] = HEX_DIGITS[high];
      result[j++] = HEX_DIGITS[low];
    }
    return valueOf_9(result, 0, result.length);
  }
}

function $convertToString(this$static, eDataType, objectValue){
  var baseType, item_0, item$iterator, itemType, list, memberType, memberType$iterator, memberTypes, result;
  if (this$static.ePackage != eDataType.getEPackage()) {
    throw toJs(new IllegalArgumentException_0("The datatype '" + eDataType.getName() + "' is not a valid classifier"));
  }
  baseType = $getExtendedMetaData(($clinit_ExtendedMetaData() , INSTANCE_11), eDataType).getBaseType();
  if (baseType) {
    return baseType.getEPackage().getEFactoryInstance().convertToString(baseType, objectValue);
  }
  itemType = $getExtendedMetaData(INSTANCE_11, eDataType).getItemType();
  if (itemType) {
    if (objectValue == null) {
      return null;
    }
    list = castTo(objectValue, 15);
    if (list.isEmpty()) {
      return '';
    }
    result = new StringBuffer;
    for (item$iterator = list.iterator_0(); item$iterator.hasNext_0();) {
      item_0 = item$iterator.next_1();
      $append_3(result, itemType.getEPackage().getEFactoryInstance().convertToString(itemType, item_0));
      result.string += ' ';
    }
    return $substring(result, result.string.length - 1);
  }
  memberTypes = $getExtendedMetaData(INSTANCE_11, eDataType).getMemberTypes();
  if (!memberTypes.isEmpty()) {
    for (memberType$iterator = memberTypes.iterator_0(); memberType$iterator.hasNext_0();) {
      memberType = castTo(memberType$iterator.next_1(), 144);
      if (memberType.isInstance(objectValue)) {
        try {
          result = memberType.getEPackage().getEFactoryInstance().convertToString(memberType, objectValue);
          if (result != null) {
            return result;
          }
        }
         catch ($e0) {
          $e0 = toJava($e0);
          if (!instanceOf($e0, 102))
            throw toJs($e0);
        }
      }
    }
    throw toJs(new IllegalArgumentException_0("Invalid value: '" + objectValue + "' for datatype :" + eDataType.getName()));
  }
  castTo(eDataType, 767).getConversionDelegate();
  return objectValue == null?null:instanceOf(objectValue, 161)?'' + castTo(objectValue, 161).value_0:getClass__Ljava_lang_Class___devirtual$(objectValue) == Ljava_util_Date_2_classLit?$format_0(EDATE_FORMATS[0], castTo(objectValue, 185)):toString_41(objectValue);
}

function $createFromString(this$static, eDataType, stringValue){
  var baseType, c, carray, charValue, i, item_0, item$array, item$index, item$max, itemType, memberType, memberType$iterator, memberTypes, result;
  if (stringValue == null) {
    return null;
  }
  if (this$static.ePackage != eDataType.getEPackage()) {
    throw toJs(new IllegalArgumentException_0("The datatype '" + eDataType.getName() + "' is not a valid classifier"));
  }
  if (instanceOf(eDataType, 436)) {
    result = $getEEnumLiteralByLiteral(castTo(eDataType, 627), stringValue);
    if (!result) {
      throw toJs(new IllegalArgumentException_0("The value '" + stringValue + "' is not a valid enumerator of '" + eDataType.getName() + "'"));
    }
    return result;
  }
  switch ($getExtendedMetaData(($clinit_ExtendedMetaData() , INSTANCE_11), eDataType).getWhiteSpaceFacet()) {
    case 2:
      {
        stringValue = normalize(stringValue, false);
        break;
      }

    case 3:
      {
        stringValue = normalize(stringValue, true);
        break;
      }

  }
  baseType = $getExtendedMetaData(INSTANCE_11, eDataType).getBaseType();
  if (baseType) {
    return baseType.getEPackage().getEFactoryInstance().createFromString(baseType, stringValue);
  }
  itemType = $getExtendedMetaData(INSTANCE_11, eDataType).getItemType();
  if (itemType) {
    result = new ArrayList;
    for (item$array = $split_5(stringValue) , item$index = 0 , item$max = item$array.length; item$index < item$max; ++item$index) {
      item_0 = item$array[item$index];
      $add_4(result, itemType.getEPackage().getEFactoryInstance().createFromString(itemType, item_0));
    }
    return result;
  }
  memberTypes = $getExtendedMetaData(INSTANCE_11, eDataType).getMemberTypes();
  if (!memberTypes.isEmpty()) {
    for (memberType$iterator = memberTypes.iterator_0(); memberType$iterator.hasNext_0();) {
      memberType = castTo(memberType$iterator.next_1(), 144);
      try {
        result = memberType.getEPackage().getEFactoryInstance().createFromString(memberType, stringValue);
        if (result != null) {
          return result;
        }
      }
       catch ($e0) {
        $e0 = toJava($e0);
        if (!instanceOf($e0, 54))
          throw toJs($e0);
      }
    }
    throw toJs(new IllegalArgumentException_0("The value '" + stringValue + "' does not match any member types of the union datatype '" + eDataType.getName() + "'"));
  }
  castTo(eDataType, 767).getConversionDelegate();
  c = wrapperClassFor(eDataType.getInstanceClass());
  if (!c)
    return null;
  if (c == Ljava_lang_Character_2_classLit) {
    try {
      charValue = __parseAndValidateInt(stringValue, $intern_43, $intern_0) & $intern_47;
    }
     catch ($e1) {
      $e1 = toJava($e1);
      if (instanceOf($e1, 120)) {
        carray = $toCharArray(stringValue);
        charValue = carray[0];
      }
       else 
        throw toJs($e1);
    }
    return valueOf_3(charValue);
  }
  if (c == Ljava_util_Date_2_classLit) {
    for (i = 0; i < EDATE_FORMATS.length; ++i) {
      try {
        return $parse_2(EDATE_FORMATS[i], stringValue);
      }
       catch ($e2) {
        $e2 = toJava($e2);
        if (!instanceOf($e2, 30))
          throw toJs($e2);
      }
    }
    throw toJs(new IllegalArgumentException_0("The value '" + stringValue + "' is not a date formatted string of the form yyyy-MM-dd'T'HH:mm:ss'.'SSSZ or a valid subset thereof"));
  }
  throw toJs(new IllegalArgumentException_0("The value '" + stringValue + "' is invalid. "));
}

function $hexStringToBytes(initialValue){
  var high, i, j, limit, low, result, size_0;
  if (initialValue == null) {
    return null;
  }
  size_0 = initialValue.length;
  limit = (size_0 + 1) / 2 | 0;
  result = initUnidimensionalArray(B_classLit, $intern_140, 23, limit, 15, 1);
  size_0 % 2 != 0 && (result[--limit] = hexCharToByte(initialValue.charCodeAt(size_0 - 1)));
  for (i = 0 , j = 0; i < limit; ++i) {
    high = hexCharToByte($charAt(initialValue, j++));
    low = hexCharToByte($charAt(initialValue, j++));
    result[i] = (high << 4 | low) << 24 >> 24;
  }
  return result;
}

function $setEPackage(this$static, newEPackage){
  var msgs;
  if (newEPackage != this$static.ePackage) {
    msgs = null;
    !!this$static.ePackage && (msgs = castTo(this$static.ePackage, 46).eInverseRemove(this$static, 4, Lorg_eclipse_emf_ecore_EPackage_2_classLit, null));
    !!newEPackage && (msgs = castTo(newEPackage, 46).eInverseAdd(this$static, 4, Lorg_eclipse_emf_ecore_EPackage_2_classLit, msgs));
    msgs = $basicSetEPackage(this$static, newEPackage, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 1, newEPackage, newEPackage));
}

function $split_5(value_0){
  var i, length_0, result, split_0;
  split_0 = $split(WHITE_SPACE, value_0);
  length_0 = split_0.length;
  result = initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, length_0, 6, 1);
  for (i = 0; i < length_0; ++i) {
    result[i] = split_0[i];
  }
  return result;
}

function EFactoryImpl(){
  $clinit_EFactoryImpl();
}

function hexCharToByte(character){
  switch (character) {
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      {
        return character - 48 << 24 >> 24;
      }

    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
      {
        return character - 97 + 10 << 24 >> 24;
      }

    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
      {
        return character - 65 + 10 << 24 >> 24;
      }

    default:{
        throw toJs(new NumberFormatException('Invalid hexadecimal'));
      }

  }
}

defineClass(660, 145, {98:1, 92:1, 89:1, 445:1, 143:1, 51:1, 106:1, 46:1, 93:1, 145:1, 109:1, 110:1}, EFactoryImpl);
_.convertToString = function convertToString(eDataType, objectValue){
  return $convertToString(this, eDataType, objectValue);
}
;
_.create_3 = function create_40(eClass){
  var eGenericType, eSuperType, eSuperTypes, result, result0;
  if (this.ePackage != $getEPackage(eClass) || (eClass.eFlags & 256) != 0) {
    throw toJs(new IllegalArgumentException_0("The class '" + eClass.name_0 + "' is not a valid classifier"));
  }
  for (eSuperTypes = $getESuperTypes(eClass); $getEGenericSuperTypes(eSuperTypes.this$01).size_0 != 0;) {
    eSuperType = castTo($resolve_1(eSuperTypes, 0, (eGenericType = castTo($get_16($getEGenericSuperTypes(eSuperTypes.this$01), 0), 86) , result0 = eGenericType.eRawType , instanceOf(result0, 99)?castTo(result0, 26):($clinit_EcorePackage$Literals() , EOBJECT))), 26);
    if ($getInstanceClass(eSuperType)) {
      result = $getEPackage(eSuperType).getEFactoryInstance().create_3(eSuperType);
      castTo(result, 46).eSetClass(eClass);
      return result;
    }
    eSuperTypes = $getESuperTypes(eSuperType);
  }
  return (eClass.instanceClassName != null?eClass.instanceClassName:eClass.generatedInstanceClassName) == 'java.util.Map$Entry'?new DynamicEObjectImpl$BasicEMapEntry(eClass):new DynamicEObjectImpl(eClass);
}
;
_.createFromString = function createFromString(eDataType, stringValue){
  return $createFromString(this, eDataType, stringValue);
}
;
_.eGet = function eGet_10(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.ePackage;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EFACTORY)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EFACTORY:eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_6(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 1:
      !!this.ePackage && (msgs = castTo(this.ePackage, 46).eInverseRemove(this, 4, Lorg_eclipse_emf_ecore_EPackage_2_classLit, msgs));
      return $basicSetEPackage(this, castTo(otherEnd, 214), msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EFACTORY):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EFACTORY)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_7(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 1:
      return $basicSetEPackage(this, null, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EFACTORY):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EFACTORY)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_9(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return !!this.ePackage;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EFACTORY)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EFACTORY:eClass), featureID));
}
;
_.eSet = function eSet_8(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setEPackage(this, castTo(newValue, 214));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EFACTORY)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EFACTORY:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_8(){
  return $clinit_EcorePackage$Literals() , EFACTORY;
}
;
var EDATE_FORMATS, HEX_DIGITS, WHITE_SPACE;
var Lorg_eclipse_emf_ecore_impl_EFactoryImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EFactoryImpl', 660);
function ElkGraphFactoryImpl(){
}

function init_1(){
  $clinit_EFactoryImpl();
  var exception, theElkGraphFactory;
  try {
    theElkGraphFactory = castTo($getEFactory(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/elk/ElkGraph'), 1782);
    if (theElkGraphFactory) {
      return theElkGraphFactory;
    }
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 102)) {
      exception = $e0;
      $log(($clinit_EcorePlugin() , exception));
    }
     else 
      throw toJs($e0);
  }
  return new ElkGraphFactoryImpl;
}

defineClass(952, 660, {98:1, 1782:1, 92:1, 89:1, 445:1, 143:1, 51:1, 106:1, 46:1, 93:1, 145:1, 109:1, 110:1}, ElkGraphFactoryImpl);
_.convertToString = function convertToString_0(eDataType, instanceValue){
  switch (eDataType.getClassifierID()) {
    case 12:
      return castTo(instanceValue, 169).getId();
    case 13:
      return toString_41(instanceValue);
    default:throw toJs(new IllegalArgumentException_0("The datatype '" + eDataType.getName() + "' is not a valid classifier"));
  }
}
;
_.create_3 = function create_41(eClass){
  var ePackage, elkBendPoint, elkEdge, elkEdgeSection, elkLabel, elkNode, elkPort, elkPropertyToValueMapEntry;
  switch (eClass.metaObjectID == -1 && (eClass.metaObjectID = (ePackage = $getEPackage(eClass) , ePackage?$indexOf_6(ePackage.getEClassifiers(), eClass):-1)) , eClass.metaObjectID) {
    case 4:
      return elkLabel = new ElkLabelImpl , elkLabel;
    case 6:
      return elkNode = new ElkNodeImpl , elkNode;
    case 7:
      return elkPort = new ElkPortImpl , elkPort;
    case 8:
      return elkEdge = new ElkEdgeImpl , elkEdge;
    case 9:
      return elkBendPoint = new ElkBendPointImpl , elkBendPoint;
    case 10:
      return elkEdgeSection = new ElkEdgeSectionImpl , elkEdgeSection;
    case 11:
      return elkPropertyToValueMapEntry = new ElkPropertyToValueMapEntryImpl , elkPropertyToValueMapEntry;
    default:throw toJs(new IllegalArgumentException_0("The class '" + eClass.name_0 + "' is not a valid classifier"));
  }
}
;
_.createFromString = function createFromString_0(eDataType, initialValue){
  switch (eDataType.getClassifierID()) {
    case 13:
    case 12:
      return null;
    default:throw toJs(new IllegalArgumentException_0("The datatype '" + eDataType.getName() + "' is not a valid classifier"));
  }
}
;
var Lorg_eclipse_elk_graph_impl_ElkGraphFactoryImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkGraphFactoryImpl', 952);
function $setName(this$static, newName){
  var oldName;
  oldName = this$static.name_0;
  this$static.name_0 = newName;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 1, oldName, this$static.name_0));
}

function $toString_17(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_12(this$static);
  result = new StringBuffer_1($toString_12(this$static));
  result.string += ' (name: ';
  $append_3(result, this$static.name_0);
  result.string += ')';
  return result.string;
}

defineClass(417, 145, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 106:1, 46:1, 93:1, 145:1, 109:1, 110:1});
_.eContents_0 = function eContents_2(){
  var eClass, eStructuralFeatures;
  eStructuralFeatures = (eClass = castTo($getField(this, 16), 26) , $containments($getEAllStructuralFeatures(!eClass?this.eStaticClass():eClass)));
  return eStructuralFeatures == null?($clinit_EContentsEList() , $clinit_EContentsEList() , EMPTY_CONTENTS_ELIST):new ENamedElementImpl$1(this, eStructuralFeatures);
}
;
_.eGet = function eGet_11(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.getName();
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), resolve, coreType);
}
;
_.eIsSet = function eIsSet_10(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID));
}
;
_.eSet = function eSet_9(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      this.setName(castToString(newValue));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_9(){
  return $clinit_EcorePackage$Literals() , ENAMED_ELEMENT;
}
;
_.getName = function getName_3(){
  return this.name_0;
}
;
_.setName = function setName(newName){
  $setName(this, newName);
}
;
_.toString_0 = function toString_127(){
  return $toString_17(this);
}
;
_.name_0 = null;
var Lorg_eclipse_emf_ecore_impl_ENamedElementImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ENamedElementImpl', 417);
function $addAnnotation(eNamedElement, source, details){
  var annotations, eAnnotation, eAnnotation0, i, theDetails;
  eAnnotation0 = (eAnnotation = new EAnnotationImpl , eAnnotation);
  $setSourceGen(eAnnotation0, (checkCriticalNotNull(source) , source));
  theDetails = (!eAnnotation0.details && (eAnnotation0.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation0)) , eAnnotation0.details);
  for (i = 1; i < details.length; i += 2) {
    $put_8(theDetails, details[i - 1], details[i]);
  }
  annotations = (!eNamedElement.eAnnotations && (eNamedElement.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, eNamedElement, 0, 3)) , eNamedElement.eAnnotations);
  $add_21(annotations, eAnnotation0);
}

function $addEException(owner, exception){
  $add_21((!owner.eExceptions && (owner.eExceptions = new EOperationImpl$1(owner, owner)) , owner.eExceptions), exception);
}

function $addEOperation(owner, type_0, name_0){
  var eOperation, o;
  o = (eOperation = new EOperationImpl , eOperation);
  $initEOperation(o, type_0, name_0);
  $add_21((!owner.eOperations && (owner.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, owner, 11, 10)) , owner.eOperations), o);
  return o;
}

function $addEParameter(owner, type_0, name_0){
  var p, p_0;
  p = (p_0 = new EParameterImpl , $setEType(p_0, type_0) , $setName(p_0, name_0) , $add_21((!owner.eParameters && (owner.eParameters = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EParameter_2_classLit, owner, 12, 10)) , owner.eParameters), p_0) , p_0);
  $setLowerBound(p, 0);
  $setUpperBound(p, 1);
  $setUnique_2(p, true);
  $setOrdered(p, true);
  return p;
}

function $addEParameter_0(owner, type_0, name_0){
  var eParameter, msgs, p;
  p = (eParameter = new EParameterImpl , eParameter);
  msgs = $setEGenericType(p, type_0, null);
  !!msgs && msgs.dispatch_0();
  $setName(p, name_0);
  $add_21((!owner.eParameters && (owner.eParameters = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EParameter_2_classLit, owner, 12, 10)) , owner.eParameters), p);
  $setLowerBound(p, 0);
  $setUpperBound(p, 1);
  $setUnique_2(p, true);
  $setOrdered(p, true);
}

function $addETypeParameter(owner, name_0){
  var eTypeParameter, eTypeParameter0;
  eTypeParameter0 = (eTypeParameter = new ETypeParameterImpl , eTypeParameter);
  $setName(eTypeParameter0, name_0);
  $add_21((!owner.eTypeParameters && (owner.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, owner, 7)) , owner.eTypeParameters), eTypeParameter0);
  return eTypeParameter0;
}

function $addETypeParameter_0(owner){
  var eTypeParameter, eTypeParameter0;
  eTypeParameter0 = (eTypeParameter = new ETypeParameterImpl , eTypeParameter);
  $setName(eTypeParameter0, 'T');
  $add_21((!owner.eTypeParameters && (owner.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, owner, 11)) , owner.eTypeParameters), eTypeParameter0);
  return eTypeParameter0;
}

function $basicGetESuperPackage(this$static){
  if (this$static.eFlags_0 >> 16 != 7)
    return null;
  return castTo(this$static.eContainer, 214);
}

function $basicSetEFactoryInstance(this$static, newEFactoryInstance, msgs){
  var notification, oldEFactoryInstance;
  oldEFactoryInstance = this$static.eFactoryInstance;
  this$static.eFactoryInstance = newEFactoryInstance;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 4, oldEFactoryInstance, newEFactoryInstance);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  return msgs;
}

function $createEAttribute(owner, id_0){
  var a, eAttribute;
  a = (eAttribute = new EAttributeImpl , eAttribute);
  a.featureID = id_0;
  $add_21((!owner.eStructuralFeatures && (owner.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, owner, 21, 17)) , owner.eStructuralFeatures), a);
}

function $createEClass(this$static, id_0){
  var c, eClass;
  c = (eClass = new EClassImpl , eClass);
  c.metaObjectID = id_0;
  !this$static.eClassifiers && (this$static.eClassifiers = new EPackageImpl$2(this$static, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this$static));
  $add_21(this$static.eClassifiers, c);
  return c;
}

function $createEDataType(this$static, id_0){
  var d, eDataType;
  d = (eDataType = new EDataTypeImpl , eDataType);
  d.metaObjectID = id_0;
  !this$static.eClassifiers && (this$static.eClassifiers = new EPackageImpl$2(this$static, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this$static));
  $add_21(this$static.eClassifiers, d);
  return d;
}

function $createEGenericType(eClassifier){
  var eGenericType, eGenericType0;
  eGenericType0 = (eGenericType = new EGenericTypeImpl , eGenericType);
  $setEClassifier(eGenericType0, eClassifier);
  return eGenericType0;
}

function $createEGenericType_0(eTypeParameter){
  var eGenericType, eGenericType0;
  eGenericType0 = (eGenericType = new EGenericTypeImpl , eGenericType);
  $setETypeParameter(eGenericType0, eTypeParameter);
  return eGenericType0;
}

function $createEOperation(owner){
  var eOperation, o;
  o = (eOperation = new EOperationImpl , eOperation);
  $add_21((!owner.eOperations && (owner.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, owner, 11, 10)) , owner.eOperations), o);
}

function $createEReference(owner, id_0){
  var eReference, r;
  r = (eReference = new EReferenceImpl , eReference);
  r.featureID = id_0;
  $add_21((!owner.eStructuralFeatures && (owner.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, owner, 21, 17)) , owner.eStructuralFeatures), r);
}

function $createResource(this$static, uri_0){
  var actualURI, resource;
  resource = $eInternalResource(this$static);
  if (!resource) {
    !resourceFactory && (resourceFactory = new EPackageImpl$3);
    actualURI = ($clinit_URI() , createURIWithCache(uri_0));
    resource = new BinaryResourceImpl(actualURI);
    $add_21(resource.getContents(), this$static);
  }
  return resource;
}

function $eBasicRemoveFromContainerFeature_1(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 7) {
    return this$static.eContainer.eInverseRemove(this$static, 6, Lorg_eclipse_emf_ecore_EPackage_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EPACKAGE):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $freeze_0(this$static){
  var i, size_0;
  if (this$static.eClassifiers) {
    for (i = 0 , size_0 = this$static.eClassifiers.size_0; i < size_0; ++i) {
      $freeze($get_16(this$static.eClassifiers, i));
    }
  }
  if (this$static.eSubpackages) {
    for (i = 0 , size_0 = this$static.eSubpackages.size_0; i < size_0; ++i) {
      $freeze($get_16(this$static.eSubpackages, i));
    }
  }
  $getNamespace(($clinit_ExtendedMetaData() , INSTANCE_11), this$static);
  this$static.eFlags |= 1;
}

function $getEClassifierGen(this$static, name_0){
  var duplicate, eClassifier, eClassifier$iterator, eClassifiers, key, result;
  if (!this$static.eNameToEClassifierMap) {
    eClassifiers = (!this$static.eClassifiers && (this$static.eClassifiers = new EPackageImpl$2(this$static, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this$static)) , this$static.eClassifiers);
    result = new HashMap_0(eClassifiers.size_0);
    for (eClassifier$iterator = new AbstractEList$EIterator(eClassifiers); eClassifier$iterator.cursor != eClassifier$iterator.this$01_2.size_1();) {
      eClassifier = castTo($doNext(eClassifier$iterator), 136);
      key = eClassifier.getName();
      duplicate = castTo(key == null?$put_4(result.hashCodeMap, null, eClassifier):$put_5(result.stringMap, key, eClassifier), 136);
      !!duplicate && (key == null?$put_4(result.hashCodeMap, null, duplicate):$put_5(result.stringMap, key, duplicate));
    }
    this$static.eNameToEClassifierMap = result;
  }
  return castTo($getStringValue(this$static.eNameToEClassifierMap, name_0), 136);
}

function $initEAttribute(a, type_0, name_0, defaultValue, lowerBound, upperBound, containerClass, isTransient, isVolatile, isChangeable, isUnsettable, isUnique, isDerived){
  $initEStructuralFeature(a, type_0, name_0, defaultValue, lowerBound, upperBound, containerClass, isTransient, isVolatile, isChangeable, isUnsettable, isUnique, isDerived);
  $setID(a, false);
  return a;
}

function $initEAttribute_0(a, type_0, name_0, containerClass, isTransient, isVolatile, isChangeable, isDerived){
  var msgs;
  instanceOf(a.eContainer, 99) && $setFlags_0($getESuperAdapter(castTo(a.eContainer, 99)), 4);
  $setName(a, name_0);
  a.containerClass = containerClass;
  $setTransient(a, isTransient);
  $setVolatile(a, isVolatile);
  $setChangeable(a, isChangeable);
  $setUnsettable(a, false);
  $setUnique_2(a, true);
  $setDerived(a, isDerived);
  $setOrdered(a, true);
  $setLowerBound(a, 0);
  a.effectiveIsMany = 0;
  $setUpperBound(a, 1);
  msgs = $setEGenericType(a, type_0, null);
  !!msgs && msgs.dispatch_0();
  $setID(a, false);
  return a;
}

function $initEClass(c, instanceClass, name_0, isAbstract, isInterface, isGenerated){
  $initEClassifier(c, instanceClass, name_0, isGenerated);
  $setAbstract(c, isAbstract);
  $setInterface(c, isInterface);
  return c;
}

function $initEClassifier(o, instanceClass, name_0, isGenerated){
  instanceOf(o.eContainer, 255) && (castTo(o.eContainer, 255).eNameToEClassifierMap = null);
  $setName(o, name_0);
  !!instanceClass && $setInstanceClass(o, instanceClass);
  isGenerated && o.setGeneratedInstanceClass(true);
}

function $initEDataType(d, instanceClass, name_0, isSerializable){
  $initEClassifier(d, instanceClass, name_0, false);
  $setSerializable(d, isSerializable);
  return d;
}

function $initEOperation(eOperation, type_0, name_0){
  $setEType(eOperation, type_0);
  $setName(eOperation, name_0);
  $setLowerBound(eOperation, 0);
  $setUpperBound(eOperation, 1);
  $setUnique_2(eOperation, true);
  $setOrdered(eOperation, true);
  return eOperation;
}

function $initEReference(r, type_0, otherEnd, name_0, lowerBound, upperBound, containerClass, isTransient, isVolatile, isChangeable, isContainment, isResolveProxies, isUnsettable, isDerived){
  $initEStructuralFeature(r, type_0, name_0, null, lowerBound, upperBound, containerClass, isTransient, isVolatile, isChangeable, isUnsettable, true, isDerived);
  $setContainmentGen(r, isContainment);
  instanceOf(r.eContainer, 99) && $setFlags_0($getESuperAdapter(castTo(r.eContainer, 99)), 2);
  !!otherEnd && $setEOpposite(r, otherEnd);
  $setResolveProxies(r, isResolveProxies);
  return r;
}

function $initEStructuralFeature(s, type_0, name_0, defaultValue, lowerBound, upperBound, containerClass, isTransient, isVolatile, isChangeable, isUnsettable, isUnique, isDerived){
  instanceOf(s.eContainer, 99) && $setFlags_0($getESuperAdapter(castTo(s.eContainer, 99)), 4);
  $setName(s, name_0);
  s.containerClass = containerClass;
  $setTransient(s, isTransient);
  $setVolatile(s, isVolatile);
  $setChangeable(s, isChangeable);
  $setUnsettable(s, isUnsettable);
  $setUnique_2(s, isUnique);
  $setDerived(s, isDerived);
  $setOrdered(s, true);
  $setLowerBound(s, lowerBound);
  s.setUpperBound(upperBound);
  $setEType(s, type_0);
  defaultValue != null && (s.defaultValueFactory = null , $setDefaultValueLiteralGen(s, defaultValue));
}

function $setEFactoryInstance(this$static, newEFactoryInstance){
  var msgs;
  if (newEFactoryInstance != this$static.eFactoryInstance) {
    msgs = null;
    !!this$static.eFactoryInstance && (msgs = castTo(this$static.eFactoryInstance, 46).eInverseRemove(this$static, 1, Lorg_eclipse_emf_ecore_EFactory_2_classLit, null));
    !!newEFactoryInstance && (msgs = castTo(newEFactoryInstance, 46).eInverseAdd(this$static, 1, Lorg_eclipse_emf_ecore_EFactory_2_classLit, msgs));
    msgs = $basicSetEFactoryInstance(this$static, newEFactoryInstance, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 4, newEFactoryInstance, newEFactoryInstance));
}

function $setNsPrefix(this$static, newNsPrefix){
  var oldNsPrefix;
  oldNsPrefix = this$static.nsPrefix;
  this$static.nsPrefix = newNsPrefix;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 3, oldNsPrefix, this$static.nsPrefix));
}

function $setNsURI(this$static, newNsURI){
  var oldNsURI;
  oldNsURI = this$static.nsURI;
  this$static.nsURI = newNsURI;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 2, oldNsURI, this$static.nsURI));
}

function EPackageImpl(){
  $setEFactoryInstance(this, new EFactoryImpl);
  this.ecorePackage = ($clinit_EcorePackage() , eINSTANCE_2);
  $clinit_EcoreFactory();
}

function EPackageImpl_0(packageURI, factory){
  var registration;
  registration = $getStringValue(($clinit_EPackage$Registry() , INSTANCE_6), packageURI);
  instanceOf(registration, 469)?$putStringValue(INSTANCE_6, packageURI, new EPackageImpl$1(this, factory)):$putStringValue(INSTANCE_6, packageURI, this);
  $setEFactoryInstance(this, factory);
  if (factory == ($clinit_EcoreFactory() , eINSTANCE_1)) {
    this.ecorePackage = castTo(this, 1718);
    castTo(factory, 1720);
  }
   else {
    this.ecorePackage = ($clinit_EcorePackage() , eINSTANCE_2);
  }
}

defineClass(255, 417, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 214:1, 106:1, 46:1, 93:1, 145:1, 255:1, 109:1, 110:1, 632:1}, EPackageImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_2(msgs){
  return $eBasicRemoveFromContainerFeature_1(this, msgs);
}
;
_.eGet = function eGet_12(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return this.nsURI;
    case 3:
      return this.nsPrefix;
    case 4:
      return this.eFactoryInstance;
    case 5:
      return !this.eClassifiers && (this.eClassifiers = new EPackageImpl$2(this, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this)) , this.eClassifiers;
    case 6:
      return !this.eSubpackages && (this.eSubpackages = new EObjectContainmentWithInverseEList$Resolving(Lorg_eclipse_emf_ecore_EPackage_2_classLit, this, 6, 7)) , this.eSubpackages;
    case 7:
      if (resolve)
        return this.eFlags_0 >> 16 == 7?castTo(this.eContainer, 214):null;
      return $basicGetESuperPackage(this);
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPACKAGE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EPACKAGE:eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_7(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 4:
      !!this.eFactoryInstance && (msgs = castTo(this.eFactoryInstance, 46).eInverseRemove(this, 1, Lorg_eclipse_emf_ecore_EFactory_2_classLit, msgs));
      return $basicSetEFactoryInstance(this, castTo(otherEnd, 445), msgs);
    case 5:
      return !this.eClassifiers && (this.eClassifiers = new EPackageImpl$2(this, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this)) , $basicAdd_0(this.eClassifiers, otherEnd, msgs);
    case 6:
      return !this.eSubpackages && (this.eSubpackages = new EObjectContainmentWithInverseEList$Resolving(Lorg_eclipse_emf_ecore_EPackage_2_classLit, this, 6, 7)) , $basicAdd_0(this.eSubpackages, otherEnd, msgs);
    case 7:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_1(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $eBasicSetContainer(this, otherEnd, 7, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EPACKAGE):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPACKAGE)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_8(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 4:
      return $basicSetEFactoryInstance(this, null, msgs);
    case 5:
      return !this.eClassifiers && (this.eClassifiers = new EPackageImpl$2(this, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this)) , $basicRemove_0(this.eClassifiers, otherEnd, msgs);
    case 6:
      return !this.eSubpackages && (this.eSubpackages = new EObjectContainmentWithInverseEList$Resolving(Lorg_eclipse_emf_ecore_EPackage_2_classLit, this, 6, 7)) , $basicRemove_0(this.eSubpackages, otherEnd, msgs);
    case 7:
      return $eBasicSetContainer(this, null, 7, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EPACKAGE):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPACKAGE)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_11(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return this.nsURI != null;
    case 3:
      return this.nsPrefix != null;
    case 4:
      return !!this.eFactoryInstance;
    case 5:
      return !!this.eClassifiers && this.eClassifiers.size_0 != 0;
    case 6:
      return !!this.eSubpackages && this.eSubpackages.size_0 != 0;
    case 7:
      return !!$basicGetESuperPackage(this);
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPACKAGE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EPACKAGE:eClass), featureID));
}
;
_.eObjectForURIFragmentSegment = function eObjectForURIFragmentSegment_1(uriFragmentSegment){
  var result;
  result = $getEClassifierGen(this, uriFragmentSegment);
  return result?result:$eObjectForURIFragmentSegment_0(this, uriFragmentSegment);
}
;
_.eSet = function eSet_10(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName(this, castToString(newValue));
      return;
    case 2:
      $setNsURI(this, castToString(newValue));
      return;
    case 3:
      $setNsPrefix(this, castToString(newValue));
      return;
    case 4:
      $setEFactoryInstance(this, castTo(newValue, 445));
      return;
    case 5:
      !this.eClassifiers && (this.eClassifiers = new EPackageImpl$2(this, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this));
      $clear_11(this.eClassifiers);
      !this.eClassifiers && (this.eClassifiers = new EPackageImpl$2(this, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this));
      $addAll_6(this.eClassifiers, castTo(newValue, 13));
      return;
    case 6:
      !this.eSubpackages && (this.eSubpackages = new EObjectContainmentWithInverseEList$Resolving(Lorg_eclipse_emf_ecore_EPackage_2_classLit, this, 6, 7));
      $clear_11(this.eSubpackages);
      !this.eSubpackages && (this.eSubpackages = new EObjectContainmentWithInverseEList$Resolving(Lorg_eclipse_emf_ecore_EPackage_2_classLit, this, 6, 7));
      $addAll_6(this.eSubpackages, castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPACKAGE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EPACKAGE:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_10(){
  return $clinit_EcorePackage$Literals() , EPACKAGE;
}
;
_.freeze = function freeze_0(){
  $freeze_0(this);
}
;
_.getEClassifiers = function getEClassifiers(){
  return !this.eClassifiers && (this.eClassifiers = new EPackageImpl$2(this, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, this)) , this.eClassifiers;
}
;
_.getEFactoryInstance = function getEFactoryInstance(){
  return this.eFactoryInstance;
}
;
_.getExtendedMetaData = function getExtendedMetaData(){
  return this.ePackageExtendedMetaData;
}
;
_.getNsPrefix = function getNsPrefix(){
  return this.nsPrefix;
}
;
_.getNsURI = function getNsURI(){
  return this.nsURI;
}
;
_.setExtendedMetaData = function setExtendedMetaData(ePackageExtendedMetaData){
  this.ePackageExtendedMetaData = ePackageExtendedMetaData;
}
;
_.toString_0 = function toString_128(){
  var result;
  if ((this.eFlags_0 & 64) != 0)
    return $toString_17(this);
  result = new StringBuffer_1($toString_17(this));
  result.string += ' (nsURI: ';
  $append_3(result, this.nsURI);
  result.string += ', nsPrefix: ';
  $append_3(result, this.nsPrefix);
  result.string += ')';
  return result.string;
}
;
_.nsPrefix = null;
_.nsURI = null;
var resourceFactory;
var Lorg_eclipse_emf_ecore_impl_EPackageImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EPackageImpl', 255);
function $createPackageContents(this$static){
  if (this$static.isCreated)
    return;
  this$static.isCreated = true;
  this$static.iPropertyHolderEClass = $createEClass(this$static, 0);
  this$static.eMapPropertyHolderEClass = $createEClass(this$static, 1);
  $createEReference(this$static.eMapPropertyHolderEClass, 0);
  this$static.elkGraphElementEClass = $createEClass(this$static, 2);
  $createEReference(this$static.elkGraphElementEClass, 1);
  $createEAttribute(this$static.elkGraphElementEClass, 2);
  this$static.elkShapeEClass = $createEClass(this$static, 3);
  $createEAttribute(this$static.elkShapeEClass, 3);
  $createEAttribute(this$static.elkShapeEClass, 4);
  $createEAttribute(this$static.elkShapeEClass, 5);
  $createEAttribute(this$static.elkShapeEClass, 6);
  this$static.elkLabelEClass = $createEClass(this$static, 4);
  $createEReference(this$static.elkLabelEClass, 7);
  $createEAttribute(this$static.elkLabelEClass, 8);
  this$static.elkConnectableShapeEClass = $createEClass(this$static, 5);
  $createEReference(this$static.elkConnectableShapeEClass, 7);
  $createEReference(this$static.elkConnectableShapeEClass, 8);
  this$static.elkNodeEClass = $createEClass(this$static, 6);
  $createEReference(this$static.elkNodeEClass, 9);
  $createEReference(this$static.elkNodeEClass, 10);
  $createEReference(this$static.elkNodeEClass, 11);
  $createEReference(this$static.elkNodeEClass, 12);
  $createEAttribute(this$static.elkNodeEClass, 13);
  this$static.elkPortEClass = $createEClass(this$static, 7);
  $createEReference(this$static.elkPortEClass, 9);
  this$static.elkEdgeEClass = $createEClass(this$static, 8);
  $createEReference(this$static.elkEdgeEClass, 3);
  $createEReference(this$static.elkEdgeEClass, 4);
  $createEReference(this$static.elkEdgeEClass, 5);
  $createEReference(this$static.elkEdgeEClass, 6);
  $createEAttribute(this$static.elkEdgeEClass, 7);
  $createEAttribute(this$static.elkEdgeEClass, 8);
  $createEAttribute(this$static.elkEdgeEClass, 9);
  $createEAttribute(this$static.elkEdgeEClass, 10);
  this$static.elkBendPointEClass = $createEClass(this$static, 9);
  $createEAttribute(this$static.elkBendPointEClass, 0);
  $createEAttribute(this$static.elkBendPointEClass, 1);
  this$static.elkEdgeSectionEClass = $createEClass(this$static, 10);
  $createEAttribute(this$static.elkEdgeSectionEClass, 1);
  $createEAttribute(this$static.elkEdgeSectionEClass, 2);
  $createEAttribute(this$static.elkEdgeSectionEClass, 3);
  $createEAttribute(this$static.elkEdgeSectionEClass, 4);
  $createEReference(this$static.elkEdgeSectionEClass, 5);
  $createEReference(this$static.elkEdgeSectionEClass, 6);
  $createEReference(this$static.elkEdgeSectionEClass, 7);
  $createEReference(this$static.elkEdgeSectionEClass, 8);
  $createEReference(this$static.elkEdgeSectionEClass, 9);
  $createEReference(this$static.elkEdgeSectionEClass, 10);
  $createEAttribute(this$static.elkEdgeSectionEClass, 11);
  this$static.elkPropertyToValueMapEntryEClass = $createEClass(this$static, 11);
  $createEAttribute(this$static.elkPropertyToValueMapEntryEClass, 0);
  $createEAttribute(this$static.elkPropertyToValueMapEntryEClass, 1);
  this$static.iPropertyEDataType = $createEDataType(this$static, 12);
  this$static.propertyValueEDataType = $createEDataType(this$static, 13);
}

function $initializePackageContents(this$static){
  var eGenericType, eGenericType0, eGenericType1, eGenericType2, eGenericType3, eGenericType4, eGenericType5, eGenericType6, g1, g2, g3, msgs, msgs0, op, t1;
  if (this$static.isInitialized)
    return;
  this$static.isInitialized = true;
  $setName(this$static, 'graph');
  $setNsPrefix(this$static, 'graph');
  $setNsURI(this$static, 'http://www.eclipse.org/elk/ElkGraph');
  $addETypeParameter(this$static.iPropertyEDataType, 'T');
  $add_21($getESuperTypes(this$static.eMapPropertyHolderEClass), this$static.iPropertyHolderEClass);
  $add_21($getESuperTypes(this$static.elkGraphElementEClass), this$static.eMapPropertyHolderEClass);
  $add_21($getESuperTypes(this$static.elkShapeEClass), this$static.elkGraphElementEClass);
  $add_21($getESuperTypes(this$static.elkLabelEClass), this$static.elkShapeEClass);
  $add_21($getESuperTypes(this$static.elkConnectableShapeEClass), this$static.elkShapeEClass);
  $add_21($getESuperTypes(this$static.elkNodeEClass), this$static.elkConnectableShapeEClass);
  $add_21($getESuperTypes(this$static.elkPortEClass), this$static.elkConnectableShapeEClass);
  $add_21($getESuperTypes(this$static.elkEdgeEClass), this$static.elkGraphElementEClass);
  $add_21($getESuperTypes(this$static.elkEdgeSectionEClass), this$static.eMapPropertyHolderEClass);
  $initEClass(this$static.iPropertyHolderEClass, Lorg_eclipse_elk_graph_properties_IPropertyHolder_2_classLit, 'IPropertyHolder', true, true, false);
  op = $addEOperation(this$static.iPropertyHolderEClass, this$static.iPropertyHolderEClass, 'setProperty');
  t1 = $addETypeParameter_0(op);
  g1 = $createEGenericType(this$static.iPropertyEDataType);
  g2 = (eGenericType0 = (eGenericType1 = new EGenericTypeImpl , eGenericType1) , eGenericType0);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  g3 = $createEGenericType_0(t1);
  $setELowerBound(g2, g3);
  $addEParameter_0(op, g1, 'property');
  g1 = $createEGenericType_0(t1);
  $addEParameter_0(op, g1, 'value');
  op = $addEOperation(this$static.iPropertyHolderEClass, null, 'getProperty');
  t1 = $addETypeParameter_0(op);
  g1 = $createEGenericType(this$static.iPropertyEDataType);
  g2 = $createEGenericType_0(t1);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  $addEParameter_0(op, g1, 'property');
  g1 = $createEGenericType_0(t1);
  msgs0 = $setEGenericType(op, g1, null);
  !!msgs0 && msgs0.dispatch_0();
  op = $addEOperation(this$static.iPropertyHolderEClass, this$static.ecorePackage.eBooleanEDataType, 'hasProperty');
  g1 = $createEGenericType(this$static.iPropertyEDataType);
  g2 = (eGenericType2 = (eGenericType3 = new EGenericTypeImpl , eGenericType3) , eGenericType2);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  $addEParameter_0(op, g1, 'property');
  op = $addEOperation(this$static.iPropertyHolderEClass, this$static.iPropertyHolderEClass, 'copyProperties');
  $addEParameter(op, this$static.iPropertyHolderEClass, 'source');
  op = $addEOperation(this$static.iPropertyHolderEClass, null, 'getAllProperties');
  g1 = $createEGenericType(this$static.ecorePackage.eMapEDataType);
  g2 = $createEGenericType(this$static.iPropertyEDataType);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  g3 = (eGenericType4 = (eGenericType5 = new EGenericTypeImpl , eGenericType5) , eGenericType4);
  $add_21((!g2.eTypeArguments && (g2.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g2, 1)) , g2.eTypeArguments), g3);
  g2 = $createEGenericType(this$static.ecorePackage.eJavaObjectEDataType);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  msgs = $setEGenericType(op, g1, null);
  !!msgs && msgs.dispatch_0();
  $initEClass(this$static.eMapPropertyHolderEClass, Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit, 'EMapPropertyHolder', true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eMapPropertyHolderEClass), 0), 17), this$static.elkPropertyToValueMapEntryEClass, null, 'properties', 0, -1, Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit, false, false, true, true, false, false, false);
  $initEClass(this$static.elkGraphElementEClass, Lorg_eclipse_elk_graph_ElkGraphElement_2_classLit, 'ElkGraphElement', true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkGraphElementEClass), 0), 17), this$static.elkLabelEClass, castTo($get_16($getEStructuralFeatures(this$static.elkLabelEClass), 0), 17), 'labels', 0, -1, Lorg_eclipse_elk_graph_ElkGraphElement_2_classLit, false, false, true, true, false, false, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkGraphElementEClass), 1), 29), this$static.ecorePackage.eStringEDataType, 'identifier', null, 0, 1, Lorg_eclipse_elk_graph_ElkGraphElement_2_classLit, false, false, true, false, true, false);
  $initEClass(this$static.elkShapeEClass, Lorg_eclipse_elk_graph_ElkShape_2_classLit, 'ElkShape', true, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkShapeEClass), 0), 29), this$static.ecorePackage.eDoubleEDataType, 'height', '0.0', 1, 1, Lorg_eclipse_elk_graph_ElkShape_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkShapeEClass), 1), 29), this$static.ecorePackage.eDoubleEDataType, 'width', '0.0', 1, 1, Lorg_eclipse_elk_graph_ElkShape_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkShapeEClass), 2), 29), this$static.ecorePackage.eDoubleEDataType, 'x', '0.0', 1, 1, Lorg_eclipse_elk_graph_ElkShape_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkShapeEClass), 3), 29), this$static.ecorePackage.eDoubleEDataType, 'y', '0.0', 1, 1, Lorg_eclipse_elk_graph_ElkShape_2_classLit, false, false, true, false, true, false);
  op = $addEOperation(this$static.elkShapeEClass, null, 'setDimensions');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'width');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'height');
  op = $addEOperation(this$static.elkShapeEClass, null, 'setLocation');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'x');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'y');
  $initEClass(this$static.elkLabelEClass, Lorg_eclipse_elk_graph_ElkLabel_2_classLit, 'ElkLabel', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkLabelEClass), 0), 17), this$static.elkGraphElementEClass, castTo($get_16($getEStructuralFeatures(this$static.elkGraphElementEClass), 0), 17), 'parent', 0, 1, Lorg_eclipse_elk_graph_ElkLabel_2_classLit, false, false, true, false, false, false, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkLabelEClass), 1), 29), this$static.ecorePackage.eStringEDataType, 'text', '', 0, 1, Lorg_eclipse_elk_graph_ElkLabel_2_classLit, false, false, true, false, true, false);
  $initEClass(this$static.elkConnectableShapeEClass, Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, 'ElkConnectableShape', true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkConnectableShapeEClass), 0), 17), this$static.elkEdgeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 1), 17), 'outgoingEdges', 0, -1, Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, false, false, true, false, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkConnectableShapeEClass), 1), 17), this$static.elkEdgeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 2), 17), 'incomingEdges', 0, -1, Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, false, false, true, false, true, false, false);
  $initEClass(this$static.elkNodeEClass, Lorg_eclipse_elk_graph_ElkNode_2_classLit, 'ElkNode', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 0), 17), this$static.elkPortEClass, castTo($get_16($getEStructuralFeatures(this$static.elkPortEClass), 0), 17), 'ports', 0, -1, Lorg_eclipse_elk_graph_ElkNode_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 1), 17), this$static.elkNodeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 2), 17), 'children', 0, -1, Lorg_eclipse_elk_graph_ElkNode_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 2), 17), this$static.elkNodeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 1), 17), 'parent', 0, 1, Lorg_eclipse_elk_graph_ElkNode_2_classLit, false, false, true, false, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 3), 17), this$static.elkEdgeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 0), 17), 'containedEdges', 0, -1, Lorg_eclipse_elk_graph_ElkNode_2_classLit, false, false, true, true, false, false, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 4), 29), this$static.ecorePackage.eBooleanEDataType, 'hierarchical', null, 0, 1, Lorg_eclipse_elk_graph_ElkNode_2_classLit, true, true, false, false, true, true);
  $initEClass(this$static.elkPortEClass, Lorg_eclipse_elk_graph_ElkPort_2_classLit, 'ElkPort', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkPortEClass), 0), 17), this$static.elkNodeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 0), 17), 'parent', 0, 1, Lorg_eclipse_elk_graph_ElkPort_2_classLit, false, false, true, false, false, false, false);
  $initEClass(this$static.elkEdgeEClass, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, 'ElkEdge', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 0), 17), this$static.elkNodeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkNodeEClass), 3), 17), 'containingNode', 0, 1, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, false, false, true, false, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 1), 17), this$static.elkConnectableShapeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkConnectableShapeEClass), 0), 17), 'sources', 0, -1, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, false, false, true, false, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 2), 17), this$static.elkConnectableShapeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkConnectableShapeEClass), 1), 17), 'targets', 0, -1, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, false, false, true, false, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 3), 17), this$static.elkEdgeSectionEClass, castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 5), 17), 'sections', 0, -1, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, false, false, true, true, false, false, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 4), 29), this$static.ecorePackage.eBooleanEDataType, 'hyperedge', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, true, true, false, false, true, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 5), 29), this$static.ecorePackage.eBooleanEDataType, 'hierarchical', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, true, true, false, false, true, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 6), 29), this$static.ecorePackage.eBooleanEDataType, 'selfloop', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, true, true, false, false, true, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 7), 29), this$static.ecorePackage.eBooleanEDataType, 'connected', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdge_2_classLit, true, true, false, false, true, true);
  $initEClass(this$static.elkBendPointEClass, Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, 'ElkBendPoint', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkBendPointEClass), 0), 29), this$static.ecorePackage.eDoubleEDataType, 'x', '0.0', 1, 1, Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkBendPointEClass), 1), 29), this$static.ecorePackage.eDoubleEDataType, 'y', '0.0', 1, 1, Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, false, false, true, false, true, false);
  op = $addEOperation(this$static.elkBendPointEClass, null, 'set');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'x');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'y');
  $initEClass(this$static.elkEdgeSectionEClass, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, 'ElkEdgeSection', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 0), 29), this$static.ecorePackage.eDoubleEDataType, 'startX', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 1), 29), this$static.ecorePackage.eDoubleEDataType, 'startY', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 2), 29), this$static.ecorePackage.eDoubleEDataType, 'endX', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 3), 29), this$static.ecorePackage.eDoubleEDataType, 'endY', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 4), 17), this$static.elkBendPointEClass, null, 'bendPoints', 0, -1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 5), 17), this$static.elkEdgeEClass, castTo($get_16($getEStructuralFeatures(this$static.elkEdgeEClass), 3), 17), 'parent', 0, 1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 6), 17), this$static.elkConnectableShapeEClass, null, 'outgoingShape', 0, 1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 7), 17), this$static.elkConnectableShapeEClass, null, 'incomingShape', 0, 1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 8), 17), this$static.elkEdgeSectionEClass, castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 9), 17), 'outgoingSections', 0, -1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 9), 17), this$static.elkEdgeSectionEClass, castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 8), 17), 'incomingSections', 0, -1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkEdgeSectionEClass), 10), 29), this$static.ecorePackage.eStringEDataType, 'identifier', null, 0, 1, Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, false, false, true, false, true, false);
  op = $addEOperation(this$static.elkEdgeSectionEClass, null, 'setStartLocation');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'x');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'y');
  op = $addEOperation(this$static.elkEdgeSectionEClass, null, 'setEndLocation');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'x');
  $addEParameter(op, this$static.ecorePackage.eDoubleEDataType, 'y');
  $initEClass(this$static.elkPropertyToValueMapEntryEClass, Ljava_util_Map$Entry_2_classLit, 'ElkPropertyToValueMapEntry', false, false, false);
  g1 = $createEGenericType(this$static.iPropertyEDataType);
  g2 = (eGenericType6 = (eGenericType = new EGenericTypeImpl , eGenericType) , eGenericType6);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  $initEAttribute_0(castTo($get_16($getEStructuralFeatures(this$static.elkPropertyToValueMapEntryEClass), 0), 29), g1, 'key', Ljava_util_Map$Entry_2_classLit, false, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.elkPropertyToValueMapEntryEClass), 1), 29), this$static.propertyValueEDataType, 'value', null, 0, 1, Ljava_util_Map$Entry_2_classLit, false, false, true, false, true, false);
  $initEDataType(this$static.iPropertyEDataType, Lorg_eclipse_elk_graph_properties_IProperty_2_classLit, 'IProperty', true);
  $initEDataType(this$static.propertyValueEDataType, Ljava_lang_Object_2_classLit, 'PropertyValue', true);
  $createResource(this$static, 'http://www.eclipse.org/elk/ElkGraph');
}

function ElkGraphPackageImpl(){
  EPackageImpl_0.call(this, 'http://www.eclipse.org/elk/ElkGraph', ($clinit_ElkGraphFactory() , eINSTANCE));
  this.iPropertyHolderEClass = null;
  this.eMapPropertyHolderEClass = null;
  this.elkGraphElementEClass = null;
  this.elkShapeEClass = null;
  this.elkLabelEClass = null;
  this.elkConnectableShapeEClass = null;
  this.elkNodeEClass = null;
  this.elkPortEClass = null;
  this.elkEdgeEClass = null;
  this.elkBendPointEClass = null;
  this.elkEdgeSectionEClass = null;
  this.elkPropertyToValueMapEntryEClass = null;
  this.iPropertyEDataType = null;
  this.propertyValueEDataType = null;
  this.isCreated = false;
  this.isInitialized = false;
}

function init_2(){
  var theElkGraphPackage;
  if (isInited)
    return castTo($getEPackage_0(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/elk/ElkGraph'), 1785);
  theElkGraphPackage = castTo(instanceOf($getStringValue(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/elk/ElkGraph'), 530)?$getStringValue(INSTANCE_6, 'http://www.eclipse.org/elk/ElkGraph'):new ElkGraphPackageImpl, 530);
  isInited = true;
  $createPackageContents(theElkGraphPackage);
  $initializePackageContents(theElkGraphPackage);
  $freeze_0(theElkGraphPackage);
  $putStringValue(INSTANCE_6, 'http://www.eclipse.org/elk/ElkGraph', theElkGraphPackage);
  return theElkGraphPackage;
}

defineClass(530, 255, {98:1, 1785:1, 530:1, 92:1, 89:1, 143:1, 179:1, 51:1, 214:1, 106:1, 46:1, 93:1, 145:1, 255:1, 109:1, 110:1, 632:1}, ElkGraphPackageImpl);
_.isCreated = false;
_.isInitialized = false;
var isInited = false;
var Lorg_eclipse_elk_graph_impl_ElkGraphPackageImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkGraphPackageImpl', 530);
function $basicSetParent_0(this$static, newParent, msgs){
  msgs = $eBasicSetContainer(this$static, castTo(newParent, 46), 7, msgs);
  return msgs;
}

function $eBasicRemoveFromContainerFeature_2(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 7) {
    return this$static.eContainer.eInverseRemove(this$static, 1, Lorg_eclipse_elk_graph_ElkGraphElement_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_ElkGraphPackage$Literals() , ELK_LABEL):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getParent_1(this$static){
  if (this$static.eFlags_0 >> 16 != 7)
    return null;
  return castTo(this$static.eContainer, 202);
}

function $setParent_0(this$static, newParent){
  var eContainerFeatureID, msgs;
  if (newParent != this$static.eContainer || this$static.eFlags_0 >> 16 != 7 && !!newParent) {
    if (isAncestor(this$static, newParent))
      throw toJs(new IllegalArgumentException_0('Recursive containment not allowed for ' + $toString_18(this$static)));
    msgs = null;
    !!this$static.eContainer && (msgs = (eContainerFeatureID = this$static.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_2(this$static, null):this$static.eContainer.eInverseRemove(this$static, -1 - eContainerFeatureID, null, null)));
    !!newParent && (msgs = castTo(newParent, 46).eInverseAdd(this$static, 1, Lorg_eclipse_elk_graph_ElkGraphElement_2_classLit, msgs));
    msgs = $basicSetParent_0(this$static, newParent, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 7, newParent, newParent));
}

function $setText(this$static, newText){
  var oldText;
  oldText = this$static.text_0;
  this$static.text_0 = newText;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 8, oldText, this$static.text_0));
}

function $toString_18(this$static){
  var builder;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_14(this$static);
  builder = new StringBuilder_1('ElkLabel');
  !this$static.text_0 || $append_11($append_11((builder.string += ' "' , builder), this$static.text_0), '"');
  $append_11($append_6($append_11($append_6($append_11($append_6($append_11($append_6((builder.string += ' (' , builder), this$static.x_0), ','), this$static.y_0), ' | '), this$static.width_0), ','), this$static.height), ')');
  return builder.string;
}

function ElkLabelImpl(){
}

defineClass(241, 671, {98:1, 392:1, 202:1, 135:1, 444:1, 241:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1}, ElkLabelImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_3(msgs){
  return $eBasicRemoveFromContainerFeature_2(this, msgs);
}
;
_.eGet = function eGet_13(featureID, resolve, coreType){
  switch (featureID) {
    case 7:
      return $getParent_1(this);
    case 8:
      return this.text_0;
  }
  return $eGet_5(this, featureID, resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_8(otherEnd, featureID, msgs){
  var eContainerFeatureID;
  switch (featureID) {
    case 7:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_2(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $basicSetParent_0(this, castTo(otherEnd, 202), msgs);
  }
  return $eInverseAdd_0(this, otherEnd, featureID, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_9(otherEnd, featureID, msgs){
  if (featureID == 7) {
    return $basicSetParent_0(this, null, msgs);
  }
  return $eInverseRemove_1(this, otherEnd, featureID, msgs);
}
;
_.eIsSet = function eIsSet_12(featureID){
  switch (featureID) {
    case 7:
      return !!$getParent_1(this);
    case 8:
      return !$equals_4('', this.text_0);
  }
  return $eIsSet_2(this, featureID);
}
;
_.eSet = function eSet_11(featureID, newValue){
  switch (featureID) {
    case 7:
      $setParent_0(this, castTo(newValue, 202));
      return;
    case 8:
      $setText(this, castToString(newValue));
      return;
  }
  $eSet_3(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_11(){
  return $clinit_ElkGraphPackage$Literals() , ELK_LABEL;
}
;
_.toString_0 = function toString_129(){
  return $toString_18(this);
}
;
_.text_0 = '';
var Lorg_eclipse_elk_graph_impl_ElkLabelImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkLabelImpl', 241);
function $basicSetParent_1(this$static, newParent, msgs){
  msgs = $eBasicSetContainer(this$static, newParent, 11, msgs);
  return msgs;
}

function $eBasicRemoveFromContainerFeature_3(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 11) {
    return this$static.eContainer.eInverseRemove(this$static, 10, Lorg_eclipse_elk_graph_ElkNode_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_ElkGraphPackage$Literals() , ELK_NODE):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getChildren(this$static){
  !this$static.children && (this$static.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, this$static, 10, 11));
  return this$static.children;
}

function $getContainedEdges(this$static){
  !this$static.containedEdges && (this$static.containedEdges = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this$static, 12, 3));
  return this$static.containedEdges;
}

function $getParent_2(this$static){
  if (this$static.eFlags_0 >> 16 != 11)
    return null;
  return castTo(this$static.eContainer, 35);
}

function $getPorts_3(this$static){
  !this$static.ports && (this$static.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, this$static, 9, 9));
  return this$static.ports;
}

function $setParent_1(this$static, newParent){
  var eContainerFeatureID, msgs;
  if (newParent != this$static.eContainer || this$static.eFlags_0 >> 16 != 11 && !!newParent) {
    if (isAncestor(this$static, newParent))
      throw toJs(new IllegalArgumentException_0('Recursive containment not allowed for ' + $toString_19(this$static)));
    msgs = null;
    !!this$static.eContainer && (msgs = (eContainerFeatureID = this$static.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_3(this$static, null):this$static.eContainer.eInverseRemove(this$static, -1 - eContainerFeatureID, null, null)));
    !!newParent && (msgs = $eInverseAdd(newParent, this$static, 10, msgs));
    msgs = $basicSetParent_1(this$static, newParent, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 11, newParent, newParent));
}

function $toString_19(this$static){
  var builder, id_0, text_0;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_14(this$static);
  builder = new StringBuilder_1('ElkNode');
  id_0 = this$static.identifier;
  if (!id_0) {
    !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7));
    if (this$static.labels.size_0 > 0) {
      text_0 = (!this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7)) , castTo(castTo($get_16(this$static.labels, 0), 135), 241)).text_0;
      !text_0 || $append_11($append_11((builder.string += ' "' , builder), text_0), '"');
    }
  }
   else {
    $append_11($append_11((builder.string += ' "' , builder), id_0), '"');
  }
  $append_11($append_6($append_11($append_6($append_11($append_6($append_11($append_6((builder.string += ' (' , builder), this$static.x_0), ','), this$static.y_0), ' | '), this$static.width_0), ','), this$static.height), ')');
  return builder.string;
}

function ElkNodeImpl(){
  ElkConnectableShapeImpl.call(this);
}

defineClass(240, 672, {98:1, 392:1, 97:1, 202:1, 35:1, 444:1, 240:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1}, ElkNodeImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_4(msgs){
  return $eBasicRemoveFromContainerFeature_3(this, msgs);
}
;
_.eGet = function eGet_14(featureID, resolve, coreType){
  switch (featureID) {
    case 9:
      return !this.ports && (this.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, this, 9, 9)) , this.ports;
    case 10:
      return !this.children && (this.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, this, 10, 11)) , this.children;
    case 11:
      return $getParent_2(this);
    case 12:
      return !this.containedEdges && (this.containedEdges = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this, 12, 3)) , this.containedEdges;
    case 13:
      return $clinit_Boolean() , !this.children && (this.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, this, 10, 11)) , this.children.size_0 > 0?true:false;
  }
  return $eGet_6(this, featureID, resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_9(otherEnd, featureID, msgs){
  var eContainerFeatureID;
  switch (featureID) {
    case 9:
      return !this.ports && (this.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, this, 9, 9)) , $basicAdd_0(this.ports, otherEnd, msgs);
    case 10:
      return !this.children && (this.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, this, 10, 11)) , $basicAdd_0(this.children, otherEnd, msgs);
    case 11:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_3(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $basicSetParent_1(this, castTo(otherEnd, 35), msgs);
    case 12:
      return !this.containedEdges && (this.containedEdges = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this, 12, 3)) , $basicAdd_0(this.containedEdges, otherEnd, msgs);
  }
  return $eInverseAdd_1(this, otherEnd, featureID, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_10(otherEnd, featureID, msgs){
  switch (featureID) {
    case 9:
      return !this.ports && (this.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, this, 9, 9)) , $basicRemove_0(this.ports, otherEnd, msgs);
    case 10:
      return !this.children && (this.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, this, 10, 11)) , $basicRemove_0(this.children, otherEnd, msgs);
    case 11:
      return $basicSetParent_1(this, null, msgs);
    case 12:
      return !this.containedEdges && (this.containedEdges = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this, 12, 3)) , $basicRemove_0(this.containedEdges, otherEnd, msgs);
  }
  return $eInverseRemove_2(this, otherEnd, featureID, msgs);
}
;
_.eIsSet = function eIsSet_13(featureID){
  switch (featureID) {
    case 9:
      return !!this.ports && this.ports.size_0 != 0;
    case 10:
      return !!this.children && this.children.size_0 != 0;
    case 11:
      return !!$getParent_2(this);
    case 12:
      return !!this.containedEdges && this.containedEdges.size_0 != 0;
    case 13:
      return !this.children && (this.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, this, 10, 11)) , this.children.size_0 > 0;
  }
  return $eIsSet_3(this, featureID);
}
;
_.eSet = function eSet_12(featureID, newValue){
  switch (featureID) {
    case 9:
      !this.ports && (this.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, this, 9, 9));
      $clear_11(this.ports);
      !this.ports && (this.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, this, 9, 9));
      $addAll_6(this.ports, castTo(newValue, 13));
      return;
    case 10:
      !this.children && (this.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, this, 10, 11));
      $clear_11(this.children);
      !this.children && (this.children = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkNode_2_classLit, this, 10, 11));
      $addAll_6(this.children, castTo(newValue, 13));
      return;
    case 11:
      $setParent_1(this, castTo(newValue, 35));
      return;
    case 12:
      !this.containedEdges && (this.containedEdges = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this, 12, 3));
      $clear_11(this.containedEdges);
      !this.containedEdges && (this.containedEdges = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, this, 12, 3));
      $addAll_6(this.containedEdges, castTo(newValue, 13));
      return;
  }
  $eSet_4(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_12(){
  return $clinit_ElkGraphPackage$Literals() , ELK_NODE;
}
;
_.toString_0 = function toString_130(){
  return $toString_19(this);
}
;
var Lorg_eclipse_elk_graph_impl_ElkNodeImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkNodeImpl', 240);
function $basicSetParent_2(this$static, newParent, msgs){
  msgs = $eBasicSetContainer(this$static, newParent, 9, msgs);
  return msgs;
}

function $eBasicRemoveFromContainerFeature_4(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 9) {
    return this$static.eContainer.eInverseRemove(this$static, 9, Lorg_eclipse_elk_graph_ElkNode_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_ElkGraphPackage$Literals() , ELK_PORT):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getParent_3(this$static){
  if (this$static.eFlags_0 >> 16 != 9)
    return null;
  return castTo(this$static.eContainer, 35);
}

function $setParent_2(this$static, newParent){
  var eContainerFeatureID, msgs;
  if (newParent != this$static.eContainer || this$static.eFlags_0 >> 16 != 9 && !!newParent) {
    if (isAncestor(this$static, newParent))
      throw toJs(new IllegalArgumentException_0('Recursive containment not allowed for ' + $toString_20(this$static)));
    msgs = null;
    !!this$static.eContainer && (msgs = (eContainerFeatureID = this$static.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_4(this$static, null):this$static.eContainer.eInverseRemove(this$static, -1 - eContainerFeatureID, null, null)));
    !!newParent && (msgs = $eInverseAdd(newParent, this$static, 9, msgs));
    msgs = $basicSetParent_2(this$static, newParent, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 9, newParent, newParent));
}

function $toString_20(this$static){
  var builder, id_0, text_0;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_14(this$static);
  builder = new StringBuilder_1('ElkPort');
  id_0 = this$static.identifier;
  if (!id_0) {
    !this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7));
    if (this$static.labels.size_0 > 0) {
      text_0 = (!this$static.labels && (this$static.labels = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkLabel_2_classLit, this$static, 1, 7)) , castTo(castTo($get_16(this$static.labels, 0), 135), 241)).text_0;
      !text_0 || $append_11($append_11((builder.string += ' "' , builder), text_0), '"');
    }
  }
   else {
    $append_11($append_11((builder.string += ' "' , builder), id_0), '"');
  }
  $append_11($append_6($append_11($append_6($append_11($append_6($append_11($append_6((builder.string += ' (' , builder), this$static.x_0), ','), this$static.y_0), ' | '), this$static.width_0), ','), this$static.height), ')');
  return builder.string;
}

function ElkPortImpl(){
  ElkConnectableShapeImpl.call(this);
}

defineClass(187, 672, {98:1, 392:1, 97:1, 202:1, 123:1, 444:1, 187:1, 94:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1}, ElkPortImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_5(msgs){
  return $eBasicRemoveFromContainerFeature_4(this, msgs);
}
;
_.eGet = function eGet_15(featureID, resolve, coreType){
  if (featureID == 9) {
    return $getParent_3(this);
  }
  return $eGet_6(this, featureID, resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_10(otherEnd, featureID, msgs){
  var eContainerFeatureID;
  switch (featureID) {
    case 9:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_4(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $basicSetParent_2(this, castTo(otherEnd, 35), msgs);
  }
  return $eInverseAdd_1(this, otherEnd, featureID, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_11(otherEnd, featureID, msgs){
  if (featureID == 9) {
    return $basicSetParent_2(this, null, msgs);
  }
  return $eInverseRemove_2(this, otherEnd, featureID, msgs);
}
;
_.eIsSet = function eIsSet_14(featureID){
  if (featureID == 9) {
    return !!$getParent_3(this);
  }
  return $eIsSet_3(this, featureID);
}
;
_.eSet = function eSet_13(featureID, newValue){
  switch (featureID) {
    case 9:
      $setParent_2(this, castTo(newValue, 35));
      return;
  }
  $eSet_4(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_13(){
  return $clinit_ElkGraphPackage$Literals() , ELK_PORT;
}
;
_.toString_0 = function toString_131(){
  return $toString_20(this);
}
;
var Lorg_eclipse_elk_graph_impl_ElkPortImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkPortImpl', 187);
var Lorg_eclipse_emf_common_util_BasicEMap$Entry_2_classLit = createForInterface('org.eclipse.emf.common.util', 'BasicEMap/Entry');
function $setTypedKey(this$static, newKey){
  var oldKey;
  oldKey = this$static.key;
  this$static.key = newKey;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 0, oldKey, this$static.key));
}

function $setTypedValue(this$static, newValue){
  var oldValue;
  oldValue = this$static.value_0;
  this$static.value_0 = newValue;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 1, oldValue, this$static.value_0));
}

function ElkPropertyToValueMapEntryImpl(){
}

defineClass(1007, 110, {98:1, 39:1, 92:1, 89:1, 140:1, 51:1, 106:1, 46:1, 93:1, 109:1, 110:1}, ElkPropertyToValueMapEntryImpl);
_.equals_0 = function equals_176(other){
  return this === other;
}
;
_.getKey = function getKey_7(){
  return this.key;
}
;
_.hashCode_1 = function hashCode_67(){
  return getHashCode_0(this);
}
;
_.setKey = function setKey(key){
  $setTypedKey(this, castTo(key, 169));
}
;
_.eGet = function eGet_16(featureID, resolve, coreType){
  switch (featureID) {
    case 0:
      return this.key;
    case 1:
      return this.value_0;
  }
  return $eGet(this, featureID, resolve, coreType);
}
;
_.eIsSet = function eIsSet_15(featureID){
  switch (featureID) {
    case 0:
      return !!this.key;
    case 1:
      return this.value_0 != null;
  }
  return $eIsSet(this, featureID);
}
;
_.eSet = function eSet_14(featureID, newValue){
  switch (featureID) {
    case 0:
      $setTypedKey(this, castTo(newValue, 169));
      return;
    case 1:
      $setTypedValue(this, newValue);
      return;
  }
  $eSet(this, featureID, newValue);
}
;
_.eStaticClass = function eStaticClass_14(){
  return $clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY;
}
;
_.getHash = function getHash(){
  var theKey;
  if (this.hash == -1) {
    theKey = this.key;
    this.hash = !theKey?0:hashCode__I__devirtual$(theKey);
  }
  return this.hash;
}
;
_.getValue = function getValue_7(){
  return this.value_0;
}
;
_.setHash = function setHash(hash){
  this.hash = hash;
}
;
_.setValue = function setValue_8(value_0){
  var oldValue;
  oldValue = this.value_0;
  $setTypedValue(this, value_0);
  return oldValue;
}
;
_.toString_0 = function toString_132(){
  var result;
  if ((this.eFlags_0 & 64) != 0)
    return $toString_12(this);
  result = new StringBuilder;
  $append_11($append_11($append_11(result, this.key?this.key.getId():'null'), ' -> '), valueOf_7(this.value_0));
  return result.string;
}
;
_.hash = -1;
_.value_0 = null;
var Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit = createForClass('org.eclipse.elk.graph.impl', 'ElkPropertyToValueMapEntryImpl', 1007);
function $addJsonArr(arr, jv){
  var size_0;
  size_0 = arr.jsArray.length;
  $get_4(arr, size_0);
  $set0(arr, size_0, jv);
}

function $addJsonArr_0(arr, o){
  var _doubleValue, _matched;
  _matched = false;
  if (instanceOfString(o)) {
    _matched = true;
    $addJsonArr(arr, new JSONString(castToString(o)));
  }
  if (!_matched) {
    if (instanceOf(o, 217)) {
      _matched = true;
      $addJsonArr(arr, (_doubleValue = doubleValue__D__devirtual$(castTo(o, 217)) , new JSONNumber(_doubleValue)));
    }
  }
  if (!_matched) {
    throw toJs(new Error_0('Severe implementation error in the Json to ElkGraph importer.'));
  }
}

function $addJsonObj(o, element, n){
  var _doubleValue, _jSONNumber;
  _doubleValue = doubleValue__D__devirtual$(n);
  _jSONNumber = new JSONNumber(_doubleValue);
  $put_0(o, element, _jSONNumber);
}

function $addJsonObj_0(this$static, o, element, obj){
  var _matched;
  _matched = false;
  if (instanceOfString(obj)) {
    _matched = true;
    $addJsonObj_1(o, element, castToString(obj));
  }
  if (!_matched) {
    if (instanceOfBoolean(obj)) {
      _matched = true;
      $addJsonObj_0(this$static, o, element, obj);
    }
  }
  if (!_matched) {
    if (instanceOf(obj, 217)) {
      _matched = true;
      $addJsonObj(o, element, castTo(obj, 217));
    }
  }
  if (!_matched) {
    throw toJs(new Error_0('Severe implementation error in the Json to ElkGraph importer.'));
  }
}

function $addJsonObj_1(o, element, s){
  var _jSONString;
  _jSONString = new JSONString(s);
  $put_0(o, element, _jSONString);
}

function $asId(id_0){
  var _isInt;
  if (instanceOf(id_0, 205)) {
    return castTo(id_0, 205).value_0;
  }
  if (instanceOf(id_0, 270)) {
    _isInt = castTo(id_0, 270).value_0 % 1 == 0;
    if (_isInt) {
      return valueOf_4(round_int(checkNotNull_1(castTo(id_0, 270).value_0)));
    }
  }
  throw toJs(new JsonImportException("Id must be a string or an integer: '" + id_0 + "'."));
}

function $getId(o){
  var _containsKey, _not, _xblockexpression;
  _containsKey = 'id' in o.jsObject;
  _not = !_containsKey;
  if (_not) {
    throw toJs(new JsonImportException('Every element must have an id.'));
  }
  _xblockexpression = $asId($get_5(o, 'id'));
  return _xblockexpression;
}

function $optDouble(o, element){
  var _containsKey, _doubleValue, _isNumber, _xifexpression;
  _containsKey = element in o.jsObject;
  if (_containsKey) {
    _isNumber = $get_5(o, element).isNumber();
    _doubleValue = 0;
    !!_isNumber && (_doubleValue = _isNumber.value_0);
    _xifexpression = _doubleValue;
  }
   else {
    _xifexpression = null;
  }
  return _xifexpression;
}

function $optJSONArray(arr, element){
  var _get, _isArray;
  _get = $get_5(arr, element);
  _isArray = null;
  !!_get && (_isArray = _get.isArray_0());
  return _isArray;
}

function $optJSONObject(arr, i){
  var _get, _isObject;
  _get = $get_4(arr, i);
  _isObject = null;
  !!_get && (_isObject = _get.isObject());
  return _isObject;
}

function $optJSONObject_0(o, element){
  var _get, _isObject;
  _get = $get_5(o, element);
  _isObject = null;
  !!_get && (_isObject = _get.isObject());
  return _isObject;
}

function $optString(o, element){
  var _get, _stringVal;
  _get = $get_5(o, element);
  _stringVal = null;
  !!_get && (_stringVal = $stringVal(_get));
  return _stringVal;
}

function $stringVal(v){
  var _matched, _switchResult;
  _switchResult = null;
  _matched = false;
  if (instanceOf(v, 205)) {
    _matched = true;
    _switchResult = castTo(v, 205).value_0;
  }
  if (!_matched) {
    if (instanceOf(v, 270)) {
      _matched = true;
      _switchResult = '' + castTo(v, 270).value_0;
    }
  }
  if (!_matched) {
    if (instanceOf(v, 459)) {
      _matched = true;
      _switchResult = '' + castTo(v, 459).value_0;
    }
  }
  if (!_matched) {
    throw toJs(new Error_0('Severe implementation error in the Json to ElkGraph importer.'));
  }
  return _switchResult;
}

function JsonAdapter(){
}

defineClass(910, 1, {}, JsonAdapter);
var Lorg_eclipse_elk_graph_json_JsonAdapter_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonAdapter', 910);
function JsonImportException(message){
  RuntimeException_0.call(this, message);
}

defineClass(191, 54, $intern_44, JsonImportException);
var Lorg_eclipse_elk_graph_json_JsonImportException_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImportException', 191);
function $_idByElement(this$static, section){
  return $get(this$static.edgeSectionIdMap.inverse, section);
}

function $_idByElement_0(this$static, node){
  return $get(this$static.nodeIdMap.inverse, node);
}

function $_idByElement_1(this$static, port){
  return $get(this$static.portIdMap.inverse, port);
}

function $_transferLayoutInt(this$static, edge){
  var _function, _function_1, _hasProperty, _isNullOrEmpty, _isNullOrEmpty_1, _not, _not_1, edgeId, jps, jsonJPs, jsonObj, sections;
  jsonObj = castTo($get_6(this$static.edgeJsonMap, edge), 195);
  if (!jsonObj) {
    throw toJs(new JsonImportException('Edge did not exist in input.'));
  }
  edgeId = $getId(jsonObj);
  _isNullOrEmpty = isNullOrEmpty((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections));
  _not = !_isNullOrEmpty;
  if (_not) {
    sections = new JSONArray;
    _function = new JsonImporter$lambda$20$Type(this$static, edgeId, sections);
    forEach_36((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), _function);
    $put_0(jsonObj, 'sections', sections);
  }
  _hasProperty = $hasProperty_0(edge, ($clinit_CoreOptions() , JUNCTION_POINTS_0));
  if (_hasProperty) {
    jps = castTo($getProperty_0(edge, JUNCTION_POINTS_0), 74);
    _isNullOrEmpty_1 = !jps || isEmpty_31(jps);
    _not_1 = !_isNullOrEmpty_1;
    if (_not_1) {
      jsonJPs = new JSONArray;
      _function_1 = new JsonImporter$lambda$21$Type(jsonJPs);
      $forEach(jps, _function_1);
      $put_0(jsonObj, 'junctionPoints', jsonJPs);
    }
  }
  return null;
}

function $_transferLayoutInt_0(this$static, label_0){
  var jsonObj;
  jsonObj = $get_6(this$static.labelJsonMap, label_0);
  $transferShapeLayout(label_0, jsonObj);
  return null;
}

function $_transferLayoutInt_1(this$static, node){
  var jsonObj;
  jsonObj = $get(this$static.nodeJsonMap, node);
  if (jsonObj == null) {
    throw toJs(new JsonImportException('Node did not exist in input.'));
  }
  $transferShapeLayout(node, jsonObj);
  return null;
}

function $_transferLayoutInt_2(this$static, port){
  var jsonObj;
  jsonObj = $get_6(this$static.portJsonMap, port);
  if (jsonObj == null) {
    throw toJs(new JsonImportException('Port did not exist in input.'));
  }
  $transferShapeLayout(port, jsonObj);
  return null;
}

function $idByElement(this$static, node){
  if (instanceOf(node, 240)) {
    return $_idByElement_0(this$static, castTo(node, 35));
  }
   else if (instanceOf(node, 187)) {
    return $_idByElement_1(this$static, castTo(node, 123));
  }
   else if (instanceOf(node, 418)) {
    return $_idByElement(this$static, castTo(node, 228));
  }
   else {
    throw toJs(new IllegalArgumentException_0('Unhandled parameter types: ' + $toString_1(new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [node])))));
  }
}

function $lambda$0_12(this$static, parent_1, children_1){
  var _doubleDotLessThan, _optJSONObject, _sizeJsonArr, i, i$iterator;
  if (children_1) {
    _sizeJsonArr = children_1.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      _optJSONObject = $optJSONObject(children_1, i.value_0);
      !!_optJSONObject && $transformNode_0(this$static, _optJSONObject, parent_1);
    }
  }
}

function $lambda$1_5(this$static, node_1, edges_1){
  var _doubleDotLessThan, _sizeJsonArr, edge, i, i$iterator;
  if (edges_1) {
    _sizeJsonArr = edges_1.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      edge = $optJSONObject(edges_1, i.value_0);
      'sources' in edge.jsObject || 'targets' in edge.jsObject?$transformEdge_1(this$static, edge, node_1):$transformPrimitiveEdge(this$static, edge, node_1);
    }
  }
}

function $lambda$10_0(section_1, endPoint_1){
  var _function_2, _function_3, _optDouble, _optDouble_1;
  if (endPoint_1) {
    _optDouble = $optDouble(endPoint_1, 'x');
    _function_2 = new JsonImporter$lambda$30$Type(section_1);
    $setEndX(_function_2.section_0, (checkCriticalNotNull(_optDouble) , _optDouble));
    _optDouble_1 = $optDouble(endPoint_1, 'y');
    _function_3 = new JsonImporter$lambda$31$Type(section_1);
    $setEndY(_function_3.section_0, (checkCriticalNotNull(_optDouble_1) , _optDouble_1));
  }
   else {
    throw toJs(new JsonImportException('All edge sections need an end point.'));
  }
}

function $lambda$11(section_1, bendPoints_1){
  var _doubleDotLessThan, _function_3, _optJSONObject_2, _sizeJsonArr, i, i$iterator;
  if (bendPoints_1) {
    _sizeJsonArr = bendPoints_1.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      _optJSONObject_2 = $optJSONObject(bendPoints_1, i.value_0);
      _function_3 = new JsonImporter$lambda$32$Type(section_1);
      $lambda$32(_function_3.section_1, _optJSONObject_2);
    }
  }
}

function $lambda$12_1(opts_1, layoutData_2, k_2){
  var _jsonObj, _stringVal;
  _jsonObj = $get_5(opts_1, k_2);
  _stringVal = null;
  !!_jsonObj && (_stringVal = $stringVal(_jsonObj));
  $setOption(layoutData_2, k_2, _stringVal);
}

function $lambda$13(this$static, element_1, labels_1){
  var _doubleDotLessThan, _equals, _hasJsonObj, _property, _sizeJsonArr, i, i$iterator, jsonLabel, label_0;
  if (labels_1) {
    _sizeJsonArr = labels_1.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      jsonLabel = $optJSONObject(labels_1, i.value_0);
      if (jsonLabel) {
        label_0 = createLabel($optString(jsonLabel, 'text'), element_1);
        $put_1(this$static.labelJsonMap, label_0, jsonLabel);
        _hasJsonObj = 'id' in jsonLabel.jsObject;
        _hasJsonObj && $setIdentifier(label_0, $optString(jsonLabel, 'id'));
        $transformProperties(jsonLabel, label_0);
        $transformShapeLayout(jsonLabel, label_0);
        _property = castTo($getProperty_0(label_0, ($clinit_CoreOptions() , EDGE_LABELS_PLACEMENT_0)), 236);
        _equals = equal(_property, ($clinit_EdgeLabelPlacement() , UNDEFINED_4));
        _equals && $setProperty_1(label_0, EDGE_LABELS_PLACEMENT_0, CENTER_4);
      }
    }
  }
}

function $lambda$14_0(this$static, parent_1, ports_1){
  var _doubleDotLessThan, _optJSONObject, _sizeJsonArr, i, i$iterator, port, port_0, elkPort;
  if (ports_1) {
    _sizeJsonArr = ports_1.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      _optJSONObject = $optJSONObject(ports_1, i.value_0);
      !!_optJSONObject && (port = $register_5(this$static, (port_0 = ($clinit_ElkGraphFactory() , elkPort = new ElkPortImpl , elkPort) , !!parent_1 && $setParent_2(port_0, parent_1) , port_0), _optJSONObject) , $setIdentifier(port, $optString(_optJSONObject, 'id')) , $transformProperties(_optJSONObject, port) , $transformShapeLayout(_optJSONObject, port) , $transformLabels(this$static, _optJSONObject, port));
    }
  }
}

function $lambda$15_0(shape_1, it_1){
  $setX_1(shape_1, it_1 == null || isInfinite((checkCriticalNotNull(it_1) , it_1)) || isNaN_0((checkCriticalNotNull(it_1) , it_1))?0:(checkCriticalNotNull(it_1) , it_1));
}

function $lambda$16(shape_1, it_1){
  $setY_1(shape_1, it_1 == null || isInfinite((checkCriticalNotNull(it_1) , it_1)) || isNaN_0((checkCriticalNotNull(it_1) , it_1))?0:(checkCriticalNotNull(it_1) , it_1));
}

function $lambda$17_0(shape_1, it_1){
  $setWidth_0(shape_1, it_1 == null || isInfinite((checkCriticalNotNull(it_1) , it_1)) || isNaN_0((checkCriticalNotNull(it_1) , it_1))?0:(checkCriticalNotNull(it_1) , it_1));
}

function $lambda$18(shape_1, it_1){
  $setHeight_0(shape_1, it_1 == null || isInfinite((checkCriticalNotNull(it_1) , it_1)) || isNaN_0((checkCriticalNotNull(it_1) , it_1))?0:(checkCriticalNotNull(it_1) , it_1));
}

function $lambda$2_4(this$static, children_0){
  var _doubleDotLessThan, _optJSONObject, _sizeJsonArr, i, i$iterator;
  if (children_0) {
    _sizeJsonArr = children_0.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      _optJSONObject = $optJSONObject(children_0, i.value_0);
      !!_optJSONObject && $transformEdges_2(this$static, _optJSONObject);
    }
  }
}

function $lambda$20_1(this$static, edgeId_1, sections_2, elkSection_2, i_3){
  var _function_1, _function_2, _function_3, _incomingShape, _isEmpty, _isEmpty_1, _isNullOrEmpty_1, _jSONString, _jsonObject, _not_1, _not_2, _not_3, _outgoingShape, _plus, _plus_1, _tripleNotEquals, _tripleNotEquals_1, bendPoints, endPoint, incomingSections, jsonSection, maybeSection, outgoingSections, startPoint;
  maybeSection = $get_6(this$static.edgeSectionJsonMap, elkSection_2);
  if (maybeSection == null) {
    maybeSection = new JSONObject;
    _jsonObject = castTo(maybeSection, 195);
    _plus = edgeId_1 + '_s';
    _plus_1 = _plus + i_3;
    _jSONString = new JSONString(_plus_1);
    $put_0(_jsonObject, 'id', _jSONString);
  }
  jsonSection = castTo(maybeSection, 195);
  $addJsonArr(sections_2, jsonSection);
  startPoint = new JSONObject;
  $addJsonObj(startPoint, 'x', elkSection_2.startX);
  $addJsonObj(startPoint, 'y', elkSection_2.startY);
  $put_0(jsonSection, 'startPoint', startPoint);
  endPoint = new JSONObject;
  $addJsonObj(endPoint, 'x', elkSection_2.endX);
  $addJsonObj(endPoint, 'y', elkSection_2.endY);
  $put_0(jsonSection, 'endPoint', endPoint);
  _isNullOrEmpty_1 = isNullOrEmpty((!elkSection_2.bendPoints && (elkSection_2.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, elkSection_2, 5)) , elkSection_2.bendPoints));
  _not_1 = !_isNullOrEmpty_1;
  if (_not_1) {
    bendPoints = new JSONArray;
    _function_1 = new JsonImporter$lambda$33$Type(bendPoints);
    $forEach((!elkSection_2.bendPoints && (elkSection_2.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, elkSection_2, 5)) , elkSection_2.bendPoints), _function_1);
    $put_0(jsonSection, 'bendPoints', bendPoints);
  }
  _incomingShape = $getIncomingShape(elkSection_2);
  _tripleNotEquals = !!_incomingShape;
  _tripleNotEquals && $addJsonObj_0(this$static._jsonAdapter, jsonSection, 'incomingShape', $idByElement(this$static, $getIncomingShape(elkSection_2)));
  _outgoingShape = $getOutgoingShape(elkSection_2);
  _tripleNotEquals_1 = !!_outgoingShape;
  _tripleNotEquals_1 && $addJsonObj_0(this$static._jsonAdapter, jsonSection, 'outgoingShape', $idByElement(this$static, $getOutgoingShape(elkSection_2)));
  _isEmpty = (!elkSection_2.incomingSections && (elkSection_2.incomingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, elkSection_2, 10, 9)) , elkSection_2.incomingSections).size_0 == 0;
  _not_2 = !_isEmpty;
  if (_not_2) {
    incomingSections = new JSONArray;
    _function_2 = new JsonImporter$lambda$34$Type(this$static, incomingSections);
    $forEach((!elkSection_2.incomingSections && (elkSection_2.incomingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, elkSection_2, 10, 9)) , elkSection_2.incomingSections), _function_2);
    $put_0(jsonSection, 'incomingSections', incomingSections);
  }
  _isEmpty_1 = (!elkSection_2.outgoingSections && (elkSection_2.outgoingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, elkSection_2, 9, 10)) , elkSection_2.outgoingSections).size_0 == 0;
  _not_3 = !_isEmpty_1;
  if (_not_3) {
    outgoingSections = new JSONArray;
    _function_3 = new JsonImporter$lambda$35$Type(this$static, outgoingSections);
    $forEach((!elkSection_2.outgoingSections && (elkSection_2.outgoingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, elkSection_2, 9, 10)) , elkSection_2.outgoingSections), _function_3);
    $put_0(jsonSection, 'outgoingSections', outgoingSections);
  }
}

function $lambda$21(jsonJPs_1, jp_1){
  var jsonPnt;
  jsonPnt = new JSONObject;
  $addJsonObj(jsonPnt, 'x', jp_1.x_0);
  $addJsonObj(jsonPnt, 'y', jp_1.y_0);
  $addJsonArr(jsonJPs_1, jsonPnt);
}

function $lambda$26(section_1, bendPoint_1){
  createBendPoint(section_1, checkNotNull_1($optDouble(bendPoint_1, 'x')), checkNotNull_1($optDouble(bendPoint_1, 'y')));
}

function $lambda$27_0(this$static, edge_1, incomingSectionIdentifiers_2, outgoingSectionIdentifiers_3, jsonSection_3){
  var _function_2, _function_3, _function_4, _function_5, _optJSONArray_1, _optJSONArray_2, _optString, _optString_1, elkSection, _optJSONObject, _function, _optJSONObject_1, _function_1, _optJSONArray, _function_2_0;
  elkSection = $register_3(this$static, createEdgeSection(edge_1), jsonSection_3);
  $setIdentifier_0(elkSection, $optString(jsonSection_3, 'id'));
  _optJSONObject = $optJSONObject_0(jsonSection_3, 'startPoint');
  _function = new JsonImporter$lambda$9$Type(elkSection);
  $lambda$9(_function.section_1, _optJSONObject);
  _optJSONObject_1 = $optJSONObject_0(jsonSection_3, 'endPoint');
  _function_1 = new JsonImporter$lambda$10$Type(elkSection);
  $lambda$10_0(_function_1.section_1, _optJSONObject_1);
  _optJSONArray = $optJSONArray(jsonSection_3, 'bendPoints');
  _function_2_0 = new JsonImporter$lambda$11$Type(elkSection);
  $lambda$11(_function_2_0.section_1, _optJSONArray);
  _optString = $optString(jsonSection_3, 'incomingShape');
  _function_2 = new JsonImporter$lambda$36$Type(this$static, elkSection);
  $lambda$36(_function_2.$$outer_0, _function_2.elkSection_1, _optString);
  _optString_1 = $optString(jsonSection_3, 'outgoingShape');
  _function_3 = new JsonImporter$lambda$37$Type(this$static, elkSection);
  $lambda$37(_function_3.$$outer_0, _function_3.elkSection_1, _optString_1);
  _optJSONArray_1 = $optJSONArray(jsonSection_3, 'incomingSections');
  _function_4 = new JsonImporter$lambda$38$Type(incomingSectionIdentifiers_2, elkSection);
  $lambda$38(_function_4.incomingSectionIdentifiers_1, _function_4.elkSection_2, _optJSONArray_1);
  _optJSONArray_2 = $optJSONArray(jsonSection_3, 'outgoingSections');
  _function_5 = new JsonImporter$lambda$39$Type(outgoingSectionIdentifiers_3, elkSection);
  $lambda$39(_function_5.outgoingSectionIdentifiers_1, _function_5.elkSection_2, _optJSONArray_2);
}

function $lambda$3_2(section_1, srcPnt_1){
  var _function_1, _function_2, _optDouble, _optDouble_1;
  if (srcPnt_1) {
    _optDouble = $optDouble(srcPnt_1, 'x');
    _function_1 = new JsonImporter$lambda$22$Type(section_1);
    $setStartX(_function_1.section_0, (checkCriticalNotNull(_optDouble) , _optDouble));
    _optDouble_1 = $optDouble(srcPnt_1, 'y');
    _function_2 = new JsonImporter$lambda$23$Type(section_1);
    $setStartY(_function_2.section_0, (checkCriticalNotNull(_optDouble_1) , _optDouble_1));
  }
}

function $lambda$32(section_1, bendPoint_1){
  createBendPoint(section_1, checkNotNull_1($optDouble(bendPoint_1, 'x')), checkNotNull_1($optDouble(bendPoint_1, 'y')));
}

function $lambda$33(bendPoints_1, pnt_1){
  var jsonPnt;
  jsonPnt = new JSONObject;
  $addJsonObj(jsonPnt, 'x', pnt_1.x_0);
  $addJsonObj(jsonPnt, 'y', pnt_1.y_0);
  $addJsonArr(bendPoints_1, jsonPnt);
}

function $lambda$34(this$static, incomingSections_1, sec_1){
  $addJsonArr_0(incomingSections_1, $idByElement(this$static, sec_1));
}

function $lambda$35(this$static, outgoingSections_1, sec_1){
  $addJsonArr_0(outgoingSections_1, $idByElement(this$static, sec_1));
}

function $lambda$36(this$static, elkSection_1, jsonShapeId_1){
  jsonShapeId_1 != null && $setIncomingShape(elkSection_1, $shapeById(this$static, jsonShapeId_1));
}

function $lambda$37(this$static, elkSection_1, jsonShapeId_1){
  jsonShapeId_1 != null && $setOutgoingShape(elkSection_1, $shapeById(this$static, jsonShapeId_1));
}

function $lambda$38(incomingSectionIdentifiers_1, elkSection_2, jsonSectionIds_2){
  var _doubleDotLessThan_1, _sizeJsonArr_1, j, j$iterator;
  if (jsonSectionIds_2) {
    _sizeJsonArr_1 = jsonSectionIds_2.jsArray.length;
    _doubleDotLessThan_1 = new ExclusiveRange(_sizeJsonArr_1);
    for (j$iterator = (_doubleDotLessThan_1.last - _doubleDotLessThan_1.first) * _doubleDotLessThan_1.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan_1); j$iterator.hasNext_0();) {
      j = castTo(j$iterator.next_1(), 21);
      $put(incomingSectionIdentifiers_1, elkSection_2, $asId($get_4(jsonSectionIds_2, j.value_0)));
    }
  }
}

function $lambda$39(outgoingSectionIdentifiers_1, elkSection_2, jsonSectionIds_2){
  var _doubleDotLessThan_1, _sizeJsonArr_1, j, j$iterator;
  if (jsonSectionIds_2) {
    _sizeJsonArr_1 = jsonSectionIds_2.jsArray.length;
    _doubleDotLessThan_1 = new ExclusiveRange(_sizeJsonArr_1);
    for (j$iterator = (_doubleDotLessThan_1.last - _doubleDotLessThan_1.first) * _doubleDotLessThan_1.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan_1); j$iterator.hasNext_0();) {
      j = castTo(j$iterator.next_1(), 21);
      $put(outgoingSectionIdentifiers_1, elkSection_2, $asId($get_4(jsonSectionIds_2, j.value_0)));
    }
  }
}

function $lambda$4_2(section_1, tgtPnt_1){
  var _function_2, _function_3, _optDouble, _optDouble_1;
  if (tgtPnt_1) {
    _optDouble = $optDouble(tgtPnt_1, 'x');
    _function_2 = new JsonImporter$lambda$24$Type(section_1);
    $setEndX(_function_2.section_0, (checkCriticalNotNull(_optDouble) , _optDouble));
    _optDouble_1 = $optDouble(tgtPnt_1, 'y');
    _function_3 = new JsonImporter$lambda$25$Type(section_1);
    $setEndY(_function_3.section_0, (checkCriticalNotNull(_optDouble_1) , _optDouble_1));
  }
}

function $lambda$5(section_1, bendPoints_1){
  var _doubleDotLessThan, _function_3, _optJSONObject_2, _sizeJsonArr, i, i$iterator;
  if (bendPoints_1) {
    _sizeJsonArr = bendPoints_1.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      _optJSONObject_2 = $optJSONObject(bendPoints_1, i.value_0);
      _function_3 = new JsonImporter$lambda$26$Type(section_1);
      $lambda$26(_function_3.section_1, _optJSONObject_2);
    }
  }
}

function $lambda$6(this$static, edge_1, sources_1){
  var _doubleDotLessThan, _sizeJsonArr, _sources, i, i$iterator, sourceElement;
  if (sources_1) {
    _sizeJsonArr = sources_1.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      sourceElement = $shapeById(this$static, $asId($get_4(sources_1, i.value_0)));
      if (sourceElement) {
        _sources = (!edge_1.sources && (edge_1.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge_1, 4, 7)) , edge_1.sources);
        $add_21(_sources, sourceElement);
      }
    }
  }
}

function $lambda$7_0(this$static, edge_1, targets_1){
  var _doubleDotLessThan, _sizeJsonArr, _targets, i, i$iterator, targetElement;
  if (targets_1) {
    _sizeJsonArr = targets_1.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      targetElement = $shapeById(this$static, $asId($get_4(targets_1, i.value_0)));
      if (targetElement) {
        _targets = (!edge_1.targets && (edge_1.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge_1, 5, 8)) , edge_1.targets);
        $add_21(_targets, targetElement);
      }
    }
  }
}

function $lambda$8_0(this$static, edge_1, incomingSectionIdentifiers_2, outgoingSectionIdentifiers_3, sections_3){
  var _doubleDotLessThan, _function_1, _optJSONObject, _sizeJsonArr, i, i$iterator;
  if (sections_3) {
    _sizeJsonArr = sections_3.jsArray.length;
    _doubleDotLessThan = new ExclusiveRange(_sizeJsonArr);
    for (i$iterator = (_doubleDotLessThan.last - _doubleDotLessThan.first) * _doubleDotLessThan.step < 0?($clinit_ExclusiveRange() , EMPTY_LIST_ITERATOR_0):new ExclusiveRange$RangeIterator(_doubleDotLessThan); i$iterator.hasNext_0();) {
      i = castTo(i$iterator.next_1(), 21);
      _optJSONObject = $optJSONObject(sections_3, i.value_0);
      _function_1 = new JsonImporter$lambda$27$Type(this$static, edge_1, incomingSectionIdentifiers_2, outgoingSectionIdentifiers_3);
      $lambda$27_0(_function_1.$$outer_0, _function_1.edge_1, _function_1.incomingSectionIdentifiers_2, _function_1.outgoingSectionIdentifiers_3, _optJSONObject);
    }
  }
}

function $lambda$9(section_1, startPoint_1){
  var _function_1, _function_2, _optDouble, _optDouble_1;
  if (startPoint_1) {
    _optDouble = $optDouble(startPoint_1, 'x');
    _function_1 = new JsonImporter$lambda$28$Type(section_1);
    $setStartX(_function_1.section_0, (checkCriticalNotNull(_optDouble) , _optDouble));
    _optDouble_1 = $optDouble(startPoint_1, 'y');
    _function_2 = new JsonImporter$lambda$29$Type(section_1);
    $setStartY(_function_2.section_0, (checkCriticalNotNull(_optDouble_1) , _optDouble_1));
  }
   else {
    throw toJs(new JsonImportException('All edge sections need a start point.'));
  }
}

function $register_2(this$static, edge, obj){
  var id_0;
  id_0 = $getId(obj);
  $put_1(this$static.edgeIdMap, id_0, edge);
  $put_1(this$static.edgeJsonMap, edge, obj);
  return edge;
}

function $register_3(this$static, edgeSection, obj){
  var id_0;
  id_0 = $getId(obj);
  $putInBothMaps(this$static.edgeSectionIdMap, id_0, edgeSection, false);
  $put_1(this$static.edgeSectionJsonMap, edgeSection, obj);
  return edgeSection;
}

function $register_4(this$static, node, obj){
  var id_0;
  id_0 = $getId(obj);
  $putInBothMaps(this$static.nodeIdMap, id_0, node, false);
  $putInBothMaps(this$static.nodeJsonMap, node, obj, false);
  return node;
}

function $register_5(this$static, port, obj){
  var id_0;
  id_0 = $getId(obj);
  $putInBothMaps(this$static.portIdMap, id_0, port, false);
  $put_1(this$static.portJsonMap, port, obj);
  return port;
}

function $setOption(e, id_0, value_0){
  var _xifexpression, _xifexpression_1, optionData, parsed;
  optionData = $getOptionDataBySuffix(getInstance(), id_0);
  _xifexpression = null;
  if (optionData) {
    parsed = $parseValue(optionData, value_0);
    _xifexpression_1 = null;
    parsed != null && (_xifexpression_1 = (parsed == null?(!e.properties && (e.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, e, 0)) , $removeKey(e.properties, optionData)):(!e.properties && (e.properties = new EcoreEMap(($clinit_ElkGraphPackage$Literals() , ELK_PROPERTY_TO_VALUE_MAP_ENTRY), Lorg_eclipse_elk_graph_impl_ElkPropertyToValueMapEntryImpl_2_classLit, e, 0)) , $put_8(e.properties, optionData, parsed)) , e));
    _xifexpression = _xifexpression_1;
  }
  return _xifexpression;
}

function $shapeById(this$static, id_0){
  var node, port;
  node = castTo($get(this$static.nodeIdMap, id_0), 35);
  if (node) {
    return node;
  }
  port = castTo($get(this$static.portIdMap, id_0), 123);
  if (port) {
    return port;
  }
  throw toJs(new JsonImportException('Referenced shape does not exist: ' + id_0));
}

function $transferLayoutInt(this$static, node){
  if (instanceOf(node, 240)) {
    return $_transferLayoutInt_1(this$static, castTo(node, 35));
  }
   else if (instanceOf(node, 187)) {
    return $_transferLayoutInt_2(this$static, castTo(node, 123));
  }
   else if (instanceOf(node, 241)) {
    return $_transferLayoutInt_0(this$static, castTo(node, 135));
  }
   else if (instanceOf(node, 173)) {
    return $_transferLayoutInt(this$static, castTo(node, 100));
  }
   else if (node) {
    return null;
  }
   else {
    throw toJs(new IllegalArgumentException_0('Unhandled parameter types: ' + $toString_1(new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [null])))));
  }
}

function $transferShapeLayout(shape_0, jsonObjA){
  var jsonObj;
  jsonObj = castTo(jsonObjA, 195);
  $addJsonObj(jsonObj, 'x', shape_0.x_0);
  $addJsonObj(jsonObj, 'y', shape_0.y_0);
  $addJsonObj(jsonObj, 'width', shape_0.width_0);
  $addJsonObj(jsonObj, 'height', shape_0.height);
}

function $transformEdge_1(this$static, jsonObjA, parent_0){
  var _function, _function_1, _idSave, _optJSONArray, _optJSONArray_1, _plus, _plus_1, _xblockexpression, edge;
  edge = $register_2(this$static, createEdge(parent_0), jsonObjA);
  $setIdentifier(edge, $optString(jsonObjA, 'id'));
  _optJSONArray = $optJSONArray(jsonObjA, 'sources');
  _function = new JsonImporter$lambda$6$Type(this$static, edge);
  $lambda$6(_function.$$outer_0, _function.edge_1, _optJSONArray);
  _optJSONArray_1 = $optJSONArray(jsonObjA, 'targets');
  _function_1 = new JsonImporter$lambda$7$Type(this$static, edge);
  $lambda$7_0(_function_1.$$outer_0, _function_1.edge_1, _optJSONArray_1);
  if ((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources).size_0 == 0 || (!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets).size_0 == 0) {
    _idSave = $optString(jsonObjA, 'id');
    _plus = "An edge must have at least one source and one target (edge id: '" + _idSave;
    _plus_1 = _plus + "').";
    throw toJs(new JsonImportException(_plus_1));
  }
  $transformProperties(jsonObjA, edge);
  $transformEdgeSections(this$static, jsonObjA, edge);
  _xblockexpression = $transformLabels(this$static, jsonObjA, edge);
  return _xblockexpression;
}

function $transformEdgeSections(this$static, jsonObjA, edge){
  var _function, _get, _get_1, _idSave, _incomingSections, _keySet, _keySet_1, _optJSONArray, _outgoingSections, _plus, _plus_1, id_0, id$iterator, id_1, id_1$iterator, incomingSectionIdentifiers, outgoingSectionIdentifiers, referencedSection, result, result0, section, section$iterator, section_1, section_1$iterator, section_2;
  incomingSectionIdentifiers = new HashMultimap;
  outgoingSectionIdentifiers = new HashMultimap;
  _optJSONArray = $optJSONArray(jsonObjA, 'sections');
  _function = new JsonImporter$lambda$8$Type(this$static, edge, incomingSectionIdentifiers, outgoingSectionIdentifiers);
  $lambda$8_0(_function.$$outer_0, _function.edge_1, _function.incomingSectionIdentifiers_2, _function.outgoingSectionIdentifiers_3, _optJSONArray);
  _keySet = (result0 = incomingSectionIdentifiers.keySet , !result0?(incomingSectionIdentifiers.keySet = instanceOf(incomingSectionIdentifiers.map_0, 124)?new AbstractMapBasedMultimap$NavigableKeySet(incomingSectionIdentifiers, castTo(incomingSectionIdentifiers.map_0, 124)):instanceOf(incomingSectionIdentifiers.map_0, 118)?new AbstractMapBasedMultimap$SortedKeySet(incomingSectionIdentifiers, castTo(incomingSectionIdentifiers.map_0, 118)):new AbstractMapBasedMultimap$KeySet(incomingSectionIdentifiers, incomingSectionIdentifiers.map_0)):result0);
  for (section$iterator = _keySet.iterator_0(); section$iterator.hasNext_0();) {
    section = castTo(section$iterator.next_1(), 228);
    _get = castTo($get_0(incomingSectionIdentifiers, section), 19);
    for (id$iterator = _get.iterator_0(); id$iterator.hasNext_0();) {
      id_0 = id$iterator.next_1();
      referencedSection = castTo($get(this$static.edgeSectionIdMap, id_0), 228);
      if (referencedSection) {
        _incomingSections = (!section.incomingSections && (section.incomingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, section, 10, 9)) , section.incomingSections);
        $add_21(_incomingSections, referencedSection);
      }
       else {
        _idSave = $optString(jsonObjA, 'id');
        _plus = 'Referenced edge section does not exist: ' + id_0 + " (edge id: '" + _idSave;
        _plus_1 = _plus + "').";
        throw toJs(new JsonImportException(_plus_1));
      }
    }
  }
  _keySet_1 = (result = outgoingSectionIdentifiers.keySet , !result?(outgoingSectionIdentifiers.keySet = instanceOf(outgoingSectionIdentifiers.map_0, 124)?new AbstractMapBasedMultimap$NavigableKeySet(outgoingSectionIdentifiers, castTo(outgoingSectionIdentifiers.map_0, 124)):instanceOf(outgoingSectionIdentifiers.map_0, 118)?new AbstractMapBasedMultimap$SortedKeySet(outgoingSectionIdentifiers, castTo(outgoingSectionIdentifiers.map_0, 118)):new AbstractMapBasedMultimap$KeySet(outgoingSectionIdentifiers, outgoingSectionIdentifiers.map_0)):result);
  for (section_1$iterator = _keySet_1.iterator_0(); section_1$iterator.hasNext_0();) {
    section_1 = castTo(section_1$iterator.next_1(), 228);
    _get_1 = castTo($get_0(outgoingSectionIdentifiers, section_1), 19);
    for (id_1$iterator = _get_1.iterator_0(); id_1$iterator.hasNext_0();) {
      id_1 = id_1$iterator.next_1();
      referencedSection = castTo($get(this$static.edgeSectionIdMap, id_1), 228);
      if (referencedSection) {
        _outgoingSections = (!section_1.outgoingSections && (section_1.outgoingSections = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, section_1, 9, 10)) , section_1.outgoingSections);
        $add_21(_outgoingSections, referencedSection);
      }
       else {
        _idSave = $optString(jsonObjA, 'id');
        _plus = 'Referenced edge section does not exist: ' + id_1 + " (edge id: '" + _idSave;
        _plus_1 = _plus + "').";
        throw toJs(new JsonImportException(_plus_1));
      }
    }
  }
  !edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7));
  if (edge.sources.size_0 != 0 && (!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets.size_0 != 0) && (!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources.size_0 <= 1 && (!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets.size_0 <= 1)) && (!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0 == 1) {
    section_2 = castTo($get_16((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), 0), 228);
    if (!$getIncomingShape(section_2) && !$getOutgoingShape(section_2)) {
      $setIncomingShape(section_2, castTo($get_16((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources), 0), 97));
      $setOutgoingShape(section_2, castTo($get_16((!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets), 0), 97));
    }
  }
}

function $transformEdges_2(this$static, jsonObjA){
  var _function, _function_1, _idSave, _optJSONArray, _optJSONArray_1, _plus, _plus_1, node;
  node = castTo($get(this$static.nodeJsonMap.inverse, jsonObjA), 35);
  if (!node) {
    _idSave = $optString(jsonObjA, 'id');
    _plus = "Unable to find elk node for json object '" + _idSave;
    _plus_1 = _plus + "' Panic!";
    throw toJs(new JsonImportException(_plus_1));
  }
  _optJSONArray = $optJSONArray(jsonObjA, 'edges');
  _function = new JsonImporter$lambda$1$Type(this$static, node);
  $lambda$1_5(_function.$$outer_0, _function.node_1, _optJSONArray);
  _optJSONArray_1 = $optJSONArray(jsonObjA, 'children');
  _function_1 = new JsonImporter$lambda$2$Type(this$static);
  $lambda$2_4(_function_1.$$outer_0, _optJSONArray_1);
}

function $transformLabels(this$static, jsonObjA, element){
  var _function, _optJSONArray, _xblockexpression;
  _optJSONArray = $optJSONArray(jsonObjA, 'labels');
  _function = new JsonImporter$lambda$13$Type(this$static, element);
  _xblockexpression = ($lambda$13(_function.$$outer_0, _function.element_1, _optJSONArray) , _optJSONArray);
  return _xblockexpression;
}

function $transformNode_0(this$static, jsonNode, parent_0){
  var node, node_0, elkNode, _optJSONArray, _function, _optJSONArray_0, _function_0;
  node = $register_4(this$static, (node_0 = ($clinit_ElkGraphFactory() , elkNode = new ElkNodeImpl , elkNode) , !!parent_0 && $setParent_1(node_0, parent_0) , node_0), jsonNode);
  $setIdentifier(node, $optString(jsonNode, 'id'));
  $transformProperties(jsonNode, node);
  $transformShapeLayout(jsonNode, node);
  _optJSONArray = $optJSONArray(jsonNode, 'ports');
  _function = new JsonImporter$lambda$14$Type(this$static, node);
  $lambda$14_0(_function.$$outer_0, _function.parent_1, _optJSONArray);
  $transformLabels(this$static, jsonNode, node);
  _optJSONArray_0 = $optJSONArray(jsonNode, 'children');
  _function_0 = new JsonImporter$lambda$0$Type(this$static, node);
  $lambda$0_12(_function_0.$$outer_0, _function_0.parent_1, _optJSONArray_0);
  return node;
}

function $transformPrimitiveEdge(this$static, jsonObjA, parent_0){
  var _asId, _asId_1, _elvis, _elvis_1, _id, _idSave, _idSave_1, _idSave_2, _id_1, _jsonObj, _jsonObj_1, _plus, _plus_1, _plus_2, _plus_3, _plus_4, _plus_5, _plus_6, _plus_7, _plus_8, _plus_9, _sources, _targets, _xblockexpression, edge, srcNode, srcPort, tgtNode, tgtPort;
  edge = $register_2(this$static, createEdge(parent_0), jsonObjA);
  $setIdentifier(edge, $optString(jsonObjA, 'id'));
  srcNode = castTo($get(this$static.nodeIdMap, $asId($get_5(jsonObjA, 'source'))), 35);
  _jsonObj = $get_5(jsonObjA, 'sourcePort');
  _asId = null;
  !!_jsonObj && (_asId = $asId(_jsonObj));
  srcPort = castTo($get(this$static.portIdMap, _asId), 123);
  if (!srcNode) {
    _id = $getId(jsonObjA);
    _plus = "An edge must have a source node (edge id: '" + _id;
    _plus_1 = _plus + "').";
    throw toJs(new JsonImportException(_plus_1));
  }
  if (!!srcPort && !equal($getParent_3(srcPort), srcNode)) {
    _idSave = $optString(jsonObjA, 'id');
    _plus_2 = "The source port of an edge must be a port of the edge's source node (edge id: '" + _idSave;
    _plus_3 = _plus_2 + "').";
    throw toJs(new JsonImportException(_plus_3));
  }
  _sources = (!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources);
  srcPort?(_elvis = srcPort):(_elvis = srcNode);
  $add_21(_sources, _elvis);
  tgtNode = castTo($get(this$static.nodeIdMap, $asId($get_5(jsonObjA, 'target'))), 35);
  _jsonObj_1 = $get_5(jsonObjA, 'targetPort');
  _asId_1 = null;
  !!_jsonObj_1 && (_asId_1 = $asId(_jsonObj_1));
  tgtPort = castTo($get(this$static.portIdMap, _asId_1), 123);
  if (!tgtNode) {
    _id_1 = $getId(jsonObjA);
    _plus_4 = "An edge must have a target node (edge id: '" + _id_1;
    _plus_5 = _plus_4 + "').";
    throw toJs(new JsonImportException(_plus_5));
  }
  if (!!tgtPort && !equal($getParent_3(tgtPort), tgtNode)) {
    _idSave_1 = $optString(jsonObjA, 'id');
    _plus_6 = "The target port of an edge must be a port of the edge's target node (edge id: '" + _idSave_1;
    _plus_7 = _plus_6 + "').";
    throw toJs(new JsonImportException(_plus_7));
  }
  _targets = (!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets);
  tgtPort?(_elvis_1 = tgtPort):(_elvis_1 = tgtNode);
  $add_21(_targets, _elvis_1);
  if ((!edge.sources && (edge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 4, 7)) , edge.sources).size_0 == 0 || (!edge.targets && (edge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, edge, 5, 8)) , edge.targets).size_0 == 0) {
    _idSave_2 = $optString(jsonObjA, 'id');
    _plus_8 = "An edge must have at least one source and one target (edge id: '" + _idSave_2;
    _plus_9 = _plus_8 + "').";
    throw toJs(new JsonImportException(_plus_9));
  }
  $transformProperties(jsonObjA, edge);
  $transformPrimitiveEdgeLayout(jsonObjA, edge);
  _xblockexpression = $transformLabels(this$static, jsonObjA, edge);
  return _xblockexpression;
}

function $transformPrimitiveEdgeLayout(jsonObjA, edge){
  var _function, _function_1, _function_2, _optJSONArray, _optJSONObject, _optJSONObject_1, _xblockexpression_1, _xifexpression, section;
  _xifexpression = null;
  if ('sourcePoint' in jsonObjA.jsObject || 'targetPoint' in jsonObjA.jsObject || 'bendPoints' in jsonObjA.jsObject) {
    section = createEdgeSection(edge);
    _optJSONObject = $optJSONObject_0(jsonObjA, 'sourcePoint');
    _function = new JsonImporter$lambda$3$Type(section);
    $lambda$3_2(_function.section_1, _optJSONObject);
    _optJSONObject_1 = $optJSONObject_0(jsonObjA, 'targetPoint');
    _function_1 = new JsonImporter$lambda$4$Type(section);
    $lambda$4_2(_function_1.section_1, _optJSONObject_1);
    _optJSONArray = $optJSONArray(jsonObjA, 'bendPoints');
    _function_2 = new JsonImporter$lambda$5$Type(section);
    _xblockexpression_1 = ($lambda$5(_function_2.section_1, _optJSONArray) , _optJSONArray);
    _xifexpression = _xblockexpression_1;
  }
  return _xifexpression;
}

function $transformProperties(jsonObjA, layoutData){
  var _function, _keysJsonObj, keys_0, layoutOptions;
  layoutOptions = $optJSONObject_0(jsonObjA, 'layoutOptions');
  !layoutOptions && (layoutOptions = $optJSONObject_0(jsonObjA, 'properties'));
  if (layoutOptions) {
    _keysJsonObj = null;
    !!layoutOptions && (_keysJsonObj = (keys_0 = $computeKeys0(layoutOptions, initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, 0, 6, 1)) , new JSONObject$1(layoutOptions, keys_0)));
    if (_keysJsonObj) {
      _function = new JsonImporter$lambda$12$Type(layoutOptions, layoutData);
      $forEach(_keysJsonObj, _function);
    }
  }
}

function $transformShapeLayout(jsonObjA, shape_0){
  var _function, _function_1, _function_2, _function_3, _optDouble, _optDouble_1, _optDouble_2, _optDouble_3, _xblockexpression;
  _optDouble = $optDouble(jsonObjA, 'x');
  _function = new JsonImporter$lambda$15$Type(shape_0);
  $lambda$15_0(_function.shape_1, _optDouble);
  _optDouble_1 = $optDouble(jsonObjA, 'y');
  _function_1 = new JsonImporter$lambda$16$Type(shape_0);
  $lambda$16(_function_1.shape_1, _optDouble_1);
  _optDouble_2 = $optDouble(jsonObjA, 'width');
  _function_2 = new JsonImporter$lambda$17$Type(shape_0);
  $lambda$17_0(_function_2.shape_1, _optDouble_2);
  _optDouble_3 = $optDouble(jsonObjA, 'height');
  _function_3 = new JsonImporter$lambda$18$Type(shape_0);
  _xblockexpression = ($lambda$18(_function_3.shape_1, _optDouble_3) , _optDouble_3);
  return _xblockexpression;
}

function JsonImporter(){
  this._jsonAdapter = new JsonAdapter;
  this.nodeIdMap = new HashBiMap;
  this.portIdMap = new HashBiMap;
  this.edgeIdMap = ($clinit_Maps() , new HashMap);
  this.edgeSectionIdMap = new HashBiMap;
  this.nodeJsonMap = new HashBiMap;
  this.portJsonMap = new HashMap;
  this.edgeJsonMap = new HashMap;
  this.edgeSectionJsonMap = new HashMap;
  this.labelJsonMap = new HashMap;
}

defineClass(786, 1, {}, JsonImporter);
var Lorg_eclipse_elk_graph_json_JsonImporter_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter', 786);
function JsonImporter$lambda$0$Type($$outer_0, parent_1){
  this.$$outer_0 = $$outer_0;
  this.parent_1 = parent_1;
}

defineClass(824, 1, {}, JsonImporter$lambda$0$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$0$Type', 824);
function JsonImporter$lambda$1$Type($$outer_0, node_1){
  this.$$outer_0 = $$outer_0;
  this.node_1 = node_1;
}

defineClass(825, 1, {}, JsonImporter$lambda$1$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$1$Type', 825);
function JsonImporter$lambda$10$Type(section_1){
  this.section_1 = section_1;
}

defineClass(848, 1, {}, JsonImporter$lambda$10$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$10$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$10$Type', 848);
function JsonImporter$lambda$11$Type(section_1){
  this.section_1 = section_1;
}

defineClass(850, 1, {}, JsonImporter$lambda$11$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$11$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$11$Type', 850);
function JsonImporter$lambda$12$Type(opts_1, layoutData_2){
  this.opts_1 = opts_1;
  this.layoutData_2 = layoutData_2;
}

defineClass(851, 1, {}, JsonImporter$lambda$12$Type);
_.accept = function accept_110(arg0){
  $lambda$12_1(this.opts_1, this.layoutData_2, arg0);
}
;
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$12$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$12$Type', 851);
function JsonImporter$lambda$13$Type($$outer_0, element_1){
  this.$$outer_0 = $$outer_0;
  this.element_1 = element_1;
}

defineClass(852, 1, {}, JsonImporter$lambda$13$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$13$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$13$Type', 852);
function JsonImporter$lambda$14$Type($$outer_0, parent_1){
  this.$$outer_0 = $$outer_0;
  this.parent_1 = parent_1;
}

defineClass(853, 1, {}, JsonImporter$lambda$14$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$14$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$14$Type', 853);
function JsonImporter$lambda$15$Type(shape_1){
  this.shape_1 = shape_1;
}

defineClass(854, 1, {}, JsonImporter$lambda$15$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$15$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$15$Type', 854);
function JsonImporter$lambda$16$Type(shape_1){
  this.shape_1 = shape_1;
}

defineClass(855, 1, {}, JsonImporter$lambda$16$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$16$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$16$Type', 855);
function JsonImporter$lambda$17$Type(shape_1){
  this.shape_1 = shape_1;
}

defineClass(856, 1, {}, JsonImporter$lambda$17$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$17$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$17$Type', 856);
function JsonImporter$lambda$18$Type(shape_1){
  this.shape_1 = shape_1;
}

defineClass(857, 1, {}, JsonImporter$lambda$18$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$18$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$18$Type', 857);
function $apply_31(this$static, arg0){
  $transferLayoutInt(this$static.$$outer_0, castTo(arg0, 51));
}

function JsonImporter$lambda$19$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(788, 1, {}, JsonImporter$lambda$19$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$19$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$19$Type', 788);
function JsonImporter$lambda$2$Type($$outer_0){
  this.$$outer_0 = $$outer_0;
}

defineClass(826, 1, {}, JsonImporter$lambda$2$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$2$Type', 826);
function $apply_32(this$static, arg0, arg1){
  $lambda$20_1(this$static.$$outer_0, this$static.edgeId_1, this$static.sections_2, arg0, arg1);
}

function JsonImporter$lambda$20$Type($$outer_0, edgeId_1, sections_2){
  this.$$outer_0 = $$outer_0;
  this.edgeId_1 = edgeId_1;
  this.sections_2 = sections_2;
}

defineClass(861, 1, {}, JsonImporter$lambda$20$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$20$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$20$Type', 861);
function JsonImporter$lambda$21$Type(jsonJPs_1){
  this.jsonJPs_1 = jsonJPs_1;
}

defineClass(862, 1, {}, JsonImporter$lambda$21$Type);
_.accept = function accept_111(arg0){
  $lambda$21(this.jsonJPs_1, arg0);
}
;
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$21$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$21$Type', 862);
function JsonImporter$lambda$22$Type(section_0){
  this.section_0 = section_0;
}

defineClass(827, 1, {}, JsonImporter$lambda$22$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$22$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$22$Type', 827);
function JsonImporter$lambda$23$Type(section_0){
  this.section_0 = section_0;
}

defineClass(828, 1, {}, JsonImporter$lambda$23$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$23$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$23$Type', 828);
function JsonImporter$lambda$24$Type(section_0){
  this.section_0 = section_0;
}

defineClass(830, 1, {}, JsonImporter$lambda$24$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$24$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$24$Type', 830);
function JsonImporter$lambda$25$Type(section_0){
  this.section_0 = section_0;
}

defineClass(831, 1, {}, JsonImporter$lambda$25$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$25$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$25$Type', 831);
function JsonImporter$lambda$26$Type(section_1){
  this.section_1 = section_1;
}

defineClass(833, 1, {}, JsonImporter$lambda$26$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$26$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$26$Type', 833);
function JsonImporter$lambda$27$Type($$outer_0, edge_1, incomingSectionIdentifiers_2, outgoingSectionIdentifiers_3){
  this.$$outer_0 = $$outer_0;
  this.edge_1 = edge_1;
  this.incomingSectionIdentifiers_2 = incomingSectionIdentifiers_2;
  this.outgoingSectionIdentifiers_3 = outgoingSectionIdentifiers_3;
}

defineClass(841, 1, {}, JsonImporter$lambda$27$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$27$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$27$Type', 841);
function JsonImporter$lambda$28$Type(section_0){
  this.section_0 = section_0;
}

defineClass(843, 1, {}, JsonImporter$lambda$28$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$28$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$28$Type', 843);
function JsonImporter$lambda$29$Type(section_0){
  this.section_0 = section_0;
}

defineClass(844, 1, {}, JsonImporter$lambda$29$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$29$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$29$Type', 844);
function JsonImporter$lambda$3$Type(section_1){
  this.section_1 = section_1;
}

defineClass(829, 1, {}, JsonImporter$lambda$3$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$3$Type', 829);
function JsonImporter$lambda$30$Type(section_0){
  this.section_0 = section_0;
}

defineClass(846, 1, {}, JsonImporter$lambda$30$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$30$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$30$Type', 846);
function JsonImporter$lambda$31$Type(section_0){
  this.section_0 = section_0;
}

defineClass(847, 1, {}, JsonImporter$lambda$31$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$31$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$31$Type', 847);
function JsonImporter$lambda$32$Type(section_1){
  this.section_1 = section_1;
}

defineClass(849, 1, {}, JsonImporter$lambda$32$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$32$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$32$Type', 849);
function JsonImporter$lambda$33$Type(bendPoints_1){
  this.bendPoints_1 = bendPoints_1;
}

defineClass(858, 1, {}, JsonImporter$lambda$33$Type);
_.accept = function accept_112(arg0){
  $lambda$33(this.bendPoints_1, arg0);
}
;
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$33$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$33$Type', 858);
function JsonImporter$lambda$34$Type($$outer_0, incomingSections_1){
  this.$$outer_0 = $$outer_0;
  this.incomingSections_1 = incomingSections_1;
}

defineClass(859, 1, {}, JsonImporter$lambda$34$Type);
_.accept = function accept_113(arg0){
  $lambda$34(this.$$outer_0, this.incomingSections_1, arg0);
}
;
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$34$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$34$Type', 859);
function JsonImporter$lambda$35$Type($$outer_0, outgoingSections_1){
  this.$$outer_0 = $$outer_0;
  this.outgoingSections_1 = outgoingSections_1;
}

defineClass(860, 1, {}, JsonImporter$lambda$35$Type);
_.accept = function accept_114(arg0){
  $lambda$35(this.$$outer_0, this.outgoingSections_1, arg0);
}
;
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$35$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$35$Type', 860);
function JsonImporter$lambda$36$Type($$outer_0, elkSection_1){
  this.$$outer_0 = $$outer_0;
  this.elkSection_1 = elkSection_1;
}

defineClass(837, 1, {}, JsonImporter$lambda$36$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$36$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$36$Type', 837);
function JsonImporter$lambda$37$Type($$outer_0, elkSection_1){
  this.$$outer_0 = $$outer_0;
  this.elkSection_1 = elkSection_1;
}

defineClass(838, 1, {}, JsonImporter$lambda$37$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$37$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$37$Type', 838);
function JsonImporter$lambda$38$Type(incomingSectionIdentifiers_1, elkSection_2){
  this.incomingSectionIdentifiers_1 = incomingSectionIdentifiers_1;
  this.elkSection_2 = elkSection_2;
}

defineClass(839, 1, {}, JsonImporter$lambda$38$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$38$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$38$Type', 839);
function JsonImporter$lambda$39$Type(outgoingSectionIdentifiers_1, elkSection_2){
  this.outgoingSectionIdentifiers_1 = outgoingSectionIdentifiers_1;
  this.elkSection_2 = elkSection_2;
}

defineClass(840, 1, {}, JsonImporter$lambda$39$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$39$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$39$Type', 840);
function JsonImporter$lambda$4$Type(section_1){
  this.section_1 = section_1;
}

defineClass(832, 1, {}, JsonImporter$lambda$4$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$4$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$4$Type', 832);
function JsonImporter$lambda$5$Type(section_1){
  this.section_1 = section_1;
}

defineClass(834, 1, {}, JsonImporter$lambda$5$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$5$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$5$Type', 834);
function JsonImporter$lambda$6$Type($$outer_0, edge_1){
  this.$$outer_0 = $$outer_0;
  this.edge_1 = edge_1;
}

defineClass(835, 1, {}, JsonImporter$lambda$6$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$6$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$6$Type', 835);
function JsonImporter$lambda$7$Type($$outer_0, edge_1){
  this.$$outer_0 = $$outer_0;
  this.edge_1 = edge_1;
}

defineClass(836, 1, {}, JsonImporter$lambda$7$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$7$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$7$Type', 836);
function JsonImporter$lambda$8$Type($$outer_0, edge_1, incomingSectionIdentifiers_2, outgoingSectionIdentifiers_3){
  this.$$outer_0 = $$outer_0;
  this.edge_1 = edge_1;
  this.incomingSectionIdentifiers_2 = incomingSectionIdentifiers_2;
  this.outgoingSectionIdentifiers_3 = outgoingSectionIdentifiers_3;
}

defineClass(842, 1, {}, JsonImporter$lambda$8$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$8$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$8$Type', 842);
function JsonImporter$lambda$9$Type(section_1){
  this.section_1 = section_1;
}

defineClass(845, 1, {}, JsonImporter$lambda$9$Type);
var Lorg_eclipse_elk_graph_json_JsonImporter$lambda$9$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonImporter/lambda$9$Type', 845);
function _toJson(lad){
  var _categoryId, _function, _function_1, _isNullOrEmpty, _isNullOrEmpty_1, _not, _not_1, _tripleNotEquals, jsonArr, jsonArr_1, jsonObj;
  jsonObj = createCommon(lad);
  _categoryId = lad.category;
  _tripleNotEquals = _categoryId != null;
  _tripleNotEquals && $addJsonObj_1(jsonObj, 'category', lad.category);
  _isNullOrEmpty = isNullOrEmpty(new AbstractMap$1(lad.knownOptions));
  _not = !_isNullOrEmpty;
  if (_not) {
    jsonArr = new JSONArray;
    $put_0(jsonObj, 'knownOptions', jsonArr);
    _function = new JsonMetaDataConverter$lambda$0$Type(jsonArr);
    $forEach(new AbstractMap$1(lad.knownOptions), _function);
  }
  _isNullOrEmpty_1 = isNullOrEmpty(lad.supportedFeatures);
  _not_1 = !_isNullOrEmpty_1;
  if (_not_1) {
    jsonArr_1 = new JSONArray;
    $put_0(jsonObj, 'supportedFeatures', jsonArr_1);
    _function_1 = new JsonMetaDataConverter$lambda$1$Type(jsonArr_1);
    $forEach(lad.supportedFeatures, _function_1);
  }
  return jsonObj;
}

function _toJson_0(lcd){
  var _function, _isNullOrEmpty, _not, jsonArr, jsonObj;
  jsonObj = createCommon(lcd);
  _isNullOrEmpty = isNullOrEmpty(lcd.layouters);
  _not = !_isNullOrEmpty;
  if (_not) {
    jsonArr = new JSONArray;
    $put_0(jsonObj, 'knownLayouters', jsonArr);
    _function = new JsonMetaDataConverter$lambda$2$Type(jsonArr);
    $forEach(lcd.layouters, _function);
  }
  return jsonObj;
}

function _toJson_1(lod){
  var _function, _group, _isNullOrEmpty, _not, _tripleNotEquals, _tripleNotEquals_1, _type, jsonArr, jsonObj;
  jsonObj = createCommon(lod);
  _group = lod.group;
  _tripleNotEquals = _group != null;
  _tripleNotEquals && $addJsonObj_1(jsonObj, 'group', lod.group);
  _type = lod.type_0;
  _tripleNotEquals_1 = !!_type;
  _tripleNotEquals_1 && $addJsonObj_1(jsonObj, 'type', $toString_2(lod.type_0));
  _isNullOrEmpty = isNullOrEmpty(lod.targets);
  _not = !_isNullOrEmpty;
  if (_not) {
    jsonArr = new JSONArray;
    $put_0(jsonObj, 'targets', jsonArr);
    _function = new JsonMetaDataConverter$lambda$3$Type(jsonArr);
    $forEach(lod.targets, _function);
  }
  return jsonObj;
}

function createCommon(data_0){
  var _description, _id, _name, _tripleNotEquals, _tripleNotEquals_1, _tripleNotEquals_2, jsonObj;
  jsonObj = new JSONObject;
  _id = data_0.getId();
  _tripleNotEquals = _id != null;
  _tripleNotEquals && $addJsonObj_1(jsonObj, 'id', data_0.getId());
  _name = data_0.getName();
  _tripleNotEquals_1 = _name != null;
  _tripleNotEquals_1 && $addJsonObj_1(jsonObj, 'name', data_0.getName());
  _description = data_0.getDescription();
  _tripleNotEquals_2 = _description != null;
  _tripleNotEquals_2 && $addJsonObj_1(jsonObj, 'description', data_0.getDescription());
  return jsonObj;
}

function lambda$1_7(jsonArr_1_0, f_1){
  $addJsonArr(jsonArr_1_0, new JSONString(f_1.name_0 != null?f_1.name_0:'' + f_1.ordinal));
}

function lambda$2_6(jsonArr_0, l_1){
  var _id, _tripleNotEquals;
  _id = l_1.id_0;
  _tripleNotEquals = _id != null;
  _tripleNotEquals && $addJsonArr(jsonArr_0, new JSONString(l_1.id_0));
}

function lambda$3_5(jsonArr_0, t_1){
  $addJsonArr(jsonArr_0, new JSONString(t_1.name_0 != null?t_1.name_0:'' + t_1.ordinal));
}

function toJson(lad){
  if (instanceOf(lad, 153)) {
    return _toJson(castTo(lad, 153));
  }
   else if (instanceOf(lad, 207)) {
    return _toJson_0(castTo(lad, 207));
  }
   else if (instanceOf(lad, 24)) {
    return _toJson_1(castTo(lad, 24));
  }
   else {
    throw toJs(new IllegalArgumentException_0('Unhandled parameter types: ' + $toString_1(new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_Object_2_classLit, 1), $intern_1, 1, 5, [lad])))));
  }
}

function JsonMetaDataConverter$lambda$0$Type(jsonArr_0){
  this.jsonArr_0 = jsonArr_0;
}

defineClass(897, 1, {}, JsonMetaDataConverter$lambda$0$Type);
_.accept = function accept_115(arg0){
  $addJsonArr(this.jsonArr_0, new JSONString(castToString(arg0)));
}
;
var Lorg_eclipse_elk_graph_json_JsonMetaDataConverter$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonMetaDataConverter/lambda$0$Type', 897);
function JsonMetaDataConverter$lambda$1$Type(jsonArr_1_0){
  this.jsonArr_1_0 = jsonArr_1_0;
}

defineClass(898, 1, {}, JsonMetaDataConverter$lambda$1$Type);
_.accept = function accept_116(arg0){
  lambda$1_7(this.jsonArr_1_0, arg0);
}
;
var Lorg_eclipse_elk_graph_json_JsonMetaDataConverter$lambda$1$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonMetaDataConverter/lambda$1$Type', 898);
function JsonMetaDataConverter$lambda$2$Type(jsonArr_0){
  this.jsonArr_0 = jsonArr_0;
}

defineClass(899, 1, {}, JsonMetaDataConverter$lambda$2$Type);
_.accept = function accept_117(arg0){
  lambda$2_6(this.jsonArr_0, arg0);
}
;
var Lorg_eclipse_elk_graph_json_JsonMetaDataConverter$lambda$2$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonMetaDataConverter/lambda$2$Type', 899);
function JsonMetaDataConverter$lambda$3$Type(jsonArr_0){
  this.jsonArr_0 = jsonArr_0;
}

defineClass(900, 1, {}, JsonMetaDataConverter$lambda$3$Type);
_.accept = function accept_118(arg0){
  lambda$3_5(this.jsonArr_0, arg0);
}
;
var Lorg_eclipse_elk_graph_json_JsonMetaDataConverter$lambda$3$Type_2_classLit = createForClass('org.eclipse.elk.graph.json', 'JsonMetaDataConverter/lambda$3$Type', 900);
function $clinit_GraphFeature(){
  $clinit_GraphFeature = emptyMethod;
  SELF_LOOPS_0 = new GraphFeature('SELF_LOOPS', 0);
  INSIDE_SELF_LOOPS = new GraphFeature('INSIDE_SELF_LOOPS', 1);
  MULTI_EDGES = new GraphFeature('MULTI_EDGES', 2);
  EDGE_LABELS = new GraphFeature('EDGE_LABELS', 3);
  PORTS_1 = new GraphFeature('PORTS', 4);
  COMPOUND = new GraphFeature('COMPOUND', 5);
  CLUSTERS = new GraphFeature('CLUSTERS', 6);
  DISCONNECTED = new GraphFeature('DISCONNECTED', 7);
}

function GraphFeature(enum$name, enum$ordinal){
  Enum.call(this, enum$name, enum$ordinal);
}

function valueOf_100(name_0){
  $clinit_GraphFeature();
  return valueOf(($clinit_GraphFeature$Map() , $MAP_88), name_0);
}

function values_96(){
  $clinit_GraphFeature();
  return stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_graph_properties_GraphFeature_2_classLit, 1), $intern_38, 238, 0, [SELF_LOOPS_0, INSIDE_SELF_LOOPS, MULTI_EDGES, EDGE_LABELS, PORTS_1, COMPOUND, CLUSTERS, DISCONNECTED]);
}

defineClass(238, 22, {3:1, 34:1, 22:1, 238:1}, GraphFeature);
var CLUSTERS, COMPOUND, DISCONNECTED, EDGE_LABELS, INSIDE_SELF_LOOPS, MULTI_EDGES, PORTS_1, SELF_LOOPS_0;
var Lorg_eclipse_elk_graph_properties_GraphFeature_2_classLit = createForEnum('org.eclipse.elk.graph.properties', 'GraphFeature', 238, Ljava_lang_Enum_2_classLit, values_96, valueOf_100);
function $clinit_GraphFeature$Map(){
  $clinit_GraphFeature$Map = emptyMethod;
  $MAP_88 = createValueOfMap(($clinit_GraphFeature() , stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_graph_properties_GraphFeature_2_classLit, 1), $intern_38, 238, 0, [SELF_LOOPS_0, INSIDE_SELF_LOOPS, MULTI_EDGES, EDGE_LABELS, PORTS_1, COMPOUND, CLUSTERS, DISCONNECTED])));
}

var $MAP_88;
function $compareTo_21(this$static, other){
  return $compareTo_9(this$static.id_0, other.getId());
}

function $equals_8(this$static, obj){
  return instanceOf(obj, 169) && $equals_4(this$static.id_0, castTo(obj, 169).getId());
}

function $getDefault(this$static){
  var clone;
  if (instanceOf(this$static.defaultValue, 4)) {
    clone = clone_10(this$static.defaultValue);
    if (clone == null) {
      throw toJs(new IllegalStateException_0("Couldn't clone property '" + this$static.id_0 + "'. " + "Make sure it's type is registered with the " + ($ensureNamesAreInitialized(Lorg_eclipse_elk_graph_util_ElkReflect_2_classLit) , Lorg_eclipse_elk_graph_util_ElkReflect_2_classLit.simpleName) + ' utility class.'));
    }
    return clone;
  }
   else {
    return this$static.defaultValue;
  }
}

function Property(theid){
  this.id_0 = theid;
}

function Property_0(theid, thedefaultValue){
  Property.call(this, theid);
  this.defaultValue = thedefaultValue;
}

function Property_1(theid, thedefaultValue){
  Property_0.call(this, theid, thedefaultValue);
}

function Property_2(other, thedefaultValue){
  Property_0.call(this, other.id_0, thedefaultValue);
}

defineClass(14, 1, {34:1, 169:1}, Property, Property_0, Property_1, Property_2);
_.compareTo_0 = function compareTo_22(other){
  return $compareTo_21(this, castTo(other, 169));
}
;
_.equals_0 = function equals_177(obj){
  return $equals_8(this, obj);
}
;
_.getDefault = function getDefault_0(){
  return $getDefault(this);
}
;
_.getId = function getId_2(){
  return this.id_0;
}
;
_.hashCode_1 = function hashCode_68(){
  return getHashCode_1(this.id_0);
}
;
_.toString_0 = function toString_133(){
  return this.id_0;
}
;
var Lorg_eclipse_elk_graph_properties_Property_2_classLit = createForClass('org.eclipse.elk.graph.properties', 'Property', 14);
function $compare_24(this$static, ph1, ph2){
  var p1, p2;
  p1 = castTo(ph1.getProperty(this$static.property), 34);
  p2 = castTo(ph2.getProperty(this$static.property), 34);
  return p1 != null && p2 != null?compareTo_Ljava_lang_Object__I__devirtual$(p1, p2):p1 != null?-1:p2 != null?1:0;
}

function PropertyHolderComparator(property){
  this.property = property;
}

defineClass(755, 1, $intern_40, PropertyHolderComparator);
_.compare_0 = function compare_75(ph1, ph2){
  return $compare_24(this, castTo(ph1, 94), castTo(ph2, 94));
}
;
_.equals_0 = function equals_178(other){
  return this === other;
}
;
_.reversed = function reversed_67(){
  return new Comparators$ReversedComparator(this);
}
;
var Lorg_eclipse_elk_graph_properties_PropertyHolderComparator_2_classLit = createForClass('org.eclipse.elk.graph.properties', 'PropertyHolderComparator', 755);
function allIncomingEdges(node){
  var incomingEdgeIterables, port, port$iterator;
  incomingEdgeIterables = newArrayListWithCapacity(1 + (!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports).size_0);
  $add_4(incomingEdgeIterables, (!node.incomingEdges && (node.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, node, 8, 5)) , node.incomingEdges));
  for (port$iterator = new AbstractEList$EIterator((!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports)); port$iterator.cursor != port$iterator.this$01_2.size_1();) {
    port = castTo($doNext(port$iterator), 123);
    $add_4(incomingEdgeIterables, (!port.incomingEdges && (port.incomingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, port, 8, 5)) , port.incomingEdges));
  }
  return checkNotNull(incomingEdgeIterables) , new FluentIterable$2(incomingEdgeIterables);
}

function allOutgoingEdges(node){
  var outgoingEdgeIterables, port, port$iterator;
  outgoingEdgeIterables = newArrayListWithCapacity(1 + (!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports).size_0);
  $add_4(outgoingEdgeIterables, (!node.outgoingEdges && (node.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, node, 7, 4)) , node.outgoingEdges));
  for (port$iterator = new AbstractEList$EIterator((!node.ports && (node.ports = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkPort_2_classLit, node, 9, 9)) , node.ports)); port$iterator.cursor != port$iterator.this$01_2.size_1();) {
    port = castTo($doNext(port$iterator), 123);
    $add_4(outgoingEdgeIterables, (!port.outgoingEdges && (port.outgoingEdges = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkEdge_2_classLit, port, 7, 4)) , port.outgoingEdges));
  }
  return checkNotNull(outgoingEdgeIterables) , new FluentIterable$2(outgoingEdgeIterables);
}

function connectableShapeToNode(connectableShape){
  if (instanceOf(connectableShape, 240)) {
    return castTo(connectableShape, 35);
  }
   else if (instanceOf(connectableShape, 187)) {
    return $getParent_3(castTo(connectableShape, 123));
  }
   else if (!connectableShape) {
    throw toJs(new NullPointerException_0('connectableShape cannot be null'));
  }
   else {
    throw toJs(new UnsupportedOperationException_0('Only support nodes and ports.'));
  }
}

function connectableShapeToPort(connectableShape){
  if (instanceOf(connectableShape, 187)) {
    return castTo(connectableShape, 123);
  }
   else if (!connectableShape) {
    throw toJs(new NullPointerException_0('connectableShape cannot be null'));
  }
   else {
    return null;
  }
}

function createBendPoint(edgeSection, x_0, y_0){
  var bendPoint, elkBendPoint;
  bendPoint = ($clinit_ElkGraphFactory() , elkBendPoint = new ElkBendPointImpl , elkBendPoint);
  $setX_0(bendPoint, x_0);
  $setY_0(bendPoint, y_0);
  !!edgeSection && $add_21((!edgeSection.bendPoints && (edgeSection.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, edgeSection, 5)) , edgeSection.bendPoints), bendPoint);
  return bendPoint;
}

function createEdge(containingNode){
  var edge, elkEdge;
  edge = ($clinit_ElkGraphFactory() , elkEdge = new ElkEdgeImpl , elkEdge);
  !!containingNode && $setContainingNode(edge, containingNode);
  return edge;
}

function createEdgeSection(edge){
  var elkEdgeSection, section;
  section = ($clinit_ElkGraphFactory() , elkEdgeSection = new ElkEdgeSectionImpl , elkEdgeSection);
  !!edge && $add_21((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), section);
  return section;
}

function createLabel(text_0, parent_0){
  var label_0, label_1, elkLabel;
  label_0 = (label_1 = ($clinit_ElkGraphFactory() , elkLabel = new ElkLabelImpl , elkLabel) , !!parent_0 && $setParent_0(label_1, parent_0) , label_1);
  $setText(label_0, text_0);
  return label_0;
}

function firstEdgeSection(edge, resetSection, removeOtherSections){
  var section, sections;
  if ((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections).size_0 == 0) {
    return createEdgeSection(edge);
  }
   else {
    section = castTo($get_16((!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections), 0), 228);
    if (resetSection) {
      $clear_11((!section.bendPoints && (section.bendPoints = new EObjectContainmentEList(Lorg_eclipse_elk_graph_ElkBendPoint_2_classLit, section, 5)) , section.bendPoints));
      $setStartX(section, 0);
      $setStartY(section, 0);
      $setEndX(section, 0);
      $setEndY(section, 0);
    }
    if (removeOtherSections) {
      sections = (!edge.sections && (edge.sections = new EObjectContainmentWithInverseEList(Lorg_eclipse_elk_graph_ElkEdgeSection_2_classLit, edge, 6, 6)) , edge.sections);
      while (sections.size_0 > 1) {
        $remove_34(sections, sections.size_0 - 1);
      }
    }
    return section;
  }
}

function getSourceNode(simpleEdge){
  if ((!simpleEdge.sources && (simpleEdge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 4, 7)) , simpleEdge.sources).size_0 != 1 || (!simpleEdge.targets && (simpleEdge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 5, 8)) , simpleEdge.targets).size_0 != 1) {
    throw toJs(new IllegalArgumentException_0("Passed edge is not 'simple'."));
  }
  return connectableShapeToNode(castTo($get_16((!simpleEdge.sources && (simpleEdge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 4, 7)) , simpleEdge.sources), 0), 97));
}

function getSourcePort(simpleEdge){
  if ((!simpleEdge.sources && (simpleEdge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 4, 7)) , simpleEdge.sources).size_0 != 1 || (!simpleEdge.targets && (simpleEdge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 5, 8)) , simpleEdge.targets).size_0 != 1) {
    throw toJs(new IllegalArgumentException_0("Passed edge is not 'simple'."));
  }
  return connectableShapeToPort(castTo($get_16((!simpleEdge.sources && (simpleEdge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 4, 7)) , simpleEdge.sources), 0), 97));
}

function getTargetNode(simpleEdge){
  if ((!simpleEdge.sources && (simpleEdge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 4, 7)) , simpleEdge.sources).size_0 != 1 || (!simpleEdge.targets && (simpleEdge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 5, 8)) , simpleEdge.targets).size_0 != 1) {
    throw toJs(new IllegalArgumentException_0("Passed edge is not 'simple'."));
  }
  return connectableShapeToNode(castTo($get_16((!simpleEdge.targets && (simpleEdge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 5, 8)) , simpleEdge.targets), 0), 97));
}

function getTargetPort(simpleEdge){
  if ((!simpleEdge.sources && (simpleEdge.sources = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 4, 7)) , simpleEdge.sources).size_0 != 1 || (!simpleEdge.targets && (simpleEdge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 5, 8)) , simpleEdge.targets).size_0 != 1) {
    throw toJs(new IllegalArgumentException_0("Passed edge is not 'simple'."));
  }
  return connectableShapeToPort(castTo($get_16((!simpleEdge.targets && (simpleEdge.targets = new EObjectWithInverseResolvingEList$ManyInverse(Lorg_eclipse_elk_graph_ElkConnectableShape_2_classLit, simpleEdge, 5, 8)) , simpleEdge.targets), 0), 97));
}

function isDescendant_0(child, ancestor){
  var current;
  current = child;
  while ($getParent_2(current)) {
    current = $getParent_2(current);
    if (current == ancestor) {
      return true;
    }
  }
  return false;
}

var Lorg_eclipse_emf_common_util_EList_2_classLit = createForInterface('org.eclipse.emf.common.util', 'EList');
function $add_20(this$static, index_0, object){
  var size_0;
  size_0 = this$static.size_1();
  if (index_0 > size_0)
    throw toJs(new AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0));
  if (this$static.isUnique() && this$static.contains(object)) {
    throw toJs(new IllegalArgumentException_0("The 'no duplicates' constraint is violated"));
  }
  this$static.addUnique(index_0, object);
}

function $add_21(this$static, object){
  if (this$static.isUnique() && this$static.contains(object)) {
    return false;
  }
   else {
    this$static.addUnique_0(object);
    return true;
  }
}

function $addAll_6(this$static, collection){
  var result;
  this$static.isUnique() && (collection = (result = new LinkedHashSet_1(collection) , $removeAll_0(result, this$static) , new ArrayList_1(result)));
  return this$static.addAllUnique(collection);
}

function $basicListIterator(this$static, index_0){
  var size_0;
  size_0 = this$static.size_1();
  if (index_0 < 0 || index_0 > size_0)
    throw toJs(new AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0));
  return new AbstractEList$NonResolvingEListIterator_0(this$static, index_0);
}

function $didClear(this$static, size_0, oldObjects){
  var i, object;
  if (oldObjects != null) {
    for (i = 0; i < size_0; ++i) {
      object = oldObjects[i];
      this$static.didRemove(i, object);
    }
  }
}

function $equals_9(this$static, object){
  var i, list, o1, o2, objects, size_0;
  if (object === this$static) {
    return true;
  }
  if (!instanceOf(object, 15)) {
    return false;
  }
  list = castTo(object, 15);
  size_0 = this$static.size_1();
  if (list.size_1() != size_0) {
    return false;
  }
  objects = list.iterator_0();
  if (this$static.useEquals()) {
    for (i = 0; i < size_0; ++i) {
      o1 = this$static.primitiveGet(i);
      o2 = objects.next_1();
      if (o1 == null?o2 != null:!equals_Ljava_lang_Object__Z__devirtual$(o1, o2)) {
        return false;
      }
    }
  }
   else {
    for (i = 0; i < size_0; ++i) {
      o1 = this$static.primitiveGet(i);
      o2 = objects.next_1();
      if (maskUndefined(o1) !== maskUndefined(o2)) {
        return false;
      }
    }
  }
  return true;
}

function $getDuplicates(this$static, collection){
  var filteredResult, object, object$iterator;
  if (collection.isEmpty()) {
    return $clinit_ECollections() , $clinit_ECollections() , EMPTY_ELIST;
  }
   else {
    filteredResult = new AbstractEList$1(this$static, collection.size_1());
    for (object$iterator = new AbstractEList$EIterator(this$static); object$iterator.cursor != object$iterator.this$01_2.size_1();) {
      object = $doNext(object$iterator);
      collection.contains(object) && $add_21(filteredResult, object);
    }
    return filteredResult;
  }
}

function $hashCode_1(this$static){
  var hashCode, i, object, size_0;
  hashCode = 1;
  for (i = 0 , size_0 = this$static.size_1(); i < size_0; ++i) {
    object = this$static.primitiveGet(i);
    hashCode = 31 * hashCode + (object == null?0:hashCode__I__devirtual$(object));
  }
  return hashCode;
}

function $remove_31(this$static, object){
  var index_0;
  index_0 = this$static.indexOf_0(object);
  if (index_0 >= 0) {
    this$static.remove_2(index_0);
    return true;
  }
   else {
    return false;
  }
}

function $set_8(this$static, index_0, object){
  var currentIndex, size_0;
  size_0 = this$static.size_1();
  if (index_0 >= size_0)
    throw toJs(new AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0));
  if (this$static.isUnique()) {
    currentIndex = this$static.indexOf_0(object);
    if (currentIndex >= 0 && currentIndex != index_0) {
      throw toJs(new IllegalArgumentException_0("The 'no duplicates' constraint is violated"));
    }
  }
  return this$static.setUnique(index_0, object);
}

function $toString_21(this$static){
  var i, size_0, stringBuffer;
  stringBuffer = new StringBuffer;
  stringBuffer.string += '[';
  for (i = 0 , size_0 = this$static.size_1(); i < size_0;) {
    $append_3(stringBuffer, valueOf_7(this$static.primitiveGet(i)));
    ++i < size_0 && (stringBuffer.string += ', ' , stringBuffer);
  }
  stringBuffer.string += ']';
  return stringBuffer.string;
}

function $validate(this$static, object){
  if (!this$static.canContainNull() && object == null) {
    throw toJs(new IllegalArgumentException_0("The 'no null' constraint is violated"));
  }
  return object;
}

defineClass(61, 43, {20:1, 28:1, 43:1, 13:1, 15:1, 61:1, 52:1});
_.add_3 = function add_44(index_0, object){
  $add_20(this, index_0, object);
}
;
_.add_1 = function add_45(object){
  return $add_21(this, object);
}
;
_.addAll = function addAll_14(collection){
  return $addAll_6(this, collection);
}
;
_.basicIterator = function basicIterator(){
  return new AbstractEList$NonResolvingEIterator(this);
}
;
_.basicListIterator = function basicListIterator(){
  return new AbstractEList$NonResolvingEListIterator(this);
}
;
_.basicListIterator_0 = function basicListIterator_0(index_0){
  return $basicListIterator(this, index_0);
}
;
_.canContainNull = function canContainNull(){
  return true;
}
;
_.didAdd = function didAdd(index_0, newObject){
}
;
_.didChange = function didChange(){
}
;
_.didClear = function didClear(size_0, oldObjects){
  $didClear(this, size_0, oldObjects);
}
;
_.didRemove = function didRemove(index_0, oldObject){
}
;
_.didSet = function didSet(index_0, newObject, oldObject){
}
;
_.equals_0 = function equals_179(object){
  return $equals_9(this, object);
}
;
_.hashCode_1 = function hashCode_69(){
  return $hashCode_1(this);
}
;
_.isUnique = function isUnique_0(){
  return false;
}
;
_.iterator_0 = function iterator_71(){
  return new AbstractEList$EIterator(this);
}
;
_.listIterator_0 = function listIterator_15(){
  return new AbstractEList$EListIterator(this);
}
;
_.listIterator_1 = function listIterator_16(index_0){
  var size_0;
  size_0 = this.size_1();
  if (index_0 < 0 || index_0 > size_0)
    throw toJs(new AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0));
  return new AbstractEList$EListIterator_0(this, index_0);
}
;
_.remove_1 = function remove_95(object){
  return $remove_31(this, object);
}
;
_.resolve = function resolve_0(index_0, object){
  return object;
}
;
_.set_2 = function set_22(index_0, object){
  return $set_8(this, index_0, object);
}
;
_.toString_0 = function toString_134(){
  return $toString_21(this);
}
;
_.useEquals = function useEquals(){
  return true;
}
;
_.validate = function validate(index_0, object){
  return $validate(this, object);
}
;
var Lorg_eclipse_emf_common_util_AbstractEList_2_classLit = createForClass('org.eclipse.emf.common.util', 'AbstractEList', 61);
function $addAllUnique(this$static, index_0, collection){
  var growth, i, object, objects, shifted;
  growth = collection.size_1();
  $grow(this$static, this$static.size_0 + growth);
  shifted = this$static.size_0 - index_0;
  shifted > 0 && arraycopy(this$static.data_0, index_0, this$static.data_0, index_0 + growth, shifted);
  objects = collection.iterator_0();
  this$static.size_0 += growth;
  for (i = 0; i < growth; ++i) {
    object = objects.next_1();
    $assign(this$static, index_0, this$static.validate(index_0, object));
    this$static.didAdd(index_0, object);
    this$static.didChange();
    ++index_0;
  }
  return growth != 0;
}

function $addAllUnique_0(this$static, collection){
  var growth, i, object, objects, oldSize;
  growth = collection.size_1();
  this$static.grow(this$static.size_0 + growth);
  objects = collection.iterator_0();
  oldSize = this$static.size_0;
  this$static.size_0 += growth;
  for (i = oldSize; i < this$static.size_0; ++i) {
    object = objects.next_1();
    $assign(this$static, i, this$static.validate(i, object));
    this$static.didAdd(i, object);
    this$static.didChange();
  }
  return growth != 0;
}

function $addUnique(this$static, index_0, object){
  var validatedObject;
  this$static.grow(this$static.size_0 + 1);
  validatedObject = this$static.validate(index_0, object);
  index_0 != this$static.size_0 && arraycopy(this$static.data_0, index_0, this$static.data_0, index_0 + 1, this$static.size_0 - index_0);
  setCheck(this$static.data_0, index_0, validatedObject);
  ++this$static.size_0;
  this$static.didAdd(index_0, object);
  this$static.didChange();
}

function $addUnique_0(this$static, object){
  this$static.grow(this$static.size_0 + 1);
  $assign(this$static, this$static.size_0, this$static.validate(this$static.size_0, object));
  this$static.didAdd(this$static.size_0++, object);
  this$static.didChange();
}

function $assign(this$static, index_0, object){
  setCheck(this$static.data_0, index_0, object);
  return object;
}

function $basicGet(this$static, index_0){
  if (this$static.data_0 == null || index_0 >= this$static.size_0)
    throw toJs(new BasicEList$BasicIndexOutOfBoundsException(index_0, this$static.size_0));
  return this$static.data_0[index_0];
}

function $clear_9(this$static){
  var oldData, oldSize;
  ++this$static.modCount;
  oldData = this$static.data_0;
  oldSize = this$static.size_0;
  this$static.data_0 = null;
  this$static.size_0 = 0;
  this$static.didClear(oldSize, oldData);
  this$static.didChange();
}

function $contains_10(this$static, object){
  var i;
  if (this$static.useEquals() && object != null) {
    for (i = 0; i < this$static.size_0; ++i) {
      if (equals_Ljava_lang_Object__Z__devirtual$(object, this$static.data_0[i])) {
        return true;
      }
    }
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      if (maskUndefined(this$static.data_0[i]) === maskUndefined(object)) {
        return true;
      }
    }
  }
  return false;
}

function $get_16(this$static, index_0){
  if (this$static.data_0 == null || index_0 >= this$static.size_0)
    throw toJs(new BasicEList$BasicIndexOutOfBoundsException(index_0, this$static.size_0));
  return this$static.resolve(index_0, this$static.data_0[index_0]);
}

function $grow(this$static, minimumCapacity){
  var newCapacity, oldCapacity, oldData;
  ++this$static.modCount;
  oldCapacity = this$static.data_0 == null?0:this$static.data_0.length;
  if (minimumCapacity > oldCapacity) {
    oldData = this$static.data_0;
    newCapacity = oldCapacity + (oldCapacity / 2 | 0) + 4;
    newCapacity < minimumCapacity && (newCapacity = minimumCapacity);
    this$static.data_0 = this$static.newData(newCapacity);
    oldData != null && arraycopy(oldData, 0, this$static.data_0, 0, this$static.size_0);
  }
}

function $indexOf_4(this$static, object){
  var i;
  if (this$static.useEquals() && object != null) {
    for (i = 0; i < this$static.size_0; ++i) {
      if (equals_Ljava_lang_Object__Z__devirtual$(object, this$static.data_0[i])) {
        return i;
      }
    }
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      if (maskUndefined(this$static.data_0[i]) === maskUndefined(object)) {
        return i;
      }
    }
  }
  return -1;
}

function $remove_32(this$static, index_0){
  var oldObject, shifted;
  if (index_0 >= this$static.size_0)
    throw toJs(new BasicEList$BasicIndexOutOfBoundsException(index_0, this$static.size_0));
  ++this$static.modCount;
  oldObject = this$static.data_0[index_0];
  shifted = this$static.size_0 - index_0 - 1;
  shifted > 0 && arraycopy(this$static.data_0, index_0 + 1, this$static.data_0, index_0, shifted);
  setCheck(this$static.data_0, --this$static.size_0, null);
  this$static.didRemove(index_0, oldObject);
  this$static.didChange();
  return oldObject;
}

function $setUnique(this$static, index_0, object){
  var oldObject;
  oldObject = this$static.data_0[index_0];
  $assign(this$static, index_0, this$static.validate(index_0, object));
  this$static.didSet(index_0, object, oldObject);
  this$static.didChange();
  return oldObject;
}

function $shrink_0(this$static){
  var oldData;
  ++this$static.modCount;
  if (this$static.size_0 == 0) {
    this$static.data_0 = null;
  }
   else if (this$static.size_0 < this$static.data_0.length) {
    oldData = this$static.data_0;
    this$static.data_0 = this$static.newData(this$static.size_0);
    arraycopy(oldData, 0, this$static.data_0, 0, this$static.size_0);
  }
}

function $toArray_5(this$static){
  var result;
  result = this$static.newData(this$static.size_0);
  this$static.size_0 > 0 && arraycopy(this$static.data_0, 0, result, 0, this$static.size_0);
  return result;
}

function $toArray_6(this$static, array){
  var newArray;
  if (this$static.size_0 > 0) {
    if (array.length < this$static.size_0) {
      newArray = newInstance_10(getClass__Ljava_lang_Class___devirtual$(array).componentType, this$static.size_0);
      array = newArray;
    }
    arraycopy(this$static.data_0, 0, array, 0, this$static.size_0);
  }
  array.length > this$static.size_0 && setCheck(array, this$static.size_0, null);
  return array;
}

function BasicEList(){
}

function BasicEList_0(initialCapacity){
  if (initialCapacity < 0) {
    throw toJs(new IllegalArgumentException_0('Illegal Capacity: ' + initialCapacity));
  }
  this.data_0 = this.newData(initialCapacity);
}

function BasicEList_1(collection){
  this.size_0 = collection.size_1();
  if (this.size_0 > 0) {
    this.data_0 = this.newData(this.size_0 + (this.size_0 / 8 | 0) + 1);
    collection.toArray_0(this.data_0);
  }
}

defineClass(55, 61, $intern_141, BasicEList, BasicEList_0, BasicEList_1);
_.addAllUnique = function addAllUnique(collection){
  return $addAllUnique_0(this, collection);
}
;
_.addUnique = function addUnique(index_0, object){
  $addUnique(this, index_0, object);
}
;
_.addUnique_0 = function addUnique_0(object){
  $addUnique_0(this, object);
}
;
_.basicGet = function basicGet(index_0){
  return $basicGet(this, index_0);
}
;
_.clear_0 = function clear_48(){
  $clear_9(this);
}
;
_.contains = function contains_46(object){
  return $contains_10(this, object);
}
;
_.get_3 = function get_37(index_0){
  return $get_16(this, index_0);
}
;
_.grow = function grow(minimumCapacity){
  $grow(this, minimumCapacity);
}
;
_.indexOf_0 = function indexOf_8(object){
  return $indexOf_4(this, object);
}
;
_.isEmpty = function isEmpty_22(){
  return this.size_0 == 0;
}
;
_.newData = function newData_0(capacity){
  return initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, capacity, 5, 1);
}
;
_.primitiveGet = function primitiveGet(index_0){
  return this.data_0[index_0];
}
;
_.remove_2 = function remove_96(index_0){
  return $remove_32(this, index_0);
}
;
_.setUnique = function setUnique(index_0, object){
  return $setUnique(this, index_0, object);
}
;
_.size_1 = function size_56(){
  return this.size_0;
}
;
_.toArray = function toArray_28(){
  return $toArray_5(this);
}
;
_.toArray_0 = function toArray_29(array){
  return $toArray_6(this, array);
}
;
_.size_0 = 0;
var Lorg_eclipse_emf_common_util_BasicEList_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEList', 55);
var Lorg_eclipse_emf_common_util_TreeIterator_2_classLit = createForInterface('org.eclipse.emf.common.util', 'TreeIterator');
function $hasAnyChildren(this$static){
  var nextPruneIterator;
  nextPruneIterator = this$static.getChildren(this$static.object);
  $add_21(this$static, nextPruneIterator);
  return nextPruneIterator.hasNext_0();
}

function $next_16(this$static){
  var currentIterator, iterator, nextIterator, result, result0;
  if (this$static.data_0 == null) {
    this$static.nextPruneIterator = this$static.getChildren(this$static.object);
    $add_21(this$static, this$static.nextPruneIterator);
    if (this$static.includeRoot) {
      result0 = this$static.object;
      return result0;
    }
  }
  currentIterator = castTo(this$static.data_0[this$static.size_0 - 1], 47);
  result = currentIterator.next_1();
  this$static.nextRemoveIterator = currentIterator;
  iterator = this$static.getChildren(result);
  if (iterator.hasNext_0()) {
    this$static.nextPruneIterator = iterator;
    $add_21(this$static, iterator);
  }
   else {
    this$static.nextPruneIterator = null;
    while (!currentIterator.hasNext_0()) {
      setCheck(this$static.data_0, --this$static.size_0, null);
      if (this$static.size_0 == 0) {
        break;
      }
      nextIterator = castTo(this$static.data_0[this$static.size_0 - 1], 47);
      currentIterator = nextIterator;
    }
  }
  return result;
}

function AbstractTreeIterator(object, includeRoot){
  this.object = object;
  this.includeRoot = includeRoot;
}

defineClass(651, 55, $intern_142);
_.forEachRemaining = function forEachRemaining_46(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_42(){
  return this.data_0 == null && !this.includeRoot?$hasAnyChildren(this):this.data_0 == null || this.size_0 != 0 && castTo(this.data_0[this.size_0 - 1], 47).hasNext_0();
}
;
_.next_1 = function next_43(){
  return $next_16(this);
}
;
_.remove_0 = function remove_97(){
  if (!this.nextRemoveIterator) {
    throw toJs(new IllegalStateException_0('There is no valid object to remove.'));
  }
  this.nextRemoveIterator.remove_0();
}
;
_.includeRoot = false;
var Lorg_eclipse_emf_common_util_AbstractTreeIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'AbstractTreeIterator', 651);
function ElkGraphUtil$PropertiesSkippingTreeIterator(object){
  AbstractTreeIterator.call(this, object, true);
}

defineClass(642, 651, $intern_142, ElkGraphUtil$PropertiesSkippingTreeIterator);
_.getChildren = function getChildren(object){
  var iterator;
  iterator = castTo(object, 51).eContents_0().iterator_0();
  instanceOf(iterator, 272) && castTo(iterator, 272).filter_0(new ElkGraphUtil$PropertiesSkippingTreeIterator$1);
  return iterator;
}
;
var Lorg_eclipse_elk_graph_util_ElkGraphUtil$PropertiesSkippingTreeIterator_2_classLit = createForClass('org.eclipse.elk.graph.util', 'ElkGraphUtil/PropertiesSkippingTreeIterator', 642);
function ElkGraphUtil$PropertiesSkippingTreeIterator$1(){
}

defineClass(901, 1, {}, ElkGraphUtil$PropertiesSkippingTreeIterator$1);
var Lorg_eclipse_elk_graph_util_ElkGraphUtil$PropertiesSkippingTreeIterator$1_2_classLit = createForClass('org.eclipse.elk.graph.util', 'ElkGraphUtil/PropertiesSkippingTreeIterator/1', 901);
function $clinit_ElkReflect(){
  $clinit_ElkReflect = emptyMethod;
  REGISTRY_NEW = ($clinit_Maps() , new HashMap);
  REGISTRY_CLONE = new HashMap;
  registerClone(Ljava_util_EnumSet_2_classLit, new ElkReflect$lambda$0$Type);
}

function clone_10(clonee){
  $clinit_ElkReflect();
  if (instanceOf(clonee, 134)) {
    return castTo($get_6(REGISTRY_CLONE, Ljava_util_EnumSet_2_classLit), 295).clone(clonee);
  }
  if ($containsKey_2(REGISTRY_CLONE, getClass__Ljava_lang_Class___devirtual$(clonee))) {
    return castTo($get_6(REGISTRY_CLONE, getClass__Ljava_lang_Class___devirtual$(clonee)), 295).clone(clonee);
  }
  return null;
}

function newInstance_9(clazz){
  $clinit_ElkReflect();
  return $containsKey_2(REGISTRY_NEW, clazz)?castTo($get_6(REGISTRY_NEW, clazz), 351).newInstance():null;
}

function register(clazz, newFun, cloneFun){
  $clinit_ElkReflect();
  !!clazz && $put_1(REGISTRY_NEW, clazz, newFun);
  !!clazz && $put_1(REGISTRY_CLONE, clazz, cloneFun);
}

function registerClone(clazz, cloneFun){
  !!clazz && $put_1(REGISTRY_CLONE, clazz, cloneFun);
}

var REGISTRY_CLONE, REGISTRY_NEW;
var Lorg_eclipse_elk_graph_util_ElkReflect_2_classLit = createForClass('org.eclipse.elk.graph.util', 'ElkReflect', null);
function ElkReflect$lambda$0$Type(){
}

defineClass(816, 1, $intern_134, ElkReflect$lambda$0$Type);
_.clone = function clone_11(o){
  return $clinit_ElkReflect() , $clone(castTo(o, 190));
}
;
var Lorg_eclipse_elk_graph_util_ElkReflect$lambda$0$Type_2_classLit = createForClass('org.eclipse.elk.graph.util', 'ElkReflect/lambda$0$Type', 816);
function $clinit_ElkJs(){
  $clinit_ElkJs = emptyMethod;
  SERVICE = getInstance();
}

function exportLayout(){
  $clinit_ElkJs();
  function Dispatcher(worker){
    var _this = this;
    this.dispatch = function(event_0){
      var data_0 = event_0.data;
      switch (data_0.cmd) {
        case 'algorithms':
          var algs = getLayoutData(($clinit_Collections() , new Collections$UnmodifiableCollection(new AbstractMap$2(SERVICE.layoutAlgorithmMap))));
          worker.postMessage({id:data_0.id, data:algs});
          break;
        case 'categories':
          var cats = getLayoutData(($clinit_Collections() , new Collections$UnmodifiableCollection(new AbstractMap$2(SERVICE.layoutCategoryMap))));
          worker.postMessage({id:data_0.id, data:cats});
          break;
        case 'options':
          var opts = getLayoutData(($clinit_Collections() , new Collections$UnmodifiableCollection(new AbstractMap$2(SERVICE.layoutOptionMap))));
          worker.postMessage({id:data_0.id, data:opts});
          break;
        case 'register':
          registerLayoutAlgorithms(data_0.algorithms);
          worker.postMessage({id:data_0.id});
          break;
        case 'layout':
          layout_10(data_0.graph, data_0.options || {});
          worker.postMessage({id:data_0.id, data:data_0.graph});
          break;
      }
    }
    ;
    this.saveDispatch = function(event_0){
      try {
        _this.dispatch(event_0);
      }
       catch (err) {
        delete err['__java$exception'];
        worker.postMessage({id:event_0.data.id, error:err.message});
      }
    }
    ;
  }

  function FakeWorker(url_0){
    var _this = this;
    this.dispatcher = new Dispatcher({postMessage:function(msg){
      _this.onmessage({data:msg});
    }
    });
    this.postMessage = function(msg){
      setTimeout(function(){
        _this.dispatcher.saveDispatch({data:msg});
      }
      , 0);
    }
    ;
  }

  if (typeof document === 'undefined' && typeof self !== 'undefined') {
    var dispatcher = new Dispatcher(self);
    self.onmessage = dispatcher.saveDispatch;
  }
   else if (typeof module !== 'undefined' && module.exports) {
    Object.defineProperty(exports, '__esModule', {value:true});
    module.exports = {'default':FakeWorker, Worker:FakeWorker};
  }
}

function getLayoutData(data_0){
  var arr, json, ld, ld$iterator;
  arr = new JSONArray;
  for (ld$iterator = new Collections$UnmodifiableCollectionIterator(data_0.coll.iterator_0()); ld$iterator.it.hasNext_0();) {
    ld = castTo(ld$iterator.it.next_1(), 643);
    json = toJson(ld);
    $set_0(arr, arr.jsArray.length, json);
  }
  return arr.jsArray;
}

function layout_10(graphObj, optionsObj){
  var _function, elkGraph, graph, importer, lc, options, root;
  graph = new JSONObject_0(graphObj);
  importer = new JsonImporter;
  elkGraph = ($clear(importer.nodeIdMap) , $clear(importer.portIdMap) , $reset(importer.edgeIdMap) , $clear(importer.edgeSectionIdMap) , $clear(importer.nodeJsonMap) , $reset(importer.portJsonMap) , $reset(importer.edgeJsonMap) , $reset(importer.edgeSectionJsonMap) , root = $transformNode_0(importer, graph, null) , $transformEdges_2(importer, graph) , root);
  if (optionsObj) {
    options = new JSONObject_0(optionsObj);
    lc = optsToCfg(options);
    applyVisitors(elkGraph, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_util_IGraphElementVisitor_2_classLit, 1), $intern_1, 641, 0, [lc]));
  }
  $layout_3(new RecursiveGraphLayoutEngine, elkGraph, new BasicProgressMonitor);
  _function = new JsonImporter$lambda$19$Type(importer);
  forEach_37(new ElkGraphUtil$PropertiesSkippingTreeIterator(elkGraph), _function);
}

function optsToCfg(opts){
  var jsonVal, key, key$iterator, keys_0, lc, option, serialized, value_0;
  lc = new LayoutConfigurator;
  $addFilter(lc, ($clinit_LayoutConfigurator() , NO_OVERWRITE));
  for (key$iterator = (keys_0 = $computeKeys0(opts, initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, 0, 6, 1)) , new AbstractList$IteratorImpl(new Arrays$ArrayList((new JSONObject$1(opts, keys_0)).val$keys2))); key$iterator.i < key$iterator.this$01_0.size_1();) {
    key = (checkCriticalElement(key$iterator.i < key$iterator.this$01_0.size_1()) , castToString(key$iterator.this$01_0.get_3(key$iterator.last = key$iterator.i++)));
    option = $getOptionDataBySuffix(SERVICE, key);
    if (option) {
      jsonVal = $get_5(opts, key);
      jsonVal.isString()?(serialized = jsonVal.isString().value_0):jsonVal.isBoolean()?(serialized = '' + jsonVal.isBoolean().value_0):jsonVal.isNumber()?(serialized = '' + jsonVal.isNumber().value_0):(serialized = jsonVal.toString_0());
      value_0 = $parseValue(option, serialized);
      if (value_0 != null) {
        ($containsEnum(option.targets, ($clinit_LayoutOptionData$Target() , NODES)) || $containsEnum(option.targets, PARENTS)) && $setProperty($configure(lc, Lorg_eclipse_elk_graph_ElkNode_2_classLit), option, value_0);
        $containsEnum(option.targets, EDGES) && $setProperty($configure(lc, Lorg_eclipse_elk_graph_ElkEdge_2_classLit), option, value_0);
        $containsEnum(option.targets, PORTS) && $setProperty($configure(lc, Lorg_eclipse_elk_graph_ElkPort_2_classLit), option, value_0);
        $containsEnum(option.targets, LABELS) && $setProperty($configure(lc, Lorg_eclipse_elk_graph_ElkLabel_2_classLit), option, value_0);
      }
    }
  }
  return lc;
}

function registerLayoutAlgorithms(arrayObj){
  var alg, arr, i;
  arr = new JSONArray_0(arrayObj);
  for (i = 0; i < arr.jsArray.length; ++i) {
    alg = $get_4(arr, i).isString().value_0;
    $equals_4(alg, 'layered')?$registerLayoutMetaDataProviders(SERVICE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit, 1), $intern_1, 141, 0, [new LayeredMetaDataProvider])):$equals_4(alg, 'force')?$registerLayoutMetaDataProviders(SERVICE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit, 1), $intern_1, 141, 0, [new ForceMetaDataProvider])):$equals_4(alg, 'stress')?$registerLayoutMetaDataProviders(SERVICE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit, 1), $intern_1, 141, 0, [new StressMetaDataProvider])):$equals_4(alg, 'mrtree')?$registerLayoutMetaDataProviders(SERVICE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit, 1), $intern_1, 141, 0, [new MrTreeMetaDataProvider])):$equals_4(alg, 'radial')?$registerLayoutMetaDataProviders(SERVICE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit, 1), $intern_1, 141, 0, [new RadialMetaDataProvider])):$equals_4(alg, 'disco')?$registerLayoutMetaDataProviders(SERVICE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit, 1), $intern_1, 141, 0, [new PolyominoOptions, new DisCoMetaDataProvider])):($equals_4(alg, 'sporeOverlap') || $equals_4(alg, 'sporeCompaction')) && $registerLayoutMetaDataProviders(SERVICE, stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_elk_core_data_ILayoutMetaDataProvider_2_classLit, 1), $intern_1, 141, 0, [new SporeMetaDataProvider]));
  }
}

var SERVICE;
var Lorg_eclipse_emf_common_util_ResourceLocator_2_classLit = createForInterface('org.eclipse.emf.common.util', 'ResourceLocator');
function $getString(key){
  return $equals_4('_UI_EMFDiagnostic_marker', key)?'EMF Problem':$equals_4('_UI_CircularContainment_diagnostic', key)?'An object may not circularly contain itself':$equals_4('parser.parse.1', key)?'Wrong character.':$equals_4('parser.parse.2', key)?'Invalid reference number.':$equals_4('parser.next.1', key)?'A character is required after \\.':$equals_4('parser.next.2', key)?"'?' is not expected.  '(?:' or '(?=' or '(?!' or '(?<' or '(?#' or '(?>'?":$equals_4('parser.next.3', key)?"'(?<' or '(?<!' is expected.":$equals_4('parser.next.4', key)?'A comment is not terminated.':$equals_4('parser.factor.1', key)?"')' is expected.":$equals_4('parser.factor.2', key)?'Unexpected end of the pattern in a modifier group.':$equals_4('parser.factor.3', key)?"':' is expected.":$equals_4('parser.factor.4', key)?'Unexpected end of the pattern in a conditional group.':$equals_4('parser.factor.5', key)?'A back reference or an anchor or a lookahead or a look-behind is expected in a conditional pattern.':$equals_4('parser.factor.6', key)?'There are more than three choices in a conditional group.':$equals_4('parser.atom.1', key)?'A character in U+0040-U+005f must follow \\c.':$equals_4('parser.atom.2', key)?"A '{' is required before a character category.":$equals_4('parser.atom.3', key)?"A property name is not closed by '}'.":$equals_4('parser.atom.4', key)?'Unexpected meta character.':$equals_4('parser.atom.5', key)?'Unknown property.':$equals_4('parser.cc.1', key)?"A POSIX character class must be closed by ':]'.":$equals_4('parser.cc.2', key)?'Unexpected end of the pattern in a character class.':$equals_4('parser.cc.3', key)?'Unknown name for a POSIX character class.':$equals_4('parser.cc.4', key)?"'-' is invalid here.":$equals_4('parser.cc.5', key)?"']' is expected.":$equals_4('parser.cc.6', key)?"'[' is invalid in a character class.  Write '\\['.":$equals_4('parser.cc.7', key)?"']' is invalid in a character class.  Write '\\]'.":$equals_4('parser.cc.8', key)?"'-' is an invalid character range. Write '\\-'.":$equals_4('parser.ope.1', key)?"'[' is expected.":$equals_4('parser.ope.2', key)?"')' or '-[' or '+[' or '&[' is expected.":$equals_4('parser.ope.3', key)?'The range end code point is less than the start code point.':$equals_4('parser.descape.1', key)?'Invalid Unicode hex notation.':$equals_4('parser.descape.2', key)?'Overflow in a hex notation.':$equals_4('parser.descape.3', key)?"'\\x{' must be closed by '}'.":$equals_4('parser.descape.4', key)?'Invalid Unicode code point.':$equals_4('parser.descape.5', key)?'An anchor must not be here.':$equals_4('parser.process.1', key)?'This expression is not supported in the current option setting.':$equals_4('parser.quantifier.1', key)?'Invalid quantifier. A digit is expected.':$equals_4('parser.quantifier.2', key)?"Invalid quantifier. Invalid quantity or a '}' is missing.":$equals_4('parser.quantifier.3', key)?"Invalid quantifier. A digit or '}' is expected.":$equals_4('parser.quantifier.4', key)?'Invalid quantifier. A min quantity must be <= a max quantity.':$equals_4('parser.quantifier.5', key)?'Invalid quantifier. A quantity value overflow.':$equals_4('_UI_PackageRegistry_extensionpoint', key)?'Ecore Package Registry for Generated Packages':$equals_4('_UI_DynamicPackageRegistry_extensionpoint', key)?'Ecore Package Registry for Dynamic Packages':$equals_4('_UI_FactoryRegistry_extensionpoint', key)?'Ecore Factory Override Registry':$equals_4('_UI_URIExtensionParserRegistry_extensionpoint', key)?'URI Extension Parser Registry':$equals_4('_UI_URIProtocolParserRegistry_extensionpoint', key)?'URI Protocol Parser Registry':$equals_4('_UI_URIContentParserRegistry_extensionpoint', key)?'URI Content Parser Registry':$equals_4('_UI_ContentHandlerRegistry_extensionpoint', key)?'Content Handler Registry':$equals_4('_UI_URIMappingRegistry_extensionpoint', key)?'URI Converter Mapping Registry':$equals_4('_UI_PackageRegistryImplementation_extensionpoint', key)?'Ecore Package Registry Implementation':$equals_4('_UI_ValidationDelegateRegistry_extensionpoint', key)?'Validation Delegate Registry':$equals_4('_UI_SettingDelegateRegistry_extensionpoint', key)?'Feature Setting Delegate Factory Registry':$equals_4('_UI_InvocationDelegateRegistry_extensionpoint', key)?'Operation Invocation Delegate Factory Registry':$equals_4('_UI_EClassInterfaceNotAbstract_diagnostic', key)?'A class that is an interface must also be abstract':$equals_4('_UI_EClassNoCircularSuperTypes_diagnostic', key)?'A class may not be a super type of itself':$equals_4('_UI_EClassNotWellFormedMapEntryNoInstanceClassName_diagnostic', key)?"A class that inherits from a map entry class must have instance class name 'java.util.Map$Entry'":$equals_4('_UI_EReferenceOppositeOfOppositeInconsistent_diagnostic', key)?'The opposite of the opposite may not be a reference different from this one':$equals_4('_UI_EReferenceOppositeNotFeatureOfType_diagnostic', key)?"The opposite must be a feature of the reference's type":$equals_4('_UI_EReferenceTransientOppositeNotTransient_diagnostic', key)?'The opposite of a transient reference must be transient if it is proxy resolving':$equals_4('_UI_EReferenceOppositeBothContainment_diagnostic', key)?'The opposite of a containment reference must not be a containment reference':$equals_4('_UI_EReferenceConsistentUnique_diagnostic', key)?'A containment or bidirectional reference must be unique if its upper bound is different from 1':$equals_4('_UI_ETypedElementNoType_diagnostic', key)?'The typed element must have a type':$equals_4('_UI_EAttributeNoDataType_diagnostic', key)?'The generic attribute type must not refer to a class':$equals_4('_UI_EReferenceNoClass_diagnostic', key)?'The generic reference type must not refer to a data type':$equals_4('_UI_EGenericTypeNoTypeParameterAndClassifier_diagnostic', key)?"A generic type can't refer to both a type parameter and a classifier":$equals_4('_UI_EGenericTypeNoClass_diagnostic', key)?'A generic super type must refer to a class':$equals_4('_UI_EGenericTypeNoTypeParameterOrClassifier_diagnostic', key)?'A generic type in this context must refer to a classifier or a type parameter':$equals_4('_UI_EGenericTypeBoundsOnlyForTypeArgument_diagnostic', key)?'A generic type may have bounds only when used as a type argument':$equals_4('_UI_EGenericTypeNoUpperAndLowerBound_diagnostic', key)?'A generic type must not have both a lower and an upper bound':$equals_4('_UI_EGenericTypeNoTypeParameterOrClassifierAndBound_diagnostic', key)?'A generic type with bounds must not also refer to a type parameter or classifier':$equals_4('_UI_EGenericTypeNoArguments_diagnostic', key)?'A generic type may have arguments only if it refers to a classifier':$equals_4('_UI_EGenericTypeOutOfScopeTypeParameter_diagnostic', key)?'A generic type may only refer to a type parameter that is in scope':key;
}

defineClass(991, 1, {});
var Lorg_eclipse_emf_common_util_DelegatingResourceLocator_2_classLit = createForClass('org.eclipse.emf.common.util', 'DelegatingResourceLocator', 991);
function $log(logEntry){
  logEntry?$printStackTraceImpl(logEntry, ($clinit_System() , err_0), ''):($clinit_System() , err_0);
}

defineClass(992, 991, {});
var Lorg_eclipse_emf_common_EMFPlugin_2_classLit = createForClass('org.eclipse.emf.common', 'EMFPlugin', 992);
var Lorg_eclipse_emf_common_notify_Adapter_2_classLit = createForInterface('org.eclipse.emf.common.notify', 'Adapter');
var Lorg_eclipse_emf_common_notify_Notification_2_classLit = createForInterface('org.eclipse.emf.common.notify', 'Notification');
defineClass(1041, 1, $intern_143);
_.getTarget = function getTarget(){
  return this.target;
}
;
_.notifyChanged = function notifyChanged(msg){
}
;
_.setTarget = function setTarget(newTarget){
  this.target = newTarget;
}
;
_.unsetTarget = function unsetTarget(oldTarget){
  this.target == oldTarget && (this.target = null);
}
;
_.target = null;
var Lorg_eclipse_emf_common_notify_impl_AdapterImpl_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'AdapterImpl', 1041);
function $addAllUnique_1(this$static, index_0, collection){
  var object, object$iterator;
  ++this$static.modCount;
  if (collection.isEmpty()) {
    return false;
  }
   else {
    for (object$iterator = collection.iterator_0(); object$iterator.hasNext_0();) {
      object = object$iterator.next_1();
      this$static.delegateAdd(index_0, this$static.validate(index_0, object));
      ++index_0;
    }
    return true;
  }
}

function $addUnique_1(this$static, index_0, object){
  ++this$static.modCount;
  this$static.delegateAdd(index_0, this$static.validate(index_0, object));
}

function $addUnique_2(this$static, object){
  var size_0;
  ++this$static.modCount;
  size_0 = this$static.delegateSize();
  this$static.delegateAdd_0(this$static.validate(size_0, object));
}

function $doClear(this$static, oldSize, oldData){
  ++this$static.modCount;
  this$static.delegateClear();
  $didClear(this$static, oldSize, oldData);
}

function $remove_33(this$static, index_0){
  var oldObject;
  ++this$static.modCount;
  oldObject = this$static.delegateRemove(index_0);
  return oldObject;
}

defineClass(1772, 61, $intern_144);
_.addAllUnique = function addAllUnique_0(collection){
  var i, object, object$iterator;
  ++this.modCount;
  if (collection.isEmpty()) {
    return false;
  }
   else {
    i = this.delegateSize();
    for (object$iterator = collection.iterator_0(); object$iterator.hasNext_0();) {
      object = object$iterator.next_1();
      this.delegateAdd_0(this.validate(i, object));
      ++i;
    }
    return true;
  }
}
;
_.addUnique = function addUnique_1(index_0, object){
  $addUnique_1(this, index_0, object);
}
;
_.addUnique_0 = function addUnique_2(object){
  $addUnique_2(this, object);
}
;
_.basicList = function basicList(){
  return this.delegateBasicList();
}
;
_.clear_0 = function clear_49(){
  $doClear(this, this.delegateSize(), this.delegateToArray());
}
;
_.contains = function contains_47(object){
  return this.delegateContains(object);
}
;
_.containsAll = function containsAll_12(collection){
  return this.delegateContainsAll(collection);
}
;
_.delegateAdd = function delegateAdd(index_0, object){
  this.delegateList_0().$_nullMethod();
}
;
_.delegateAdd_0 = function delegateAdd_0(object){
  this.delegateList_0().$_nullMethod();
}
;
_.delegateBasicList = function delegateBasicList(){
  return this.delegateList_0();
}
;
_.delegateClear = function delegateClear(){
  this.delegateList_0().$_nullMethod();
}
;
_.delegateContains = function delegateContains(object){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateContainsAll = function delegateContainsAll(collection){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateEquals = function delegateEquals(object){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateGet = function delegateGet(index_0){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateHashCode = function delegateHashCode(){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateIndexOf = function delegateIndexOf(object){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateIsEmpty = function delegateIsEmpty(){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateRemove = function delegateRemove(index_0){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateSet = function delegateSet(index_0, object){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateSize = function delegateSize(){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateToArray = function delegateToArray(){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateToArray_0 = function delegateToArray_0(array){
  return this.delegateList_0().$_nullMethod();
}
;
_.delegateToString = function delegateToString(){
  return this.delegateList_0().$_nullMethod();
}
;
_.equals_0 = function equals_180(object){
  return this.delegateEquals(object);
}
;
_.get_3 = function get_38(index_0){
  return this.resolve(index_0, this.delegateGet(index_0));
}
;
_.hashCode_1 = function hashCode_70(){
  return this.delegateHashCode();
}
;
_.indexOf_0 = function indexOf_9(object){
  return this.delegateIndexOf(object);
}
;
_.isEmpty = function isEmpty_23(){
  return this.delegateIsEmpty();
}
;
_.primitiveGet = function primitiveGet_0(index_0){
  return this.delegateGet(index_0);
}
;
_.remove_2 = function remove_98(index_0){
  return $remove_33(this, index_0);
}
;
_.remove_1 = function remove_99(object){
  var index_0;
  index_0 = this.indexOf_0(object);
  if (index_0 >= 0) {
    this.remove_2(index_0);
    return true;
  }
   else {
    return false;
  }
}
;
_.setUnique = function setUnique_0(index_0, object){
  return this.delegateSet(index_0, this.validate(index_0, object));
}
;
_.size_1 = function size_57(){
  return this.delegateSize();
}
;
_.toArray = function toArray_30(){
  return this.delegateToArray();
}
;
_.toArray_0 = function toArray_31(array){
  return this.delegateToArray_0(array);
}
;
_.toString_0 = function toString_135(){
  return this.delegateToString();
}
;
var Lorg_eclipse_emf_common_util_DelegatingEList_2_classLit = createForClass('org.eclipse.emf.common.util', 'DelegatingEList', 1772);
function $addAllUnique_2(this$static, index_0, collection){
  var collectionSize, i, lastIndex, notification, notifications, oldIsSet, value_0;
  collectionSize = collection.size_1();
  if (collectionSize == 0) {
    return false;
  }
   else {
    if (this$static.isNotificationRequired()) {
      oldIsSet = this$static.isSet_0();
      $addAllUnique_1(this$static, index_0, collection);
      notification = collectionSize == 1?this$static.createNotification(3, null, collection.iterator_0().next_1(), index_0, oldIsSet):this$static.createNotification(5, null, collection, index_0, oldIsSet);
      if (this$static.hasInverse()) {
        notifications = collectionSize < 100?null:new NotificationChainImpl_0(collectionSize);
        lastIndex = index_0 + collectionSize;
        for (i = index_0; i < lastIndex; ++i) {
          value_0 = this$static.delegateGet(i);
          notifications = this$static.inverseAdd(value_0, notifications);
          notifications = notifications;
        }
        if (!notifications) {
          this$static.dispatchNotification(notification);
        }
         else {
          notifications.add_4(notification);
          notifications.dispatch_0();
        }
      }
       else {
        this$static.dispatchNotification(notification);
      }
    }
     else {
      $addAllUnique_1(this$static, index_0, collection);
      if (this$static.hasInverse()) {
        notifications = collectionSize < 100?null:new NotificationChainImpl_0(collectionSize);
        lastIndex = index_0 + collectionSize;
        for (i = index_0; i < lastIndex; ++i) {
          notifications = this$static.inverseAdd(this$static.delegateGet(i), notifications);
        }
        !!notifications && notifications.dispatch_0();
      }
    }
    return true;
  }
}

function $addUnique_3(this$static, index_0, object){
  var notification, notifications, oldIsSet;
  if (this$static.isNotificationRequired()) {
    oldIsSet = this$static.isSet_0();
    ++this$static.modCount;
    this$static.delegateAdd(index_0, this$static.validate(index_0, object));
    notification = this$static.createNotification(3, null, object, index_0, oldIsSet);
    if (this$static.hasInverse()) {
      notifications = this$static.inverseAdd(object, null);
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      this$static.dispatchNotification(notification);
    }
  }
   else {
    ++this$static.modCount;
    this$static.delegateAdd(index_0, this$static.validate(index_0, object));
    if (this$static.hasInverse()) {
      notifications = this$static.inverseAdd(object, null);
      !!notifications && notifications.dispatch_0();
    }
  }
}

function $addUnique_4(this$static, object){
  var index_0, notification, notifications, oldIsSet;
  if (this$static.isNotificationRequired()) {
    index_0 = this$static.delegateSize();
    oldIsSet = this$static.isSet_0();
    ++this$static.modCount;
    this$static.delegateAdd(index_0, this$static.validate(index_0, object));
    notification = this$static.createNotification(3, null, object, index_0, oldIsSet);
    if (this$static.hasInverse()) {
      notifications = this$static.inverseAdd(object, null);
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      this$static.dispatchNotification(notification);
    }
  }
   else {
    $addUnique_2(this$static, object);
    if (this$static.hasInverse()) {
      notifications = this$static.inverseAdd(object, null);
      !!notifications && notifications.dispatch_0();
    }
  }
}

function $basicAdd(this$static, object, notifications){
  var index_0, notification, oldIsSet;
  if (this$static.isNotificationRequired()) {
    index_0 = this$static.delegateSize();
    oldIsSet = this$static.isSet_0();
    ++this$static.modCount;
    this$static.delegateAdd(index_0, this$static.validate(index_0, object));
    notification = this$static.createNotification(3, null, object, index_0, oldIsSet);
    !notifications?(notifications = notification):notifications.add_4(notification);
  }
   else {
    $addUnique_1(this$static, this$static.delegateSize(), object);
  }
  return notifications;
}

function $basicRemove(this$static, object, notifications){
  var index_0, notification, oldIsSet, oldObject;
  index_0 = this$static.indexOf_0(object);
  if (index_0 != -1) {
    if (this$static.isNotificationRequired()) {
      oldIsSet = this$static.isSet_0();
      oldObject = $remove_33(this$static, index_0);
      notification = this$static.createNotification(4, oldObject, null, index_0, oldIsSet);
      !notifications?(notifications = notification):notifications.add_4(notification);
    }
     else {
      $remove_33(this$static, index_0);
    }
  }
  return notifications;
}

function $clear_10(this$static){
  var collection, i, notification, notifications, object, oldData, oldIsSet, size_0;
  if (this$static.isNotificationRequired()) {
    size_0 = this$static.delegateSize();
    oldIsSet = this$static.isSet_0();
    if (size_0 > 0) {
      collection = new BasicEList_1(this$static.basicList());
      notifications = size_0 < 100?null:new NotificationChainImpl_0(size_0);
      $doClear(this$static, size_0, collection.data_0);
      notification = size_0 == 1?this$static.createNotification(4, $get_16(collection, 0), null, 0, oldIsSet):this$static.createNotification(6, collection, null, -1, oldIsSet);
      if (this$static.hasInverse()) {
        for (i = new AbstractEList$EIterator(collection); i.cursor != i.this$01_2.size_1();) {
          notifications = this$static.inverseRemove($doNext(i), notifications);
        }
        if (!notifications) {
          this$static.dispatchNotification(notification);
        }
         else {
          notifications.add_4(notification);
          notifications.dispatch_0();
        }
      }
       else {
        if (!notifications) {
          this$static.dispatchNotification(notification);
        }
         else {
          notifications.add_4(notification);
          notifications.dispatch_0();
        }
      }
    }
     else {
      $doClear(this$static, this$static.delegateSize(), this$static.delegateToArray());
      this$static.dispatchNotification(this$static.createNotification(6, ($clinit_Collections() , EMPTY_LIST), null, -1, oldIsSet));
    }
  }
   else if (this$static.hasInverse()) {
    size_0 = this$static.delegateSize();
    if (size_0 > 0) {
      oldData = this$static.delegateToArray();
      $doClear(this$static, size_0, oldData);
      notifications = size_0 < 100?null:new NotificationChainImpl_0(size_0);
      for (i = 0; i < size_0; ++i) {
        object = oldData[i];
        notifications = this$static.inverseRemove(object, notifications);
      }
      !!notifications && notifications.dispatch_0();
    }
     else {
      $doClear(this$static, this$static.delegateSize(), this$static.delegateToArray());
    }
  }
   else {
    $doClear(this$static, this$static.delegateSize(), this$static.delegateToArray());
  }
}

function $setUnique_0(this$static, index_0, object){
  var notification, notifications, oldIsSet, oldObject, oldObject0;
  if (this$static.isNotificationRequired()) {
    notifications = null;
    oldIsSet = this$static.isSet_0();
    notification = this$static.createNotification(1, oldObject0 = (oldObject = this$static.delegateSet(index_0, this$static.validate(index_0, object)) , oldObject), object, index_0, oldIsSet);
    if (this$static.hasInverse() && !(this$static.useEquals() && !!oldObject0?equals_Ljava_lang_Object__Z__devirtual$(oldObject0, object):maskUndefined(oldObject0) === maskUndefined(object))) {
      !!oldObject0 && (notifications = this$static.inverseRemove(oldObject0, null));
      notifications = this$static.inverseAdd(object, notifications);
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      this$static.dispatchNotification(notification);
    }
    return oldObject0;
  }
   else {
    oldObject0 = (oldObject = this$static.delegateSet(index_0, this$static.validate(index_0, object)) , oldObject);
    if (this$static.hasInverse() && !(this$static.useEquals() && !!oldObject0?equals_Ljava_lang_Object__Z__devirtual$(oldObject0, object):maskUndefined(oldObject0) === maskUndefined(object))) {
      notifications = null;
      !!oldObject0 && (notifications = this$static.inverseRemove(oldObject0, null));
      notifications = this$static.inverseAdd(object, notifications);
      !!notifications && notifications.dispatch_0();
    }
    return oldObject0;
  }
}

defineClass(1773, 1772, $intern_144);
_.addAllUnique_0 = function addAllUnique_1(index_0, collection){
  return $addAllUnique_2(this, index_0, collection);
}
;
_.addAllUnique = function addAllUnique_2(collection){
  return this.addAllUnique_0(this.delegateSize(), collection);
}
;
_.addUnique = function addUnique_3(index_0, object){
  $addUnique_3(this, index_0, object);
}
;
_.addUnique_0 = function addUnique_4(object){
  $addUnique_4(this, object);
}
;
_.canContainNull = function canContainNull_0(){
  return !this.hasInverse();
}
;
_.clear_0 = function clear_50(){
  $clear_10(this);
}
;
_.createNotification = function createNotification(eventType, oldObject, newObject, index_0, wasSet){
  return new DelegatingNotifyingListImpl$1(this, eventType, oldObject, newObject, index_0, wasSet);
}
;
_.dispatchNotification = function dispatchNotification(notification){
  $eNotify(this.getNotifier(), notification);
}
;
_.getFeature = function getFeature(){
  return null;
}
;
_.getFeatureID_0 = function getFeatureID(){
  return -1;
}
;
_.getNotifier = function getNotifier(){
  return null;
}
;
_.hasInverse = function hasInverse(){
  return false;
}
;
_.inverseAdd = function inverseAdd(object, notifications){
  return notifications;
}
;
_.inverseRemove = function inverseRemove(object, notifications){
  return notifications;
}
;
_.isNotificationRequired = function isNotificationRequired(){
  return false;
}
;
_.isSet_0 = function isSet(){
  return !this.delegateIsEmpty();
}
;
_.remove_2 = function remove_100(index_0){
  var notification, notifications, oldIsSet, oldObject;
  if (this.isNotificationRequired()) {
    oldIsSet = this.isSet_0();
    notification = this.createNotification(4, oldObject = $remove_33(this, index_0), null, index_0, oldIsSet);
    if (this.hasInverse() && !!oldObject) {
      notifications = this.inverseRemove(oldObject, null);
      if (!notifications) {
        this.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      this.dispatchNotification(notification);
    }
    return oldObject;
  }
   else {
    oldObject = $remove_33(this, index_0);
    if (this.hasInverse() && !!oldObject) {
      notifications = this.inverseRemove(oldObject, null);
      !!notifications && notifications.dispatch_0();
    }
    return oldObject;
  }
}
;
_.setUnique = function setUnique_1(index_0, object){
  return $setUnique_0(this, index_0, object);
}
;
var Lorg_eclipse_emf_common_notify_impl_DelegatingNotifyingListImpl_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'DelegatingNotifyingListImpl', 1773);
function $add_22(this$static, newNotification){
  if (!newNotification) {
    return false;
  }
   else {
    if (this$static.merge_0(newNotification)) {
      return false;
    }
    if (!this$static.next_0) {
      if (instanceOf(newNotification, 142)) {
        this$static.next_0 = castTo(newNotification, 142);
        return true;
      }
       else {
        this$static.next_0 = new NotificationChainImpl;
        return this$static.next_0.add_4(newNotification);
      }
    }
     else {
      return this$static.next_0.add_4(newNotification);
    }
  }
}

function $dispatch(this$static){
  var notifier;
  notifier = this$static.getNotifier();
  notifier != null && this$static.eventType != -1 && castTo(notifier, 92).eNotify(this$static);
  !!this$static.next_0 && this$static.next_0.dispatch_0();
}

function $getNewBooleanValue(this$static){
  if (this$static.primitiveType != 0)
    throw toJs(new IllegalStateException);
  return neq(this$static.newSimplePrimitiveValue, 0);
}

function $getNewByteValue(this$static){
  if (this$static.primitiveType != 1)
    throw toJs(new IllegalStateException);
  return toInt_0(this$static.newSimplePrimitiveValue) << 24 >> 24;
}

function $getNewCharValue(this$static){
  if (this$static.primitiveType != 2)
    throw toJs(new IllegalStateException);
  return toInt_0(this$static.newSimplePrimitiveValue) & $intern_47;
}

function $getNewDoubleValue(this$static){
  if (this$static.primitiveType != 3)
    throw toJs(new IllegalStateException);
  return this$static.newIEEEPrimitiveValue;
}

function $getNewFloatValue(this$static){
  if (this$static.primitiveType != 4)
    throw toJs(new IllegalStateException);
  return this$static.newIEEEPrimitiveValue;
}

function $getNewIntValue(this$static){
  if (this$static.primitiveType != 5)
    throw toJs(new IllegalStateException);
  return toInt_0(this$static.newSimplePrimitiveValue);
}

function $getNewLongValue(this$static){
  if (this$static.primitiveType != 6)
    throw toJs(new IllegalStateException);
  return this$static.newSimplePrimitiveValue;
}

function $getNewShortValue(this$static){
  if (this$static.primitiveType != 7)
    throw toJs(new IllegalStateException);
  return toInt_0(this$static.newSimplePrimitiveValue) << 16 >> 16;
}

function $getNewValue(this$static){
  if (this$static.newValue == null) {
    switch (this$static.primitiveType) {
      case 0:
        this$static.newValue = $getNewBooleanValue(this$static)?($clinit_Boolean() , TRUE_0):($clinit_Boolean() , FALSE_0);
        break;
      case 1:
        this$static.newValue = valueOf_2($getNewByteValue(this$static));
        break;
      case 2:
        this$static.newValue = valueOf_3($getNewCharValue(this$static));
        break;
      case 3:
        this$static.newValue = $getNewDoubleValue(this$static);
        break;
      case 4:
        this$static.newValue = new Float($getNewFloatValue(this$static));
        break;
      case 6:
        this$static.newValue = valueOf_5($getNewLongValue(this$static));
        break;
      case 5:
        this$static.newValue = valueOf_4($getNewIntValue(this$static));
        break;
      case 7:
        this$static.newValue = valueOf_6($getNewShortValue(this$static));
    }
  }
  return this$static.newValue;
}

function $getOldBooleanValue(this$static){
  if (this$static.primitiveType != 0)
    throw toJs(new IllegalStateException);
  return neq(this$static.oldSimplePrimitiveValue, 0);
}

function $getOldByteValue(this$static){
  if (this$static.primitiveType != 1)
    throw toJs(new IllegalStateException);
  return toInt_0(this$static.oldSimplePrimitiveValue) << 24 >> 24;
}

function $getOldCharValue(this$static){
  if (this$static.primitiveType != 2)
    throw toJs(new IllegalStateException);
  return toInt_0(this$static.oldSimplePrimitiveValue) & $intern_47;
}

function $getOldDoubleValue(this$static){
  if (this$static.primitiveType != 3)
    throw toJs(new IllegalStateException);
  return this$static.oldIEEEPrimitiveValue;
}

function $getOldFloatValue(this$static){
  if (this$static.primitiveType != 4)
    throw toJs(new IllegalStateException);
  return this$static.oldIEEEPrimitiveValue;
}

function $getOldIntValue(this$static){
  if (this$static.primitiveType != 5)
    throw toJs(new IllegalStateException);
  return toInt_0(this$static.oldSimplePrimitiveValue);
}

function $getOldLongValue(this$static){
  if (this$static.primitiveType != 6)
    throw toJs(new IllegalStateException);
  return this$static.oldSimplePrimitiveValue;
}

function $getOldShortValue(this$static){
  if (this$static.primitiveType != 7)
    throw toJs(new IllegalStateException);
  return toInt_0(this$static.oldSimplePrimitiveValue) << 16 >> 16;
}

function $getOldValue(this$static){
  if (this$static.oldValue == null) {
    switch (this$static.primitiveType) {
      case 0:
        this$static.oldValue = $getOldBooleanValue(this$static)?($clinit_Boolean() , TRUE_0):($clinit_Boolean() , FALSE_0);
        break;
      case 1:
        this$static.oldValue = valueOf_2($getOldByteValue(this$static));
        break;
      case 2:
        this$static.oldValue = valueOf_3($getOldCharValue(this$static));
        break;
      case 3:
        this$static.oldValue = $getOldDoubleValue(this$static);
        break;
      case 4:
        this$static.oldValue = new Float($getOldFloatValue(this$static));
        break;
      case 6:
        this$static.oldValue = valueOf_5($getOldLongValue(this$static));
        break;
      case 5:
        this$static.oldValue = valueOf_4($getOldIntValue(this$static));
        break;
      case 7:
        this$static.oldValue = valueOf_6($getOldShortValue(this$static));
    }
  }
  return this$static.oldValue;
}

function $isTouch(this$static){
  switch (this$static.eventType) {
    case 9:
    case 8:
      {
        return true;
      }

    case 3:
    case 5:
    case 4:
    case 6:
      {
        return false;
      }

    case 7:
      {
        return castTo($getOldValue(this$static), 21).value_0 == this$static.position;
      }

    case 1:
    case 2:
      {
        if (this$static.position == -2) {
          return false;
        }
         else {
          switch (this$static.primitiveType) {
            case 0:
            case 1:
            case 2:
            case 6:
            case 5:
            case 7:
              {
                return eq(this$static.oldSimplePrimitiveValue, this$static.newSimplePrimitiveValue);
              }

            case 3:
            case 4:
              {
                return this$static.oldIEEEPrimitiveValue == this$static.newIEEEPrimitiveValue;
              }

            default:{
                return this$static.oldValue == null?this$static.newValue == null:equals_Ljava_lang_Object__Z__devirtual$(this$static.oldValue, this$static.newValue);
              }

          }
        }
      }

    default:{
        return false;
      }

  }
}

function $wasSet(this$static){
  var defaultValue;
  switch (this$static.eventType) {
    case 1:
      {
        if (this$static.isFeatureUnsettable()) {
          return this$static.position != -2;
        }
        break;
      }

    case 2:
      {
        if (this$static.isFeatureUnsettable()) {
          return this$static.position == -2;
        }
        break;
      }

    case 3:
    case 5:
    case 4:
    case 6:
    case 7:
      {
        return this$static.position > -2;
      }

    default:{
        return false;
      }

  }
  defaultValue = this$static.getFeatureDefaultValue();
  switch (this$static.primitiveType) {
    case 0:
      return defaultValue != null && checkNotNull_1(castToBoolean(defaultValue)) != neq(this$static.oldSimplePrimitiveValue, 0);
    case 1:
      return defaultValue != null && castTo(defaultValue, 196).value_0 != toInt_0(this$static.oldSimplePrimitiveValue) << 24 >> 24;
    case 2:
      return defaultValue != null && castTo(defaultValue, 161).value_0 != (toInt_0(this$static.oldSimplePrimitiveValue) & $intern_47);
    case 6:
      return defaultValue != null && neq(castTo(defaultValue, 152).value_0, this$static.oldSimplePrimitiveValue);
    case 5:
      return defaultValue != null && castTo(defaultValue, 21).value_0 != toInt_0(this$static.oldSimplePrimitiveValue);
    case 7:
      return defaultValue != null && castTo(defaultValue, 171).value_0 != toInt_0(this$static.oldSimplePrimitiveValue) << 16 >> 16;
    case 3:
      return defaultValue != null && checkNotNull_1(castToDouble(defaultValue)) != this$static.oldIEEEPrimitiveValue;
    case 4:
      return defaultValue != null && castTo(defaultValue, 128).value_0 != this$static.oldIEEEPrimitiveValue;
    default:return defaultValue == null?this$static.oldValue != null:!equals_Ljava_lang_Object__Z__devirtual$(defaultValue, this$static.oldValue);
  }
}

function NotificationImpl(eventType, oldDoubleValue, newDoubleValue){
  this.eventType = eventType;
  this.oldIEEEPrimitiveValue = oldDoubleValue;
  this.newIEEEPrimitiveValue = newDoubleValue;
  this.position = -1;
  this.primitiveType = 3;
}

function NotificationImpl_0(eventType, oldIntValue, newIntValue){
  this.eventType = eventType;
  this.oldSimplePrimitiveValue = oldIntValue;
  this.newSimplePrimitiveValue = newIntValue;
  this.position = -1;
  this.primitiveType = 5;
}

function NotificationImpl_1(eventType, oldValue, newValue, position){
  this.eventType = eventType;
  this.oldValue = oldValue;
  this.newValue = newValue;
  this.position = position;
  this.primitiveType = -1;
}

function NotificationImpl_2(eventType, oldValue, newValue, position, wasSet){
  this.eventType = eventType;
  this.oldValue = oldValue;
  this.newValue = newValue;
  this.position = position;
  this.primitiveType = -1;
  wasSet || (this.position = -2 - position - 1);
}

function NotificationImpl_3(eventType, oldBooleanValue, newBooleanValue){
  this.eventType = eventType;
  this.oldSimplePrimitiveValue = oldBooleanValue?1:0;
  this.newSimplePrimitiveValue = newBooleanValue?1:0;
  this.position = -1;
  this.primitiveType = 0;
}

defineClass(142, 1, $intern_145);
_.add_4 = function add_46(newNotification){
  return $add_22(this, newNotification);
}
;
_.dispatch_0 = function dispatch(){
  $dispatch(this);
}
;
_.getEventType = function getEventType(){
  return this.eventType;
}
;
_.getFeature = function getFeature_0(){
  return null;
}
;
_.getFeatureDefaultValue = function getFeatureDefaultValue(){
  return null;
}
;
_.getFeatureID = function getFeatureID_0(expectedClass){
  return -1;
}
;
_.getNewValue = function getNewValue(){
  return $getNewValue(this);
}
;
_.getNotifier = function getNotifier_0(){
  return null;
}
;
_.getOldValue = function getOldValue(){
  return $getOldValue(this);
}
;
_.getPosition_0 = function getPosition_2(){
  return this.position < 0?this.position < -2?-2 - this.position - 1:-1:this.position;
}
;
_.isFeatureUnsettable = function isFeatureUnsettable(){
  return false;
}
;
_.merge_0 = function merge_2(notification){
  var index_0, list, newPositions, notificationEventType, notificationNotifier, notificationPosition, oldPosition, originalPosition, originalWasSet, positions, removedValues;
  switch (this.eventType) {
    case 1:
    case 2:
      {
        notificationEventType = notification.getEventType();
        switch (notificationEventType) {
          case 1:
          case 2:
            {
              notificationNotifier = notification.getNotifier();
              if (maskUndefined(notificationNotifier) === maskUndefined(this.getNotifier()) && this.getFeatureID(null) == notification.getFeatureID(null)) {
                this.newValue = notification.getNewValue();
                notification.getEventType() == 1 && (this.eventType = 1);
                return true;
              }
            }

        }
      }

    case 4:
      {
        notificationEventType = notification.getEventType();
        switch (notificationEventType) {
          case 4:
            {
              notificationNotifier = notification.getNotifier();
              if (maskUndefined(notificationNotifier) === maskUndefined(this.getNotifier()) && this.getFeatureID(null) == notification.getFeatureID(null)) {
                originalWasSet = $wasSet(this);
                originalPosition = this.position < 0?this.position < -2?-2 - this.position - 1:-1:this.position;
                notificationPosition = notification.getPosition_0();
                this.eventType = 6;
                removedValues = new BasicEList_0(2);
                if (originalPosition <= notificationPosition) {
                  $add_21(removedValues, this.oldValue);
                  $add_21(removedValues, notification.getOldValue());
                  this.newValue = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [this.position = originalPosition, notificationPosition + 1]);
                }
                 else {
                  $add_21(removedValues, notification.getOldValue());
                  $add_21(removedValues, this.oldValue);
                  this.newValue = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [this.position = notificationPosition, originalPosition]);
                }
                this.oldValue = removedValues;
                originalWasSet || (this.position = -2 - this.position - 1);
                return true;
              }
              break;
            }

        }
        break;
      }

    case 6:
      {
        notificationEventType = notification.getEventType();
        switch (notificationEventType) {
          case 4:
            {
              notificationNotifier = notification.getNotifier();
              if (maskUndefined(notificationNotifier) === maskUndefined(this.getNotifier()) && this.getFeatureID(null) == notification.getFeatureID(null)) {
                originalWasSet = $wasSet(this);
                notificationPosition = notification.getPosition_0();
                positions = castTo(this.newValue, 40);
                newPositions = initUnidimensionalArray(I_classLit, $intern_49, 23, positions.length + 1, 15, 1);
                index_0 = 0;
                while (index_0 < positions.length) {
                  oldPosition = positions[index_0];
                  if (oldPosition <= notificationPosition) {
                    newPositions[index_0++] = oldPosition;
                    ++notificationPosition;
                  }
                   else {
                    break;
                  }
                }
                list = castTo(this.oldValue, 15);
                list.add_3(index_0, notification.getOldValue());
                newPositions[index_0] = notificationPosition;
                while (++index_0 < newPositions.length) {
                  newPositions[index_0] = positions[index_0 - 1];
                }
                this.newValue = newPositions;
                originalWasSet || (this.position = -2 - newPositions[0]);
                return true;
              }
              break;
            }

        }
        break;
      }

  }
  return false;
}
;
_.toString_0 = function toString_136(){
  var i, positions, result;
  result = new StringBuffer_1($getName(this.___clazz) + '@' + (hashCode__I__devirtual$(this) >>> 0).toString(16));
  result.string += ' (eventType: ';
  switch (this.eventType) {
    case 1:
      {
        result.string += 'SET';
        break;
      }

    case 2:
      {
        result.string += 'UNSET';
        break;
      }

    case 3:
      {
        result.string += 'ADD';
        break;
      }

    case 5:
      {
        result.string += 'ADD_MANY';
        break;
      }

    case 4:
      {
        result.string += 'REMOVE';
        break;
      }

    case 6:
      {
        result.string += 'REMOVE_MANY';
        break;
      }

    case 7:
      {
        result.string += 'MOVE';
        break;
      }

    case 8:
      {
        result.string += 'REMOVING_ADAPTER';
        break;
      }

    case 9:
      {
        result.string += 'RESOLVE';
        break;
      }

    default:{
        $append_1(result, this.eventType);
        break;
      }

  }
  $isTouch(this) && (result.string += ', touch: true' , result);
  result.string += ', position: ';
  $append_1(result, this.position < 0?this.position < -2?-2 - this.position - 1:-1:this.position);
  result.string += ', notifier: ';
  $append_2(result, this.getNotifier());
  result.string += ', feature: ';
  $append_2(result, this.getFeature());
  result.string += ', oldValue: ';
  $append_2(result, $getOldValue(this));
  result.string += ', newValue: ';
  if (this.eventType == 6 && instanceOf(this.newValue, 40)) {
    positions = castTo(this.newValue, 40);
    result.string += '[';
    for (i = 0; i < positions.length;) {
      result.string += positions[i];
      ++i < positions.length && (result.string += ', ' , result);
    }
    result.string += ']';
  }
   else {
    $append_2(result, $getNewValue(this));
  }
  result.string += ', isTouch: ';
  $append_4(result, $isTouch(this));
  result.string += ', wasSet: ';
  $append_4(result, $wasSet(this));
  result.string += ')';
  return result.string;
}
;
_.eventType = 0;
_.newIEEEPrimitiveValue = 0;
_.newSimplePrimitiveValue = 0;
_.oldIEEEPrimitiveValue = 0;
_.oldSimplePrimitiveValue = 0;
_.position = 0;
_.primitiveType = 0;
var Lorg_eclipse_emf_common_notify_impl_NotificationImpl_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'NotificationImpl', 142);
function DelegatingNotifyingListImpl$1(this$0, $anonymous0, $anonymous1, $anonymous2, $anonymous3, $anonymous4){
  this.this$01 = this$0;
  NotificationImpl_2.call(this, $anonymous0, $anonymous1, $anonymous2, $anonymous3, $anonymous4);
}

defineClass(1055, 142, $intern_145, DelegatingNotifyingListImpl$1);
_.getFeature = function getFeature_1(){
  return this.this$01.getFeature();
}
;
_.getFeatureID = function getFeatureID_1(expectedClass){
  return this.this$01.getFeatureID_0();
}
;
_.getNotifier = function getNotifier_1(){
  return this.this$01.getNotifier();
}
;
var Lorg_eclipse_emf_common_notify_impl_DelegatingNotifyingListImpl$1_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'DelegatingNotifyingListImpl/1', 1055);
function $add_23(this$static, newNotification){
  var i, notification;
  if (!newNotification) {
    return false;
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      notification = castTo(this$static.data_0[i], 352);
      if (notification.merge_0(newNotification)) {
        return false;
      }
    }
    return $add_21(this$static, newNotification);
  }
}

function NotificationChainImpl(){
}

function NotificationChainImpl_0(initialCapacity){
  BasicEList_0.call(this, initialCapacity);
}

defineClass(225, 55, $intern_141, NotificationChainImpl, NotificationChainImpl_0);
_.add_1 = function add_47(newNotification){
  return $add_23(this, castTo(newNotification, 352));
}
;
_.add_4 = function add_48(newNotification){
  return $add_23(this, newNotification);
}
;
_.dispatch_0 = function dispatch_0(){
  var i, notification, notifier;
  for (i = 0; i < this.size_0; ++i) {
    notification = castTo(this.data_0[i], 352);
    notifier = notification.getNotifier();
    notifier != null && notification.getEventType() != -1 && castTo(notifier, 92).eNotify(notification);
  }
}
;
_.newData = function newData_1(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_common_notify_Notification_2_classLit, $intern_1, 352, capacity, 0, 1);
}
;
var Lorg_eclipse_emf_common_notify_impl_NotificationChainImpl_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'NotificationChainImpl', 225);
defineClass(1335, 89, $intern_137);
_.eBasicAdapters = function eBasicAdapters_1(){
  return this.eAdapters;
}
;
_.eDeliver = function eDeliver_1(){
  return (this.eFlags & 1) != 0;
}
;
_.eFlags = 1;
var Lorg_eclipse_emf_common_notify_impl_NotifierImpl_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'NotifierImpl', 1335);
function $addAllUnique_3(this$static, index_0, collection){
  var collectionSize, i, lastIndex, notification, notifications, object, oldIsSet, value_0;
  collectionSize = collection.size_1();
  if (collectionSize == 0) {
    return false;
  }
   else {
    if (this$static.isNotificationRequired()) {
      oldIsSet = this$static.isSet_0();
      $addAllUnique(this$static, index_0, collection);
      notification = collectionSize == 1?this$static.createNotification(3, null, collection.iterator_0().next_1(), index_0, oldIsSet):this$static.createNotification(5, null, collection, index_0, oldIsSet);
      if (this$static.hasInverse()) {
        notifications = collectionSize < 100?null:new NotificationChainImpl_0(collectionSize);
        lastIndex = index_0 + collectionSize;
        for (i = index_0; i < lastIndex; ++i) {
          value_0 = this$static.data_0[i];
          notifications = this$static.inverseAdd(value_0, notifications);
          notifications = this$static.shadowAdd(value_0, notifications);
        }
        if (!notifications) {
          this$static.dispatchNotification(notification);
        }
         else {
          notifications.add_4(notification);
          notifications.dispatch_0();
        }
      }
       else {
        this$static.dispatchNotification(notification);
      }
    }
     else {
      $addAllUnique(this$static, index_0, collection);
      if (this$static.hasInverse()) {
        notifications = collectionSize < 100?null:new NotificationChainImpl_0(collectionSize);
        lastIndex = index_0 + collectionSize;
        for (i = index_0; i < lastIndex; ++i) {
          object = this$static.data_0[i];
          notifications = this$static.inverseAdd(object, notifications);
        }
        !!notifications && notifications.dispatch_0();
      }
    }
    return true;
  }
}

function $addUnique_5(this$static, index_0, object){
  var notification, notifications, oldIsSet;
  if (this$static.isNotificationRequired()) {
    oldIsSet = this$static.isSet_0();
    $addUnique(this$static, index_0, object);
    notification = this$static.createNotification(3, null, object, index_0, oldIsSet);
    if (this$static.hasInverse()) {
      notifications = this$static.inverseAdd(object, null);
      this$static.hasShadow() && (notifications = this$static.shadowAdd(object, notifications));
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      this$static.dispatchNotification(notification);
    }
  }
   else {
    $addUnique(this$static, index_0, object);
    if (this$static.hasInverse()) {
      notifications = this$static.inverseAdd(object, null);
      !!notifications && notifications.dispatch_0();
    }
  }
}

function $addUnique_6(this$static, object){
  var index_0, notification, notifications, oldIsSet;
  if (this$static.isNotificationRequired()) {
    index_0 = this$static.size_0;
    oldIsSet = this$static.isSet_0();
    $addUnique_0(this$static, object);
    notification = this$static.createNotification(3, null, object, index_0, oldIsSet);
    if (this$static.hasInverse()) {
      notifications = this$static.inverseAdd(object, null);
      this$static.hasShadow() && (notifications = this$static.shadowAdd(object, notifications));
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      this$static.dispatchNotification(notification);
    }
  }
   else {
    $addUnique_0(this$static, object);
    if (this$static.hasInverse()) {
      notifications = this$static.inverseAdd(object, null);
      !!notifications && notifications.dispatch_0();
    }
  }
}

function $basicAdd_0(this$static, object, notifications){
  var index_0, notification, oldIsSet;
  if (this$static.isNotificationRequired()) {
    index_0 = this$static.size_0;
    oldIsSet = this$static.isSet_0();
    $addUnique(this$static, index_0, object);
    notification = this$static.createNotification(3, null, object, index_0, oldIsSet);
    !notifications?(notifications = notification):notifications.add_4(notification);
  }
   else {
    $addUnique(this$static, this$static.size_0, object);
  }
  return notifications;
}

function $basicRemove_0(this$static, object, notifications){
  var index_0, notification, oldIsSet, oldObject;
  index_0 = this$static.indexOf_0(object);
  if (index_0 != -1) {
    if (this$static.isNotificationRequired()) {
      oldIsSet = this$static.isSet_0();
      oldObject = $remove_32(this$static, index_0);
      notification = this$static.createNotification(4, oldObject, null, index_0, oldIsSet);
      !notifications?(notifications = notification):notifications.add_4(notification);
    }
     else {
      $remove_32(this$static, index_0);
    }
  }
  return notifications;
}

function $clear_11(this$static){
  var collection, collectionSize, i, notification, notifications, object, oldData, oldIsSet, oldSize;
  if (this$static.isNotificationRequired()) {
    oldIsSet = this$static.isSet_0();
    if (this$static.size_0 > 0) {
      collection = new BasicEList$UnmodifiableEList(this$static.size_0, this$static.data_0);
      collectionSize = this$static.size_0;
      notifications = collectionSize < 100?null:new NotificationChainImpl_0(collectionSize);
      if (this$static.hasShadow()) {
        for (i = 0; i < this$static.size_0; ++i) {
          object = this$static.data_0[i];
          notifications = this$static.shadowRemove(object, notifications);
        }
      }
      $clear_9(this$static);
      notification = collectionSize == 1?this$static.createNotification(4, $get_16(collection, 0), null, 0, oldIsSet):this$static.createNotification(6, collection, null, -1, oldIsSet);
      if (this$static.hasInverse()) {
        for (i = new AbstractEList$NonResolvingEIterator(collection); i.cursor != i.this$01_2.size_1();) {
          notifications = this$static.inverseRemove($doNext_0(i), notifications);
        }
        if (!notifications) {
          this$static.dispatchNotification(notification);
        }
         else {
          notifications.add_4(notification);
          notifications.dispatch_0();
        }
      }
       else {
        if (!notifications) {
          this$static.dispatchNotification(notification);
        }
         else {
          notifications.add_4(notification);
          notifications.dispatch_0();
        }
      }
    }
     else {
      $clear_9(this$static);
      this$static.dispatchNotification(this$static.createNotification(6, ($clinit_Collections() , EMPTY_LIST), null, -1, oldIsSet));
    }
  }
   else if (this$static.hasInverse()) {
    if (this$static.size_0 > 0) {
      oldData = this$static.data_0;
      oldSize = this$static.size_0;
      $clear_9(this$static);
      notifications = oldSize < 100?null:new NotificationChainImpl_0(oldSize);
      for (i = 0; i < oldSize; ++i) {
        object = oldData[i];
        notifications = this$static.inverseRemove(object, notifications);
      }
      !!notifications && notifications.dispatch_0();
    }
     else {
      $clear_9(this$static);
    }
  }
   else {
    $clear_9(this$static);
  }
}

function $createNotificationChain(capacity){
  return capacity < 100?null:new NotificationChainImpl_0(capacity);
}

function $remove_34(this$static, index_0){
  var notification, notifications, oldIsSet, oldObject;
  if (this$static.isNotificationRequired()) {
    notifications = null;
    oldIsSet = this$static.isSet_0();
    this$static.hasShadow() && (notifications = this$static.shadowRemove(this$static.basicGet(index_0), null));
    notification = this$static.createNotification(4, oldObject = $remove_32(this$static, index_0), null, index_0, oldIsSet);
    if (this$static.hasInverse() && oldObject != null) {
      notifications = this$static.inverseRemove(oldObject, notifications);
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
    return oldObject;
  }
   else {
    oldObject = $remove_32(this$static, index_0);
    if (this$static.hasInverse() && oldObject != null) {
      notifications = this$static.inverseRemove(oldObject, null);
      !!notifications && notifications.dispatch_0();
    }
    return oldObject;
  }
}

function $removeAll_4(this$static, collection){
  var collectionSize, count, i, i0, i1, initialObject, j, list, listSize, notification, notifications, object, objects, oldIsSet, oldPositions, positions, repeat, result, resultList;
  oldIsSet = this$static.size_0 != 0;
  result = false;
  positions = null;
  if ($eNotificationRequired(this$static.owner)) {
    listSize = collection.size_1();
    if (listSize > 0) {
      notifications = listSize < 100?null:new NotificationChainImpl_0(listSize);
      list = new BasicEList_1(collection);
      objects = list.data_0;
      positions = initUnidimensionalArray(I_classLit, $intern_49, 23, listSize, 15, 1);
      count = 0;
      resultList = new BasicEList_0(listSize);
      for (i = 0; i < this$static.size_0; ++i) {
        initialObject = this$static.data_0[i];
        LOOP: for (repeat = 0; repeat < 2; ++repeat) {
          for (j = listSize; --j >= 0;) {
            if (initialObject != null?equals_Ljava_lang_Object__Z__devirtual$(initialObject, objects[j]):null == objects[j]) {
              if (positions.length <= count) {
                oldPositions = positions;
                positions = initUnidimensionalArray(I_classLit, $intern_49, 23, 2 * positions.length, 15, 1);
                arraycopy(oldPositions, 0, positions, 0, count);
              }
              positions[count++] = i;
              $add_21(resultList, objects[j]);
              break LOOP;
            }
          }
          if (maskUndefined(initialObject) === maskUndefined(initialObject)) {
            break;
          }
        }
      }
      objects = resultList.data_0;
      if (count > positions.length) {
        oldPositions = positions;
        positions = initUnidimensionalArray(I_classLit, $intern_49, 23, count, 15, 1);
        arraycopy(oldPositions, 0, positions, 0, count);
      }
      if (count > 0) {
        result = true;
        for (i0 = 0; i0 < count; ++i0) {
          object = objects[i0];
          notifications = $shadowRemove_2(this$static, castTo(object, 76), notifications);
        }
        for (i1 = count; --i1 >= 0;) {
          $remove_32(this$static, positions[i1]);
        }
        if (count != count) {
          for (i = count; --i >= count;) {
            $remove_32(resultList, i);
          }
          oldPositions = positions;
          positions = initUnidimensionalArray(I_classLit, $intern_49, 23, count, 15, 1);
          arraycopy(oldPositions, 0, positions, 0, count);
        }
        collection = resultList;
      }
    }
  }
   else {
    collection = $getDuplicates(this$static, collection);
    for (i = this$static.size_0; --i >= 0;) {
      if (collection.contains(this$static.data_0[i])) {
        $remove_32(this$static, i);
        result = true;
      }
    }
  }
  if (result) {
    if (positions != null) {
      collectionSize = collection.size_1();
      notification = collectionSize == 1?$createNotification(this$static, 4, collection.iterator_0().next_1(), null, positions[0], oldIsSet):$createNotification(this$static, 6, collection, positions, positions[0], oldIsSet);
      notifications = collectionSize < 100?null:new NotificationChainImpl_0(collectionSize);
      for (i = collection.iterator_0(); i.hasNext_0();) {
        object = i.next_1();
        notifications = $inverseRemove_3(this$static, castTo(object, 76), notifications);
      }
      if (!notifications) {
        $eNotify(this$static.owner, notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      notifications = $createNotificationChain(collection.size_1());
      for (i = collection.iterator_0(); i.hasNext_0();) {
        object = i.next_1();
        notifications = $inverseRemove_3(this$static, castTo(object, 76), notifications);
      }
      !!notifications && notifications.dispatch_0();
    }
    return true;
  }
   else {
    return false;
  }
}

function $setUnique_1(this$static, index_0, object){
  var notification, notifications, oldIsSet, oldObject;
  if (this$static.isNotificationRequired()) {
    notifications = null;
    oldIsSet = this$static.isSet_0();
    notification = this$static.createNotification(1, oldObject = $setUnique(this$static, index_0, object), object, index_0, oldIsSet);
    if (this$static.hasInverse() && !(this$static.useEquals() && oldObject != null?equals_Ljava_lang_Object__Z__devirtual$(oldObject, object):maskUndefined(oldObject) === maskUndefined(object))) {
      oldObject != null && (notifications = this$static.inverseRemove(oldObject, null));
      notifications = this$static.inverseAdd(object, notifications);
      this$static.hasShadow() && (notifications = this$static.shadowSet(oldObject, object, notifications));
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
     else {
      this$static.hasShadow() && (notifications = this$static.shadowSet(oldObject, object, null));
      if (!notifications) {
        this$static.dispatchNotification(notification);
      }
       else {
        notifications.add_4(notification);
        notifications.dispatch_0();
      }
    }
    return oldObject;
  }
   else {
    oldObject = $setUnique(this$static, index_0, object);
    if (this$static.hasInverse() && !(this$static.useEquals() && oldObject != null?equals_Ljava_lang_Object__Z__devirtual$(oldObject, object):maskUndefined(oldObject) === maskUndefined(object))) {
      notifications = null;
      oldObject != null && (notifications = this$static.inverseRemove(oldObject, null));
      notifications = this$static.inverseAdd(object, notifications);
      !!notifications && notifications.dispatch_0();
    }
    return oldObject;
  }
}

defineClass(1770, 55, $intern_141);
_.addAllUnique_0 = function addAllUnique_3(index_0, collection){
  return $addAllUnique_3(this, index_0, collection);
}
;
_.addAllUnique = function addAllUnique_4(collection){
  return this.addAllUnique_0(this.size_0, collection);
}
;
_.addUnique = function addUnique_5(index_0, object){
  $addUnique_5(this, index_0, object);
}
;
_.addUnique_0 = function addUnique_6(object){
  $addUnique_6(this, object);
}
;
_.canContainNull = function canContainNull_1(){
  return !this.hasInverse();
}
;
_.clear_0 = function clear_51(){
  $clear_11(this);
}
;
_.createNotification = function createNotification_0(eventType, oldObject, newObject, index_0, wasSet){
  return new NotifyingListImpl$1(this, eventType, oldObject, newObject, index_0, wasSet);
}
;
_.dispatchNotification = function dispatchNotification_0(notification){
  $eNotify(this.getNotifier(), notification);
}
;
_.getFeature = function getFeature_2(){
  return null;
}
;
_.getFeatureID_0 = function getFeatureID_2(){
  return -1;
}
;
_.getNotifier = function getNotifier_2(){
  return null;
}
;
_.hasInverse = function hasInverse_0(){
  return false;
}
;
_.hasShadow = function hasShadow(){
  return false;
}
;
_.inverseAdd = function inverseAdd_0(object, notifications){
  return notifications;
}
;
_.inverseRemove = function inverseRemove_0(object, notifications){
  return notifications;
}
;
_.isNotificationRequired = function isNotificationRequired_0(){
  return false;
}
;
_.isSet_0 = function isSet_0(){
  return this.size_0 != 0;
}
;
_.remove_2 = function remove_101(index_0){
  return $remove_34(this, index_0);
}
;
_.setUnique = function setUnique_2(index_0, object){
  return $setUnique_1(this, index_0, object);
}
;
_.shadowAdd = function shadowAdd(object, notifications){
  return notifications;
}
;
_.shadowRemove = function shadowRemove(object, notifications){
  return notifications;
}
;
_.shadowSet = function shadowSet(oldObject, newObject, notifications){
  return notifications;
}
;
var Lorg_eclipse_emf_common_notify_impl_NotifyingListImpl_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'NotifyingListImpl', 1770);
function NotifyingListImpl$1(this$0, $anonymous0, $anonymous1, $anonymous2, $anonymous3, $anonymous4){
  this.this$01 = this$0;
  NotificationImpl_2.call(this, $anonymous0, $anonymous1, $anonymous2, $anonymous3, $anonymous4);
}

defineClass(1054, 142, $intern_145, NotifyingListImpl$1);
_.getFeature = function getFeature_3(){
  return this.this$01.getFeature();
}
;
_.getFeatureID = function getFeatureID_3(expectedClass){
  return this.this$01.getFeatureID_0();
}
;
_.getNotifier = function getNotifier_3(){
  return this.this$01.getNotifier();
}
;
var Lorg_eclipse_emf_common_notify_impl_NotifyingListImpl$1_2_classLit = createForClass('org.eclipse.emf.common.notify.impl', 'NotifyingListImpl/1', 1054);
function AbstractEList$1(this$0, $anonymous0){
  this.this$01 = this$0;
  BasicEList_0.call(this, $anonymous0);
}

defineClass(902, 55, $intern_141, AbstractEList$1);
_.contains = function contains_48(object){
  if (this.size_0 > 10) {
    if (!this.set_0 || this.this$01.modCount != this.expectedModCount) {
      this.set_0 = new HashSet_1(this);
      this.expectedModCount = this.modCount;
    }
    return $contains_6(this.set_0, object);
  }
   else {
    return $contains_10(this, object);
  }
}
;
_.useEquals = function useEquals_0(){
  return true;
}
;
_.expectedModCount = 0;
var Lorg_eclipse_emf_common_util_AbstractEList$1_2_classLit = createForClass('org.eclipse.emf.common.util', 'AbstractEList/1', 902);
function AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0){
  IndexOutOfBoundsException_0.call(this, 'index=' + index_0 + ', size=' + size_0);
}

defineClass(304, 80, $intern_59, AbstractEList$BasicIndexOutOfBoundsException);
var Lorg_eclipse_emf_common_util_AbstractEList$BasicIndexOutOfBoundsException_2_classLit = createForClass('org.eclipse.emf.common.util', 'AbstractEList/BasicIndexOutOfBoundsException', 304);
function $doNext(this$static){
  var next;
  try {
    next = this$static.this$01_2.get_3(this$static.cursor);
    this$static.checkModCount();
    this$static.lastCursor = this$static.cursor++;
    return next;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      this$static.checkModCount();
      throw toJs(new NoSuchElementException);
    }
     else 
      throw toJs($e0);
  }
}

function $remove_35(this$static){
  if (this$static.lastCursor == -1) {
    throw toJs(new IllegalStateException);
  }
  this$static.checkModCount();
  try {
    this$static.this$01_2.remove_2(this$static.lastCursor);
    this$static.expectedModCount = this$static.this$01_2.modCount;
    this$static.lastCursor < this$static.cursor && --this$static.cursor;
    this$static.lastCursor = -1;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      throw toJs(new ConcurrentModificationException);
    }
     else 
      throw toJs($e0);
  }
}

function AbstractEList$EIterator(this$0){
  this.this$01_2 = this$0;
  this.expectedModCount = this.this$01_2.modCount;
}

defineClass(36, 1, $intern_4, AbstractEList$EIterator);
_.forEachRemaining = function forEachRemaining_47(consumer){
  $forEachRemaining(this, consumer);
}
;
_.checkModCount = function checkModCount(){
  if (this.this$01_2.modCount != this.expectedModCount) {
    throw toJs(new ConcurrentModificationException);
  }
}
;
_.doNext = function doNext(){
  return $doNext(this);
}
;
_.hasNext_0 = function hasNext_43(){
  return this.cursor != this.this$01_2.size_1();
}
;
_.next_1 = function next_44(){
  return this.doNext();
}
;
_.remove_0 = function remove_102(){
  $remove_35(this);
}
;
_.cursor = 0;
_.expectedModCount = 0;
_.lastCursor = -1;
var Lorg_eclipse_emf_common_util_AbstractEList$EIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'AbstractEList/EIterator', 36);
function $doAdd_0(this$static, object){
  this$static.checkModCount();
  try {
    this$static.this$01_1.add_3(this$static.cursor++, object);
    this$static.expectedModCount = this$static.this$01_1.modCount;
    this$static.lastCursor = -1;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      throw toJs(new ConcurrentModificationException);
    }
     else 
      throw toJs($e0);
  }
}

function $doSet(this$static, object){
  if (this$static.lastCursor == -1) {
    throw toJs(new IllegalStateException);
  }
  this$static.checkModCount();
  try {
    this$static.this$01_1.set_2(this$static.lastCursor, object);
    this$static.expectedModCount = this$static.this$01_1.modCount;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      throw toJs(new ConcurrentModificationException);
    }
     else 
      throw toJs($e0);
  }
}

function AbstractEList$EListIterator(this$0){
  this.this$01_1 = this$0;
  AbstractEList$EIterator.call(this, this$0);
}

function AbstractEList$EListIterator_0(this$0, index_0){
  this.this$01_1 = this$0;
  AbstractEList$EIterator.call(this, this$0);
  this.cursor = index_0;
}

defineClass(271, 36, $intern_18, AbstractEList$EListIterator, AbstractEList$EListIterator_0);
_.remove_0 = function remove_103(){
  $remove_35(this);
}
;
_.add_2 = function add_49(object){
  $doAdd_0(this, object);
}
;
_.doPrevious = function doPrevious(){
  var previous;
  try {
    previous = this.this$01_1.get_3(--this.cursor);
    this.checkModCount();
    this.lastCursor = this.cursor;
    return previous;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      this.checkModCount();
      throw toJs(new NoSuchElementException);
    }
     else 
      throw toJs($e0);
  }
}
;
_.doSet = function doSet(object){
  $doSet(this, object);
}
;
_.hasPrevious = function hasPrevious_9(){
  return this.cursor != 0;
}
;
_.nextIndex_0 = function nextIndex_10(){
  return this.cursor;
}
;
_.previous_0 = function previous_10(){
  return this.doPrevious();
}
;
_.previousIndex = function previousIndex_9(){
  return this.cursor - 1;
}
;
_.set_1 = function set_23(object){
  this.doSet(object);
}
;
var Lorg_eclipse_emf_common_util_AbstractEList$EListIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'AbstractEList/EListIterator', 271);
function $doNext_0(this$static){
  var next;
  try {
    next = this$static.this$01_0.primitiveGet(this$static.cursor);
    this$static.checkModCount();
    this$static.lastCursor = this$static.cursor++;
    return next;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      this$static.checkModCount();
      throw toJs(new NoSuchElementException);
    }
     else 
      throw toJs($e0);
  }
}

function AbstractEList$NonResolvingEIterator(this$0){
  this.this$01_0 = this$0;
  AbstractEList$EIterator.call(this, this$0);
}

defineClass(334, 36, $intern_4, AbstractEList$NonResolvingEIterator);
_.doNext = function doNext_0(){
  return $doNext_0(this);
}
;
_.remove_0 = function remove_104(){
  throw toJs(new UnsupportedOperationException);
}
;
var Lorg_eclipse_emf_common_util_AbstractEList$NonResolvingEIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'AbstractEList/NonResolvingEIterator', 334);
function AbstractEList$NonResolvingEListIterator(this$0){
  this.this$01_0 = this$0;
  AbstractEList$EListIterator.call(this, this$0);
}

function AbstractEList$NonResolvingEListIterator_0(this$0, index_0){
  this.this$01_0 = this$0;
  AbstractEList$EListIterator_0.call(this, this$0, index_0);
}

defineClass(367, 271, $intern_18, AbstractEList$NonResolvingEListIterator, AbstractEList$NonResolvingEListIterator_0);
_.add_2 = function add_50(object){
  throw toJs(new UnsupportedOperationException);
}
;
_.doNext = function doNext_1(){
  var next;
  try {
    next = this.this$01_0.primitiveGet(this.cursor);
    this.checkModCount();
    this.lastCursor = this.cursor++;
    return next;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      this.checkModCount();
      throw toJs(new NoSuchElementException);
    }
     else 
      throw toJs($e0);
  }
}
;
_.doPrevious = function doPrevious_0(){
  var previous;
  try {
    previous = this.this$01_0.primitiveGet(--this.cursor);
    this.checkModCount();
    this.lastCursor = this.cursor;
    return previous;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      this.checkModCount();
      throw toJs(new NoSuchElementException);
    }
     else 
      throw toJs($e0);
  }
}
;
_.remove_0 = function remove_105(){
  throw toJs(new UnsupportedOperationException);
}
;
_.set_1 = function set_24(object){
  throw toJs(new UnsupportedOperationException);
}
;
var Lorg_eclipse_emf_common_util_AbstractEList$NonResolvingEListIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'AbstractEList/NonResolvingEListIterator', 367);
function newInstance_10(componentType, size_0){
  var helper;
  helper = castTo($get_6(($clinit_Reflect() , HELPER_REGISTRY), componentType), 49);
  return helper?helper.newArrayInstance(size_0):initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, size_0, 5, 1);
}

function $clinit_ArrayDelegatingEList(){
  $clinit_ArrayDelegatingEList = emptyMethod;
  EMPTY_ARRAY = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}

function $assign_0(data_0, index_0, object){
  setCheck(data_0, index_0, object);
  return object;
}

function $copy_0(this$static){
  var data_0, newData;
  data_0 = castTo($getField(this$static.this$01, 4), 119);
  if (data_0 != null) {
    newData = initUnidimensionalArray(Lorg_eclipse_emf_common_notify_Adapter_2_classLit, $intern_146, 393, data_0.length, 0, 1);
    arraycopy(data_0, 0, newData, 0, data_0.length);
    return newData;
  }
   else {
    return EMPTY_ARRAY;
  }
}

function $grow_0(this$static, size_0){
  var data_0, oldData;
  oldData = castTo($getField(this$static.this$01, 4), 119);
  data_0 = initUnidimensionalArray(Lorg_eclipse_emf_common_notify_Adapter_2_classLit, $intern_146, 393, size_0, 0, 1);
  oldData != null && arraycopy(oldData, 0, data_0, 0, oldData.length);
  return data_0;
}

function $remove_36(this$static, index_0){
  var data_0, newData, oldObject, shifted, size_0;
  data_0 = castTo($getField(this$static.this$01, 4), 119);
  size_0 = data_0 == null?0:data_0.length;
  if (index_0 >= size_0)
    throw toJs(new AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0));
  oldObject = data_0[index_0];
  if (size_0 == 1) {
    newData = null;
  }
   else {
    newData = initUnidimensionalArray(Lorg_eclipse_emf_common_notify_Adapter_2_classLit, $intern_146, 393, size_0 - 1, 0, 1);
    arraycopy(data_0, 0, newData, 0, index_0);
    shifted = size_0 - index_0 - 1;
    shifted > 0 && arraycopy(data_0, index_0 + 1, newData, index_0, shifted);
  }
  $setData(this$static, newData);
  $didRemove_0(this$static, index_0, oldObject);
  return oldObject;
}

defineClass(1757, 61, $intern_147);
_.addAllUnique = function addAllUnique_5(collection){
  var data_0, data0, growth, i, i0, object, objects, oldSize, size_0;
  growth = collection.size_1();
  if (growth != 0) {
    oldSize = (data0 = castTo($getField(this.this$01, 4), 119) , data0 == null?0:data0.length);
    size_0 = oldSize + growth;
    data_0 = $grow_0(this, size_0);
    objects = collection.iterator_0();
    for (i0 = oldSize; i0 < size_0; ++i0) {
      object = objects.next_1();
      $assign_0(data_0, i0, $validate(this, object));
    }
    $setData(this, data_0);
    for (i = oldSize; i < size_0; ++i) {
      object = data_0[i];
      this.didAdd(i, object);
    }
    return true;
  }
   else {
    ++this.modCount;
    return false;
  }
}
;
_.addUnique = function addUnique_7(index_0, object){
  var data_0, oldData, size_0, validatedObject;
  oldData = castTo($getField(this.this$01, 4), 119);
  size_0 = oldData == null?0:oldData.length;
  data_0 = $grow_0(this, size_0 + 1);
  validatedObject = $validate(this, object);
  index_0 != size_0 && arraycopy(oldData, index_0, data_0, index_0 + 1, size_0 - index_0);
  setCheck(data_0, index_0, validatedObject);
  $setData(this, data_0);
  this.didAdd(index_0, object);
}
;
_.addUnique_0 = function addUnique_8(object){
  var data_0, data0, size_0;
  size_0 = (data0 = castTo($getField(this.this$01, 4), 119) , data0 == null?0:data0.length);
  data_0 = $grow_0(this, size_0 + 1);
  $assign_0(data_0, size_0, $validate(this, object));
  $setData(this, data_0);
  this.didAdd(size_0, object);
}
;
_.basicIterator = function basicIterator_0(){
  return new ArrayDelegatingEList$NonResolvingEIterator(this);
}
;
_.basicListIterator = function basicListIterator_1(){
  return new ArrayDelegatingEList$NonResolvingEListIterator(this);
}
;
_.basicListIterator_0 = function basicListIterator_2(index_0){
  var data_0, size_0;
  size_0 = (data_0 = castTo($getField(this.this$01, 4), 119) , data_0 == null?0:data_0.length);
  if (index_0 < 0 || index_0 > size_0)
    throw toJs(new AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0));
  return new ArrayDelegatingEList$NonResolvingEListIterator_0(this, index_0);
}
;
_.clear_0 = function clear_52(){
  var oldData, oldSize;
  ++this.modCount;
  oldData = castTo($getField(this.this$01, 4), 119);
  oldSize = oldData == null?0:oldData.length;
  $setData(this, null);
  $didClear(this, oldSize, oldData);
}
;
_.contains = function contains_49(object){
  var data_0, datum, datum$index, datum$max;
  data_0 = castTo($getField(this.this$01, 4), 119);
  if (data_0 != null) {
    if (object != null) {
      for (datum$index = 0 , datum$max = data_0.length; datum$index < datum$max; ++datum$index) {
        datum = data_0[datum$index];
        if (equals_Ljava_lang_Object__Z__devirtual$(object, datum)) {
          return true;
        }
      }
    }
     else {
      for (datum$index = 0 , datum$max = data_0.length; datum$index < datum$max; ++datum$index) {
        datum = data_0[datum$index];
        if (!datum) {
          return true;
        }
      }
    }
  }
  return false;
}
;
_.get_3 = function get_39(index_0){
  var data_0, size_0;
  data_0 = castTo($getField(this.this$01, 4), 119);
  size_0 = data_0 == null?0:data_0.length;
  if (index_0 >= size_0)
    throw toJs(new AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0));
  return data_0[index_0];
}
;
_.indexOf_0 = function indexOf_10(object){
  var data_0, i, size_0;
  data_0 = castTo($getField(this.this$01, 4), 119);
  if (data_0 != null) {
    if (object != null) {
      for (i = 0 , size_0 = data_0.length; i < size_0; ++i) {
        if (equals_Ljava_lang_Object__Z__devirtual$(object, data_0[i])) {
          return i;
        }
      }
    }
     else {
      for (i = 0 , size_0 = data_0.length; i < size_0; ++i) {
        if (!data_0[i]) {
          return i;
        }
      }
    }
  }
  return -1;
}
;
_.isEmpty = function isEmpty_24(){
  return castTo($getField(this.this$01, 4), 119) == null;
}
;
_.iterator_0 = function iterator_72(){
  return new ArrayDelegatingEList$EIterator(this);
}
;
_.listIterator_0 = function listIterator_17(){
  return new ArrayDelegatingEList$EListIterator(this);
}
;
_.listIterator_1 = function listIterator_18(index_0){
  var data_0, size_0;
  size_0 = (data_0 = castTo($getField(this.this$01, 4), 119) , data_0 == null?0:data_0.length);
  if (index_0 < 0 || index_0 > size_0)
    throw toJs(new AbstractEList$BasicIndexOutOfBoundsException(index_0, size_0));
  return new ArrayDelegatingEList$EListIterator_0(this, index_0);
}
;
_.primitiveGet = function primitiveGet_1(index_0){
  return castTo($getField(this.this$01, 4), 119)[index_0];
}
;
_.remove_2 = function remove_106(index_0){
  return $remove_36(this, index_0);
}
;
_.setUnique = function setUnique_3(index_0, object){
  var data_0, oldObject;
  data_0 = $copy_0(this);
  oldObject = data_0[index_0];
  $assign_0(data_0, index_0, $validate(this, object));
  $setData(this, data_0);
  return oldObject;
}
;
_.size_1 = function size_58(){
  var data_0;
  return data_0 = castTo($getField(this.this$01, 4), 119) , data_0 == null?0:data_0.length;
}
;
_.toArray = function toArray_32(){
  var data_0, result, size_0;
  data_0 = castTo($getField(this.this$01, 4), 119);
  size_0 = data_0 == null?0:data_0.length;
  result = initUnidimensionalArray(Lorg_eclipse_emf_common_notify_Adapter_2_classLit, $intern_146, 393, size_0, 0, 1);
  size_0 > 0 && arraycopy(data_0, 0, result, 0, size_0);
  return result;
}
;
_.toArray_0 = function toArray_33(array){
  var data_0, newArray, size_0;
  data_0 = castTo($getField(this.this$01, 4), 119);
  size_0 = data_0 == null?0:data_0.length;
  if (size_0 > 0) {
    if (array.length < size_0) {
      newArray = newInstance_10(getClass__Ljava_lang_Class___devirtual$(array).componentType, size_0);
      array = newArray;
    }
    arraycopy(data_0, 0, array, 0, size_0);
  }
  array.length > size_0 && setCheck(array, size_0, null);
  return array;
}
;
var EMPTY_ARRAY;
var Lorg_eclipse_emf_common_util_ArrayDelegatingEList_2_classLit = createForClass('org.eclipse.emf.common.util', 'ArrayDelegatingEList', 1757);
function ArrayDelegatingEList$EIterator(this$0){
  this.this$01 = this$0;
  AbstractEList$EIterator.call(this, this$0);
  this.expectedData = castTo($getField(this.this$01.this$01, 4), 119);
}

defineClass(965, 36, $intern_4, ArrayDelegatingEList$EIterator);
_.checkModCount = function checkModCount_0(){
  if (this.this$01.modCount != this.expectedModCount || maskUndefined(castTo($getField(this.this$01.this$01, 4), 119)) !== maskUndefined(this.expectedData)) {
    throw toJs(new ConcurrentModificationException);
  }
}
;
_.remove_0 = function remove_107(){
  $remove_35(this);
  this.expectedData = castTo($getField(this.this$01.this$01, 4), 119);
}
;
var Lorg_eclipse_emf_common_util_ArrayDelegatingEList$EIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'ArrayDelegatingEList/EIterator', 965);
function $$init_10(this$static){
  this$static.expectedData = castTo($getField(this$static.this$01.this$01, 4), 119);
}

function ArrayDelegatingEList$EListIterator(this$0){
  this.this$01 = this$0;
  AbstractEList$EListIterator.call(this, this$0);
  $$init_10(this);
}

function ArrayDelegatingEList$EListIterator_0(this$0, index_0){
  this.this$01 = this$0;
  AbstractEList$EListIterator_0.call(this, this$0, index_0);
  $$init_10(this);
}

defineClass(662, 271, $intern_18, ArrayDelegatingEList$EListIterator, ArrayDelegatingEList$EListIterator_0);
_.checkModCount = function checkModCount_1(){
  if (this.this$01.modCount != this.expectedModCount || maskUndefined(castTo($getField(this.this$01.this$01, 4), 119)) !== maskUndefined(this.expectedData)) {
    throw toJs(new ConcurrentModificationException);
  }
}
;
_.doSet = function doSet_0(object){
  $doSet(this, object);
  this.expectedData = castTo($getField(this.this$01.this$01, 4), 119);
}
;
_.remove_0 = function remove_108(){
  $remove_35(this);
  this.expectedData = castTo($getField(this.this$01.this$01, 4), 119);
}
;
var Lorg_eclipse_emf_common_util_ArrayDelegatingEList$EListIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'ArrayDelegatingEList/EListIterator', 662);
function ArrayDelegatingEList$NonResolvingEIterator(this$0){
  this.this$01 = this$0;
  AbstractEList$NonResolvingEIterator.call(this, this$0);
  this.expectedData = castTo($getField(this.this$01.this$01, 4), 119);
}

defineClass(966, 334, $intern_4, ArrayDelegatingEList$NonResolvingEIterator);
_.checkModCount = function checkModCount_2(){
  if (this.this$01.modCount != this.expectedModCount || maskUndefined(castTo($getField(this.this$01.this$01, 4), 119)) !== maskUndefined(this.expectedData)) {
    throw toJs(new ConcurrentModificationException);
  }
}
;
var Lorg_eclipse_emf_common_util_ArrayDelegatingEList$NonResolvingEIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'ArrayDelegatingEList/NonResolvingEIterator', 966);
function $$init_11(this$static){
  this$static.expectedData = castTo($getField(this$static.this$01.this$01, 4), 119);
}

function ArrayDelegatingEList$NonResolvingEListIterator(this$0){
  this.this$01 = this$0;
  AbstractEList$NonResolvingEListIterator.call(this, this$0);
  $$init_11(this);
}

function ArrayDelegatingEList$NonResolvingEListIterator_0(this$0, index_0){
  this.this$01 = this$0;
  AbstractEList$NonResolvingEListIterator_0.call(this, this$0, index_0);
  $$init_11(this);
}

defineClass(663, 367, $intern_18, ArrayDelegatingEList$NonResolvingEListIterator, ArrayDelegatingEList$NonResolvingEListIterator_0);
_.checkModCount = function checkModCount_3(){
  if (this.this$01.modCount != this.expectedModCount || maskUndefined(castTo($getField(this.this$01.this$01, 4), 119)) !== maskUndefined(this.expectedData)) {
    throw toJs(new ConcurrentModificationException);
  }
}
;
var Lorg_eclipse_emf_common_util_ArrayDelegatingEList$NonResolvingEListIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'ArrayDelegatingEList/NonResolvingEListIterator', 663);
function BasicEList$BasicIndexOutOfBoundsException(index_0, size_0){
  AbstractEList$BasicIndexOutOfBoundsException.call(this, index_0, size_0);
}

defineClass(575, 304, $intern_59, BasicEList$BasicIndexOutOfBoundsException);
var Lorg_eclipse_emf_common_util_BasicEList$BasicIndexOutOfBoundsException_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEList/BasicIndexOutOfBoundsException', 575);
function BasicEList$UnmodifiableEList(size_0, data_0){
  this.size_0 = size_0;
  this.data_0 = data_0;
}

defineClass(652, 55, $intern_141, BasicEList$UnmodifiableEList);
_.add_3 = function add_51(index_0, object){
  throw toJs(new UnsupportedOperationException);
}
;
_.add_1 = function add_52(object){
  throw toJs(new UnsupportedOperationException);
}
;
_.addAll = function addAll_15(collection){
  throw toJs(new UnsupportedOperationException);
}
;
_.clear_0 = function clear_53(){
  throw toJs(new UnsupportedOperationException);
}
;
_.grow = function grow_0(minimumCapacity){
  throw toJs(new UnsupportedOperationException);
}
;
_.iterator_0 = function iterator_73(){
  return this.basicIterator();
}
;
_.listIterator_0 = function listIterator_19(){
  return this.basicListIterator();
}
;
_.listIterator_1 = function listIterator_20(index_0){
  return this.basicListIterator_0(index_0);
}
;
_.remove_2 = function remove_109(index_0){
  throw toJs(new UnsupportedOperationException);
}
;
_.remove_1 = function remove_110(object){
  throw toJs(new UnsupportedOperationException);
}
;
_.set_2 = function set_25(index_0, object){
  throw toJs(new UnsupportedOperationException);
}
;
var Lorg_eclipse_emf_common_util_BasicEList$UnmodifiableEList_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEList/UnmodifiableEList', 652);
function $add_24(this$static, index_0, object){
  this$static.delegateEList.add_3(index_0, castTo(object, 140));
}

function $add_25(this$static, object){
  return this$static.delegateEList.add_1(castTo(object, 140));
}

function $containsKey_5(this$static, key){
  var entryIndex, hash, index_0;
  if (this$static.size_0 > 0) {
    this$static.ensureEntryDataExists();
    hash = key == null?0:hashCode__I__devirtual$(key);
    index_0 = (hash & $intern_0) % this$static.entryData.length;
    entryIndex = $entryIndexForKey(this$static, index_0, hash, key);
    return entryIndex != -1;
  }
   else {
    return false;
  }
}

function $containsValue_2(this$static, value_0){
  var eList, entries, entry, i, j, size_0;
  if (this$static.size_0 > 0) {
    this$static.ensureEntryDataExists();
    if (value_0 != null) {
      for (i = 0; i < this$static.entryData.length; ++i) {
        eList = this$static.entryData[i];
        if (eList) {
          entries = castTo(eList.data_0, 353);
          size_0 = eList.size_0;
          for (j = 0; j < size_0; ++j) {
            entry = entries[j];
            if (equals_Ljava_lang_Object__Z__devirtual$(value_0, entry.getValue())) {
              return true;
            }
          }
        }
      }
    }
     else {
      for (i = 0; i < this$static.entryData.length; ++i) {
        eList = this$static.entryData[i];
        if (eList) {
          entries = castTo(eList.data_0, 353);
          size_0 = eList.size_0;
          for (j = 0; j < size_0; ++j) {
            entry = entries[j];
            if (null == entry.getValue()) {
              return true;
            }
          }
        }
      }
    }
  }
  return false;
}

function $didClear_0(oldEntryData){
  var eList, i, j, size_0;
  if (oldEntryData != null) {
    for (i = 0; i < oldEntryData.length; ++i) {
      eList = oldEntryData[i];
      if (eList) {
        castTo(eList.data_0, 353);
        size_0 = eList.size_0;
        for (j = 0; j < size_0; ++j)
        ;
      }
    }
  }
}

function $doClear_0(this$static){
  var oldEntryData;
  if (this$static.entryData == null) {
    ++this$static.modCount;
    this$static.size_0 = 0;
    $didClear_0(null);
  }
   else {
    ++this$static.modCount;
    oldEntryData = this$static.entryData;
    this$static.entryData = null;
    this$static.size_0 = 0;
    $didClear_0(oldEntryData);
  }
}

function $doPut(this$static, entry){
  var eList, hash, index_0;
  if (this$static.entryData == null) {
    ++this$static.modCount;
    ++this$static.size_0;
  }
   else {
    hash = entry.getHash();
    $grow_1(this$static, this$static.size_0 + 1);
    index_0 = (hash & $intern_0) % this$static.entryData.length;
    eList = this$static.entryData[index_0];
    !eList && (eList = this$static.entryData[index_0] = this$static.newList());
    eList.add_1(entry);
    ++this$static.size_0;
  }
}

function $doRemove(this$static, entry){
  var hash, index_0, key;
  if (this$static.entryData == null) {
    ++this$static.modCount;
    --this$static.size_0;
  }
   else {
    key = entry.getKey();
    hash = entry.getHash();
    index_0 = (hash & $intern_0) % this$static.entryData.length;
    $removeEntry_0(this$static, index_0, $entryIndexForKey(this$static, index_0, hash, key));
  }
}

function $entryForKey(this$static, index_0, hash, key){
  var eList, entries, entry, j, size_0;
  eList = this$static.entryData[index_0];
  if (eList) {
    entries = eList.data_0;
    size_0 = eList.size_0;
    if (key != null) {
      for (j = 0; j < size_0; ++j) {
        entry = castTo(entries[j], 140);
        if (entry.getHash() == hash && equals_Ljava_lang_Object__Z__devirtual$(key, entry.getKey())) {
          return entry;
        }
      }
    }
     else {
      for (j = 0; j < size_0; ++j) {
        entry = castTo(entries[j], 140);
        if (entry.getKey() == null) {
          return entry;
        }
      }
    }
  }
  return null;
}

function $entryIndexForKey(this$static, index_0, hash, key){
  var eList, entries, entry, j, size_0;
  if (key != null) {
    eList = this$static.entryData[index_0];
    if (eList) {
      entries = eList.data_0;
      size_0 = eList.size_0;
      for (j = 0; j < size_0; ++j) {
        entry = castTo(entries[j], 140);
        if (entry.getHash() == hash && equals_Ljava_lang_Object__Z__devirtual$(key, entry.getKey())) {
          return j;
        }
      }
    }
  }
   else {
    eList = this$static.entryData[index_0];
    if (eList) {
      entries = eList.data_0;
      size_0 = eList.size_0;
      for (j = 0; j < size_0; ++j) {
        entry = castTo(entries[j], 140);
        if (entry.getKey() == null) {
          return j;
        }
      }
    }
  }
  return -1;
}

function $entrySet_2(this$static){
  !this$static.view && (this$static.view = new BasicEMap$View);
  !this$static.view.entrySet && (this$static.view.entrySet = new BasicEMap$5(this$static));
  return this$static.view.entrySet;
}

function $equals_10(this$static, object){
  return instanceOf(object, 15) && $equals_9(this$static.delegateEList, object);
}

function $get_17(this$static, key){
  var entry, hash, index_0;
  if (this$static.size_0 > 0) {
    this$static.ensureEntryDataExists();
    hash = key == null?0:hashCode__I__devirtual$(key);
    index_0 = (hash & $intern_0) % this$static.entryData.length;
    entry = $entryForKey(this$static, index_0, hash, key);
    if (entry) {
      return entry.getValue();
    }
  }
  return null;
}

function $grow_1(this$static, minimumCapacity){
  var eList, entries, entry, i, index_0, j, oldCapacity, oldEList, oldEntryData, size_0;
  ++this$static.modCount;
  oldCapacity = this$static.entryData == null?0:this$static.entryData.length;
  if (minimumCapacity > oldCapacity) {
    oldEntryData = this$static.entryData;
    this$static.entryData = initUnidimensionalArray(Lorg_eclipse_emf_common_util_BasicEList_2_classLit, $intern_148, 55, 2 * oldCapacity + 4, 0, 1);
    for (i = 0; i < oldCapacity; ++i) {
      oldEList = oldEntryData[i];
      if (oldEList) {
        entries = oldEList.data_0;
        size_0 = oldEList.size_0;
        for (j = 0; j < size_0; ++j) {
          entry = castTo(entries[j], 140);
          index_0 = $indexOf_5(this$static, entry.getHash());
          eList = this$static.entryData[index_0];
          !eList && (eList = this$static.entryData[index_0] = this$static.newList());
          eList.add_1(entry);
        }
      }
    }
    return true;
  }
   else {
    return false;
  }
}

function $hashOf(key){
  return key == null?0:hashCode__I__devirtual$(key);
}

function $indexOf_5(this$static, hash){
  return (hash & $intern_0) % this$static.entryData.length;
}

function $keySet_1(this$static){
  !this$static.view && (this$static.view = new BasicEMap$View);
  !this$static.view.keySet && (this$static.view.keySet = new BasicEMap$3(this$static));
  return this$static.view.keySet;
}

function $map_0(this$static){
  !this$static.view && (this$static.view = new BasicEMap$View);
  !this$static.view.map_0 && (this$static.view.map_0 = new BasicEMap$DelegatingMap(this$static));
  return this$static.view.map_0;
}

function $put_8(this$static, key, value_0){
  var entry, entry0, hash, index_0, result;
  this$static.ensureEntryDataExists();
  hash = key == null?0:hashCode__I__devirtual$(key);
  if (this$static.size_0 > 0) {
    index_0 = (hash & $intern_0) % this$static.entryData.length;
    entry0 = $entryForKey(this$static, index_0, hash, key);
    if (entry0) {
      result = entry0.setValue(value_0);
      return result;
    }
  }
  entry = this$static.newEntry(hash, key, value_0);
  this$static.delegateEList.add_1(entry);
  return null;
}

function $putAll_0(this$static, map_0){
  var entry, entry$iterator;
  for (entry$iterator = map_0.entrySet_0().iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 39);
    $put_8(this$static, entry.getKey(), entry.getValue());
  }
}

function $remove_37(this$static, object){
  var result;
  if (instanceOf(object, 39)) {
    return this$static.delegateEList.remove_1(object);
  }
   else {
    result = $containsKey_5(this$static, object);
    $removeKey(this$static, object);
    return result;
  }
}

function $removeEntry_0(this$static, index_0, entryIndex){
  var entry;
  ++this$static.modCount;
  --this$static.size_0;
  entry = castTo(this$static.entryData[index_0].remove_2(entryIndex), 140);
  return entry.getValue();
}

function $removeKey(this$static, key){
  var entry, hash, index_0;
  this$static.ensureEntryDataExists();
  hash = key == null?0:hashCode__I__devirtual$(key);
  index_0 = (hash & $intern_0) % this$static.entryData.length;
  entry = $entryForKey(this$static, index_0, hash, key);
  if (entry) {
    $remove_37(this$static, entry);
    return entry.getValue();
  }
   else {
    return null;
  }
}

function $set_9(this$static, index_0, object){
  return castTo(this$static.delegateEList.set_2(index_0, castTo(object, 140)), 39);
}

function $values_1(this$static){
  !this$static.view && (this$static.view = new BasicEMap$View);
  !this$static.view.values && (this$static.view.values = new BasicEMap$4(this$static));
  return this$static.view.values;
}

defineClass(661, 1, {3:1, 20:1, 13:1, 15:1, 52:1, 558:1});
_.add_3 = function add_53(index_0, object){
  $add_24(this, index_0, castTo(object, 39));
}
;
_.add_1 = function add_54(object){
  return $add_25(this, castTo(object, 39));
}
;
_.forEach_0 = function forEach_31(action){
  $forEach(this, action);
}
;
_.get_3 = function get_40(index_0){
  return castTo($get_16(this.delegateEList, index_0), 140);
}
;
_.parallelStream = function parallelStream_3(){
  return this.stream();
}
;
_.remove_2 = function remove_111(index_0){
  return castTo(this.delegateEList.remove_2(index_0), 39);
}
;
_.set_2 = function set_26(index_0, object){
  return $set_9(this, index_0, castTo(object, 39));
}
;
_.sort_0 = function sort_12(c){
  $sort_0(this, c);
}
;
_.spliterator_0 = function spliterator_31(){
  return new Spliterators$IteratorSpliterator(this, 16);
}
;
_.stream = function stream_4(){
  return new Stream$StreamSource(null, this.spliterator_0());
}
;
_.addAll = function addAll_16(collection){
  return this.delegateEList.addAll(collection);
}
;
_.clear_0 = function clear_54(){
  this.delegateEList.clear_0();
}
;
_.contains = function contains_50(object){
  return this.delegateEList.contains(object);
}
;
_.containsAll = function containsAll_13(collection){
  return $containsAll(this.delegateEList, collection);
}
;
_.ensureEntryDataExists = function ensureEntryDataExists(){
  var entry, entry$iterator, oldModCount;
  if (this.entryData == null) {
    this.entryData = initUnidimensionalArray(Lorg_eclipse_emf_common_util_BasicEList_2_classLit, $intern_148, 55, 2 * this.size_0 + 1, 0, 1);
    oldModCount = this.modCount;
    this.size_0 = 0;
    for (entry$iterator = this.delegateEList.iterator_0(); entry$iterator.cursor != entry$iterator.this$01_2.size_1();) {
      entry = castTo(entry$iterator.doNext(), 140);
      $doPut(this, entry);
    }
    this.modCount = oldModCount;
  }
}
;
_.equals_0 = function equals_181(object){
  return $equals_10(this, object);
}
;
_.hashCode_1 = function hashCode_71(){
  return $hashCode_1(this.delegateEList);
}
;
_.indexOf_0 = function indexOf_11(object){
  return this.delegateEList.indexOf_0(object);
}
;
_.initializeDelegateEList = function initializeDelegateEList(){
  this.delegateEList = new BasicEMap$1(this);
}
;
_.isEmpty = function isEmpty_25(){
  return this.size_0 == 0;
}
;
_.iterator_0 = function iterator_74(){
  return this.delegateEList.iterator_0();
}
;
_.listIterator_0 = function listIterator_21(){
  return this.delegateEList.listIterator_0();
}
;
_.listIterator_1 = function listIterator_22(index_0){
  return this.delegateEList.listIterator_1(index_0);
}
;
_.map_2 = function map_4(){
  return $map_0(this);
}
;
_.newEntry = function newEntry_0(hash, key, value_0){
  return new BasicEMap$EntryImpl(hash, key, value_0);
}
;
_.newList = function newList(){
  return new BasicEMap$2;
}
;
_.remove_1 = function remove_112(object){
  return $remove_37(this, object);
}
;
_.size_1 = function size_59(){
  return this.size_0;
}
;
_.subList = function subList_10(start_0, end){
  return new AbstractList$SubList(this.delegateEList, start_0, end);
}
;
_.toArray = function toArray_34(){
  return this.delegateEList.toArray();
}
;
_.toArray_0 = function toArray_35(array){
  return this.delegateEList.toArray_0(array);
}
;
_.toString_0 = function toString_137(){
  return $toString_21(this.delegateEList);
}
;
_.modCount = 0;
_.size_0 = 0;
var Lorg_eclipse_emf_common_util_BasicEMap_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap', 661);
function $didAdd(this$static, newObject){
  $doPut(this$static.this$01, newObject);
}

function $didRemove(this$static, oldObject){
  $doRemove(this$static.this$01, oldObject);
}

function $didSet(this$static, newObject, oldObject){
  $doRemove(this$static.this$01, oldObject);
  $doPut(this$static.this$01, newObject);
}

function BasicEMap$1(this$0){
  this.this$01 = this$0;
}

defineClass(960, 55, $intern_141, BasicEMap$1);
_.didAdd = function didAdd_0(index_0, newObject){
  $didAdd(this, castTo(newObject, 140));
}
;
_.didRemove = function didRemove_0(index_0, oldObject){
  $didRemove(this, castTo(oldObject, 140));
}
;
_.didSet = function didSet_0(index_0, newObject, oldObject){
  $didSet(this, castTo(newObject, 140), castTo(oldObject, 140));
}
;
_.didClear = function didClear_0(size_0, oldObjects){
  $doClear_0(this.this$01);
}
;
var Lorg_eclipse_emf_common_util_BasicEMap$1_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/1', 960);
function BasicEMap$2(){
}

defineClass(961, 55, $intern_141, BasicEMap$2);
_.newData = function newData_2(listCapacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_common_util_BasicEMap$EntryImpl_2_classLit, $intern_149, 577, listCapacity, 0, 1);
}
;
var Lorg_eclipse_emf_common_util_BasicEMap$2_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/2', 961);
function BasicEMap$3(this$0){
  this.this$01 = this$0;
}

defineClass(962, $intern_13, $intern_14, BasicEMap$3);
_.clear_0 = function clear_55(){
  this.this$01.delegateEList.clear_0();
}
;
_.contains = function contains_51(key){
  return $containsKey_5(this.this$01, key);
}
;
_.iterator_0 = function iterator_75(){
  return this.this$01.size_0 == 0?($clinit_ECollections() , EMPTY_ELIST.listIterator):new BasicEMap$BasicEMapKeyIterator(this.this$01);
}
;
_.remove_1 = function remove_113(key){
  var oldSize;
  oldSize = this.this$01.size_0;
  $removeKey(this.this$01, key);
  return this.this$01.size_0 != oldSize;
}
;
_.size_1 = function size_60(){
  return this.this$01.size_0;
}
;
var Lorg_eclipse_emf_common_util_BasicEMap$3_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/3', 962);
function BasicEMap$4(this$0){
  this.this$01 = this$0;
}

defineClass(963, 28, $intern_12, BasicEMap$4);
_.clear_0 = function clear_56(){
  this.this$01.delegateEList.clear_0();
}
;
_.contains = function contains_52(value_0){
  return $containsValue_2(this.this$01, value_0);
}
;
_.iterator_0 = function iterator_76(){
  return this.this$01.size_0 == 0?($clinit_ECollections() , EMPTY_ELIST.listIterator):new BasicEMap$BasicEMapValueIterator(this.this$01);
}
;
_.size_1 = function size_61(){
  return this.this$01.size_0;
}
;
var Lorg_eclipse_emf_common_util_BasicEMap$4_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/4', 963);
function $remove_38(this$static, object){
  var eList, entries, entry, hash, index_0, j, key, otherEntry, size_0;
  if (this$static.this$01.size_0 > 0 && instanceOf(object, 39)) {
    this$static.this$01.ensureEntryDataExists();
    otherEntry = castTo(object, 39);
    key = otherEntry.getKey();
    hash = key == null?0:hashCode__I__devirtual$(key);
    index_0 = $indexOf_5(this$static.this$01, hash);
    eList = this$static.this$01.entryData[index_0];
    if (eList) {
      entries = castTo(eList.data_0, 353);
      size_0 = eList.size_0;
      for (j = 0; j < size_0; ++j) {
        entry = entries[j];
        if (entry.getHash() == hash && entry.equals_0(otherEntry)) {
          $remove_38(this$static, otherEntry);
          return true;
        }
      }
    }
  }
  return false;
}

function BasicEMap$5(this$0){
  this.this$01 = this$0;
}

defineClass(964, $intern_13, $intern_14, BasicEMap$5);
_.clear_0 = function clear_57(){
  this.this$01.delegateEList.clear_0();
}
;
_.contains = function contains_53(object){
  var eList, entries, entry, hash, index_0, j, key, otherEntry, size_0;
  if (this.this$01.size_0 > 0 && instanceOf(object, 39)) {
    this.this$01.ensureEntryDataExists();
    otherEntry = castTo(object, 39);
    key = otherEntry.getKey();
    hash = key == null?0:hashCode__I__devirtual$(key);
    index_0 = $indexOf_5(this.this$01, hash);
    eList = this.this$01.entryData[index_0];
    if (eList) {
      entries = castTo(eList.data_0, 353);
      size_0 = eList.size_0;
      for (j = 0; j < size_0; ++j) {
        entry = entries[j];
        if (entry.getHash() == hash && entry.equals_0(otherEntry)) {
          return true;
        }
      }
    }
  }
  return false;
}
;
_.iterator_0 = function iterator_77(){
  return this.this$01.size_0 == 0?($clinit_ECollections() , EMPTY_ELIST.listIterator):new BasicEMap$BasicEMapIterator(this.this$01);
}
;
_.remove_1 = function remove_114(object){
  return $remove_38(this, object);
}
;
_.size_1 = function size_62(){
  return this.this$01.size_0;
}
;
var Lorg_eclipse_emf_common_util_BasicEMap$5_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/5', 964);
function $scan(this$static){
  var eList;
  this$static.this$01.ensureEntryDataExists();
  if (this$static.entryCursor != -1) {
    ++this$static.entryCursor;
    eList = this$static.this$01.entryData[this$static.cursor];
    if (this$static.entryCursor < eList.size_0) {
      return;
    }
    ++this$static.cursor;
  }
  for (; this$static.cursor < this$static.this$01.entryData.length; ++this$static.cursor) {
    eList = this$static.this$01.entryData[this$static.cursor];
    if (!!eList && eList.size_0 != 0) {
      this$static.entryCursor = 0;
      return;
    }
  }
  this$static.entryCursor = -1;
}

function BasicEMap$BasicEMapIterator(this$0){
  this.this$01 = this$0;
  this.expectedModCount = this.this$01.modCount;
  this$0.size_0 > 0 && $scan(this);
}

defineClass(578, 1, $intern_4, BasicEMap$BasicEMapIterator);
_.forEachRemaining = function forEachRemaining_48(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_44(){
  return this.entryCursor != -1;
}
;
_.next_1 = function next_45(){
  var result;
  if (this.this$01.modCount != this.expectedModCount) {
    throw toJs(new ConcurrentModificationException);
  }
  if (this.entryCursor == -1) {
    throw toJs(new NoSuchElementException);
  }
  this.lastCursor = this.cursor;
  this.lastEntryCursor = this.entryCursor;
  $scan(this);
  result = castTo(this.this$01.entryData[this.lastCursor].data_0[this.lastEntryCursor], 140);
  return this.yield_0(result);
}
;
_.remove_0 = function remove_115(){
  if (this.this$01.modCount != this.expectedModCount) {
    throw toJs(new ConcurrentModificationException);
  }
  if (this.lastEntryCursor == -1) {
    throw toJs(new IllegalStateException);
  }
  this.this$01.delegateEList.remove_1($get_16(this.this$01.entryData[this.lastCursor], this.lastEntryCursor));
  this.expectedModCount = this.this$01.modCount;
  this.lastEntryCursor = -1;
  this.cursor == this.lastCursor && this.entryCursor != -1 && --this.entryCursor;
}
;
_.yield_0 = function yield_0(entry){
  return entry;
}
;
_.cursor = 0;
_.entryCursor = -1;
_.expectedModCount = 0;
_.lastCursor = 0;
_.lastEntryCursor = 0;
var Lorg_eclipse_emf_common_util_BasicEMap$BasicEMapIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/BasicEMapIterator', 578);
function BasicEMap$BasicEMapKeyIterator(this$0){
  BasicEMap$BasicEMapIterator.call(this, this$0);
}

defineClass(958, 578, $intern_4, BasicEMap$BasicEMapKeyIterator);
_.yield_0 = function yield_1(entry){
  return entry.getKey();
}
;
var Lorg_eclipse_emf_common_util_BasicEMap$BasicEMapKeyIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/BasicEMapKeyIterator', 958);
function BasicEMap$BasicEMapValueIterator(this$0){
  BasicEMap$BasicEMapIterator.call(this, this$0);
}

defineClass(959, 578, $intern_4, BasicEMap$BasicEMapValueIterator);
_.yield_0 = function yield_2(entry){
  return entry.getValue();
}
;
var Lorg_eclipse_emf_common_util_BasicEMap$BasicEMapValueIterator_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/BasicEMapValueIterator', 959);
function $containsKey_6(this$static, key){
  return $containsKey_5(this$static.this$01, key);
}

function BasicEMap$DelegatingMap(this$0){
  this.this$01 = this$0;
}

defineClass(957, 1, $intern_2, BasicEMap$DelegatingMap);
_.forEach = function forEach_32(consumer){
  $forEach_1(this, consumer);
}
;
_.merge = function merge_3(key, value_0, remappingFunction){
  return $merge(this, key, value_0, remappingFunction);
}
;
_.clear_0 = function clear_58(){
  this.this$01.delegateEList.clear_0();
}
;
_.containsKey = function containsKey_10(key){
  return $containsKey_6(this, key);
}
;
_.containsValue = function containsValue_6(value_0){
  return $containsValue_2(this.this$01, value_0);
}
;
_.entrySet_0 = function entrySet_8(){
  return $entrySet_2(this.this$01);
}
;
_.equals_0 = function equals_182(object){
  return $equals_10(this.this$01, object);
}
;
_.get_0 = function get_41(key){
  return $get_17(this.this$01, key);
}
;
_.hashCode_1 = function hashCode_72(){
  return $hashCode_1(this.this$01.delegateEList);
}
;
_.isEmpty = function isEmpty_26(){
  return this.this$01.size_0 == 0;
}
;
_.keySet_0 = function keySet_15(){
  return $keySet_1(this.this$01);
}
;
_.put = function put_7(key, value_0){
  return $put_8(this.this$01, key, value_0);
}
;
_.remove = function remove_116(key){
  return $removeKey(this.this$01, key);
}
;
_.size_1 = function size_63(){
  return this.this$01.size_0;
}
;
_.toString_0 = function toString_138(){
  return $toString_21(this.this$01.delegateEList);
}
;
_.values_0 = function values_97(){
  return $values_1(this.this$01);
}
;
var Lorg_eclipse_emf_common_util_BasicEMap$DelegatingMap_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/DelegatingMap', 957);
function BasicEMap$EntryImpl(hash, key, value_0){
  this.hash = hash;
  this.key = key;
  this.value_0 = value_0;
}

defineClass(577, 1, {39:1, 140:1, 577:1}, BasicEMap$EntryImpl);
_.equals_0 = function equals_183(object){
  var entry;
  if (instanceOf(object, 39)) {
    entry = castTo(object, 39);
    return (this.key != null?equals_Ljava_lang_Object__Z__devirtual$(this.key, entry.getKey()):maskUndefined(this.key) === maskUndefined(entry.getKey())) && (this.value_0 != null?equals_Ljava_lang_Object__Z__devirtual$(this.value_0, entry.getValue()):maskUndefined(this.value_0) === maskUndefined(entry.getValue()));
  }
   else {
    return false;
  }
}
;
_.getHash = function getHash_0(){
  return this.hash;
}
;
_.getKey = function getKey_8(){
  return this.key;
}
;
_.getValue = function getValue_8(){
  return this.value_0;
}
;
_.hashCode_1 = function hashCode_73(){
  return this.hash ^ (this.value_0 == null?0:hashCode__I__devirtual$(this.value_0));
}
;
_.setHash = function setHash_0(hash){
  this.hash = hash;
}
;
_.setKey = function setKey_0(key){
  throw toJs(new RuntimeException);
}
;
_.setValue = function setValue_9(value_0){
  var oldValue;
  oldValue = this.value_0;
  this.value_0 = value_0;
  return oldValue;
}
;
_.toString_0 = function toString_139(){
  return this.key + '->' + this.value_0;
}
;
_.hash = 0;
var Lorg_eclipse_emf_common_util_BasicEMap$EntryImpl_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/EntryImpl', 577);
function BasicEMap$View(){
}

defineClass(504, 1, {}, BasicEMap$View);
var Lorg_eclipse_emf_common_util_BasicEMap$View_2_classLit = createForClass('org.eclipse.emf.common.util', 'BasicEMap/View', 504);
function $clinit_ECollections(){
  $clinit_ECollections = emptyMethod;
  EMPTY_ELIST = new ECollections$EmptyUnmodifiableEList;
  new ECollections$EmptyUnmodifiableEMap;
}

var EMPTY_ELIST;
function $add_26(){
  throw toJs(new UnsupportedOperationException);
}

function $add_27(){
  throw toJs(new UnsupportedOperationException);
}

function $addAll_7(){
  throw toJs(new UnsupportedOperationException);
}

function $clear_12(){
  throw toJs(new UnsupportedOperationException);
}

function $remove_39(){
  throw toJs(new UnsupportedOperationException);
}

function $remove_40(){
  throw toJs(new UnsupportedOperationException);
}

function $set_10(){
  throw toJs(new UnsupportedOperationException);
}

function ECollections$BasicEmptyUnmodifiableEList(){
  this.listIterator = new ECollections$BasicEmptyUnmodifiableEList$1;
}

defineClass(723, 1, {});
_.equals_0 = function equals_184(o){
  return $equals_2(($clinit_Collections() , EMPTY_LIST), o);
}
;
_.hashCode_1 = function hashCode_74(){
  return hashCode_45(($clinit_Collections() , EMPTY_LIST));
}
;
_.toString_0 = function toString_140(){
  return $toString_1(($clinit_Collections() , EMPTY_LIST));
}
;
var Lorg_eclipse_emf_common_util_ECollections$BasicEmptyUnmodifiableEList_2_classLit = createForClass('org.eclipse.emf.common.util', 'ECollections/BasicEmptyUnmodifiableEList', 723);
function ECollections$BasicEmptyUnmodifiableEList$1(){
}

defineClass(1245, 1, $intern_18, ECollections$BasicEmptyUnmodifiableEList$1);
_.forEachRemaining = function forEachRemaining_49(consumer){
  $forEachRemaining(this, consumer);
}
;
_.add_2 = function add_55(o){
  throw toJs(new UnsupportedOperationException);
}
;
_.hasNext_0 = function hasNext_45(){
  return false;
}
;
_.hasPrevious = function hasPrevious_10(){
  return false;
}
;
_.next_1 = function next_46(){
  throw toJs(new NoSuchElementException);
}
;
_.nextIndex_0 = function nextIndex_11(){
  return 0;
}
;
_.previous_0 = function previous_11(){
  throw toJs(new NoSuchElementException);
}
;
_.previousIndex = function previousIndex_10(){
  return -1;
}
;
_.remove_0 = function remove_117(){
  throw toJs(new UnsupportedOperationException);
}
;
_.set_1 = function set_27(o){
  throw toJs(new UnsupportedOperationException);
}
;
var Lorg_eclipse_emf_common_util_ECollections$BasicEmptyUnmodifiableEList$1_2_classLit = createForClass('org.eclipse.emf.common.util', 'ECollections/BasicEmptyUnmodifiableEList/1', 1245);
function ECollections$EmptyUnmodifiableEList(){
  ECollections$BasicEmptyUnmodifiableEList.call(this);
}

defineClass(1243, 723, {20:1, 13:1, 15:1, 52:1}, ECollections$EmptyUnmodifiableEList);
_.add_3 = function add_56(index_0, element){
  $add_26();
}
;
_.add_1 = function add_57(o){
  return $add_27();
}
;
_.addAll = function addAll_17(coll){
  return $addAll_7();
}
;
_.clear_0 = function clear_59(){
  $clear_12();
}
;
_.contains = function contains_54(o){
  return false;
}
;
_.containsAll = function containsAll_14(coll){
  return false;
}
;
_.forEach_0 = function forEach_33(action){
  $forEach(this, action);
}
;
_.get_3 = function get_42(index_0){
  return $get_9(($clinit_Collections() , EMPTY_LIST , index_0)) , null;
}
;
_.indexOf_0 = function indexOf_12(o){
  return -1;
}
;
_.isEmpty = function isEmpty_27(){
  return true;
}
;
_.iterator_0 = function iterator_78(){
  return this.listIterator;
}
;
_.listIterator_0 = function listIterator_23(){
  return this.listIterator;
}
;
_.listIterator_1 = function listIterator_24(index_0){
  return this.listIterator;
}
;
_.parallelStream = function parallelStream_4(){
  return this.stream();
}
;
_.remove_2 = function remove_118(index_0){
  return $remove_39();
}
;
_.remove_1 = function remove_119(o){
  return $remove_40();
}
;
_.set_2 = function set_28(index_0, element){
  return $set_10();
}
;
_.size_1 = function size_64(){
  return 0;
}
;
_.sort_0 = function sort_13(c){
  $sort_0(this, c);
}
;
_.spliterator_0 = function spliterator_32(){
  return new Spliterators$IteratorSpliterator(this, 16);
}
;
_.stream = function stream_5(){
  return new Stream$StreamSource(null, this.spliterator_0());
}
;
_.subList = function subList_11(fromIndex, toIndex){
  return $clinit_Collections() , new AbstractList$SubList(EMPTY_LIST, fromIndex, toIndex);
}
;
_.toArray = function toArray_36(){
  return $toArray(($clinit_Collections() , EMPTY_LIST));
}
;
_.toArray_0 = function toArray_37(a){
  return $clinit_Collections() , $toArray_0(EMPTY_LIST, a);
}
;
var Lorg_eclipse_emf_common_util_ECollections$EmptyUnmodifiableEList_2_classLit = createForClass('org.eclipse.emf.common.util', 'ECollections/EmptyUnmodifiableEList', 1243);
function ECollections$EmptyUnmodifiableEMap(){
  ECollections$BasicEmptyUnmodifiableEList.call(this);
}

defineClass(1244, 723, {20:1, 13:1, 15:1, 52:1, 558:1}, ECollections$EmptyUnmodifiableEMap);
_.add_3 = function add_58(index_0, element){
  $add_26();
}
;
_.add_1 = function add_59(o){
  return $add_27();
}
;
_.addAll = function addAll_18(coll){
  return $addAll_7();
}
;
_.clear_0 = function clear_60(){
  $clear_12();
}
;
_.contains = function contains_55(o){
  return false;
}
;
_.containsAll = function containsAll_15(coll){
  return false;
}
;
_.forEach_0 = function forEach_34(action){
  $forEach(this, action);
}
;
_.get_3 = function get_43(index_0){
  return $get_9(($clinit_Collections() , EMPTY_LIST , index_0)) , null;
}
;
_.indexOf_0 = function indexOf_13(o){
  return -1;
}
;
_.isEmpty = function isEmpty_28(){
  return true;
}
;
_.iterator_0 = function iterator_79(){
  return this.listIterator;
}
;
_.listIterator_0 = function listIterator_25(){
  return this.listIterator;
}
;
_.listIterator_1 = function listIterator_26(index_0){
  return this.listIterator;
}
;
_.parallelStream = function parallelStream_5(){
  return this.stream();
}
;
_.remove_2 = function remove_120(index_0){
  return $remove_39();
}
;
_.remove_1 = function remove_121(o){
  return $remove_40();
}
;
_.set_2 = function set_29(index_0, element){
  return $set_10();
}
;
_.size_1 = function size_65(){
  return 0;
}
;
_.sort_0 = function sort_14(c){
  $sort_0(this, c);
}
;
_.spliterator_0 = function spliterator_33(){
  return new Spliterators$IteratorSpliterator(this, 16);
}
;
_.stream = function stream_6(){
  return new Stream$StreamSource(null, this.spliterator_0());
}
;
_.subList = function subList_12(fromIndex, toIndex){
  return $clinit_Collections() , new AbstractList$SubList(EMPTY_LIST, fromIndex, toIndex);
}
;
_.toArray = function toArray_38(){
  return $toArray(($clinit_Collections() , EMPTY_LIST));
}
;
_.toArray_0 = function toArray_39(a){
  return $clinit_Collections() , $toArray_0(EMPTY_LIST, a);
}
;
_.map_2 = function map_5(){
  return $clinit_Collections() , $clinit_Collections() , EMPTY_MAP;
}
;
var Lorg_eclipse_emf_common_util_ECollections$EmptyUnmodifiableEMap_2_classLit = createForClass('org.eclipse.emf.common.util', 'ECollections/EmptyUnmodifiableEMap', 1244);
var Lorg_eclipse_emf_common_util_Enumerator_2_classLit = createForInterface('org.eclipse.emf.common.util', 'Enumerator');
function $clinit_Reflect(){
  $clinit_Reflect = emptyMethod;
  HELPER_REGISTRY = new HashMap;
}

function isInstance(class_, instance){
  $clinit_Reflect();
  var helper;
  helper = castTo($get_6(HELPER_REGISTRY, class_), 49);
  return !helper || helper.isInstance(instance);
}

function register_0(class_, helper){
  $clinit_Reflect();
  $put_1(HELPER_REGISTRY, class_, helper);
}

var HELPER_REGISTRY;
function $clinit_URI(){
  $clinit_URI = emptyMethod;
  var set_0;
  uriCache = new URI$URICache;
  NO_SEGMENTS = initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, 0, 6, 1);
  ALPHA_HI = or_0(lowBitmask_0(33, 58), lowBitmask_0(1, 26));
  ALPHA_LO = or_0(lowBitmask_0(97, 122), lowBitmask_0(65, 90));
  DIGIT_LO = lowBitmask_0(48, 57);
  ALPHANUM_HI = or_0(ALPHA_HI, 0);
  ALPHANUM_LO = or_0(ALPHA_LO, DIGIT_LO);
  HEX_HI = or_0(or_0(0, lowBitmask_0(1, 6)), lowBitmask_0(33, 38));
  HEX_LO = or_0(or_0(DIGIT_LO, lowBitmask_0(65, 70)), lowBitmask_0(97, 102));
  UNRESERVED_HI = or_0(ALPHANUM_HI, highBitmask_0("-_.!~*'()"));
  UNRESERVED_LO = or_0(ALPHANUM_LO, lowBitmask_1("-_.!~*'()"));
  highBitmask_0(';/?:@&=+$,');
  lowBitmask_1(';/?:@&=+$,');
  or_0(UNRESERVED_HI, highBitmask_0(';:@&=+$,'));
  or_0(UNRESERVED_LO, lowBitmask_1(';:@&=+$,'));
  MAJOR_SEPARATOR_HI = highBitmask_0(':/?#');
  MAJOR_SEPARATOR_LO = lowBitmask_1(':/?#');
  SEGMENT_END_HI = highBitmask_0('/?#');
  SEGMENT_END_LO = lowBitmask_1('/?#');
  set_0 = new HashSet;
  set_0.map_0.put('jar', set_0);
  set_0.map_0.put('zip', set_0);
  set_0.map_0.put('archive', set_0);
  archiveSchemes = ($clinit_Collections() , new Collections$UnmodifiableSet(set_0));
}

function $appendFragment(this$static, fragment){
  var result;
  result = new URI((this$static.hashCode_0 & 256) != 0, this$static.scheme, this$static.authority, this$static.device, (this$static.hashCode_0 & 16) != 0, this$static.segments, this$static.query, fragment);
  this$static.fragment != null || (result.cachedTrimFragment = this$static);
  return result;
}

function $segmentsEqual(this$static, uri_0){
  var i, len;
  if (this$static.segments.length != uri_0.segments.length)
    return false;
  for (i = 0 , len = this$static.segments.length; i < len; i++) {
    if (!$equals_4(this$static.segments[i], uri_0.segments[i]))
      return false;
  }
  return true;
}

function $toString_22(this$static){
  var i, len, result;
  if (this$static.cachedToString == null) {
    result = new StringBuffer;
    if (this$static.scheme != null) {
      $append_3(result, this$static.scheme);
      result.string += ':';
    }
    if ((this$static.hashCode_0 & 256) != 0) {
      if ((this$static.hashCode_0 & 256) != 0 && this$static.authority != null) {
        isArchiveScheme(this$static.scheme) || (result.string += '//' , result);
        $append_3(result, this$static.authority);
      }
      if (this$static.device != null) {
        result.string += '/';
        $append_3(result, this$static.device);
      }
      (this$static.hashCode_0 & 16) != 0 && (result.string += '/' , result);
      for (i = 0 , len = this$static.segments.length; i < len; i++) {
        i != 0 && (result.string += '/' , result);
        $append_3(result, this$static.segments[i]);
      }
      if (this$static.query != null) {
        result.string += '?';
        $append_3(result, this$static.query);
      }
    }
     else {
      $append_3(result, this$static.authority);
    }
    if (this$static.fragment != null) {
      result.string += '#';
      $append_3(result, this$static.fragment);
    }
    this$static.cachedToString = result.string;
  }
  return this$static.cachedToString;
}

function $trimFragment(this$static){
  if (this$static.fragment == null) {
    return this$static;
  }
   else 
    !this$static.cachedTrimFragment && (this$static.cachedTrimFragment = new URI((this$static.hashCode_0 & 256) != 0, this$static.scheme, this$static.authority, this$static.device, (this$static.hashCode_0 & 16) != 0, this$static.segments, this$static.query, null));
  return this$static.cachedTrimFragment;
}

function URI(hierarchical, scheme, authority, device, absolutePath, segments, query, fragment){
  var hashCode, i, len;
  hashCode = 0;
  scheme != null && (hashCode ^= getHashCode_1(scheme.toLowerCase()));
  authority != null && (hashCode ^= getHashCode_1(authority));
  device != null && (hashCode ^= getHashCode_1(device));
  query != null && (hashCode ^= getHashCode_1(query));
  fragment != null && (hashCode ^= getHashCode_1(fragment));
  for (i = 0 , len = segments.length; i < len; i++) {
    hashCode ^= getHashCode_1(segments[i]);
  }
  hierarchical?(hashCode |= 256):(hashCode &= -257);
  absolutePath?(hashCode |= 16):(hashCode &= -17);
  this.hashCode_0 = hashCode;
  this.scheme = scheme == null?null:(checkCriticalNotNull(scheme) , scheme);
  this.authority = authority;
  this.device = device;
  this.segments = segments;
  this.query = query;
  this.fragment = fragment;
}

function contains_56(s, highBitmask, lowBitmask){
  var i, len;
  for (i = 0 , len = s.length; i < len; i++) {
    if (matches(s.charCodeAt(i), highBitmask, lowBitmask))
      return true;
  }
  return false;
}

function createURIWithCache(uri_0){
  $clinit_URI();
  var base, fragment, i, result;
  i = $indexOf_1(uri_0, fromCodePoint(35));
  base = i == -1?uri_0:uri_0.substr(0, i);
  fragment = i == -1?null:uri_0.substr(i + 1, uri_0.length - (i + 1));
  result = $get_18(uriCache, base);
  if (!result) {
    result = parseIntoURI(base);
    $put_9(uriCache, base, result);
    fragment != null && (result = $appendFragment(result, fragment));
  }
   else 
    fragment != null && (result = $appendFragment(result, (checkCriticalNotNull(fragment) , fragment)));
  return result;
}

function decode(value_0){
  $clinit_URI();
  var bytes, character, expectedBytes, i, j, len, receivedBytes, result;
  if (value_0 == null)
    return null;
  i = $indexOf_1(value_0, fromCodePoint(37));
  if (i < 0) {
    return value_0;
  }
   else {
    result = new StringBuilder_1(value_0.substr(0, i));
    bytes = initUnidimensionalArray(B_classLit, $intern_140, 23, 4, 15, 1);
    receivedBytes = 0;
    expectedBytes = 0;
    for (len = value_0.length; i < len; i++) {
      if (value_0.charCodeAt(i) == 37 && value_0.length > i + 2 && matches(value_0.charCodeAt(i + 1), HEX_HI, HEX_LO) && matches(value_0.charCodeAt(i + 2), HEX_HI, HEX_LO)) {
        character = unescape_0(value_0.charCodeAt(i + 1), value_0.charCodeAt(i + 2));
        i += 2;
        if (expectedBytes > 0) {
          (character & 192) == 128?(bytes[receivedBytes++] = character << 24 >> 24):(expectedBytes = 0);
        }
         else if (character >= 128) {
          if ((character & 224) == 192) {
            bytes[receivedBytes++] = character << 24 >> 24;
            expectedBytes = 2;
          }
           else if ((character & 240) == 224) {
            bytes[receivedBytes++] = character << 24 >> 24;
            expectedBytes = 3;
          }
           else if ((character & 248) == 240) {
            bytes[receivedBytes++] = character << 24 >> 24;
            expectedBytes = 4;
          }
        }
        if (expectedBytes > 0) {
          if (receivedBytes == expectedBytes) {
            switch (receivedBytes) {
              case 2:
                {
                  $append_5(result, ((bytes[0] & 31) << 6 | bytes[1] & 63) & $intern_47);
                  break;
                }

              case 3:
                {
                  $append_5(result, ((bytes[0] & 15) << 12 | (bytes[1] & 63) << 6 | bytes[2] & 63) & $intern_47);
                  break;
                }

            }
            receivedBytes = 0;
            expectedBytes = 0;
          }
        }
         else {
          for (j = 0; j < receivedBytes; ++j) {
            $append_5(result, bytes[j] & $intern_47);
          }
          receivedBytes = 0;
          result.string += String.fromCharCode(character);
        }
      }
       else {
        for (j = 0; j < receivedBytes; ++j) {
          $append_5(result, bytes[j] & $intern_47);
        }
        receivedBytes = 0;
        $append_5(result, value_0.charCodeAt(i));
      }
    }
    return result.string;
  }
}

function equals_186(o1, o2){
  return o1 == null?o2 == null:$equals_4(o1, o2);
}

function equals_187(s1, s2){
  return s1 == null?s2 == null:$equalsIgnoreCase(s1, s2);
}

function find_0(s, i, highBitmask, lowBitmask){
  var len;
  len = s.length;
  if (i >= len)
    return len;
  for (i = i > 0?i:0; i < len; i++) {
    if (matches(s.charCodeAt(i), highBitmask, lowBitmask))
      break;
  }
  return i;
}

function firstInvalidSegment(value_0){
  var i, len;
  if (value_0 == null)
    return null;
  for (i = 0 , len = value_0.length; i < len; i++) {
    if (!validSegment(value_0[i]))
      return value_0[i];
  }
  return null;
}

function highBitmask_0(chars){
  var c, i, len, result;
  result = 0;
  for (i = 0 , len = chars.length; i < len; i++) {
    c = chars.charCodeAt(i);
    c >= 64 && c < 128 && (result = or_0(result, shl_0(1, c - 64)));
  }
  return result;
}

function isArchiveScheme(value_0){
  return value_0 != null && $contains_3(archiveSchemes, value_0.toLowerCase());
}

function lowBitmask_0(from, to){
  var c, result;
  result = 0;
  if (from < 64 && from <= to) {
    to = to < 64?to:63;
    for (c = from; c <= to; c++) {
      result = or_0(result, shl_0(1, c));
    }
  }
  return result;
}

function lowBitmask_1(chars){
  var c, i, len, result;
  result = 0;
  for (i = 0 , len = chars.length; i < len; i++) {
    c = chars.charCodeAt(i);
    c < 64 && (result = or_0(result, shl_0(1, c)));
  }
  return result;
}

function matches(c, highBitmask, lowBitmask){
  if (c >= 128)
    return false;
  return c < 64?neq(and_0(shl_0(1, c), lowBitmask), 0):neq(and_0(shl_0(1, c - 64), highBitmask), 0);
}

function parseIntoURI(uri_0){
  var absolutePath, archiveScheme, authority, device, fragment, hierarchical, i, j, query, s, scheme, segmentList, segments;
  hierarchical = true;
  scheme = null;
  authority = null;
  device = null;
  absolutePath = false;
  segments = NO_SEGMENTS;
  query = null;
  fragment = null;
  i = 0;
  j = find_0(uri_0, 0, MAJOR_SEPARATOR_HI, MAJOR_SEPARATOR_LO);
  if (j < uri_0.length && uri_0.charCodeAt(j) == 58) {
    scheme = uri_0.substr(0, j);
    i = j + 1;
  }
  archiveScheme = scheme != null && $contains_3(archiveSchemes, scheme.toLowerCase());
  if (archiveScheme) {
    j = uri_0.lastIndexOf('!/');
    if (j == -1) {
      throw toJs(new IllegalArgumentException_0('no archive separator'));
    }
    hierarchical = true;
    authority = $substring_1(uri_0, i, ++j);
    i = j;
  }
   else if (i >= 0 && $equals_4(uri_0.substr(i, '//'.length), '//')) {
    i += 2;
    j = find_0(uri_0, i, SEGMENT_END_HI, SEGMENT_END_LO);
    authority = uri_0.substr(i, j - i);
    i = j;
  }
   else if (scheme != null && (i == uri_0.length || uri_0.charCodeAt(i) != 47)) {
    hierarchical = false;
    j = $indexOf_2(uri_0, fromCodePoint(35), i);
    j == -1 && (j = uri_0.length);
    authority = uri_0.substr(i, j - i);
    i = j;
  }
  if (!archiveScheme && i < uri_0.length && uri_0.charCodeAt(i) == 47) {
    j = find_0(uri_0, i + 1, SEGMENT_END_HI, SEGMENT_END_LO);
    s = uri_0.substr(i + 1, j - (i + 1));
    if (s.length > 0 && $charAt(s, s.length - 1) == 58) {
      device = s;
      i = j;
    }
  }
  if (i < uri_0.length && uri_0.charCodeAt(i) == 47) {
    ++i;
    absolutePath = true;
  }
  if (i < uri_0.length && uri_0.charCodeAt(i) != 63 && uri_0.charCodeAt(i) != 35) {
    segmentList = new ArrayList;
    while (i < uri_0.length && uri_0.charCodeAt(i) != 63 && uri_0.charCodeAt(i) != 35) {
      j = find_0(uri_0, i, SEGMENT_END_HI, SEGMENT_END_LO);
      $add_4(segmentList, uri_0.substr(i, j - i));
      i = j;
      j < uri_0.length && uri_0.charCodeAt(j) == 47 && (segmentsRemain(uri_0, ++i) || (segmentList.array[segmentList.array.length] = '' , true));
    }
    segments = initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, segmentList.array.length, 6, 1);
    $toArray_2(segmentList, segments);
  }
  if (i < uri_0.length && uri_0.charCodeAt(i) == 63) {
    j = $indexOf_0(uri_0, 35, ++i);
    j == -1 && (j = uri_0.length);
    query = uri_0.substr(i, j - i);
    i = j;
  }
  i < uri_0.length && (fragment = $substring_0(uri_0, ++i));
  validateURI(hierarchical, scheme, authority, device, segments, query);
  return new URI(hierarchical, scheme, authority, device, absolutePath, segments, query, fragment);
}

function segmentsRemain(uri_0, i){
  return i < uri_0.length && uri_0.charCodeAt(i) != 63 && uri_0.charCodeAt(i) != 35;
}

function unescape_0(highHexDigit, lowHexDigit){
  return (valueOf_101(highHexDigit) << 4 | valueOf_101(lowHexDigit)) & $intern_47;
}

function validArchiveAuthority(value_0){
  var archiveURI;
  if (value_0 != null && value_0.length > 0 && $charAt(value_0, value_0.length - 1) == 33) {
    try {
      archiveURI = createURIWithCache($substring_1(value_0, 0, value_0.length - 1));
      return archiveURI.fragment == null;
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (!instanceOf($e0, 30))
        throw toJs($e0);
    }
  }
  return false;
}

function validDevice(value_0){
  var len;
  if (value_0 == null)
    return true;
  len = value_0.length;
  return len > 0 && value_0.charCodeAt(len - 1) == 58 && !contains_56(value_0, SEGMENT_END_HI, SEGMENT_END_LO);
}

function validSegment(value_0){
  return value_0 != null && !contains_56(value_0, SEGMENT_END_HI, SEGMENT_END_LO);
}

function validSegments(value_0){
  var i, len;
  if (value_0 == null)
    return false;
  for (i = 0 , len = value_0.length; i < len; i++) {
    if (!validSegment(value_0[i]))
      return false;
  }
  return true;
}

function validateURI(hierarchical, scheme, authority, device, segments, query){
  var s;
  if (!(scheme == null || !contains_56(scheme, MAJOR_SEPARATOR_HI, MAJOR_SEPARATOR_LO))) {
    throw toJs(new IllegalArgumentException_0('invalid scheme: ' + scheme));
  }
  if (!hierarchical && !(authority != null && $indexOf_1(authority, fromCodePoint(35)) == -1 && authority.length > 0 && authority.charCodeAt(0) != 47)) {
    throw toJs(new IllegalArgumentException_0('invalid opaquePart: ' + authority));
  }
  if (hierarchical && !(scheme != null && $contains_3(archiveSchemes, scheme.toLowerCase())) && !(authority == null || !contains_56(authority, SEGMENT_END_HI, SEGMENT_END_LO))) {
    throw toJs(new IllegalArgumentException_0('invalid authority: ' + authority));
  }
  if (hierarchical && scheme != null && $contains_3(archiveSchemes, scheme.toLowerCase()) && !validArchiveAuthority(authority)) {
    throw toJs(new IllegalArgumentException_0('invalid authority: ' + authority));
  }
  if (!validDevice(device)) {
    throw toJs(new IllegalArgumentException_0('invalid device: ' + device));
  }
  if (!validSegments(segments)) {
    s = segments == null?'invalid segments: null':'invalid segment: ' + firstInvalidSegment(segments);
    throw toJs(new IllegalArgumentException_0(s));
  }
  if (!(query == null || $indexOf_1(query, fromCodePoint(35)) == -1)) {
    throw toJs(new IllegalArgumentException_0('invalid query: ' + query));
  }
}

function valueOf_101(hexDigit){
  if (hexDigit >= 65 && hexDigit <= 70) {
    return hexDigit - 65 + 10;
  }
  if (hexDigit >= 97 && hexDigit <= 102) {
    return hexDigit - 97 + 10;
  }
  if (hexDigit >= 48 && hexDigit <= 57) {
    return hexDigit - 48;
  }
  return 0;
}

defineClass(273, 1, {273:1}, URI);
_.equals_0 = function equals_185(object){
  var uri_0;
  if (this === object)
    return true;
  if (!instanceOf(object, 273))
    return false;
  uri_0 = castTo(object, 273);
  return this.hashCode_0 == uri_0.hashCode_0 && equals_187(this.scheme, uri_0.scheme) && equals_186(this.authority, (this.hashCode_0 & 256) != 0?(uri_0.hashCode_0 & 256) != 0?uri_0.authority:null:(uri_0.hashCode_0 & 256) != 0?null:uri_0.authority) && equals_186(this.device, uri_0.device) && equals_186(this.query, uri_0.query) && equals_186(this.fragment, uri_0.fragment) && $segmentsEqual(this, uri_0);
}
;
_.hashCode_1 = function hashCode_75(){
  return this.hashCode_0;
}
;
_.toString_0 = function toString_141(){
  return $toString_22(this);
}
;
_.hashCode_0 = 0;
var ALPHANUM_HI = 0, ALPHANUM_LO = 0, ALPHA_HI = 0, ALPHA_LO = 0, DIGIT_LO = 0, HEX_HI = 0, HEX_LO = 0, MAJOR_SEPARATOR_HI = 0, MAJOR_SEPARATOR_LO = 0, NO_SEGMENTS, SEGMENT_END_HI = 0, SEGMENT_END_LO = 0, UNRESERVED_HI = 0, UNRESERVED_LO = 0, archiveSchemes, uriCache;
var Lorg_eclipse_emf_common_util_URI_2_classLit = createForClass('org.eclipse.emf.common.util', 'URI', 273);
function $get_18(this$static, key){
  return castTo(key == null?getEntryValueOrNull($getEntry(this$static.hashCodeMap, null)):$get_11(this$static.stringMap, key), 273);
}

function $put_9(this$static, key, value_0){
  return castTo(key == null?$put_4(this$static.hashCodeMap, null, value_0):$put_5(this$static.stringMap, key, value_0), 273);
}

function URI$URICache(){
  HashMap.call(this);
}

defineClass(1006, 41, $intern_78, URI$URICache);
_.put = function put_8(key, value_0){
  return castTo($putStringValue(this, castToString(key), castTo(value_0, 273)), 273);
}
;
var Lorg_eclipse_emf_common_util_URI$URICache_2_classLit = createForClass('org.eclipse.emf.common.util', 'URI/URICache', 1006);
function UniqueEList(){
}

function UniqueEList_0(collection){
  BasicEList_0.call(this, collection.size_1());
  $addAll_6(this, collection);
}

defineClass(467, 55, $intern_141, UniqueEList, UniqueEList_0);
_.isUnique = function isUnique_1(){
  return true;
}
;
var Lorg_eclipse_emf_common_util_UniqueEList_2_classLit = createForClass('org.eclipse.emf.common.util', 'UniqueEList', 467);
function WrappedException(exception){
  $$init_0(this);
  this.detailMessage = !exception?null:$toString_3(exception, exception.getMessage());
  this.cause = exception;
  $fillInStackTrace(this);
  this.initializeBackingError();
}

defineClass(549, 54, $intern_44, WrappedException);
var Lorg_eclipse_emf_common_util_WrappedException_2_classLit = createForClass('org.eclipse.emf.common.util', 'WrappedException', 549);
var Lorg_eclipse_emf_ecore_EAnnotation_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EAnnotation');
var Lorg_eclipse_emf_ecore_ETypedElement_2_classLit = createForInterface('org.eclipse.emf.ecore', 'ETypedElement');
var Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EStructuralFeature');
var Lorg_eclipse_emf_ecore_EAttribute_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EAttribute');
var Lorg_eclipse_emf_ecore_EClassifier_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EClassifier');
var Lorg_eclipse_emf_ecore_EClass_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EClass');
var Lorg_eclipse_emf_ecore_EDataType_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EDataType');
function $clinit_EDataType$Internal$ConversionDelegate$Factory$Registry(){
  $clinit_EDataType$Internal$ConversionDelegate$Factory$Registry = emptyMethod;
  INSTANCE_5 = new EDataType$Internal$ConversionDelegate$Factory$Registry$Impl;
}

var INSTANCE_5;
function $getFactory(this$static, uri_0){
  var factory;
  return factory = uri_0 != null?$getStringValue(this$static, uri_0):getEntryValueOrNull($getEntry(this$static.hashCodeMap, null)) , throwClassCastExceptionUnlessNull(factory);
}

function EDataType$Internal$ConversionDelegate$Factory$Registry$Impl(){
  HashMap.call(this);
}

defineClass(1084, 41, $intern_78, EDataType$Internal$ConversionDelegate$Factory$Registry$Impl);
_.get_0 = function get_44(key){
  return instanceOfString(key)?$getStringValue(this, key):getEntryValueOrNull($getEntry(this.hashCodeMap, key));
}
;
var Lorg_eclipse_emf_ecore_EDataType$Internal$ConversionDelegate$Factory$Registry$Impl_2_classLit = createForClass('org.eclipse.emf.ecore', 'EDataType/Internal/ConversionDelegate/Factory/Registry/Impl', 1084);
var Lorg_eclipse_emf_ecore_EEnum_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EEnum');
var Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EEnumLiteral');
var Lorg_eclipse_emf_ecore_EGenericType_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EGenericType');
var Lorg_eclipse_emf_ecore_EOperation_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EOperation');
function $clinit_EPackage$Registry(){
  $clinit_EPackage$Registry = emptyMethod;
  INSTANCE_6 = new EPackageRegistryImpl;
}

var INSTANCE_6;
var Lorg_eclipse_emf_ecore_EParameter_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EParameter');
var Lorg_eclipse_emf_ecore_EReference_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EReference');
function EStructuralFeature$Internal$DynamicValueHolder$1(){
}

defineClass(956, 1, {}, EStructuralFeature$Internal$DynamicValueHolder$1);
_.toString_0 = function toString_142(){
  return 'NIL';
}
;
var Lorg_eclipse_emf_ecore_EStructuralFeature$Internal$DynamicValueHolder$1_2_classLit = createForClass('org.eclipse.emf.ecore', 'EStructuralFeature/Internal/DynamicValueHolder/1', 956);
function $clinit_EStructuralFeature$Internal$SettingDelegate$Factory$Registry(){
  $clinit_EStructuralFeature$Internal$SettingDelegate$Factory$Registry = emptyMethod;
  INSTANCE_7 = new EStructuralFeature$Internal$SettingDelegate$Factory$Registry$Impl;
}

var INSTANCE_7;
function $getFactory_0(this$static, uri_0){
  var factory;
  return factory = uri_0 != null?$getStringValue(this$static, uri_0):getEntryValueOrNull($getEntry(this$static.hashCodeMap, null)) , throwClassCastExceptionUnlessNull(factory);
}

function EStructuralFeature$Internal$SettingDelegate$Factory$Registry$Impl(){
  HashMap.call(this);
}

defineClass(955, 41, $intern_78, EStructuralFeature$Internal$SettingDelegate$Factory$Registry$Impl);
_.get_0 = function get_45(key){
  return instanceOfString(key)?$getStringValue(this, key):getEntryValueOrNull($getEntry(this.hashCodeMap, key));
}
;
var Lorg_eclipse_emf_ecore_EStructuralFeature$Internal$SettingDelegate$Factory$Registry$Impl_2_classLit = createForClass('org.eclipse.emf.ecore', 'EStructuralFeature/Internal/SettingDelegate/Factory/Registry/Impl', 955);
var Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit = createForInterface('org.eclipse.emf.ecore', 'ETypeParameter');
var Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit = createForInterface('org.eclipse.emf.ecore', 'EValidator/PatternMatcher');
function $clinit_EValidator$Registry(){
  $clinit_EValidator$Registry = emptyMethod;
  INSTANCE_8 = new EValidatorRegistryImpl;
}

var INSTANCE_8;
function $clinit_EcoreFactory(){
  $clinit_EcoreFactory = emptyMethod;
  eINSTANCE_1 = init_3();
}

var eINSTANCE_1;
function $clinit_EcorePackage(){
  $clinit_EcorePackage = emptyMethod;
  eINSTANCE_2 = init_4();
  !!($clinit_EcorePackage$Literals() , EATTRIBUTE) && internalBootstrap();
}

var eINSTANCE_2;
function $clinit_EcorePackage$Literals(){
  $clinit_EcorePackage$Literals = emptyMethod;
  EATTRIBUTE = ($clinit_EcorePackage() , eINSTANCE_2).eAttributeEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eAttributeEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eAttributeEClass), 1), 17);
  EANNOTATION = eINSTANCE_2.eAnnotationEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eAnnotationEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eAnnotationEClass), 1), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eAnnotationEClass), 2), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eAnnotationEClass), 3), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eAnnotationEClass), 4), 17);
  ECLASS = eINSTANCE_2.eClassEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 2), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 3), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 4), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 5), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 6), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 7), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 8), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 9), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 10), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 11), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 12), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 13), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 14), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 15), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 0), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 1), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 2), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 3), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 4), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 5), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 6), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 7), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 8), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassEClass), 9), 53);
  ECLASSIFIER = eINSTANCE_2.eClassifierEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassifierEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassifierEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassifierEClass), 2), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassifierEClass), 3), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassifierEClass), 4), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassifierEClass), 5), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassifierEClass), 0), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eClassifierEClass), 1), 53);
  EDATA_TYPE = eINSTANCE_2.eDataTypeEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eDataTypeEClass), 0), 29);
  EENUM = eINSTANCE_2.eEnumEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eEnumEClass), 0), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.eEnumEClass), 0), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eEnumEClass), 1), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eEnumEClass), 2), 53);
  EENUM_LITERAL = eINSTANCE_2.eEnumLiteralEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eEnumLiteralEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eEnumLiteralEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eEnumLiteralEClass), 2), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eEnumLiteralEClass), 3), 17);
  EFACTORY = eINSTANCE_2.eFactoryEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eFactoryEClass), 0), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.eFactoryEClass), 0), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eFactoryEClass), 1), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eFactoryEClass), 2), 53);
  EMODEL_ELEMENT = eINSTANCE_2.eModelElementEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eModelElementEClass), 0), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.eModelElementEClass), 0), 53);
  ENAMED_ELEMENT = eINSTANCE_2.eNamedElementEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eNamedElementEClass), 0), 29);
  EOBJECT = eINSTANCE_2.eObjectEClass;
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 0), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 1), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 2), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 3), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 4), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 5), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 6), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 7), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 8), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 9), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 10), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 11), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 12), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 13), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eObjectEClass), 14), 53);
  EOPERATION = eINSTANCE_2.eOperationEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eOperationEClass), 0), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eOperationEClass), 2), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eOperationEClass), 3), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eOperationEClass), 4), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.eOperationEClass), 0), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eOperationEClass), 1), 53);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eOperationEClass), 1), 17);
  EPACKAGE = eINSTANCE_2.ePackageEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.ePackageEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.ePackageEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.ePackageEClass), 2), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.ePackageEClass), 3), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.ePackageEClass), 4), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.ePackageEClass), 5), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.ePackageEClass), 0), 53);
  EPARAMETER = eINSTANCE_2.eParameterEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eParameterEClass), 0), 17);
  EREFERENCE = eINSTANCE_2.eReferenceEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eReferenceEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eReferenceEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eReferenceEClass), 2), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eReferenceEClass), 3), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eReferenceEClass), 4), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eReferenceEClass), 5), 17);
  ESTRUCTURAL_FEATURE = eINSTANCE_2.eStructuralFeatureEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStructuralFeatureEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStructuralFeatureEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStructuralFeatureEClass), 2), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStructuralFeatureEClass), 3), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStructuralFeatureEClass), 4), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStructuralFeatureEClass), 5), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStructuralFeatureEClass), 6), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStructuralFeatureEClass), 7), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.eStructuralFeatureEClass), 0), 53);
  castTo($get_16($getEOperations(eINSTANCE_2.eStructuralFeatureEClass), 1), 53);
  ETYPED_ELEMENT = eINSTANCE_2.eTypedElementEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypedElementEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypedElementEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypedElementEClass), 2), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypedElementEClass), 3), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypedElementEClass), 4), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypedElementEClass), 5), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypedElementEClass), 6), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypedElementEClass), 7), 17);
  ESTRING_TO_STRING_MAP_ENTRY = eINSTANCE_2.eStringToStringMapEntryEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStringToStringMapEntryEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eStringToStringMapEntryEClass), 1), 29);
  EGENERIC_TYPE = eINSTANCE_2.eGenericTypeEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eGenericTypeEClass), 0), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eGenericTypeEClass), 1), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eGenericTypeEClass), 2), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eGenericTypeEClass), 3), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eGenericTypeEClass), 4), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eGenericTypeEClass), 5), 17);
  castTo($get_16($getEOperations(eINSTANCE_2.eGenericTypeEClass), 0), 53);
  ETYPE_PARAMETER = eINSTANCE_2.eTypeParameterEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eTypeParameterEClass), 0), 17);
  EJAVA_OBJECT = eINSTANCE_2.eJavaObjectEDataType;
}

var EANNOTATION, EATTRIBUTE, ECLASS, ECLASSIFIER, EDATA_TYPE, EENUM, EENUM_LITERAL, EFACTORY, EGENERIC_TYPE, EJAVA_OBJECT, EMODEL_ELEMENT, ENAMED_ELEMENT, EOBJECT, EOPERATION, EPACKAGE, EPARAMETER, EREFERENCE, ESTRING_TO_STRING_MAP_ENTRY, ESTRUCTURAL_FEATURE, ETYPED_ELEMENT, ETYPE_PARAMETER;
var Lorg_eclipse_emf_ecore_util_FeatureMap$Entry_2_classLit = createForInterface('org.eclipse.emf.ecore.util', 'FeatureMap/Entry');
function BasicEObjectImpl$1(val$eAttribute, val$value){
  this.val$eAttribute1 = val$eAttribute;
  this.val$value2 = val$value;
}

defineClass(503, 1, {76:1}, BasicEObjectImpl$1);
_.getEStructuralFeature = function getEStructuralFeature(){
  return this.val$eAttribute1;
}
;
_.getValue = function getValue_9(){
  return this.val$value2;
}
;
var Lorg_eclipse_emf_ecore_impl_BasicEObjectImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'BasicEObjectImpl/1', 503);
function $clinit_BasicEObjectImpl$EPropertiesHolderBaseImpl(){
  $clinit_BasicEObjectImpl$EPropertiesHolderBaseImpl = emptyMethod;
  NO_SETTINGS = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}

defineClass(1758, 1, {106:1});
_.allocateSettings = function allocateSettings(dynamicFeatureCount){
  this.eSettings = dynamicFeatureCount == 0?NO_SETTINGS:initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, dynamicFeatureCount, 5, 1);
}
;
_.dynamicGet = function dynamicGet_0(dynamicFeatureID){
  return this.eSettings[dynamicFeatureID];
}
;
_.dynamicSet = function dynamicSet_0(dynamicFeatureID, value_0){
  this.eSettings[dynamicFeatureID] = value_0;
}
;
_.dynamicUnset = function dynamicUnset_0(dynamicFeatureID){
  this.eSettings[dynamicFeatureID] = null;
}
;
_.getEClass = function getEClass(){
  return this.eClass;
}
;
_.getEContents = function getEContents(){
  throw toJs(new UnsupportedOperationException);
}
;
_.getEProxyURI = function getEProxyURI(){
  throw toJs(new UnsupportedOperationException);
}
;
_.getEResource = function getEResource(){
  return this.eResource;
}
;
_.hasSettings = function hasSettings(){
  return this.eSettings != null;
}
;
_.setEClass = function setEClass(eClass){
  this.eClass = eClass;
}
;
_.setEContents = function setEContents(eContents){
  throw toJs(new UnsupportedOperationException);
}
;
_.setEResource = function setEResource(eResource){
  this.eResource = eResource;
}
;
var NO_SETTINGS;
var Lorg_eclipse_emf_ecore_impl_BasicEObjectImpl$EPropertiesHolderBaseImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'BasicEObjectImpl/EPropertiesHolderBaseImpl', 1758);
function BasicEObjectImpl$EPropertiesHolderImpl(){
  $clinit_BasicEObjectImpl$EPropertiesHolderBaseImpl();
}

defineClass(209, 1758, {106:1}, BasicEObjectImpl$EPropertiesHolderImpl);
_.getEContents = function getEContents_0(){
  return this.eContents;
}
;
_.getEProxyURI = function getEProxyURI_0(){
  return this.eProxyURI;
}
;
_.setEContents = function setEContents_0(eContents){
  this.eContents = eContents;
}
;
var Lorg_eclipse_emf_ecore_impl_BasicEObjectImpl$EPropertiesHolderImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'BasicEObjectImpl/EPropertiesHolderImpl', 209);
function EObjectImpl(){
}

defineClass(479, 93, $intern_139, EObjectImpl);
_.eBasicAdapters = function eBasicAdapters_2(){
  return this.eAdapters;
}
;
_.eBasicProperties = function eBasicProperties_1(){
  return this.eProperties;
}
;
_.eBasicSetContainer = function eBasicSetContainer_4(newContainer, newContainerFeatureID){
  this.eContainer = newContainer;
  this.eContainerFeatureID = newContainerFeatureID;
}
;
_.eClass_0 = function eClass_2(){
  return (this.eFlags & 2) == 0?this.eStaticClass():this.eProperties_0().getEClass();
}
;
_.eContainerFeatureID_0 = function eContainerFeatureID_2(){
  return this.eContainerFeatureID;
}
;
_.eDeliver = function eDeliver_2(){
  return (this.eFlags & 1) != 0;
}
;
_.eInternalContainer = function eInternalContainer_3(){
  return this.eContainer;
}
;
_.eIsProxy = function eIsProxy_1(){
  return (this.eFlags & 4) != 0;
}
;
_.eProperties_0 = function eProperties_2(){
  return !this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties;
}
;
_.eSetClass = function eSetClass_1(eClass){
  this.eProperties_0().setEClass(eClass);
  eClass?(this.eFlags |= 2):(this.eFlags &= -3);
}
;
_.eStaticClass = function eStaticClass_15(){
  return ($clinit_EcorePackage() , eINSTANCE_2).eObjectEClass;
}
;
_.eContainerFeatureID = 0;
_.eFlags = 1;
var Lorg_eclipse_emf_ecore_impl_EObjectImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EObjectImpl', 479);
function $clinit_DynamicEObjectImpl(){
  $clinit_DynamicEObjectImpl = emptyMethod;
  ENO_SETTINGS = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
}

function DynamicEObjectImpl(eClass){
  $clinit_DynamicEObjectImpl();
  EObjectImpl.call(this);
  this.eSetClass(eClass);
}

defineClass(729, 479, {98:1, 92:1, 89:1, 51:1, 106:1, 46:1, 93:1}, DynamicEObjectImpl);
_.dynamicGet = function dynamicGet_1(dynamicFeatureID){
  return this.eSettings[dynamicFeatureID];
}
;
_.dynamicSet = function dynamicSet_1(dynamicFeatureID, value_0){
  this.eSettings[dynamicFeatureID] = value_0;
}
;
_.dynamicUnset = function dynamicUnset_1(dynamicFeatureID){
  this.eSettings[dynamicFeatureID] = null;
}
;
_.eClass_0 = function eClass_3(){
  return this.eClass;
}
;
_.eDerivedStructuralFeatureID_0 = function eDerivedStructuralFeatureID_1(eStructuralFeature){
  return $getFeatureID(this.eClass, eStructuralFeature);
}
;
_.eDynamicClass = function eDynamicClass_1(){
  return this.eClass;
}
;
_.eHasSettings = function eHasSettings_1(){
  return this.eSettings != null;
}
;
_.eProperties_0 = function eProperties_3(){
  !this.eProperties && (this.eProperties = new DynamicEObjectImpl$DynamicEPropertiesHolderImpl);
  return this.eProperties;
}
;
_.eSetClass = function eSetClass_2(eClass){
  this.eClass = eClass;
}
;
_.eSettings_0 = function eSettings_1(){
  var size_0;
  if (this.eSettings == null) {
    size_0 = $getFeatureCount(this.eClass);
    this.eSettings = size_0 == 0?ENO_SETTINGS:initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, size_0, 5, 1);
  }
  return this;
}
;
_.eStaticFeatureCount = function eStaticFeatureCount_0(){
  return 0;
}
;
var ENO_SETTINGS;
var Lorg_eclipse_emf_ecore_impl_DynamicEObjectImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'DynamicEObjectImpl', 729);
function DynamicEObjectImpl$BasicEMapEntry(eClass){
  $clinit_DynamicEObjectImpl();
  DynamicEObjectImpl.call(this, eClass);
  this.hash = -1;
}

defineClass(1340, 729, {98:1, 39:1, 92:1, 89:1, 140:1, 51:1, 106:1, 46:1, 93:1}, DynamicEObjectImpl$BasicEMapEntry);
_.equals_0 = function equals_188(other){
  return this === other;
}
;
_.hashCode_1 = function hashCode_76(){
  return getHashCode_0(this);
}
;
_.eSetClass = function eSetClass_3(eClass){
  this.eClass = eClass;
  this.keyFeature = $getEStructuralFeature_0(eClass, 'key');
  this.valueFeature = $getEStructuralFeature_0(eClass, 'value');
}
;
_.getHash = function getHash_1(){
  var theKey;
  if (this.hash == -1) {
    theKey = $eGet_2(this, this.keyFeature);
    this.hash = theKey == null?0:hashCode__I__devirtual$(theKey);
  }
  return this.hash;
}
;
_.getKey = function getKey_9(){
  return $eGet_2(this, this.keyFeature);
}
;
_.getValue = function getValue_10(){
  return $eGet_2(this, this.valueFeature);
}
;
_.setHash = function setHash_1(hash){
  this.hash = hash;
}
;
_.setKey = function setKey_1(key){
  $eSet_0(this, this.keyFeature, key);
}
;
_.setValue = function setValue_10(value_0){
  var result;
  result = $eGet_2(this, this.valueFeature);
  $eSet_0(this, this.valueFeature, value_0);
  return result;
}
;
_.hash = 0;
var Lorg_eclipse_emf_ecore_impl_DynamicEObjectImpl$BasicEMapEntry_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'DynamicEObjectImpl/BasicEMapEntry', 1340);
function DynamicEObjectImpl$DynamicEPropertiesHolderImpl(){
}

defineClass(1341, 1, {106:1}, DynamicEObjectImpl$DynamicEPropertiesHolderImpl);
_.allocateSettings = function allocateSettings_0(maximumDynamicFeatureID){
  throw toJs(new UnsupportedOperationException);
}
;
_.dynamicGet = function dynamicGet_2(dynamicFeatureID){
  throw toJs(new UnsupportedOperationException);
}
;
_.dynamicSet = function dynamicSet_2(dynamicFeatureID, value_0){
  throw toJs(new UnsupportedOperationException);
}
;
_.dynamicUnset = function dynamicUnset_2(dynamicFeatureID){
  throw toJs(new UnsupportedOperationException);
}
;
_.getEClass = function getEClass_0(){
  throw toJs(new UnsupportedOperationException);
}
;
_.getEContents = function getEContents_1(){
  return this.eContents;
}
;
_.getEProxyURI = function getEProxyURI_1(){
  return this.eProxyURI;
}
;
_.getEResource = function getEResource_0(){
  return this.eResource;
}
;
_.hasSettings = function hasSettings_0(){
  throw toJs(new UnsupportedOperationException);
}
;
_.setEClass = function setEClass_0(eClass){
  throw toJs(new UnsupportedOperationException);
}
;
_.setEContents = function setEContents_1(eContents){
  this.eContents = eContents;
}
;
_.setEResource = function setEResource_0(eResource){
  this.eResource = eResource;
}
;
var Lorg_eclipse_emf_ecore_impl_DynamicEObjectImpl$DynamicEPropertiesHolderImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'DynamicEObjectImpl/DynamicEPropertiesHolderImpl', 1341);
function $basicSetEModelElement(this$static, newEModelElement, msgs){
  msgs = $eBasicSetContainer(this$static, castTo(newEModelElement, 46), 3, msgs);
  return msgs;
}

function $eBasicRemoveFromContainerFeature_5(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 3) {
    return this$static.eContainer.eInverseRemove(this$static, 0, Lorg_eclipse_emf_ecore_EModelElement_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EANNOTATION):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getEModelElement(this$static){
  if (this$static.eFlags_0 >> 16 != 3)
    return null;
  return castTo(this$static.eContainer, 143);
}

function $setEModelElement(this$static, newEModelElement){
  var eContainerFeatureID, msgs;
  if (newEModelElement != this$static.eContainer || this$static.eFlags_0 >> 16 != 3 && !!newEModelElement) {
    if (isAncestor(this$static, newEModelElement))
      throw toJs(new IllegalArgumentException_0('Recursive containment not allowed for ' + $toString_23(this$static)));
    msgs = null;
    !!this$static.eContainer && (msgs = (eContainerFeatureID = this$static.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_5(this$static, null):this$static.eContainer.eInverseRemove(this$static, -1 - eContainerFeatureID, null, null)));
    !!newEModelElement && (msgs = castTo(newEModelElement, 46).eInverseAdd(this$static, 0, Lorg_eclipse_emf_ecore_EModelElement_2_classLit, msgs));
    msgs = $basicSetEModelElement(this$static, newEModelElement, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 3, newEModelElement, newEModelElement));
}

function $setSource_1(this$static, newSource){
  $setSourceGen(this$static, newSource == null?null:(checkCriticalNotNull(newSource) , newSource));
}

function $setSourceGen(this$static, newSource){
  var oldSource;
  oldSource = this$static.source;
  this$static.source = newSource;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 1, oldSource, this$static.source));
}

function $toString_23(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_12(this$static);
  result = new StringBuffer_1($toString_12(this$static));
  result.string += ' (source: ';
  $append_3(result, this$static.source);
  result.string += ')';
  return result.string;
}

function EAnnotationImpl(){
}

defineClass(483, 145, {98:1, 92:1, 89:1, 628:1, 143:1, 51:1, 106:1, 46:1, 93:1, 483:1, 145:1, 109:1, 110:1}, EAnnotationImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_6(msgs){
  return $eBasicRemoveFromContainerFeature_5(this, msgs);
}
;
_.eGet = function eGet_17(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.source;
    case 2:
      return coreType?(!this.details && (this.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this)) , this.details):(!this.details && (this.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this)) , $map_0(this.details));
    case 3:
      return $getEModelElement(this);
    case 4:
      return !this.contents && (this.contents = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EObject_2_classLit, this, 4)) , this.contents;
    case 5:
      return !this.references && (this.references = new EObjectResolvingEList(Lorg_eclipse_emf_ecore_EObject_2_classLit, this, 5)) , this.references;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EANNOTATION)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EANNOTATION:eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_11(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 3:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_5(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $basicSetEModelElement(this, castTo(otherEnd, 143), msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EANNOTATION):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EANNOTATION)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_12(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 2:
      return !this.details && (this.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this)) , $basicRemove_1(this.details, otherEnd, msgs);
    case 3:
      return $basicSetEModelElement(this, null, msgs);
    case 4:
      return !this.contents && (this.contents = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EObject_2_classLit, this, 4)) , $basicRemove_0(this.contents, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EANNOTATION):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EANNOTATION)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_16(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.source != null;
    case 2:
      return !!this.details && this.details.size_0 != 0;
    case 3:
      return !!$getEModelElement(this);
    case 4:
      return !!this.contents && this.contents.size_0 != 0;
    case 5:
      return !!this.references && this.references.size_0 != 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EANNOTATION)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EANNOTATION:eClass), featureID));
}
;
_.eSet = function eSet_15(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setSource_1(this, castToString(newValue));
      return;
    case 2:
      !this.details && (this.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this));
      $set_11(this.details, newValue);
      return;
    case 3:
      $setEModelElement(this, castTo(newValue, 143));
      return;
    case 4:
      !this.contents && (this.contents = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EObject_2_classLit, this, 4));
      $clear_11(this.contents);
      !this.contents && (this.contents = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EObject_2_classLit, this, 4));
      $addAll_6(this.contents, castTo(newValue, 13));
      return;
    case 5:
      !this.references && (this.references = new EObjectResolvingEList(Lorg_eclipse_emf_ecore_EObject_2_classLit, this, 5));
      $clear_11(this.references);
      !this.references && (this.references = new EObjectResolvingEList(Lorg_eclipse_emf_ecore_EObject_2_classLit, this, 5));
      $addAll_6(this.references, castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EANNOTATION)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EANNOTATION:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_16(){
  return $clinit_EcorePackage$Literals() , EANNOTATION;
}
;
_.toString_0 = function toString_143(){
  return $toString_23(this);
}
;
_.source = null;
var Lorg_eclipse_emf_ecore_impl_EAnnotationImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EAnnotationImpl', 483);
function $basicAdd_1(this$static, object, notifications){
  return castTo(this$static.delegateEList, 69).basicAdd(object, notifications);
}

function $basicRemove_1(this$static, object, notifications){
  return castTo(this$static.delegateEList, 69).basicRemove(object, notifications);
}

function $set_11(this$static, value_0){
  var mapValue;
  if (instanceOf(value_0, 111)) {
    castTo(this$static.delegateEList, 82).unset();
    mapValue = castTo(value_0, 111);
    $putAll_0(this$static, mapValue);
  }
   else {
    castTo(this$static.delegateEList, 82).set_1(value_0);
  }
}

function EcoreEMap(entryEClass, entryClass, owner, featureID){
  this.initializeDelegateEList();
  this.entryClass = entryClass;
  this.entryEClass = entryEClass;
  this.delegateEList = new EcoreEMap$DelegateEObjectContainmentEList(this, entryClass, owner, featureID);
}

defineClass(146, 661, $intern_150, EcoreEMap);
_.basicAdd = function basicAdd(object, notifications){
  return $basicAdd_1(this, castTo(object, 39), notifications);
}
;
_.basicGet = function basicGet_0(index_0){
  return castTo(castTo(this.delegateEList, 69).basicGet(index_0), 140);
}
;
_.basicIterator = function basicIterator_1(){
  return castTo(this.delegateEList, 69).basicIterator();
}
;
_.basicListIterator = function basicListIterator_3(){
  return castTo(this.delegateEList, 69).basicListIterator();
}
;
_.basicListIterator_0 = function basicListIterator_4(index_0){
  return castTo(this.delegateEList, 69).basicListIterator_0(index_0);
}
;
_.basicRemove = function basicRemove(object, notifications){
  return $basicRemove_1(this, object, notifications);
}
;
_.get_6 = function get_46(resolve){
  return castTo(this.delegateEList, 82).get_6(resolve);
}
;
_.initializeDelegateEList = function initializeDelegateEList_0(){
}
;
_.isSet_0 = function isSet_1(){
  return castTo(this.delegateEList, 82).isSet_0();
}
;
_.newEntry = function newEntry_1(hash, key, value_0){
  var entry;
  entry = castTo($getEPackage(this.entryEClass).getEFactoryInstance().create_3(this.entryEClass), 140);
  entry.setHash(hash);
  entry.setKey(key);
  entry.setValue(value_0);
  return entry;
}
;
_.newList = function newList_0(){
  return new EcoreEMap$1(this);
}
;
_.set_1 = function set_30(value_0){
  $set_11(this, value_0);
}
;
_.unset = function unset(){
  castTo(this.delegateEList, 82).unset();
}
;
var Lorg_eclipse_emf_ecore_util_EcoreEMap_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEMap', 146);
function EAnnotationImpl$1($anonymous0, $anonymous1, $anonymous2){
  EcoreEMap.call(this, $anonymous0, $anonymous1, $anonymous2, 2);
}

defineClass(155, 146, $intern_150, EAnnotationImpl$1);
_.ensureEntryDataExists = function ensureEntryDataExists_0(){
  var eList, entry, entry$iterator, hash, index_0, result;
  if (this.entryData == null) {
    result = initUnidimensionalArray(Lorg_eclipse_emf_common_util_BasicEList_2_classLit, $intern_148, 55, 2 * this.size_0 + 1, 0, 1);
    for (entry$iterator = this.delegateEList.iterator_0(); entry$iterator.cursor != entry$iterator.this$01_2.size_1();) {
      entry = castTo(entry$iterator.doNext(), 140);
      hash = entry.getHash();
      index_0 = (hash & $intern_0) % result.length;
      eList = result[index_0];
      !eList && (eList = result[index_0] = new EcoreEMap$1(this));
      eList.add_1(entry);
    }
    this.entryData = result;
  }
}
;
var Lorg_eclipse_emf_ecore_impl_EAnnotationImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EAnnotationImpl/1', 155);
function $basicSetEGenericType(this$static, newEGenericType, msgs){
  var newEType, notification, oldEGenericType;
  oldEGenericType = this$static.eGenericType;
  this$static.eGenericType = newEGenericType;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 9, oldEGenericType, newEGenericType);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  if (!newEGenericType) {
    !!this$static.eType && (msgs = this$static.setEType(null, msgs));
  }
   else {
    newEType = newEGenericType.eRawType;
    newEType != this$static.eType && (msgs = this$static.setEType(newEType, msgs));
  }
  return msgs;
}

function $basicUnsetEGenericType(this$static, msgs){
  msgs = this$static.setEType(null, msgs);
  return $basicSetEGenericType(this$static, null, msgs);
}

function $getEType(this$static){
  var oldEType;
  if ((this$static.eFlags & 1) == 0 && !!this$static.eType && this$static.eType.eIsProxy()) {
    oldEType = castTo(this$static.eType, 46);
    this$static.eType = castTo($eResolveProxy(this$static, oldEType), 136);
    this$static.eType != oldEType && (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 9, 8, oldEType, this$static.eType));
  }
  return this$static.eType;
}

function $setEGenericType(this$static, newEGenericType, msgs){
  var notification;
  if (newEGenericType != this$static.eGenericType) {
    !!this$static.eGenericType && (msgs = $eInverseRemove(this$static.eGenericType, this$static, -10, msgs));
    !!newEGenericType && (msgs = $eInverseAdd(newEGenericType, this$static, -10, msgs));
    msgs = $basicSetEGenericType(this$static, newEGenericType, msgs);
  }
   else if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 9, newEGenericType, newEGenericType);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  return msgs;
}

function $setEType(this$static, newEType){
  var eGenericType, msgs, newEGenericType;
  msgs = this$static.setEType(newEType, null);
  newEGenericType = null;
  if (newEType) {
    newEGenericType = ($clinit_EcoreFactory() , eGenericType = new EGenericTypeImpl , eGenericType);
    $setEClassifier(newEGenericType, this$static.eType);
  }
  msgs = $setEGenericType(this$static, newEGenericType, msgs);
  !!msgs && msgs.dispatch_0();
}

function $setEType_0(this$static, newEType, msgs){
  var notification, oldEType;
  oldEType = this$static.eType;
  this$static.eType = newEType;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 8, oldEType, this$static.eType);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  return msgs;
}

function $setLowerBound(this$static, newLowerBound){
  var oldLowerBound;
  oldLowerBound = this$static.lowerBound;
  this$static.lowerBound = newLowerBound;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_0(this$static, 4, oldLowerBound, this$static.lowerBound));
}

function $setOrdered(this$static, newOrdered){
  var oldOrdered;
  oldOrdered = (this$static.eFlags & 256) != 0;
  newOrdered?(this$static.eFlags |= 256):(this$static.eFlags &= -257);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 2, oldOrdered, newOrdered));
}

function $setUnique_2(this$static, newUnique){
  var oldUnique;
  oldUnique = (this$static.eFlags & 512) != 0;
  newUnique?(this$static.eFlags |= 512):(this$static.eFlags &= -513);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 3, oldUnique, newUnique));
}

function $setUpperBound(this$static, newUpperBound){
  var oldUpperBound;
  oldUpperBound = this$static.upperBound;
  this$static.upperBound = newUpperBound;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_0(this$static, 5, oldUpperBound, this$static.upperBound));
}

function $toString_24(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_17(this$static);
  result = new StringBuffer_1($toString_17(this$static));
  result.string += ' (ordered: ';
  $append_4(result, (this$static.eFlags & 256) != 0);
  result.string += ', unique: ';
  $append_4(result, (this$static.eFlags & 512) != 0);
  result.string += ', lowerBound: ';
  $append_1(result, this$static.lowerBound);
  result.string += ', upperBound: ';
  $append_1(result, this$static.upperBound);
  result.string += ')';
  return result.string;
}

function ETypedElementImpl(){
  this.eFlags |= 256;
  this.eFlags |= 512;
}

defineClass(278, 417, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 106:1, 446:1, 46:1, 93:1, 145:1, 278:1, 109:1, 110:1});
_.eGet = function eGet_18(featureID, resolve, coreType){
  var eClass, lower;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
    case 3:
      return $clinit_Boolean() , (this.eFlags & 512) != 0?true:false;
    case 4:
      return valueOf_4(this.lowerBound);
    case 5:
      return valueOf_4(this.upperBound);
    case 6:
      return $clinit_Boolean() , this.isMany()?true:false;
    case 7:
      return $clinit_Boolean() , lower = this.lowerBound , lower >= 1?true:false;
    case 8:
      if (resolve)
        return $getEType(this);
      return this.eType;
    case 9:
      return this.eGenericType;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), resolve, coreType);
}
;
_.eInverseRemove_0 = function eInverseRemove_13(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 9:
      return $basicUnsetEGenericType(this, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(this.eStaticClass()), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_17(featureID){
  var eClass, lower;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return (this.eFlags & 256) == 0;
    case 3:
      return (this.eFlags & 512) == 0;
    case 4:
      return this.lowerBound != 0;
    case 5:
      return this.upperBound != 1;
    case 6:
      return this.isMany();
    case 7:
      return lower = this.lowerBound , lower >= 1;
    case 8:
      return !!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0;
    case 9:
      return !!this.eGenericType && !(!!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0);
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID));
}
;
_.eSet = function eSet_16(featureID, newValue){
  var eClass, msgs;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      this.setName(castToString(newValue));
      return;
    case 2:
      $setOrdered(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 3:
      $setUnique_2(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 4:
      $setLowerBound(this, castTo(newValue, 21).value_0);
      return;
    case 5:
      this.setUpperBound(castTo(newValue, 21).value_0);
      return;
    case 8:
      $setEType(this, castTo(newValue, 136));
      return;
    case 9:
      msgs = $setEGenericType(this, castTo(newValue, 86), null);
      !!msgs && msgs.dispatch_0();
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_17(){
  return $clinit_EcorePackage$Literals() , ETYPED_ELEMENT;
}
;
_.freeze = function freeze_1(){
  $getEType(this);
  this.eFlags |= 1;
}
;
_.getEType = function getEType(){
  return $getEType(this);
}
;
_.getUpperBound = function getUpperBound(){
  return this.upperBound;
}
;
_.isMany = function isMany(){
  var upper;
  return upper = this.upperBound , upper > 1 || upper == -1;
}
;
_.isUnique = function isUnique_2(){
  return (this.eFlags & 512) != 0;
}
;
_.setEType = function setEType(newEType, msgs){
  return $setEType_0(this, newEType, msgs);
}
;
_.setUpperBound = function setUpperBound(newUpperBound){
  $setUpperBound(this, newUpperBound);
}
;
_.toString_0 = function toString_144(){
  return $toString_24(this);
}
;
_.lowerBound = 0;
_.upperBound = 1;
var Lorg_eclipse_emf_ecore_impl_ETypedElementImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ETypedElementImpl', 278);
function $eBasicRemoveFromContainerFeature_6(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 17) {
    return this$static.eContainer.eInverseRemove(this$static, 21, Lorg_eclipse_emf_ecore_EClass_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?this$static.eStaticClass():eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getDefaultValue(this$static){
  var eDataType, ePackage, eType, factory, literal;
  eType = $getEType(this$static);
  literal = this$static.defaultValueLiteral;
  if (literal == null && !!eType) {
    return this$static.isMany()?null:eType.getDefaultValue();
  }
   else if (instanceOf(eType, 144)) {
    ePackage = eType.getEPackage();
    if (ePackage) {
      factory = ePackage.getEFactoryInstance();
      if (factory != this$static.defaultValueFactory) {
        eDataType = castTo(eType, 144);
        if (eDataType.isSerializable()) {
          try {
            this$static.defaultValue = factory.createFromString(eDataType, literal);
          }
           catch ($e0) {
            $e0 = toJava($e0);
            if (instanceOf($e0, 79)) {
              this$static.defaultValue = null;
            }
             else 
              throw toJs($e0);
          }
        }
        this$static.defaultValueFactory = factory;
      }
    }
    return this$static.defaultValue;
  }
  return null;
}

function $getEContainingClass(this$static){
  if (this$static.eFlags_0 >> 16 != 17)
    return null;
  return castTo(this$static.eContainer, 26);
}

function $getFeatureMapEntryPrototype(this$static){
  var eOpposite;
  if (!this$static.prototypeFeatureMapEntry) {
    eOpposite = this$static.getEOpposite();
    eOpposite?(this$static.prototypeFeatureMapEntry = new EStructuralFeatureImpl$InverseUpdatingFeatureMapEntry(this$static, this$static, null)):this$static.isContainment()?(this$static.prototypeFeatureMapEntry = new EStructuralFeatureImpl$ContainmentUpdatingFeatureMapEntry(this$static, null)):$getFeatureKind($getExtendedMetaData_1(($clinit_ExtendedMetaData() , INSTANCE_11), this$static)) == 1?(this$static.prototypeFeatureMapEntry = new EStructuralFeatureImpl$SimpleContentFeatureMapEntry(this$static)):(this$static.prototypeFeatureMapEntry = new EStructuralFeatureImpl$SimpleFeatureMapEntry(this$static, null));
  }
  return this$static.prototypeFeatureMapEntry;
}

function $isFeatureMap(this$static){
  var eType;
  if (this$static.cachedEType != this$static.eType) {
    eType = $getEType(this$static);
    this$static.cachedIsFeatureMap = !!eType && eType.getInstanceClassName() == 'org.eclipse.emf.ecore.util.FeatureMap$Entry';
    this$static.cachedEType = eType;
  }
  return this$static.cachedIsFeatureMap;
}

function $setChangeable(this$static, newChangeable){
  var oldChangeable;
  oldChangeable = (this$static.eFlags & $intern_89) != 0;
  newChangeable?(this$static.eFlags |= $intern_89):(this$static.eFlags &= -1025);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 10, oldChangeable, newChangeable));
}

function $setDefaultValueLiteral(this$static, newDefaultValueLiteral){
  this$static.defaultValueFactory = null;
  $setDefaultValueLiteralGen(this$static, newDefaultValueLiteral);
}

function $setDefaultValueLiteralGen(this$static, newDefaultValueLiteral){
  var oldDefaultValueLiteral;
  oldDefaultValueLiteral = this$static.defaultValueLiteral;
  this$static.defaultValueLiteral = newDefaultValueLiteral;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 13, oldDefaultValueLiteral, this$static.defaultValueLiteral));
}

function $setDerived(this$static, newDerived){
  var oldDerived;
  oldDerived = (this$static.eFlags & $intern_21) != 0;
  newDerived?(this$static.eFlags |= $intern_21):(this$static.eFlags &= -16385);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 16, oldDerived, newDerived));
}

function $setFeatureID(this$static, featureID){
  this$static.featureID = featureID;
}

function $setName_0(this$static, newName){
  instanceOf(this$static.eContainer, 99) && $setFlags_0($getESuperAdapter(castTo(this$static.eContainer, 99)), 4);
  $setName(this$static, newName);
}

function $setTransient(this$static, newTransient){
  var oldTransient;
  oldTransient = (this$static.eFlags & $intern_64) != 0;
  newTransient?(this$static.eFlags |= $intern_64):(this$static.eFlags &= -4097);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 12, oldTransient, newTransient));
}

function $setUnsettable(this$static, newUnsettable){
  var oldUnsettable;
  oldUnsettable = (this$static.eFlags & $intern_151) != 0;
  newUnsettable?(this$static.eFlags |= $intern_151):(this$static.eFlags &= -8193);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 15, oldUnsettable, newUnsettable));
}

function $setVolatile(this$static, newVolatile){
  var oldVolatile;
  oldVolatile = (this$static.eFlags & $intern_152) != 0;
  newVolatile?(this$static.eFlags |= $intern_152):(this$static.eFlags &= -2049);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 11, oldVolatile, newVolatile));
}

function $toString_25(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_24(this$static);
  result = new StringBuffer_1($toString_24(this$static));
  result.string += ' (changeable: ';
  $append_4(result, (this$static.eFlags & $intern_89) != 0);
  result.string += ', volatile: ';
  $append_4(result, (this$static.eFlags & $intern_152) != 0);
  result.string += ', transient: ';
  $append_4(result, (this$static.eFlags & $intern_64) != 0);
  result.string += ', defaultValueLiteral: ';
  $append_3(result, this$static.defaultValueLiteral);
  result.string += ', unsettable: ';
  $append_4(result, (this$static.eFlags & $intern_151) != 0);
  result.string += ', derived: ';
  $append_4(result, (this$static.eFlags & $intern_21) != 0);
  result.string += ')';
  return result.string;
}

function EStructuralFeatureImpl(){
  ETypedElementImpl.call(this);
  this.featureID = -1;
  this.defaultValue = null;
  this.defaultValueFactory = null;
  this.defaultValueLiteral = null;
  this.eFlags |= $intern_89;
}

defineClass(426, 278, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 159:1, 63:1, 106:1, 446:1, 46:1, 93:1, 145:1, 426:1, 278:1, 109:1, 110:1, 634:1});
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_7(msgs){
  return $eBasicRemoveFromContainerFeature_6(this, msgs);
}
;
_.eGet = function eGet_19(featureID, resolve, coreType){
  var eClass, lower;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
    case 3:
      return $clinit_Boolean() , (this.eFlags & 512) != 0?true:false;
    case 4:
      return valueOf_4(this.lowerBound);
    case 5:
      return valueOf_4(this.upperBound);
    case 6:
      return $clinit_Boolean() , this.isMany()?true:false;
    case 7:
      return $clinit_Boolean() , lower = this.lowerBound , lower >= 1?true:false;
    case 8:
      if (resolve)
        return $getEType(this);
      return this.eType;
    case 9:
      return this.eGenericType;
    case 10:
      return $clinit_Boolean() , (this.eFlags & $intern_89) != 0?true:false;
    case 11:
      return $clinit_Boolean() , (this.eFlags & $intern_152) != 0?true:false;
    case 12:
      return $clinit_Boolean() , (this.eFlags & $intern_64) != 0?true:false;
    case 13:
      return this.defaultValueLiteral;
    case 14:
      return $getDefaultValue(this);
    case 15:
      return $clinit_Boolean() , (this.eFlags & $intern_151) != 0?true:false;
    case 16:
      return $clinit_Boolean() , (this.eFlags & $intern_21) != 0?true:false;
    case 17:
      return $getEContainingClass(this);
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_12(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 17:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_6(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $eBasicSetContainer(this, otherEnd, 17, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(this.eStaticClass()), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_14(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 9:
      return $basicUnsetEGenericType(this, msgs);
    case 17:
      return $eBasicSetContainer(this, null, 17, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(this.eStaticClass()), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_18(featureID){
  var eClass, lower;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return (this.eFlags & 256) == 0;
    case 3:
      return (this.eFlags & 512) == 0;
    case 4:
      return this.lowerBound != 0;
    case 5:
      return this.upperBound != 1;
    case 6:
      return this.isMany();
    case 7:
      return lower = this.lowerBound , lower >= 1;
    case 8:
      return !!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0;
    case 9:
      return !!this.eGenericType && !(!!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0);
    case 10:
      return (this.eFlags & $intern_89) == 0;
    case 11:
      return (this.eFlags & $intern_152) != 0;
    case 12:
      return (this.eFlags & $intern_64) != 0;
    case 13:
      return this.defaultValueLiteral != null;
    case 14:
      return $getDefaultValue(this) != null;
    case 15:
      return (this.eFlags & $intern_151) != 0;
    case 16:
      return (this.eFlags & $intern_21) != 0;
    case 17:
      return !!$getEContainingClass(this);
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID));
}
;
_.eSet = function eSet_17(featureID, newValue){
  var eClass, msgs;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName_0(this, castToString(newValue));
      return;
    case 2:
      $setOrdered(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 3:
      $setUnique_2(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 4:
      $setLowerBound(this, castTo(newValue, 21).value_0);
      return;
    case 5:
      this.setUpperBound(castTo(newValue, 21).value_0);
      return;
    case 8:
      $setEType(this, castTo(newValue, 136));
      return;
    case 9:
      msgs = $setEGenericType(this, castTo(newValue, 86), null);
      !!msgs && msgs.dispatch_0();
      return;
    case 10:
      $setChangeable(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 11:
      $setVolatile(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 12:
      $setTransient(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 13:
      $setDefaultValueLiteral(this, castToString(newValue));
      return;
    case 15:
      $setUnsettable(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 16:
      $setDerived(this, checkNotNull_1(castToBoolean(newValue)));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_18(){
  return $clinit_EcorePackage$Literals() , ESTRUCTURAL_FEATURE;
}
;
_.freeze = function freeze_2(){
  $getName_2($getExtendedMetaData_1(($clinit_ExtendedMetaData() , INSTANCE_11), this));
  $getEType(this);
  this.eFlags |= 1;
}
;
_.getContainerClass = function getContainerClass(){
  return this.containerClass;
}
;
_.getDefaultValue = function getDefaultValue(){
  return $getDefaultValue(this);
}
;
_.getEContainingClass = function getEContainingClass(){
  return $getEContainingClass(this);
}
;
_.getEOpposite = function getEOpposite(){
  return null;
}
;
_.getExtendedMetaData_0 = function getExtendedMetaData_0(){
  return this.eStructuralFeatureExtendedMetaData;
}
;
_.getFeatureID_0 = function getFeatureID_4(){
  return this.featureID;
}
;
_.getFeatureMapEntryPrototype = function getFeatureMapEntryPrototype(){
  return $getFeatureMapEntryPrototype(this);
}
;
_.getSettingDelegate = function getSettingDelegate(){
  var dataClass, defaultValue, eClass, eOpposite, eType, featureMapFeature, instanceClass, intrinsicDefaultValue, upper;
  if (!this.settingDelegate) {
    eClass = $getEContainingClass(this);
    (eClass.eAllStructuralFeaturesData == null && $getEAllStructuralFeatures(eClass) , eClass.eAllStructuralFeaturesData).length;
    eOpposite = this.getEOpposite();
    !!eOpposite && $getFeatureCount($getEContainingClass(eOpposite));
    eType = $getEType(this);
    instanceClass = eType.getInstanceClass();
    dataClass = !instanceClass?null:(instanceClass.modifiers & 1) != 0?instanceClass == Z_classLit?Ljava_lang_Boolean_2_classLit:instanceClass == I_classLit?Ljava_lang_Integer_2_classLit:instanceClass == F_classLit?Ljava_lang_Float_2_classLit:instanceClass == D_classLit?Ljava_lang_Double_2_classLit:instanceClass == J_classLit?Ljava_lang_Long_2_classLit:instanceClass == S_classLit?Ljava_lang_Short_2_classLit:instanceClass == B_classLit?Ljava_lang_Byte_2_classLit:Ljava_lang_Character_2_classLit:instanceClass;
    defaultValue = $getDefaultValue(this);
    intrinsicDefaultValue = eType.getDefaultValue();
    getSettingDelegateFactory(this);
    (this.eFlags & $intern_21) != 0 && (!!(featureMapFeature = $getMixedFeature(($clinit_ExtendedMetaData() , INSTANCE_11), eClass)) && featureMapFeature != this || !!(featureMapFeature = $getGroup($getExtendedMetaData_1(INSTANCE_11, this))))?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateFeatureMapDelegator(this, featureMapFeature)):this.isMany()?this.isContainment()?!eOpposite?(this.eFlags & $intern_151) != 0?!dataClass?this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(42, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(0, this)):dataClass == Ljava_util_Map$Entry_2_classLit?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(50, Lorg_eclipse_emf_common_util_BasicEMap$Entry_2_classLit, this)):this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(43, dataClass, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(1, dataClass, this)):!dataClass?this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(44, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(2, this)):dataClass == Ljava_util_Map$Entry_2_classLit?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(41, Lorg_eclipse_emf_common_util_BasicEMap$Entry_2_classLit, this)):this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(45, dataClass, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(3, dataClass, this)):(this.eFlags & $intern_151) != 0?!dataClass?this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(46, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(4, this, eOpposite)):this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(47, dataClass, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(5, dataClass, this, eOpposite)):!dataClass?this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(48, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(6, this, eOpposite)):this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(49, dataClass, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(7, dataClass, this, eOpposite)):instanceOf(eType, 144)?dataClass == Lorg_eclipse_emf_ecore_util_FeatureMap$Entry_2_classLit?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(40, this)):(this.eFlags & 512) != 0?(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(8, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(9, dataClass, this)):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(10, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(11, dataClass, this)):(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(12, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(13, dataClass, this)):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(14, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(15, dataClass, this)):!eOpposite?this.isResolveProxies_0()?(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(16, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(17, dataClass, this)):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(18, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(19, dataClass, this)):(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(20, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(21, dataClass, this)):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(22, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany(23, dataClass, this)):(upper = eOpposite.upperBound , upper > 1 || upper == -1?this.isResolveProxies_0()?(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(24, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(25, dataClass, this, eOpposite)):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(26, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(27, dataClass, this, eOpposite)):(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(28, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(29, dataClass, this, eOpposite)):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(30, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(31, dataClass, this, eOpposite)):this.isResolveProxies_0()?(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(32, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(33, dataClass, this, eOpposite)):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(34, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(35, dataClass, this, eOpposite)):(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(36, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(37, dataClass, this, eOpposite)):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_2(38, this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_0(39, dataClass, this, eOpposite))):this.isContainer()?this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleContainerResolving(castTo(eType, 26), this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleContainer(castTo(eType, 26), this, eOpposite)):instanceOf(eType, 144)?dataClass == Lorg_eclipse_emf_ecore_util_FeatureMap$Entry_2_classLit?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateMany_1(40, this)):(this.eFlags & $intern_151) != 0?!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettableDynamic(castTo(eType, 144), defaultValue, intrinsicDefaultValue, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettableStatic(defaultValue, intrinsicDefaultValue, this, ($clinit_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator() , instanceClass == I_classLit?INT_NOTIFICATION_CREATOR:instanceClass == Z_classLit?BOOLEAN_NOTIFICATION_CREATOR:instanceClass == J_classLit?LONG_NOTIFICATION_CREATOR:instanceClass == F_classLit?FLOAT_NOTIFICATION_CREATOR:instanceClass == D_classLit?DOUBLE_NOTIFICATION_CREATOR:instanceClass == S_classLit?SHORT_NOTIFICATION_CREATOR:instanceClass == B_classLit?BYTE_NOTIFICATION_CREATOR:instanceClass == C_classLit?CHAR_NOTIFICATION_CREATOR:OBJECT_NOTIFICATION_CREATOR))):!dataClass?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleDataDynamic(castTo(eType, 144), defaultValue, intrinsicDefaultValue, this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleDataStatic(defaultValue, intrinsicDefaultValue, this, ($clinit_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator() , instanceClass == I_classLit?INT_NOTIFICATION_CREATOR:instanceClass == Z_classLit?BOOLEAN_NOTIFICATION_CREATOR:instanceClass == J_classLit?LONG_NOTIFICATION_CREATOR:instanceClass == F_classLit?FLOAT_NOTIFICATION_CREATOR:instanceClass == D_classLit?DOUBLE_NOTIFICATION_CREATOR:instanceClass == S_classLit?SHORT_NOTIFICATION_CREATOR:instanceClass == B_classLit?BYTE_NOTIFICATION_CREATOR:instanceClass == C_classLit?CHAR_NOTIFICATION_CREATOR:OBJECT_NOTIFICATION_CREATOR))):this.isContainment()?!eOpposite?(this.eFlags & $intern_151) != 0?this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettableResolving(castTo(eType, 26), this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettable(castTo(eType, 26), this)):this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentResolving(castTo(eType, 26), this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainment(castTo(eType, 26), this)):(this.eFlags & $intern_151) != 0?this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettableResolving(castTo(eType, 26), this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettable(castTo(eType, 26), this, eOpposite)):this.isResolveProxies_0()?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseResolving(castTo(eType, 26), this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverse(castTo(eType, 26), this, eOpposite)):this.isResolveProxies_0()?!eOpposite?(this.eFlags & $intern_151) != 0?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingUnsettable(castTo(eType, 26), this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolving(castTo(eType, 26), this)):(this.eFlags & $intern_151) != 0?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverseUnsettable(castTo(eType, 26), this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverse(castTo(eType, 26), this, eOpposite)):!eOpposite?(this.eFlags & $intern_151) != 0?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectUnsettable(castTo(eType, 26), this)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObject(castTo(eType, 26), this)):(this.eFlags & $intern_151) != 0?(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverseUnsettable(castTo(eType, 26), this, eOpposite)):(this.settingDelegate = new EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverse(castTo(eType, 26), this, eOpposite));
  }
  return this.settingDelegate;
}
;
_.isChangeable = function isChangeable_0(){
  return (this.eFlags & $intern_89) != 0;
}
;
_.isContainer = function isContainer(){
  return false;
}
;
_.isContainment = function isContainment_0(){
  return false;
}
;
_.isDerived = function isDerived_0(){
  return (this.eFlags & $intern_21) != 0;
}
;
_.isFeatureMap_0 = function isFeatureMap_0(){
  return $isFeatureMap(this);
}
;
_.isResolveProxies_0 = function isResolveProxies_0(){
  return false;
}
;
_.isUnsettable = function isUnsettable_0(){
  return (this.eFlags & $intern_151) != 0;
}
;
_.setExtendedMetaData_0 = function setExtendedMetaData_0(eStructuralFeatureExtendedMetaData){
  this.eStructuralFeatureExtendedMetaData = eStructuralFeatureExtendedMetaData;
}
;
_.setName = function setName_0(newName){
  $setName_0(this, newName);
}
;
_.toString_0 = function toString_145(){
  return $toString_25(this);
}
;
_.cachedIsFeatureMap = false;
_.featureID = 0;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl', 426);
function $basicGetEAttributeType(this$static){
  var eType;
  if (!this$static.eAttributeType) {
    eType = this$static.eType;
    instanceOf(eType, 144) && (this$static.eAttributeType = castTo(eType, 144));
  }
  return this$static.eAttributeType;
}

function $getEAttributeType(this$static){
  var eType;
  if (!this$static.eAttributeType || (this$static.eFlags & 1) == 0 && this$static.eAttributeType.eIsProxy()) {
    eType = $getEType(this$static);
    instanceOf(eType, 144) && (this$static.eAttributeType = castTo(eType, 144));
  }
  return this$static.eAttributeType;
}

function $isMany(this$static){
  var eType, upper;
  switch (this$static.effectiveIsMany) {
    case -1:
      {
        return true;
      }

    case 0:
      {
        upper = this$static.upperBound;
        if (upper > 1 || upper == -1) {
          this$static.effectiveIsMany = -1;
          return true;
        }
         else {
          eType = $getEType(this$static);
          if (!!eType && ($clinit_FeatureMapUtil() , eType.getInstanceClassName() == 'org.eclipse.emf.ecore.util.FeatureMap$Entry')) {
            this$static.effectiveIsMany = -1;
            return true;
          }
           else {
            this$static.effectiveIsMany = 1;
            return false;
          }
        }
      }

    default:case 1:
      {
        return false;
      }

  }
}

function $setID(this$static, newID){
  var oldID;
  oldID = (this$static.eFlags & $intern_138) != 0;
  newID?(this$static.eFlags |= $intern_138):(this$static.eFlags &= -32769);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 18, oldID, newID));
}

function $setUpperBound_0(this$static, upperBound){
  this$static.effectiveIsMany = 0;
  $setUpperBound(this$static, upperBound);
}

function EAttributeImpl(){
  EStructuralFeatureImpl.call(this);
}

defineClass(348, 426, {98:1, 92:1, 89:1, 29:1, 143:1, 179:1, 51:1, 159:1, 63:1, 106:1, 446:1, 46:1, 93:1, 348:1, 145:1, 426:1, 278:1, 109:1, 110:1, 634:1}, EAttributeImpl);
_.eGet = function eGet_20(featureID, resolve, coreType){
  var eClass, lower;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
    case 3:
      return $clinit_Boolean() , (this.eFlags & 512) != 0?true:false;
    case 4:
      return valueOf_4(this.lowerBound);
    case 5:
      return valueOf_4(this.upperBound);
    case 6:
      return $clinit_Boolean() , $isMany(this)?true:false;
    case 7:
      return $clinit_Boolean() , lower = this.lowerBound , lower >= 1?true:false;
    case 8:
      if (resolve)
        return $getEType(this);
      return this.eType;
    case 9:
      return this.eGenericType;
    case 10:
      return $clinit_Boolean() , (this.eFlags & $intern_89) != 0?true:false;
    case 11:
      return $clinit_Boolean() , (this.eFlags & $intern_152) != 0?true:false;
    case 12:
      return $clinit_Boolean() , (this.eFlags & $intern_64) != 0?true:false;
    case 13:
      return this.defaultValueLiteral;
    case 14:
      return $getDefaultValue(this);
    case 15:
      return $clinit_Boolean() , (this.eFlags & $intern_151) != 0?true:false;
    case 16:
      return $clinit_Boolean() , (this.eFlags & $intern_21) != 0?true:false;
    case 17:
      return $getEContainingClass(this);
    case 18:
      return $clinit_Boolean() , (this.eFlags & $intern_138) != 0?true:false;
    case 19:
      if (resolve)
        return $getEAttributeType(this);
      return $basicGetEAttributeType(this);
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EATTRIBUTE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EATTRIBUTE:eClass), featureID), resolve, coreType);
}
;
_.eIsSet = function eIsSet_19(featureID){
  var eClass, lower;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return (this.eFlags & 256) == 0;
    case 3:
      return (this.eFlags & 512) == 0;
    case 4:
      return this.lowerBound != 0;
    case 5:
      return this.upperBound != 1;
    case 6:
      return $isMany(this);
    case 7:
      return lower = this.lowerBound , lower >= 1;
    case 8:
      return !!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0;
    case 9:
      return !!this.eGenericType && !(!!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0);
    case 10:
      return (this.eFlags & $intern_89) == 0;
    case 11:
      return (this.eFlags & $intern_152) != 0;
    case 12:
      return (this.eFlags & $intern_64) != 0;
    case 13:
      return this.defaultValueLiteral != null;
    case 14:
      return $getDefaultValue(this) != null;
    case 15:
      return (this.eFlags & $intern_151) != 0;
    case 16:
      return (this.eFlags & $intern_21) != 0;
    case 17:
      return !!$getEContainingClass(this);
    case 18:
      return (this.eFlags & $intern_138) != 0;
    case 19:
      return !!$basicGetEAttributeType(this);
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EATTRIBUTE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EATTRIBUTE:eClass), featureID));
}
;
_.eSet = function eSet_18(featureID, newValue){
  var eClass, msgs;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName_0(this, castToString(newValue));
      return;
    case 2:
      $setOrdered(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 3:
      $setUnique_2(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 4:
      $setLowerBound(this, castTo(newValue, 21).value_0);
      return;
    case 5:
      $setUpperBound_0(this, castTo(newValue, 21).value_0);
      return;
    case 8:
      $setEType(this, castTo(newValue, 136));
      return;
    case 9:
      msgs = $setEGenericType(this, castTo(newValue, 86), null);
      !!msgs && msgs.dispatch_0();
      return;
    case 10:
      $setChangeable(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 11:
      $setVolatile(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 12:
      $setTransient(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 13:
      $setDefaultValueLiteral(this, castToString(newValue));
      return;
    case 15:
      $setUnsettable(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 16:
      $setDerived(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 18:
      $setID(this, checkNotNull_1(castToBoolean(newValue)));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EATTRIBUTE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EATTRIBUTE:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_19(){
  return $clinit_EcorePackage$Literals() , EATTRIBUTE;
}
;
_.freeze = function freeze_3(){
  $getEAttributeType(this);
  $getName_2($getExtendedMetaData_1(($clinit_ExtendedMetaData() , INSTANCE_11), this));
  $getEType(this);
  this.eFlags |= 1;
}
;
_.isMany = function isMany_0(){
  return $isMany(this);
}
;
_.setEType = function setEType_0(newEType, msgs){
  this.effectiveIsMany = 0;
  this.eAttributeType = null;
  return $setEType_0(this, newEType, msgs);
}
;
_.setUpperBound = function setUpperBound_0(upperBound){
  $setUpperBound_0(this, upperBound);
}
;
_.toString_0 = function toString_146(){
  var result;
  if ((this.eFlags_0 & 64) != 0)
    return $toString_25(this);
  result = new StringBuffer_1($toString_25(this));
  result.string += ' (iD: ';
  $append_4(result, (this.eFlags & $intern_138) != 0);
  result.string += ')';
  return result.string;
}
;
_.effectiveIsMany = 0;
var Lorg_eclipse_emf_ecore_impl_EAttributeImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EAttributeImpl', 348);
function $basicGetEPackage(this$static){
  if (this$static.eFlags_0 >> 16 != 6)
    return null;
  return castTo(this$static.eContainer, 214);
}

function $basicSetInstanceClassName(this$static, value_0){
  if (this$static.instanceClassName == null && this$static.generatedInstanceClassName != null) {
    this$static.instanceClassName = this$static.generatedInstanceClassName;
    this$static.generatedInstanceClassName = null;
  }
  $setInstanceClassNameGen(this$static, value_0 == null?null:(checkCriticalNotNull(value_0) , value_0));
  !!this$static.instanceClass && this$static.setInstanceClassGen(null);
}

function $basicSetInstanceTypeName(this$static, newInstanceTypeName){
  var oldInstanceTypeName;
  oldInstanceTypeName = this$static.instanceTypeName;
  this$static.instanceTypeName = newInstanceTypeName;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 5, oldInstanceTypeName, newInstanceTypeName));
}

function $eBasicRemoveFromContainerFeature_7(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 6) {
    return this$static.eContainer.eInverseRemove(this$static, 5, Lorg_eclipse_emf_ecore_EPackage_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?this$static.eStaticClass():eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getEPackage(this$static){
  var result;
  if (this$static.ePackage) {
    return this$static.ePackage;
  }
   else {
    result = $getEPackageGen(this$static);
    !!result && !result.eIsProxy() && (this$static.ePackage = result);
    return result;
  }
}

function $getEPackageGen(this$static){
  if (this$static.eFlags_0 >> 16 != 6)
    return null;
  return castTo($eContainer(this$static), 214);
}

function $getInstanceClass(this$static){
  var primitiveClass;
  if (!this$static.instanceClass && (this$static.instanceClassName != null || this$static.generatedInstanceClassName != null)) {
    primitiveClass = $getPrimitiveOrArrayClass(this$static);
    if (primitiveClass) {
      this$static.setInstanceClassGen(primitiveClass);
    }
     else {
      try {
        this$static.setInstanceClassGen(null);
      }
       catch ($e0) {
        $e0 = toJava($e0);
        if (!instanceOf($e0, 54))
          throw toJs($e0);
      }
    }
  }
  return this$static.instanceClass;
}

function $getPrimitiveOrArrayClass(this$static){
  var arrayIndex, className, componentClassName, result;
  className = this$static.instanceClassName != null?this$static.instanceClassName:this$static.generatedInstanceClassName;
  arrayIndex = $indexOf_1(className, fromCodePoint(91));
  if (arrayIndex != -1) {
    componentClassName = className.substr(0, arrayIndex);
    result = new StringBuffer;
    do 
      result.string += '[';
    while ((arrayIndex = $indexOf_0(className, 91, ++arrayIndex)) != -1);
    if ($equals_4(componentClassName, 'boolean'))
      result.string += 'Z';
    else if ($equals_4(componentClassName, 'byte'))
      result.string += 'B';
    else if ($equals_4(componentClassName, 'char'))
      result.string += 'C';
    else if ($equals_4(componentClassName, 'double'))
      result.string += 'D';
    else if ($equals_4(componentClassName, 'float'))
      result.string += 'F';
    else if ($equals_4(componentClassName, 'int'))
      result.string += 'I';
    else if ($equals_4(componentClassName, 'long'))
      result.string += 'J';
    else if ($equals_4(componentClassName, 'short'))
      result.string += 'S';
    else {
      result.string += 'L';
      result.string += '' + componentClassName;
      result.string += ';';
    }
    try {
      return null;
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (!instanceOf($e0, 54))
        throw toJs($e0);
    }
  }
   else if ($indexOf_1(className, fromCodePoint(46)) == -1) {
    if ($equals_4(className, 'boolean'))
      return Z_classLit;
    else if ($equals_4(className, 'byte'))
      return B_classLit;
    else if ($equals_4(className, 'char'))
      return C_classLit;
    else if ($equals_4(className, 'double'))
      return D_classLit;
    else if ($equals_4(className, 'float'))
      return F_classLit;
    else if ($equals_4(className, 'int'))
      return I_classLit;
    else if ($equals_4(className, 'long'))
      return J_classLit;
    else if ($equals_4(className, 'short'))
      return S_classLit;
  }
  return null;
}

function $isInstance(this$static, object){
  var helper, instanceClass;
  if (object != null) {
    instanceClass = $getInstanceClass(this$static);
    if (instanceClass) {
      if ((instanceClass.modifiers & 1) != 0) {
        if (instanceClass == Z_classLit) {
          return instanceOfBoolean(object);
        }
         else if (instanceClass == I_classLit) {
          return instanceOf(object, 21);
        }
         else if (instanceClass == F_classLit) {
          return instanceOf(object, 128);
        }
         else if (instanceClass == B_classLit) {
          return instanceOf(object, 196);
        }
         else if (instanceClass == C_classLit) {
          return instanceOf(object, 161);
        }
         else if (instanceClass == D_classLit) {
          return instanceOfDouble(object);
        }
         else if (instanceClass == S_classLit) {
          return instanceOf(object, 171);
        }
         else if (instanceClass == J_classLit) {
          return instanceOf(object, 152);
        }
      }
       else {
        return $clinit_Reflect() , helper = castTo($get_6(HELPER_REGISTRY, instanceClass), 49) , !helper || helper.isInstance(object);
      }
    }
     else if (instanceOf(object, 51)) {
      return this$static.dynamicIsInstance(castTo(object, 51));
    }
  }
  return false;
}

function $setGeneratedInstanceClass(this$static, isGenerated){
  if (isGenerated) {
    if (this$static.generatedInstanceClassName == null) {
      this$static.generatedInstanceClassName = this$static.instanceClassName;
      this$static.instanceClassName = null;
    }
  }
   else if (this$static.generatedInstanceClassName != null) {
    this$static.instanceClassName = this$static.generatedInstanceClassName;
    this$static.generatedInstanceClassName = null;
  }
}

function $setInstanceClass(this$static, value_0){
  var component, indices, name_0;
  if (!value_0) {
    $setInstanceClassNameGen(this$static, null);
    $basicSetInstanceTypeName(this$static, null);
  }
   else if ((value_0.modifiers & 4) != 0) {
    indices = '[]';
    for (component = value_0.componentType;; component = component.componentType) {
      if ((component.modifiers & 4) == 0) {
        name_0 = castToString(checkNotNull_1(($ensureNamesAreInitialized(component) , component.typeName + indices)));
        $setInstanceClassNameGen(this$static, name_0);
        $basicSetInstanceTypeName(this$static, name_0);
        break;
      }
      indices += '[]';
    }
  }
   else {
    name_0 = castToString(checkNotNull_1(($ensureNamesAreInitialized(value_0) , value_0.typeName)));
    $setInstanceClassNameGen(this$static, name_0);
    $basicSetInstanceTypeName(this$static, name_0);
  }
  this$static.setInstanceClassGen(value_0);
}

function $setInstanceClassName(this$static, value_0){
  $basicSetInstanceClassName(this$static, value_0);
  $basicSetInstanceTypeName(this$static, this$static.instanceClassName);
}

function $setInstanceClassNameGen(this$static, newInstanceClassName){
  var oldInstanceClassName;
  oldInstanceClassName = this$static.instanceClassName;
  this$static.instanceClassName = newInstanceClassName;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 2, oldInstanceClassName, this$static.instanceClassName));
}

function $setInstanceTypeName(this$static, newInstanceTypeName){
  var end, index_0, newInstanceClassName, oldInstanceTypeName;
  oldInstanceTypeName = this$static.instanceTypeName;
  if (newInstanceTypeName == null) {
    this$static.instanceTypeName = null;
    $basicSetInstanceClassName(this$static, null);
  }
   else {
    this$static.instanceTypeName = (checkCriticalNotNull(newInstanceTypeName) , newInstanceTypeName);
    index_0 = $indexOf_1(newInstanceTypeName, fromCodePoint(60));
    if (index_0 != -1) {
      newInstanceClassName = newInstanceTypeName.substr(0, index_0);
      $indexOf_1(newInstanceTypeName, fromCodePoint(46)) == -1 && !$equals_4(newInstanceClassName, 'boolean') && !$equals_4(newInstanceClassName, 'byte') && !$equals_4(newInstanceClassName, 'char') && !$equals_4(newInstanceClassName, 'double') && !$equals_4(newInstanceClassName, 'float') && !$equals_4(newInstanceClassName, 'int') && !$equals_4(newInstanceClassName, 'long') && !$equals_4(newInstanceClassName, 'short') && (newInstanceClassName = 'java.lang.Object');
      end = $lastIndexOf(newInstanceTypeName, fromCodePoint(62));
      end != -1 && (newInstanceClassName += '' + newInstanceTypeName.substr(end + 1, newInstanceTypeName.length - (end + 1)));
      $basicSetInstanceClassName(this$static, newInstanceClassName);
    }
     else {
      newInstanceClassName = newInstanceTypeName;
      if ($indexOf_1(newInstanceTypeName, fromCodePoint(46)) == -1) {
        index_0 = $indexOf_1(newInstanceTypeName, fromCodePoint(91));
        index_0 != -1 && (newInstanceClassName = newInstanceTypeName.substr(0, index_0));
        if (!$equals_4(newInstanceClassName, 'boolean') && !$equals_4(newInstanceClassName, 'byte') && !$equals_4(newInstanceClassName, 'char') && !$equals_4(newInstanceClassName, 'double') && !$equals_4(newInstanceClassName, 'float') && !$equals_4(newInstanceClassName, 'int') && !$equals_4(newInstanceClassName, 'long') && !$equals_4(newInstanceClassName, 'short')) {
          newInstanceClassName = 'java.lang.Object';
          index_0 != -1 && (newInstanceClassName += '' + newInstanceTypeName.substr(index_0, newInstanceTypeName.length - index_0));
        }
         else {
          newInstanceClassName = newInstanceTypeName;
        }
      }
      $basicSetInstanceClassName(this$static, newInstanceClassName);
      newInstanceClassName == newInstanceTypeName && (this$static.instanceTypeName = this$static.instanceClassName);
    }
  }
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 5, oldInstanceTypeName, newInstanceTypeName));
}

function $setName_1(this$static, newName){
  instanceOf(this$static.eContainer, 255) && (castTo(this$static.eContainer, 255).eNameToEClassifierMap = null);
  $setName(this$static, newName);
}

function $toString_26(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_17(this$static);
  result = new StringBuffer_1($toString_17(this$static));
  result.string += ' (instanceClassName: ';
  $append_3(result, this$static.instanceClassName);
  result.string += ')';
  return result.string;
}

defineClass(689, 417, {98:1, 92:1, 89:1, 136:1, 143:1, 179:1, 51:1, 106:1, 46:1, 93:1, 145:1, 109:1, 110:1, 633:1});
_.dynamicIsInstance = function dynamicIsInstance(eObject){
  return eObject.eClass_0() == this;
}
;
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_8(msgs){
  return $eBasicRemoveFromContainerFeature_7(this, msgs);
}
;
_.eBasicSetContainer = function eBasicSetContainer_5(newContainer, newContainerFeatureID){
  this.ePackage = null;
  this.eFlags_0 = newContainerFeatureID << 16 | this.eFlags_0 & 255;
  this.eContainer = newContainer;
}
;
_.eGet = function eGet_21(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return this.instanceClassName != null?this.instanceClassName:this.generatedInstanceClassName;
    case 3:
      return $getInstanceClass(this);
    case 4:
      return this.getDefaultValue();
    case 5:
      return this.instanceTypeName;
    case 6:
      if (resolve)
        return $getEPackage(this);
      return $basicGetEPackage(this);
    case 7:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7)) , this.eTypeParameters;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_13(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 6:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_7(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $eBasicSetContainer(this, otherEnd, 6, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(this.eStaticClass()), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_15(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 6:
      return $eBasicSetContainer(this, null, 6, msgs);
    case 7:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7)) , $basicRemove_0(this.eTypeParameters, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(this.eStaticClass()), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_20(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return this.instanceClassName != null && this.instanceClassName == this.instanceTypeName;
    case 3:
      return !!$getInstanceClass(this);
    case 4:
      return this.getDefaultValue() != null;
    case 5:
      return this.instanceTypeName != null && this.instanceTypeName != this.instanceClassName && this.instanceTypeName != this.generatedInstanceClassName;
    case 6:
      return !!$basicGetEPackage(this);
    case 7:
      return !!this.eTypeParameters && this.eTypeParameters.size_0 != 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID));
}
;
_.eSet = function eSet_19(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName_1(this, castToString(newValue));
      return;
    case 2:
      $setInstanceClassName(this, castToString(newValue));
      return;
    case 5:
      $setInstanceTypeName(this, castToString(newValue));
      return;
    case 7:
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7));
      $clear_11(this.eTypeParameters);
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7));
      $addAll_6(this.eTypeParameters, castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_20(){
  return $clinit_EcorePackage$Literals() , ECLASSIFIER;
}
;
_.getClassifierID = function getClassifierID(){
  var ePackage;
  return this.metaObjectID == -1 && (this.metaObjectID = (ePackage = $getEPackage(this) , ePackage?$indexOf_6(ePackage.getEClassifiers(), this):-1)) , this.metaObjectID;
}
;
_.getDefaultValue = function getDefaultValue_0(){
  return null;
}
;
_.getEPackage = function getEPackage(){
  return $getEPackage(this);
}
;
_.getExtendedMetaData_1 = function getExtendedMetaData_1(){
  return this.eClassifierExtendedMetaData;
}
;
_.getInstanceClass = function getInstanceClass(){
  return $getInstanceClass(this);
}
;
_.getInstanceClassName = function getInstanceClassName(){
  return this.instanceClassName != null?this.instanceClassName:this.generatedInstanceClassName;
}
;
_.getInstanceTypeName = function getInstanceTypeName(){
  return this.instanceTypeName;
}
;
_.isInstance = function isInstance_0(object){
  return $isInstance(this, object);
}
;
_.setExtendedMetaData_1 = function setExtendedMetaData_1(eClassifierExtendedMetaData){
  this.eClassifierExtendedMetaData = eClassifierExtendedMetaData;
}
;
_.setGeneratedInstanceClass = function setGeneratedInstanceClass(isGenerated){
  $setGeneratedInstanceClass(this, isGenerated);
}
;
_.setInstanceClassGen = function setInstanceClassGen(newInstanceClass){
  this.instanceClass = newInstanceClass;
}
;
_.setName = function setName_1(newName){
  $setName_1(this, newName);
}
;
_.toString_0 = function toString_147(){
  return $toString_26(this);
}
;
_.instanceClass = null;
_.instanceClassName = null;
_.metaObjectID = -1;
var Lorg_eclipse_emf_ecore_impl_EClassifierImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassifierImpl', 689);
function $clinit_EClassImpl(){
  $clinit_EClassImpl = emptyMethod;
  COMPUTATION_IN_PROGRESS = new EClassImpl$MyHashSet;
  NO_EALL_STRUCTURE_FEATURES_DATA = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, 1), $intern_153, 159, 0, []);
  NO_EALL_OPERATIONS_DATA = stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EOperation_2_classLit, 1), $intern_154, 53, 0, []);
}

function $getEAllAttributes(this$static){
  var attributes, computationInProgress, eStructuralFeature, eStructuralFeature$iterator, eSuperType, eSuperType$iterator, old, result;
  if (!this$static.eAllAttributes) {
    this$static.eIDAttribute = null;
    result = new EClassImpl$2(this$static);
    attributes = new EClassImpl$3;
    computationInProgress = COMPUTATION_IN_PROGRESS;
    old = computationInProgress.map_0.put(this$static, computationInProgress);
    if (old == null) {
      for (eSuperType$iterator = new AbstractEList$EIterator($getESuperTypes(this$static)); eSuperType$iterator.cursor != eSuperType$iterator.this$01_2.size_1();) {
        eSuperType = castTo($doNext(eSuperType$iterator), 26);
        $addAll_6(result, $getEAllAttributes(eSuperType));
      }
      computationInProgress.map_0.remove(this$static) != null;
      computationInProgress.map_0.size_1() == 0 && undefined;
    }
    for (eStructuralFeature$iterator = (!this$static.eStructuralFeatures && (this$static.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this$static, 21, 17)) , new AbstractEList$EIterator(this$static.eStructuralFeatures)); eStructuralFeature$iterator.cursor != eStructuralFeature$iterator.this$01_2.size_1();) {
      eStructuralFeature = castTo($doNext(eStructuralFeature$iterator), 159);
      instanceOf(eStructuralFeature, 348) && $add_21(attributes, castTo(eStructuralFeature, 29));
    }
    $shrink_0(attributes);
    this$static.eAttributes = new EClassImpl$4(this$static, (castTo($get_16($getEStructuralFeatures(($clinit_EcorePackage() , eINSTANCE_2).eClassEClass), 7), 17) , attributes.size_0), attributes.data_0);
    $addAll_6(result, this$static.eAttributes);
    $shrink_0(result);
    this$static.eAllAttributes = new EcoreEList$UnmodifiableEList$FastCompare((castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 4), 17) , result.size_0), result.data_0);
    $getESuperAdapter(this$static).modifiedState &= -2;
  }
  return this$static.eAllAttributes;
}

function $getEAllContainments(this$static){
  var eReference, eReference$iterator, result;
  if (!this$static.eAllContainments) {
    result = new EClassImpl$7;
    for (eReference$iterator = new AbstractEList$NonResolvingEIterator($getEAllReferences(this$static)); eReference$iterator.cursor != eReference$iterator.this$01_2.size_1();) {
      eReference = castTo($doNext_0(eReference$iterator), 17);
      (eReference.eFlags & $intern_138) != 0 && $add_21(result, eReference);
    }
    $shrink_0(result);
    this$static.eAllContainments = new EcoreEList$UnmodifiableEList$FastCompare((castTo($get_16($getEStructuralFeatures(($clinit_EcorePackage() , eINSTANCE_2).eClassEClass), 8), 17) , result.size_0), result.data_0);
    $getESuperAdapter(this$static).modifiedState &= -9;
  }
  return this$static.eAllContainments;
}

function $getEAllGenericSuperTypes(this$static){
  var computationInProgress, eGenericSuperType, eGenericSuperType$iterator, eSuperType, old, result;
  if (!this$static.eAllGenericSuperTypes) {
    result = new EClassImpl$1EGenericSuperTypeEList;
    computationInProgress = COMPUTATION_IN_PROGRESS;
    old = computationInProgress.map_0.put(this$static, computationInProgress);
    if (old == null) {
      for (eGenericSuperType$iterator = new AbstractEList$EIterator($getEGenericSuperTypes(this$static)); eGenericSuperType$iterator.cursor != eGenericSuperType$iterator.this$01_2.size_1();) {
        eGenericSuperType = castTo($doNext(eGenericSuperType$iterator), 86);
        eSuperType = $getERawType(eGenericSuperType);
        instanceOf(eSuperType, 99) && $addAll_6(result, $getEAllGenericSuperTypes(castTo(eSuperType, 26)));
        $add_21(result, eGenericSuperType);
      }
      computationInProgress.map_0.remove(this$static) != null;
      computationInProgress.map_0.size_1() == 0 && undefined;
    }
    $eliminateEquivalentDuplicates(result);
    $shrink_0(result);
    this$static.eAllGenericSuperTypes = new EcoreEList$UnmodifiableEList$FastCompare((castTo($get_16($getEStructuralFeatures(($clinit_EcorePackage() , eINSTANCE_2).eClassEClass), 15), 17) , result.size_0), result.data_0);
    $getESuperAdapter(this$static).modifiedState &= -33;
  }
  return this$static.eAllGenericSuperTypes;
}

function $getEAllOperations(this$static){
  var computationInProgress, eSuperType, eSuperType$iterator, i, old, operationID, result;
  if (!this$static.eAllOperations) {
    result = new EClassImpl$6;
    computationInProgress = COMPUTATION_IN_PROGRESS;
    old = computationInProgress.map_0.put(this$static, computationInProgress);
    if (old == null) {
      for (eSuperType$iterator = new AbstractEList$EIterator($getESuperTypes(this$static)); eSuperType$iterator.cursor != eSuperType$iterator.this$01_2.size_1();) {
        eSuperType = castTo($doNext(eSuperType$iterator), 26);
        $addAll_6(result, $getEAllOperations(eSuperType));
      }
      computationInProgress.map_0.remove(this$static) != null;
      computationInProgress.map_0.size_1() == 0 && undefined;
    }
    operationID = result.size_0;
    for (i = (!this$static.eOperations && (this$static.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, this$static, 11, 10)) , new AbstractEList$EIterator(this$static.eOperations)); i.cursor != i.this$01_2.size_1(); ++operationID) {
      castTo($doNext(i), 385);
    }
    $addAll_6(result, (!this$static.eOperations && (this$static.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, this$static, 11, 10)) , this$static.eOperations));
    $shrink_0(result);
    this$static.eAllOperations = new EcoreEList$UnmodifiableEList$FastCompare((castTo($get_16($getEStructuralFeatures(($clinit_EcorePackage() , eINSTANCE_2).eClassEClass), 9), 17) , result.size_0), result.data_0);
    this$static.eAllOperationsData = castTo(result.data_0, 630);
    this$static.eAllOperationsData == null && (this$static.eAllOperationsData = NO_EALL_OPERATIONS_DATA);
    $getESuperAdapter(this$static).modifiedState &= -17;
  }
  return this$static.eAllOperations;
}

function $getEAllReferences(this$static){
  var computationInProgress, eStructuralFeature, eStructuralFeature$iterator, eSuperType, eSuperType$iterator, old, references, result;
  if (!this$static.eAllReferences) {
    result = new EClassImpl$1ReferenceList;
    references = new EClassImpl$1ReferenceList;
    computationInProgress = COMPUTATION_IN_PROGRESS;
    old = computationInProgress.map_0.put(this$static, computationInProgress);
    if (old == null) {
      for (eSuperType$iterator = new AbstractEList$EIterator($getESuperTypes(this$static)); eSuperType$iterator.cursor != eSuperType$iterator.this$01_2.size_1();) {
        eSuperType = castTo($doNext(eSuperType$iterator), 26);
        $addAll_6(result, $getEAllReferences(eSuperType));
      }
      computationInProgress.map_0.remove(this$static) != null;
      computationInProgress.map_0.size_1() == 0 && undefined;
    }
    for (eStructuralFeature$iterator = (!this$static.eStructuralFeatures && (this$static.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this$static, 21, 17)) , new AbstractEList$EIterator(this$static.eStructuralFeatures)); eStructuralFeature$iterator.cursor != eStructuralFeature$iterator.this$01_2.size_1();) {
      eStructuralFeature = castTo($doNext(eStructuralFeature$iterator), 159);
      instanceOf(eStructuralFeature, 66) && $add_21(references, castTo(eStructuralFeature, 17));
    }
    $shrink_0(references);
    this$static.eReferences = new EClassImpl$5(this$static, (castTo($get_16($getEStructuralFeatures(($clinit_EcorePackage() , eINSTANCE_2).eClassEClass), 6), 17) , references.size_0), references.data_0);
    $addAll_6(result, this$static.eReferences);
    $shrink_0(result);
    this$static.eAllReferences = new EcoreEList$UnmodifiableEList$FastCompare((castTo($get_16($getEStructuralFeatures(eINSTANCE_2.eClassEClass), 5), 17) , result.size_0), result.data_0);
    $getESuperAdapter(this$static).modifiedState &= -3;
  }
  return this$static.eAllReferences;
}

function $getEAllStructuralFeatures(this$static){
  var computationInProgress, eSuperType, eSuperType$iterator, featureID, i, old, result;
  if (!this$static.eAllStructuralFeatures) {
    result = new EClassImpl$1EStructuralFeatureUniqueEList;
    computationInProgress = COMPUTATION_IN_PROGRESS;
    old = computationInProgress.map_0.put(this$static, computationInProgress);
    if (old == null) {
      for (eSuperType$iterator = new AbstractEList$EIterator($getESuperTypes(this$static)); eSuperType$iterator.cursor != eSuperType$iterator.this$01_2.size_1();) {
        eSuperType = castTo($doNext(eSuperType$iterator), 26);
        $addAll_6(result, $getEAllStructuralFeatures(eSuperType));
      }
      computationInProgress.map_0.remove(this$static) != null;
      computationInProgress.map_0.size_1() == 0 && undefined;
    }
    featureID = result.size_0;
    for (i = (!this$static.eStructuralFeatures && (this$static.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this$static, 21, 17)) , new AbstractEList$EIterator(this$static.eStructuralFeatures)); i.cursor != i.this$01_2.size_1(); ++featureID) {
      $setFeatureID(castTo($doNext(i), 426), featureID);
    }
    $addAll_6(result, (!this$static.eStructuralFeatures && (this$static.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this$static, 21, 17)) , this$static.eStructuralFeatures));
    $shrink_0(result);
    this$static.eAllStructuralFeatures = new EClassImpl$1EAllStructuralFeaturesList(this$static, result);
    this$static.eAllStructuralFeaturesData = castTo(result.data_0, 232);
    this$static.eAllStructuralFeaturesData == null && (this$static.eAllStructuralFeaturesData = NO_EALL_STRUCTURE_FEATURES_DATA);
    this$static.eNameToFeatureMap = null;
    $getESuperAdapter(this$static).modifiedState &= -5;
  }
  return this$static.eAllStructuralFeatures;
}

function $getEAllSuperTypes(this$static){
  var computationInProgress, eSuperType, eSuperType$iterator, higherSupers, old, result;
  if (!this$static.eAllSuperTypes) {
    result = new EClassImpl$9;
    computationInProgress = COMPUTATION_IN_PROGRESS;
    old = computationInProgress.map_0.put(this$static, computationInProgress);
    if (old == null) {
      for (eSuperType$iterator = new AbstractEList$EIterator($getESuperTypes(this$static)); eSuperType$iterator.cursor != eSuperType$iterator.this$01_2.size_1();) {
        eSuperType = castTo($doNext(eSuperType$iterator), 26);
        higherSupers = $getEAllSuperTypes(eSuperType);
        $addAll_6(result, higherSupers);
        $add_21(result, eSuperType);
      }
      computationInProgress.map_0.remove(this$static) != null;
    }
    $shrink_0(result);
    this$static.eAllSuperTypes = new EcoreEList$UnmodifiableEList$FastCompare((castTo($get_16($getEStructuralFeatures(($clinit_EcorePackage() , eINSTANCE_2).eClassEClass), 11), 17) , result.size_0), result.data_0);
    $getESuperAdapter(this$static).modifiedState &= -33;
  }
  return this$static.eAllSuperTypes;
}

function $getEGenericSuperTypes(this$static){
  if (!this$static.eGenericSuperTypes) {
    $getESuperAdapter(this$static);
    this$static.eGenericSuperTypes = new EClassImpl$1(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this$static);
    $getESuperTypes(this$static);
  }
  return this$static.eGenericSuperTypes;
}

function $getEOperations(this$static){
  !this$static.eOperations && (this$static.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, this$static, 11, 10));
  return this$static.eOperations;
}

function $getEStructuralFeature(this$static, featureID){
  var eAllStructuralFeaturesData;
  eAllStructuralFeaturesData = (this$static.eAllStructuralFeaturesData == null && $getEAllStructuralFeatures(this$static) , this$static.eAllStructuralFeaturesData);
  return featureID >= 0 && featureID < eAllStructuralFeaturesData.length?eAllStructuralFeaturesData[featureID]:null;
}

function $getEStructuralFeature_0(this$static, name_0){
  var duplicate, eStructuralFeature, eStructuralFeature$iterator, key, result;
  (this$static.eAllStructuralFeaturesData == null && $getEAllStructuralFeatures(this$static) , this$static.eAllStructuralFeaturesData).length;
  if (!this$static.eNameToFeatureMap) {
    result = new HashMap_0((3 * this$static.eAllStructuralFeatures.size_0 / 2 | 0) + 1);
    for (eStructuralFeature$iterator = new AbstractEList$NonResolvingEIterator(this$static.eAllStructuralFeatures); eStructuralFeature$iterator.cursor != eStructuralFeature$iterator.this$01_2.size_1();) {
      eStructuralFeature = castTo($doNext_0(eStructuralFeature$iterator), 159);
      key = eStructuralFeature.getName();
      duplicate = castTo(key == null?$put_4(result.hashCodeMap, null, eStructuralFeature):$put_5(result.stringMap, key, eStructuralFeature), 159);
      !!duplicate && (key == null?$put_4(result.hashCodeMap, null, duplicate):$put_5(result.stringMap, key, duplicate));
    }
    this$static.eNameToFeatureMap = result;
  }
  return castTo($getStringValue(this$static.eNameToFeatureMap, name_0), 159);
}

function $getEStructuralFeatures(this$static){
  !this$static.eStructuralFeatures && (this$static.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this$static, 21, 17));
  return this$static.eStructuralFeatures;
}

function $getESuperAdapter(this$static){
  if (!this$static.eSuperAdapter) {
    this$static.eSuperAdapter = new EClassImpl$10(this$static);
    $add_20(new MinimalEObjectImpl$1ArrayDelegatingAdapterList(this$static), 0, this$static.eSuperAdapter);
  }
  return this$static.eSuperAdapter;
}

function $getESuperTypes(this$static){
  if (!this$static.eSuperTypes) {
    $getESuperAdapter(this$static);
    this$static.eSuperTypes = new EClassImpl$8(this$static, this$static);
  }
  return this$static.eSuperTypes;
}

function $getFeatureCount(this$static){
  return (this$static.eAllStructuralFeaturesData == null && $getEAllStructuralFeatures(this$static) , this$static.eAllStructuralFeaturesData).length;
}

function $getFeatureID(this$static, feature){
  var eAllStructuralFeaturesData, index_0, last;
  eAllStructuralFeaturesData = (this$static.eAllStructuralFeaturesData == null && $getEAllStructuralFeatures(this$static) , this$static.eAllStructuralFeaturesData);
  index_0 = feature.getFeatureID_0();
  if (index_0 != -1) {
    for (last = eAllStructuralFeaturesData.length; index_0 < last; ++index_0) {
      if (eAllStructuralFeaturesData[index_0] == feature) {
        return index_0;
      }
    }
  }
  return -1;
}

function $isSetESuperTypes(this$static){
  return !!this$static.eSuperTypes && $getEGenericSuperTypes(this$static.eSuperTypes.this$01).size_0 != 0 && !(!!this$static.eGenericSuperTypes && $isSet(this$static.eGenericSuperTypes));
}

function $isSuperTypeOf(this$static, someClass){
  return someClass == this$static || $contains_10($getEAllSuperTypes(someClass), this$static);
}

function $setAbstract(this$static, newAbstract){
  var oldAbstract;
  oldAbstract = (this$static.eFlags & 256) != 0;
  newAbstract?(this$static.eFlags |= 256):(this$static.eFlags &= -257);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 8, oldAbstract, newAbstract));
}

function $setInterface(this$static, newInterface){
  var oldInterface;
  oldInterface = (this$static.eFlags & 512) != 0;
  newInterface?(this$static.eFlags |= 512):(this$static.eFlags &= -513);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 9, oldInterface, newInterface));
}

function $toString_27(this$static){
  var result;
  if ((this$static.eFlags_0 & 64) != 0)
    return $toString_26(this$static);
  result = new StringBuffer_1($toString_26(this$static));
  result.string += ' (abstract: ';
  $append_4(result, (this$static.eFlags & 256) != 0);
  result.string += ', interface: ';
  $append_4(result, (this$static.eFlags & 512) != 0);
  result.string += ')';
  return result.string;
}

function EClassImpl(){
  $clinit_EClassImpl();
}

defineClass(99, 689, {98:1, 92:1, 89:1, 26:1, 136:1, 143:1, 179:1, 51:1, 106:1, 46:1, 93:1, 99:1, 145:1, 448:1, 109:1, 110:1, 633:1}, EClassImpl);
_.dynamicIsInstance = function dynamicIsInstance_0(eObject){
  return $isSuperTypeOf(this, eObject.eClass_0());
}
;
_.eGet = function eGet_22(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return this.instanceClassName != null?this.instanceClassName:this.generatedInstanceClassName;
    case 3:
      return $getInstanceClass(this);
    case 4:
      return null;
    case 5:
      return this.instanceTypeName;
    case 6:
      if (resolve)
        return $getEPackage(this);
      return $basicGetEPackage(this);
    case 7:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7)) , this.eTypeParameters;
    case 8:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
    case 9:
      return $clinit_Boolean() , (this.eFlags & 512) != 0?true:false;
    case 10:
      return $getESuperTypes(this);
    case 11:
      return !this.eOperations && (this.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, this, 11, 10)) , this.eOperations;
    case 12:
      return $getEAllAttributes(this);
    case 13:
      return $getEAllReferences(this);
    case 14:
      return $getEAllReferences(this) , this.eReferences;
    case 15:
      return $getEAllAttributes(this) , this.eAttributes;
    case 16:
      return $getEAllContainments(this);
    case 17:
      return $getEAllOperations(this);
    case 18:
      return $getEAllStructuralFeatures(this);
    case 19:
      return $getEAllSuperTypes(this);
    case 20:
      return $getEAllAttributes(this) , this.eIDAttribute;
    case 21:
      return !this.eStructuralFeatures && (this.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this, 21, 17)) , this.eStructuralFeatures;
    case 22:
      return $getEGenericSuperTypes(this);
    case 23:
      return $getEAllGenericSuperTypes(this);
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ECLASS)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ECLASS:eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_14(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 6:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_7(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $eBasicSetContainer(this, otherEnd, 6, msgs);
    case 11:
      return !this.eOperations && (this.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, this, 11, 10)) , $basicAdd_0(this.eOperations, otherEnd, msgs);
    case 21:
      return !this.eStructuralFeatures && (this.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this, 21, 17)) , $basicAdd_0(this.eStructuralFeatures, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , ECLASS):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ECLASS)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_16(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 6:
      return $eBasicSetContainer(this, null, 6, msgs);
    case 7:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7)) , $basicRemove_0(this.eTypeParameters, otherEnd, msgs);
    case 11:
      return !this.eOperations && (this.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, this, 11, 10)) , $basicRemove_0(this.eOperations, otherEnd, msgs);
    case 21:
      return !this.eStructuralFeatures && (this.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this, 21, 17)) , $basicRemove_0(this.eStructuralFeatures, otherEnd, msgs);
    case 22:
      return $basicRemove_0($getEGenericSuperTypes(this), otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , ECLASS):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ECLASS)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_21(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return this.instanceClassName != null && this.instanceClassName == this.instanceTypeName;
    case 3:
      return !!$getInstanceClass(this);
    case 4:
      return false;
    case 5:
      return this.instanceTypeName != null && this.instanceTypeName != this.instanceClassName && this.instanceTypeName != this.generatedInstanceClassName;
    case 6:
      return !!$basicGetEPackage(this);
    case 7:
      return !!this.eTypeParameters && this.eTypeParameters.size_0 != 0;
    case 8:
      return (this.eFlags & 256) != 0;
    case 9:
      return (this.eFlags & 512) != 0;
    case 10:
      return !!this.eSuperTypes && $getEGenericSuperTypes(this.eSuperTypes.this$01).size_0 != 0 && !(!!this.eGenericSuperTypes && $isSet(this.eGenericSuperTypes));
    case 11:
      return !!this.eOperations && this.eOperations.size_0 != 0;
    case 12:
      return $getEAllAttributes(this).size_0 != 0;
    case 13:
      return $getEAllReferences(this).size_0 != 0;
    case 14:
      return $getEAllReferences(this) , this.eReferences.size_0 != 0;
    case 15:
      return $getEAllAttributes(this) , this.eAttributes.size_0 != 0;
    case 16:
      return $getEAllContainments(this).size_0 != 0;
    case 17:
      return $getEAllOperations(this).size_0 != 0;
    case 18:
      return $getEAllStructuralFeatures(this).size_0 != 0;
    case 19:
      return $getEAllSuperTypes(this).size_0 != 0;
    case 20:
      return $getEAllAttributes(this) , !!this.eIDAttribute;
    case 21:
      return !!this.eStructuralFeatures && this.eStructuralFeatures.size_0 != 0;
    case 22:
      return !!this.eGenericSuperTypes && $isSet(this.eGenericSuperTypes);
    case 23:
      return $getEAllGenericSuperTypes(this).size_0 != 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ECLASS)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ECLASS:eClass), featureID));
}
;
_.eObjectForURIFragmentSegment = function eObjectForURIFragmentSegment_2(uriFragmentSegment){
  var result;
  result = this.eAllStructuralFeaturesData == null || !!this.eOperations && this.eOperations.size_0 != 0?null:$getEStructuralFeature_0(this, uriFragmentSegment);
  return result?result:$eObjectForURIFragmentSegment_0(this, uriFragmentSegment);
}
;
_.eSet = function eSet_20(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName_1(this, castToString(newValue));
      return;
    case 2:
      $setInstanceClassName(this, castToString(newValue));
      return;
    case 5:
      $setInstanceTypeName(this, castToString(newValue));
      return;
    case 7:
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7));
      $clear_11(this.eTypeParameters);
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7));
      $addAll_6(this.eTypeParameters, castTo(newValue, 13));
      return;
    case 8:
      $setAbstract(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 9:
      $setInterface(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 10:
      $clear_10($getESuperTypes(this));
      $addAll_6($getESuperTypes(this), castTo(newValue, 13));
      return;
    case 11:
      !this.eOperations && (this.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, this, 11, 10));
      $clear_11(this.eOperations);
      !this.eOperations && (this.eOperations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EOperation_2_classLit, this, 11, 10));
      $addAll_6(this.eOperations, castTo(newValue, 13));
      return;
    case 21:
      !this.eStructuralFeatures && (this.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this, 21, 17));
      $clear_11(this.eStructuralFeatures);
      !this.eStructuralFeatures && (this.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, this, 21, 17));
      $addAll_6(this.eStructuralFeatures, castTo(newValue, 13));
      return;
    case 22:
      $clear_11($getEGenericSuperTypes(this));
      $addAll_6($getEGenericSuperTypes(this), castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ECLASS)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ECLASS:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_21(){
  return $clinit_EcorePackage$Literals() , ECLASS;
}
;
_.freeze = function freeze_4(){
  var i, size_0;
  $getEAllAttributes(this);
  $getEAllReferences(this);
  $getEAllContainments(this);
  $getEAllOperations(this);
  $getEAllStructuralFeatures(this);
  $getEAllSuperTypes(this);
  $getEAllGenericSuperTypes(this);
  $clear_9($getSubclasses($getESuperAdapter(this)));
  if (this.eStructuralFeatures) {
    for (i = 0 , size_0 = this.eStructuralFeatures.size_0; i < size_0; ++i) {
      $freeze($get_16(this.eStructuralFeatures, i));
    }
  }
  if (this.eOperations) {
    for (i = 0 , size_0 = this.eOperations.size_0; i < size_0; ++i) {
      $freeze($get_16(this.eOperations, i));
    }
  }
  $getExtendedMetaData(($clinit_ExtendedMetaData() , INSTANCE_11), this).getName();
  this.eFlags |= 1;
}
;
_.toString_0 = function toString_148(){
  return $toString_27(this);
}
;
_.eAttributes = null;
_.eReferences = null;
var COMPUTATION_IN_PROGRESS, NO_EALL_OPERATIONS_DATA, NO_EALL_STRUCTURE_FEATURES_DATA;
var Lorg_eclipse_emf_ecore_impl_EClassImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl', 99);
defineClass(1771, 1770, $intern_155);
_.addAllUnique_0 = function addAllUnique_6(index_0, collection){
  return $addAllUnique_3(this, index_0, collection);
}
;
_.addAllUnique = function addAllUnique_7(collection){
  return $addAllUnique_3(this, this.size_0, collection);
}
;
_.addUnique = function addUnique_9(index_0, object){
  $addUnique_5(this, index_0, object);
}
;
_.addUnique_0 = function addUnique_10(object){
  $addUnique_6(this, object);
}
;
_.basicAdd = function basicAdd_0(object, notifications){
  return $basicAdd_0(this, object, notifications);
}
;
_.basicGet = function basicGet_1(index_0){
  return $basicGet(this, index_0);
}
;
_.basicRemove = function basicRemove_0(object, notifications){
  return $basicRemove_0(this, object, notifications);
}
;
_.setUnique = function setUnique_4(index_0, object){
  return $setUnique_1(this, index_0, object);
}
;
_.basicIterator = function basicIterator_2(){
  return new AbstractEList$NonResolvingEIterator(this);
}
;
_.basicListIterator = function basicListIterator_5(){
  return new AbstractEList$NonResolvingEListIterator(this);
}
;
_.basicListIterator_0 = function basicListIterator_6(index_0){
  return $basicListIterator(this, index_0);
}
;
var Lorg_eclipse_emf_ecore_util_NotifyingInternalEListImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'NotifyingInternalEListImpl', 1771);
function $contains_11(this$static, object){
  var containedEObject, eContainer, eObject, i, opposite, result, result0;
  if (this$static.isEObject()) {
    if (this$static.size_0 > 4) {
      if (this$static.isInstance(object)) {
        if (this$static.isContainment()) {
          eObject = castTo(object, 46);
          eContainer = eObject.eContainer_0();
          result0 = eContainer == this$static.owner && (this$static.hasNavigableInverse()?eObject.eBaseStructuralFeatureID(eObject.eContainerFeatureID_0(), this$static.getInverseFeatureClass()) == this$static.getInverseFeatureID():-1 - eObject.eContainerFeatureID_0() == this$static.getFeatureID_0());
          if (this$static.hasProxies() && !result0 && !eContainer && !!eObject.eDirectResource()) {
            for (i = 0; i < this$static.size_0; ++i) {
              containedEObject = this$static.resolveProxy(castTo(this$static.data_0[i], 51));
              if (maskUndefined(containedEObject) === maskUndefined(object)) {
                return true;
              }
            }
          }
          return result0;
        }
         else if (this$static.hasNavigableInverse() && !this$static.hasManyInverse()) {
          opposite = castTo(object, 51).eGet_0($getEOpposite(castTo(this$static.getEStructuralFeature(), 17)));
          if (maskUndefined(opposite) === maskUndefined(this$static.owner)) {
            return true;
          }
           else if (opposite == null || !castTo(opposite, 51).eIsProxy()) {
            return false;
          }
        }
      }
       else {
        return false;
      }
    }
    result = $contains_10(this$static, object);
    if (this$static.hasProxies() && !result) {
      for (i = 0; i < this$static.size_0; ++i) {
        eObject = this$static.resolveProxy(castTo(this$static.data_0[i], 51));
        if (maskUndefined(eObject) === maskUndefined(object)) {
          return true;
        }
      }
    }
    return result;
  }
   else {
    return $contains_10(this$static, object);
  }
}

function $createNotification(this$static, eventType, oldObject, newObject, index_0, wasSet){
  return new ENotificationImpl_3(this$static.owner, eventType, this$static.getFeatureID_0(), oldObject, newObject, index_0, wasSet);
}

function $dispatchNotification(this$static, notification){
  $eNotify(this$static.owner, notification);
}

function $indexOf_6(this$static, object){
  var eObject, i, index_0;
  index_0 = $indexOf_4(this$static, object);
  if (index_0 >= 0)
    return index_0;
  if (this$static.isEObject()) {
    for (i = 0; i < this$static.size_0; ++i) {
      eObject = this$static.resolveProxy(castTo(this$static.data_0[i], 51));
      if (maskUndefined(eObject) === maskUndefined(object)) {
        return i;
      }
    }
  }
  return -1;
}

function $resolve(this$static, index_0, eObject){
  var notificationChain, oldObject, resolved;
  resolved = this$static.resolveProxy(eObject);
  if (resolved != eObject) {
    oldObject = this$static.data_0[index_0];
    $assign(this$static, index_0, this$static.validate(index_0, resolved));
    this$static.didSet(index_0, resolved, oldObject);
    if (this$static.isContainment()) {
      notificationChain = this$static.inverseRemove(eObject, null);
      !castTo(resolved, 46).eInternalContainer() && (notificationChain = this$static.inverseAdd(resolved, notificationChain));
      !!notificationChain && notificationChain.dispatch_0();
    }
    $eNotificationRequired(this$static.owner) && $dispatchNotification(this$static, this$static.createNotification(9, eObject, resolved, index_0, false));
    return resolved;
  }
   else {
    return eObject;
  }
}

function $set_12(this$static, newValue){
  $clear_11(this$static);
  this$static.addAll(castTo(newValue, 15));
}

function $validate_0(this$static, index_0, object){
  $validate(this$static, object);
  if (!this$static.hasInstanceClass() && object != null && !this$static.isInstance(object)) {
    throw toJs(new ArrayStoreException);
  }
  return object;
}

function EcoreEList(dataClass, owner){
  this.dataClass = dataClass;
  this.owner = owner;
}

defineClass(589, 1771, $intern_156);
_.contains = function contains_57(object){
  return $contains_11(this, object);
}
;
_.createNotification = function createNotification_1(eventType, oldObject, newObject, index_0, wasSet){
  return $createNotification(this, eventType, oldObject, newObject, index_0, wasSet);
}
;
_.dispatchNotification = function dispatchNotification_1(notification){
  $dispatchNotification(this, notification);
}
;
_.get_6 = function get_47(resolve){
  return this;
}
;
_.getEStructuralFeature = function getEStructuralFeature_0(){
  return $getEStructuralFeature(this.owner.eClass_0(), this.getFeatureID_0());
}
;
_.getFeature = function getFeature_4(){
  return this.getEStructuralFeature();
}
;
_.getFeatureID_0 = function getFeatureID_5(){
  return $getFeatureID(this.owner.eClass_0(), this.getEStructuralFeature());
}
;
_.getInverseFeatureClass = function getInverseFeatureClass(){
  return castTo(this.getEStructuralFeature().getEType(), 26).getInstanceClass();
}
;
_.getInverseFeatureID = function getInverseFeatureID(){
  return $getEOpposite(castTo(this.getEStructuralFeature(), 17)).featureID;
}
;
_.getNotifier = function getNotifier_4(){
  return this.owner;
}
;
_.hasInstanceClass = function hasInstanceClass(){
  return true;
}
;
_.hasManyInverse = function hasManyInverse(){
  return false;
}
;
_.hasNavigableInverse = function hasNavigableInverse(){
  return false;
}
;
_.hasProxies = function hasProxies(){
  return false;
}
;
_.indexOf_0 = function indexOf_14(object){
  return $indexOf_6(this, object);
}
;
_.inverseAdd = function inverseAdd_1(object, notifications){
  var internalEObject;
  return internalEObject = castTo(object, 46) , this.hasNavigableInverse()?this.hasInstanceClass()?internalEObject.eInverseAdd(this.owner, this.getInverseFeatureID(), this.getInverseFeatureClass(), notifications):internalEObject.eInverseAdd(this.owner, $getFeatureID(internalEObject.eClass_0(), $getEOpposite(castTo(this.getEStructuralFeature(), 17))), null, notifications):internalEObject.eInverseAdd(this.owner, -1 - this.getFeatureID_0(), null, notifications);
}
;
_.inverseRemove = function inverseRemove_1(object, notifications){
  var internalEObject;
  return internalEObject = castTo(object, 46) , this.hasNavigableInverse()?this.hasInstanceClass()?internalEObject.eInverseRemove(this.owner, this.getInverseFeatureID(), this.getInverseFeatureClass(), notifications):internalEObject.eInverseRemove(this.owner, $getFeatureID(internalEObject.eClass_0(), $getEOpposite(castTo(this.getEStructuralFeature(), 17))), null, notifications):internalEObject.eInverseRemove(this.owner, -1 - this.getFeatureID_0(), null, notifications);
}
;
_.isContainment = function isContainment_1(){
  return false;
}
;
_.isEObject = function isEObject(){
  return true;
}
;
_.isInstance = function isInstance_1(object){
  return isInstance(this.dataClass, object);
}
;
_.isNotificationRequired = function isNotificationRequired_1(){
  return $eNotificationRequired(this.owner);
}
;
_.isSet_0 = function isSet_2(){
  return this.size_0 != 0;
}
;
_.newData = function newData_3(capacity){
  return newInstance_10(this.dataClass, capacity);
}
;
_.resolve = function resolve_1(index_0, object){
  return this.isEObject() && this.hasProxies()?$resolve(this, index_0, castTo(object, 51)):object;
}
;
_.resolveProxy = function resolveProxy(eObject){
  return eObject.eIsProxy()?$eResolveProxy(this.owner, castTo(eObject, 46)):eObject;
}
;
_.set_1 = function set_31(newValue){
  $set_12(this, newValue);
}
;
_.toArray = function toArray_40(){
  var i;
  if (this.hasProxies()) {
    for (i = this.size_0 - 1; i >= 0; --i) {
      $get_16(this, i);
    }
  }
  return $toArray_5(this);
}
;
_.toArray_0 = function toArray_41(array){
  var i;
  if (this.hasProxies()) {
    for (i = this.size_0 - 1; i >= 0; --i) {
      $get_16(this, i);
    }
  }
  return $toArray_6(this, array);
}
;
_.unset = function unset_0(){
  $clear_11(this);
}
;
_.validate = function validate_0(index_0, object){
  return $validate_0(this, index_0, object);
}
;
var Lorg_eclipse_emf_ecore_util_EcoreEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEList', 589);
function EObjectEList(dataClass, owner, featureID){
  EcoreEList.call(this, dataClass, owner);
  this.featureID = featureID;
}

defineClass(466, 589, $intern_156, EObjectEList);
_.canContainNull = function canContainNull_2(){
  return false;
}
;
_.getFeatureID_0 = function getFeatureID_6(){
  return this.featureID;
}
;
_.hasInverse = function hasInverse_1(){
  return false;
}
;
_.isEObject = function isEObject_0(){
  return true;
}
;
_.isUnique = function isUnique_3(){
  return true;
}
;
_.resolve = function resolve_2(index_0, object){
  return object;
}
;
_.useEquals = function useEquals_1(){
  return false;
}
;
_.featureID = 0;
var Lorg_eclipse_emf_ecore_util_EObjectEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectEList', 466);
function EObjectContainmentEList(dataClass, owner, featureID){
  EObjectEList.call(this, dataClass, owner, featureID);
}

defineClass(84, 466, $intern_156, EObjectContainmentEList);
_.hasInverse = function hasInverse_2(){
  return true;
}
;
_.hasNavigableInverse = function hasNavigableInverse_0(){
  return false;
}
;
_.isContainment = function isContainment_2(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_EObjectContainmentEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectContainmentEList', 84);
function EObjectContainmentEList$Unsettable(dataClass, owner, featureID){
  EObjectContainmentEList.call(this, dataClass, owner, featureID);
}

defineClass(509, 84, $intern_156, EObjectContainmentEList$Unsettable);
_.didChange = function didChange_0(){
  this.isSet = true;
}
;
_.isSet_0 = function isSet_3(){
  return this.isSet;
}
;
_.unset = function unset_1(){
  var oldIsSet;
  $clear_11(this);
  if ($eNotificationRequired(this.owner)) {
    oldIsSet = this.isSet;
    this.isSet = false;
    $eNotify(this.owner, new ENotificationImpl_4(this.owner, 2, this.featureID, oldIsSet, false));
  }
   else {
    this.isSet = false;
  }
}
;
_.isSet = false;
var Lorg_eclipse_emf_ecore_util_EObjectContainmentEList$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectContainmentEList/Unsettable', 509);
function $isSet(this$static){
  var eGenericType, eGenericType$iterator;
  for (eGenericType$iterator = new AbstractEList$EIterator(this$static); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    if (!!eGenericType.eTypeParameter || (!eGenericType.eTypeArguments && (eGenericType.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, eGenericType, 1)) , eGenericType.eTypeArguments).size_0 != 0) {
      return true;
    }
  }
  return false;
}

function $shadowAdd(this$static, eGenericType, notifications){
  var notification, result;
  notification = new ENotificationImpl_3(this$static.owner, 3, 10, null, (result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT)), $indexOf_6(this$static, eGenericType), false);
  !notifications?(notifications = notification):notifications.add_4(notification);
  return notifications;
}

function $shadowRemove(this$static, eGenericType, notifications){
  var notification, result;
  notification = new ENotificationImpl_3(this$static.owner, 4, 10, (result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT)), null, $indexOf_6(this$static, eGenericType), false);
  !notifications?(notifications = notification):notifications.add_4(notification);
  return notifications;
}

function $shadowSet(this$static, oldEGenericType, newEGenericType, notifications){
  var notification, result, result0;
  notification = new ENotificationImpl_3(this$static.owner, 1, 10, (result0 = oldEGenericType.eRawType , instanceOf(result0, 99)?castTo(result0, 26):($clinit_EcorePackage$Literals() , EOBJECT)), (result = newEGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT)), $indexOf_6(this$static, oldEGenericType), false);
  !notifications?(notifications = notification):notifications.add_4(notification);
  return notifications;
}

function EClassImpl$1($anonymous0, $anonymous1){
  EObjectContainmentEList$Unsettable.call(this, $anonymous0, $anonymous1, 22);
}

defineClass(1028, 509, $intern_156, EClassImpl$1);
_.shadowAdd = function shadowAdd_0(eGenericType, notifications){
  return $shadowAdd(this, castTo(eGenericType, 86), notifications);
}
;
_.shadowRemove = function shadowRemove_0(eGenericType, notifications){
  return $shadowRemove(this, castTo(eGenericType, 86), notifications);
}
;
_.shadowSet = function shadowSet_0(oldEGenericType, newEGenericType, notifications){
  return $shadowSet(this, castTo(oldEGenericType, 86), castTo(newEGenericType, 86), notifications);
}
;
_.createNotification = function createNotification_2(eventType, oldObject, newObject, index_0, wasSet){
  switch (eventType) {
    case 3:
      {
        return $createNotification(this, 3, oldObject, newObject, index_0, this.size_0 > 1);
      }

    case 5:
      {
        return $createNotification(this, 5, oldObject, newObject, index_0, this.size_0 - castTo(newObject, 15).size_1() > 0);
      }

    default:{
        return new ENotificationImpl_3(this.owner, eventType, this.featureID, oldObject, newObject, index_0, true);
      }

  }
}
;
_.hasShadow = function hasShadow_0(){
  return true;
}
;
_.isSet_0 = function isSet_4(){
  return $isSet(this);
}
;
_.unset = function unset_2(){
  $clear_11(this);
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/1', 1028);
function $getSubclasses(this$static){
  !this$static.subclasses && (this$static.subclasses = new ESuperAdapter$1);
  return this$static.subclasses;
}

function $setFlags(this$static, featureId){
  var eSuperAdapter, i, oldModifiedState, subclass;
  oldModifiedState = this$static.modifiedState;
  switch (featureId) {
    case 1:
      {
        this$static.modifiedState |= 1;
        this$static.modifiedState |= 4;
        this$static.modifiedState |= 8;
        break;
      }

    case 2:
      {
        this$static.modifiedState |= 2;
        this$static.modifiedState |= 4;
        this$static.modifiedState |= 8;
        break;
      }

    case 4:
      {
        this$static.modifiedState |= 1;
        this$static.modifiedState |= 2;
        this$static.modifiedState |= 4;
        this$static.modifiedState |= 8;
        break;
      }

    case 3:
      {
        this$static.modifiedState |= 16;
        this$static.modifiedState |= 8;
        break;
      }

    case 0:
      {
        this$static.modifiedState |= 32;
        this$static.modifiedState |= 16;
        this$static.modifiedState |= 8;
        this$static.modifiedState |= 1;
        this$static.modifiedState |= 2;
        this$static.modifiedState |= 4;
        break;
      }

  }
  if (this$static.modifiedState != oldModifiedState && !!this$static.subclasses) {
    for (i = new AbstractEList$EIterator(this$static.subclasses); i.cursor != i.this$01_2.size_1();) {
      subclass = castTo($doNext(i), 448);
      eSuperAdapter = $getESuperAdapter(subclass);
      $setFlags_0(eSuperAdapter, featureId);
    }
  }
}

function getFeatureID_7(notification){
  var featureID;
  featureID = notification.getFeatureID(null);
  switch (featureID) {
    case 10:
      return 0;
    case 15:
      return 1;
    case 14:
      return 2;
    case 11:
      return 3;
    case 21:
      return 4;
  }
  return -1;
}

defineClass(1042, 1041, $intern_143);
_.notifyChanged = function notifyChanged_0(notification){
  var eSuperAdapter, eventType, featureID, holder, i, newValue, oldValue;
  eventType = notification.getEventType();
  if (eventType != 8) {
    featureID = getFeatureID_7(notification);
    if (featureID == 0) {
      switch (eventType) {
        case 1:
        case 9:
          {
            oldValue = notification.getOldValue();
            if (oldValue != null) {
              eSuperAdapter = $getESuperAdapter(castTo(oldValue, 448));
              !eSuperAdapter.subclasses && (eSuperAdapter.subclasses = new ESuperAdapter$1);
              $remove_31(eSuperAdapter.subclasses, notification.getNotifier());
            }
            newValue = notification.getNewValue();
            if (newValue != null) {
              holder = castTo(newValue, 448);
              if ((holder.eFlags & 1) == 0) {
                eSuperAdapter = $getESuperAdapter(holder);
                !eSuperAdapter.subclasses && (eSuperAdapter.subclasses = new ESuperAdapter$1);
                $add_21(eSuperAdapter.subclasses, castTo(notification.getNotifier(), 26));
              }
            }
            break;
          }

        case 3:
          {
            newValue = notification.getNewValue();
            if (newValue != null) {
              holder = castTo(newValue, 448);
              if ((holder.eFlags & 1) == 0) {
                eSuperAdapter = $getESuperAdapter(holder);
                !eSuperAdapter.subclasses && (eSuperAdapter.subclasses = new ESuperAdapter$1);
                $add_21(eSuperAdapter.subclasses, castTo(notification.getNotifier(), 26));
              }
            }
            break;
          }

        case 5:
          {
            newValue = notification.getNewValue();
            if (newValue != null) {
              for (i = castTo(newValue, 13).iterator_0(); i.hasNext_0();) {
                holder = castTo(i.next_1(), 448);
                if ((holder.eFlags & 1) == 0) {
                  eSuperAdapter = $getESuperAdapter(holder);
                  !eSuperAdapter.subclasses && (eSuperAdapter.subclasses = new ESuperAdapter$1);
                  $add_21(eSuperAdapter.subclasses, castTo(notification.getNotifier(), 26));
                }
              }
            }
            break;
          }

        case 4:
          {
            oldValue = notification.getOldValue();
            if (oldValue != null) {
              holder = castTo(oldValue, 448);
              if ((holder.eFlags & 1) == 0) {
                eSuperAdapter = $getESuperAdapter(holder);
                !eSuperAdapter.subclasses && (eSuperAdapter.subclasses = new ESuperAdapter$1);
                $remove_31(eSuperAdapter.subclasses, notification.getNotifier());
              }
            }
            break;
          }

        case 6:
          {
            oldValue = notification.getOldValue();
            if (oldValue != null) {
              for (i = castTo(oldValue, 13).iterator_0(); i.hasNext_0();) {
                holder = castTo(i.next_1(), 448);
                if ((holder.eFlags & 1) == 0) {
                  eSuperAdapter = $getESuperAdapter(holder);
                  !eSuperAdapter.subclasses && (eSuperAdapter.subclasses = new ESuperAdapter$1);
                  $remove_31(eSuperAdapter.subclasses, notification.getNotifier());
                }
              }
            }
            break;
          }

      }
    }
    this.setFlags(featureID);
  }
}
;
_.setFlags = function setFlags(featureId){
  $setFlags(this, featureId);
}
;
_.modifiedState = 63;
var Lorg_eclipse_emf_ecore_impl_ESuperAdapter_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ESuperAdapter', 1042);
function $setFlags_0(this$static, featureId){
  $setFlags(this$static, featureId);
  (this$static.modifiedState & 1) != 0 && (this$static.this$01.eAllAttributes = null);
  (this$static.modifiedState & 2) != 0 && (this$static.this$01.eAllReferences = null);
  if ((this$static.modifiedState & 4) != 0) {
    this$static.this$01.eAllStructuralFeatures = null;
    this$static.this$01.eAllStructuralFeaturesData = null;
  }
  if ((this$static.modifiedState & 16) != 0) {
    this$static.this$01.eAllOperations = null;
    this$static.this$01.eAllOperationsData = null;
  }
  (this$static.modifiedState & 8) != 0 && (this$static.this$01.eAllContainments = null);
  if ((this$static.modifiedState & 32) != 0) {
    this$static.this$01.eAllSuperTypes = null;
    this$static.this$01.eAllGenericSuperTypes = null;
  }
}

function EClassImpl$10(this$0){
  this.this$01 = this$0;
}

defineClass(1043, 1042, $intern_143, EClassImpl$10);
_.setFlags = function setFlags_0(featureId){
  $setFlags_0(this, featureId);
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$10_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/10', 1043);
defineClass(1032, 652, $intern_156);
_.addAllUnique = function addAllUnique_8(collection){
  return $addAllUnique_0(this, collection);
}
;
_.addUnique = function addUnique_11(index_0, object){
  $addUnique(this, index_0, object);
}
;
_.addUnique_0 = function addUnique_12(object){
  $addUnique_0(this, object);
}
;
_.basicGet = function basicGet_2(index_0){
  return $basicGet(this, index_0);
}
;
_.setUnique = function setUnique_5(index_0, object){
  return $setUnique(this, index_0, object);
}
;
_.basicAdd = function basicAdd_1(object, notifications){
  throw toJs(new UnsupportedOperationException);
}
;
_.basicIterator = function basicIterator_3(){
  return new AbstractEList$NonResolvingEIterator(this);
}
;
_.basicListIterator = function basicListIterator_7(){
  return new AbstractEList$NonResolvingEListIterator(this);
}
;
_.basicListIterator_0 = function basicListIterator_8(index_0){
  return $basicListIterator(this, index_0);
}
;
_.basicRemove = function basicRemove_1(object, notifications){
  throw toJs(new UnsupportedOperationException);
}
;
_.get_6 = function get_48(resolve){
  return this;
}
;
_.isSet_0 = function isSet_5(){
  return this.size_0 != 0;
}
;
_.set_1 = function set_32(newValue){
  throw toJs(new UnsupportedOperationException);
}
;
_.unset = function unset_3(){
  throw toJs(new UnsupportedOperationException);
}
;
var Lorg_eclipse_emf_ecore_util_EcoreEList$UnmodifiableEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEList/UnmodifiableEList', 1032);
function EcoreEList$UnmodifiableEList$FastCompare(size_0, data_0){
  BasicEList$UnmodifiableEList.call(this, size_0, data_0);
}

defineClass(308, 1032, $intern_156, EcoreEList$UnmodifiableEList$FastCompare);
_.useEquals = function useEquals_2(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_util_EcoreEList$UnmodifiableEList$FastCompare_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEList/UnmodifiableEList/FastCompare', 308);
function $containments(this$static){
  maskUndefined(this$static.containments) === maskUndefined(($clinit_EClassImpl() , NO_EALL_STRUCTURE_FEATURES_DATA)) && $init_2(this$static);
  return this$static.containments;
}

function $init_2(this$static){
  var containmentsList, crossReferencesList, eAnnotation, eAnnotation0, eAnnotation1, eReference, eStructuralFeature, i, isMixed, theOpposite;
  containmentsList = new EClassImpl$1EStructuralFeatureUniqueEList;
  crossReferencesList = new EClassImpl$1EStructuralFeatureUniqueEList;
  isMixed = $equals_4('mixed', (eAnnotation0 = $getEAnnotation(this$static.this$01, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData') , !eAnnotation0?null:castToString($get_17((!eAnnotation0.details && (eAnnotation0.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation0)) , eAnnotation0.details), 'kind'))));
  for (i = 0; i < this$static.size_0; ++i) {
    eStructuralFeature = castTo(this$static.data_0[i], 159);
    if (instanceOf(eStructuralFeature, 66)) {
      eReference = castTo(eStructuralFeature, 17);
      (eReference.eFlags & $intern_138) != 0?((eReference.eFlags & $intern_21) == 0 || !isMixed && (eAnnotation1 = $getEAnnotation(eReference, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData') , (!eAnnotation1?null:castToString($get_17((!eAnnotation1.details && (eAnnotation1.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation1)) , eAnnotation1.details), 'group'))) == null)) && $add_21(containmentsList, eReference):(theOpposite = $getEOpposite(eReference) , !!theOpposite && (theOpposite.eFlags & $intern_138) != 0 || ((eReference.eFlags & $intern_21) == 0 || !isMixed && (eAnnotation = $getEAnnotation(eReference, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData') , (!eAnnotation?null:castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'group'))) == null)) && $add_21(crossReferencesList, eReference));
    }
     else {
      $clinit_FeatureMapUtil();
      if (castTo(eStructuralFeature, 63).isFeatureMap_0()) {
        if (!eStructuralFeature.isDerived()) {
          $add_21(containmentsList, eStructuralFeature);
          $add_21(crossReferencesList, eStructuralFeature);
        }
      }
    }
  }
  $shrink_0(containmentsList);
  $shrink_0(crossReferencesList);
  this$static.containments = castTo(containmentsList.data_0, 232);
  castTo(crossReferencesList.data_0, 232);
}

function EClassImpl$1EAllStructuralFeaturesList(this$0, eAllStructuralFeatures){
  this.this$01 = this$0;
  EcoreEList$UnmodifiableEList$FastCompare.call(this, (castTo($get_16($getEStructuralFeatures(($clinit_EcorePackage() , eINSTANCE_2).eClassEClass), 10), 17) , eAllStructuralFeatures.size_0), eAllStructuralFeatures.data_0);
  this.containments = ($clinit_EClassImpl() , NO_EALL_STRUCTURE_FEATURES_DATA);
}

defineClass(1035, 308, $intern_156, EClassImpl$1EAllStructuralFeaturesList);
_.indexOf_0 = function indexOf_15(object){
  var eStructuralFeature, index_0, last;
  if (instanceOf(object, 159)) {
    eStructuralFeature = castTo(object, 159);
    index_0 = eStructuralFeature.getFeatureID_0();
    if (index_0 != -1) {
      for (last = this.size_0; index_0 < last; ++index_0) {
        if (maskUndefined(this.data_0[index_0]) === maskUndefined(object)) {
          return index_0;
        }
      }
    }
  }
  return -1;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$1EAllStructuralFeaturesList_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/1EAllStructuralFeaturesList', 1035);
function $eliminateEquivalentDuplicates(this$static){
  var eGenericType, eGenericTypes, i, j, otherEGenericType;
  eGenericTypes = castTo(this$static.data_0, 631);
  for (i = this$static.size_0 - 1; i >= 0; --i) {
    eGenericType = eGenericTypes[i];
    for (j = 0; j < i; ++j) {
      otherEGenericType = eGenericTypes[j];
      if ($equivalent(this$static, eGenericType, otherEGenericType)) {
        $remove_32(this$static, i);
        break;
      }
    }
  }
}

function $equivalent(this$static, eGenericType, otherEGenericType){
  var eClassifier, eTypeArgument, eTypeArgumentSize, eTypeArguments, eTypeParameter, instanceTypeName, j, otherEClassifier, otherETypeArgument, otherETypeArguments, otherETypeParameter, otherInstanceTypeName;
  if (eGenericType == otherEGenericType) {
    return true;
  }
   else {
    eGenericType = $resolve_0(this$static, eGenericType);
    otherEGenericType = $resolve_0(this$static, otherEGenericType);
    eClassifier = $getEClassifier(eGenericType);
    if (eClassifier) {
      otherEClassifier = $getEClassifier(otherEGenericType);
      if (otherEClassifier != eClassifier) {
        if (!otherEClassifier) {
          return false;
        }
         else {
          instanceTypeName = eClassifier.getInstanceTypeName();
          otherInstanceTypeName = otherEClassifier.getInstanceTypeName();
          return instanceTypeName == otherInstanceTypeName && instanceTypeName != null;
        }
      }
       else {
        eTypeArguments = (!eGenericType.eTypeArguments && (eGenericType.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, eGenericType, 1)) , eGenericType.eTypeArguments);
        eTypeArgumentSize = eTypeArguments.size_0;
        otherETypeArguments = (!otherEGenericType.eTypeArguments && (otherEGenericType.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, otherEGenericType, 1)) , otherEGenericType.eTypeArguments);
        if (eTypeArgumentSize == otherETypeArguments.size_0) {
          for (j = 0; j < eTypeArgumentSize; ++j) {
            eTypeArgument = castTo($get_16(eTypeArguments, j), 86);
            otherETypeArgument = castTo($get_16(otherETypeArguments, j), 86);
            if (!$equivalent(this$static, eTypeArgument, otherETypeArgument)) {
              return false;
            }
          }
        }
        return true;
      }
    }
     else {
      eTypeParameter = eGenericType.eTypeParameter;
      otherETypeParameter = otherEGenericType.eTypeParameter;
      return eTypeParameter == otherETypeParameter;
    }
  }
}

function $resolve_0(this$static, eGenericType){
  var eContainer, eGenericTypes, eTypeArguments, eTypeParameter, i, index_0, otherEGenericType;
  eTypeParameter = eGenericType.eTypeParameter;
  if (eTypeParameter) {
    eContainer = $eContainer(eTypeParameter);
    eGenericTypes = castTo(this$static.data_0, 631);
    for (i = 0; i < this$static.size_0; ++i) {
      otherEGenericType = eGenericTypes[i];
      if ($getEClassifier(otherEGenericType) == eContainer) {
        eTypeArguments = (!otherEGenericType.eTypeArguments && (otherEGenericType.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, otherEGenericType, 1)) , otherEGenericType.eTypeArguments);
        index_0 = castTo(eContainer.eGet_0(eContainmentFeature(eTypeParameter, eTypeParameter.eContainer, eTypeParameter.eFlags_0 >> 16)), 15).indexOf_0(eTypeParameter);
        if (index_0 < eTypeArguments.size_0) {
          return $resolve_0(this$static, castTo($get_16(eTypeArguments, index_0), 86));
        }
      }
    }
  }
  return eGenericType;
}

function EClassImpl$1EGenericSuperTypeEList(){
}

defineClass(1029, 467, $intern_141, EClassImpl$1EGenericSuperTypeEList);
_.newData = function newData_4(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, $intern_157, 86, capacity, 0, 1);
}
;
_.useEquals = function useEquals_3(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$1EGenericSuperTypeEList_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/1EGenericSuperTypeEList', 1029);
function EClassImpl$1EStructuralFeatureUniqueEList(){
}

defineClass(590, 467, $intern_141, EClassImpl$1EStructuralFeatureUniqueEList);
_.newData = function newData_5(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, $intern_153, 159, capacity, 0, 1);
}
;
_.useEquals = function useEquals_4(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$1EStructuralFeatureUniqueEList_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/1EStructuralFeatureUniqueEList', 590);
function EClassImpl$1ReferenceList(){
}

defineClass(690, 467, $intern_141, EClassImpl$1ReferenceList);
_.newData = function newData_6(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EReference_2_classLit, $intern_153, 17, capacity, 0, 1);
}
;
_.useEquals = function useEquals_5(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$1ReferenceList_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/1ReferenceList', 690);
function $didAdd_0(this$static, eAttribute){
  (eAttribute.eFlags & $intern_138) != 0 && !this$static.this$01.eIDAttribute && (this$static.this$01.eIDAttribute = eAttribute);
}

function EClassImpl$2(this$0){
  this.this$01 = this$0;
}

defineClass(1030, 467, $intern_141, EClassImpl$2);
_.didAdd = function didAdd_1(index_0, eAttribute){
  $didAdd_0(this, castTo(eAttribute, 29));
}
;
_.newData = function newData_7(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EAttribute_2_classLit, $intern_153, 29, capacity, 0, 1);
}
;
_.useEquals = function useEquals_6(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$2_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/2', 1030);
function EClassImpl$3(){
}

defineClass(1031, 467, $intern_141, EClassImpl$3);
_.newData = function newData_8(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EAttribute_2_classLit, $intern_153, 29, capacity, 0, 1);
}
;
_.useEquals = function useEquals_7(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$3_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/3', 1031);
function $add_28(this$static, object){
  $clinit_System();
  return $add_21($getEStructuralFeatures(this$static.this$01), object);
}

function $addUnique_7(this$static, object){
  $addUnique_6($getEStructuralFeatures(this$static.this$01), object);
}

function EClassImpl$4(this$0, $anonymous2, $anonymous3){
  this.this$01 = this$0;
  EcoreEList$UnmodifiableEList$FastCompare.call(this, $anonymous2, $anonymous3);
}

defineClass(1033, 308, $intern_156, EClassImpl$4);
_.add_1 = function add_60(object){
  return $add_28(this, castTo(object, 29));
}
;
_.addUnique_0 = function addUnique_13(object){
  $addUnique_7(this, castTo(object, 29));
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$4_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/4', 1033);
function $add_29(this$static, object){
  $clinit_System();
  return $add_21($getEStructuralFeatures(this$static.this$01), object);
}

function $addUnique_8(this$static, object){
  $addUnique_6($getEStructuralFeatures(this$static.this$01), object);
}

function EClassImpl$5(this$0, $anonymous2, $anonymous3){
  this.this$01 = this$0;
  EcoreEList$UnmodifiableEList$FastCompare.call(this, $anonymous2, $anonymous3);
}

defineClass(1034, 308, $intern_156, EClassImpl$5);
_.add_1 = function add_61(object){
  return $add_29(this, castTo(object, 17));
}
;
_.addUnique_0 = function addUnique_14(object){
  $addUnique_8(this, castTo(object, 17));
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$5_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/5', 1034);
function EClassImpl$6(){
}

defineClass(1036, 467, $intern_141, EClassImpl$6);
_.newData = function newData_9(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EOperation_2_classLit, $intern_154, 53, capacity, 0, 1);
}
;
_.useEquals = function useEquals_8(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$6_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/6', 1036);
function EClassImpl$7(){
}

defineClass(1037, 467, $intern_141, EClassImpl$7);
_.newData = function newData_10(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EReference_2_classLit, $intern_153, 17, capacity, 0, 1);
}
;
_.useEquals = function useEquals_9(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$7_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/7', 1037);
defineClass(1774, 1773, {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 61:1, 52:1, 69:1});
_.addAllUnique_0 = function addAllUnique_9(index_0, collection){
  return $addAllUnique_2(this, index_0, collection);
}
;
_.addAllUnique = function addAllUnique_10(collection){
  return $addAllUnique_2(this, this.delegateSize(), collection);
}
;
_.addUnique = function addUnique_15(index_0, object){
  $addUnique_3(this, index_0, object);
}
;
_.addUnique_0 = function addUnique_16(object){
  $addUnique_4(this, object);
}
;
_.basicAdd = function basicAdd_2(object, notifications){
  return $basicAdd(this, object, notifications);
}
;
_.basicRemove = function basicRemove_2(object, notifications){
  return $basicRemove(this, object, notifications);
}
;
_.setUnique = function setUnique_6(index_0, object){
  return $setUnique_0(this, index_0, object);
}
;
_.basicGet = function basicGet_3(index_0){
  return this.delegateGet(index_0);
}
;
_.basicIterator = function basicIterator_4(){
  return new AbstractEList$NonResolvingEIterator(this);
}
;
_.basicList = function basicList_0(){
  return this.delegateBasicList();
}
;
_.basicListIterator = function basicListIterator_9(){
  return new AbstractEList$NonResolvingEListIterator(this);
}
;
_.basicListIterator_0 = function basicListIterator_10(index_0){
  return $basicListIterator(this, index_0);
}
;
var Lorg_eclipse_emf_ecore_util_DelegatingNotifyingInternalEListImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'DelegatingNotifyingInternalEListImpl', 1774);
function $resolve_1(this$static, index_0, object){
  var internalEObject, internalEObject0, notificationChain, resolved;
  if (this$static.isEObject() && this$static.hasProxies()) {
    resolved = $resolveProxy(this$static, castTo(object, 51));
    if (maskUndefined(resolved) !== maskUndefined(object)) {
      this$static.delegateGet(index_0);
      this$static.delegateSet(index_0, $validate_1(this$static, index_0, resolved));
      if (this$static.isContainment()) {
        notificationChain = (internalEObject0 = castTo(object, 46) , this$static.hasNavigableInverse()?this$static.hasInstanceClass()?internalEObject0.eInverseRemove(this$static.owner, $getEOpposite(castTo($getEStructuralFeature($eClass(this$static.owner), this$static.getFeatureID_0()), 17)).featureID, castTo($getEStructuralFeature($eClass(this$static.owner), this$static.getFeatureID_0()).getEType(), 26).getInstanceClass(), null):internalEObject0.eInverseRemove(this$static.owner, $getFeatureID(internalEObject0.eClass_0(), $getEOpposite(castTo($getEStructuralFeature($eClass(this$static.owner), this$static.getFeatureID_0()), 17))), null, null):internalEObject0.eInverseRemove(this$static.owner, -1 - this$static.getFeatureID_0(), null, null));
        !castTo(resolved, 46).eInternalContainer() && (notificationChain = (internalEObject = castTo(resolved, 46) , this$static.hasNavigableInverse()?this$static.hasInstanceClass()?internalEObject.eInverseAdd(this$static.owner, $getEOpposite(castTo($getEStructuralFeature($eClass(this$static.owner), this$static.getFeatureID_0()), 17)).featureID, castTo($getEStructuralFeature($eClass(this$static.owner), this$static.getFeatureID_0()).getEType(), 26).getInstanceClass(), notificationChain):internalEObject.eInverseAdd(this$static.owner, $getFeatureID(internalEObject.eClass_0(), $getEOpposite(castTo($getEStructuralFeature($eClass(this$static.owner), this$static.getFeatureID_0()), 17))), null, notificationChain):internalEObject.eInverseAdd(this$static.owner, -1 - this$static.getFeatureID_0(), null, notificationChain)));
        !!notificationChain && notificationChain.dispatch_0();
      }
      $eNotificationRequired(this$static.owner) && this$static.dispatchNotification(this$static.createNotification(9, object, resolved, index_0, false));
      return resolved;
    }
  }
  return object;
}

function $resolveProxy(this$static, eObject){
  return eObject.eIsProxy()?$eResolveProxy(this$static.owner, castTo(eObject, 46)):eObject;
}

function $validate_1(this$static, index_0, object){
  $validate(this$static, object);
  if (object != null && !this$static.isInstance(object)) {
    throw toJs(new ArrayStoreException);
  }
  return object;
}

function DelegatingEcoreEList(owner){
  this.owner = owner;
}

defineClass(691, 1774, $intern_158);
_.canContainNull = function canContainNull_3(){
  var eClassifier;
  eClassifier = $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()).getEType();
  return instanceOf(eClassifier, 144) && !instanceOf(eClassifier, 436) && (eClassifier.getInstanceClass().modifiers & 1) == 0;
}
;
_.contains = function contains_58(object){
  var containedEObject, eContainer, eObject, i, opposite, result, result0, size_0;
  if (this.isEObject()) {
    size_0 = this.delegateSize();
    if (size_0 > 4) {
      if (this.isInstance(object)) {
        if (this.isContainment()) {
          eObject = castTo(object, 46);
          eContainer = eObject.eContainer_0();
          result0 = eContainer == this.owner && (this.hasNavigableInverse()?eObject.eBaseStructuralFeatureID(eObject.eContainerFeatureID_0(), castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()).getEType(), 26).getInstanceClass()) == $getEOpposite(castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()), 17)).featureID:-1 - eObject.eContainerFeatureID_0() == this.getFeatureID_0());
          if (this.hasProxies() && !result0 && !eContainer && !!eObject.eDirectResource()) {
            for (i = 0; i < size_0; ++i) {
              containedEObject = $resolveProxy(this, this.delegateGet(i));
              if (maskUndefined(containedEObject) === maskUndefined(object)) {
                return true;
              }
            }
          }
          return result0;
        }
         else if (this.hasNavigableInverse() && !this.hasManyInverse()) {
          opposite = castTo(object, 51).eGet_0($getEOpposite(castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()), 17)));
          if (maskUndefined(opposite) === maskUndefined(this.owner)) {
            return true;
          }
           else if (opposite == null || !castTo(opposite, 51).eIsProxy()) {
            return false;
          }
        }
      }
       else {
        return false;
      }
    }
    result = this.delegateContains(object);
    if (this.hasProxies() && !result) {
      for (i = 0; i < size_0; ++i) {
        eObject = $resolveProxy(this, this.delegateGet(i));
        if (maskUndefined(eObject) === maskUndefined(object)) {
          return true;
        }
      }
    }
    return result;
  }
   else {
    return this.delegateContains(object);
  }
}
;
_.createNotification = function createNotification_3(eventType, oldObject, newObject, index_0, wasSet){
  return new ENotificationImpl_3(this.owner, eventType, this.getFeatureID_0(), oldObject, newObject, index_0, wasSet);
}
;
_.dispatchNotification = function dispatchNotification_2(notification){
  $eNotify(this.owner, notification);
}
;
_.get_6 = function get_49(resolve){
  return this;
}
;
_.getFeature = function getFeature_5(){
  return $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0());
}
;
_.getFeatureID_0 = function getFeatureID_8(){
  return $getFeatureID($eClass(this.owner), $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()));
}
;
_.getNotifier = function getNotifier_5(){
  return this.owner;
}
;
_.hasInstanceClass = function hasInstanceClass_0(){
  return !!$getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()).getEType().getInstanceClass();
}
;
_.hasInverse = function hasInverse_3(){
  var eReference, eStructuralFeature;
  eStructuralFeature = $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0());
  if (instanceOf(eStructuralFeature, 66)) {
    eReference = castTo(eStructuralFeature, 17);
    return (eReference.eFlags & $intern_138) != 0 || !!$getEOpposite(castTo(eStructuralFeature, 17));
  }
   else {
    return false;
  }
}
;
_.hasManyInverse = function hasManyInverse_0(){
  var eReference, eStructuralFeature, oppositeEReference, upper;
  eStructuralFeature = $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0());
  if (instanceOf(eStructuralFeature, 66)) {
    eReference = castTo(eStructuralFeature, 17);
    oppositeEReference = $getEOpposite(eReference);
    return !!oppositeEReference && (upper = oppositeEReference.upperBound , upper > 1 || upper == -1);
  }
   else {
    return false;
  }
}
;
_.hasNavigableInverse = function hasNavigableInverse_1(){
  var eReference, eStructuralFeature, oppositeEReference;
  eStructuralFeature = $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0());
  if (instanceOf(eStructuralFeature, 66)) {
    eReference = castTo(eStructuralFeature, 17);
    oppositeEReference = $getEOpposite(eReference);
    return !!oppositeEReference;
  }
   else {
    return false;
  }
}
;
_.hasProxies = function hasProxies_0(){
  var eReference, eStructuralFeature;
  eStructuralFeature = $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0());
  if (instanceOf(eStructuralFeature, 66)) {
    eReference = castTo(eStructuralFeature, 17);
    return (eReference.eFlags & $intern_66) != 0;
  }
   else {
    return false;
  }
}
;
_.indexOf_0 = function indexOf_16(object){
  var eObject, i, index_0, size_0;
  index_0 = this.delegateIndexOf(object);
  if (index_0 >= 0)
    return index_0;
  if (this.isEObject()) {
    for (i = 0 , size_0 = this.delegateSize(); i < size_0; ++i) {
      eObject = $resolveProxy(this, this.delegateGet(i));
      if (maskUndefined(eObject) === maskUndefined(object)) {
        return i;
      }
    }
  }
  return -1;
}
;
_.inverseAdd = function inverseAdd_2(object, notifications){
  var internalEObject;
  return internalEObject = castTo(object, 46) , this.hasNavigableInverse()?this.hasInstanceClass()?internalEObject.eInverseAdd(this.owner, $getEOpposite(castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()), 17)).featureID, castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()).getEType(), 26).getInstanceClass(), notifications):internalEObject.eInverseAdd(this.owner, $getFeatureID(internalEObject.eClass_0(), $getEOpposite(castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()), 17))), null, notifications):internalEObject.eInverseAdd(this.owner, -1 - this.getFeatureID_0(), null, notifications);
}
;
_.inverseRemove = function inverseRemove_2(object, notifications){
  var internalEObject;
  return internalEObject = castTo(object, 46) , this.hasNavigableInverse()?this.hasInstanceClass()?internalEObject.eInverseRemove(this.owner, $getEOpposite(castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()), 17)).featureID, castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()).getEType(), 26).getInstanceClass(), notifications):internalEObject.eInverseRemove(this.owner, $getFeatureID(internalEObject.eClass_0(), $getEOpposite(castTo($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()), 17))), null, notifications):internalEObject.eInverseRemove(this.owner, -1 - this.getFeatureID_0(), null, notifications);
}
;
_.isContainment = function isContainment_3(){
  var eReference, eStructuralFeature;
  eStructuralFeature = $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0());
  if (instanceOf(eStructuralFeature, 66)) {
    eReference = castTo(eStructuralFeature, 17);
    return (eReference.eFlags & $intern_138) != 0;
  }
   else {
    return false;
  }
}
;
_.isEObject = function isEObject_1(){
  return instanceOf($getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()).getEType(), 99);
}
;
_.isInstance = function isInstance_2(object){
  return $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()).getEType().isInstance(object);
}
;
_.isNotificationRequired = function isNotificationRequired_2(){
  return $eNotificationRequired(this.owner);
}
;
_.isSet_0 = function isSet_6(){
  return !this.delegateIsEmpty();
}
;
_.isUnique = function isUnique_4(){
  return $getEStructuralFeature($eClass(this.owner), this.getFeatureID_0()).isUnique();
}
;
_.resolve = function resolve_3(index_0, object){
  return $resolve_1(this, index_0, object);
}
;
_.set_1 = function set_33(newValue){
  $clear_10(this);
  $addAll_6(this, castTo(newValue, 15));
}
;
_.toArray = function toArray_42(){
  var i;
  if (this.hasProxies()) {
    for (i = this.delegateSize() - 1; i >= 0; --i) {
      $resolve_1(this, i, this.delegateGet(i));
    }
  }
  return this.delegateToArray();
}
;
_.toArray_0 = function toArray_43(array){
  var i;
  if (this.hasProxies()) {
    for (i = this.delegateSize() - 1; i >= 0; --i) {
      $resolve_1(this, i, this.delegateGet(i));
    }
  }
  return this.delegateToArray_0(array);
}
;
_.unset = function unset_4(){
  $clear_10(this);
}
;
_.validate = function validate_1(index_0, object){
  return $validate_1(this, index_0, object);
}
;
var Lorg_eclipse_emf_ecore_util_DelegatingEcoreEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'DelegatingEcoreEList', 691);
function $delegateAdd(this$static, index_0, eClass){
  $add_20($getEGenericSuperTypes(this$static.this$01), index_0, $wrap(eClass));
}

function $delegateAdd_0(this$static, eClass){
  $add_21($getEGenericSuperTypes(this$static.this$01), $wrap(eClass));
}

function $delegateContains(this$static, object){
  var eClass, eClass$iterator;
  for (eClass$iterator = new AbstractEList$EIterator(this$static); eClass$iterator.cursor != eClass$iterator.this$01_2.size_1();) {
    eClass = castTo($doNext(eClass$iterator), 26);
    if (maskUndefined(object) === maskUndefined(eClass)) {
      return true;
    }
  }
  return false;
}

function $delegateSet(this$static, index_0, eClass){
  var eGenericType, result, result0;
  eGenericType = castTo($get_16($getEGenericSuperTypes(this$static.this$01), index_0), 86);
  result0 = (result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT));
  ((result0.eFlags_0 & 64) != 0?$eResolveProxy(this$static.owner, result0):result0) == eClass?$getERawType(eGenericType):$setEClassifier(eGenericType, eClass);
  return result0;
}

function $wrap(eClass){
  var eGenericType, eGenericType0;
  eGenericType0 = ($clinit_EcoreFactory() , eGenericType = new EGenericTypeImpl , eGenericType);
  $setEClassifier(eGenericType0, eClass);
  return eGenericType0;
}

function EClassImpl$8(this$0, $anonymous0){
  this.this$01 = this$0;
  DelegatingEcoreEList.call(this, $anonymous0);
}

defineClass(1038, 691, $intern_158, EClassImpl$8);
_.delegateAdd = function delegateAdd_1(index_0, eClass){
  $delegateAdd(this, index_0, castTo(eClass, 26));
}
;
_.delegateAdd_0 = function delegateAdd_2(eClass){
  $delegateAdd_0(this, castTo(eClass, 26));
}
;
_.delegateGet = function delegateGet_0(index_0){
  var eGenericType, result;
  return eGenericType = castTo($get_16($getEGenericSuperTypes(this.this$01), index_0), 86) , result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT);
}
;
_.delegateRemove = function delegateRemove_0(index_0){
  var eGenericType, result;
  return eGenericType = castTo($remove_34($getEGenericSuperTypes(this.this$01), index_0), 86) , result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT);
}
;
_.delegateSet = function delegateSet_0(index_0, eClass){
  return $delegateSet(this, index_0, castTo(eClass, 26));
}
;
_.canContainNull = function canContainNull_4(){
  return false;
}
;
_.createNotification = function createNotification_4(eventType, oldObject, newObject, index_0, wasSet){
  return null;
}
;
_.delegateBasicList = function delegateBasicList_0(){
  return new EClassImpl$8$1(this);
}
;
_.delegateClear = function delegateClear_0(){
  $clear_11($getEGenericSuperTypes(this.this$01));
}
;
_.delegateContains = function delegateContains_0(object){
  return $delegateContains(this, object);
}
;
_.delegateContainsAll = function delegateContainsAll_0(collection){
  var object, object$iterator;
  for (object$iterator = collection.iterator_0(); object$iterator.hasNext_0();) {
    object = object$iterator.next_1();
    if (!$delegateContains(this, object)) {
      return false;
    }
  }
  return true;
}
;
_.delegateEquals = function delegateEquals_0(object){
  var i, j, list;
  if (instanceOf(object, 15)) {
    list = castTo(object, 15);
    if (list.size_1() == $getEGenericSuperTypes(this.this$01).size_0) {
      for (i = list.iterator_0() , j = new AbstractEList$EIterator(this); i.hasNext_0();) {
        if (maskUndefined(i.next_1()) !== maskUndefined($doNext(j))) {
          return false;
        }
      }
      return true;
    }
  }
  return false;
}
;
_.delegateHashCode = function delegateHashCode_0(){
  var eGenericType, eGenericType$iterator, hashCode, object, result;
  hashCode = 1;
  for (eGenericType$iterator = new AbstractEList$EIterator($getEGenericSuperTypes(this.this$01)); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    object = (result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT));
    hashCode = 31 * hashCode + (!object?0:getHashCode_0(object));
  }
  return hashCode;
}
;
_.delegateIndexOf = function delegateIndexOf_0(object){
  var eGenericType, eGenericType$iterator, index_0, result;
  index_0 = 0;
  for (eGenericType$iterator = new AbstractEList$EIterator($getEGenericSuperTypes(this.this$01)); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    if (maskUndefined(object) === maskUndefined((result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT)))) {
      return index_0;
    }
    ++index_0;
  }
  return -1;
}
;
_.delegateIsEmpty = function delegateIsEmpty_0(){
  return $getEGenericSuperTypes(this.this$01).size_0 == 0;
}
;
_.delegateList_0 = function delegateList_1(){
  return null;
}
;
_.delegateSize = function delegateSize_0(){
  return $getEGenericSuperTypes(this.this$01).size_0;
}
;
_.delegateToArray = function delegateToArray_1(){
  var eGenericType, eGenericType$iterator, index_0, result, result0, size_0;
  size_0 = $getEGenericSuperTypes(this.this$01).size_0;
  result0 = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, size_0, 5, 1);
  index_0 = 0;
  for (eGenericType$iterator = new AbstractEList$EIterator($getEGenericSuperTypes(this.this$01)); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    result0[index_0++] = (result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT));
  }
  return result0;
}
;
_.delegateToArray_0 = function delegateToArray_2(array){
  var eGenericType, eGenericType$iterator, index_0, newArray, rawType, result, size_0;
  size_0 = $getEGenericSuperTypes(this.this$01).size_0;
  if (array.length < size_0) {
    newArray = newInstance_10(getClass__Ljava_lang_Class___devirtual$(array).componentType, size_0);
    array = newArray;
  }
  array.length > size_0 && setCheck(array, size_0, null);
  index_0 = 0;
  for (eGenericType$iterator = new AbstractEList$EIterator($getEGenericSuperTypes(this.this$01)); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    rawType = (result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT));
    setCheck(array, index_0++, rawType);
  }
  return array;
}
;
_.delegateToString = function delegateToString_0(){
  var eGenericSuperTypes, i, result, size_0, stringBuffer;
  stringBuffer = new StringBuffer;
  stringBuffer.string += '[';
  eGenericSuperTypes = $getEGenericSuperTypes(this.this$01);
  for (i = 0 , size_0 = $getEGenericSuperTypes(this.this$01).size_0; i < size_0;) {
    $append_3(stringBuffer, valueOf_7((result = castTo($get_16(eGenericSuperTypes, i), 86).eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT))));
    ++i < size_0 && (stringBuffer.string += ', ' , stringBuffer);
  }
  stringBuffer.string += ']';
  return stringBuffer.string;
}
;
_.dispatchNotification = function dispatchNotification_3(notification){
}
;
_.getFeatureID_0 = function getFeatureID_9(){
  return 10;
}
;
_.hasInstanceClass = function hasInstanceClass_1(){
  return true;
}
;
_.hasInverse = function hasInverse_4(){
  return false;
}
;
_.hasManyInverse = function hasManyInverse_1(){
  return false;
}
;
_.hasNavigableInverse = function hasNavigableInverse_2(){
  return false;
}
;
_.hasProxies = function hasProxies_1(){
  return true;
}
;
_.isContainment = function isContainment_4(){
  return false;
}
;
_.isEObject = function isEObject_2(){
  return true;
}
;
_.isInstance = function isInstance_3(object){
  return instanceOf(object, 99);
}
;
_.isSet_0 = function isSet_7(){
  return $isSetESuperTypes(this.this$01);
}
;
_.isUnique = function isUnique_5(){
  return true;
}
;
_.useEquals = function useEquals_10(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$8_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/8', 1038);
function EClassImpl$8$1(this$1){
  this.this$11 = this$1;
}

defineClass(1039, 1741, $intern_36, EClassImpl$8$1);
_.listIterator_1 = function listIterator_27(index_0){
  return $basicListIterator(this.this$11, index_0);
}
;
_.size_1 = function size_66(){
  return $getEGenericSuperTypes(this.this$11.this$01).size_0;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$8$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/8/1', 1039);
function EClassImpl$9(){
}

defineClass(1040, 467, $intern_141, EClassImpl$9);
_.newData = function newData_11(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EClassifier_2_classLit, $intern_1, 136, capacity, 0, 1);
}
;
_.useEquals = function useEquals_11(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EClassImpl$9_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/9', 1040);
function EClassImpl$MyHashSet(){
  HashSet.call(this);
}

defineClass(1027, 65, $intern_79, EClassImpl$MyHashSet);
var Lorg_eclipse_emf_ecore_impl_EClassImpl$MyHashSet_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EClassImpl/MyHashSet', 1027);
function $setSerializable(this$static, newSerializable){
  var oldSerializable;
  oldSerializable = (this$static.eFlags & 256) != 0;
  newSerializable?(this$static.eFlags |= 256):(this$static.eFlags &= -257);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 8, oldSerializable, newSerializable));
}

function EDataTypeImpl(){
  this.eFlags |= 256;
}

defineClass(536, 689, {98:1, 92:1, 89:1, 136:1, 144:1, 767:1, 143:1, 179:1, 51:1, 106:1, 46:1, 93:1, 145:1, 109:1, 110:1, 633:1}, EDataTypeImpl);
_.eGet = function eGet_23(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return this.instanceClassName != null?this.instanceClassName:this.generatedInstanceClassName;
    case 3:
      return $getInstanceClass(this);
    case 4:
      return this.getDefaultValue();
    case 5:
      return this.instanceTypeName;
    case 6:
      if (resolve)
        return $getEPackage(this);
      return $basicGetEPackage(this);
    case 7:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7)) , this.eTypeParameters;
    case 8:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), resolve, coreType);
}
;
_.eIsSet = function eIsSet_22(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return this.instanceClassName != null && this.instanceClassName == this.instanceTypeName;
    case 3:
      return !!$getInstanceClass(this);
    case 4:
      return this.getDefaultValue() != null;
    case 5:
      return this.instanceTypeName != null && this.instanceTypeName != this.instanceClassName && this.instanceTypeName != this.generatedInstanceClassName;
    case 6:
      return !!$basicGetEPackage(this);
    case 7:
      return !!this.eTypeParameters && this.eTypeParameters.size_0 != 0;
    case 8:
      return (this.eFlags & 256) == 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID));
}
;
_.eSet = function eSet_21(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName_1(this, castToString(newValue));
      return;
    case 2:
      $setInstanceClassName(this, castToString(newValue));
      return;
    case 5:
      $setInstanceTypeName(this, castToString(newValue));
      return;
    case 7:
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7));
      $clear_11(this.eTypeParameters);
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7));
      $addAll_6(this.eTypeParameters, castTo(newValue, 13));
      return;
    case 8:
      $setSerializable(this, checkNotNull_1(castToBoolean(newValue)));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?this.eStaticClass():eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_22(){
  return $clinit_EcorePackage$Literals() , EDATA_TYPE;
}
;
_.freeze = function freeze_5(){
  $getExtendedMetaData(($clinit_ExtendedMetaData() , INSTANCE_11), this).getName();
  this.eFlags |= 1;
}
;
_.getConversionDelegate = function getConversionDelegate(){
  var conversionDelegates, eDataTypeDelegateURI, eDataTypeDelegateURI$iterator;
  if (!this.conversionDelegateIsSet) {
    conversionDelegates = getConversionDelegates($getEPackage(this));
    if (!conversionDelegates.isEmpty()) {
      for (eDataTypeDelegateURI$iterator = conversionDelegates.iterator_0(); eDataTypeDelegateURI$iterator.hasNext_0();) {
        eDataTypeDelegateURI = castToString(eDataTypeDelegateURI$iterator.next_1());
        !!$getEAnnotation(this, eDataTypeDelegateURI) && getConversionDelegateFactory(this);
      }
    }
  }
  return this.conversionDelegate;
}
;
_.getDefaultValue = function getDefaultValue_1(){
  var instanceClass;
  if (!this.defaultValueIsSet) {
    instanceClass = null;
    try {
      instanceClass = $getInstanceClass(this);
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (!instanceOf($e0, 102))
        throw toJs($e0);
    }
    this.defaultValue = null;
    !!instanceClass && (instanceClass.modifiers & 1) != 0 && (instanceClass == Z_classLit?(this.defaultValue = ($clinit_Boolean() , FALSE_0)):instanceClass == I_classLit?(this.defaultValue = valueOf_4(0)):instanceClass == F_classLit?(this.defaultValue = new Float(0)):instanceClass == D_classLit?(this.defaultValue = 0):instanceClass == J_classLit?(this.defaultValue = valueOf_5(0)):instanceClass == S_classLit?(this.defaultValue = valueOf_6(0)):instanceClass == B_classLit?(this.defaultValue = valueOf_2(0)):(this.defaultValue = valueOf_3(0)));
    this.defaultValueIsSet = true;
  }
  return this.defaultValue;
}
;
_.isSerializable = function isSerializable_0(){
  return (this.eFlags & 256) != 0;
}
;
_.setDataTypeGeneratedInstanceClass = function setDataTypeGeneratedInstanceClass(isGenerated){
  isGenerated && (this.instanceClassName = 'org.eclipse.emf.common.util.AbstractEnumerator');
}
;
_.setGeneratedInstanceClass = function setGeneratedInstanceClass_0(isGenerated){
  $setGeneratedInstanceClass(this, isGenerated);
  this.setDataTypeGeneratedInstanceClass(isGenerated);
}
;
_.setInstanceClassGen = function setInstanceClassGen_0(instanceClass){
  this.instanceClass = instanceClass;
  this.defaultValueIsSet = false;
}
;
_.toString_0 = function toString_149(){
  var result;
  if ((this.eFlags_0 & 64) != 0)
    return $toString_26(this);
  result = new StringBuffer_1($toString_26(this));
  result.string += ' (serializable: ';
  $append_4(result, (this.eFlags & 256) != 0);
  result.string += ')';
  return result.string;
}
;
_.conversionDelegateIsSet = false;
_.defaultValue = null;
_.defaultValueIsSet = false;
var Lorg_eclipse_emf_ecore_impl_EDataTypeImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EDataTypeImpl', 536);
function $getDefaultValue_0(this$static){
  var eLiterals;
  eLiterals = (!this$static.eLiterals && (this$static.eLiterals = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, this$static, 9, 5)) , this$static.eLiterals);
  if (eLiterals.size_0 != 0) {
    return $getInstance(castTo($get_16(eLiterals, 0), 636));
  }
  return null;
}

function $getEEnumLiteralByLiteral(this$static, literal){
  var eEnumLiteral, eEnumLiteral$iterator, result;
  if (literal == null) {
    for (eEnumLiteral$iterator = (!this$static.eLiterals && (this$static.eLiterals = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, this$static, 9, 5)) , new AbstractEList$EIterator(this$static.eLiterals)); eEnumLiteral$iterator.cursor != eEnumLiteral$iterator.this$01_2.size_1();) {
      eEnumLiteral = castTo($doNext(eEnumLiteral$iterator), 636);
      result = eEnumLiteral.literal;
      if ((result == null?eEnumLiteral.name_0:result) == null) {
        return eEnumLiteral;
      }
    }
  }
   else {
    for (eEnumLiteral$iterator = (!this$static.eLiterals && (this$static.eLiterals = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, this$static, 9, 5)) , new AbstractEList$EIterator(this$static.eLiterals)); eEnumLiteral$iterator.cursor != eEnumLiteral$iterator.this$01_2.size_1();) {
      eEnumLiteral = castTo($doNext(eEnumLiteral$iterator), 636);
      if ($equals_4(literal, (result = eEnumLiteral.literal , result == null?eEnumLiteral.name_0:result))) {
        return eEnumLiteral;
      }
    }
  }
  return null;
}

function EEnumImpl(){
  EDataTypeImpl.call(this);
}

defineClass(436, 536, {98:1, 92:1, 89:1, 136:1, 144:1, 767:1, 627:1, 143:1, 179:1, 51:1, 106:1, 46:1, 93:1, 436:1, 145:1, 109:1, 110:1, 633:1}, EEnumImpl);
_.eGet = function eGet_24(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return this.instanceClassName != null?this.instanceClassName:this.generatedInstanceClassName;
    case 3:
      return $getInstanceClass(this);
    case 4:
      return $getDefaultValue_0(this);
    case 5:
      return this.instanceTypeName;
    case 6:
      if (resolve)
        return $getEPackage(this);
      return $basicGetEPackage(this);
    case 7:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7)) , this.eTypeParameters;
    case 8:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
    case 9:
      return !this.eLiterals && (this.eLiterals = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, this, 9, 5)) , this.eLiterals;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EENUM:eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_15(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 6:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_7(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $eBasicSetContainer(this, otherEnd, 6, msgs);
    case 9:
      return !this.eLiterals && (this.eLiterals = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, this, 9, 5)) , $basicAdd_0(this.eLiterals, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EENUM):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_17(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 6:
      return $eBasicSetContainer(this, null, 6, msgs);
    case 7:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7)) , $basicRemove_0(this.eTypeParameters, otherEnd, msgs);
    case 9:
      return !this.eLiterals && (this.eLiterals = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, this, 9, 5)) , $basicRemove_0(this.eLiterals, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EENUM):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_23(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return this.instanceClassName != null && this.instanceClassName == this.instanceTypeName;
    case 3:
      return !!$getInstanceClass(this);
    case 4:
      return !!$getDefaultValue_0(this);
    case 5:
      return this.instanceTypeName != null && this.instanceTypeName != this.instanceClassName && this.instanceTypeName != this.generatedInstanceClassName;
    case 6:
      return !!$basicGetEPackage(this);
    case 7:
      return !!this.eTypeParameters && this.eTypeParameters.size_0 != 0;
    case 8:
      return (this.eFlags & 256) == 0;
    case 9:
      return !!this.eLiterals && this.eLiterals.size_0 != 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EENUM:eClass), featureID));
}
;
_.eSet = function eSet_22(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName_1(this, castToString(newValue));
      return;
    case 2:
      $setInstanceClassName(this, castToString(newValue));
      return;
    case 5:
      $setInstanceTypeName(this, castToString(newValue));
      return;
    case 7:
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7));
      $clear_11(this.eTypeParameters);
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 7));
      $addAll_6(this.eTypeParameters, castTo(newValue, 13));
      return;
    case 8:
      $setSerializable(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 9:
      !this.eLiterals && (this.eLiterals = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, this, 9, 5));
      $clear_11(this.eLiterals);
      !this.eLiterals && (this.eLiterals = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, this, 9, 5));
      $addAll_6(this.eLiterals, castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EENUM:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_23(){
  return $clinit_EcorePackage$Literals() , EENUM;
}
;
_.freeze = function freeze_6(){
  var i, size_0;
  if (this.eLiterals) {
    for (i = 0 , size_0 = this.eLiterals.size_0; i < size_0; ++i) {
      $freeze($get_16(this.eLiterals, i));
    }
  }
  $getExtendedMetaData(($clinit_ExtendedMetaData() , INSTANCE_11), this).getName();
  this.eFlags |= 1;
}
;
_.getDefaultValue = function getDefaultValue_2(){
  return $getDefaultValue_0(this);
}
;
_.isInstance = function isInstance_4(object){
  if (object != null) {
    return true;
  }
  return false;
}
;
_.setDataTypeGeneratedInstanceClass = function setDataTypeGeneratedInstanceClass_0(isGenerated){
}
;
var Lorg_eclipse_emf_ecore_impl_EEnumImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EEnumImpl', 436);
function $eBasicRemoveFromContainerFeature_8(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 5) {
    return this$static.eContainer.eInverseRemove(this$static, 9, Lorg_eclipse_emf_ecore_EEnum_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EENUM_LITERAL):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getInstance(this$static){
  return this$static.instance?this$static.instance:this$static.generatedInstance;
}

function $setInstance(this$static, newInstance){
  var literal, result, oldInstance;
  oldInstance = this$static.instance;
  this$static.instance = newInstance;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 3, oldInstance, this$static.instance));
  if (!newInstance) {
    $setName(this$static, null);
    $setValue_0(this$static, 0);
    $setLiteral(this$static, null);
  }
   else if (newInstance != this$static) {
    $setName(this$static, newInstance.name_0);
    $setValue_0(this$static, newInstance.value_0);
    literal = (result = newInstance.literal , result == null?newInstance.name_0:result);
    $setLiteral(this$static, literal == null || $equals_4(literal, newInstance.name_0)?null:literal);
  }
}

function $setLiteral(this$static, newLiteral){
  var oldLiteral;
  oldLiteral = this$static.literal;
  this$static.literal = newLiteral;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 4, oldLiteral, this$static.literal));
}

function $setValue_0(this$static, newValue){
  var oldValue;
  oldValue = this$static.value_0;
  this$static.value_0 = newValue;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_0(this$static, 2, oldValue, this$static.value_0));
}

function EEnumLiteralImpl(){
  this.generatedInstance = this;
}

defineClass(541, 417, {98:1, 92:1, 89:1, 1719:1, 636:1, 143:1, 179:1, 51:1, 106:1, 46:1, 93:1, 541:1, 145:1, 109:1, 110:1}, EEnumLiteralImpl);
_.getName = function getName_4(){
  return this.name_0;
}
;
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_9(msgs){
  return $eBasicRemoveFromContainerFeature_8(this, msgs);
}
;
_.eGet = function eGet_25(featureID, resolve, coreType){
  var eClass, result;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return valueOf_4(this.value_0);
    case 3:
      return this.instance?this.instance:this.generatedInstance;
    case 4:
      return result = this.literal , result == null?this.name_0:result;
    case 5:
      return this.eFlags_0 >> 16 == 5?castTo(this.eContainer, 627):null;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM_LITERAL)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EENUM_LITERAL:eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_16(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 5:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_8(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $eBasicSetContainer(this, otherEnd, 5, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EENUM_LITERAL):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM_LITERAL)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_18(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 5:
      return $eBasicSetContainer(this, null, 5, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EENUM_LITERAL):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM_LITERAL)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_24(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return this.value_0 != 0;
    case 3:
      return !!this.instance;
    case 4:
      return this.literal != null;
    case 5:
      return !!(this.eFlags_0 >> 16 == 5?castTo(this.eContainer, 627):null);
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM_LITERAL)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EENUM_LITERAL:eClass), featureID));
}
;
_.eSet = function eSet_23(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName(this, castToString(newValue));
      return;
    case 2:
      $setValue_0(this, castTo(newValue, 21).value_0);
      return;
    case 3:
      $setInstance(this, castTo(newValue, 1719));
      return;
    case 4:
      $setLiteral(this, castToString(newValue));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EENUM_LITERAL)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EENUM_LITERAL:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_24(){
  return $clinit_EcorePackage$Literals() , EENUM_LITERAL;
}
;
_.toString_0 = function toString_150(){
  var result;
  return result = this.literal , result == null?this.name_0:result;
}
;
_.instance = null;
_.literal = null;
_.value_0 = 0;
var Lorg_eclipse_emf_ecore_impl_EEnumLiteralImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EEnumLiteralImpl', 541);
var Lorg_eclipse_emf_ecore_impl_EFactoryImpl$InternalEDateTimeFormat_2_classLit = createForInterface('org.eclipse.emf.ecore.impl', 'EFactoryImpl/InternalEDateTimeFormat');
function $format_0(this$static, value_0){
  return $format(this$static.dateTimeFormat, value_0, null);
}

function $parse_2(this$static, value_0){
  return $parse_1(this$static.dateTimeFormat, value_0);
}

function EFactoryImpl$1ClientInternalEDateTimeFormat(dateTimeFormat){
  this.dateTimeFormat = dateTimeFormat;
}

defineClass(461, 1, {1783:1}, EFactoryImpl$1ClientInternalEDateTimeFormat);
var Lorg_eclipse_emf_ecore_impl_EFactoryImpl$1ClientInternalEDateTimeFormat_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EFactoryImpl/1ClientInternalEDateTimeFormat', 461);
function $basicSetELowerBound(this$static, newELowerBound, msgs){
  var notification, oldELowerBound;
  oldELowerBound = this$static.eLowerBound;
  this$static.eLowerBound = newELowerBound;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 3, oldELowerBound, newELowerBound);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  return msgs;
}

function $basicSetETypeParameter(this$static, newETypeParameter, msgs){
  var notification, oldETypeParameter;
  oldETypeParameter = this$static.eTypeParameter;
  this$static.eTypeParameter = newETypeParameter;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 4, oldETypeParameter, newETypeParameter);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  oldETypeParameter != newETypeParameter && (newETypeParameter?(msgs = $setERawType(this$static, $getErasure(this$static, newETypeParameter), msgs)):(msgs = $setERawType(this$static, this$static.eClassifier, msgs)));
  return msgs;
}

function $basicSetEUpperBound(this$static, newEUpperBound, msgs){
  var notification, oldEUpperBound;
  oldEUpperBound = this$static.eUpperBound;
  this$static.eUpperBound = newEUpperBound;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 0, oldEUpperBound, newEUpperBound);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  return msgs;
}

function $getEClassifier(this$static){
  var oldEClassifier;
  if (!!this$static.eClassifier && this$static.eClassifier.eIsProxy()) {
    oldEClassifier = castTo(this$static.eClassifier, 46);
    this$static.eClassifier = castTo($eResolveProxy(this$static, oldEClassifier), 136);
    this$static.eClassifier != oldEClassifier && (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 9, 5, oldEClassifier, this$static.eClassifier));
  }
  return this$static.eClassifier;
}

function $getERawType(this$static){
  var newERawType, oldERawType;
  if (!!this$static.eRawType && this$static.eRawType.eIsProxy()) {
    oldERawType = castTo(this$static.eRawType, 46);
    this$static.eRawType = castTo($eResolveProxy(this$static, oldERawType), 136);
    if (this$static.eRawType != oldERawType) {
      (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 9, 2, oldERawType, this$static.eRawType));
      if (instanceOf(this$static.eContainer, 385)) {
        this$static.eFlags_0 >> 16 == -15 && this$static.eContainer.eNotificationRequired() && $dispatch(new ENotificationImpl_2(this$static.eContainer, 9, 13, oldERawType, this$static.eRawType, $indexOf_6($getEGenericExceptions(castTo(this$static.eContainer, 53)), this$static)));
      }
       else if (instanceOf(this$static.eContainer, 99)) {
        if (this$static.eFlags_0 >> 16 == -23 && this$static.eContainer.eNotificationRequired()) {
          newERawType = this$static.eRawType;
          instanceOf(newERawType, 99) || (newERawType = ($clinit_EcorePackage$Literals() , EOBJECT));
          instanceOf(oldERawType, 99) || (oldERawType = ($clinit_EcorePackage$Literals() , EOBJECT));
          $dispatch(new ENotificationImpl_2(this$static.eContainer, 9, 10, oldERawType, newERawType, $indexOf_6($getEGenericSuperTypes(castTo(this$static.eContainer, 26)), this$static)));
        }
      }
    }
  }
  return this$static.eRawType;
}

function $getETypeArguments(this$static){
  !this$static.eTypeArguments && (this$static.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this$static, 1));
  return this$static.eTypeArguments;
}

function $getErasure(this$static, eTypeParameter){
  var eBound, eBound$iterator, eRawType, needEClass, needEDataType;
  if (!eTypeParameter) {
    return null;
  }
   else {
    needEClass = instanceOf(this$static.eContainer, 99) || instanceOf(this$static.eContainer, 66);
    needEDataType = !needEClass && instanceOf(this$static.eContainer, 348);
    for (eBound$iterator = new AbstractEList$EIterator((!eTypeParameter.eBounds && (eTypeParameter.eBounds = new ETypeParameterImpl$1(eTypeParameter, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, eTypeParameter)) , eTypeParameter.eBounds)); eBound$iterator.cursor != eBound$iterator.this$01_2.size_1();) {
      eBound = castTo($doNext(eBound$iterator), 86);
      eRawType = $getERawType(eBound);
      if (needEClass?instanceOf(eRawType, 99):needEDataType?instanceOf(eRawType, 144):!!eRawType) {
        return eRawType;
      }
    }
    return needEClass?($clinit_EcorePackage$Literals() , EOBJECT):($clinit_EcorePackage$Literals() , EJAVA_OBJECT);
  }
}

function $setEClassifier(this$static, newEClassifier){
  var msgs, oldEClassifier;
  oldEClassifier = this$static.eClassifier;
  msgs = $setEClassifier_0(this$static, newEClassifier, null);
  oldEClassifier != newEClassifier && !this$static.eTypeParameter && (msgs = $setERawType(this$static, newEClassifier, msgs));
  !!msgs && msgs.dispatch_0();
}

function $setEClassifier_0(this$static, newEClassifier, msgs){
  var notification, oldEClassifier;
  oldEClassifier = this$static.eClassifier;
  this$static.eClassifier = newEClassifier;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 5, oldEClassifier, this$static.eClassifier);
    !msgs?(msgs = notification):$add_22(msgs, notification);
  }
  return msgs;
}

function $setELowerBound(this$static, newELowerBound){
  var msgs;
  if (newELowerBound != this$static.eLowerBound) {
    msgs = null;
    !!this$static.eLowerBound && (msgs = $eInverseRemove(this$static.eLowerBound, this$static, -4, null));
    !!newELowerBound && (msgs = $eInverseAdd(newELowerBound, this$static, -4, msgs));
    msgs = $basicSetELowerBound(this$static, newELowerBound, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 3, newELowerBound, newELowerBound));
}

function $setERawType(this$static, newERawType, msgs){
  var delegateIterator, eGenericType, eGenericType$iterator, eGenericTypes, eTypeParameter, notification, oldERawType;
  oldERawType = this$static.eRawType;
  !newERawType && (newERawType = eJavaObject);
  this$static.eRawType = newERawType;
  if ((this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0) {
    notification = new ENotificationImpl_1(this$static, 1, 2, oldERawType, this$static.eRawType);
    !msgs?(msgs = notification):msgs.add_4(notification);
  }
  if (oldERawType != newERawType) {
    if (instanceOf(this$static.eContainer, 278)) {
      if (this$static.eFlags_0 >> 16 == -10) {
        msgs = castTo(this$static.eContainer, 278).setEType(newERawType, msgs);
      }
       else if (this$static.eFlags_0 >> 16 == -15) {
        !newERawType && (newERawType = ($clinit_EcorePackage$Literals() , EJAVA_OBJECT));
        !oldERawType && (oldERawType = ($clinit_EcorePackage$Literals() , EJAVA_OBJECT));
        if (this$static.eContainer.eNotificationRequired()) {
          notification = new ENotificationImpl_3(this$static.eContainer, 1, 13, oldERawType, newERawType, $indexOf_6($getEGenericExceptions(castTo(this$static.eContainer, 53)), this$static), false);
          !msgs?(msgs = notification):msgs.add_4(notification);
        }
      }
    }
     else if (instanceOf(this$static.eContainer, 99)) {
      if (this$static.eFlags_0 >> 16 == -23) {
        instanceOf(newERawType, 99) || (newERawType = ($clinit_EcorePackage$Literals() , EOBJECT));
        instanceOf(oldERawType, 99) || (oldERawType = ($clinit_EcorePackage$Literals() , EOBJECT));
        if (this$static.eContainer.eNotificationRequired()) {
          notification = new ENotificationImpl_3(this$static.eContainer, 1, 10, oldERawType, newERawType, $indexOf_6($getEGenericSuperTypes(castTo(this$static.eContainer, 26)), this$static), false);
          !msgs?(msgs = notification):msgs.add_4(notification);
        }
      }
    }
     else if (instanceOf(this$static.eContainer, 423)) {
      eTypeParameter = castTo(this$static.eContainer, 772);
      eGenericTypes = (!eTypeParameter.eGenericTypes && (eTypeParameter.eGenericTypes = new ETypeParameterImpl$2$1(new ETypeParameterImpl$2)) , eTypeParameter.eGenericTypes);
      for (eGenericType$iterator = (delegateIterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(eGenericTypes.this$11)).this$01) , new ETypeParameterImpl$2$1$1(delegateIterator)); eGenericType$iterator.val$delegateIterator2.hasNext;) {
        eGenericType = castTo($next_7(eGenericType$iterator.val$delegateIterator2).getKey(), 86);
        msgs = $setERawType(eGenericType, $getErasure(eGenericType, eTypeParameter), msgs);
      }
    }
  }
  return msgs;
}

function $setETypeParameter(this$static, newETypeParameter){
  var msgs;
  if (newETypeParameter != this$static.eTypeParameter) {
    !!this$static.eTypeParameter && $remove_41($getEGenericTypes(this$static.eTypeParameter), this$static);
    !!newETypeParameter && (!newETypeParameter.eGenericTypes && (newETypeParameter.eGenericTypes = new ETypeParameterImpl$2$1(new ETypeParameterImpl$2)) , $add_30(newETypeParameter.eGenericTypes, this$static));
    msgs = $basicSetETypeParameter(this$static, newETypeParameter, null);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 4, newETypeParameter, newETypeParameter));
}

function $setEUpperBound(this$static, newEUpperBound){
  var msgs;
  if (newEUpperBound != this$static.eUpperBound) {
    msgs = null;
    !!this$static.eUpperBound && (msgs = $eInverseRemove(this$static.eUpperBound, this$static, -1, null));
    !!newEUpperBound && (msgs = $eInverseAdd(newEUpperBound, this$static, -1, msgs));
    msgs = $basicSetEUpperBound(this$static, newEUpperBound, msgs);
    !!msgs && msgs.dispatch_0();
  }
   else 
    (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 0, newEUpperBound, newEUpperBound));
}

function $toString_28(this$static, result){
  var eTypeArgument, eTypeArgument$iterator, first, index_0, instanceTypeName, label_0, tail;
  if (this$static.eClassifier) {
    label_0 = this$static.eClassifier.getName();
    tail = null;
    if (label_0 != null) {
      result.string += '' + label_0;
    }
     else {
      instanceTypeName = this$static.eClassifier.getInstanceTypeName();
      if (instanceTypeName != null) {
        index_0 = $indexOf_1(instanceTypeName, fromCodePoint(91));
        if (index_0 != -1) {
          tail = instanceTypeName.substr(index_0, instanceTypeName.length - index_0);
          result.string += '' + (instanceTypeName == null?'null':instanceTypeName).substr(0, index_0);
        }
         else {
          result.string += '' + instanceTypeName;
        }
      }
    }
    if (!!this$static.eTypeArguments && this$static.eTypeArguments.size_0 != 0) {
      first = true;
      result.string += '<';
      for (eTypeArgument$iterator = new AbstractEList$EIterator(this$static.eTypeArguments); eTypeArgument$iterator.cursor != eTypeArgument$iterator.this$01_2.size_1();) {
        eTypeArgument = castTo($doNext(eTypeArgument$iterator), 86);
        first?(first = false):(result.string += ', ' , result);
        $toString_28(eTypeArgument, result);
      }
      result.string += '>';
    }
    tail != null && (result.string += '' + tail , result);
  }
   else if (this$static.eTypeParameter) {
    label_0 = this$static.eTypeParameter.name_0;
    label_0 != null && (result.string += '' + label_0 , result);
  }
   else {
    result.string += '?';
    if (this$static.eLowerBound) {
      result.string += ' super ';
      $toString_28(this$static.eLowerBound, result);
    }
     else {
      if (this$static.eUpperBound) {
        result.string += ' extends ';
        $toString_28(this$static.eUpperBound, result);
      }
    }
  }
}

function EGenericTypeImpl(){
  this.eRawType = eJavaObject;
}

defineClass(223, 110, {98:1, 92:1, 89:1, 86:1, 51:1, 106:1, 46:1, 93:1, 223:1, 109:1, 110:1}, EGenericTypeImpl);
_.eBasicSetContainer_0 = function eBasicSetContainer_6(newContainer, newContainerFeatureID, msgs){
  var newERawType;
  msgs = $eBasicSetContainer(this, newContainer, newContainerFeatureID, msgs);
  if (!!this.eTypeParameter && instanceOf(newContainer, 159)) {
    newERawType = $getErasure(this, this.eTypeParameter);
    newERawType != this.eRawType && (msgs = $setERawType(this, newERawType, msgs));
  }
  return msgs;
}
;
_.eGet = function eGet_26(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return this.eUpperBound;
    case 1:
      return !this.eTypeArguments && (this.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this, 1)) , this.eTypeArguments;
    case 2:
      if (resolve)
        return $getERawType(this);
      return this.eRawType;
    case 3:
      return this.eLowerBound;
    case 4:
      return this.eTypeParameter;
    case 5:
      if (resolve)
        return $getEClassifier(this);
      return this.eClassifier;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EGENERIC_TYPE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EGENERIC_TYPE:eClass), featureID), resolve, coreType);
}
;
_.eInverseRemove_0 = function eInverseRemove_19(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return $basicSetEUpperBound(this, null, msgs);
    case 1:
      return !this.eTypeArguments && (this.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this, 1)) , $basicRemove_0(this.eTypeArguments, otherEnd, msgs);
    case 3:
      return $basicSetELowerBound(this, null, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EGENERIC_TYPE):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EGENERIC_TYPE)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_25(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eUpperBound;
    case 1:
      return !!this.eTypeArguments && this.eTypeArguments.size_0 != 0;
    case 2:
      return !!this.eRawType;
    case 3:
      return !!this.eLowerBound;
    case 4:
      return !!this.eTypeParameter;
    case 5:
      return !!this.eClassifier;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EGENERIC_TYPE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EGENERIC_TYPE:eClass), featureID));
}
;
_.eSet = function eSet_24(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      $setEUpperBound(this, castTo(newValue, 86));
      return;
    case 1:
      !this.eTypeArguments && (this.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this, 1));
      $clear_11(this.eTypeArguments);
      !this.eTypeArguments && (this.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this, 1));
      $addAll_6(this.eTypeArguments, castTo(newValue, 13));
      return;
    case 3:
      $setELowerBound(this, castTo(newValue, 86));
      return;
    case 4:
      $setETypeParameter(this, castTo(newValue, 772));
      return;
    case 5:
      $setEClassifier(this, castTo(newValue, 136));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EGENERIC_TYPE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EGENERIC_TYPE:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_25(){
  return $clinit_EcorePackage$Literals() , EGENERIC_TYPE;
}
;
_.toString_0 = function toString_151(){
  var result;
  result = new StringBuilder_1($toString_12(this));
  result.string += ' (expression: ';
  $toString_28(this, result);
  result.string += ')';
  return result.string;
}
;
var eJavaObject;
var Lorg_eclipse_emf_ecore_impl_EGenericTypeImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EGenericTypeImpl', 223);
function $addUnique_9(this$static, index_0, object){
  var iter;
  iter = this$static.listIterator_1(index_0);
  iter.add_2(object);
}

defineClass(1751, 1741, $intern_159);
_.basicAdd = function basicAdd_3(object, notifications){
  $addUnique_9(this, this.size_1(), object);
  return notifications;
}
;
_.basicGet = function basicGet_4(index_0){
  return $get_3(this.basicList(), index_0);
}
;
_.basicIterator = function basicIterator_5(){
  return this.basicListIterator();
}
;
_.basicList = function basicList_1(){
  return new AbstractSequentialInternalEList$1(this);
}
;
_.basicListIterator = function basicListIterator_11(){
  return this.basicListIterator_0(0);
}
;
_.basicListIterator_0 = function basicListIterator_12(index_0){
  return this.basicList().listIterator_1(index_0);
}
;
_.basicRemove = function basicRemove_3(object, notifications){
  $advanceToFind(this, object, true);
  return notifications;
}
;
var Lorg_eclipse_emf_ecore_util_AbstractSequentialInternalEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'AbstractSequentialInternalEList', 1751);
function $clinit_EContentsEList(){
  $clinit_EContentsEList = emptyMethod;
  EMPTY_CONTENTS_ELIST = new EContentsEList$1;
}

function $isIncludedEntry(eStructuralFeature){
  return instanceOf(eStructuralFeature, 66) && (castTo(castTo(eStructuralFeature, 17), 66).eFlags & $intern_138) != 0;
}

function $iterator_4(this$static){
  var result;
  if (this$static.eStructuralFeatures == null) {
    return $clinit_EContentsEList$FeatureIteratorImpl() , $clinit_EContentsEList$FeatureIteratorImpl() , EMPTY_ITERATOR;
  }
  result = this$static.resolve_0()?this$static.newResolvingListIterator():this$static.newNonResolvingListIterator();
  return result;
}

function EContentsEList(eObject, eStructuralFeatures){
  $clinit_EContentsEList();
  this.eObject = eObject;
  this.eStructuralFeatures = eStructuralFeatures;
}

defineClass(460, 1751, $intern_159, EContentsEList);
_.basicGet = function basicGet_5(index_0){
  return $get_3(this.basicList(), index_0);
}
;
_.basicIterator = function basicIterator_6(){
  if (this.eStructuralFeatures == null) {
    return $clinit_EContentsEList$FeatureIteratorImpl() , $clinit_EContentsEList$FeatureIteratorImpl() , EMPTY_ITERATOR;
  }
  return this.newNonResolvingListIterator();
}
;
_.basicList = function basicList_2(){
  return new EContentsEList$2(this.eObject, this.eStructuralFeatures);
}
;
_.basicListIterator = function basicListIterator_13(){
  if (this.eStructuralFeatures == null) {
    return $clinit_EContentsEList$FeatureIteratorImpl() , $clinit_EContentsEList$FeatureIteratorImpl() , EMPTY_ITERATOR;
  }
  return this.newNonResolvingListIterator();
}
;
_.basicListIterator_0 = function basicListIterator_14(index_0){
  var i, result;
  if (this.eStructuralFeatures == null) {
    if (index_0 < 0 || index_0 > 1) {
      throw toJs(new IndexOutOfBoundsException_0('index=' + index_0 + ', size=0'));
    }
    return $clinit_EContentsEList$FeatureIteratorImpl() , $clinit_EContentsEList$FeatureIteratorImpl() , EMPTY_ITERATOR;
  }
  result = this.newNonResolvingListIterator();
  for (i = 0; i < index_0; ++i) {
    $next_17(result);
  }
  return result;
}
;
_.isEmpty = function isEmpty_29(){
  var feature, featureMap, i, j, size_0, value_0;
  if (this.eStructuralFeatures != null) {
    for (i = 0; i < this.eStructuralFeatures.length; ++i) {
      feature = this.eStructuralFeatures[i];
      if (!this.useIsSet() || this.eObject.eIsSet_0(feature)) {
        value_0 = this.eObject.eGet_1(feature, false);
        $clinit_FeatureMapUtil();
        if (castTo(feature, 63).isFeatureMap_0()) {
          featureMap = castTo(value_0, 188);
          for (j = 0 , size_0 = featureMap.size_1(); j < size_0; ++j) {
            if ($isIncludedEntry(featureMap.getEStructuralFeature_0(j)) && featureMap.getValue_0(j) != null) {
              return false;
            }
          }
        }
         else if (feature.isMany()) {
          if (!castTo(value_0, 13).isEmpty()) {
            return false;
          }
        }
         else if (value_0 != null) {
          return false;
        }
      }
    }
  }
  return true;
}
;
_.iterator_0 = function iterator_80(){
  return $iterator_4(this);
}
;
_.listIterator_1 = function listIterator_28(index_0){
  var i, result;
  if (this.eStructuralFeatures == null) {
    if (index_0 != 0) {
      throw toJs(new IndexOutOfBoundsException_0('index=' + index_0 + ', size=0'));
    }
    return $clinit_EContentsEList$FeatureIteratorImpl() , $clinit_EContentsEList$FeatureIteratorImpl() , EMPTY_ITERATOR;
  }
  result = this.resolve_0()?this.newResolvingListIterator():this.newNonResolvingListIterator();
  for (i = 0; i < index_0; ++i) {
    $next_17(result);
  }
  return result;
}
;
_.newNonResolvingListIterator = function newNonResolvingListIterator(){
  return new EContentsEList$FeatureIteratorImpl(this.eObject, this.eStructuralFeatures);
}
;
_.newResolvingListIterator = function newResolvingListIterator(){
  return new EContentsEList$ResolvingFeatureIteratorImpl(this.eObject, this.eStructuralFeatures);
}
;
_.resolve_0 = function resolve_4(){
  return true;
}
;
_.size_1 = function size_67(){
  var feature, featureMap, i, j, result, size_0, value_0;
  result = 0;
  if (this.eStructuralFeatures != null) {
    for (i = 0; i < this.eStructuralFeatures.length; ++i) {
      feature = this.eStructuralFeatures[i];
      if (!this.useIsSet() || this.eObject.eIsSet_0(feature)) {
        value_0 = this.eObject.eGet_1(feature, false);
        $clinit_FeatureMapUtil();
        if (castTo(feature, 63).isFeatureMap_0()) {
          featureMap = castTo(value_0, 188);
          for (j = 0 , size_0 = featureMap.size_1(); j < size_0; ++j) {
            $isIncludedEntry(featureMap.getEStructuralFeature_0(j)) && featureMap.getValue_0(j) != null && ++result;
          }
        }
         else 
          feature.isMany()?(result += castTo(value_0, 13).size_1()):value_0 != null && ++result;
      }
    }
  }
  return result;
}
;
_.useIsSet = function useIsSet(){
  return true;
}
;
var EMPTY_CONTENTS_ELIST;
var Lorg_eclipse_emf_ecore_util_EContentsEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EContentsEList', 460);
function ENamedElementImpl$1($anonymous0, $anonymous1){
  $clinit_EContentsEList();
  EContentsEList.call(this, $anonymous0, $anonymous1);
}

defineClass(1044, 460, $intern_159, ENamedElementImpl$1);
_.newNonResolvingListIterator = function newNonResolvingListIterator_0(){
  return new ENamedElementImpl$1$2(this.eObject, this.eStructuralFeatures);
}
;
_.newResolvingListIterator = function newResolvingListIterator_0(){
  return new ENamedElementImpl$1$1(this.eObject, this.eStructuralFeatures);
}
;
_.useIsSet = function useIsSet_0(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_ENamedElementImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ENamedElementImpl/1', 1044);
function $clinit_EContentsEList$FeatureIteratorImpl(){
  $clinit_EContentsEList$FeatureIteratorImpl = emptyMethod;
  EMPTY_ITERATOR = new EContentsEList$FeatureIteratorImpl$1;
}

function $next_17(this$static){
  var result;
  if (this$static.prepared > 1 || this$static.hasNext_0()) {
    ++this$static.cursor;
    this$static.prepared = 0;
    result = this$static.preparedResult;
    this$static.hasNext_0();
    return result;
  }
   else {
    throw toJs(new NoSuchElementException);
  }
}

function $scanNext(this$static){
  var entry, entryFeature;
  if (this$static.isHandlingFeatureMap) {
    while (this$static.valueListIndex < this$static.valueListSize) {
      entry = castTo(!this$static.valueInternalEList?this$static.valueList.get_3(this$static.valueListIndex):this$static.valueInternalEList.basicGet(this$static.valueListIndex), 76);
      entryFeature = entry.getEStructuralFeature();
      if (instanceOf(entryFeature, 66) && (castTo(castTo(entryFeature, 17), 66).eFlags & $intern_138) != 0 && (!this$static.featureFilter || entryFeature.getContainerClass() != Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit || entryFeature.getFeatureID_0() != 0) && entry.getValue() != null) {
        return true;
      }
       else {
        ++this$static.valueListIndex;
      }
    }
    return false;
  }
   else {
    return this$static.valueListIndex < this$static.valueListSize;
  }
}

function $scanNext_0(this$static, values){
  var entry, entryFeature;
  if (this$static.isHandlingFeatureMap) {
    while (values.hasNext_0()) {
      entry = castTo(values.next_1(), 76);
      entryFeature = entry.getEStructuralFeature();
      if (instanceOf(entryFeature, 66) && (castTo(castTo(entryFeature, 17), 66).eFlags & $intern_138) != 0 && (!this$static.featureFilter || entryFeature.getContainerClass() != Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit || entryFeature.getFeatureID_0() != 0) && entry.getValue() != null) {
        values.previous_0();
        return true;
      }
    }
    return false;
  }
   else {
    return values.hasNext_0();
  }
}

function $scanPrevious(this$static){
  var entry, entryFeature;
  if (this$static.isHandlingFeatureMap) {
    while (this$static.valueListIndex > 0) {
      entry = castTo(this$static.valueList.get_3(this$static.valueListIndex - 1), 76);
      entryFeature = entry.getEStructuralFeature();
      if (instanceOf(entryFeature, 66) && (castTo(castTo(entryFeature, 17), 66).eFlags & $intern_138) != 0 && (!this$static.featureFilter || entryFeature.getContainerClass() != Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit || entryFeature.getFeatureID_0() != 0) && entry.getValue() != null) {
        return true;
      }
       else {
        --this$static.valueListIndex;
      }
    }
    return false;
  }
   else {
    return this$static.valueListIndex > 0;
  }
}

function $scanPrevious_0(this$static, values){
  var entry, entryFeature;
  if (this$static.isHandlingFeatureMap) {
    while (values.hasPrevious()) {
      entry = castTo(values.previous_0(), 76);
      entryFeature = entry.getEStructuralFeature();
      if (instanceOf(entryFeature, 66) && (castTo(castTo(entryFeature, 17), 66).eFlags & $intern_138) != 0 && (!this$static.featureFilter || entryFeature.getContainerClass() != Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit || entryFeature.getFeatureID_0() != 0) && entry.getValue() != null) {
        values.next_1();
        return true;
      }
    }
    return false;
  }
   else {
    return values.hasPrevious();
  }
}

function EContentsEList$FeatureIteratorImpl(eObject, eStructuralFeatures){
  $clinit_EContentsEList$FeatureIteratorImpl();
  this.eObject = eObject;
  this.eStructuralFeatures = eStructuralFeatures;
}

defineClass(272, 1, $intern_160, EContentsEList$FeatureIteratorImpl);
_.forEachRemaining = function forEachRemaining_50(consumer){
  $forEachRemaining(this, consumer);
}
;
_.add_2 = function add_62(o){
  throw toJs(new UnsupportedOperationException);
}
;
_.filter_0 = function filter_2(featureFilter){
  if (this.prepared != 0 || !!this.featureFilter) {
    throw toJs(new IllegalStateException_0('Iterator already in use or already filtered'));
  }
  this.featureFilter = featureFilter;
}
;
_.hasNext_0 = function hasNext_46(){
  var entry, feature, newPreparedResult, newValueList, result, value_0;
  switch (this.prepared) {
    case 3:
    case 2:
      {
        return true;
      }

    case 1:
      {
        return false;
      }

    case -3:
      {
        !this.values?++this.valueListIndex:this.values.next_1();
      }

    default:{
        if (!this.valueList || (!this.values?!$scanNext(this):!$scanNext_0(this, this.values))) {
          while (this.featureCursor < this.eStructuralFeatures.length) {
            feature = this.eStructuralFeatures[this.featureCursor++];
            if ((!this.featureFilter || feature.getContainerClass() != Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit || feature.getFeatureID_0() != 0) && (!this.useIsSet() || this.eObject.eIsSet_0(feature))) {
              value_0 = this.eObject.eGet_1(feature, this.resolve_0());
              this.isHandlingFeatureMap = ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0());
              if (this.isHandlingFeatureMap || feature.isMany()) {
                if (this.resolve_0()) {
                  newValueList = castTo(value_0, 15);
                  this.valueList = newValueList;
                }
                 else {
                  newValueList = castTo(value_0, 69);
                  this.valueList = this.valueInternalEList = newValueList;
                }
                if (instanceOf(this.valueList, 50)) {
                  this.values = null;
                  this.valueListSize = this.valueList.size_1();
                  this.valueListIndex = 0;
                }
                 else {
                  this.values = !this.valueInternalEList?this.valueList.listIterator_0():this.valueInternalEList.basicListIterator();
                }
                if (!this.values?$scanNext(this):$scanNext_0(this, this.values)) {
                  result = !this.values?!this.valueInternalEList?this.valueList.get_3(this.valueListIndex++):this.valueInternalEList.basicGet(this.valueListIndex++):this.values.next_1();
                  if (this.isHandlingFeatureMap) {
                    entry = castTo(result, 76);
                    entry.getEStructuralFeature();
                    newPreparedResult = entry.getValue();
                    this.preparedResult = newPreparedResult;
                  }
                   else {
                    this.preparedResult = result;
                  }
                  this.prepared = 3;
                  return true;
                }
              }
               else if (value_0 != null) {
                this.valueList = null;
                this.values = null;
                this.preparedResult = value_0;
                this.prepared = 2;
                return true;
              }
            }
          }
          this.valueList = null;
          this.values = null;
          this.isHandlingFeatureMap = false;
          this.prepared = 1;
          return false;
        }
         else {
          result = !this.values?!this.valueInternalEList?this.valueList.get_3(this.valueListIndex++):this.valueInternalEList.basicGet(this.valueListIndex++):this.values.next_1();
          if (this.isHandlingFeatureMap) {
            entry = castTo(result, 76);
            entry.getEStructuralFeature();
            newPreparedResult = entry.getValue();
            this.preparedResult = newPreparedResult;
          }
           else {
            this.preparedResult = result;
          }
          this.prepared = 3;
          return true;
        }
      }

  }
}
;
_.hasPrevious = function hasPrevious_11(){
  var entry, feature, newPreparedResult, newValueList, result, value_0;
  switch (this.prepared) {
    case -3:
    case -2:
      {
        return true;
      }

    case -1:
      {
        return false;
      }

    case 3:
      {
        !this.values?--this.valueListIndex:this.values.previous_0();
      }

    default:{
        if (!this.valueList || (!this.values?!$scanPrevious(this):!$scanPrevious_0(this, this.values))) {
          while (this.featureCursor > 0) {
            feature = this.eStructuralFeatures[--this.featureCursor];
            if ((!this.featureFilter || feature.getContainerClass() != Lorg_eclipse_elk_graph_EMapPropertyHolder_2_classLit || feature.getFeatureID_0() != 0) && (!this.useIsSet() || this.eObject.eIsSet_0(feature))) {
              value_0 = this.eObject.eGet_1(feature, this.resolve_0());
              this.isHandlingFeatureMap = ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0());
              if (this.isHandlingFeatureMap || feature.isMany()) {
                if (this.resolve_0()) {
                  newValueList = castTo(value_0, 15);
                  this.valueList = newValueList;
                }
                 else {
                  newValueList = castTo(value_0, 69);
                  this.valueList = this.valueInternalEList = newValueList;
                }
                if (instanceOf(this.valueList, 50)) {
                  this.valueListSize = this.valueList.size_1();
                  this.valueListIndex = this.valueListSize;
                }
                 else {
                  this.values = !this.valueInternalEList?this.valueList.listIterator_1(this.valueList.size_1()):this.valueInternalEList.basicListIterator_0(this.valueList.size_1());
                }
                if (!this.values?$scanPrevious(this):$scanPrevious_0(this, this.values)) {
                  result = !this.values?!this.valueInternalEList?this.valueList.get_3(--this.valueListIndex):this.valueInternalEList.basicGet(--this.valueListIndex):this.values.previous_0();
                  if (this.isHandlingFeatureMap) {
                    entry = castTo(result, 76);
                    entry.getEStructuralFeature();
                    newPreparedResult = entry.getValue();
                    this.preparedResult = newPreparedResult;
                  }
                   else {
                    this.preparedResult = result;
                  }
                  this.prepared = -3;
                  return true;
                }
              }
               else if (value_0 != null) {
                this.valueList = null;
                this.values = null;
                this.preparedResult = value_0;
                this.prepared = -2;
                return true;
              }
            }
          }
          this.valueList = null;
          this.values = null;
          this.prepared = -1;
          return false;
        }
         else {
          result = !this.values?!this.valueInternalEList?this.valueList.get_3(--this.valueListIndex):this.valueInternalEList.basicGet(--this.valueListIndex):this.values.previous_0();
          if (this.isHandlingFeatureMap) {
            entry = castTo(result, 76);
            entry.getEStructuralFeature();
            newPreparedResult = entry.getValue();
            this.preparedResult = newPreparedResult;
          }
           else {
            this.preparedResult = result;
          }
          this.prepared = -3;
          return true;
        }
      }

  }
}
;
_.next_1 = function next_47(){
  return $next_17(this);
}
;
_.nextIndex_0 = function nextIndex_12(){
  return this.cursor;
}
;
_.previous_0 = function previous_12(){
  var result;
  if (this.prepared < -1 || this.hasPrevious()) {
    --this.cursor;
    this.prepared = 0;
    result = this.preparedResult;
    this.hasPrevious();
    return result;
  }
   else {
    throw toJs(new NoSuchElementException);
  }
}
;
_.previousIndex = function previousIndex_11(){
  return this.cursor - 1;
}
;
_.remove_0 = function remove_122(){
  throw toJs(new UnsupportedOperationException);
}
;
_.resolve_0 = function resolve_5(){
  return false;
}
;
_.set_1 = function set_34(o){
  throw toJs(new UnsupportedOperationException);
}
;
_.useIsSet = function useIsSet_1(){
  return true;
}
;
_.cursor = 0;
_.featureCursor = 0;
_.isHandlingFeatureMap = false;
_.prepared = 0;
_.valueListIndex = 0;
_.valueListSize = 0;
var EMPTY_ITERATOR;
var Lorg_eclipse_emf_ecore_util_EContentsEList$FeatureIteratorImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EContentsEList/FeatureIteratorImpl', 272);
function EContentsEList$ResolvingFeatureIteratorImpl(eObject, eStructuralFeatures){
  $clinit_EContentsEList$FeatureIteratorImpl();
  EContentsEList$FeatureIteratorImpl.call(this, eObject, eStructuralFeatures);
}

defineClass(653, 272, $intern_160, EContentsEList$ResolvingFeatureIteratorImpl);
_.resolve_0 = function resolve_6(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_EContentsEList$ResolvingFeatureIteratorImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EContentsEList/ResolvingFeatureIteratorImpl', 653);
function ENamedElementImpl$1$1($anonymous0, $anonymous1){
  $clinit_EContentsEList$FeatureIteratorImpl();
  EContentsEList$ResolvingFeatureIteratorImpl.call(this, $anonymous0, $anonymous1);
}

defineClass(1045, 653, $intern_160, ENamedElementImpl$1$1);
_.useIsSet = function useIsSet_2(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_ENamedElementImpl$1$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ENamedElementImpl/1/1', 1045);
function ENamedElementImpl$1$2($anonymous0, $anonymous1){
  $clinit_EContentsEList$FeatureIteratorImpl();
  EContentsEList$FeatureIteratorImpl.call(this, $anonymous0, $anonymous1);
}

defineClass(1046, 272, $intern_160, ENamedElementImpl$1$2);
_.useIsSet = function useIsSet_3(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_ENamedElementImpl$1$2_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ENamedElementImpl/1/2', 1046);
function $$init_12(this$static){
}

function $getFeature(this$static){
  var eClass;
  if (!this$static.feature && this$static.featureID != -1) {
    eClass = this$static.notifier.eClass_0();
    this$static.feature = $getEStructuralFeature(eClass, this$static.featureID);
  }
  return this$static.feature;
}

function ENotificationImpl(notifier, featureID, oldDoubleValue, newDoubleValue){
  NotificationImpl.call(this, 1, oldDoubleValue, newDoubleValue);
  $$init_12(this);
  this.notifier = notifier;
  this.featureID = featureID;
}

function ENotificationImpl_0(notifier, featureID, oldIntValue, newIntValue){
  NotificationImpl_0.call(this, 1, oldIntValue, newIntValue);
  $$init_12(this);
  this.notifier = notifier;
  this.featureID = featureID;
}

function ENotificationImpl_1(notifier, eventType, featureID, oldValue, newValue){
  ENotificationImpl_2.call(this, notifier, eventType, featureID, oldValue, newValue, -1);
}

function ENotificationImpl_2(notifier, eventType, featureID, oldValue, newValue, position){
  NotificationImpl_1.call(this, eventType, oldValue, newValue, position);
  $$init_12(this);
  this.notifier = notifier;
  this.featureID = featureID;
}

function ENotificationImpl_3(notifier, eventType, featureID, oldValue, newValue, position, wasSet){
  NotificationImpl_2.call(this, eventType, oldValue, newValue, position, wasSet);
  $$init_12(this);
  this.notifier = notifier;
  this.featureID = featureID;
}

function ENotificationImpl_4(notifier, eventType, featureID, oldBooleanValue, newBooleanValue){
  NotificationImpl_3.call(this, eventType, oldBooleanValue, newBooleanValue);
  $$init_12(this);
  this.notifier = notifier;
  this.featureID = featureID;
}

function ENotificationImpl_5(notifier, eventType, feature, oldByteValue, newByteValue){
  this.eventType = eventType;
  this.oldSimplePrimitiveValue = oldByteValue;
  this.newSimplePrimitiveValue = newByteValue;
  this.position = -1;
  this.primitiveType = 1;
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_6(notifier, eventType, feature, oldByteValue, newByteValue, isSetChange){
  ENotificationImpl_5.call(this, notifier, eventType, feature, oldByteValue, newByteValue);
  isSetChange && (this.position = -2);
}

function ENotificationImpl_7(notifier, eventType, feature, oldCharValue, newCharValue){
  this.eventType = eventType;
  this.oldSimplePrimitiveValue = oldCharValue;
  this.newSimplePrimitiveValue = newCharValue;
  this.position = -1;
  this.primitiveType = 2;
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_8(notifier, eventType, feature, oldCharValue, newCharValue, isSetChange){
  ENotificationImpl_7.call(this, notifier, eventType, feature, oldCharValue, newCharValue);
  isSetChange && (this.position = -2);
}

function ENotificationImpl_9(notifier, eventType, feature, oldDoubleValue, newDoubleValue){
  NotificationImpl.call(this, eventType, oldDoubleValue, newDoubleValue);
  $$init_12(this);
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_10(notifier, eventType, feature, oldDoubleValue, newDoubleValue, isSetChange){
  ENotificationImpl_9.call(this, notifier, eventType, feature, oldDoubleValue, newDoubleValue);
  isSetChange && (this.position = -2);
}

function ENotificationImpl_11(notifier, eventType, feature, oldFloatValue, newFloatValue){
  this.eventType = eventType;
  this.oldIEEEPrimitiveValue = oldFloatValue;
  this.newIEEEPrimitiveValue = newFloatValue;
  this.position = -1;
  this.primitiveType = 4;
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_12(notifier, eventType, feature, oldFloatValue, newFloatValue, isSetChange){
  ENotificationImpl_11.call(this, notifier, eventType, feature, oldFloatValue, newFloatValue);
  isSetChange && (this.position = -2);
}

function ENotificationImpl_13(notifier, eventType, feature, oldIntValue, newIntValue){
  NotificationImpl_0.call(this, eventType, oldIntValue, newIntValue);
  $$init_12(this);
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_14(notifier, eventType, feature, oldIntValue, newIntValue, isSetChange){
  ENotificationImpl_13.call(this, notifier, eventType, feature, oldIntValue, newIntValue);
  isSetChange && (this.position = -2);
}

function ENotificationImpl_15(notifier, eventType, feature, oldLongValue, newLongValue){
  this.eventType = eventType;
  this.oldSimplePrimitiveValue = oldLongValue;
  this.newSimplePrimitiveValue = newLongValue;
  this.position = -1;
  this.primitiveType = 6;
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_16(notifier, eventType, feature, oldLongValue, newLongValue, isSetChange){
  ENotificationImpl_15.call(this, notifier, eventType, feature, oldLongValue, newLongValue);
  isSetChange && (this.position = -2);
}

function ENotificationImpl_17(notifier, eventType, feature, oldValue, newValue){
  ENotificationImpl_18.call(this, notifier, eventType, feature, oldValue, newValue, -1);
}

function ENotificationImpl_18(notifier, eventType, feature, oldValue, newValue, position){
  NotificationImpl_1.call(this, eventType, oldValue, newValue, position);
  $$init_12(this);
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_19(notifier, eventType, feature, oldValue, newValue, isSetChange){
  ENotificationImpl_18.call(this, notifier, eventType, feature, oldValue, newValue, isSetChange?-2:-1);
}

function ENotificationImpl_20(notifier, eventType, feature, oldShortValue, newShortValue){
  this.eventType = eventType;
  this.oldSimplePrimitiveValue = oldShortValue;
  this.newSimplePrimitiveValue = newShortValue;
  this.position = -1;
  this.primitiveType = 7;
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_21(notifier, eventType, feature, oldShortValue, newShortValue, isSetChange){
  ENotificationImpl_20.call(this, notifier, eventType, feature, oldShortValue, newShortValue);
  isSetChange && (this.position = -2);
}

function ENotificationImpl_22(notifier, eventType, feature, oldBooleanValue, newBooleanValue){
  NotificationImpl_3.call(this, eventType, oldBooleanValue, newBooleanValue);
  $$init_12(this);
  this.notifier = notifier;
  this.feature = feature;
}

function ENotificationImpl_23(notifier, eventType, feature, oldBooleanValue, newBooleanValue, isSetChange){
  ENotificationImpl_22.call(this, notifier, eventType, feature, oldBooleanValue, newBooleanValue);
  isSetChange && (this.position = -2);
}

defineClass(33, 142, $intern_145, ENotificationImpl, ENotificationImpl_0, ENotificationImpl_1, ENotificationImpl_2, ENotificationImpl_3, ENotificationImpl_4, ENotificationImpl_5, ENotificationImpl_6, ENotificationImpl_7, ENotificationImpl_8, ENotificationImpl_9, ENotificationImpl_10, ENotificationImpl_11, ENotificationImpl_12, ENotificationImpl_13, ENotificationImpl_14, ENotificationImpl_15, ENotificationImpl_16, ENotificationImpl_17, ENotificationImpl_19, ENotificationImpl_20, ENotificationImpl_21, ENotificationImpl_22, ENotificationImpl_23);
_.getFeature = function getFeature_6(){
  return $getFeature(this);
}
;
_.getFeatureDefaultValue = function getFeatureDefaultValue_0(){
  var feature;
  feature = $getFeature(this);
  if (feature) {
    return feature.getDefaultValue();
  }
  return null;
}
;
_.getFeatureID = function getFeatureID_10(expectedClass){
  this.featureID == -1 && !!this.feature && (this.featureID = this.notifier.eDerivedStructuralFeatureID(this.feature.getFeatureID_0(), this.feature.getContainerClass()));
  return this.notifier.eBaseStructuralFeatureID(this.featureID, expectedClass);
}
;
_.getNotifier = function getNotifier_6(){
  return this.notifier;
}
;
_.isFeatureUnsettable = function isFeatureUnsettable_0(){
  var feature;
  feature = $getFeature(this);
  if (feature) {
    return feature.isUnsettable();
  }
  return false;
}
;
_.featureID = -1;
var Lorg_eclipse_emf_ecore_impl_ENotificationImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ENotificationImpl', 33);
function $eBasicRemoveFromContainerFeature_9(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 10) {
    return this$static.eContainer.eInverseRemove(this$static, 11, Lorg_eclipse_emf_ecore_EClass_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EOPERATION):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function $getEGenericExceptions(this$static){
  if (!this$static.eGenericExceptions) {
    this$static.eGenericExceptions = new EOperationImpl$2(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this$static);
    !this$static.eExceptions && (this$static.eExceptions = new EOperationImpl$1(this$static, this$static));
  }
  return this$static.eGenericExceptions;
}

function $isSetEExceptions(this$static){
  return !!this$static.eExceptions && $getEGenericExceptions(this$static.eExceptions.this$01).size_0 != 0 && !(!!this$static.eGenericExceptions && $isSet_0(this$static.eGenericExceptions));
}

function EOperationImpl(){
  ETypedElementImpl.call(this);
}

defineClass(385, 278, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 53:1, 106:1, 446:1, 46:1, 93:1, 145:1, 385:1, 278:1, 109:1, 110:1}, EOperationImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_10(msgs){
  return $eBasicRemoveFromContainerFeature_9(this, msgs);
}
;
_.eGet = function eGet_27(featureID, resolve, coreType){
  var eClass, lower, upper;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
    case 3:
      return $clinit_Boolean() , (this.eFlags & 512) != 0?true:false;
    case 4:
      return valueOf_4(this.lowerBound);
    case 5:
      return valueOf_4(this.upperBound);
    case 6:
      return $clinit_Boolean() , upper = this.upperBound , upper > 1 || upper == -1?true:false;
    case 7:
      return $clinit_Boolean() , lower = this.lowerBound , lower >= 1?true:false;
    case 8:
      if (resolve)
        return $getEType(this);
      return this.eType;
    case 9:
      return this.eGenericType;
    case 10:
      return this.eFlags_0 >> 16 == 10?castTo(this.eContainer, 26):null;
    case 11:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 11)) , this.eTypeParameters;
    case 12:
      return !this.eParameters && (this.eParameters = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EParameter_2_classLit, this, 12, 10)) , this.eParameters;
    case 13:
      return !this.eExceptions && (this.eExceptions = new EOperationImpl$1(this, this)) , this.eExceptions;
    case 14:
      return $getEGenericExceptions(this);
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EOPERATION)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EOPERATION:eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_17(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 10:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_9(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $eBasicSetContainer(this, otherEnd, 10, msgs);
    case 12:
      return !this.eParameters && (this.eParameters = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EParameter_2_classLit, this, 12, 10)) , $basicAdd_0(this.eParameters, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EOPERATION):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EOPERATION)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_20(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 9:
      return $basicUnsetEGenericType(this, msgs);
    case 10:
      return $eBasicSetContainer(this, null, 10, msgs);
    case 11:
      return !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 11)) , $basicRemove_0(this.eTypeParameters, otherEnd, msgs);
    case 12:
      return !this.eParameters && (this.eParameters = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EParameter_2_classLit, this, 12, 10)) , $basicRemove_0(this.eParameters, otherEnd, msgs);
    case 14:
      return $basicRemove_0($getEGenericExceptions(this), otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EOPERATION):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EOPERATION)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_26(featureID){
  var eClass, lower, upper;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return (this.eFlags & 256) == 0;
    case 3:
      return (this.eFlags & 512) == 0;
    case 4:
      return this.lowerBound != 0;
    case 5:
      return this.upperBound != 1;
    case 6:
      return upper = this.upperBound , upper > 1 || upper == -1;
    case 7:
      return lower = this.lowerBound , lower >= 1;
    case 8:
      return !!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0;
    case 9:
      return !!this.eGenericType && !(!!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0);
    case 10:
      return !!(this.eFlags_0 >> 16 == 10?castTo(this.eContainer, 26):null);
    case 11:
      return !!this.eTypeParameters && this.eTypeParameters.size_0 != 0;
    case 12:
      return !!this.eParameters && this.eParameters.size_0 != 0;
    case 13:
      return !!this.eExceptions && $getEGenericExceptions(this.eExceptions.this$01).size_0 != 0 && !(!!this.eGenericExceptions && $isSet_0(this.eGenericExceptions));
    case 14:
      return !!this.eGenericExceptions && $isSet_0(this.eGenericExceptions);
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EOPERATION)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EOPERATION:eClass), featureID));
}
;
_.eSet = function eSet_25(featureID, newValue){
  var eClass, msgs;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName(this, castToString(newValue));
      return;
    case 2:
      $setOrdered(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 3:
      $setUnique_2(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 4:
      $setLowerBound(this, castTo(newValue, 21).value_0);
      return;
    case 5:
      $setUpperBound(this, castTo(newValue, 21).value_0);
      return;
    case 8:
      $setEType(this, castTo(newValue, 136));
      return;
    case 9:
      msgs = $setEGenericType(this, castTo(newValue, 86), null);
      !!msgs && msgs.dispatch_0();
      return;
    case 11:
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 11));
      $clear_11(this.eTypeParameters);
      !this.eTypeParameters && (this.eTypeParameters = new EObjectContainmentEList$Resolving(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, this, 11));
      $addAll_6(this.eTypeParameters, castTo(newValue, 13));
      return;
    case 12:
      !this.eParameters && (this.eParameters = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EParameter_2_classLit, this, 12, 10));
      $clear_11(this.eParameters);
      !this.eParameters && (this.eParameters = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EParameter_2_classLit, this, 12, 10));
      $addAll_6(this.eParameters, castTo(newValue, 13));
      return;
    case 13:
      !this.eExceptions && (this.eExceptions = new EOperationImpl$1(this, this));
      $clear_10(this.eExceptions);
      !this.eExceptions && (this.eExceptions = new EOperationImpl$1(this, this));
      $addAll_6(this.eExceptions, castTo(newValue, 13));
      return;
    case 14:
      $clear_11($getEGenericExceptions(this));
      $addAll_6($getEGenericExceptions(this), castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EOPERATION)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EOPERATION:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_26(){
  return $clinit_EcorePackage$Literals() , EOPERATION;
}
;
_.freeze = function freeze_7(){
  var i, size_0;
  if (this.eParameters) {
    for (i = 0 , size_0 = this.eParameters.size_0; i < size_0; ++i) {
      $freeze($get_16(this.eParameters, i));
    }
  }
  $getEType(this);
  this.eFlags |= 1;
}
;
var Lorg_eclipse_emf_ecore_impl_EOperationImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EOperationImpl', 385);
function $delegateAdd_1(this$static, index_0, eClassifier){
  $add_20($getEGenericExceptions(this$static.this$01), index_0, $wrap_0(eClassifier));
}

function $delegateAdd_2(this$static, eClassifier){
  $add_21($getEGenericExceptions(this$static.this$01), $wrap_0(eClassifier));
}

function $delegateContains_0(this$static, object){
  var eClassifier, eClassifier$iterator;
  for (eClassifier$iterator = new AbstractEList$EIterator(this$static); eClassifier$iterator.cursor != eClassifier$iterator.this$01_2.size_1();) {
    eClassifier = castTo($doNext(eClassifier$iterator), 136);
    if (maskUndefined(object) === maskUndefined(eClassifier)) {
      return true;
    }
  }
  return false;
}

function $delegateSet_0(this$static, index_0, eClassifier){
  var eGenericType, result, result0;
  eGenericType = castTo($get_16($getEGenericExceptions(this$static.this$01), index_0), 86);
  result0 = (result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT));
  (result0.eIsProxy()?$eResolveProxy(this$static.owner, castTo(result0, 46)):result0) == eClassifier?$getERawType(eGenericType):$setEClassifier(eGenericType, eClassifier);
  return result0;
}

function $wrap_0(eClassifier){
  var eGenericType, eGenericType0;
  eGenericType0 = ($clinit_EcoreFactory() , eGenericType = new EGenericTypeImpl , eGenericType);
  $setEClassifier(eGenericType0, eClassifier);
  return eGenericType0;
}

function EOperationImpl$1(this$0, $anonymous0){
  this.this$01 = this$0;
  DelegatingEcoreEList.call(this, $anonymous0);
}

defineClass(476, 691, $intern_158, EOperationImpl$1);
_.delegateAdd = function delegateAdd_3(index_0, eClassifier){
  $delegateAdd_1(this, index_0, castTo(eClassifier, 136));
}
;
_.delegateAdd_0 = function delegateAdd_4(eClassifier){
  $delegateAdd_2(this, castTo(eClassifier, 136));
}
;
_.delegateGet = function delegateGet_1(index_0){
  var eGenericType, result;
  return eGenericType = castTo($get_16($getEGenericExceptions(this.this$01), index_0), 86) , result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT);
}
;
_.delegateRemove = function delegateRemove_1(index_0){
  var eGenericType, result;
  return eGenericType = castTo($remove_34($getEGenericExceptions(this.this$01), index_0), 86) , result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT);
}
;
_.delegateSet = function delegateSet_1(index_0, eClassifier){
  return $delegateSet_0(this, index_0, castTo(eClassifier, 136));
}
;
_.canContainNull = function canContainNull_5(){
  return false;
}
;
_.createNotification = function createNotification_5(eventType, oldObject, newObject, index_0, wasSet){
  return null;
}
;
_.delegateBasicList = function delegateBasicList_1(){
  return new EOperationImpl$1$1(this);
}
;
_.delegateClear = function delegateClear_1(){
  $clear_11($getEGenericExceptions(this.this$01));
}
;
_.delegateContains = function delegateContains_1(object){
  return $delegateContains_0(this, object);
}
;
_.delegateContainsAll = function delegateContainsAll_1(collection){
  var object, object$iterator;
  for (object$iterator = collection.iterator_0(); object$iterator.hasNext_0();) {
    object = object$iterator.next_1();
    if (!$delegateContains_0(this, object)) {
      return false;
    }
  }
  return true;
}
;
_.delegateEquals = function delegateEquals_1(object){
  var i, j, list;
  if (instanceOf(object, 15)) {
    list = castTo(object, 15);
    if (list.size_1() == $getEGenericExceptions(this.this$01).size_0) {
      for (i = list.iterator_0() , j = new AbstractEList$EIterator(this); i.hasNext_0();) {
        if (maskUndefined(i.next_1()) !== maskUndefined($doNext(j))) {
          return false;
        }
      }
      return true;
    }
  }
  return false;
}
;
_.delegateHashCode = function delegateHashCode_1(){
  var eGenericType, eGenericType$iterator, hashCode, object, result;
  hashCode = 1;
  for (eGenericType$iterator = new AbstractEList$EIterator($getEGenericExceptions(this.this$01)); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    object = (result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT));
    hashCode = 31 * hashCode + (!object?0:hashCode__I__devirtual$(object));
  }
  return hashCode;
}
;
_.delegateIndexOf = function delegateIndexOf_1(object){
  var eGenericType, eGenericType$iterator, index_0, result;
  index_0 = 0;
  for (eGenericType$iterator = new AbstractEList$EIterator($getEGenericExceptions(this.this$01)); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    if (maskUndefined(object) === maskUndefined((result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT)))) {
      return index_0;
    }
    ++index_0;
  }
  return -1;
}
;
_.delegateIsEmpty = function delegateIsEmpty_1(){
  return $getEGenericExceptions(this.this$01).size_0 == 0;
}
;
_.delegateList_0 = function delegateList_2(){
  return null;
}
;
_.delegateSize = function delegateSize_1(){
  return $getEGenericExceptions(this.this$01).size_0;
}
;
_.delegateToArray = function delegateToArray_3(){
  var eGenericType, eGenericType$iterator, index_0, result, result0, size_0;
  size_0 = $getEGenericExceptions(this.this$01).size_0;
  result0 = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, size_0, 5, 1);
  index_0 = 0;
  for (eGenericType$iterator = new AbstractEList$EIterator($getEGenericExceptions(this.this$01)); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    result0[index_0++] = (result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT));
  }
  return result0;
}
;
_.delegateToArray_0 = function delegateToArray_4(array){
  var eGenericType, eGenericType$iterator, index_0, newArray, rawType, result, size_0;
  size_0 = $getEGenericExceptions(this.this$01).size_0;
  if (array.length < size_0) {
    newArray = newInstance_10(getClass__Ljava_lang_Class___devirtual$(array).componentType, size_0);
    array = newArray;
  }
  array.length > size_0 && setCheck(array, size_0, null);
  index_0 = 0;
  for (eGenericType$iterator = new AbstractEList$EIterator($getEGenericExceptions(this.this$01)); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    rawType = (result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT));
    setCheck(array, index_0++, rawType);
  }
  return array;
}
;
_.delegateToString = function delegateToString_1(){
  var eGenericExceptions, i, result, size_0, stringBuffer;
  stringBuffer = new StringBuffer;
  stringBuffer.string += '[';
  eGenericExceptions = $getEGenericExceptions(this.this$01);
  for (i = 0 , size_0 = $getEGenericExceptions(this.this$01).size_0; i < size_0;) {
    $append_3(stringBuffer, valueOf_7((result = castTo($get_16(eGenericExceptions, i), 86).eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT))));
    ++i < size_0 && (stringBuffer.string += ', ' , stringBuffer);
  }
  stringBuffer.string += ']';
  return stringBuffer.string;
}
;
_.dispatchNotification = function dispatchNotification_4(notification){
}
;
_.getFeatureID_0 = function getFeatureID_11(){
  return 13;
}
;
_.hasInstanceClass = function hasInstanceClass_2(){
  return true;
}
;
_.hasInverse = function hasInverse_5(){
  return false;
}
;
_.hasManyInverse = function hasManyInverse_2(){
  return false;
}
;
_.hasNavigableInverse = function hasNavigableInverse_3(){
  return false;
}
;
_.hasProxies = function hasProxies_2(){
  return true;
}
;
_.isContainment = function isContainment_5(){
  return false;
}
;
_.isEObject = function isEObject_3(){
  return true;
}
;
_.isInstance = function isInstance_5(object){
  return instanceOf(object, 136);
}
;
_.isSet_0 = function isSet_8(){
  return $isSetEExceptions(this.this$01);
}
;
_.isUnique = function isUnique_6(){
  return true;
}
;
_.useEquals = function useEquals_12(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EOperationImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EOperationImpl/1', 476);
function EOperationImpl$1$1(this$1){
  this.this$11 = this$1;
}

defineClass(1241, 1741, $intern_36, EOperationImpl$1$1);
_.listIterator_1 = function listIterator_29(index_0){
  return $basicListIterator(this.this$11, index_0);
}
;
_.size_1 = function size_68(){
  return $getEGenericExceptions(this.this$11.this$01).size_0;
}
;
var Lorg_eclipse_emf_ecore_impl_EOperationImpl$1$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EOperationImpl/1/1', 1241);
function $isSet_0(this$static){
  var eGenericType, eGenericType$iterator;
  for (eGenericType$iterator = new AbstractEList$EIterator(this$static); eGenericType$iterator.cursor != eGenericType$iterator.this$01_2.size_1();) {
    eGenericType = castTo($doNext(eGenericType$iterator), 86);
    if (!!eGenericType.eTypeParameter || (!eGenericType.eTypeArguments && (eGenericType.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, eGenericType, 1)) , eGenericType.eTypeArguments).size_0 != 0) {
      return true;
    }
  }
  return false;
}

function $shadowAdd_0(this$static, eGenericType, notifications){
  var notification, result;
  notification = new ENotificationImpl_3(this$static.owner, 3, 13, null, (result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT)), $indexOf_6(this$static, eGenericType), false);
  !notifications?(notifications = notification):notifications.add_4(notification);
  return notifications;
}

function $shadowRemove_0(this$static, eGenericType, notifications){
  var notification, result;
  notification = new ENotificationImpl_3(this$static.owner, 4, 13, (result = eGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT)), null, $indexOf_6(this$static, eGenericType), false);
  !notifications?(notifications = notification):notifications.add_4(notification);
  return notifications;
}

function $shadowSet_0(this$static, oldEGenericType, newEGenericType, notifications){
  var notification, result, result0;
  notification = new ENotificationImpl_3(this$static.owner, 1, 13, (result0 = oldEGenericType.eRawType , result0?result0:($clinit_EcorePackage$Literals() , EJAVA_OBJECT)), (result = newEGenericType.eRawType , result?result:($clinit_EcorePackage$Literals() , EJAVA_OBJECT)), $indexOf_6(this$static, oldEGenericType), false);
  !notifications?(notifications = notification):notifications.add_4(notification);
  return notifications;
}

function EOperationImpl$2($anonymous0, $anonymous1){
  EObjectContainmentEList$Unsettable.call(this, $anonymous0, $anonymous1, 14);
}

defineClass(1242, 509, $intern_156, EOperationImpl$2);
_.shadowAdd = function shadowAdd_1(eGenericType, notifications){
  return $shadowAdd_0(this, castTo(eGenericType, 86), notifications);
}
;
_.shadowRemove = function shadowRemove_1(eGenericType, notifications){
  return $shadowRemove_0(this, castTo(eGenericType, 86), notifications);
}
;
_.shadowSet = function shadowSet_1(oldEGenericType, newEGenericType, notifications){
  return $shadowSet_0(this, castTo(oldEGenericType, 86), castTo(newEGenericType, 86), notifications);
}
;
_.createNotification = function createNotification_6(eventType, oldObject, newObject, index_0, wasSet){
  switch (eventType) {
    case 3:
      {
        return $createNotification(this, 3, oldObject, newObject, index_0, this.size_0 > 1);
      }

    case 5:
      {
        return $createNotification(this, 5, oldObject, newObject, index_0, this.size_0 - castTo(newObject, 15).size_1() > 0);
      }

    default:{
        return new ENotificationImpl_3(this.owner, eventType, this.featureID, oldObject, newObject, index_0, true);
      }

  }
}
;
_.hasShadow = function hasShadow_1(){
  return true;
}
;
_.isSet_0 = function isSet_9(){
  return $isSet_0(this);
}
;
_.unset = function unset_5(){
  $clear_11(this);
}
;
var Lorg_eclipse_emf_ecore_impl_EOperationImpl$2_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EOperationImpl/2', 1242);
function EPackageImpl$1(this$0, val$factory){
  this.this$01 = this$0;
  this.val$factory2 = val$factory;
}

defineClass(469, 1, {1717:1, 469:1}, EPackageImpl$1);
var Lorg_eclipse_emf_ecore_impl_EPackageImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EPackageImpl/1', 469);
function EObjectContainmentWithInverseEList(dataClass, owner, featureID, inverseFeatureID){
  EObjectContainmentEList.call(this, dataClass, owner, featureID);
  this.inverseFeatureID = inverseFeatureID;
}

defineClass(18, 84, $intern_156, EObjectContainmentWithInverseEList);
_.getInverseFeatureClass = function getInverseFeatureClass_0(){
  return this.dataClass;
}
;
_.getInverseFeatureID = function getInverseFeatureID_0(){
  return this.inverseFeatureID;
}
;
_.hasNavigableInverse = function hasNavigableInverse_4(){
  return true;
}
;
_.inverseFeatureID = 0;
var Lorg_eclipse_emf_ecore_util_EObjectContainmentWithInverseEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectContainmentWithInverseEList', 18);
function EObjectContainmentWithInverseEList$Resolving(dataClass, owner, featureID, inverseFeatureID){
  EObjectContainmentWithInverseEList.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(375, 18, $intern_156, EObjectContainmentWithInverseEList$Resolving);
_.hasProxies = function hasProxies_3(){
  return true;
}
;
_.resolve = function resolve_7(index_0, object){
  return $resolve(this, index_0, castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_util_EObjectContainmentWithInverseEList$Resolving_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectContainmentWithInverseEList/Resolving', 375);
function EPackageImpl$2(this$0, $anonymous0, $anonymous1){
  this.this$01 = this$0;
  EObjectContainmentWithInverseEList$Resolving.call(this, $anonymous0, $anonymous1, 5, 6);
}

defineClass(309, 375, $intern_156, EPackageImpl$2);
_.didChange = function didChange_1(){
  this.this$01.eNameToEClassifierMap = null;
}
;
var Lorg_eclipse_emf_ecore_impl_EPackageImpl$2_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EPackageImpl/2', 309);
function EPackageImpl$3(){
}

defineClass(1129, 1, {}, EPackageImpl$3);
var Lorg_eclipse_emf_ecore_impl_EPackageImpl$3_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EPackageImpl/3', 1129);
function $getEFactory(this$static, nsURI){
  var ePackage, ePackageDescriptor, result;
  ePackage = $get_11(this$static.stringMap, nsURI);
  if (instanceOf(ePackage, 214)) {
    result = castTo(ePackage, 214);
    result.getNsURI() == null && undefined;
    return result.getEFactoryInstance();
  }
   else if (instanceOf(ePackage, 469)) {
    ePackageDescriptor = castTo(ePackage, 1717);
    result = ePackageDescriptor.val$factory2;
    return result;
  }
   else {
    return null;
  }
}

function $getEPackage_0(this$static, nsURI){
  var ePackage, ePackageDescriptor, result;
  ePackage = nsURI == null?getEntryValueOrNull($getEntry(this$static.hashCodeMap, null)):$get_11(this$static.stringMap, nsURI);
  if (instanceOf(ePackage, 214)) {
    result = castTo(ePackage, 214);
    result.getNsURI() == null && undefined;
    return result;
  }
   else if (instanceOf(ePackage, 469)) {
    ePackageDescriptor = castTo(ePackage, 1717);
    result = ePackageDescriptor.this$01;
    !!result && (result.nsURI == null?undefined:nsURI == null?$put_4(this$static.hashCodeMap, null, result):$put_5(this$static.stringMap, nsURI, result));
    return result;
  }
   else {
    return null;
  }
}

function EPackageRegistryImpl(){
  HashMap.call(this);
}

defineClass(668, 41, $intern_78, EPackageRegistryImpl);
_.containsKey = function containsKey_11(key){
  return instanceOfString(key)?$hasStringValue(this, key):!!$getEntry(this.hashCodeMap, key);
}
;
var Lorg_eclipse_emf_ecore_impl_EPackageRegistryImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EPackageRegistryImpl', 668);
function $eBasicRemoveFromContainerFeature_10(this$static, msgs){
  var eClass, inverseFeature;
  if (this$static.eFlags_0 >> 16 == 10) {
    return this$static.eContainer.eInverseRemove(this$static, 12, Lorg_eclipse_emf_ecore_EOperation_2_classLit, msgs);
  }
  return inverseFeature = $getEOpposite(castTo($getEStructuralFeature((eClass = castTo($getField(this$static, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EPARAMETER):eClass), this$static.eFlags_0 >> 16), 17)) , this$static.eContainer.eInverseRemove(this$static, inverseFeature.featureID, inverseFeature.containerClass, msgs);
}

function EParameterImpl(){
  ETypedElementImpl.call(this);
}

defineClass(482, 278, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 1784:1, 106:1, 446:1, 46:1, 93:1, 145:1, 482:1, 278:1, 109:1, 110:1}, EParameterImpl);
_.eBasicRemoveFromContainerFeature = function eBasicRemoveFromContainerFeature_11(msgs){
  return $eBasicRemoveFromContainerFeature_10(this, msgs);
}
;
_.eGet = function eGet_28(featureID, resolve, coreType){
  var eClass, lower, upper;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
    case 3:
      return $clinit_Boolean() , (this.eFlags & 512) != 0?true:false;
    case 4:
      return valueOf_4(this.lowerBound);
    case 5:
      return valueOf_4(this.upperBound);
    case 6:
      return $clinit_Boolean() , upper = this.upperBound , upper > 1 || upper == -1?true:false;
    case 7:
      return $clinit_Boolean() , lower = this.lowerBound , lower >= 1?true:false;
    case 8:
      if (resolve)
        return $getEType(this);
      return this.eType;
    case 9:
      return this.eGenericType;
    case 10:
      return this.eFlags_0 >> 16 == 10?castTo(this.eContainer, 53):null;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPARAMETER)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EPARAMETER:eClass), featureID), resolve, coreType);
}
;
_.eInverseAdd_0 = function eInverseAdd_18(otherEnd, featureID, msgs){
  var eClass, eContainerFeatureID, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicAdd_0(this.eAnnotations, otherEnd, msgs);
    case 10:
      !!this.eContainer && (msgs = (eContainerFeatureID = this.eFlags_0 >> 16 , eContainerFeatureID >= 0?$eBasicRemoveFromContainerFeature_10(this, msgs):this.eContainer.eInverseRemove(this, -1 - eContainerFeatureID, null, msgs)));
      return $eBasicSetContainer(this, otherEnd, 10, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EPARAMETER):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseAdd(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPARAMETER)), otherEnd, msgs);
}
;
_.eInverseRemove_0 = function eInverseRemove_21(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 9:
      return $basicUnsetEGenericType(this, msgs);
    case 10:
      return $eBasicSetContainer(this, null, 10, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , EPARAMETER):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPARAMETER)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_27(featureID){
  var eClass, lower, upper;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return (this.eFlags & 256) == 0;
    case 3:
      return (this.eFlags & 512) == 0;
    case 4:
      return this.lowerBound != 0;
    case 5:
      return this.upperBound != 1;
    case 6:
      return upper = this.upperBound , upper > 1 || upper == -1;
    case 7:
      return lower = this.lowerBound , lower >= 1;
    case 8:
      return !!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0;
    case 9:
      return !!this.eGenericType && !(!!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0);
    case 10:
      return !!(this.eFlags_0 >> 16 == 10?castTo(this.eContainer, 53):null);
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EPARAMETER)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EPARAMETER:eClass), featureID));
}
;
_.eStaticClass = function eStaticClass_27(){
  return $clinit_EcorePackage$Literals() , EPARAMETER;
}
;
var Lorg_eclipse_emf_ecore_impl_EParameterImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EParameterImpl', 482);
function $basicGetEReferenceType(this$static){
  var eType;
  if (!this$static.eReferenceType) {
    eType = this$static.eType;
    instanceOf(eType, 99) && (this$static.eReferenceType = castTo(eType, 26));
  }
  return this$static.eReferenceType;
}

function $getEOpposite(this$static){
  var oldEOpposite;
  if (!!this$static.eOpposite && (this$static.eOpposite.eFlags_0 & 64) != 0) {
    oldEOpposite = this$static.eOpposite;
    this$static.eOpposite = castTo($eResolveProxy(this$static, oldEOpposite), 17);
    this$static.eOpposite != oldEOpposite && (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 9, 21, oldEOpposite, this$static.eOpposite));
  }
  return this$static.eOpposite;
}

function $getEReferenceType(this$static){
  var eType;
  if (!this$static.eReferenceType || (this$static.eFlags & 1) == 0 && (this$static.eReferenceType.eFlags_0 & 64) != 0) {
    eType = $getEType(this$static);
    instanceOf(eType, 99) && (this$static.eReferenceType = castTo(eType, 26));
  }
  return this$static.eReferenceType;
}

function $setContainment(this$static, value_0){
  $setContainmentGen(this$static, value_0);
  instanceOf(this$static.eContainer, 99) && $setFlags_0($getESuperAdapter(castTo(this$static.eContainer, 99)), 2);
}

function $setContainmentGen(this$static, newContainment){
  var oldContainment;
  oldContainment = (this$static.eFlags & $intern_138) != 0;
  newContainment?(this$static.eFlags |= $intern_138):(this$static.eFlags &= -32769);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 18, oldContainment, newContainment));
}

function $setEOpposite(this$static, newEOpposite){
  var oldEOpposite;
  oldEOpposite = this$static.eOpposite;
  this$static.eOpposite = newEOpposite;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 21, oldEOpposite, this$static.eOpposite));
}

function $setResolveProxies(this$static, newResolveProxies){
  var oldResolveProxies;
  oldResolveProxies = (this$static.eFlags & $intern_66) != 0;
  newResolveProxies?(this$static.eFlags |= $intern_66):(this$static.eFlags &= -65537);
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_4(this$static, 1, 20, oldResolveProxies, newResolveProxies));
}

function EReferenceImpl(){
  EStructuralFeatureImpl.call(this);
  this.eFlags |= $intern_66;
}

defineClass(66, 426, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 17:1, 159:1, 63:1, 106:1, 446:1, 46:1, 93:1, 145:1, 66:1, 426:1, 278:1, 109:1, 110:1, 634:1}, EReferenceImpl);
_.eGet = function eGet_29(featureID, resolve, coreType){
  var eClass, lower, theOpposite, upper;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return $clinit_Boolean() , (this.eFlags & 256) != 0?true:false;
    case 3:
      return $clinit_Boolean() , (this.eFlags & 512) != 0?true:false;
    case 4:
      return valueOf_4(this.lowerBound);
    case 5:
      return valueOf_4(this.upperBound);
    case 6:
      return $clinit_Boolean() , upper = this.upperBound , upper > 1 || upper == -1?true:false;
    case 7:
      return $clinit_Boolean() , lower = this.lowerBound , lower >= 1?true:false;
    case 8:
      if (resolve)
        return $getEType(this);
      return this.eType;
    case 9:
      return this.eGenericType;
    case 10:
      return $clinit_Boolean() , (this.eFlags & $intern_89) != 0?true:false;
    case 11:
      return $clinit_Boolean() , (this.eFlags & $intern_152) != 0?true:false;
    case 12:
      return $clinit_Boolean() , (this.eFlags & $intern_64) != 0?true:false;
    case 13:
      return this.defaultValueLiteral;
    case 14:
      return $getDefaultValue(this);
    case 15:
      return $clinit_Boolean() , (this.eFlags & $intern_151) != 0?true:false;
    case 16:
      return $clinit_Boolean() , (this.eFlags & $intern_21) != 0?true:false;
    case 17:
      return $getEContainingClass(this);
    case 18:
      return $clinit_Boolean() , (this.eFlags & $intern_138) != 0?true:false;
    case 19:
      return $clinit_Boolean() , theOpposite = $getEOpposite(this) , !!theOpposite && (theOpposite.eFlags & $intern_138) != 0?true:false;
    case 20:
      return $clinit_Boolean() , (this.eFlags & $intern_66) != 0?true:false;
    case 21:
      if (resolve)
        return $getEOpposite(this);
      return this.eOpposite;
    case 22:
      if (resolve)
        return $getEReferenceType(this);
      return $basicGetEReferenceType(this);
    case 23:
      return !this.eKeys && (this.eKeys = new EObjectResolvingEList(Lorg_eclipse_emf_ecore_EAttribute_2_classLit, this, 23)) , this.eKeys;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EREFERENCE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EREFERENCE:eClass), featureID), resolve, coreType);
}
;
_.eIsSet = function eIsSet_28(featureID){
  var eClass, lower, theOpposite, upper;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return (this.eFlags & 256) == 0;
    case 3:
      return (this.eFlags & 512) == 0;
    case 4:
      return this.lowerBound != 0;
    case 5:
      return this.upperBound != 1;
    case 6:
      return upper = this.upperBound , upper > 1 || upper == -1;
    case 7:
      return lower = this.lowerBound , lower >= 1;
    case 8:
      return !!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0;
    case 9:
      return !!this.eGenericType && !(!!this.eType && !this.eGenericType.eTypeParameter && $getETypeArguments(this.eGenericType).size_0 == 0);
    case 10:
      return (this.eFlags & $intern_89) == 0;
    case 11:
      return (this.eFlags & $intern_152) != 0;
    case 12:
      return (this.eFlags & $intern_64) != 0;
    case 13:
      return this.defaultValueLiteral != null;
    case 14:
      return $getDefaultValue(this) != null;
    case 15:
      return (this.eFlags & $intern_151) != 0;
    case 16:
      return (this.eFlags & $intern_21) != 0;
    case 17:
      return !!$getEContainingClass(this);
    case 18:
      return (this.eFlags & $intern_138) != 0;
    case 19:
      return theOpposite = $getEOpposite(this) , !!theOpposite && (theOpposite.eFlags & $intern_138) != 0;
    case 20:
      return (this.eFlags & $intern_66) == 0;
    case 21:
      return !!this.eOpposite;
    case 22:
      return !!$basicGetEReferenceType(this);
    case 23:
      return !!this.eKeys && this.eKeys.size_0 != 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EREFERENCE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EREFERENCE:eClass), featureID));
}
;
_.eSet = function eSet_26(featureID, newValue){
  var eClass, msgs;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName_0(this, castToString(newValue));
      return;
    case 2:
      $setOrdered(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 3:
      $setUnique_2(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 4:
      $setLowerBound(this, castTo(newValue, 21).value_0);
      return;
    case 5:
      $setUpperBound(this, castTo(newValue, 21).value_0);
      return;
    case 8:
      $setEType(this, castTo(newValue, 136));
      return;
    case 9:
      msgs = $setEGenericType(this, castTo(newValue, 86), null);
      !!msgs && msgs.dispatch_0();
      return;
    case 10:
      $setChangeable(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 11:
      $setVolatile(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 12:
      $setTransient(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 13:
      $setDefaultValueLiteral(this, castToString(newValue));
      return;
    case 15:
      $setUnsettable(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 16:
      $setDerived(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 18:
      $setContainment(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 20:
      $setResolveProxies(this, checkNotNull_1(castToBoolean(newValue)));
      return;
    case 21:
      $setEOpposite(this, castTo(newValue, 17));
      return;
    case 23:
      !this.eKeys && (this.eKeys = new EObjectResolvingEList(Lorg_eclipse_emf_ecore_EAttribute_2_classLit, this, 23));
      $clear_11(this.eKeys);
      !this.eKeys && (this.eKeys = new EObjectResolvingEList(Lorg_eclipse_emf_ecore_EAttribute_2_classLit, this, 23));
      $addAll_6(this.eKeys, castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , EREFERENCE)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?EREFERENCE:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_28(){
  return $clinit_EcorePackage$Literals() , EREFERENCE;
}
;
_.freeze = function freeze_8(){
  $getEReferenceType(this);
  $getName_2($getExtendedMetaData_1(($clinit_ExtendedMetaData() , INSTANCE_11), this));
  $getEType(this);
  this.eFlags |= 1;
}
;
_.getEOpposite = function getEOpposite_0(){
  return $getEOpposite(this);
}
;
_.isContainer = function isContainer_0(){
  var theOpposite;
  return theOpposite = $getEOpposite(this) , !!theOpposite && (theOpposite.eFlags & $intern_138) != 0;
}
;
_.isContainment = function isContainment_6(){
  return (this.eFlags & $intern_138) != 0;
}
;
_.isResolveProxies_0 = function isResolveProxies_1(){
  return (this.eFlags & $intern_66) != 0;
}
;
_.setEType = function setEType_1(newEType, msgs){
  this.eReferenceType = null;
  return $setEType_0(this, newEType, msgs);
}
;
_.toString_0 = function toString_152(){
  var result;
  if ((this.eFlags_0 & 64) != 0)
    return $toString_25(this);
  result = new StringBuffer_1($toString_25(this));
  result.string += ' (containment: ';
  $append_4(result, (this.eFlags & $intern_138) != 0);
  result.string += ', resolveProxies: ';
  $append_4(result, (this.eFlags & $intern_66) != 0);
  result.string += ')';
  return result.string;
}
;
var Lorg_eclipse_emf_ecore_impl_EReferenceImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EReferenceImpl', 66);
function $setKey(this$static, key){
  $setTypedKeyGen(this$static, key == null?null:(checkCriticalNotNull(key) , key));
}

function $setTypedKey_0(this$static, newKey){
  $setTypedKeyGen(this$static, newKey == null?null:(checkCriticalNotNull(newKey) , newKey));
}

function $setTypedKeyGen(this$static, newKey){
  var oldKey;
  oldKey = this$static.key;
  this$static.key = newKey;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 0, oldKey, this$static.key));
}

function $setTypedValue_0(this$static, newValue){
  var oldValue;
  oldValue = this$static.value_0;
  this$static.value_0 = newValue;
  (this$static.eFlags_0 & 4) != 0 && (this$static.eFlags_0 & 1) == 0 && $eNotify(this$static, new ENotificationImpl_1(this$static, 1, 1, oldValue, this$static.value_0));
}

function $setValue_1(this$static, value_0){
  var oldValue;
  oldValue = this$static.value_0;
  $setTypedValue_0(this$static, value_0);
  return oldValue;
}

function EStringToStringMapEntryImpl(){
}

defineClass(520, 110, {98:1, 39:1, 92:1, 89:1, 140:1, 51:1, 106:1, 46:1, 93:1, 520:1, 109:1, 110:1}, EStringToStringMapEntryImpl);
_.equals_0 = function equals_189(other){
  return this === other;
}
;
_.getKey = function getKey_10(){
  return this.key;
}
;
_.getValue = function getValue_11(){
  return this.value_0;
}
;
_.hashCode_1 = function hashCode_77(){
  return getHashCode_0(this);
}
;
_.setKey = function setKey_2(key){
  $setKey(this, castToString(key));
}
;
_.setValue = function setValue_11(value_0){
  return $setValue_1(this, castToString(value_0));
}
;
_.eGet = function eGet_30(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return this.key;
    case 1:
      return this.value_0;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ESTRING_TO_STRING_MAP_ENTRY:eClass), featureID), resolve, coreType);
}
;
_.eIsSet = function eIsSet_29(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return this.key != null;
    case 1:
      return this.value_0 != null;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ESTRING_TO_STRING_MAP_ENTRY:eClass), featureID));
}
;
_.eSet = function eSet_27(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      $setTypedKey_0(this, castToString(newValue));
      return;
    case 1:
      $setTypedValue_0(this, castToString(newValue));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ESTRING_TO_STRING_MAP_ENTRY:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_29(){
  return $clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY;
}
;
_.getHash = function getHash_2(){
  var theKey;
  if (this.hash == -1) {
    theKey = this.key;
    this.hash = theKey == null?0:getHashCode_1(theKey);
  }
  return this.hash;
}
;
_.setHash = function setHash_2(hash){
  this.hash = hash;
}
;
_.toString_0 = function toString_153(){
  var result;
  if ((this.eFlags_0 & 64) != 0)
    return $toString_12(this);
  result = new StringBuffer_1($toString_12(this));
  result.string += ' (key: ';
  $append_3(result, this.key);
  result.string += ', value: ';
  $append_3(result, this.value_0);
  result.string += ')';
  return result.string;
}
;
_.hash = -1;
_.key = null;
_.value_0 = null;
var Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStringToStringMapEntryImpl', 520);
var Lorg_eclipse_emf_ecore_util_FeatureMap$Entry$Internal_2_classLit = createForInterface('org.eclipse.emf.ecore.util', 'FeatureMap/Entry/Internal');
function $validate_2(this$static, value_0){
  var valueClass;
  if (value_0 != null && !this$static.eStructuralFeature.getEType().isInstance(value_0)) {
    valueClass = instanceOf(value_0, 51)?castTo(value_0, 51).eClass_0().name_0:$getName(getClass__Ljava_lang_Class___devirtual$(value_0));
    throw toJs(new ClassCastException_0("The feature '" + this$static.eStructuralFeature.getName() + "'s type '" + this$static.eStructuralFeature.getEType().getName() + "' does not permit a value of type '" + valueClass + "'"));
  }
}

function EStructuralFeatureImpl$BasicFeatureMapEntry(eStructuralFeature){
  this.eStructuralFeature = eStructuralFeature;
}

defineClass(535, 1, $intern_161);
_.createEntry = function createEntry(value_0){
  return this.createEntry_0(castTo(value_0, 46));
}
;
_.createEntry_0 = function createEntry_0(value_0){
  return this.createEntry(value_0);
}
;
_.equals_0 = function equals_190(that){
  var entry, value_0;
  if (this === that) {
    return true;
  }
   else if (instanceOf(that, 76)) {
    entry = castTo(that, 76);
    if (entry.getEStructuralFeature() == this.eStructuralFeature) {
      value_0 = this.getValue();
      return value_0 == null?entry.getValue() == null:equals_Ljava_lang_Object__Z__devirtual$(value_0, entry.getValue());
    }
     else {
      return false;
    }
  }
   else {
    return false;
  }
}
;
_.getEStructuralFeature = function getEStructuralFeature_1(){
  return this.eStructuralFeature;
}
;
_.hashCode_1 = function hashCode_78(){
  var value_0;
  value_0 = this.getValue();
  return hashCode__I__devirtual$(this.eStructuralFeature) ^ (value_0 == null?0:hashCode__I__devirtual$(value_0));
}
;
_.toString_0 = function toString_154(){
  var eStructuralFeature, prefix;
  eStructuralFeature = this.eStructuralFeature;
  prefix = $getEPackage(eStructuralFeature.getEContainingClass()).getNsPrefix();
  eStructuralFeature.getName();
  return (prefix != null && prefix.length != 0?prefix + ':' + eStructuralFeature.getName():eStructuralFeature.getName()) + '=' + this.getValue();
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$BasicFeatureMapEntry_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/BasicFeatureMapEntry', 535);
function $inverseAdd(this$static, owner, otherEnd, featureID, notifications){
  var containmentFeatureID;
  if (otherEnd) {
    containmentFeatureID = $getFeatureID(owner.eClass_0(), this$static.eStructuralFeature);
    notifications = otherEnd.eInverseAdd(owner, -1 - (containmentFeatureID == -1?featureID:containmentFeatureID), null, notifications);
  }
  return notifications;
}

function $inverseRemove(this$static, owner, otherEnd, featureID, notifications){
  var containmentFeatureID;
  if (otherEnd) {
    containmentFeatureID = $getFeatureID(owner.eClass_0(), this$static.eStructuralFeature);
    notifications = otherEnd.eInverseRemove(owner, -1 - (containmentFeatureID == -1?featureID:containmentFeatureID), null, notifications);
  }
  return notifications;
}

function EStructuralFeatureImpl$ContainmentUpdatingFeatureMapEntry(eStructuralFeature, value_0){
  EStructuralFeatureImpl$BasicFeatureMapEntry.call(this, eStructuralFeature);
  this.value_0 = value_0;
}

defineClass(722, 535, $intern_161, EStructuralFeatureImpl$ContainmentUpdatingFeatureMapEntry);
_.createEntry_0 = function createEntry_1(value_0){
  return new EStructuralFeatureImpl$ContainmentUpdatingFeatureMapEntry(this.eStructuralFeature, value_0);
}
;
_.getValue = function getValue_12(){
  return this.value_0;
}
;
_.inverseAdd_0 = function inverseAdd_3(owner, featureID, notifications){
  return $inverseAdd(this, owner, this.value_0, featureID, notifications);
}
;
_.inverseRemove_0 = function inverseRemove_3(owner, featureID, notifications){
  return $inverseRemove(this, owner, this.value_0, featureID, notifications);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$ContainmentUpdatingFeatureMapEntry_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/ContainmentUpdatingFeatureMapEntry', 722);
function EStructuralFeatureImpl$InternalSettingDelegateFeatureMapDelegator(feature, featureMapFeature){
  this.feature = feature;
  this.featureMapFeature = featureMapFeature;
}

defineClass(1217, 1, {}, EStructuralFeatureImpl$InternalSettingDelegateFeatureMapDelegator);
_.dynamicGet_0 = function dynamicGet_3(owner, settings, index_0, resolve, coreType){
  var featureMap;
  featureMap = castTo($eGet_0(owner, this.featureMapFeature), 248);
  return featureMap.setting(this.feature).get_6(resolve);
}
;
_.dynamicInverseAdd = function dynamicInverseAdd(owner, settings, index_0, otherEnd, notifications){
  var featureMap;
  featureMap = castTo($eGet_0(owner, this.featureMapFeature), 248);
  return featureMap.basicAdd_0(this.feature, otherEnd, notifications);
}
;
_.dynamicInverseRemove = function dynamicInverseRemove(owner, settings, index_0, otherEnd, notifications){
  var featureMap;
  featureMap = castTo($eGet_0(owner, this.featureMapFeature), 248);
  return featureMap.basicRemove_0(this.feature, otherEnd, notifications);
}
;
_.dynamicIsSet = function dynamicIsSet(owner, settings, index_0){
  var featureMap;
  featureMap = castTo($eGet_0(owner, this.featureMapFeature), 248);
  return featureMap.setting(this.feature).isSet_0();
}
;
_.dynamicSet_0 = function dynamicSet_3(owner, settings, index_0, newValue){
  var featureMap;
  featureMap = castTo($eGet_0(owner, this.featureMapFeature), 248);
  featureMap.setting(this.feature).set_1(newValue);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateFeatureMapDelegator_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateFeatureMapDelegator', 1217);
function $createDynamicSetting(this$static, owner){
  switch (this$static.style) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 42:
    case 44:
    case 46:
    case 48:
    case 8:
    case 10:
    case 12:
    case 14:
    case 16:
    case 18:
    case 20:
    case 22:
    case 24:
    case 26:
    case 28:
    case 30:
    case 32:
    case 34:
    case 36:
    case 38:
      return new EcoreEList$Dynamic(this$static.dynamicKind, this$static.dataClass, owner, this$static.feature);
    case 1:
      return new EObjectContainmentEList$Unsettable(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 43:
      return new EObjectContainmentEList$Unsettable$Resolving(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 3:
      return new EObjectContainmentEList(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 45:
      return new EObjectContainmentEList$Resolving(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 41:
      return new EcoreEMap(castTo($getEType(this$static.feature), 26), this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 50:
      return new EcoreEMap$Unsettable(castTo($getEType(this$static.feature), 26), this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 5:
      return new EObjectContainmentWithInverseEList$Unsettable(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 47:
      return new EObjectContainmentWithInverseEList$Unsettable$Resolving(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 7:
      return new EObjectContainmentWithInverseEList(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 49:
      return new EObjectContainmentWithInverseEList$Resolving(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 9:
      return new EDataTypeUniqueEList$Unsettable(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 11:
      return new EDataTypeUniqueEList(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 13:
      return new EDataTypeEList$Unsettable(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 15:
      return new EDataTypeEList(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 17:
      return new EObjectResolvingEList$Unsettable(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 19:
      return new EObjectResolvingEList(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 21:
      return new EObjectEList$Unsettable(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 23:
      return new EObjectEList(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    case 25:
      return new EObjectWithInverseResolvingEList$Unsettable$ManyInverse(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 27:
      return new EObjectWithInverseResolvingEList$ManyInverse(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 29:
      return new EObjectWithInverseEList$Unsettable$ManyInverse(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 31:
      return new EObjectWithInverseEList$ManyInverse(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 33:
      return new EObjectWithInverseResolvingEList$Unsettable(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 35:
      return new EObjectWithInverseResolvingEList(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 37:
      return new EObjectWithInverseEList$Unsettable(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 39:
      return new EObjectWithInverseEList(this$static.dataClass, owner, $getFeatureID(owner.eClass_0(), this$static.feature), this$static.inverseFeature.featureID);
    case 40:
      return new BasicFeatureMap(owner, $getFeatureID(owner.eClass_0(), this$static.feature));
    default:throw toJs(new RuntimeException_0('Unknown feature style: ' + this$static.style));
  }
}

function EStructuralFeatureImpl$InternalSettingDelegateMany(style, dataClass, feature){
  this.style = style;
  this.dataClass = dataClass;
  this.feature = feature;
}

function EStructuralFeatureImpl$InternalSettingDelegateMany_0(style, dataClass, feature, inverseFeature){
  this.style = style;
  this.dataClass = dataClass;
  this.feature = feature;
  this.inverseFeature = inverseFeature;
}

function EStructuralFeatureImpl$InternalSettingDelegateMany_1(style, feature){
  this.style = style;
  this.dataClass = Ljava_lang_Object_2_classLit;
  this.dynamicKind = kind_0(feature);
  this.feature = feature;
}

function EStructuralFeatureImpl$InternalSettingDelegateMany_2(style, feature, inverseFeature){
  this.style = style;
  this.dataClass = Ljava_lang_Object_2_classLit;
  this.dynamicKind = kind_0(feature);
  this.feature = feature;
  this.inverseFeature = inverseFeature;
}

defineClass(85, 1, {}, EStructuralFeatureImpl$InternalSettingDelegateMany, EStructuralFeatureImpl$InternalSettingDelegateMany_0, EStructuralFeatureImpl$InternalSettingDelegateMany_1, EStructuralFeatureImpl$InternalSettingDelegateMany_2);
_.dynamicGet_0 = function dynamicGet_4(owner, settings, index_0, resolve, coreType){
  var result;
  result = settings.dynamicGet(index_0);
  result == null && settings.dynamicSet(index_0, result = $createDynamicSetting(this, owner));
  if (!coreType) {
    switch (this.style) {
      case 50:
      case 41:
        return castTo(result, 558).map_2();
      case 40:
        return castTo(result, 248).getWrapper();
    }
  }
  return result;
}
;
_.dynamicInverseAdd = function dynamicInverseAdd_0(owner, settings, index_0, otherEnd, notifications){
  var result, setting;
  setting = settings.dynamicGet(index_0);
  setting == null && settings.dynamicSet(index_0, setting = $createDynamicSetting(this, owner));
  result = castTo(setting, 69).basicAdd(otherEnd, notifications);
  return result;
}
;
_.dynamicInverseRemove = function dynamicInverseRemove_0(owner, settings, index_0, otherEnd, notifications){
  var setting;
  setting = settings.dynamicGet(index_0);
  setting != null && (notifications = castTo(setting, 69).basicRemove(otherEnd, notifications));
  return notifications;
}
;
_.dynamicIsSet = function dynamicIsSet_0(owner, settings, index_0){
  var setting;
  setting = settings.dynamicGet(index_0);
  return setting != null && castTo(setting, 82).isSet_0();
}
;
_.dynamicSet_0 = function dynamicSet_4(owner, settings, index_0, newValue){
  var setting;
  setting = castTo(settings.dynamicGet(index_0), 82);
  !setting && settings.dynamicSet(index_0, setting = $createDynamicSetting(this, owner));
  setting.set_1(newValue);
}
;
_.dynamicKind = 0;
_.style = 0;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateMany_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateMany', 85);
function $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle(){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle = emptyMethod;
  NIL_0 = ($clinit_EStructuralFeature$Internal$DynamicValueHolder() , NIL);
}

function EStructuralFeatureImpl$InternalSettingDelegateSingle(feature){
  this.feature = feature;
}

defineClass(475, 1, {});
_.dynamicInverseAdd = function dynamicInverseAdd_1(owner, settings, index_0, otherEnd, notifications){
  throw toJs(new UnsupportedOperationException);
}
;
_.dynamicInverseRemove = function dynamicInverseRemove_1(owner, settings, index_0, otherEnd, notifications){
  throw toJs(new UnsupportedOperationException);
}
;
var NIL_0;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingle_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingle', 475);
function EStructuralFeatureImpl$InternalSettingDelegateSingleContainer(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingle.call(this, feature);
  this.eClass = eClass;
  this.inverseFeature = inverseFeature;
}

defineClass(715, 475, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleContainer);
_.dynamicGet_0 = function dynamicGet_5(owner, settings, index_0, resolve, coreType){
  return eContainmentFeature(owner, owner.eInternalContainer(), owner.eContainerFeatureID_0()) == this.inverseFeature?this.isResolveProxies_0() && resolve?$eContainer(owner):owner.eInternalContainer():null;
}
;
_.dynamicInverseAdd = function dynamicInverseAdd_2(owner, settings, index_0, otherEnd, notifications){
  var eContainerFeatureID, featureID;
  !!owner.eInternalContainer() && (notifications = (eContainerFeatureID = owner.eContainerFeatureID_0() , eContainerFeatureID >= 0?owner.eBasicRemoveFromContainerFeature(notifications):owner.eInternalContainer().eInverseRemove(owner, -1 - eContainerFeatureID, null, notifications)));
  featureID = $getFeatureID(owner.eClass_0(), this.feature);
  return owner.eBasicSetContainer_0(otherEnd, featureID, notifications);
}
;
_.dynamicInverseRemove = function dynamicInverseRemove_2(owner, settings, index_0, otherEnd, notifications){
  var featureID;
  featureID = $getFeatureID(owner.eClass_0(), this.feature);
  return owner.eBasicSetContainer_0(null, featureID, notifications);
}
;
_.dynamicIsSet = function dynamicIsSet_1(owner, settings, index_0){
  var featureID;
  featureID = $getFeatureID(owner.eClass_0(), this.feature);
  return !!owner.eInternalContainer() && owner.eContainerFeatureID_0() == featureID;
}
;
_.dynamicSet_0 = function dynamicSet_5(owner, settings, index_0, newValue){
  var eContainer, eContainerFeatureID, featureID, internalEObject, notifications;
  if (newValue != null && !$isInstance(this.eClass, newValue)) {
    throw toJs(new ClassCastException_0("The value of type '" + (instanceOf(newValue, 51)?$toString_27(castTo(newValue, 51).eClass_0()):$toString_4(getClass__Ljava_lang_Class___devirtual$(newValue))) + "' must be of type '" + this.eClass + "'"));
  }
  eContainer = owner.eInternalContainer();
  featureID = $getFeatureID(owner.eClass_0(), this.feature);
  if (maskUndefined(newValue) !== maskUndefined(eContainer) || owner.eContainerFeatureID_0() != featureID && newValue != null) {
    if (isAncestor(owner, castTo(newValue, 51)))
      throw toJs(new IllegalArgumentException_0('Recursive containment not allowed for ' + owner.toString_0()));
    notifications = null;
    !!eContainer && (notifications = (eContainerFeatureID = owner.eContainerFeatureID_0() , eContainerFeatureID >= 0?owner.eBasicRemoveFromContainerFeature(null):owner.eInternalContainer().eInverseRemove(owner, -1 - eContainerFeatureID, null, null)));
    internalEObject = castTo(newValue, 46);
    !!internalEObject && (notifications = internalEObject.eInverseAdd(owner, $getFeatureID(internalEObject.eClass_0(), this.inverseFeature), null, notifications));
    notifications = owner.eBasicSetContainer_0(internalEObject, featureID, notifications);
    !!notifications && notifications.dispatch_0();
  }
   else {
    owner.eBasicHasAdapters() && owner.eDeliver() && $eNotify(owner, new ENotificationImpl_1(owner, 1, featureID, newValue, newValue));
  }
}
;
_.isResolveProxies_0 = function isResolveProxies_2(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleContainer_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleContainer', 715);
function EStructuralFeatureImpl$InternalSettingDelegateSingleContainerResolving(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleContainer.call(this, eClass, feature, inverseFeature);
}

defineClass(1218, 715, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleContainerResolving);
_.isResolveProxies_0 = function isResolveProxies_3(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleContainerResolving_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleContainerResolving', 1218);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData(defaultValue, intrinsicDefaultValue, feature){
  EStructuralFeatureImpl$InternalSettingDelegateSingle.call(this, feature);
  this.defaultValue = defaultValue;
  this.intrinsicDefaultValue = intrinsicDefaultValue;
  this.notificationCreator = ($clinit_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator() , OBJECT_NOTIFICATION_CREATOR);
}

function EStructuralFeatureImpl$InternalSettingDelegateSingleData_0(defaultValue, intrinsicDefaultValue, feature, notificationCreator){
  EStructuralFeatureImpl$InternalSettingDelegateSingle.call(this, feature);
  this.defaultValue = defaultValue;
  this.intrinsicDefaultValue = intrinsicDefaultValue;
  this.notificationCreator = notificationCreator;
}

defineClass(533, 475, {});
_.dynamicGet_0 = function dynamicGet_6(owner, settings, index_0, resolve, coreType){
  var result;
  return result = settings.dynamicGet(index_0) , result == null?this.defaultValue:maskUndefined(result) === maskUndefined(NIL_0)?null:result;
}
;
_.dynamicIsSet = function dynamicIsSet_2(owner, settings, index_0){
  var setting;
  setting = settings.dynamicGet(index_0);
  return setting != null && (maskUndefined(setting) === maskUndefined(NIL_0) || !equals_Ljava_lang_Object__Z__devirtual$(setting, this.defaultValue));
}
;
_.dynamicSet_0 = function dynamicSet_6(owner, settings, index_0, newValue){
  var oldValue, result;
  if (owner.eBasicHasAdapters() && owner.eDeliver()) {
    oldValue = (result = settings.dynamicGet(index_0) , result == null?this.defaultValue:maskUndefined(result) === maskUndefined(NIL_0)?null:result);
    if (newValue == null) {
      if (this.intrinsicDefaultValue != null) {
        settings.dynamicSet(index_0, null);
        newValue = this.defaultValue;
      }
       else 
        this.defaultValue != null?settings.dynamicSet(index_0, NIL_0):settings.dynamicSet(index_0, null);
    }
     else {
      this.validate_0(newValue);
      settings.dynamicSet(index_0, newValue);
    }
    $eNotify(owner, this.notificationCreator.createNotification_0(owner, 1, this.feature, oldValue, newValue));
  }
   else {
    if (newValue == null) {
      this.intrinsicDefaultValue != null?settings.dynamicSet(index_0, null):this.defaultValue != null?settings.dynamicSet(index_0, NIL_0):settings.dynamicSet(index_0, null);
    }
     else {
      this.validate_0(newValue);
      settings.dynamicSet(index_0, newValue);
    }
  }
}
;
_.validate_0 = function validate_2(object){
  throw toJs(new ClassCastException);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData', 533);
function $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator(){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator = emptyMethod;
  OBJECT_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator;
  BOOLEAN_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$1;
  BYTE_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$2;
  CHAR_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$3;
  DOUBLE_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$4;
  FLOAT_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$5;
  INT_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$6;
  LONG_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$7;
  SHORT_NOTIFICATION_CREATOR = new EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$8;
}

function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator(){
}

defineClass($intern_162, 1, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator);
_.createNotification_0 = function createNotification_7(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_17(notifier, eventType, feature, oldValue, newValue);
}
;
_.createNotification_1 = function createNotification_8(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_19(notifier, eventType, feature, oldValue, newValue, wasSet);
}
;
var BOOLEAN_NOTIFICATION_CREATOR, BYTE_NOTIFICATION_CREATOR, CHAR_NOTIFICATION_CREATOR, DOUBLE_NOTIFICATION_CREATOR, FLOAT_NOTIFICATION_CREATOR, INT_NOTIFICATION_CREATOR, LONG_NOTIFICATION_CREATOR, OBJECT_NOTIFICATION_CREATOR, SHORT_NOTIFICATION_CREATOR;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator', $intern_162);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$1(){
}

defineClass(1233, $intern_162, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$1);
_.createNotification_0 = function createNotification_9(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_22(notifier, eventType, feature, checkNotNull_1(castToBoolean(oldValue)), checkNotNull_1(castToBoolean(newValue)));
}
;
_.createNotification_1 = function createNotification_10(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_23(notifier, eventType, feature, checkNotNull_1(castToBoolean(oldValue)), checkNotNull_1(castToBoolean(newValue)), wasSet);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator/1', 1233);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$2(){
}

defineClass(1234, $intern_162, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$2);
_.createNotification_0 = function createNotification_11(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_5(notifier, eventType, feature, castTo(oldValue, 196).value_0, castTo(newValue, 196).value_0);
}
;
_.createNotification_1 = function createNotification_12(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_6(notifier, eventType, feature, castTo(oldValue, 196).value_0, castTo(newValue, 196).value_0, wasSet);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$2_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator/2', 1234);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$3(){
}

defineClass(1235, $intern_162, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$3);
_.createNotification_0 = function createNotification_13(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_7(notifier, eventType, feature, castTo(oldValue, 161).value_0, castTo(newValue, 161).value_0);
}
;
_.createNotification_1 = function createNotification_14(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_8(notifier, eventType, feature, castTo(oldValue, 161).value_0, castTo(newValue, 161).value_0, wasSet);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$3_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator/3', 1235);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$4(){
}

defineClass(1236, $intern_162, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$4);
_.createNotification_0 = function createNotification_15(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_9(notifier, eventType, feature, checkNotNull_1(castToDouble(oldValue)), checkNotNull_1(castToDouble(newValue)));
}
;
_.createNotification_1 = function createNotification_16(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_10(notifier, eventType, feature, checkNotNull_1(castToDouble(oldValue)), checkNotNull_1(castToDouble(newValue)), wasSet);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$4_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator/4', 1236);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$5(){
}

defineClass(1237, $intern_162, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$5);
_.createNotification_0 = function createNotification_17(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_11(notifier, eventType, feature, castTo(oldValue, 128).value_0, castTo(newValue, 128).value_0);
}
;
_.createNotification_1 = function createNotification_18(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_12(notifier, eventType, feature, castTo(oldValue, 128).value_0, castTo(newValue, 128).value_0, wasSet);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$5_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator/5', 1237);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$6(){
}

defineClass(1238, $intern_162, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$6);
_.createNotification_0 = function createNotification_19(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_13(notifier, eventType, feature, castTo(oldValue, 21).value_0, castTo(newValue, 21).value_0);
}
;
_.createNotification_1 = function createNotification_20(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_14(notifier, eventType, feature, castTo(oldValue, 21).value_0, castTo(newValue, 21).value_0, wasSet);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$6_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator/6', 1238);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$7(){
}

defineClass(1239, $intern_162, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$7);
_.createNotification_0 = function createNotification_21(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_15(notifier, eventType, feature, castTo(oldValue, 152).value_0, castTo(newValue, 152).value_0);
}
;
_.createNotification_1 = function createNotification_22(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_16(notifier, eventType, feature, castTo(oldValue, 152).value_0, castTo(newValue, 152).value_0, wasSet);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$7_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator/7', 1239);
function EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$8(){
}

defineClass(1240, $intern_162, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$8);
_.createNotification_0 = function createNotification_23(notifier, eventType, feature, oldValue, newValue){
  return new ENotificationImpl_20(notifier, eventType, feature, castTo(oldValue, 171).value_0, castTo(newValue, 171).value_0);
}
;
_.createNotification_1 = function createNotification_24(notifier, eventType, feature, oldValue, newValue, wasSet){
  return new ENotificationImpl_21(notifier, eventType, feature, castTo(oldValue, 171).value_0, castTo(newValue, 171).value_0, wasSet);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleData$NotificationCreator$8_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleData/NotificationCreator/8', 1240);
function EStructuralFeatureImpl$InternalSettingDelegateSingleDataDynamic(eDataType, defaultValue, intrinsicDefaultValue, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleData.call(this, defaultValue, intrinsicDefaultValue, feature);
  this.eDataType = eDataType;
}

defineClass(1220, 533, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleDataDynamic);
_.validate_0 = function validate_3(object){
  if (!this.eDataType.isInstance(object)) {
    throw toJs(new ClassCastException_0("The value of type '" + getClass__Ljava_lang_Class___devirtual$(object) + "' must be of type '" + this.eDataType + "'"));
  }
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleDataDynamic_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleDataDynamic', 1220);
function EStructuralFeatureImpl$InternalSettingDelegateSingleDataStatic(defaultValue, intrinsicDefaultValue, feature, notificationCreator){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleData_0.call(this, defaultValue, intrinsicDefaultValue, feature, notificationCreator);
}

defineClass(1221, 533, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleDataStatic);
_.validate_0 = function validate_4(object){
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleDataStatic_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleDataStatic', 1221);
defineClass(716, 533, {});
_.dynamicIsSet = function dynamicIsSet_3(owner, settings, index_0){
  var setting;
  setting = settings.dynamicGet(index_0);
  return setting != null;
}
;
_.dynamicSet_0 = function dynamicSet_7(owner, settings, index_0, newValue){
  var oldIsSet, oldValue;
  if (owner.eBasicHasAdapters() && owner.eDeliver()) {
    oldIsSet = true;
    oldValue = settings.dynamicGet(index_0);
    if (oldValue == null) {
      oldIsSet = false;
      oldValue = this.defaultValue;
    }
     else 
      maskUndefined(oldValue) === maskUndefined(NIL_0) && (oldValue = null);
    if (newValue == null) {
      if (this.intrinsicDefaultValue != null) {
        settings.dynamicSet(index_0, null);
        newValue = this.defaultValue;
      }
       else {
        settings.dynamicSet(index_0, NIL_0);
      }
    }
     else {
      this.validate_0(newValue);
      settings.dynamicSet(index_0, newValue);
    }
    $eNotify(owner, this.notificationCreator.createNotification_1(owner, 1, this.feature, oldValue, newValue, !oldIsSet));
  }
   else {
    if (newValue == null) {
      this.intrinsicDefaultValue != null?settings.dynamicSet(index_0, null):settings.dynamicSet(index_0, NIL_0);
    }
     else {
      this.validate_0(newValue);
      settings.dynamicSet(index_0, newValue);
    }
  }
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettable_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleDataUnsettable', 716);
function EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettableDynamic(eDataType, defaultValue, intrinsicDefaultValue, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleData.call(this, defaultValue, intrinsicDefaultValue, feature);
  this.eDataType = eDataType;
}

defineClass(1222, 716, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettableDynamic);
_.validate_0 = function validate_5(object){
  if (!this.eDataType.isInstance(object)) {
    throw toJs(new ClassCastException_0("The value of type '" + getClass__Ljava_lang_Class___devirtual$(object) + "' must be of type '" + this.eDataType + "'"));
  }
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettableDynamic_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleDataUnsettableDynamic', 1222);
function EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettableStatic(defaultValue, intrinsicDefaultValue, feature, notificationCreator){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleData_0.call(this, defaultValue, intrinsicDefaultValue, feature, notificationCreator);
}

defineClass(1223, 716, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettableStatic);
_.validate_0 = function validate_6(object){
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleDataUnsettableStatic_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleDataUnsettableStatic', 1223);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObject(eClass, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingle.call(this, feature);
  this.eClass = eClass;
}

function EStructuralFeatureImpl$InternalSettingDelegateSingleEObject_0(eClass, feature, inverseFeature){
  EStructuralFeatureImpl$InternalSettingDelegateSingle.call(this, feature);
  this.eClass = eClass;
  this.inverseFeature = inverseFeature;
}

defineClass(384, 475, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObject);
_.dynamicGet_0 = function dynamicGet_7(owner, settings, index_0, resolve, coreType){
  var newEObject, notificationChain, oldEObject, resolvedEObject, result;
  result = settings.dynamicGet(index_0);
  if (this.isUnsettable() && maskUndefined(result) === maskUndefined(NIL_0)) {
    return null;
  }
   else if (this.isResolveProxies_0() && resolve && result != null) {
    oldEObject = castTo(result, 46);
    if (oldEObject.eIsProxy()) {
      resolvedEObject = $eResolveProxy(owner, oldEObject);
      if (oldEObject != resolvedEObject) {
        if (!$isInstance(this.eClass, resolvedEObject)) {
          throw toJs(new ClassCastException_0("The value of type '" + getClass__Ljava_lang_Class___devirtual$(resolvedEObject) + "' must be of type '" + this.eClass + "'"));
        }
        settings.dynamicSet(index_0, result = resolvedEObject);
        if (this.isContainment()) {
          newEObject = castTo(resolvedEObject, 46);
          notificationChain = oldEObject.eInverseRemove(owner, !this.inverseFeature?-1 - $getFeatureID(owner.eClass_0(), this.feature):$getFeatureID(oldEObject.eClass_0(), this.inverseFeature), null, null);
          !newEObject.eInternalContainer() && (notificationChain = newEObject.eInverseAdd(owner, !this.inverseFeature?-1 - $getFeatureID(owner.eClass_0(), this.feature):$getFeatureID(newEObject.eClass_0(), this.inverseFeature), null, notificationChain));
          !!notificationChain && notificationChain.dispatch_0();
        }
        owner.eBasicHasAdapters() && owner.eDeliver() && $eNotify(owner, new ENotificationImpl_17(owner, 9, this.feature, oldEObject, resolvedEObject));
      }
    }
    return result;
  }
   else {
    return result;
  }
}
;
_.dynamicInverseAdd = function dynamicInverseAdd_3(owner, settings, index_0, otherEnd, notifications){
  var internalEObject, oldValue;
  oldValue = settings.dynamicGet(index_0);
  maskUndefined(oldValue) === maskUndefined(NIL_0) && (oldValue = null);
  settings.dynamicSet(index_0, otherEnd);
  if (this.hasInverse()) {
    if (maskUndefined(oldValue) !== maskUndefined(otherEnd) && oldValue != null) {
      internalEObject = castTo(oldValue, 46);
      notifications = internalEObject.eInverseRemove(owner, $getFeatureID(internalEObject.eClass_0(), this.inverseFeature), null, notifications);
    }
  }
   else 
    this.isContainment() && oldValue != null && (notifications = castTo(oldValue, 46).eInverseRemove(owner, -1 - $getFeatureID(owner.eClass_0(), this.feature), null, notifications));
  if (owner.eBasicHasAdapters() && owner.eDeliver()) {
    !notifications && (notifications = new NotificationChainImpl_0(4));
    notifications.add_4(new ENotificationImpl_17(owner, 1, this.feature, oldValue, otherEnd));
  }
  return notifications;
}
;
_.dynamicInverseRemove = function dynamicInverseRemove_3(owner, settings, index_0, otherEnd, notifications){
  var oldValue;
  oldValue = settings.dynamicGet(index_0);
  maskUndefined(oldValue) === maskUndefined(NIL_0) && (oldValue = null);
  settings.dynamicUnset(index_0);
  if (owner.eBasicHasAdapters() && owner.eDeliver()) {
    !notifications && (notifications = new NotificationChainImpl_0(4));
    this.isUnsettable()?notifications.add_4(new ENotificationImpl_17(owner, 2, this.feature, oldValue, null)):notifications.add_4(new ENotificationImpl_17(owner, 1, this.feature, oldValue, null));
  }
  return notifications;
}
;
_.dynamicIsSet = function dynamicIsSet_4(owner, settings, index_0){
  var setting;
  setting = settings.dynamicGet(index_0);
  return setting != null;
}
;
_.dynamicSet_0 = function dynamicSet_8(owner, settings, index_0, newValue){
  var internalEObject, notification, notifications, oldIsSet, oldValue;
  if (newValue != null && !$isInstance(this.eClass, newValue)) {
    throw toJs(new ClassCastException_0("The value of type '" + (instanceOf(newValue, 51)?$toString_27(castTo(newValue, 51).eClass_0()):$toString_4(getClass__Ljava_lang_Class___devirtual$(newValue))) + "' must be of type '" + this.eClass + "'"));
  }
  oldValue = settings.dynamicGet(index_0);
  oldIsSet = oldValue != null;
  this.isUnsettable() && maskUndefined(oldValue) === maskUndefined(NIL_0) && (oldValue = null);
  notifications = null;
  if (this.hasInverse()) {
    if (maskUndefined(oldValue) !== maskUndefined(newValue)) {
      if (oldValue != null) {
        internalEObject = castTo(oldValue, 46);
        notifications = internalEObject.eInverseRemove(owner, $getFeatureID(internalEObject.eClass_0(), this.inverseFeature), null, null);
      }
      if (newValue != null) {
        internalEObject = castTo(newValue, 46);
        notifications = internalEObject.eInverseAdd(owner, $getFeatureID(internalEObject.eClass_0(), this.inverseFeature), null, notifications);
      }
    }
  }
   else if (this.isContainment()) {
    if (maskUndefined(oldValue) !== maskUndefined(newValue)) {
      oldValue != null && (notifications = castTo(oldValue, 46).eInverseRemove(owner, -1 - $getFeatureID(owner.eClass_0(), this.feature), null, null));
      newValue != null && (notifications = castTo(newValue, 46).eInverseAdd(owner, -1 - $getFeatureID(owner.eClass_0(), this.feature), null, notifications));
    }
  }
  newValue == null && this.isUnsettable()?settings.dynamicSet(index_0, NIL_0):settings.dynamicSet(index_0, newValue);
  if (owner.eBasicHasAdapters() && owner.eDeliver()) {
    notification = new ENotificationImpl_19(owner, 1, this.feature, oldValue, newValue, this.isUnsettable() && !oldIsSet);
    if (!notifications) {
      $eNotify(owner, notification);
    }
     else {
      notifications.add_4(notification);
      notifications.dispatch_0();
    }
  }
   else 
    !!notifications && notifications.dispatch_0();
}
;
_.hasInverse = function hasInverse_6(){
  return false;
}
;
_.isContainment = function isContainment_7(){
  return false;
}
;
_.isResolveProxies_0 = function isResolveProxies_4(){
  return false;
}
;
_.isUnsettable = function isUnsettable_1(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObject_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObject', 384);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainment(eClass, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObject.call(this, eClass, feature);
}

defineClass(534, 384, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainment);
_.isContainment = function isContainment_8(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainment_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectContainment', 534);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentResolving(eClass, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainment.call(this, eClass, feature);
}

defineClass(1226, 534, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentResolving);
_.isResolveProxies_0 = function isResolveProxies_5(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentResolving_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectContainmentResolving', 1226);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettable(eClass, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainment.call(this, eClass, feature);
}

defineClass(718, 534, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettable);
_.isUnsettable = function isUnsettable_2(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettable_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectContainmentUnsettable', 718);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettableResolving(eClass, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettable.call(this, eClass, feature);
}

defineClass(1228, 718, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettableResolving);
_.isResolveProxies_0 = function isResolveProxies_6(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentUnsettableResolving_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectContainmentUnsettableResolving', 1228);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverse(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObject_0.call(this, eClass, feature, inverseFeature);
}

defineClass(604, 534, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverse);
_.hasInverse = function hasInverse_7(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverse_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectContainmentWithInverse', 604);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseResolving(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverse.call(this, eClass, feature, inverseFeature);
}

defineClass(1227, 604, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseResolving);
_.isResolveProxies_0 = function isResolveProxies_7(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseResolving_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectContainmentWithInverseResolving', 1227);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettable(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverse.call(this, eClass, feature, inverseFeature);
}

defineClass(719, 604, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettable);
_.isUnsettable = function isUnsettable_3(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettable_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettable', 719);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettableResolving(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettable.call(this, eClass, feature, inverseFeature);
}

defineClass(1229, 719, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettableResolving);
_.isResolveProxies_0 = function isResolveProxies_8(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettableResolving_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectContainmentWithInverseUnsettableResolving', 1229);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolving(eClass, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObject.call(this, eClass, feature);
}

defineClass(605, 384, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolving);
_.isResolveProxies_0 = function isResolveProxies_9(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolving_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectResolving', 605);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingUnsettable(eClass, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolving.call(this, eClass, feature);
}

defineClass(1230, 605, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingUnsettable);
_.isUnsettable = function isUnsettable_4(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingUnsettable_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectResolvingUnsettable', 1230);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverse(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObject_0.call(this, eClass, feature, inverseFeature);
}

defineClass(720, 605, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverse);
_.hasInverse = function hasInverse_8(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverse_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectResolvingWithInverse', 720);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverseUnsettable(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverse.call(this, eClass, feature, inverseFeature);
}

defineClass(1231, 720, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverseUnsettable);
_.isUnsettable = function isUnsettable_5(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectResolvingWithInverseUnsettable_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectResolvingWithInverseUnsettable', 1231);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectUnsettable(eClass, feature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObject.call(this, eClass, feature);
}

defineClass(1224, 384, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectUnsettable);
_.isUnsettable = function isUnsettable_6(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectUnsettable_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectUnsettable', 1224);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverse(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObject_0.call(this, eClass, feature, inverseFeature);
}

defineClass(717, 384, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverse);
_.hasInverse = function hasInverse_9(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverse_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectWithInverse', 717);
function EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverseUnsettable(eClass, feature, inverseFeature){
  $clinit_EStructuralFeatureImpl$InternalSettingDelegateSingle();
  EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverse.call(this, eClass, feature, inverseFeature);
}

defineClass(1225, 717, {}, EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverseUnsettable);
_.isUnsettable = function isUnsettable_7(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InternalSettingDelegateSingleEObjectWithInverseUnsettable_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InternalSettingDelegateSingleEObjectWithInverseUnsettable', 1225);
function $inverseAdd_0(this$static, owner, otherEnd, notifications){
  !!otherEnd && (notifications = otherEnd.eInverseAdd(owner, $getFeatureID(otherEnd.eClass_0(), this$static.eStructuralFeature.getEOpposite()), null, notifications));
  return notifications;
}

function $inverseRemove_0(this$static, owner, otherEnd, notifications){
  !!otherEnd && (notifications = otherEnd.eInverseRemove(owner, $getFeatureID(otherEnd.eClass_0(), this$static.eStructuralFeature.getEOpposite()), null, notifications));
  return notifications;
}

function EStructuralFeatureImpl$InverseUpdatingFeatureMapEntry(this$0, eStructuralFeature, value_0){
  this.this$01 = this$0;
  EStructuralFeatureImpl$BasicFeatureMapEntry.call(this, eStructuralFeature);
  this.value_0 = value_0;
}

defineClass(721, 535, $intern_161, EStructuralFeatureImpl$InverseUpdatingFeatureMapEntry);
_.createEntry_0 = function createEntry_2(value_0){
  return new EStructuralFeatureImpl$InverseUpdatingFeatureMapEntry(this.this$01, this.eStructuralFeature, value_0);
}
;
_.getValue = function getValue_13(){
  return this.value_0;
}
;
_.inverseAdd_0 = function inverseAdd_4(owner, featureID, notifications){
  return $inverseAdd_0(this, owner, this.value_0, notifications);
}
;
_.inverseRemove_0 = function inverseRemove_4(owner, featureID, notifications){
  return $inverseRemove_0(this, owner, this.value_0, notifications);
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$InverseUpdatingFeatureMapEntry_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/InverseUpdatingFeatureMapEntry', 721);
function EStructuralFeatureImpl$SimpleContentFeatureMapEntry(eStructuralFeature){
  this.eStructuralFeature = eStructuralFeature;
  this.eDataType = castTo($getEType(eStructuralFeature), 144);
  this.eFactory = this.eDataType.getEPackage().getEFactoryInstance();
}

defineClass(1232, 535, $intern_161, EStructuralFeatureImpl$SimpleContentFeatureMapEntry);
_.createEntry = function createEntry_3(value_0){
  return new EStructuralFeatureImpl$SimpleFeatureMapEntry(($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__TEXT), this.eFactory.convertToString(this.eDataType, value_0));
}
;
_.getValue = function getValue_14(){
  return null;
}
;
_.inverseAdd_0 = function inverseAdd_5(owner, featureID, notifications){
  return notifications;
}
;
_.inverseRemove_0 = function inverseRemove_5(owner, featureID, notifications){
  return notifications;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$SimpleContentFeatureMapEntry_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/SimpleContentFeatureMapEntry', 1232);
function EStructuralFeatureImpl$SimpleFeatureMapEntry(eStructuralFeature, value_0){
  EStructuralFeatureImpl$BasicFeatureMapEntry.call(this, eStructuralFeature);
  this.value_0 = value_0;
}

defineClass(606, 535, $intern_161, EStructuralFeatureImpl$SimpleFeatureMapEntry);
_.createEntry = function createEntry_4(value_0){
  return new EStructuralFeatureImpl$SimpleFeatureMapEntry(this.eStructuralFeature, value_0);
}
;
_.getValue = function getValue_15(){
  return this.value_0;
}
;
_.inverseAdd_0 = function inverseAdd_6(owner, featureID, notifications){
  return notifications;
}
;
_.inverseRemove_0 = function inverseRemove_6(owner, featureID, notifications){
  return notifications;
}
;
var Lorg_eclipse_emf_ecore_impl_EStructuralFeatureImpl$SimpleFeatureMapEntry_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EStructuralFeatureImpl/SimpleFeatureMapEntry', 606);
function ESuperAdapter$1(){
}

defineClass(372, 467, $intern_141, ESuperAdapter$1);
_.newData = function newData_12(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EClass_2_classLit, $intern_1, 26, capacity, 0, 1);
}
;
_.useEquals = function useEquals_13(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_impl_ESuperAdapter$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ESuperAdapter/1', 372);
function $getEGenericTypes(this$static){
  !this$static.eGenericTypes && (this$static.eGenericTypes = new ETypeParameterImpl$2$1(new ETypeParameterImpl$2));
  return this$static.eGenericTypes;
}

function ETypeParameterImpl(){
}

defineClass(423, 417, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 106:1, 772:1, 46:1, 93:1, 145:1, 423:1, 109:1, 110:1}, ETypeParameterImpl);
_.eGet = function eGet_31(featureID, resolve, coreType){
  var eClass;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , this.eAnnotations;
    case 1:
      return this.name_0;
    case 2:
      return !this.eBounds && (this.eBounds = new ETypeParameterImpl$1(this, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this)) , this.eBounds;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ETYPE_PARAMETER)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ETYPE_PARAMETER:eClass), featureID), resolve, coreType);
}
;
_.eInverseRemove_0 = function eInverseRemove_22(otherEnd, featureID, msgs){
  var eClass, feature;
  switch (featureID) {
    case 0:
      return !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3)) , $basicRemove_0(this.eAnnotations, otherEnd, msgs);
    case 2:
      return !this.eBounds && (this.eBounds = new ETypeParameterImpl$1(this, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this)) , $basicRemove_0(this.eBounds, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?($clinit_EcorePackage$Literals() , ETYPE_PARAMETER):eClass), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings_0(this), featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ETYPE_PARAMETER)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_30(featureID){
  var eClass;
  switch (featureID) {
    case 0:
      return !!this.eAnnotations && this.eAnnotations.size_0 != 0;
    case 1:
      return this.name_0 != null;
    case 2:
      return !!this.eBounds && this.eBounds.size_0 != 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ETYPE_PARAMETER)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ETYPE_PARAMETER:eClass), featureID));
}
;
_.eSet = function eSet_28(featureID, newValue){
  var eClass;
  switch (featureID) {
    case 0:
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $clear_11(this.eAnnotations);
      !this.eAnnotations && (this.eAnnotations = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, this, 0, 3));
      $addAll_6(this.eAnnotations, castTo(newValue, 13));
      return;
    case 1:
      $setName(this, castToString(newValue));
      return;
    case 2:
      !this.eBounds && (this.eBounds = new ETypeParameterImpl$1(this, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this));
      $clear_11(this.eBounds);
      !this.eBounds && (this.eBounds = new ETypeParameterImpl$1(this, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, this));
      $addAll_6(this.eBounds, castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_EcorePackage$Literals() , ETYPE_PARAMETER)), $getEStructuralFeature((eClass = castTo($getField(this, 16), 26) , !eClass?ETYPE_PARAMETER:eClass), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_30(){
  return $clinit_EcorePackage$Literals() , ETYPE_PARAMETER;
}
;
var Lorg_eclipse_emf_ecore_impl_ETypeParameterImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ETypeParameterImpl', 423);
function $inverseAdd_1(this$static, object, notifications){
  var delegateIterator, eGenericType, eGenericType$iterator, eGenericTypes;
  notifications = $eInverseAdd(object, this$static.owner, -1 - this$static.featureID, notifications);
  eGenericTypes = $getEGenericTypes(this$static.this$01);
  for (eGenericType$iterator = (delegateIterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(eGenericTypes.this$11)).this$01) , new ETypeParameterImpl$2$1$1(delegateIterator)); eGenericType$iterator.val$delegateIterator2.hasNext;) {
    eGenericType = castTo($next_7(eGenericType$iterator.val$delegateIterator2).getKey(), 86);
    notifications = $setERawType(eGenericType, $getErasure(eGenericType, this$static.this$01), notifications);
  }
  return notifications;
}

function $inverseRemove_1(this$static, object, notifications){
  var delegateIterator, eGenericType, eGenericType$iterator, eGenericTypes;
  notifications = $eInverseRemove(object, this$static.owner, -1 - this$static.featureID, notifications);
  eGenericTypes = $getEGenericTypes(this$static.this$01);
  for (eGenericType$iterator = (delegateIterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(eGenericTypes.this$11)).this$01) , new ETypeParameterImpl$2$1$1(delegateIterator)); eGenericType$iterator.val$delegateIterator2.hasNext;) {
    eGenericType = castTo($next_7(eGenericType$iterator.val$delegateIterator2).getKey(), 86);
    notifications = $setERawType(eGenericType, $getErasure(eGenericType, this$static.this$01), notifications);
  }
  return notifications;
}

function ETypeParameterImpl$1(this$0, $anonymous0, $anonymous1){
  this.this$01 = this$0;
  EObjectContainmentEList.call(this, $anonymous0, $anonymous1, 2);
}

defineClass(474, 84, $intern_156, ETypeParameterImpl$1);
_.inverseAdd = function inverseAdd_7(object, notifications){
  return $inverseAdd_1(this, castTo(object, 86), notifications);
}
;
_.inverseRemove = function inverseRemove_7(object, notifications){
  return $inverseRemove_1(this, castTo(object, 86), notifications);
}
;
var Lorg_eclipse_emf_ecore_impl_ETypeParameterImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ETypeParameterImpl/1', 474);
function ETypeParameterImpl$2(){
  HashMap.call(this);
}

defineClass(601, 41, $intern_78, ETypeParameterImpl$2);
_.keySet_0 = function keySet_16(){
  return new ETypeParameterImpl$2$1(this);
}
;
var Lorg_eclipse_emf_ecore_impl_ETypeParameterImpl$2_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ETypeParameterImpl/2', 601);
function $add_30(this$static, eGenericType){
  return $put_1(this$static.this$11, eGenericType, '') == null;
}

function $remove_41(this$static, object){
  if ($containsKey_2(this$static.this$11, object)) {
    $remove_7(this$static.this$11, object);
    return true;
  }
   else {
    return false;
  }
}

function ETypeParameterImpl$2$1(this$1){
  this.this$11 = this$1;
}

defineClass(528, $intern_13, $intern_14, ETypeParameterImpl$2$1);
_.add_1 = function add_63(eGenericType){
  return $add_30(this, castTo(eGenericType, 86));
}
;
_.addAll = function addAll_19(eGenericTypes){
  var eGenericType, eGenericType$iterator, result;
  result = false;
  for (eGenericType$iterator = eGenericTypes.iterator_0(); eGenericType$iterator.hasNext_0();) {
    eGenericType = castTo(eGenericType$iterator.next_1(), 86);
    $put_1(this.this$11, eGenericType, '') == null && (result = true);
  }
  return result;
}
;
_.clear_0 = function clear_61(){
  $reset(this.this$11);
}
;
_.contains = function contains_59(object){
  return $containsKey_2(this.this$11, object);
}
;
_.iterator_0 = function iterator_81(){
  var delegateIterator;
  return delegateIterator = new AbstractHashMap$EntrySetIterator((new AbstractHashMap$EntrySet(this.this$11)).this$01) , new ETypeParameterImpl$2$1$1(delegateIterator);
}
;
_.remove_1 = function remove_123(object){
  return $remove_41(this, object);
}
;
_.size_1 = function size_69(){
  return $size_0(this.this$11);
}
;
var Lorg_eclipse_emf_ecore_impl_ETypeParameterImpl$2$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ETypeParameterImpl/2/1', 528);
function ETypeParameterImpl$2$1$1(val$delegateIterator){
  this.val$delegateIterator2 = val$delegateIterator;
}

defineClass(529, 1, $intern_4, ETypeParameterImpl$2$1$1);
_.forEachRemaining = function forEachRemaining_51(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_48(){
  return castTo($next_7(this.val$delegateIterator2).getKey(), 86);
}
;
_.hasNext_0 = function hasNext_47(){
  return this.val$delegateIterator2.hasNext;
}
;
_.remove_0 = function remove_124(){
  $remove_8(this.val$delegateIterator2);
}
;
var Lorg_eclipse_emf_ecore_impl_ETypeParameterImpl$2$1$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'ETypeParameterImpl/2/1/1', 529);
function EValidatorRegistryImpl(){
  HashMap.call(this);
}

defineClass(1194, 41, $intern_78, EValidatorRegistryImpl);
_.containsKey = function containsKey_12(key){
  return instanceOfString(key)?$hasStringValue(this, key):!!$getEntry(this.hashCodeMap, key);
}
;
_.get_0 = function get_50(key){
  var eValidator, eValidatorDescriptor;
  eValidator = instanceOfString(key)?$getStringValue(this, key):getEntryValueOrNull($getEntry(this.hashCodeMap, key));
  if (instanceOf(eValidator, 773)) {
    eValidatorDescriptor = castTo(eValidator, 773);
    eValidator = eValidatorDescriptor.getEValidator();
    $put_1(this, castTo(key, 214), eValidator);
    return eValidator;
  }
   else 
    return eValidator != null?eValidator:key == null?($clinit_EObjectValidator() , INSTANCE_9):null;
}
;
var Lorg_eclipse_emf_ecore_impl_EValidatorRegistryImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EValidatorRegistryImpl', 1194);
function $booleanValueOf(initialValue){
  if ($equalsIgnoreCase('true', initialValue)) {
    return $clinit_Boolean() , TRUE_0;
  }
   else if ($equalsIgnoreCase('false', initialValue)) {
    return $clinit_Boolean() , FALSE_0;
  }
   else {
    throw toJs(new IllegalArgumentException_0('Expecting true or false'));
  }
}

function $convertEByteArrayToString(instanceValue){
  var bytes;
  if (instanceValue == null) {
    return null;
  }
   else {
    bytes = castTo(instanceValue, 178);
    return $bytesToHexString(bytes, bytes.length);
  }
}

function $convertECharToString(instanceValue){
  if (instanceOf(instanceValue, 161)) {
    return '' + castTo(instanceValue, 161).value_0;
  }
  return instanceValue == null?null:toString_41(instanceValue);
}

function $convertECharacterObjectToString(instanceValue){
  if (instanceOf(instanceValue, 161)) {
    return '' + castTo(instanceValue, 161).value_0;
  }
  return instanceValue == null?null:toString_41(instanceValue);
}

function $createECharFromString(initialValue){
  var carray, charValue;
  if (initialValue == null) {
    return null;
  }
  try {
    charValue = __parseAndValidateInt(initialValue, $intern_43, $intern_0) & $intern_47;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 120)) {
      carray = $toCharArray(initialValue);
      charValue = carray[0];
    }
     else 
      throw toJs($e0);
  }
  return valueOf_3(charValue);
}

function $createECharacterObjectFromString(initialValue){
  var carray, charValue;
  if (initialValue == null) {
    return null;
  }
  try {
    charValue = __parseAndValidateInt(initialValue, $intern_43, $intern_0) & $intern_47;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 120)) {
      carray = $toCharArray(initialValue);
      charValue = carray[0];
    }
     else 
      throw toJs($e0);
  }
  return valueOf_3(charValue);
}

function $createEDateFromString(initialValue){
  var exception, i, parseException;
  if (initialValue == null) {
    return null;
  }
  exception = null;
  for (i = 0; i < EDATE_FORMATS.length; ++i) {
    try {
      return $parse_2(EDATE_FORMATS[i], initialValue);
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (instanceOf($e0, 30)) {
        parseException = $e0;
        exception = parseException;
      }
       else 
        throw toJs($e0);
    }
  }
  throw toJs(new WrappedException(exception));
}

function EcoreFactoryImpl(){
}

function init_3(){
  $clinit_EFactoryImpl();
  var exception, theEcoreFactory;
  try {
    theEcoreFactory = castTo($getEFactory(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/emf/2002/Ecore'), 1720);
    if (theEcoreFactory) {
      return theEcoreFactory;
    }
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 102)) {
      exception = $e0;
      $log(($clinit_EcorePlugin() , exception));
    }
     else 
      throw toJs($e0);
  }
  return new EcoreFactoryImpl;
}

defineClass(1216, 660, {98:1, 92:1, 89:1, 445:1, 143:1, 51:1, 106:1, 1720:1, 46:1, 93:1, 145:1, 109:1, 110:1}, EcoreFactoryImpl);
_.convertToString = function convertToString_1(eDataType, instanceValue){
  switch (eDataType.getClassifierID()) {
    case 21:
    case 22:
    case 23:
    case 24:
    case 26:
    case 31:
    case 32:
    case 37:
    case 38:
    case 39:
    case 40:
    case 43:
    case 44:
    case 48:
    case 49:
    case 20:
      return instanceValue == null?null:toString_41(instanceValue);
    case 25:
      return $convertEByteArrayToString(instanceValue);
    case 27:
      return $convertECharToString(instanceValue);
    case 28:
      return $convertECharacterObjectToString(instanceValue);
    case 29:
      return instanceValue == null?null:$format_0(EDATE_FORMATS[0], castTo(instanceValue, 185));
    case 41:
      return instanceValue == null?'':$getName(castTo(instanceValue, 283));
    case 42:
      return toString_41(instanceValue);
    case 50:
      return castToString(instanceValue);
    default:throw toJs(new IllegalArgumentException_0("The datatype '" + eDataType.getName() + "' is not a valid classifier"));
  }
}
;
_.create_3 = function create_42(eClass0){
  var eAnnotation, eAttribute, eClass, eDataType, eEnum, eEnumLiteral, eFactory, eGenericType, eObject, eOperation, ePackage, ePackage0, eParameter, eReference, eStringToStringMapEntry, eTypeParameter;
  switch (eClass0.metaObjectID == -1 && (eClass0.metaObjectID = (ePackage0 = $getEPackage(eClass0) , ePackage0?$indexOf_6(ePackage0.getEClassifiers(), eClass0):-1)) , eClass0.metaObjectID) {
    case 0:
      return eAttribute = new EAttributeImpl , eAttribute;
    case 1:
      return eAnnotation = new EAnnotationImpl , eAnnotation;
    case 2:
      return eClass = new EClassImpl , eClass;
    case 4:
      return eDataType = new EDataTypeImpl , eDataType;
    case 5:
      return eEnum = new EEnumImpl , eEnum;
    case 6:
      return eEnumLiteral = new EEnumLiteralImpl , eEnumLiteral;
    case 7:
      return eFactory = new EFactoryImpl , eFactory;
    case 10:
      return eObject = new EObjectImpl , eObject;
    case 11:
      return eOperation = new EOperationImpl , eOperation;
    case 12:
      return ePackage = new EPackageImpl , ePackage;
    case 13:
      return eParameter = new EParameterImpl , eParameter;
    case 14:
      return eReference = new EReferenceImpl , eReference;
    case 17:
      return eStringToStringMapEntry = new EStringToStringMapEntryImpl , eStringToStringMapEntry;
    case 18:
      return eGenericType = new EGenericTypeImpl , eGenericType;
    case 19:
      return eTypeParameter = new ETypeParameterImpl , eTypeParameter;
    default:throw toJs(new IllegalArgumentException_0("The class '" + eClass0.name_0 + "' is not a valid classifier"));
  }
}
;
_.createFromString = function createFromString_1(eDataType, initialValue){
  switch (eDataType.getClassifierID()) {
    case 20:
      return initialValue == null?null:new BigDecimal_0(initialValue);
    case 21:
      return initialValue == null?null:new BigInteger_4(initialValue);
    case 23:
    case 22:
      return initialValue == null?null:$booleanValueOf(initialValue);
    case 26:
    case 24:
      return initialValue == null?null:valueOf_2(__parseAndValidateInt(initialValue, -128, 127) << 24 >> 24);
    case 25:
      return $hexStringToBytes(initialValue);
    case 27:
      return $createECharFromString(initialValue);
    case 28:
      return $createECharacterObjectFromString(initialValue);
    case 29:
      return $createEDateFromString(initialValue);
    case 32:
    case 31:
      return initialValue == null?null:__parseAndValidateDouble(initialValue);
    case 38:
    case 37:
      return initialValue == null?null:new Float_0(initialValue);
    case 40:
    case 39:
      return initialValue == null?null:valueOf_4(__parseAndValidateInt(initialValue, $intern_43, $intern_0));
    case 41:
      return null;
    case 42:
      return initialValue == null?null:null;
    case 44:
    case 43:
      return initialValue == null?null:valueOf_5(__parseAndValidateLong(initialValue));
    case 49:
    case 48:
      return initialValue == null?null:valueOf_6(__parseAndValidateInt(initialValue, $intern_163, 32767) << 16 >> 16);
    case 50:
      return initialValue;
    default:throw toJs(new IllegalArgumentException_0("The datatype '" + eDataType.getName() + "' is not a valid classifier"));
  }
}
;
var Lorg_eclipse_emf_ecore_impl_EcoreFactoryImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcoreFactoryImpl', 1216);
function $clinit_EcorePackageImpl(){
  $clinit_EcorePackageImpl = emptyMethod;
  eGenericTypes_0 = new ArrayList;
}

function $$init_13(this$static){
  this$static.eAttributeEClass = null;
  this$static.eAnnotationEClass = null;
  this$static.eClassEClass = null;
  this$static.eDataTypeEClass = null;
  this$static.eEnumEClass = null;
  this$static.eEnumLiteralEClass = null;
  this$static.eFactoryEClass = null;
  this$static.eClassifierEClass = null;
  this$static.eModelElementEClass = null;
  this$static.eNamedElementEClass = null;
  this$static.eObjectEClass = null;
  this$static.eOperationEClass = null;
  this$static.ePackageEClass = null;
  this$static.eParameterEClass = null;
  this$static.eReferenceEClass = null;
  this$static.eStructuralFeatureEClass = null;
  this$static.eTypedElementEClass = null;
  this$static.eStringToStringMapEntryEClass = null;
  this$static.eGenericTypeEClass = null;
  this$static.eTypeParameterEClass = null;
  this$static.eBigDecimalEDataType = null;
  this$static.eBigIntegerEDataType = null;
  this$static.eBooleanObjectEDataType = null;
  this$static.eCharacterObjectEDataType = null;
  this$static.eDateEDataType = null;
  this$static.eDiagnosticChainEDataType = null;
  this$static.eDoubleObjectEDataType = null;
  this$static.eFloatObjectEDataType = null;
  this$static.eIntegerObjectEDataType = null;
  this$static.eBooleanEDataType = null;
  this$static.eByteObjectEDataType = null;
  this$static.eByteEDataType = null;
  this$static.eByteArrayEDataType = null;
  this$static.eCharEDataType = null;
  this$static.eDoubleEDataType = null;
  this$static.eFloatEDataType = null;
  this$static.eIntEDataType = null;
  this$static.eJavaClassEDataType = null;
  this$static.eJavaObjectEDataType = null;
  this$static.eLongObjectEDataType = null;
  this$static.eMapEDataType = null;
  this$static.eShortObjectEDataType = null;
  this$static.eLongEDataType = null;
  this$static.eShortEDataType = null;
  this$static.eTreeIteratorEDataType = null;
  this$static.eInvocationTargetExceptionEDataType = null;
  this$static.eFeatureMapEntryEDataType = null;
  this$static.eEnumeratorEDataType = null;
  this$static.eFeatureMapEDataType = null;
  this$static.eStringEDataType = null;
  this$static.eeListEDataType = null;
  this$static.eResourceEDataType = null;
  this$static.eResourceSetEDataType = null;
  this$static.isCreated = false;
  this$static.isInitialized = false;
}

function $createEGenericType_1(){
  var eGenericType, eGenericType0, eGenericType1;
  eGenericType0 = (eGenericType1 = (eGenericType = new EGenericTypeImpl , eGenericType) , eGenericType1);
  $add_4(eGenericTypes_0, eGenericType0);
  return eGenericType0;
}

function $createEcoreAnnotations(this$static){
  $addAnnotation(this$static.eAttributeEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'ConsistentTransient']));
  $addAnnotation(this$static.eAnnotationEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'WellFormedSourceURI']));
  $addAnnotation(this$static.eClassEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'InterfaceIsAbstract AtMostOneID UniqueFeatureNames UniqueOperationSignatures NoCircularSuperTypes WellFormedMapEntryClass ConsistentSuperTypes DisjointFeatureAndOperationSignatures']));
  $addAnnotation(this$static.eClassifierEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'WellFormedInstanceTypeName UniqueTypeParameterNames']));
  $addAnnotation(this$static.eEnumEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'UniqueEnumeratorNames UniqueEnumeratorLiterals']));
  $addAnnotation(this$static.eNamedElementEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'WellFormedName']));
  $addAnnotation(this$static.eOperationEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'UniqueParameterNames UniqueTypeParameterNames NoRepeatingVoid']));
  $addAnnotation(this$static.ePackageEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'WellFormedNsURI WellFormedNsPrefix UniqueSubpackageNames UniqueClassifierNames UniqueNsURIs']));
  $addAnnotation(this$static.eReferenceEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'ConsistentOpposite SingleContainer ConsistentKeys ConsistentUnique ConsistentContainer']));
  $addAnnotation(this$static.eStructuralFeatureEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'ValidDefaultValueLiteral']));
  $addAnnotation(this$static.eTypedElementEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'ValidLowerBound ValidUpperBound ConsistentBounds ValidType']));
  $addAnnotation(this$static.eGenericTypeEClass, 'http://www.eclipse.org/emf/2002/Ecore', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['constraints', 'ConsistentType ConsistentBounds ConsistentArguments']));
}

function $createExtendedMetaDataAnnotations(this$static){
  $addAnnotation(this$static.eBigDecimalEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#decimal']));
  $addAnnotation(this$static.eBigIntegerEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#integer']));
  $addAnnotation(this$static.eBooleanEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#boolean']));
  $addAnnotation(this$static.eBooleanObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'EBoolean', 'name', 'EBoolean:Object']));
  $addAnnotation(this$static.eByteEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#byte']));
  $addAnnotation(this$static.eByteArrayEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#hexBinary']));
  $addAnnotation(this$static.eByteObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'EByte', 'name', 'EByte:Object']));
  $addAnnotation(this$static.eCharacterObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'EChar', 'name', 'EChar:Object']));
  $addAnnotation(this$static.eDoubleEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#double']));
  $addAnnotation(this$static.eDoubleObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'EDouble', 'name', 'EDouble:Object']));
  $addAnnotation(this$static.eFloatEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#float']));
  $addAnnotation(this$static.eFloatObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'EFloat', 'name', 'EFloat:Object']));
  $addAnnotation(this$static.eIntEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#int']));
  $addAnnotation(this$static.eIntegerObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'EInt', 'name', 'EInt:Object']));
  $addAnnotation(this$static.eLongEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#long']));
  $addAnnotation(this$static.eLongObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'ELong', 'name', 'ELong:Object']));
  $addAnnotation(this$static.eShortEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#short']));
  $addAnnotation(this$static.eShortObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'EShort', 'name', 'EShort:Object']));
  $addAnnotation(this$static.eStringEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['baseType', 'http://www.w3.org/2001/XMLSchema#string']));
}

function $createPackageContents_0(this$static){
  if (this$static.isCreated)
    return;
  this$static.isCreated = true;
  this$static.eAttributeEClass = $createEClass(this$static, 0);
  $createEAttribute(this$static.eAttributeEClass, 18);
  $createEReference(this$static.eAttributeEClass, 19);
  this$static.eAnnotationEClass = $createEClass(this$static, 1);
  $createEAttribute(this$static.eAnnotationEClass, 1);
  $createEReference(this$static.eAnnotationEClass, 2);
  $createEReference(this$static.eAnnotationEClass, 3);
  $createEReference(this$static.eAnnotationEClass, 4);
  $createEReference(this$static.eAnnotationEClass, 5);
  this$static.eClassEClass = $createEClass(this$static, 2);
  $createEAttribute(this$static.eClassEClass, 8);
  $createEAttribute(this$static.eClassEClass, 9);
  $createEReference(this$static.eClassEClass, 10);
  $createEReference(this$static.eClassEClass, 11);
  $createEReference(this$static.eClassEClass, 12);
  $createEReference(this$static.eClassEClass, 13);
  $createEReference(this$static.eClassEClass, 14);
  $createEReference(this$static.eClassEClass, 15);
  $createEReference(this$static.eClassEClass, 16);
  $createEReference(this$static.eClassEClass, 17);
  $createEReference(this$static.eClassEClass, 18);
  $createEReference(this$static.eClassEClass, 19);
  $createEReference(this$static.eClassEClass, 20);
  $createEReference(this$static.eClassEClass, 21);
  $createEReference(this$static.eClassEClass, 22);
  $createEReference(this$static.eClassEClass, 23);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  $createEOperation(this$static.eClassEClass);
  this$static.eClassifierEClass = $createEClass(this$static, 3);
  $createEAttribute(this$static.eClassifierEClass, 2);
  $createEAttribute(this$static.eClassifierEClass, 3);
  $createEAttribute(this$static.eClassifierEClass, 4);
  $createEAttribute(this$static.eClassifierEClass, 5);
  $createEReference(this$static.eClassifierEClass, 6);
  $createEReference(this$static.eClassifierEClass, 7);
  $createEOperation(this$static.eClassifierEClass);
  $createEOperation(this$static.eClassifierEClass);
  this$static.eDataTypeEClass = $createEClass(this$static, 4);
  $createEAttribute(this$static.eDataTypeEClass, 8);
  this$static.eEnumEClass = $createEClass(this$static, 5);
  $createEReference(this$static.eEnumEClass, 9);
  $createEOperation(this$static.eEnumEClass);
  $createEOperation(this$static.eEnumEClass);
  $createEOperation(this$static.eEnumEClass);
  this$static.eEnumLiteralEClass = $createEClass(this$static, 6);
  $createEAttribute(this$static.eEnumLiteralEClass, 2);
  $createEAttribute(this$static.eEnumLiteralEClass, 3);
  $createEAttribute(this$static.eEnumLiteralEClass, 4);
  $createEReference(this$static.eEnumLiteralEClass, 5);
  this$static.eFactoryEClass = $createEClass(this$static, 7);
  $createEReference(this$static.eFactoryEClass, 1);
  $createEOperation(this$static.eFactoryEClass);
  $createEOperation(this$static.eFactoryEClass);
  $createEOperation(this$static.eFactoryEClass);
  this$static.eModelElementEClass = $createEClass(this$static, 8);
  $createEReference(this$static.eModelElementEClass, 0);
  $createEOperation(this$static.eModelElementEClass);
  this$static.eNamedElementEClass = $createEClass(this$static, 9);
  $createEAttribute(this$static.eNamedElementEClass, 1);
  this$static.eObjectEClass = $createEClass(this$static, 10);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  $createEOperation(this$static.eObjectEClass);
  this$static.eOperationEClass = $createEClass(this$static, 11);
  $createEReference(this$static.eOperationEClass, 10);
  $createEReference(this$static.eOperationEClass, 11);
  $createEReference(this$static.eOperationEClass, 12);
  $createEReference(this$static.eOperationEClass, 13);
  $createEReference(this$static.eOperationEClass, 14);
  $createEOperation(this$static.eOperationEClass);
  $createEOperation(this$static.eOperationEClass);
  this$static.ePackageEClass = $createEClass(this$static, 12);
  $createEAttribute(this$static.ePackageEClass, 2);
  $createEAttribute(this$static.ePackageEClass, 3);
  $createEReference(this$static.ePackageEClass, 4);
  $createEReference(this$static.ePackageEClass, 5);
  $createEReference(this$static.ePackageEClass, 6);
  $createEReference(this$static.ePackageEClass, 7);
  $createEOperation(this$static.ePackageEClass);
  this$static.eParameterEClass = $createEClass(this$static, 13);
  $createEReference(this$static.eParameterEClass, 10);
  this$static.eReferenceEClass = $createEClass(this$static, 14);
  $createEAttribute(this$static.eReferenceEClass, 18);
  $createEAttribute(this$static.eReferenceEClass, 19);
  $createEAttribute(this$static.eReferenceEClass, 20);
  $createEReference(this$static.eReferenceEClass, 21);
  $createEReference(this$static.eReferenceEClass, 22);
  $createEReference(this$static.eReferenceEClass, 23);
  this$static.eStructuralFeatureEClass = $createEClass(this$static, 15);
  $createEAttribute(this$static.eStructuralFeatureEClass, 10);
  $createEAttribute(this$static.eStructuralFeatureEClass, 11);
  $createEAttribute(this$static.eStructuralFeatureEClass, 12);
  $createEAttribute(this$static.eStructuralFeatureEClass, 13);
  $createEAttribute(this$static.eStructuralFeatureEClass, 14);
  $createEAttribute(this$static.eStructuralFeatureEClass, 15);
  $createEAttribute(this$static.eStructuralFeatureEClass, 16);
  $createEReference(this$static.eStructuralFeatureEClass, 17);
  $createEOperation(this$static.eStructuralFeatureEClass);
  $createEOperation(this$static.eStructuralFeatureEClass);
  this$static.eTypedElementEClass = $createEClass(this$static, 16);
  $createEAttribute(this$static.eTypedElementEClass, 2);
  $createEAttribute(this$static.eTypedElementEClass, 3);
  $createEAttribute(this$static.eTypedElementEClass, 4);
  $createEAttribute(this$static.eTypedElementEClass, 5);
  $createEAttribute(this$static.eTypedElementEClass, 6);
  $createEAttribute(this$static.eTypedElementEClass, 7);
  $createEReference(this$static.eTypedElementEClass, 8);
  $createEReference(this$static.eTypedElementEClass, 9);
  this$static.eStringToStringMapEntryEClass = $createEClass(this$static, 17);
  $createEAttribute(this$static.eStringToStringMapEntryEClass, 0);
  $createEAttribute(this$static.eStringToStringMapEntryEClass, 1);
  this$static.eGenericTypeEClass = $createEClass(this$static, 18);
  $createEReference(this$static.eGenericTypeEClass, 0);
  $createEReference(this$static.eGenericTypeEClass, 1);
  $createEReference(this$static.eGenericTypeEClass, 2);
  $createEReference(this$static.eGenericTypeEClass, 3);
  $createEReference(this$static.eGenericTypeEClass, 4);
  $createEReference(this$static.eGenericTypeEClass, 5);
  $createEOperation(this$static.eGenericTypeEClass);
  this$static.eTypeParameterEClass = $createEClass(this$static, 19);
  $createEReference(this$static.eTypeParameterEClass, 2);
  this$static.eBigDecimalEDataType = $createEDataType(this$static, 20);
  this$static.eBigIntegerEDataType = $createEDataType(this$static, 21);
  this$static.eBooleanEDataType = $createEDataType(this$static, 22);
  this$static.eBooleanObjectEDataType = $createEDataType(this$static, 23);
  this$static.eByteEDataType = $createEDataType(this$static, 24);
  this$static.eByteArrayEDataType = $createEDataType(this$static, 25);
  this$static.eByteObjectEDataType = $createEDataType(this$static, 26);
  this$static.eCharEDataType = $createEDataType(this$static, 27);
  this$static.eCharacterObjectEDataType = $createEDataType(this$static, 28);
  this$static.eDateEDataType = $createEDataType(this$static, 29);
  this$static.eDiagnosticChainEDataType = $createEDataType(this$static, 30);
  this$static.eDoubleEDataType = $createEDataType(this$static, 31);
  this$static.eDoubleObjectEDataType = $createEDataType(this$static, 32);
  this$static.eeListEDataType = $createEDataType(this$static, 33);
  this$static.eEnumeratorEDataType = $createEDataType(this$static, 34);
  this$static.eFeatureMapEDataType = $createEDataType(this$static, 35);
  this$static.eFeatureMapEntryEDataType = $createEDataType(this$static, 36);
  this$static.eFloatEDataType = $createEDataType(this$static, 37);
  this$static.eFloatObjectEDataType = $createEDataType(this$static, 38);
  this$static.eIntEDataType = $createEDataType(this$static, 39);
  this$static.eIntegerObjectEDataType = $createEDataType(this$static, 40);
  this$static.eJavaClassEDataType = $createEDataType(this$static, 41);
  this$static.eJavaObjectEDataType = $createEDataType(this$static, 42);
  this$static.eLongEDataType = $createEDataType(this$static, 43);
  this$static.eLongObjectEDataType = $createEDataType(this$static, 44);
  this$static.eMapEDataType = $createEDataType(this$static, 45);
  this$static.eResourceEDataType = $createEDataType(this$static, 46);
  this$static.eResourceSetEDataType = $createEDataType(this$static, 47);
  this$static.eShortEDataType = $createEDataType(this$static, 48);
  this$static.eShortObjectEDataType = $createEDataType(this$static, 49);
  this$static.eStringEDataType = $createEDataType(this$static, 50);
  this$static.eTreeIteratorEDataType = $createEDataType(this$static, 51);
  this$static.eInvocationTargetExceptionEDataType = $createEDataType(this$static, 52);
}

function $initializePackageContents_0(this$static){
  var g1, g2, msgs, msgs0, msgs1, msgs2, op;
  if (this$static.isInitialized)
    return;
  this$static.isInitialized = true;
  $setName(this$static, 'ecore');
  $setNsPrefix(this$static, 'ecore');
  $setNsURI(this$static, 'http://www.eclipse.org/emf/2002/Ecore');
  $addETypeParameter(this$static.eeListEDataType, 'E');
  $addETypeParameter(this$static.eJavaClassEDataType, 'T');
  $addETypeParameter(this$static.eMapEDataType, 'K');
  $addETypeParameter(this$static.eMapEDataType, 'V');
  $addETypeParameter(this$static.eTreeIteratorEDataType, 'E');
  $add_21($getESuperTypes(this$static.eAttributeEClass), this$static.eStructuralFeatureEClass);
  $add_21($getESuperTypes(this$static.eAnnotationEClass), this$static.eModelElementEClass);
  $add_21($getESuperTypes(this$static.eClassEClass), this$static.eClassifierEClass);
  $add_21($getESuperTypes(this$static.eClassifierEClass), this$static.eNamedElementEClass);
  $add_21($getESuperTypes(this$static.eDataTypeEClass), this$static.eClassifierEClass);
  $add_21($getESuperTypes(this$static.eEnumEClass), this$static.eDataTypeEClass);
  $add_21($getESuperTypes(this$static.eEnumLiteralEClass), this$static.eNamedElementEClass);
  $add_21($getESuperTypes(this$static.eFactoryEClass), this$static.eModelElementEClass);
  $add_21($getESuperTypes(this$static.eNamedElementEClass), this$static.eModelElementEClass);
  $add_21($getESuperTypes(this$static.eOperationEClass), this$static.eTypedElementEClass);
  $add_21($getESuperTypes(this$static.ePackageEClass), this$static.eNamedElementEClass);
  $add_21($getESuperTypes(this$static.eParameterEClass), this$static.eTypedElementEClass);
  $add_21($getESuperTypes(this$static.eReferenceEClass), this$static.eStructuralFeatureEClass);
  $add_21($getESuperTypes(this$static.eStructuralFeatureEClass), this$static.eTypedElementEClass);
  $add_21($getESuperTypes(this$static.eTypedElementEClass), this$static.eNamedElementEClass);
  $add_21($getESuperTypes(this$static.eTypeParameterEClass), this$static.eNamedElementEClass);
  $initEClass(this$static.eAttributeEClass, Lorg_eclipse_emf_ecore_EAttribute_2_classLit, 'EAttribute', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eAttributeEClass), 0), 29), this$static.eBooleanEDataType, 'iD', null, 0, 1, Lorg_eclipse_emf_ecore_EAttribute_2_classLit, false, false, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eAttributeEClass), 1), 17), this$static.eDataTypeEClass, null, 'eAttributeType', 1, 1, Lorg_eclipse_emf_ecore_EAttribute_2_classLit, true, true, false, false, true, false, true);
  $initEClass(this$static.eAnnotationEClass, Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, 'EAnnotation', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eAnnotationEClass), 0), 29), this$static.eStringEDataType, 'source', null, 0, 1, Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, false, false, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eAnnotationEClass), 1), 17), this$static.eStringToStringMapEntryEClass, null, 'details', 0, -1, Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eAnnotationEClass), 2), 17), this$static.eModelElementEClass, castTo($get_16($getEStructuralFeatures(this$static.eModelElementEClass), 0), 17), 'eModelElement', 0, 1, Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, true, false, true, false, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eAnnotationEClass), 3), 17), this$static.eObjectEClass, null, 'contents', 0, -1, Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eAnnotationEClass), 4), 17), this$static.eObjectEClass, null, 'references', 0, -1, Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, false, false, true, false, true, false, false);
  $initEClass(this$static.eClassEClass, Lorg_eclipse_emf_ecore_EClass_2_classLit, 'EClass', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 0), 29), this$static.eBooleanEDataType, 'abstract', null, 0, 1, Lorg_eclipse_emf_ecore_EClass_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 1), 29), this$static.eBooleanEDataType, 'interface', null, 0, 1, Lorg_eclipse_emf_ecore_EClass_2_classLit, false, false, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 2), 17), this$static.eClassEClass, null, 'eSuperTypes', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, false, false, true, false, true, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 3), 17), this$static.eOperationEClass, castTo($get_16($getEStructuralFeatures(this$static.eOperationEClass), 0), 17), 'eOperations', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 4), 17), this$static.eAttributeEClass, null, 'eAllAttributes', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 5), 17), this$static.eReferenceEClass, null, 'eAllReferences', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 6), 17), this$static.eReferenceEClass, null, 'eReferences', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 7), 17), this$static.eAttributeEClass, null, 'eAttributes', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 8), 17), this$static.eReferenceEClass, null, 'eAllContainments', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 9), 17), this$static.eOperationEClass, null, 'eAllOperations', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 10), 17), this$static.eStructuralFeatureEClass, null, 'eAllStructuralFeatures', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 11), 17), this$static.eClassEClass, null, 'eAllSuperTypes', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 12), 17), this$static.eAttributeEClass, null, 'eIDAttribute', 0, 1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 13), 17), this$static.eStructuralFeatureEClass, castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 7), 17), 'eStructuralFeatures', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 14), 17), this$static.eGenericTypeEClass, null, 'eGenericSuperTypes', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, false, false, true, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 15), 17), this$static.eGenericTypeEClass, null, 'eAllGenericSuperTypes', 0, -1, Lorg_eclipse_emf_ecore_EClass_2_classLit, true, true, false, false, true, false, true);
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 0), 53), this$static.eBooleanEDataType, 'isSuperTypeOf');
  $addEParameter(op, this$static.eClassEClass, 'someClass');
  $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 1), 53), this$static.eIntEDataType, 'getFeatureCount');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 2), 53), this$static.eStructuralFeatureEClass, 'getEStructuralFeature');
  $addEParameter(op, this$static.eIntEDataType, 'featureID');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 3), 53), this$static.eIntEDataType, 'getFeatureID');
  $addEParameter(op, this$static.eStructuralFeatureEClass, 'feature');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 4), 53), this$static.eStructuralFeatureEClass, 'getEStructuralFeature');
  $addEParameter(op, this$static.eStringEDataType, 'featureName');
  $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 5), 53), this$static.eIntEDataType, 'getOperationCount');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 6), 53), this$static.eOperationEClass, 'getEOperation');
  $addEParameter(op, this$static.eIntEDataType, 'operationID');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 7), 53), this$static.eIntEDataType, 'getOperationID');
  $addEParameter(op, this$static.eOperationEClass, 'operation');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 8), 53), this$static.eOperationEClass, 'getOverride');
  $addEParameter(op, this$static.eOperationEClass, 'operation');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassEClass), 9), 53), this$static.eGenericTypeEClass, 'getFeatureType');
  $addEParameter(op, this$static.eStructuralFeatureEClass, 'feature');
  $initEClass(this$static.eClassifierEClass, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, 'EClassifier', true, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eClassifierEClass), 0), 29), this$static.eStringEDataType, 'instanceClassName', null, 0, 1, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, false, true, true, true, true, false);
  g1 = $createEGenericType(this$static.eJavaClassEDataType);
  g2 = $createEGenericType_1();
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  $initEAttribute_0(castTo($get_16($getEStructuralFeatures(this$static.eClassifierEClass), 1), 29), g1, 'instanceClass', Lorg_eclipse_emf_ecore_EClassifier_2_classLit, true, true, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eClassifierEClass), 2), 29), this$static.eJavaObjectEDataType, 'defaultValue', null, 0, 1, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, true, true, false, false, true, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eClassifierEClass), 3), 29), this$static.eStringEDataType, 'instanceTypeName', null, 0, 1, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, false, true, true, true, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassifierEClass), 4), 17), this$static.ePackageEClass, castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 3), 17), 'ePackage', 0, 1, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, true, false, false, false, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eClassifierEClass), 5), 17), this$static.eTypeParameterEClass, null, 'eTypeParameters', 0, -1, Lorg_eclipse_emf_ecore_EClassifier_2_classLit, false, false, true, true, true, false, false);
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eClassifierEClass), 0), 53), this$static.eBooleanEDataType, 'isInstance');
  $addEParameter(op, this$static.eJavaObjectEDataType, 'object');
  $initEOperation(castTo($get_16($getEOperations(this$static.eClassifierEClass), 1), 53), this$static.eIntEDataType, 'getClassifierID');
  $initEClass(this$static.eDataTypeEClass, Lorg_eclipse_emf_ecore_EDataType_2_classLit, 'EDataType', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eDataTypeEClass), 0), 29), this$static.eBooleanEDataType, 'serializable', 'true', 0, 1, Lorg_eclipse_emf_ecore_EDataType_2_classLit, false, false, true, false, true, false);
  $initEClass(this$static.eEnumEClass, Lorg_eclipse_emf_ecore_EEnum_2_classLit, 'EEnum', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eEnumEClass), 0), 17), this$static.eEnumLiteralEClass, castTo($get_16($getEStructuralFeatures(this$static.eEnumLiteralEClass), 3), 17), 'eLiterals', 0, -1, Lorg_eclipse_emf_ecore_EEnum_2_classLit, false, false, true, true, false, false, false);
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eEnumEClass), 0), 53), this$static.eEnumLiteralEClass, 'getEEnumLiteral');
  $addEParameter(op, this$static.eStringEDataType, 'name');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eEnumEClass), 1), 53), this$static.eEnumLiteralEClass, 'getEEnumLiteral');
  $addEParameter(op, this$static.eIntEDataType, 'value');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eEnumEClass), 2), 53), this$static.eEnumLiteralEClass, 'getEEnumLiteralByLiteral');
  $addEParameter(op, this$static.eStringEDataType, 'literal');
  $initEClass(this$static.eEnumLiteralEClass, Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, 'EEnumLiteral', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eEnumLiteralEClass), 0), 29), this$static.eIntEDataType, 'value', null, 0, 1, Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eEnumLiteralEClass), 1), 29), this$static.eEnumeratorEDataType, 'instance', null, 0, 1, Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, true, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eEnumLiteralEClass), 2), 29), this$static.eStringEDataType, 'literal', null, 0, 1, Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, false, false, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eEnumLiteralEClass), 3), 17), this$static.eEnumEClass, castTo($get_16($getEStructuralFeatures(this$static.eEnumEClass), 0), 17), 'eEnum', 0, 1, Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, true, false, false, false, false, false, false);
  $initEClass(this$static.eFactoryEClass, Lorg_eclipse_emf_ecore_EFactory_2_classLit, 'EFactory', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eFactoryEClass), 0), 17), this$static.ePackageEClass, castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 2), 17), 'ePackage', 1, 1, Lorg_eclipse_emf_ecore_EFactory_2_classLit, true, false, true, false, false, false, false);
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eFactoryEClass), 0), 53), this$static.eObjectEClass, 'create');
  $addEParameter(op, this$static.eClassEClass, 'eClass');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eFactoryEClass), 1), 53), this$static.eJavaObjectEDataType, 'createFromString');
  $addEParameter(op, this$static.eDataTypeEClass, 'eDataType');
  $addEParameter(op, this$static.eStringEDataType, 'literalValue');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eFactoryEClass), 2), 53), this$static.eStringEDataType, 'convertToString');
  $addEParameter(op, this$static.eDataTypeEClass, 'eDataType');
  $addEParameter(op, this$static.eJavaObjectEDataType, 'instanceValue');
  $initEClass(this$static.eModelElementEClass, Lorg_eclipse_emf_ecore_EModelElement_2_classLit, 'EModelElement', true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eModelElementEClass), 0), 17), this$static.eAnnotationEClass, castTo($get_16($getEStructuralFeatures(this$static.eAnnotationEClass), 2), 17), 'eAnnotations', 0, -1, Lorg_eclipse_emf_ecore_EModelElement_2_classLit, false, false, true, true, false, false, false);
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eModelElementEClass), 0), 53), this$static.eAnnotationEClass, 'getEAnnotation');
  $addEParameter(op, this$static.eStringEDataType, 'source');
  $initEClass(this$static.eNamedElementEClass, Lorg_eclipse_emf_ecore_ENamedElement_2_classLit, 'ENamedElement', true, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eNamedElementEClass), 0), 29), this$static.eStringEDataType, 'name', null, 0, 1, Lorg_eclipse_emf_ecore_ENamedElement_2_classLit, false, false, true, false, true, false);
  $initEClass(this$static.eObjectEClass, Lorg_eclipse_emf_ecore_EObject_2_classLit, 'EObject', false, false, true);
  $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 0), 53), this$static.eClassEClass, 'eClass');
  $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 1), 53), this$static.eBooleanEDataType, 'eIsProxy');
  $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 2), 53), this$static.eResourceEDataType, 'eResource');
  $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 3), 53), this$static.eObjectEClass, 'eContainer');
  $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 4), 53), this$static.eStructuralFeatureEClass, 'eContainingFeature');
  $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 5), 53), this$static.eReferenceEClass, 'eContainmentFeature');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 6), 53), null, 'eContents');
  g1 = $createEGenericType(this$static.eeListEDataType);
  g2 = $createEGenericType(this$static.eObjectEClass);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  msgs0 = $setEGenericType(op, g1, null);
  !!msgs0 && msgs0.dispatch_0();
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 7), 53), null, 'eAllContents');
  g1 = $createEGenericType(this$static.eTreeIteratorEDataType);
  g2 = $createEGenericType(this$static.eObjectEClass);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  msgs1 = $setEGenericType(op, g1, null);
  !!msgs1 && msgs1.dispatch_0();
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 8), 53), null, 'eCrossReferences');
  g1 = $createEGenericType(this$static.eeListEDataType);
  g2 = $createEGenericType(this$static.eObjectEClass);
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  msgs2 = $setEGenericType(op, g1, null);
  !!msgs2 && msgs2.dispatch_0();
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 9), 53), this$static.eJavaObjectEDataType, 'eGet');
  $addEParameter(op, this$static.eStructuralFeatureEClass, 'feature');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 10), 53), this$static.eJavaObjectEDataType, 'eGet');
  $addEParameter(op, this$static.eStructuralFeatureEClass, 'feature');
  $addEParameter(op, this$static.eBooleanEDataType, 'resolve');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 11), 53), null, 'eSet');
  $addEParameter(op, this$static.eStructuralFeatureEClass, 'feature');
  $addEParameter(op, this$static.eJavaObjectEDataType, 'newValue');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 12), 53), this$static.eBooleanEDataType, 'eIsSet');
  $addEParameter(op, this$static.eStructuralFeatureEClass, 'feature');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 13), 53), null, 'eUnset');
  $addEParameter(op, this$static.eStructuralFeatureEClass, 'feature');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eObjectEClass), 14), 53), this$static.eJavaObjectEDataType, 'eInvoke');
  $addEParameter(op, this$static.eOperationEClass, 'operation');
  g1 = $createEGenericType(this$static.eeListEDataType);
  g2 = $createEGenericType_1();
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  $addEParameter_0(op, g1, 'arguments');
  $addEException(op, this$static.eInvocationTargetExceptionEDataType);
  $initEClass(this$static.eOperationEClass, Lorg_eclipse_emf_ecore_EOperation_2_classLit, 'EOperation', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eOperationEClass), 0), 17), this$static.eClassEClass, castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 3), 17), 'eContainingClass', 0, 1, Lorg_eclipse_emf_ecore_EOperation_2_classLit, true, false, false, false, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eOperationEClass), 1), 17), this$static.eTypeParameterEClass, null, 'eTypeParameters', 0, -1, Lorg_eclipse_emf_ecore_EOperation_2_classLit, false, false, true, true, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eOperationEClass), 2), 17), this$static.eParameterEClass, castTo($get_16($getEStructuralFeatures(this$static.eParameterEClass), 0), 17), 'eParameters', 0, -1, Lorg_eclipse_emf_ecore_EOperation_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eOperationEClass), 3), 17), this$static.eClassifierEClass, null, 'eExceptions', 0, -1, Lorg_eclipse_emf_ecore_EOperation_2_classLit, false, false, true, false, true, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eOperationEClass), 4), 17), this$static.eGenericTypeEClass, null, 'eGenericExceptions', 0, -1, Lorg_eclipse_emf_ecore_EOperation_2_classLit, false, false, true, true, false, true, false);
  $initEOperation(castTo($get_16($getEOperations(this$static.eOperationEClass), 0), 53), this$static.eIntEDataType, 'getOperationID');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eOperationEClass), 1), 53), this$static.eBooleanEDataType, 'isOverrideOf');
  $addEParameter(op, this$static.eOperationEClass, 'someOperation');
  $initEClass(this$static.ePackageEClass, Lorg_eclipse_emf_ecore_EPackage_2_classLit, 'EPackage', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 0), 29), this$static.eStringEDataType, 'nsURI', null, 0, 1, Lorg_eclipse_emf_ecore_EPackage_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 1), 29), this$static.eStringEDataType, 'nsPrefix', null, 0, 1, Lorg_eclipse_emf_ecore_EPackage_2_classLit, false, false, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 2), 17), this$static.eFactoryEClass, castTo($get_16($getEStructuralFeatures(this$static.eFactoryEClass), 0), 17), 'eFactoryInstance', 1, 1, Lorg_eclipse_emf_ecore_EPackage_2_classLit, true, false, true, false, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 3), 17), this$static.eClassifierEClass, castTo($get_16($getEStructuralFeatures(this$static.eClassifierEClass), 4), 17), 'eClassifiers', 0, -1, Lorg_eclipse_emf_ecore_EPackage_2_classLit, false, false, true, true, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 4), 17), this$static.ePackageEClass, castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 5), 17), 'eSubpackages', 0, -1, Lorg_eclipse_emf_ecore_EPackage_2_classLit, false, false, true, true, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 5), 17), this$static.ePackageEClass, castTo($get_16($getEStructuralFeatures(this$static.ePackageEClass), 4), 17), 'eSuperPackage', 0, 1, Lorg_eclipse_emf_ecore_EPackage_2_classLit, true, false, false, false, true, false, false);
  op = $initEOperation(castTo($get_16($getEOperations(this$static.ePackageEClass), 0), 53), this$static.eClassifierEClass, 'getEClassifier');
  $addEParameter(op, this$static.eStringEDataType, 'name');
  $initEClass(this$static.eParameterEClass, Lorg_eclipse_emf_ecore_EParameter_2_classLit, 'EParameter', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eParameterEClass), 0), 17), this$static.eOperationEClass, castTo($get_16($getEStructuralFeatures(this$static.eOperationEClass), 2), 17), 'eOperation', 0, 1, Lorg_eclipse_emf_ecore_EParameter_2_classLit, true, false, false, false, false, false, false);
  $initEClass(this$static.eReferenceEClass, Lorg_eclipse_emf_ecore_EReference_2_classLit, 'EReference', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eReferenceEClass), 0), 29), this$static.eBooleanEDataType, 'containment', null, 0, 1, Lorg_eclipse_emf_ecore_EReference_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eReferenceEClass), 1), 29), this$static.eBooleanEDataType, 'container', null, 0, 1, Lorg_eclipse_emf_ecore_EReference_2_classLit, true, true, false, false, true, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eReferenceEClass), 2), 29), this$static.eBooleanEDataType, 'resolveProxies', 'true', 0, 1, Lorg_eclipse_emf_ecore_EReference_2_classLit, false, false, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eReferenceEClass), 3), 17), this$static.eReferenceEClass, null, 'eOpposite', 0, 1, Lorg_eclipse_emf_ecore_EReference_2_classLit, false, false, true, false, true, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eReferenceEClass), 4), 17), this$static.eClassEClass, null, 'eReferenceType', 1, 1, Lorg_eclipse_emf_ecore_EReference_2_classLit, true, true, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eReferenceEClass), 5), 17), this$static.eAttributeEClass, null, 'eKeys', 0, -1, Lorg_eclipse_emf_ecore_EReference_2_classLit, false, false, true, false, true, false, false);
  $initEClass(this$static.eStructuralFeatureEClass, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, 'EStructuralFeature', true, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 0), 29), this$static.eBooleanEDataType, 'changeable', 'true', 0, 1, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 1), 29), this$static.eBooleanEDataType, 'volatile', null, 0, 1, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 2), 29), this$static.eBooleanEDataType, 'transient', null, 0, 1, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 3), 29), this$static.eStringEDataType, 'defaultValueLiteral', null, 0, 1, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 4), 29), this$static.eJavaObjectEDataType, 'defaultValue', null, 0, 1, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, true, true, false, false, true, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 5), 29), this$static.eBooleanEDataType, 'unsettable', null, 0, 1, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 6), 29), this$static.eBooleanEDataType, 'derived', null, 0, 1, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, false, false, true, false, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eStructuralFeatureEClass), 7), 17), this$static.eClassEClass, castTo($get_16($getEStructuralFeatures(this$static.eClassEClass), 13), 17), 'eContainingClass', 0, 1, Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, true, false, false, false, false, false, false);
  $initEOperation(castTo($get_16($getEOperations(this$static.eStructuralFeatureEClass), 0), 53), this$static.eIntEDataType, 'getFeatureID');
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eStructuralFeatureEClass), 1), 53), null, 'getContainerClass');
  g1 = $createEGenericType(this$static.eJavaClassEDataType);
  g2 = $createEGenericType_1();
  $add_21((!g1.eTypeArguments && (g1.eTypeArguments = new EObjectContainmentEList(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, g1, 1)) , g1.eTypeArguments), g2);
  msgs = $setEGenericType(op, g1, null);
  !!msgs && msgs.dispatch_0();
  $initEClass(this$static.eTypedElementEClass, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, 'ETypedElement', true, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eTypedElementEClass), 0), 29), this$static.eBooleanEDataType, 'ordered', 'true', 0, 1, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eTypedElementEClass), 1), 29), this$static.eBooleanEDataType, 'unique', 'true', 0, 1, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eTypedElementEClass), 2), 29), this$static.eIntEDataType, 'lowerBound', null, 0, 1, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eTypedElementEClass), 3), 29), this$static.eIntEDataType, 'upperBound', '1', 0, 1, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eTypedElementEClass), 4), 29), this$static.eBooleanEDataType, 'many', null, 0, 1, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, true, true, false, false, true, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eTypedElementEClass), 5), 29), this$static.eBooleanEDataType, 'required', null, 0, 1, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, true, true, false, false, true, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eTypedElementEClass), 6), 17), this$static.eClassifierEClass, null, 'eType', 0, 1, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, false, true, true, false, true, true, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eTypedElementEClass), 7), 17), this$static.eGenericTypeEClass, null, 'eGenericType', 0, 1, Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, false, true, true, true, false, true, false);
  $initEClass(this$static.eStringToStringMapEntryEClass, Ljava_util_Map$Entry_2_classLit, 'EStringToStringMapEntry', false, false, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStringToStringMapEntryEClass), 0), 29), this$static.eStringEDataType, 'key', null, 0, 1, Ljava_util_Map$Entry_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.eStringToStringMapEntryEClass), 1), 29), this$static.eStringEDataType, 'value', null, 0, 1, Ljava_util_Map$Entry_2_classLit, false, false, true, false, true, false);
  $initEClass(this$static.eGenericTypeEClass, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, 'EGenericType', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eGenericTypeEClass), 0), 17), this$static.eGenericTypeEClass, null, 'eUpperBound', 0, 1, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eGenericTypeEClass), 1), 17), this$static.eGenericTypeEClass, null, 'eTypeArguments', 0, -1, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eGenericTypeEClass), 2), 17), this$static.eClassifierEClass, null, 'eRawType', 1, 1, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, true, false, false, false, true, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eGenericTypeEClass), 3), 17), this$static.eGenericTypeEClass, null, 'eLowerBound', 0, 1, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, false, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eGenericTypeEClass), 4), 17), this$static.eTypeParameterEClass, null, 'eTypeParameter', 0, 1, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, false, false, true, false, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eGenericTypeEClass), 5), 17), this$static.eClassifierEClass, null, 'eClassifier', 0, 1, Lorg_eclipse_emf_ecore_EGenericType_2_classLit, false, false, true, false, true, false, false);
  op = $initEOperation(castTo($get_16($getEOperations(this$static.eGenericTypeEClass), 0), 53), this$static.eBooleanEDataType, 'isInstance');
  $addEParameter(op, this$static.eJavaObjectEDataType, 'object');
  $initEClass(this$static.eTypeParameterEClass, Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, 'ETypeParameter', false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.eTypeParameterEClass), 0), 17), this$static.eGenericTypeEClass, null, 'eBounds', 0, -1, Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, false, false, true, true, false, false, false);
  $initEDataType(this$static.eBigDecimalEDataType, Ljava_math_BigDecimal_2_classLit, 'EBigDecimal', true);
  $initEDataType(this$static.eBigIntegerEDataType, Ljava_math_BigInteger_2_classLit, 'EBigInteger', true);
  $initEDataType(this$static.eBooleanEDataType, Z_classLit, 'EBoolean', true);
  $initEDataType(this$static.eBooleanObjectEDataType, Ljava_lang_Boolean_2_classLit, 'EBooleanObject', true);
  $initEDataType(this$static.eByteEDataType, B_classLit, 'EByte', true);
  $initEDataType(this$static.eByteArrayEDataType, getClassLiteralForArray(B_classLit, 1), 'EByteArray', true);
  $initEDataType(this$static.eByteObjectEDataType, Ljava_lang_Byte_2_classLit, 'EByteObject', true);
  $initEDataType(this$static.eCharEDataType, C_classLit, 'EChar', true);
  $initEDataType(this$static.eCharacterObjectEDataType, Ljava_lang_Character_2_classLit, 'ECharacterObject', true);
  $initEDataType(this$static.eDateEDataType, Ljava_util_Date_2_classLit, 'EDate', true);
  $initEDataType(this$static.eDiagnosticChainEDataType, Lorg_eclipse_emf_common_util_DiagnosticChain_2_classLit, 'EDiagnosticChain', false);
  $initEDataType(this$static.eDoubleEDataType, D_classLit, 'EDouble', true);
  $initEDataType(this$static.eDoubleObjectEDataType, Ljava_lang_Double_2_classLit, 'EDoubleObject', true);
  $initEDataType(this$static.eeListEDataType, Lorg_eclipse_emf_common_util_EList_2_classLit, 'EEList', false);
  $initEDataType(this$static.eEnumeratorEDataType, Lorg_eclipse_emf_common_util_Enumerator_2_classLit, 'EEnumerator', false);
  $initEDataType(this$static.eFeatureMapEDataType, Lorg_eclipse_emf_ecore_util_FeatureMap_2_classLit, 'EFeatureMap', false);
  $initEDataType(this$static.eFeatureMapEntryEDataType, Lorg_eclipse_emf_ecore_util_FeatureMap$Entry_2_classLit, 'EFeatureMapEntry', false);
  $initEDataType(this$static.eFloatEDataType, F_classLit, 'EFloat', true);
  $initEDataType(this$static.eFloatObjectEDataType, Ljava_lang_Float_2_classLit, 'EFloatObject', true);
  $initEDataType(this$static.eIntEDataType, I_classLit, 'EInt', true);
  $initEDataType(this$static.eIntegerObjectEDataType, Ljava_lang_Integer_2_classLit, 'EIntegerObject', true);
  $initEDataType(this$static.eJavaClassEDataType, Ljava_lang_Class_2_classLit, 'EJavaClass', true);
  $initEDataType(this$static.eJavaObjectEDataType, Ljava_lang_Object_2_classLit, 'EJavaObject', true);
  $initEDataType(this$static.eLongEDataType, J_classLit, 'ELong', true);
  $initEDataType(this$static.eLongObjectEDataType, Ljava_lang_Long_2_classLit, 'ELongObject', true);
  $initEDataType(this$static.eMapEDataType, Ljava_util_Map_2_classLit, 'EMap', false);
  $initEDataType(this$static.eResourceEDataType, Lorg_eclipse_emf_ecore_resource_Resource_2_classLit, 'EResource', false);
  $initEDataType(this$static.eResourceSetEDataType, Lorg_eclipse_emf_ecore_resource_ResourceSet_2_classLit, 'EResourceSet', false);
  $initEDataType(this$static.eShortEDataType, S_classLit, 'EShort', true);
  $initEDataType(this$static.eShortObjectEDataType, Ljava_lang_Short_2_classLit, 'EShortObject', true);
  $initEDataType(this$static.eStringEDataType, Ljava_lang_String_2_classLit, 'EString', true);
  $initEDataType(this$static.eTreeIteratorEDataType, Lorg_eclipse_emf_common_util_TreeIterator_2_classLit, 'ETreeIterator', false);
  $initEDataType(this$static.eInvocationTargetExceptionEDataType, Lorg_eclipse_emf_common_util_InvocationTargetException_2_classLit, 'EInvocationTargetException', false);
  $createResource(this$static, 'http://www.eclipse.org/emf/2002/Ecore');
}

function EcorePackageImpl(){
  EPackageImpl_0.call(this, 'http://www.eclipse.org/emf/2002/Ecore', ($clinit_EcoreFactory() , eINSTANCE_1));
  $$init_13(this);
}

function init_4(){
  $clinit_EcorePackageImpl();
  var theEcorePackage;
  if (isInited_0)
    return castTo($getEPackage_0(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/emf/2002/Ecore'), 1718);
  register_0(Ljava_util_Map$Entry_2_classLit, new EcorePackageImpl$44);
  initializeRegistryHelpersGen();
  theEcorePackage = castTo(instanceOf($getStringValue(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/emf/2002/Ecore'), 519)?$getStringValue(INSTANCE_6, 'http://www.eclipse.org/emf/2002/Ecore'):new EcorePackageImpl, 519);
  isInited_0 = true;
  $createPackageContents_0(theEcorePackage);
  $initializePackageContents_0(theEcorePackage);
  $put_1(($clinit_EValidator$Registry() , INSTANCE_8), theEcorePackage, new EcorePackageImpl$1);
  $putStringValue(INSTANCE_6, 'http://www.eclipse.org/emf/2002/Ecore', theEcorePackage);
  return theEcorePackage;
}

function initializeRegistryHelpersGen(){
  register_0(Lorg_eclipse_emf_ecore_EAttribute_2_classLit, new EcorePackageImpl$2);
  register_0(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, new EcorePackageImpl$3);
  register_0(Lorg_eclipse_emf_ecore_EClass_2_classLit, new EcorePackageImpl$4);
  register_0(Lorg_eclipse_emf_ecore_EClassifier_2_classLit, new EcorePackageImpl$5);
  register_0(Lorg_eclipse_emf_ecore_EDataType_2_classLit, new EcorePackageImpl$6);
  register_0(Lorg_eclipse_emf_ecore_EEnum_2_classLit, new EcorePackageImpl$7);
  register_0(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, new EcorePackageImpl$8);
  register_0(Lorg_eclipse_emf_ecore_EFactory_2_classLit, new EcorePackageImpl$9);
  register_0(Lorg_eclipse_emf_ecore_EModelElement_2_classLit, new EcorePackageImpl$10);
  register_0(Lorg_eclipse_emf_ecore_ENamedElement_2_classLit, new EcorePackageImpl$11);
  register_0(Lorg_eclipse_emf_ecore_EObject_2_classLit, new EcorePackageImpl$12);
  register_0(Lorg_eclipse_emf_ecore_EOperation_2_classLit, new EcorePackageImpl$13);
  register_0(Lorg_eclipse_emf_ecore_EPackage_2_classLit, new EcorePackageImpl$14);
  register_0(Lorg_eclipse_emf_ecore_EParameter_2_classLit, new EcorePackageImpl$15);
  register_0(Lorg_eclipse_emf_ecore_EReference_2_classLit, new EcorePackageImpl$16);
  register_0(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, new EcorePackageImpl$17);
  register_0(Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, new EcorePackageImpl$18);
  register_0(Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, new EcorePackageImpl$19);
  register_0(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, new EcorePackageImpl$20);
  register_0(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, new EcorePackageImpl$21);
  register_0(Ljava_lang_Boolean_2_classLit, new EcorePackageImpl$22);
  register_0(getClassLiteralForArray(B_classLit, 1), new EcorePackageImpl$23);
  register_0(Ljava_lang_Byte_2_classLit, new EcorePackageImpl$24);
  register_0(Ljava_lang_Character_2_classLit, new EcorePackageImpl$25);
  register_0(Ljava_util_Date_2_classLit, new EcorePackageImpl$26);
  register_0(Lorg_eclipse_emf_common_util_DiagnosticChain_2_classLit, new EcorePackageImpl$27);
  register_0(Ljava_lang_Double_2_classLit, new EcorePackageImpl$28);
  register_0(Lorg_eclipse_emf_common_util_EList_2_classLit, new EcorePackageImpl$29);
  register_0(Lorg_eclipse_emf_common_util_Enumerator_2_classLit, new EcorePackageImpl$30);
  register_0(Lorg_eclipse_emf_ecore_util_FeatureMap_2_classLit, new EcorePackageImpl$31);
  register_0(Lorg_eclipse_emf_ecore_util_FeatureMap$Entry_2_classLit, new EcorePackageImpl$32);
  register_0(Ljava_lang_Float_2_classLit, new EcorePackageImpl$33);
  register_0(Ljava_lang_Integer_2_classLit, new EcorePackageImpl$34);
  register_0(Ljava_lang_Class_2_classLit, new EcorePackageImpl$35);
  register_0(Ljava_lang_Long_2_classLit, new EcorePackageImpl$36);
  register_0(Ljava_util_Map_2_classLit, new EcorePackageImpl$37);
  register_0(Lorg_eclipse_emf_ecore_resource_Resource_2_classLit, new EcorePackageImpl$38);
  register_0(Lorg_eclipse_emf_ecore_resource_ResourceSet_2_classLit, new EcorePackageImpl$39);
  register_0(Ljava_lang_Short_2_classLit, new EcorePackageImpl$40);
  register_0(Ljava_lang_String_2_classLit, new EcorePackageImpl$41);
  register_0(Lorg_eclipse_emf_common_util_TreeIterator_2_classLit, new EcorePackageImpl$42);
  register_0(Lorg_eclipse_emf_common_util_InvocationTargetException_2_classLit, new EcorePackageImpl$43);
}

function internalBootstrap(){
  $clinit_EcorePackageImpl();
  var eGenericType, eGenericType$iterator;
  $createExtendedMetaDataAnnotations(($clinit_EcorePackage() , eINSTANCE_2));
  $createEcoreAnnotations(eINSTANCE_2);
  $freeze_0(eINSTANCE_2);
  eJavaObject = ($clinit_EcorePackage$Literals() , EJAVA_OBJECT);
  for (eGenericType$iterator = new ArrayList$1(eGenericTypes_0); eGenericType$iterator.i < eGenericType$iterator.this$01.array.length;) {
    eGenericType = castTo($next_10(eGenericType$iterator), 223);
    $setERawType(eGenericType, EJAVA_OBJECT, null);
  }
  return true;
}

defineClass(519, 255, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 214:1, 106:1, 1718:1, 46:1, 93:1, 145:1, 255:1, 519:1, 109:1, 110:1, 632:1}, EcorePackageImpl);
_.isCreated = false;
_.isInitialized = false;
var eGenericTypes_0, isInited_0 = false;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl', 519);
function EcorePackageImpl$1(){
}

defineClass(1085, 1, {773:1}, EcorePackageImpl$1);
_.getEValidator = function getEValidator(){
  return $clinit_EcoreValidator() , INSTANCE_10;
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/1', 1085);
function EcorePackageImpl$10(){
}

defineClass(1094, 1, $intern_164, EcorePackageImpl$10);
_.isInstance = function isInstance_6(instance){
  return instanceOf(instance, 143);
}
;
_.newArrayInstance = function newArrayInstance(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EModelElement_2_classLit, $intern_1, 143, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$10_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/10', 1094);
function EcorePackageImpl$11(){
}

defineClass(1095, 1, $intern_164, EcorePackageImpl$11);
_.isInstance = function isInstance_7(instance){
  return instanceOf(instance, 179);
}
;
_.newArrayInstance = function newArrayInstance_0(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_ENamedElement_2_classLit, $intern_1, 179, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$11_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/11', 1095);
function EcorePackageImpl$12(){
}

defineClass(1096, 1, $intern_164, EcorePackageImpl$12);
_.isInstance = function isInstance_8(instance){
  return instanceOf(instance, 51);
}
;
_.newArrayInstance = function newArrayInstance_1(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EObject_2_classLit, $intern_1, 51, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$12_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/12', 1096);
function EcorePackageImpl$13(){
}

defineClass(1097, 1, $intern_164, EcorePackageImpl$13);
_.isInstance = function isInstance_9(instance){
  return instanceOf(instance, 385);
}
;
_.newArrayInstance = function newArrayInstance_2(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EOperation_2_classLit, $intern_154, 53, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$13_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/13', 1097);
function EcorePackageImpl$14(){
}

defineClass(1098, 1, $intern_164, EcorePackageImpl$14);
_.isInstance = function isInstance_10(instance){
  return instanceOf(instance, 214);
}
;
_.newArrayInstance = function newArrayInstance_3(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EPackage_2_classLit, $intern_1, 214, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$14_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/14', 1098);
function EcorePackageImpl$15(){
}

defineClass(1099, 1, $intern_164, EcorePackageImpl$15);
_.isInstance = function isInstance_11(instance){
  return instanceOf(instance, 482);
}
;
_.newArrayInstance = function newArrayInstance_4(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EParameter_2_classLit, $intern_1, 1784, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$15_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/15', 1099);
function EcorePackageImpl$16(){
}

defineClass(1100, 1, $intern_164, EcorePackageImpl$16);
_.isInstance = function isInstance_12(instance){
  return instanceOf(instance, 66);
}
;
_.newArrayInstance = function newArrayInstance_5(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EReference_2_classLit, $intern_153, 17, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$16_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/16', 1100);
function EcorePackageImpl$17(){
}

defineClass(1101, 1, $intern_164, EcorePackageImpl$17);
_.isInstance = function isInstance_13(instance){
  return instanceOf(instance, 159);
}
;
_.newArrayInstance = function newArrayInstance_6(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, $intern_153, 159, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$17_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/17', 1101);
function EcorePackageImpl$18(){
}

defineClass(1102, 1, $intern_164, EcorePackageImpl$18);
_.isInstance = function isInstance_14(instance){
  return instanceOf(instance, 446);
}
;
_.newArrayInstance = function newArrayInstance_7(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_ETypedElement_2_classLit, $intern_1, 446, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$18_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/18', 1102);
function EcorePackageImpl$19(){
}

defineClass(1103, 1, $intern_164, EcorePackageImpl$19);
_.isInstance = function isInstance_15(instance){
  return instanceOf(instance, 520);
}
;
_.newArrayInstance = function newArrayInstance_8(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, $intern_149, 520, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$19_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/19', 1103);
function EcorePackageImpl$2(){
}

defineClass(1086, 1, $intern_164, EcorePackageImpl$2);
_.isInstance = function isInstance_16(instance){
  return instanceOf(instance, 348);
}
;
_.newArrayInstance = function newArrayInstance_9(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EAttribute_2_classLit, $intern_153, 29, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$2_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/2', 1086);
function EcorePackageImpl$20(){
}

defineClass(1104, 1, $intern_164, EcorePackageImpl$20);
_.isInstance = function isInstance_17(instance){
  return instanceOf(instance, 223);
}
;
_.newArrayInstance = function newArrayInstance_10(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EGenericType_2_classLit, $intern_157, 86, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$20_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/20', 1104);
function EcorePackageImpl$21(){
}

defineClass(1105, 1, $intern_164, EcorePackageImpl$21);
_.isInstance = function isInstance_18(instance){
  return instanceOf(instance, 423);
}
;
_.newArrayInstance = function newArrayInstance_11(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_ETypeParameter_2_classLit, $intern_1, 772, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$21_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/21', 1105);
function EcorePackageImpl$22(){
}

defineClass(1106, 1, $intern_164, EcorePackageImpl$22);
_.isInstance = function isInstance_19(instance){
  return instanceOfBoolean(instance);
}
;
_.newArrayInstance = function newArrayInstance_12(size_0){
  return initUnidimensionalArray(Ljava_lang_Boolean_2_classLit, $intern_33, 449, size_0, 8, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$22_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/22', 1106);
function EcorePackageImpl$23(){
}

defineClass(1107, 1, $intern_164, EcorePackageImpl$23);
_.isInstance = function isInstance_20(instance){
  return instanceOf(instance, 178);
}
;
_.newArrayInstance = function newArrayInstance_13(size_0){
  return initUnidimensionalArray(B_classLit, $intern_33, 178, size_0, 0, 2);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$23_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/23', 1107);
function EcorePackageImpl$24(){
}

defineClass(1108, 1, $intern_164, EcorePackageImpl$24);
_.isInstance = function isInstance_21(instance){
  return instanceOf(instance, 196);
}
;
_.newArrayInstance = function newArrayInstance_14(size_0){
  return initUnidimensionalArray(Ljava_lang_Byte_2_classLit, $intern_33, 196, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$24_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/24', 1108);
function EcorePackageImpl$25(){
}

defineClass(1109, 1, $intern_164, EcorePackageImpl$25);
_.isInstance = function isInstance_22(instance){
  return instanceOf(instance, 161);
}
;
_.newArrayInstance = function newArrayInstance_15(size_0){
  return initUnidimensionalArray(Ljava_lang_Character_2_classLit, $intern_33, 161, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$25_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/25', 1109);
function EcorePackageImpl$26(){
}

defineClass(1110, 1, $intern_164, EcorePackageImpl$26);
_.isInstance = function isInstance_23(instance){
  return instanceOf(instance, 185);
}
;
_.newArrayInstance = function newArrayInstance_16(size_0){
  return initUnidimensionalArray(Ljava_util_Date_2_classLit, $intern_33, 185, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$26_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/26', 1110);
function EcorePackageImpl$27(){
}

defineClass(1111, 1, $intern_164, EcorePackageImpl$27);
_.isInstance = function isInstance_24(instance){
  return false;
}
;
_.newArrayInstance = function newArrayInstance_17(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_common_util_DiagnosticChain_2_classLit, $intern_1, 1873, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$27_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/27', 1111);
function EcorePackageImpl$28(){
}

defineClass(1112, 1, $intern_164, EcorePackageImpl$28);
_.isInstance = function isInstance_25(instance){
  return instanceOfDouble(instance);
}
;
_.newArrayInstance = function newArrayInstance_18(size_0){
  return initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_33, 323, size_0, 7, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$28_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/28', 1112);
function EcorePackageImpl$29(){
}

defineClass(1113, 1, $intern_164, EcorePackageImpl$29);
_.isInstance = function isInstance_26(instance){
  return instanceOf(instance, 52);
}
;
_.newArrayInstance = function newArrayInstance_19(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_common_util_EList_2_classLit, $intern_102, 52, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$29_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/29', 1113);
function EcorePackageImpl$3(){
}

defineClass(1087, 1, $intern_164, EcorePackageImpl$3);
_.isInstance = function isInstance_27(instance){
  return instanceOf(instance, 483);
}
;
_.newArrayInstance = function newArrayInstance_20(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EAnnotation_2_classLit, {3:1, 4:1, 5:1, 1713:1}, 628, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$3_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/3', 1087);
function EcorePackageImpl$30(){
}

defineClass(1114, 1, $intern_164, EcorePackageImpl$30);
_.isInstance = function isInstance_28(instance){
  return instanceOf(instance, 541);
}
;
_.newArrayInstance = function newArrayInstance_21(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_common_util_Enumerator_2_classLit, $intern_1, 1719, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$30_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/30', 1114);
function EcorePackageImpl$31(){
}

defineClass(1115, 1, $intern_164, EcorePackageImpl$31);
_.isInstance = function isInstance_29(instance){
  return instanceOf(instance, 188);
}
;
_.newArrayInstance = function newArrayInstance_22(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_util_FeatureMap_2_classLit, $intern_102, 188, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$31_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/31', 1115);
function EcorePackageImpl$32(){
}

defineClass(1116, 1, $intern_164, EcorePackageImpl$32);
_.isInstance = function isInstance_30(instance){
  return instanceOf(instance, 76);
}
;
_.newArrayInstance = function newArrayInstance_23(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_util_FeatureMap$Entry_2_classLit, $intern_165, 76, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$32_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/32', 1116);
function EcorePackageImpl$33(){
}

defineClass(1117, 1, $intern_164, EcorePackageImpl$33);
_.isInstance = function isInstance_31(instance){
  return instanceOf(instance, 128);
}
;
_.newArrayInstance = function newArrayInstance_24(size_0){
  return initUnidimensionalArray(Ljava_lang_Float_2_classLit, $intern_33, 128, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$33_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/33', 1117);
function EcorePackageImpl$34(){
}

defineClass(1118, 1, $intern_164, EcorePackageImpl$34);
_.isInstance = function isInstance_32(instance){
  return instanceOf(instance, 21);
}
;
_.newArrayInstance = function newArrayInstance_25(size_0){
  return initUnidimensionalArray(Ljava_lang_Integer_2_classLit, $intern_33, 21, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$34_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/34', 1118);
function EcorePackageImpl$35(){
}

defineClass(1119, 1, $intern_164, EcorePackageImpl$35);
_.isInstance = function isInstance_33(instance){
  return instanceOf(instance, 283);
}
;
_.newArrayInstance = function newArrayInstance_26(size_0){
  return initUnidimensionalArray(Ljava_lang_Class_2_classLit, $intern_1, 283, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$35_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/35', 1119);
function EcorePackageImpl$36(){
}

defineClass(1120, 1, $intern_164, EcorePackageImpl$36);
_.isInstance = function isInstance_34(instance){
  return instanceOf(instance, 152);
}
;
_.newArrayInstance = function newArrayInstance_27(size_0){
  return initUnidimensionalArray(Ljava_lang_Long_2_classLit, $intern_33, 152, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$36_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/36', 1120);
function EcorePackageImpl$37(){
}

defineClass(1121, 1, $intern_164, EcorePackageImpl$37);
_.isInstance = function isInstance_35(instance){
  return instanceOf(instance, 111);
}
;
_.newArrayInstance = function newArrayInstance_28(size_0){
  return initUnidimensionalArray(Ljava_util_Map_2_classLit, $intern_1, 111, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$37_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/37', 1121);
function EcorePackageImpl$38(){
}

defineClass(1122, 1, $intern_164, EcorePackageImpl$38);
_.isInstance = function isInstance_36(instance){
  return instanceOf(instance, 559);
}
;
_.newArrayInstance = function newArrayInstance_29(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_resource_Resource_2_classLit, $intern_1, 559, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$38_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/38', 1122);
function EcorePackageImpl$39(){
}

defineClass(1123, 1, $intern_164, EcorePackageImpl$39);
_.isInstance = function isInstance_37(instance){
  return false;
}
;
_.newArrayInstance = function newArrayInstance_30(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_resource_ResourceSet_2_classLit, $intern_1, 1874, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$39_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/39', 1123);
function EcorePackageImpl$4(){
}

defineClass(1088, 1, $intern_164, EcorePackageImpl$4);
_.isInstance = function isInstance_38(instance){
  return instanceOf(instance, 99);
}
;
_.newArrayInstance = function newArrayInstance_31(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EClass_2_classLit, $intern_1, 26, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$4_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/4', 1088);
function EcorePackageImpl$40(){
}

defineClass(1124, 1, $intern_164, EcorePackageImpl$40);
_.isInstance = function isInstance_39(instance){
  return instanceOf(instance, 171);
}
;
_.newArrayInstance = function newArrayInstance_32(size_0){
  return initUnidimensionalArray(Ljava_lang_Short_2_classLit, $intern_33, 171, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$40_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/40', 1124);
function EcorePackageImpl$41(){
}

defineClass(1125, 1, $intern_164, EcorePackageImpl$41);
_.isInstance = function isInstance_40(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_33(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$41_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/41', 1125);
function EcorePackageImpl$42(){
}

defineClass(1126, 1, $intern_164, EcorePackageImpl$42);
_.isInstance = function isInstance_41(instance){
  return instanceOf(instance, 557);
}
;
_.newArrayInstance = function newArrayInstance_34(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_common_util_TreeIterator_2_classLit, $intern_1, 557, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$42_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/42', 1126);
function EcorePackageImpl$43(){
}

defineClass(1127, 1, $intern_164, EcorePackageImpl$43);
_.isInstance = function isInstance_42(instance){
  return false;
}
;
_.newArrayInstance = function newArrayInstance_35(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_common_util_InvocationTargetException_2_classLit, $intern_33, 1875, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$43_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/43', 1127);
function EcorePackageImpl$44(){
}

defineClass(1128, 1, $intern_164, EcorePackageImpl$44);
_.isInstance = function isInstance_43(instance){
  return instanceOf(instance, 39);
}
;
_.newArrayInstance = function newArrayInstance_36(size_0){
  return initUnidimensionalArray(Ljava_util_Map$Entry_2_classLit, $intern_1, 39, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$44_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/44', 1128);
function EcorePackageImpl$5(){
}

defineClass(1089, 1, $intern_164, EcorePackageImpl$5);
_.isInstance = function isInstance_44(instance){
  return instanceOf(instance, 136);
}
;
_.newArrayInstance = function newArrayInstance_37(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EClassifier_2_classLit, $intern_1, 136, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$5_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/5', 1089);
function EcorePackageImpl$6(){
}

defineClass(1090, 1, $intern_164, EcorePackageImpl$6);
_.isInstance = function isInstance_45(instance){
  return instanceOf(instance, 144);
}
;
_.newArrayInstance = function newArrayInstance_38(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EDataType_2_classLit, $intern_1, 144, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$6_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/6', 1090);
function EcorePackageImpl$7(){
}

defineClass(1091, 1, $intern_164, EcorePackageImpl$7);
_.isInstance = function isInstance_46(instance){
  return instanceOf(instance, 436);
}
;
_.newArrayInstance = function newArrayInstance_39(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EEnum_2_classLit, $intern_1, 627, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$7_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/7', 1091);
function EcorePackageImpl$8(){
}

defineClass(1092, 1, $intern_164, EcorePackageImpl$8);
_.isInstance = function isInstance_47(instance){
  return instanceOf(instance, 541);
}
;
_.newArrayInstance = function newArrayInstance_40(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EEnumLiteral_2_classLit, $intern_1, 636, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$8_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/8', 1092);
function EcorePackageImpl$9(){
}

defineClass(1093, 1, $intern_164, EcorePackageImpl$9);
_.isInstance = function isInstance_48(instance){
  return instanceOf(instance, 445);
}
;
_.newArrayInstance = function newArrayInstance_41(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EFactory_2_classLit, $intern_1, 445, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_impl_EcorePackageImpl$9_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'EcorePackageImpl/9', 1093);
function $didAdd_1(this$static, newAdapter){
  var listener$index, listener$max, listeners;
  newAdapter.setTarget(this$static.this$01);
  listeners = castTo($getField(this$static.this$01, 8), 1715);
  if (listeners != null) {
    for (listener$index = 0 , listener$max = listeners.length; listener$index < listener$max; ++listener$index) {
      null.$_nullMethod();
    }
  }
}

function $didRemove_0(this$static, index_0, oldAdapter){
  var listener$index, listener$max, listeners, notification;
  listeners = castTo($getField(this$static.this$01, 8), 1715);
  if (listeners != null) {
    for (listener$index = 0 , listener$max = listeners.length; listener$index < listener$max; ++listener$index) {
      null.$_nullMethod();
    }
  }
  if ((this$static.this$01.eFlags_0 & 1) == 0) {
    notification = new MinimalEObjectImpl$1ArrayDelegatingAdapterList$1(this$static, oldAdapter, index_0);
    oldAdapter.notifyChanged(notification);
  }
  instanceOf(oldAdapter, 629)?castTo(oldAdapter, 629).unsetTarget(this$static.this$01):oldAdapter.getTarget() == this$static.this$01 && oldAdapter.setTarget(null);
}

function $setData(this$static, data_0){
  var eContainerAdapterArray, eInternalContainer;
  ++this$static.modCount;
  if (data_0 != null) {
    eContainerAdapterArray = (eInternalContainer = this$static.this$01.eContainer , instanceOf(eInternalContainer, 93)?castTo(eInternalContainer, 93).eBasicAdapterArray():null);
    if (equals_47(data_0, eContainerAdapterArray)) {
      $setField(this$static.this$01, 4, eContainerAdapterArray);
      return;
    }
  }
  $setField(this$static.this$01, 4, castTo(data_0, 119));
}

function MinimalEObjectImpl$1ArrayDelegatingAdapterList(this$0){
  $clinit_ArrayDelegatingEList();
  this.this$01 = this$0;
}

defineClass(953, 1757, $intern_147, MinimalEObjectImpl$1ArrayDelegatingAdapterList);
_.didAdd = function didAdd_2(index_0, newAdapter){
  $didAdd_1(this, castTo(newAdapter, 393));
}
;
_.didRemove = function didRemove_1(index_0, oldAdapter){
  $didRemove_0(this, index_0, castTo(oldAdapter, 393));
}
;
var Lorg_eclipse_emf_ecore_impl_MinimalEObjectImpl$1ArrayDelegatingAdapterList_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'MinimalEObjectImpl/1ArrayDelegatingAdapterList', 953);
function MinimalEObjectImpl$1ArrayDelegatingAdapterList$1(this$1, $anonymous1, $anonymous3){
  this.this$11 = this$1;
  NotificationImpl_1.call(this, 8, $anonymous1, null, $anonymous3);
}

defineClass(954, 142, $intern_145, MinimalEObjectImpl$1ArrayDelegatingAdapterList$1);
_.getNotifier = function getNotifier_7(){
  return this.this$11.this$01;
}
;
var Lorg_eclipse_emf_ecore_impl_MinimalEObjectImpl$1ArrayDelegatingAdapterList$1_2_classLit = createForClass('org.eclipse.emf.ecore.impl', 'MinimalEObjectImpl/1ArrayDelegatingAdapterList/1', 954);
function $clinit_EcorePlugin(){
  $clinit_EcorePlugin = emptyMethod;
  new EcorePlugin;
  new ArrayList;
}

function EcorePlugin(){
  new HashMap;
  new HashMap;
  new HashMap;
}

defineClass(993, 992, {}, EcorePlugin);
var Lorg_eclipse_emf_ecore_plugin_EcorePlugin_2_classLit = createForClass('org.eclipse.emf.ecore.plugin', 'EcorePlugin', 993);
var Lorg_eclipse_emf_ecore_resource_Resource_2_classLit = createForInterface('org.eclipse.emf.ecore.resource', 'Resource');
function $getEObject(this$static, uriFragmentPath){
  var eObject, i, size_0;
  size_0 = uriFragmentPath.array.length;
  eObject = $getEObjectForURIFragmentRootSegment(this$static, size_0 == 0?'':(checkCriticalElementIndex(0, uriFragmentPath.array.length) , castToString(uriFragmentPath.array[0])));
  for (i = 1; i < size_0 && !!eObject; ++i) {
    eObject = castTo(eObject, 46).eObjectForURIFragmentSegment((checkCriticalElementIndex(i, uriFragmentPath.array.length) , castToString(uriFragmentPath.array[i])));
  }
  return eObject;
}

function $getEObjectByID(this$static, id_0){
  var eObject, eObjectId, i, result, eClass, eIDAttribute;
  result = null;
  for (i = new ResourceImpl$5((!this$static.contents && (this$static.contents = new ResourceImpl$ContentsEList(this$static)) , this$static.contents)); $hasNext_6(i);) {
    eObject = castTo($next_16(i), 51);
    eObjectId = (eClass = eObject.eClass_0() , eIDAttribute = ($getEAllAttributes(eClass) , eClass.eIDAttribute) , !eIDAttribute || !eObject.eIsSet_0(eIDAttribute)?null:convertToString_2($getEAttributeType(eIDAttribute), eObject.eGet_0(eIDAttribute)));
    if (eObjectId != null) {
      if ($equals_4(eObjectId, id_0)) {
        result = eObject;
        break;
      }
    }
  }
  return result;
}

function $getEObjectForURIFragmentRootSegment(this$static, uriFragmentRootSegment){
  var contents, exception, position;
  position = 0;
  if (uriFragmentRootSegment.length > 0) {
    try {
      position = __parseAndValidateInt(uriFragmentRootSegment, $intern_43, $intern_0);
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (instanceOf($e0, 120)) {
        exception = $e0;
        throw toJs(new WrappedException(exception));
      }
       else 
        throw toJs($e0);
    }
  }
  contents = (!this$static.contents && (this$static.contents = new ResourceImpl$ContentsEList(this$static)) , this$static.contents);
  return position < contents.size_0 && position >= 0?castTo($get_16(contents, position), 51):null;
}

defineClass(728, 1335, $intern_166);
_.attached = function attached(eObject){
}
;
_.detached = function detached(eObject){
}
;
_.getContents = function getContents(){
  return !this.contents && (this.contents = new ResourceImpl$ContentsEList(this)) , this.contents;
}
;
_.getEObject = function getEObject(uriFragment){
  var i, index_0, length_0, start_0, uriFragmentPath;
  length_0 = uriFragment.length;
  if (length_0 > 0) {
    if (uriFragment.charCodeAt(0) == 47) {
      uriFragmentPath = new ArrayList_0(4);
      start_0 = 1;
      for (i = 1; i < length_0; ++i) {
        if (uriFragment.charCodeAt(i) == 47) {
          $add_4(uriFragmentPath, start_0 == i?'':uriFragment.substr(start_0, i - start_0));
          start_0 = i + 1;
        }
      }
      $add_4(uriFragmentPath, uriFragment.substr(start_0, uriFragment.length - start_0));
      return $getEObject(this, uriFragmentPath);
    }
     else if (uriFragment.charCodeAt(length_0 - 1) == 63) {
      index_0 = $lastIndexOf_0(uriFragment, fromCodePoint(63), length_0 - 2);
      index_0 > 0 && (uriFragment = uriFragment.substr(0, index_0));
    }
  }
  return $getEObjectByID(this, uriFragment);
}
;
_.getResourceSet = function getResourceSet(){
  return this.resourceSet;
}
;
_.toString_0 = function toString_155(){
  return $getName(this.___clazz) + '@' + (hashCode__I__devirtual$(this) >>> 0).toString(16) + " uri='" + this.uri_0 + "'";
}
;
_.isLoaded = false;
var Lorg_eclipse_emf_ecore_resource_impl_ResourceImpl_2_classLit = createForClass('org.eclipse.emf.ecore.resource.impl', 'ResourceImpl', 728);
function BinaryResourceImpl(uri_0){
  this.uri_0 = uri_0;
}

defineClass(1336, 728, $intern_166, BinaryResourceImpl);
var Lorg_eclipse_emf_ecore_resource_impl_BinaryResourceImpl_2_classLit = createForClass('org.eclipse.emf.ecore.resource.impl', 'BinaryResourceImpl', 1336);
function $getEObjectChildren(this$static, eObject){
  return this$static.isResolveProxies?eObject.eContents_0().iterator_0():castTo(eObject.eContents_0(), 69).basicIterator();
}

function $hasNext_6(this$static){
  var iterator;
  if (!this$static.includeRoot && this$static.data_0 == null) {
    this$static.nextPruneIterator = this$static.getChildren(this$static.object);
    $add_21(this$static, this$static.nextPruneIterator);
    iterator = this$static.nextPruneIterator;
  }
   else {
    if (this$static.data_0 == null) {
      return true;
    }
     else if (this$static.size_0 == 0) {
      return false;
    }
     else {
      iterator = castTo(this$static.data_0[this$static.size_0 - 1], 47);
    }
  }
  if (iterator == this$static.resourceSetIterator && null.$_nullField >= null.$_nullMethod()) {
    $next_16(this$static);
    return $hasNext_6(this$static);
  }
   else {
    return iterator.hasNext_0();
  }
}

defineClass(1026, 651, $intern_142);
_.getChildren = function getChildren_0(object){
  return instanceOf(object, 51)?$getEObjectChildren(this, castTo(object, 51)):instanceOf(object, 559)?new AbstractEList$EIterator(castTo(object, 559).getContents()):maskUndefined(object) === maskUndefined(this.object)?castTo(object, 13).iterator_0():($clinit_ECollections() , EMPTY_ELIST.listIterator);
}
;
_.hasNext_0 = function hasNext_48(){
  return $hasNext_6(this);
}
;
_.isResolveProxies = false;
var Lorg_eclipse_emf_ecore_util_EcoreUtil$ContentTreeIterator_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreUtil/ContentTreeIterator', 1026);
function ResourceImpl$5($anonymous0){
  AbstractTreeIterator.call(this, $anonymous0, false);
  this.isResolveProxies = false;
}

defineClass(1337, 1026, $intern_142, ResourceImpl$5);
_.getChildren = function getChildren_1(object){
  return maskUndefined(object) === maskUndefined(this.object)?castTo(object, 15).iterator_0():new EcoreUtil$ProperContentIterator(castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_resource_impl_ResourceImpl$5_2_classLit = createForClass('org.eclipse.emf.ecore.resource.impl', 'ResourceImpl/5', 1337);
function ResourceImpl$ContentsEList(this$0){
  this.this$01 = this$0;
}

defineClass(609, 1771, $intern_155, ResourceImpl$ContentsEList);
_.contains = function contains_60(object){
  return this.size_0 <= 4?$contains_10(this, object):instanceOf(object, 46) && castTo(object, 46).eDirectResource() == this.this$01;
}
;
_.didAdd = function didAdd_3(index_0, object){
  index_0 == this.size_0 - 1 && (this.this$01.isLoaded || (this.this$01.isLoaded = true , null));
}
;
_.didClear = function didClear_1(oldSize, oldData){
  oldSize == 0?this.this$01.isLoaded || (this.this$01.isLoaded = true , null):$didClear(this, oldSize, oldData);
}
;
_.didRemove = function didRemove_2(index_0, object){
}
;
_.didSet = function didSet_1(index_0, newObject, oldObject){
}
;
_.getFeatureID_0 = function getFeatureID_12(){
  return 2;
}
;
_.getNotifier = function getNotifier_8(){
  return this.this$01;
}
;
_.hasInverse = function hasInverse_10(){
  return true;
}
;
_.inverseAdd = function inverseAdd_8(object, notifications){
  var eObject;
  eObject = castTo(object, 46);
  notifications = eObject.eSetResource(this.this$01, notifications);
  return notifications;
}
;
_.inverseRemove = function inverseRemove_8(object, notifications){
  var eObject;
  eObject = castTo(object, 46);
  return eObject.eSetResource(null, notifications);
}
;
_.isNotificationRequired = function isNotificationRequired_3(){
  return false;
}
;
_.isUnique = function isUnique_7(){
  return true;
}
;
_.newData = function newData_13(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_EObject_2_classLit, $intern_1, 51, capacity, 0, 1);
}
;
_.useEquals = function useEquals_14(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_resource_impl_ResourceImpl$ContentsEList_2_classLit = createForClass('org.eclipse.emf.ecore.resource.impl', 'ResourceImpl/ContentsEList', 609);
function AbstractSequentialInternalEList$1(this$0){
  this.this$01 = this$0;
}

defineClass(906, 1741, $intern_36, AbstractSequentialInternalEList$1);
_.listIterator_1 = function listIterator_30(index_0){
  return this.this$01.basicListIterator_0(index_0);
}
;
_.size_1 = function size_70(){
  return this.this$01.size_1();
}
;
var Lorg_eclipse_emf_ecore_util_AbstractSequentialInternalEList$1_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'AbstractSequentialInternalEList/1', 906);
function $clinit_ExtendedMetaData(){
  $clinit_ExtendedMetaData = emptyMethod;
  FEATURE_KINDS = stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['unspecified', 'simple', 'attribute', 'attributeWildcard', 'element', 'elementWildcard', 'group']);
  CONTENT_KINDS = stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['unspecified', 'empty', 'simple', 'mixed', 'elementOnly']);
  WHITE_SPACE_KINDS = stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['unspecified', 'preserve', 'replace', 'collapse']);
  INSTANCE_11 = new BasicExtendedMetaData;
}

var CONTENT_KINDS, FEATURE_KINDS, INSTANCE_11, WHITE_SPACE_KINDS;
function $clinit_BasicExtendedMetaData(){
  $clinit_BasicExtendedMetaData = emptyMethod;
  var eAttribute, eDataType;
  UNINITIALIZED_EDATA_TYPE = ($clinit_EcoreFactory() , eDataType = new EDataTypeImpl , eDataType);
  UNINITIALIZED_ESTRUCTURAL_FEATURE = (eAttribute = new EAttributeImpl , eAttribute);
}

function $basicGetAffiliation(this$static, eStructuralFeature){
  var eAnnotation, fragmentIndex, qualifiedName;
  eAnnotation = eStructuralFeature.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    qualifiedName = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'affiliation'));
    if (qualifiedName != null) {
      fragmentIndex = $lastIndexOf(qualifiedName, fromCodePoint(35));
      return fragmentIndex == -1?$getElement(this$static, $getNamespace(this$static, $getEPackage(eStructuralFeature.getEContainingClass())), qualifiedName):fragmentIndex == 0?$getElement(this$static, null, qualifiedName.substr(1, qualifiedName.length - 1)):$getElement(this$static, qualifiedName.substr(0, fragmentIndex), qualifiedName.substr(fragmentIndex + 1, qualifiedName.length - (fragmentIndex + 1)));
    }
  }
  return null;
}

function $basicGetBaseType(this$static, eDataType){
  var baseType, details, eAnnotation, index_0, type_0;
  eAnnotation = eDataType.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    details = (!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details);
    baseType = castToString($get_17(details, 'baseType'));
    if (baseType != null) {
      index_0 = baseType.lastIndexOf('#');
      type_0 = index_0 == -1?$getType_0(this$static, eDataType.getEPackage(), baseType):index_0 == 0?$getType(this$static, null, baseType.substr(1, baseType.length - 1)):$getType(this$static, baseType.substr(0, index_0), baseType.substr(index_0 + 1, baseType.length - (index_0 + 1)));
      if (instanceOf(type_0, 144)) {
        return castTo(type_0, 144);
      }
    }
  }
  return null;
}

function $basicGetContentKind(this$static, eClass){
  var eAnnotation, i, kind;
  eAnnotation = eClass.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    kind = $get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'kind');
    if (kind != null) {
      for (i = 1; i < ($clinit_ExtendedMetaData() , CONTENT_KINDS).length; ++i) {
        if ($equals_4(CONTENT_KINDS[i], kind)) {
          return i;
        }
      }
    }
  }
  return 0;
}

function $basicGetFeatureKind(this$static, eStructuralFeature){
  var eAnnotation, i, kind;
  eAnnotation = eStructuralFeature.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    kind = $get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'kind');
    if (kind != null) {
      for (i = 1; i < ($clinit_ExtendedMetaData() , FEATURE_KINDS).length; ++i) {
        if ($equals_4(FEATURE_KINDS[i], kind)) {
          return i;
        }
      }
    }
  }
  return 0;
}

function $basicGetGroup(this$static, eStructuralFeature){
  var eAnnotation, eContainingClass, fragmentIndex, name_0, namespace, qualifiedName;
  eAnnotation = eStructuralFeature.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    qualifiedName = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'group'));
    if (qualifiedName != null) {
      fragmentIndex = $lastIndexOf(qualifiedName, fromCodePoint(35));
      eContainingClass = eStructuralFeature.getEContainingClass();
      if (fragmentIndex == -1) {
        namespace = $getNamespace(this$static, $getEPackage(eContainingClass));
        name_0 = qualifiedName;
      }
       else if (fragmentIndex == 0) {
        namespace = null;
        name_0 = qualifiedName.substr(1, qualifiedName.length - 1);
      }
       else {
        namespace = qualifiedName.substr(0, fragmentIndex);
        name_0 = qualifiedName.substr(fragmentIndex + 1, qualifiedName.length - (fragmentIndex + 1));
      }
      switch ($getFeatureKind($getExtendedMetaData_1(this$static, eStructuralFeature))) {
        case 2:
        case 3:
          {
            return $getAttribute_0(this$static, eContainingClass, namespace, name_0);
          }

        case 0:
        case 4:
        case 5:
        case 6:
          {
            return $getElement_0(this$static, eContainingClass, namespace, name_0);
          }

      }
    }
  }
  return null;
}

function $basicGetItemType(this$static, eDataType){
  var details, eAnnotation, index_0, itemType, type_0;
  eAnnotation = eDataType.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    details = (!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details);
    itemType = castToString($get_17(details, 'itemType'));
    if (itemType != null) {
      index_0 = itemType.lastIndexOf('#');
      type_0 = index_0 == -1?$getType_0(this$static, eDataType.getEPackage(), itemType):index_0 == 0?$getType(this$static, null, itemType.substr(1, itemType.length - 1)):$getType(this$static, itemType.substr(0, index_0), itemType.substr(index_0 + 1, itemType.length - (index_0 + 1)));
      if (instanceOf(type_0, 144)) {
        return castTo(type_0, 144);
      }
    }
  }
  return null;
}

function $basicGetMemberTypes(this$static, eDataType){
  var eAnnotation, index_0, member, member$array, member$index, member$max, memberTypes, result, type_0;
  eAnnotation = eDataType.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    memberTypes = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'memberTypes'));
    if (memberTypes != null) {
      result = new ArrayList;
      for (member$array = $split_0(memberTypes, '\\w') , member$index = 0 , member$max = member$array.length; member$index < member$max; ++member$index) {
        member = member$array[member$index];
        index_0 = member.lastIndexOf('#');
        type_0 = index_0 == -1?$getType_0(this$static, eDataType.getEPackage(), member):index_0 == 0?$getType(this$static, null, member.substr(1, member.length - 1)):$getType(this$static, member.substr(0, index_0), member.substr(index_0 + 1, member.length - (index_0 + 1)));
        instanceOf(type_0, 144) && $add_4(result, castTo(type_0, 144));
      }
      return result;
    }
  }
  return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
}

function $basicGetName(this$static, eClassifier){
  var eAnnotation, result;
  eAnnotation = eClassifier.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    result = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'name'));
    if (result != null) {
      return result;
    }
  }
  return eClassifier.getName();
}

function $basicGetName_0(this$static, eStructuralFeature){
  var eAnnotation, result;
  eAnnotation = eStructuralFeature.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    result = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'name'));
    if (result != null) {
      return result;
    }
  }
  return eStructuralFeature.getName();
}

function $basicGetNamespace(this$static, eStructuralFeature){
  var eAnnotation, result;
  eAnnotation = eStructuralFeature.getEAnnotation(this$static.annotationURI);
  if (!eAnnotation) {
    return null;
  }
   else {
    result = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'namespace'));
    return $equals_4('##targetNamespace', result)?$getNamespace(this$static, $getEPackage(eStructuralFeature.getEContainingClass())):result;
  }
}

function $basicGetWhiteSpaceFacet(this$static, eDataType){
  var eAnnotation, i, whiteSpaceLiteral;
  eAnnotation = eDataType.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    whiteSpaceLiteral = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'whiteSpace'));
    for (i = 1; i < ($clinit_ExtendedMetaData() , WHITE_SPACE_KINDS).length; ++i) {
      if ($equals_4(WHITE_SPACE_KINDS[i], whiteSpaceLiteral)) {
        return i;
      }
    }
  }
  return 0;
}

function $basicGetWildcards(this$static, eStructuralFeature){
  var eAnnotation, result, wildcard, wildcard$array, wildcard$index, wildcard$max, wildcards;
  eAnnotation = eStructuralFeature.getEAnnotation(this$static.annotationURI);
  if (eAnnotation) {
    wildcards = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'wildcards'));
    if (wildcards != null) {
      result = new ArrayList;
      for (wildcard$array = $split_0(wildcards, '\\w') , wildcard$index = 0 , wildcard$max = wildcard$array.length; wildcard$index < wildcard$max; ++wildcard$index) {
        wildcard = wildcard$array[wildcard$index];
        $equals_4(wildcard, '##other')?$add_4(result, '!##' + $getNamespace(this$static, $getEPackage(eStructuralFeature.getEContainingClass()))):$equals_4(wildcard, '##local')?(result.array[result.array.length] = null , true):$equals_4(wildcard, '##targetNamespace')?$add_4(result, $getNamespace(this$static, $getEPackage(eStructuralFeature.getEContainingClass()))):(result.array[result.array.length] = wildcard , true);
      }
      return result;
    }
  }
  return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
}

function $getAffiliation(this$static, eClass, eStructuralFeature){
  var affiliation, allAttributes, allElements, i, name_0, namespace, namespace0, result, size_0;
  if ($getFeatureID(eClass, eStructuralFeature) >= 0) {
    return eStructuralFeature;
  }
  switch ($getFeatureKind($getExtendedMetaData_1(this$static, eStructuralFeature))) {
    case 2:
      {
        if ($equals_4('', $getExtendedMetaData(this$static, eStructuralFeature.getEContainingClass()).getName())) {
          namespace = $getNamespace_0($getExtendedMetaData_1(this$static, eStructuralFeature));
          name_0 = $getName_2($getExtendedMetaData_1(this$static, eStructuralFeature));
          result = $getLocalAttribute(this$static, eClass, namespace, name_0);
          if (result) {
            return result;
          }
          allAttributes = $getAllAttributes(this$static, eClass);
          for (i = 0 , size_0 = allAttributes.size_1(); i < size_0; ++i) {
            result = castTo(allAttributes.get_3(i), 159);
            if ($matches($getWildcards($getExtendedMetaData_1(this$static, result)), namespace)) {
              return result;
            }
          }
        }
        return null;
      }

    case 4:
      {
        if ($equals_4('', $getExtendedMetaData(this$static, eStructuralFeature.getEContainingClass()).getName())) {
          for (affiliation = eStructuralFeature; affiliation; affiliation = $getAffiliation_0($getExtendedMetaData_1(this$static, affiliation))) {
            namespace0 = $getNamespace_0($getExtendedMetaData_1(this$static, affiliation));
            name_0 = $getName_2($getExtendedMetaData_1(this$static, affiliation));
            result = $getLocalElement(this$static, eClass, namespace0, name_0);
            if (result) {
              return result;
            }
          }
          namespace = $getNamespace_0($getExtendedMetaData_1(this$static, eStructuralFeature));
          if ($equals_4('http://www.eclipse.org/emf/2003/XMLType', namespace)) {
            return $getMixedFeature(this$static, eClass);
          }
           else {
            allElements = $getAllElements(this$static, eClass);
            for (i = 0 , size_0 = allElements.size_1(); i < size_0; ++i) {
              result = castTo(allElements.get_3(i), 159);
              if ($matches($getWildcards($getExtendedMetaData_1(this$static, result)), namespace)) {
                return result;
              }
            }
          }
        }
        return null;
      }

    default:{
        return null;
      }

  }
}

function $getAllAttributes(this$static, eClass){
  var allAttributes, attributes, changeable, eGenericType, eSuperType, i, result, result0, size_0, superTypes;
  superTypes = $getESuperTypes(eClass);
  result0 = null;
  changeable = false;
  for (i = 0 , size_0 = $getEGenericSuperTypes(superTypes.this$01).size_0; i < size_0; ++i) {
    eSuperType = castTo($resolve_1(superTypes, i, (eGenericType = castTo($get_16($getEGenericSuperTypes(superTypes.this$01), i), 86) , result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT))), 26);
    allAttributes = $getAllAttributes(this$static, eSuperType);
    if (!allAttributes.isEmpty()) {
      if (!result0) {
        result0 = allAttributes;
      }
       else {
        if (!changeable) {
          changeable = true;
          result0 = new UniqueEList_0(result0);
        }
        result0.addAll(allAttributes);
      }
    }
  }
  attributes = $getAttributes(this$static, eClass);
  if (attributes.isEmpty()) {
    return !result0?($clinit_Collections() , $clinit_Collections() , EMPTY_LIST):result0;
  }
   else {
    if (!result0) {
      return attributes;
    }
     else {
      changeable || (result0 = new UniqueEList_0(result0));
      result0.addAll(attributes);
      return result0;
    }
  }
}

function $getAllElements(this$static, eClass){
  var allElements, changeable, eGenericType, eSuperType, elements, i, result, result0, size_0, superTypes;
  superTypes = $getESuperTypes(eClass);
  result0 = null;
  changeable = false;
  for (i = 0 , size_0 = $getEGenericSuperTypes(superTypes.this$01).size_0; i < size_0; ++i) {
    eSuperType = castTo($resolve_1(superTypes, i, (eGenericType = castTo($get_16($getEGenericSuperTypes(superTypes.this$01), i), 86) , result = eGenericType.eRawType , instanceOf(result, 99)?castTo(result, 26):($clinit_EcorePackage$Literals() , EOBJECT))), 26);
    allElements = $getAllElements(this$static, eSuperType);
    if (!allElements.isEmpty()) {
      if (!result0) {
        result0 = allElements;
      }
       else {
        if (!changeable) {
          changeable = true;
          result0 = new UniqueEList_0(result0);
        }
        result0.addAll(allElements);
      }
    }
  }
  elements = $getElements(this$static, eClass);
  if (elements.isEmpty()) {
    return !result0?($clinit_Collections() , $clinit_Collections() , EMPTY_LIST):result0;
  }
   else {
    if (!result0) {
      return elements;
    }
     else {
      changeable || (result0 = new UniqueEList_0(result0));
      result0.addAll(elements);
      return result0;
    }
  }
}

function $getAnnotation(this$static, eModelElement){
  var result;
  result = eModelElement.getEAnnotation(this$static.annotationURI);
  return result;
}

function $getAttribute(this$static, namespace, name_0){
  var documentRoot, ePackage, ePackage0;
  ePackage0 = (ePackage = $getEPackage_0(this$static.registry, namespace) , ePackage);
  if (ePackage0) {
    documentRoot = castTo($getType_1($getExtendedMetaData_0(this$static, ePackage0), ''), 26);
    if (documentRoot) {
      return $getLocalAttribute(this$static, documentRoot, namespace, name_0);
    }
  }
  return null;
}

function $getAttribute_0(this$static, eClass, namespace, name_0){
  var result;
  result = $getLocalAttribute(this$static, eClass, namespace, name_0);
  if (!result) {
    result = $getAttribute(this$static, namespace, name_0);
    if (!!result && !$getAffiliation(this$static, eClass, result)) {
      return null;
    }
  }
  return result;
}

function $getAttributes(this$static, eClass){
  var eStructuralFeature, eStructuralFeatures, i, result, size_0;
  eStructuralFeatures = (!eClass.eStructuralFeatures && (eClass.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, eClass, 21, 17)) , eClass.eStructuralFeatures);
  result = null;
  for (i = 0 , size_0 = eStructuralFeatures.size_0; i < size_0; ++i) {
    eStructuralFeature = castTo($get_16(eStructuralFeatures, i), 159);
    switch ($getFeatureKind($getExtendedMetaData_1(this$static, eStructuralFeature))) {
      case 2:
      case 3:
        {
          !result && (result = new ArrayList);
          result.array[result.array.length] = eStructuralFeature;
        }

    }
  }
  return !result?($clinit_Collections() , $clinit_Collections() , EMPTY_LIST):result;
}

function $getElement(this$static, namespace, name_0){
  var documentRoot, ePackage, ePackage0;
  ePackage0 = (ePackage = $getEPackage_0(this$static.registry, namespace) , ePackage);
  if (ePackage0) {
    documentRoot = castTo($getType_1($getExtendedMetaData_0(this$static, ePackage0), ''), 26);
    if (documentRoot) {
      return $getLocalElement(this$static, documentRoot, namespace, name_0);
    }
  }
  return null;
}

function $getElement_0(this$static, eClass, namespace, name_0){
  var result;
  result = $getLocalElement(this$static, eClass, namespace, name_0);
  if (!result) {
    result = $getElement(this$static, namespace, name_0);
    if (!!result && !$getAffiliation(this$static, eClass, result)) {
      return null;
    }
  }
  return result;
}

function $getElements(this$static, eClass){
  var eStructuralFeature, eStructuralFeatures, i, result, size_0;
  eStructuralFeatures = (!eClass.eStructuralFeatures && (eClass.eStructuralFeatures = new EObjectContainmentWithInverseEList(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, eClass, 21, 17)) , eClass.eStructuralFeatures);
  result = null;
  for (i = 0 , size_0 = eStructuralFeatures.size_0; i < size_0; ++i) {
    eStructuralFeature = castTo($get_16(eStructuralFeatures, i), 159);
    switch ($getFeatureKind($getExtendedMetaData_1(this$static, eStructuralFeature))) {
      case 4:
      case 5:
      case 6:
        {
          !result && (result = new ArrayList);
          result.array[result.array.length] = eStructuralFeature;
          break;
        }

    }
  }
  return !result?($clinit_Collections() , $clinit_Collections() , EMPTY_LIST):result;
}

function $getExtendedMetaData(this$static, eClassifier){
  var holder, result;
  holder = castTo(eClassifier, 633);
  result = holder.getExtendedMetaData_1();
  !result && holder.setExtendedMetaData_1(result = instanceOf(eClassifier, 99)?new BasicExtendedMetaData$EClassExtendedMetaDataImpl(this$static, castTo(eClassifier, 26)):new BasicExtendedMetaData$EDataTypeExtendedMetaDataImpl(this$static, castTo(eClassifier, 144)));
  return result;
}

function $getExtendedMetaData_0(this$static, ePackage){
  var holder, result;
  holder = castTo(ePackage, 632);
  result = holder.getExtendedMetaData();
  !result && holder.setExtendedMetaData(result = new BasicExtendedMetaData$EPackageExtendedMetaDataImpl(this$static, ePackage));
  return result;
}

function $getExtendedMetaData_1(this$static, eStructuralFeature){
  var holder, result;
  holder = castTo(eStructuralFeature, 634);
  result = holder.getExtendedMetaData_0();
  !result && holder.setExtendedMetaData_0(result = new BasicExtendedMetaData$EStructuralFeatureExtendedMetaDataImpl(this$static, eStructuralFeature));
  return result;
}

function $getLocalAttribute(this$static, eClass, namespace, name_0){
  var allAttributes, eStructuralFeature, featureNamespace, i, result, size_0;
  result = null;
  allAttributes = $getAllAttributes(this$static, eClass);
  for (i = 0 , size_0 = allAttributes.size_1(); i < size_0; ++i) {
    eStructuralFeature = castTo(allAttributes.get_3(i), 159);
    if ($equals_4(name_0, $getName_2($getExtendedMetaData_1(this$static, eStructuralFeature)))) {
      featureNamespace = $getNamespace_0($getExtendedMetaData_1(this$static, eStructuralFeature));
      if (namespace == null) {
        if (featureNamespace == null) {
          return eStructuralFeature;
        }
         else 
          !result && (result = eStructuralFeature);
      }
       else if ($equals_4(namespace, featureNamespace)) {
        return eStructuralFeature;
      }
       else 
        featureNamespace == null && !result && (result = eStructuralFeature);
    }
  }
  return null;
}

function $getLocalElement(this$static, eClass, namespace, name_0){
  var allElements, eStructuralFeature, featureNamespace, i, result, size_0;
  result = null;
  allElements = $getAllElements(this$static, eClass);
  for (i = 0 , size_0 = allElements.size_1(); i < size_0; ++i) {
    eStructuralFeature = castTo(allElements.get_3(i), 159);
    if ($equals_4(name_0, $getName_2($getExtendedMetaData_1(this$static, eStructuralFeature)))) {
      featureNamespace = $getNamespace_0($getExtendedMetaData_1(this$static, eStructuralFeature));
      if (namespace == null) {
        if (featureNamespace == null) {
          return eStructuralFeature;
        }
         else 
          !result && (result = eStructuralFeature);
      }
       else if ($equals_4(namespace, featureNamespace)) {
        return eStructuralFeature;
      }
       else 
        featureNamespace == null && !result && (result = eStructuralFeature);
    }
  }
  return null;
}

function $getMixedFeature(this$static, eClass){
  var eAllAttributes, eAttribute, i, size_0;
  switch ($getExtendedMetaData(this$static, eClass).getContentKind()) {
    case 3:
    case 2:
      {
        eAllAttributes = $getEAllAttributes(eClass);
        for (i = 0 , size_0 = eAllAttributes.size_0; i < size_0; ++i) {
          eAttribute = castTo($get_16(eAllAttributes, i), 29);
          if ($getFeatureKind($getExtendedMetaData_1(this$static, eAttribute)) == 5) {
            return eAttribute;
          }
        }
        break;
      }

  }
  return null;
}

function $getNamespace(this$static, ePackage){
  return $isQualified($getExtendedMetaData_0(this$static, ePackage))?ePackage.getNsURI():null;
}

function $getType(this$static, namespace, name_0){
  var ePackage, ePackage0;
  ePackage0 = (ePackage = $getEPackage_0(this$static.registry, namespace) , ePackage);
  return !ePackage0?null:$getType_1($getExtendedMetaData_0(this$static, ePackage0), name_0);
}

function $getType_0(this$static, ePackage, name_0){
  return $getType_1($getExtendedMetaData_0(this$static, ePackage), name_0);
}

function $matches(wildcards, namespace){
  var i, size_0, suffixlength, wildcard;
  if (!wildcards.isEmpty()) {
    for (i = 0 , size_0 = wildcards.size_1(); i < size_0; ++i) {
      wildcard = castToString(wildcards.get_3(i));
      if (wildcard == null?namespace == null:$equals_4(wildcard.substr(0, 3), '!##')?namespace != null && (suffixlength = namespace.length , !$equals_4(wildcard.substr(wildcard.length - suffixlength, suffixlength), namespace) || wildcard.length != namespace.length + 3) && !$equals_4('http://www.eclipse.org/emf/2003/XMLType', namespace):$equals_4(wildcard, '##any') && !$equals_4('http://www.eclipse.org/emf/2003/XMLType', namespace) || $equals_4(wildcard, namespace)) {
        return true;
      }
    }
  }
  return false;
}

function BasicExtendedMetaData(){
  $clinit_BasicExtendedMetaData();
  BasicExtendedMetaData_0.call(this, ($clinit_EPackage$Registry() , INSTANCE_6));
}

function BasicExtendedMetaData_0(registry){
  this.annotationURI = (checkCriticalNotNull('http:///org/eclipse/emf/ecore/util/ExtendedMetaData') , 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData');
  this.registry = registry;
  new EPackageRegistryImpl;
}

defineClass(591, 1, {}, BasicExtendedMetaData);
var UNINITIALIZED_EDATA_TYPE, UNINITIALIZED_ESTRUCTURAL_FEATURE;
var Lorg_eclipse_emf_ecore_util_BasicExtendedMetaData_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'BasicExtendedMetaData', 591);
function $setContentKind(this$static, kind){
  this$static.contentKind = kind;
}

function $setName_2(this$static, name_0){
  this$static.name_0 = name_0;
}

function BasicExtendedMetaData$EClassExtendedMetaDataImpl(this$0, eClass){
  this.this$01 = this$0;
  this.eClass = eClass;
}

defineClass(1048, 1, {}, BasicExtendedMetaData$EClassExtendedMetaDataImpl);
_.getBaseType = function getBaseType(){
  return null;
}
;
_.getContentKind = function getContentKind(){
  this.contentKind == -2 && $setContentKind(this, $basicGetContentKind(this.this$01, this.eClass));
  return this.contentKind;
}
;
_.getItemType = function getItemType(){
  return null;
}
;
_.getMemberTypes = function getMemberTypes(){
  return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
}
;
_.getName = function getName_5(){
  this.name_0 == 'uninitialized' && $setName_2(this, $basicGetName(this.this$01, this.eClass));
  return this.name_0;
}
;
_.getWhiteSpaceFacet = function getWhiteSpaceFacet(){
  return 0;
}
;
_.contentKind = -2;
_.name_0 = 'uninitialized';
var Lorg_eclipse_emf_ecore_util_BasicExtendedMetaData$EClassExtendedMetaDataImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'BasicExtendedMetaData/EClassExtendedMetaDataImpl', 1048);
function $setBaseType(this$static, baseType){
  this$static.baseType = baseType;
}

function $setItemType(this$static, itemType){
  this$static.itemType = itemType;
}

function $setMemberTypes(this$static, memberTypes){
  this$static.memberTypes = memberTypes;
}

function $setName_3(this$static, name_0){
  this$static.name_0 = name_0;
}

function $setWhiteSpaceFacet(this$static, whiteSpace){
  this$static.whiteSpace = whiteSpace;
}

function BasicExtendedMetaData$EDataTypeExtendedMetaDataImpl(this$0, eDataType){
  this.this$01 = this$0;
  this.baseType = ($clinit_BasicExtendedMetaData() , UNINITIALIZED_EDATA_TYPE);
  this.itemType = UNINITIALIZED_EDATA_TYPE;
  this.eDataType = eDataType;
}

defineClass(1049, 1, {}, BasicExtendedMetaData$EDataTypeExtendedMetaDataImpl);
_.getBaseType = function getBaseType_0(){
  this.baseType == ($clinit_BasicExtendedMetaData() , UNINITIALIZED_EDATA_TYPE) && $setBaseType(this, $basicGetBaseType(this.this$01, this.eDataType));
  return this.baseType;
}
;
_.getContentKind = function getContentKind_0(){
  return 0;
}
;
_.getItemType = function getItemType_0(){
  this.itemType == ($clinit_BasicExtendedMetaData() , UNINITIALIZED_EDATA_TYPE) && $setItemType(this, $basicGetItemType(this.this$01, this.eDataType));
  return this.itemType;
}
;
_.getMemberTypes = function getMemberTypes_0(){
  !this.memberTypes && $setMemberTypes(this, $basicGetMemberTypes(this.this$01, this.eDataType));
  return this.memberTypes;
}
;
_.getName = function getName_6(){
  this.name_0 == 'uninitialized' && $setName_3(this, $basicGetName(this.this$01, this.eDataType));
  return this.name_0;
}
;
_.getWhiteSpaceFacet = function getWhiteSpaceFacet_0(){
  this.whiteSpace == -2 && $setWhiteSpaceFacet(this, $basicGetWhiteSpaceFacet(this.this$01, this.eDataType));
  return this.whiteSpace;
}
;
_.name_0 = 'uninitialized';
_.whiteSpace = -2;
var Lorg_eclipse_emf_ecore_util_BasicExtendedMetaData$EDataTypeExtendedMetaDataImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'BasicExtendedMetaData/EDataTypeExtendedMetaDataImpl', 1049);
function $getType_1(this$static, name_0){
  var conflictingEClassifier, eClassifier, eClassifierName, eClassifiers, i, i0, nameToClassifierMap, originalMapSize, result, size_0;
  result = null;
  !!this$static.nameToClassifierMap && (result = castTo($getStringValue(this$static.nameToClassifierMap, name_0), 136));
  if (!result) {
    eClassifiers = this$static.ePackage.getEClassifiers();
    size_0 = eClassifiers.size_0;
    if (!this$static.nameToClassifierMap || $size_0(this$static.nameToClassifierMap) != size_0) {
      nameToClassifierMap = new HashMap;
      !!this$static.nameToClassifierMap && $putAll(nameToClassifierMap, this$static.nameToClassifierMap);
      originalMapSize = nameToClassifierMap.hashCodeMap.size_0 + nameToClassifierMap.stringMap.size_0;
      for (i0 = originalMapSize; i0 < size_0; ++i0) {
        eClassifier = castTo($get_16(eClassifiers, i0), 136);
        eClassifierName = $getExtendedMetaData(this$static.this$01, eClassifier).getName();
        conflictingEClassifier = castTo(eClassifierName == null?$put_4(nameToClassifierMap.hashCodeMap, null, eClassifier):$put_5(nameToClassifierMap.stringMap, eClassifierName, eClassifier), 136);
        !!conflictingEClassifier && conflictingEClassifier != eClassifier && (eClassifierName == null?$put_4(nameToClassifierMap.hashCodeMap, null, conflictingEClassifier):$put_5(nameToClassifierMap.stringMap, eClassifierName, conflictingEClassifier));
      }
      if (nameToClassifierMap.hashCodeMap.size_0 + nameToClassifierMap.stringMap.size_0 != size_0) {
        for (i = 0; i < originalMapSize; ++i) {
          eClassifier = castTo($get_16(eClassifiers, i), 136);
          eClassifierName = $getExtendedMetaData(this$static.this$01, eClassifier).getName();
          conflictingEClassifier = castTo(eClassifierName == null?$put_4(nameToClassifierMap.hashCodeMap, null, eClassifier):$put_5(nameToClassifierMap.stringMap, eClassifierName, eClassifier), 136);
          !!conflictingEClassifier && conflictingEClassifier != eClassifier && (eClassifierName == null?$put_4(nameToClassifierMap.hashCodeMap, null, conflictingEClassifier):$put_5(nameToClassifierMap.stringMap, eClassifierName, conflictingEClassifier));
        }
      }
      this$static.nameToClassifierMap = nameToClassifierMap;
    }
    result = castTo($getStringValue(this$static.nameToClassifierMap, name_0), 136);
  }
  return result;
}

function $isQualified(this$static){
  var eAnnotation;
  this$static.isInitialized || $setQualified(this$static, (eAnnotation = $getAnnotation(this$static.this$01, this$static.ePackage) , !eAnnotation || !$equals_4('false', $get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'qualified'))));
  return this$static.isQualified;
}

function $setQualified(this$static, isQualified){
  this$static.isQualified = isQualified;
  this$static.isInitialized = true;
}

function BasicExtendedMetaData$EPackageExtendedMetaDataImpl(this$0, ePackage){
  this.this$01 = this$0;
  this.ePackage = ePackage;
}

defineClass(1047, 1, {}, BasicExtendedMetaData$EPackageExtendedMetaDataImpl);
_.isInitialized = false;
_.isQualified = false;
var Lorg_eclipse_emf_ecore_util_BasicExtendedMetaData$EPackageExtendedMetaDataImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'BasicExtendedMetaData/EPackageExtendedMetaDataImpl', 1047);
function $getAffiliation_0(this$static){
  this$static.affiliation == ($clinit_BasicExtendedMetaData() , UNINITIALIZED_ESTRUCTURAL_FEATURE) && $setAffiliation(this$static, $basicGetAffiliation(this$static.this$01, this$static.eStructuralFeature));
  return this$static.affiliation;
}

function $getFeatureKind(this$static){
  this$static.featureKind == -2 && $setFeatureKind(this$static, $basicGetFeatureKind(this$static.this$01, this$static.eStructuralFeature));
  return this$static.featureKind;
}

function $getGroup(this$static){
  this$static.group == ($clinit_BasicExtendedMetaData() , UNINITIALIZED_ESTRUCTURAL_FEATURE) && $setGroup(this$static, $basicGetGroup(this$static.this$01, this$static.eStructuralFeature));
  return this$static.group;
}

function $getName_2(this$static){
  this$static.name_0 == 'uninitialized' && $setName_4(this$static, $basicGetName_0(this$static.this$01, this$static.eStructuralFeature));
  return this$static.name_0;
}

function $getNamespace_0(this$static){
  this$static.namespace == 'uninitialized' && $setNamespace(this$static, $basicGetNamespace(this$static.this$01, this$static.eStructuralFeature));
  return this$static.namespace;
}

function $getWildcards(this$static){
  !this$static.wildcards && $setWildcards(this$static, $basicGetWildcards(this$static.this$01, this$static.eStructuralFeature));
  return this$static.wildcards;
}

function $setAffiliation(this$static, affiliation){
  this$static.affiliation = affiliation;
}

function $setFeatureKind(this$static, kind){
  this$static.featureKind = kind;
}

function $setGroup(this$static, group){
  this$static.group = group;
}

function $setName_4(this$static, name_0){
  this$static.name_0 = name_0;
}

function $setNamespace(this$static, namespace){
  this$static.namespace = namespace;
}

function $setWildcards(this$static, wildcards){
  this$static.wildcards = wildcards;
}

function BasicExtendedMetaData$EStructuralFeatureExtendedMetaDataImpl(this$0, eStructuralFeature){
  this.this$01 = this$0;
  this.group = ($clinit_BasicExtendedMetaData() , UNINITIALIZED_ESTRUCTURAL_FEATURE);
  this.affiliation = UNINITIALIZED_ESTRUCTURAL_FEATURE;
  this.eStructuralFeature = eStructuralFeature;
}

defineClass(1050, 1, {}, BasicExtendedMetaData$EStructuralFeatureExtendedMetaDataImpl);
_.featureKind = -2;
_.name_0 = 'uninitialized';
_.namespace = 'uninitialized';
var Lorg_eclipse_emf_ecore_util_BasicExtendedMetaData$EStructuralFeatureExtendedMetaDataImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'BasicExtendedMetaData/EStructuralFeatureExtendedMetaDataImpl', 1050);
function EDataTypeEList(dataClass, owner, featureID){
  EcoreEList.call(this, dataClass, owner);
  this.featureID = featureID;
}

defineClass(553, 589, $intern_156, EDataTypeEList);
_.getFeatureID_0 = function getFeatureID_13(){
  return this.featureID;
}
;
_.isEObject = function isEObject_4(){
  return false;
}
;
_.resolve = function resolve_8(index_0, object){
  return object;
}
;
_.featureID = 0;
var Lorg_eclipse_emf_ecore_util_EDataTypeEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EDataTypeEList', 553);
var Lorg_eclipse_emf_ecore_util_FeatureMap_2_classLit = createForInterface('org.eclipse.emf.ecore.util', 'FeatureMap');
function $add_31(this$static, index_0, object){
  var entries, entryFeature, i, otherEntry, validator;
  entryFeature = object.getEStructuralFeature();
  if (isMany_1(this$static.owner, entryFeature)) {
    if (entryFeature.isUnique()) {
      entries = castTo(this$static.data_0, 127);
      for (i = 0; i < this$static.size_0; ++i) {
        otherEntry = entries[i];
        if (equals_Ljava_lang_Object__Z__devirtual$(otherEntry, object) && i != index_0) {
          throw toJs(new IllegalArgumentException_0("The 'no duplicates' constraint is violated"));
        }
      }
    }
  }
   else {
    validator = getValidator(this$static.owner.eClass_0(), entryFeature);
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      otherEntry = entries[i];
      if (validator.isValid(otherEntry.getEStructuralFeature())) {
        throw toJs(new IllegalArgumentException_0('The multiplicity constraint is violated'));
      }
    }
  }
  $add_20(this$static, index_0, object);
}

function $add_32(this$static, feature, index_0, object){
  var entries, entry, i, isFeatureMap, validator;
  isFeatureMap = ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0());
  if (isMany_1(this$static.owner, feature)) {
    if (feature.isUnique() && $contains_13(this$static, feature, object, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0)) {
      throw toJs(new IllegalArgumentException_0("The 'no duplicates' constraint is violated"));
    }
  }
   else {
    validator = getValidator(this$static.owner.eClass_0(), feature);
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        throw toJs(new IllegalArgumentException_0('The multiplicity constraint is violated'));
      }
    }
  }
  $add_20(this$static, $entryIndex(this$static, feature, index_0), isFeatureMap?castTo(object, 76):createEntry_5(feature, object));
}

function $add_33(this$static, feature, object){
  var entries, entry, i, isFeatureMap, validator;
  isFeatureMap = ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0());
  if (isMany_1(this$static.owner, feature)) {
    if (feature.isUnique() && $contains_13(this$static, feature, object, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0)) {
      return false;
    }
  }
   else {
    validator = getValidator(this$static.owner.eClass_0(), feature);
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (isFeatureMap?equals_Ljava_lang_Object__Z__devirtual$(entry, object):object == null?entry.getValue() == null:equals_Ljava_lang_Object__Z__devirtual$(object, entry.getValue())) {
          return false;
        }
         else {
          castTo($set_8(this$static, i, isFeatureMap?castTo(object, 76):createEntry_5(feature, object)), 76);
          return true;
        }
      }
    }
  }
  return $add_21(this$static, isFeatureMap?castTo(object, 76):createEntry_5(feature, object));
}

function $add_34(this$static, object){
  var entries, entryFeature, i, otherEntry, validator;
  entryFeature = object.getEStructuralFeature();
  if (isMany_1(this$static.owner, entryFeature)) {
    if (entryFeature.isUnique() && $contains_12(this$static, entryFeature, object.getValue())) {
      return false;
    }
  }
   else {
    validator = getValidator(this$static.owner.eClass_0(), entryFeature);
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      otherEntry = entries[i];
      if (validator.isValid(otherEntry.getEStructuralFeature())) {
        if (equals_Ljava_lang_Object__Z__devirtual$(otherEntry, object)) {
          return false;
        }
         else {
          castTo($set_8(this$static, i, object), 76);
          return true;
        }
      }
    }
  }
  return $add_21(this$static, object);
}

function $addAll_8(this$static, feature, collection){
  var entries, entry, entryCollection, i, isFeatureMap, object, object$iterator, validator;
  if (collection.size_1() == 0) {
    return false;
  }
  isFeatureMap = ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0());
  entryCollection = isFeatureMap?collection:new BasicEList_0(collection.size_1());
  if (isMany_1(this$static.owner, feature)) {
    if (feature.isUnique()) {
      for (object$iterator = collection.iterator_0(); object$iterator.hasNext_0();) {
        object = object$iterator.next_1();
        if (!$contains_13(this$static, feature, object, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0)) {
          entry = createEntry_5(feature, object);
          entryCollection.contains(entry) || entryCollection.add_1(entry);
        }
      }
    }
     else if (!isFeatureMap) {
      for (object$iterator = collection.iterator_0(); object$iterator.hasNext_0();) {
        object = object$iterator.next_1();
        entry = createEntry_5(feature, object);
        entryCollection.add_1(entry);
      }
    }
  }
   else {
    if (collection.size_1() > 1) {
      throw toJs(new IllegalArgumentException_0('The multiplicity constraint is violated'));
    }
    validator = getValidator(this$static.owner.eClass_0(), feature);
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (collection.contains(isFeatureMap?entry:entry.getValue())) {
          return false;
        }
         else {
          for (object$iterator = collection.iterator_0(); object$iterator.hasNext_0();) {
            object = object$iterator.next_1();
            castTo($set_8(this$static, i, isFeatureMap?castTo(object, 76):createEntry_5(feature, object)), 76);
          }
          return true;
        }
      }
    }
    if (!isFeatureMap) {
      entry = createEntry_5(feature, collection.iterator_0().next_1());
      entryCollection.add_1(entry);
    }
  }
  return $addAll_6(this$static, entryCollection);
}

function $addUnique_10(this$static, entry){
  var index_0, notification, notifications, oldIsSet;
  this$static.modCount = -1;
  if ($eNotificationRequired(this$static.owner)) {
    index_0 = this$static.size_0;
    oldIsSet = this$static.size_0 != 0;
    $addUnique_0(this$static, entry);
    notification = new ENotificationImpl_3(this$static.owner, 3, this$static.featureID, null, entry, index_0, oldIsSet);
    notifications = entry.inverseAdd_0(this$static.owner, this$static.featureID, null);
    notifications = $shadowAdd_1(this$static, entry, notifications);
    if (!notifications) {
      $eNotify(this$static.owner, notification);
    }
     else {
      notifications.add_4(notification);
      notifications.dispatch_0();
    }
  }
   else {
    $addUnique_0(this$static, entry);
    notifications = entry.inverseAdd_0(this$static.owner, this$static.featureID, null);
    !!notifications && notifications.dispatch_0();
  }
}

function $addUnique_11(this$static, object){
  ++this$static.modCount;
  $validate_3(this$static, this$static.size_0, object);
  $addUnique_10(this$static, castTo(object, 319));
}

function $basicAdd_2(this$static, feature, object, notifications){
  var entries, entry, entry0, i, notification, oldIsSet;
  if (object == null) {
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      entry0 = entries[i];
      if (entry0.getEStructuralFeature() == feature) {
        return $basicRemove_0(this$static, entry0, notifications);
      }
    }
  }
  entry = ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0()?castTo(object, 76):createEntry_5(feature, object));
  if ($eNotificationRequired(this$static.owner)) {
    oldIsSet = !$isEmpty_1(this$static, feature);
    notifications = $basicAdd_0(this$static, entry, notifications);
    notification = feature.isMany()?$createNotification_0(this$static, 3, feature, null, object, $indexOf_8(this$static, feature, object, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0), oldIsSet):$createNotification_0(this$static, 1, feature, feature.getDefaultValue(), object, -1, oldIsSet);
    notifications?notifications.add_4(notification):(notifications = notification);
  }
   else {
    notifications = $basicAdd_0(this$static, entry, notifications);
  }
  return notifications;
}

function $basicIterator(this$static, feature){
  return new BasicFeatureMap$FeatureEIterator(feature, this$static);
}

function $basicListIterator_0(this$static, feature){
  return new BasicFeatureMap$FeatureEIterator(feature, this$static);
}

function $basicListIterator_1(this$static, feature, index_0){
  var i, result;
  result = new BasicFeatureMap$FeatureEIterator(feature, this$static);
  for (i = 0; i < index_0; ++i) {
    $next_18(result);
  }
  return result;
}

function $basicRemove_2(this$static, object, notifications){
  var entries, entry, feature, i, match_0, notification;
  if (instanceOf(object, 76)) {
    return $basicRemove_0(this$static, object, notifications);
  }
   else {
    match_0 = null;
    feature = null;
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (equals_Ljava_lang_Object__Z__devirtual$(object, entry.getValue())) {
        feature = entry.getEStructuralFeature();
        if (instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_138) != 0) {
          match_0 = entry;
          break;
        }
      }
    }
    if (match_0) {
      if ($eNotificationRequired(this$static.owner)) {
        notification = feature.isMany()?$createNotification_0(this$static, 4, feature, object, null, $indexOf_8(this$static, feature, object, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0), true):$createNotification_0(this$static, feature.isUnsettable()?2:1, feature, object, feature.getDefaultValue(), -1, true);
        notifications?notifications.add_4(notification):(notifications = notification);
      }
      notifications = $basicRemove_2(this$static, match_0, notifications);
    }
    return notifications;
  }
}

function $basicRemove_3(this$static, feature, object, notifications){
  var count, entries, entry, i, match_0, notification, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  count = 0;
  entries = castTo(this$static.data_0, 127);
  match_0 = null;
  $clinit_FeatureMapUtil();
  if (castTo(feature, 63).isFeatureMap_0()) {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (equals_Ljava_lang_Object__Z__devirtual$(entry, object)) {
          match_0 = entry;
          break;
        }
        ++count;
      }
    }
  }
   else if (object != null) {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (equals_Ljava_lang_Object__Z__devirtual$(object, entry.getValue())) {
          match_0 = entry;
          break;
        }
        ++count;
      }
    }
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (entry.getValue() == null) {
          match_0 = entry;
          break;
        }
        ++count;
      }
    }
  }
  if (match_0) {
    if ($eNotificationRequired(this$static.owner)) {
      notification = feature.isMany()?new FeatureMapUtil$FeatureENotificationImpl(this$static.owner, 4, feature, object, null, count, true):$createNotification_0(this$static, feature.isUnsettable()?2:1, feature, object, feature.getDefaultValue(), -1, true);
      notifications?notifications.add_4(notification):(notifications = notification);
    }
    notifications = $basicRemove_2(this$static, match_0, notifications);
  }
  return notifications;
}

function $clear_13(this$static, feature){
  var entries, entry, entryCollection, i, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entryCollection = new BasicEList;
  entries = castTo(this$static.data_0, 127);
  for (i = this$static.size_0; --i >= 0;) {
    entry = entries[i];
    validator.isValid(entry.getEStructuralFeature()) && $add_21(entryCollection, entry);
  }
  !$removeAll_4(this$static, entryCollection) && $eNotificationRequired(this$static.owner) && $dispatchNotification(this$static, feature.isMany()?$createNotification_0(this$static, 6, feature, ($clinit_Collections() , EMPTY_LIST), null, -1, false):$createNotification_0(this$static, feature.isUnsettable()?2:1, feature, null, null, -1, false));
}

function $contains_12(this$static, feature, object){
  return $contains_13(this$static, feature, object, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0);
}

function $contains_13(this$static, feature, object, resolve){
  var entries, entry, i, i0, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entries = castTo(this$static.data_0, 127);
  $clinit_FeatureMapUtil();
  if (castTo(feature, 63).isFeatureMap_0()) {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature()) && equals_Ljava_lang_Object__Z__devirtual$(entry, object)) {
        return true;
      }
    }
  }
   else if (object != null) {
    for (i0 = 0; i0 < this$static.size_0; ++i0) {
      entry = entries[i0];
      if (validator.isValid(entry.getEStructuralFeature()) && equals_Ljava_lang_Object__Z__devirtual$(object, entry.getValue())) {
        return true;
      }
    }
    if (resolve) {
      for (i = 0; i < this$static.size_0; ++i) {
        entry = entries[i];
        if (validator.isValid(entry.getEStructuralFeature()) && maskUndefined(object) === maskUndefined($resolveProxy_0(this$static, castTo(entry.getValue(), 51)))) {
          return true;
        }
      }
    }
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature()) && entry.getValue() == null) {
        return false;
      }
    }
  }
  return false;
}

function $containsAll_1(this$static, feature, collection){
  var i;
  for (i = collection.iterator_0(); i.hasNext_0();) {
    if (!$contains_12(this$static, feature, i.next_1())) {
      return false;
    }
  }
  return true;
}

function $createNotification_0(this$static, eventType, feature, oldObject, newObject, index_0, wasSet){
  return new FeatureMapUtil$FeatureENotificationImpl(this$static.owner, eventType, feature, oldObject, newObject, index_0, wasSet);
}

function $entryIndex(this$static, feature, index_0){
  var count, entries, entry, i, result, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  count = 0;
  result = this$static.size_0;
  entries = castTo(this$static.data_0, 127);
  for (i = 0; i < this$static.size_0; ++i) {
    entry = entries[i];
    if (validator.isValid(entry.getEStructuralFeature())) {
      if (index_0 == count) {
        return i;
      }
      ++count;
      result = i + 1;
    }
  }
  if (index_0 == count) {
    return result;
  }
   else {
    throw toJs(new IndexOutOfBoundsException_0('index=' + index_0 + ', size=' + count));
  }
}

function $get_19(this$static, feature, index_0, resolve){
  var count, entries, entry, i, validator, value_0;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entries = castTo(this$static.data_0, 127);
  if (isMany_1(this$static.owner, feature)) {
    count = 0;
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (count == index_0) {
          $clinit_FeatureMapUtil();
          if (castTo(feature, 63).isFeatureMap_0()) {
            return entry;
          }
           else {
            value_0 = entry.getValue();
            value_0 != null && resolve && instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0 && (value_0 = $resolveProxy_1(this$static, feature, i, count, value_0));
            return value_0;
          }
        }
        ++count;
      }
    }
    throw toJs(new IndexOutOfBoundsException_0('index=' + index_0 + ', size=' + count));
  }
   else {
    count = 0;
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        $clinit_FeatureMapUtil();
        if (castTo(feature, 63).isFeatureMap_0()) {
          return entry;
        }
         else {
          value_0 = entry.getValue();
          value_0 != null && resolve && instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0 && (value_0 = $resolveProxy_1(this$static, feature, i, count, value_0));
          return value_0;
        }
      }
      ++count;
    }
    return feature.getDefaultValue();
  }
}

function $get_20(this$static, feature, resolve){
  var count, entries, entry, entryFeature, i, result, validator, value_0;
  entries = castTo(this$static.data_0, 127);
  if (isMany_1(this$static.owner, feature)) {
    return $clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0()?new FeatureMapUtil$FeatureFeatureMap(feature, this$static):new FeatureMapUtil$FeatureEList(feature, this$static);
  }
   else {
    validator = getValidator(this$static.owner.eClass_0(), feature);
    count = 0;
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      entryFeature = entry.getEStructuralFeature();
      if (validator.isValid(entryFeature)) {
        $clinit_FeatureMapUtil();
        if (castTo(feature, 63).isFeatureMap_0()) {
          return entry;
        }
         else if (entryFeature == ($clinit_XMLTypeFeatures() , TEXT) || entryFeature == CDATA) {
          result = new StringBuilder_1(toString_41(entry.getValue()));
          while (++i < this$static.size_0) {
            entry = entries[i];
            entryFeature = entry.getEStructuralFeature();
            (entryFeature == TEXT || entryFeature == CDATA) && $append_11(result, toString_41(entry.getValue()));
          }
          return createFromString_2(castTo(feature.getEType(), 144), result.string);
        }
         else {
          value_0 = entry.getValue();
          value_0 != null && resolve && instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0 && (value_0 = $resolveProxy_1(this$static, feature, i, count, value_0));
          return value_0;
        }
      }
      ++count;
    }
    return feature.getDefaultValue();
  }
}

function $indexOf_7(this$static, feature, object){
  return $indexOf_8(this$static, feature, object, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0);
}

function $indexOf_8(this$static, feature, object, resolve){
  var entries, entry, i, i0, result, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  result = 0;
  entries = castTo(this$static.data_0, 127);
  $clinit_FeatureMapUtil();
  if (castTo(feature, 63).isFeatureMap_0()) {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (equals_Ljava_lang_Object__Z__devirtual$(entry, object)) {
          return result;
        }
        ++result;
      }
    }
  }
   else if (object != null) {
    for (i0 = 0; i0 < this$static.size_0; ++i0) {
      entry = entries[i0];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (equals_Ljava_lang_Object__Z__devirtual$(object, entry.getValue())) {
          return result;
        }
        ++result;
      }
    }
    if (resolve) {
      result = 0;
      for (i = 0; i < this$static.size_0; ++i) {
        entry = entries[i];
        if (validator.isValid(entry.getEStructuralFeature())) {
          if (maskUndefined(object) === maskUndefined($resolveProxy_0(this$static, castTo(entry.getValue(), 51)))) {
            return result;
          }
          ++result;
        }
      }
    }
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (entry.getValue() == null) {
          return result;
        }
        ++result;
      }
    }
  }
  return -1;
}

function $inverseAdd_2(this$static, entry, notifications){
  return entry.inverseAdd_0(this$static.owner, this$static.featureID, notifications);
}

function $inverseAdd_3(this$static, object, notifications){
  return $inverseAdd_2(this$static, castTo(object, 319), notifications);
}

function $inverseRemove_2(this$static, entry, notifications){
  return entry.inverseRemove_0(this$static.owner, this$static.featureID, notifications);
}

function $inverseRemove_3(this$static, object, notifications){
  return $inverseRemove_2(this$static, castTo(object, 319), notifications);
}

function $isEmpty_1(this$static, feature){
  var entries, entry, i, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entries = castTo(this$static.data_0, 127);
  for (i = 0; i < this$static.size_0; ++i) {
    entry = entries[i];
    if (validator.isValid(entry.getEStructuralFeature())) {
      return false;
    }
  }
  return true;
}

function $iterator_5(this$static, feature){
  return instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0?new BasicFeatureMap$ResolvingFeatureEIterator(feature, this$static):new BasicFeatureMap$FeatureEIterator(feature, this$static);
}

function $list(this$static, feature){
  return $clinit_FeatureMapUtil() , $isFeatureMap(feature)?new FeatureMapUtil$FeatureFeatureMap(feature, this$static):new FeatureMapUtil$FeatureEList(feature, this$static);
}

function $listIterator_2(this$static, feature){
  return instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0?new BasicFeatureMap$ResolvingFeatureEIterator(feature, this$static):new BasicFeatureMap$FeatureEIterator(feature, this$static);
}

function $listIterator_3(this$static, feature, index_0){
  var i, result;
  result = instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0?new BasicFeatureMap$ResolvingFeatureEIterator(feature, this$static):new BasicFeatureMap$FeatureEIterator(feature, this$static);
  for (i = 0; i < index_0; ++i) {
    $next_18(result);
  }
  return result;
}

function $remove_42(this$static, feature, index_0){
  var count, entries, entry, i, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entries = castTo(this$static.data_0, 127);
  count = 0;
  for (i = 0; i < this$static.size_0; ++i) {
    entry = entries[i];
    if (validator.isValid(entry.getEStructuralFeature())) {
      if (count == index_0) {
        $remove_34(this$static, i);
        return $clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0()?entry:entry.getValue();
      }
      ++count;
    }
  }
  throw toJs(new IndexOutOfBoundsException_0('index=' + index_0 + ', size=' + count));
}

function $remove_43(this$static, feature, object){
  var entries, entry, i, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entries = castTo(this$static.data_0, 127);
  $clinit_FeatureMapUtil();
  if (castTo(feature, 63).isFeatureMap_0()) {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (equals_Ljava_lang_Object__Z__devirtual$(entry, object)) {
          $remove_34(this$static, i);
          return true;
        }
      }
    }
  }
   else if (object != null) {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (equals_Ljava_lang_Object__Z__devirtual$(object, entry.getValue())) {
          $remove_34(this$static, i);
          return true;
        }
      }
    }
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (entry.getValue() == null) {
          $remove_34(this$static, i);
          return true;
        }
      }
    }
  }
  return false;
}

function $resolve_2(this$static, index_0, entry){
  var affiliatedFeature, affliatedEntry, entries, feature, featureIndex, i, inverseFeatureID, newEntry, notifications, object, opposite, reference, resolved, validator;
  feature = entry.getEStructuralFeature();
  if (instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0) {
    object = castTo(entry.getValue(), 46);
    resolved = $eResolveProxy(this$static.owner, object);
    if (resolved != object) {
      newEntry = createEntry_5(feature, resolved);
      $assign(this$static, index_0, $validate_3(this$static, index_0, newEntry));
      notifications = null;
      if ($eNotificationRequired(this$static.owner)) {
        affiliatedFeature = $getAffiliation(($clinit_ExtendedMetaData() , INSTANCE_11), this$static.owner.eClass_0(), feature);
        if (affiliatedFeature != $getEStructuralFeature(this$static.owner.eClass_0(), this$static.featureID)) {
          validator = getValidator(this$static.owner.eClass_0(), feature);
          featureIndex = 0;
          entries = castTo(this$static.data_0, 127);
          for (i = 0; i < index_0; ++i) {
            affliatedEntry = entries[i];
            validator.isValid(affliatedEntry.getEStructuralFeature()) && ++featureIndex;
          }
          notifications = new FeatureMapUtil$FeatureENotificationImpl(this$static.owner, 9, affiliatedFeature, object, resolved, featureIndex, false);
          notifications.add_4(new ENotificationImpl_3(this$static.owner, 9, this$static.featureID, entry, newEntry, index_0, false));
        }
      }
      reference = castTo(feature, 17);
      opposite = $getEOpposite(reference);
      if (opposite) {
        notifications = object.eInverseRemove(this$static.owner, $getFeatureID(object.eClass_0(), opposite), null, notifications);
        notifications = castTo(resolved, 46).eInverseAdd(this$static.owner, $getFeatureID(resolved.eClass_0(), opposite), null, notifications);
      }
       else if ((reference.eFlags & $intern_138) != 0) {
        inverseFeatureID = -1 - $getFeatureID(this$static.owner.eClass_0(), reference);
        notifications = object.eInverseRemove(this$static.owner, inverseFeatureID, null, null);
        !castTo(resolved, 46).eInternalContainer() && (notifications = castTo(resolved, 46).eInverseAdd(this$static.owner, inverseFeatureID, null, notifications));
      }
      !!notifications && notifications.dispatch_0();
      return newEntry;
    }
  }
  return entry;
}

function $resolveProxy_0(this$static, eObject){
  return $eResolveProxy(this$static.owner, castTo(eObject, 46));
}

function $resolveProxy_1(this$static, feature, entryIndex, index_0, object){
  var entry, notifications, oldObject, resolved;
  resolved = $resolveProxy_0(this$static, castTo(object, 51));
  if (maskUndefined(resolved) !== maskUndefined(object)) {
    oldObject = castTo(this$static.data_0[entryIndex], 76);
    entry = createEntry_5(feature, resolved);
    $assign(this$static, entryIndex, $validate_3(this$static, entryIndex, entry));
    if ($eNotificationRequired(this$static.owner)) {
      notifications = $createNotification_0(this$static, 9, entry.getEStructuralFeature(), object, resolved, index_0, false);
      $add_22(notifications, new ENotificationImpl_3(this$static.owner, 9, this$static.featureID, oldObject, entry, index_0, false));
      $dispatch(notifications);
    }
    return resolved;
  }
  return object;
}

function $set_13(this$static, index_0, object){
  var entries, entryFeature, i, otherEntry, validator;
  entryFeature = object.getEStructuralFeature();
  if (isMany_1(this$static.owner, entryFeature)) {
    if (entryFeature.isUnique()) {
      entries = castTo(this$static.data_0, 127);
      for (i = 0; i < this$static.size_0; ++i) {
        otherEntry = entries[i];
        if (equals_Ljava_lang_Object__Z__devirtual$(otherEntry, object) && i != index_0) {
          throw toJs(new IllegalArgumentException_0("The 'no duplicates' constraint is violated"));
        }
      }
    }
  }
   else {
    validator = getValidator(this$static.owner.eClass_0(), entryFeature);
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      otherEntry = entries[i];
      if (validator.isValid(otherEntry.getEStructuralFeature()) && i != index_0) {
        throw toJs(new IllegalArgumentException_0('The multiplicity constraint is violated'));
      }
    }
  }
  return castTo($set_8(this$static, index_0, object), 76);
}

function $set_14(this$static, newValue){
  $set_12(this$static, instanceOf(newValue, 188)?newValue:castTo(newValue, 1716).featureMap_0());
}

function $set_15(this$static, feature, index_0, object){
  var count, currentIndex, entries, entry, i, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entries = castTo(this$static.data_0, 127);
  if (isMany_1(this$static.owner, feature)) {
    if (feature.isUnique()) {
      currentIndex = $indexOf_8(this$static, feature, object, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0);
      if (currentIndex >= 0 && currentIndex != index_0) {
        throw toJs(new IllegalArgumentException_0("The 'no duplicates' constraint is violated"));
      }
    }
    count = 0;
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        if (count == index_0) {
          return castTo($set_8(this$static, i, ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0()?castTo(object, 76):createEntry_5(feature, object))), 76);
        }
        ++count;
      }
    }
    throw toJs(new IndexOutOfBoundsException_0('index=' + index_0 + ', size=' + count));
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        return $clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0()?entry:entry.getValue();
      }
    }
    return null;
  }
}

function $set_16(this$static, feature, object){
  var entries, entry, entryFeature, i, index_0, list, shouldUnset, validator;
  if (isMany_1(this$static.owner, feature)) {
    list = ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0()?new FeatureMapUtil$FeatureFeatureMap(feature, this$static):new FeatureMapUtil$FeatureEList(feature, this$static));
    $clear_13(list.featureMap, list.feature);
    $addAll_9(list, castTo(object, 13));
  }
   else {
    validator = getValidator(this$static.owner.eClass_0(), feature);
    entries = castTo(this$static.data_0, 127);
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      entryFeature = entry.getEStructuralFeature();
      if (validator.isValid(entryFeature)) {
        if (entryFeature == ($clinit_XMLTypeFeatures() , TEXT) || entryFeature == CDATA) {
          shouldUnset = $shouldUnset(this$static, feature, object);
          index_0 = i;
          shouldUnset?$remove_34(this$static, i):++i;
          while (i < this$static.size_0) {
            entry = entries[i];
            entryFeature = entry.getEStructuralFeature();
            entryFeature == TEXT || entryFeature == CDATA?$remove_34(this$static, i):++i;
          }
          shouldUnset || castTo($set_8(this$static, index_0, createEntry_5(feature, object)), 76);
        }
         else 
          $shouldUnset(this$static, feature, object)?$remove_34(this$static, i):castTo($set_8(this$static, i, ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0()?castTo(object, 76):createEntry_5(feature, object))), 76);
        return;
      }
    }
    $shouldUnset(this$static, feature, object) || $add_21(this$static, ($clinit_FeatureMapUtil() , castTo(feature, 63).isFeatureMap_0()?castTo(object, 76):createEntry_5(feature, object)));
  }
}

function $setting(this$static, feature){
  return isMany_1(this$static.owner, feature)?($clinit_FeatureMapUtil() , $isFeatureMap(feature)?new FeatureMapUtil$FeatureFeatureMap(feature, this$static):new FeatureMapUtil$FeatureEList(feature, this$static)):new FeatureMapUtil$FeatureValue(feature, this$static);
}

function $shadowAdd_1(this$static, entry, notifications){
  var feature, notification, value_0;
  feature = entry.getEStructuralFeature();
  value_0 = entry.getValue();
  notification = feature.isMany()?$createNotification_0(this$static, 3, feature, null, value_0, $indexOf_8(this$static, feature, value_0, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0), true):$createNotification_0(this$static, 1, feature, feature.getDefaultValue(), value_0, -1, true);
  notifications?notifications.add_4(notification):(notifications = notification);
  return notifications;
}

function $shadowAdd_2(this$static, object, notifications){
  return $shadowAdd_1(this$static, castTo(object, 319), notifications);
}

function $shadowRemove_1(this$static, entry, notifications){
  var feature, notification, value_0;
  feature = entry.getEStructuralFeature();
  value_0 = entry.getValue();
  notification = feature.isMany()?$createNotification_0(this$static, 4, feature, value_0, null, $indexOf_8(this$static, feature, value_0, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0), true):$createNotification_0(this$static, feature.isUnsettable()?2:1, feature, value_0, feature.getDefaultValue(), -1, true);
  notifications?notifications.add_4(notification):(notifications = notification);
  return notifications;
}

function $shadowRemove_2(this$static, object, notifications){
  return $shadowRemove_1(this$static, castTo(object, 319), notifications);
}

function $shadowSet_1(this$static, oldObject, newObject, notifications){
  var feature, newValue, notification, oldValue;
  if ($eNotificationRequired(this$static.owner)) {
    feature = oldObject.getEStructuralFeature();
    oldValue = oldObject.getValue();
    newValue = newObject.getValue();
    notification = $createNotification_0(this$static, 1, feature, oldValue, newValue, feature.isMany()?$indexOf_8(this$static, feature, newValue, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0):-1, true);
    notifications?notifications.add_4(notification):(notifications = notification);
  }
  return notifications;
}

function $shouldUnset(this$static, feature, value_0){
  var defaultValue;
  if (feature.isUnsettable()) {
    return false;
  }
   else if (feature.getUpperBound() != -2) {
    defaultValue = feature.getDefaultValue();
    return defaultValue == null?value_0 == null:equals_Ljava_lang_Object__Z__devirtual$(defaultValue, value_0);
  }
   else 
    return feature.getEContainingClass() == this$static.owner.eClass_0() && value_0 == null;
}

function $size_1(this$static, feature){
  var entries, entry, i, result, validator;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  result = 0;
  entries = castTo(this$static.data_0, 127);
  for (i = 0; i < this$static.size_0; ++i) {
    entry = entries[i];
    validator.isValid(entry.getEStructuralFeature()) && ++result;
  }
  return result;
}

function $toArray_7(this$static, feature){
  return $toArray_8(this$static, feature, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0);
}

function $toArray_8(this$static, feature, resolve){
  var entries, entry, i, result, validator, value_0;
  result = new BasicEList;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entries = castTo(this$static.data_0, 127);
  $clinit_FeatureMapUtil();
  if (castTo(feature, 63).isFeatureMap_0()) {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      validator.isValid(entry.getEStructuralFeature()) && $add_21(result, entry);
    }
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        value_0 = entry.getValue();
        $add_21(result, resolve?$resolveProxy_1(this$static, feature, i, result.size_0, value_0):value_0);
      }
    }
  }
  return $toArray_5(result);
}

function $toArray_9(this$static, feature, array){
  return $toArray_10(this$static, feature, array, instanceOf(feature, 66) && (castTo(castTo(feature, 17), 66).eFlags & $intern_66) != 0);
}

function $toArray_10(this$static, feature, array, resolve){
  var entries, entry, i, result, validator, value_0;
  result = new BasicEList;
  validator = getValidator(this$static.owner.eClass_0(), feature);
  entries = castTo(this$static.data_0, 127);
  $clinit_FeatureMapUtil();
  if (castTo(feature, 63).isFeatureMap_0()) {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      validator.isValid(entry.getEStructuralFeature()) && $add_21(result, entry);
    }
  }
   else {
    for (i = 0; i < this$static.size_0; ++i) {
      entry = entries[i];
      if (validator.isValid(entry.getEStructuralFeature())) {
        value_0 = entry.getValue();
        $add_21(result, resolve?$resolveProxy_1(this$static, feature, i, result.size_0, value_0):value_0);
      }
    }
  }
  return $toArray_6(result, array);
}

function $validate_3(this$static, index_0, object){
  var eStructuralFeature, result;
  if (this$static.modCount == 0)
    return object;
  result = castTo($validate_0(this$static, index_0, object), 76);
  eStructuralFeature = object.getEStructuralFeature();
  if (!eStructuralFeature.isChangeable() || !this$static.featureMapValidator.isValid(eStructuralFeature)) {
    throw toJs(new RuntimeException_0("Invalid entry feature '" + eStructuralFeature.getEContainingClass().name_0 + '.' + eStructuralFeature.getName() + "'"));
  }
  return result;
}

function BasicFeatureMap(owner, featureID){
  EDataTypeEList.call(this, Lorg_eclipse_emf_ecore_util_FeatureMap$Entry$Internal_2_classLit, owner, featureID);
  this.wrapper = this;
  this.featureMapValidator = getValidator(owner.eClass_0(), $getEStructuralFeature(this.owner.eClass_0(), this.featureID));
}

defineClass(91, 553, {3:1, 4:1, 20:1, 28:1, 43:1, 13:1, 15:1, 50:1, 61:1, 55:1, 52:1, 82:1, 188:1, 248:1, 1716:1, 69:1}, BasicFeatureMap);
_.add_3 = function add_64(index_0, object){
  $add_31(this, index_0, castTo(object, 76));
}
;
_.add_1 = function add_65(object){
  return $add_34(this, castTo(object, 76));
}
;
_.addUnique_0 = function addUnique_17(object){
  $addUnique_11(this, castTo(object, 76));
}
;
_.inverseAdd = function inverseAdd_9(object, notifications){
  return $inverseAdd_3(this, castTo(object, 76), notifications);
}
;
_.inverseRemove = function inverseRemove_9(object, notifications){
  return $inverseRemove_3(this, castTo(object, 76), notifications);
}
;
_.resolve = function resolve_9(index_0, entry){
  return $resolve_2(this, index_0, castTo(entry, 76));
}
;
_.set_2 = function set_35(index_0, object){
  return $set_13(this, index_0, castTo(object, 76));
}
;
_.shadowAdd = function shadowAdd_2(object, notifications){
  return $shadowAdd_2(this, castTo(object, 76), notifications);
}
;
_.shadowRemove = function shadowRemove_2(object, notifications){
  return $shadowRemove_2(this, castTo(object, 76), notifications);
}
;
_.shadowSet = function shadowSet_2(oldObject, newObject, notifications){
  return $shadowSet_1(this, castTo(oldObject, 76), castTo(newObject, 76), notifications);
}
;
_.validate = function validate_7(index_0, object){
  return $validate_3(this, index_0, castTo(object, 76));
}
;
_.addAll = function addAll_20(collection){
  var entries, entry, entry$iterator, entryFeature, include, j, otherEntry, uniqueCollection, validator;
  uniqueCollection = new BasicEList_0(collection.size_1());
  for (entry$iterator = collection.iterator_0(); entry$iterator.hasNext_0();) {
    entry = castTo(entry$iterator.next_1(), 76);
    entryFeature = entry.getEStructuralFeature();
    if (isMany_1(this.owner, entryFeature)) {
      (!entryFeature.isUnique() || !$contains_12(this, entryFeature, entry.getValue()) && !$contains_10(uniqueCollection, entry)) && $add_21(uniqueCollection, entry);
    }
     else {
      validator = getValidator(this.owner.eClass_0(), entryFeature);
      entries = castTo(this.data_0, 127);
      include = true;
      for (j = 0; j < this.size_0; ++j) {
        otherEntry = entries[j];
        if (validator.isValid(otherEntry.getEStructuralFeature())) {
          castTo($set_8(this, j, entry), 76);
          include = false;
          break;
        }
      }
      include && $add_21(uniqueCollection, entry);
    }
  }
  return $addAll_6(this, uniqueCollection);
}
;
_.addAllUnique = function addAllUnique_11(collection){
  this.modCount = -1;
  return $addAllUnique_3(this, this.size_0, collection);
}
;
_.basicAdd_0 = function basicAdd_4(feature, object, notifications){
  return $basicAdd_2(this, feature, object, notifications);
}
;
_.basicRemove = function basicRemove_4(object, notifications){
  return $basicRemove_2(this, object, notifications);
}
;
_.basicRemove_0 = function basicRemove_5(feature, object, notifications){
  return $basicRemove_3(this, feature, object, notifications);
}
;
_.featureMap_0 = function featureMap_0(){
  return this;
}
;
_.get_7 = function get_51(feature, resolve){
  return $get_20(this, feature, resolve);
}
;
_.getEStructuralFeature_0 = function getEStructuralFeature_2(index_0){
  return castTo($get_16(this, index_0), 76).getEStructuralFeature();
}
;
_.getValue_0 = function getValue_16(index_0){
  return castTo($get_16(this, index_0), 76).getValue();
}
;
_.getWrapper = function getWrapper(){
  return this.wrapper;
}
;
_.hasInverse = function hasInverse_11(){
  return true;
}
;
_.hasShadow = function hasShadow_2(){
  return true;
}
;
_.isSet_1 = function isSet_10(feature){
  return !$isEmpty_1(this, feature);
}
;
_.newData = function newData_14(capacity){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_util_FeatureMap$Entry$Internal_2_classLit, $intern_165, 319, capacity, 0, 1);
}
;
_.resolveProxy = function resolveProxy_0(eObject){
  return $resolveProxy_0(this, eObject);
}
;
_.set_1 = function set_36(newValue){
  $set_14(this, newValue);
}
;
_.set_3 = function set_37(feature, object){
  $set_16(this, feature, object);
}
;
_.setting = function setting_0(feature){
  return $setting(this, feature);
}
;
var Lorg_eclipse_emf_ecore_util_BasicFeatureMap_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'BasicFeatureMap', 91);
function $checkModCount(this$static){
  if (this$static.featureMap.modCount != this$static.expectedModCount) {
    throw toJs(new ConcurrentModificationException);
  }
}

function $hasNext_7(this$static){
  switch (this$static.prepared) {
    case 2:
      {
        return true;
      }

    case 1:
      {
        return false;
      }

    case -1:
      {
        ++this$static.entryCursor;
      }

    default:{
        return this$static.scanNext();
      }

  }
}

function $hasPrevious(this$static){
  switch (this$static.prepared) {
    case -2:
      {
        return true;
      }

    case -1:
      {
        return false;
      }

    case 1:
      {
        --this$static.entryCursor;
      }

    default:{
        return this$static.scanPrevious();
      }

  }
}

function $next_18(this$static){
  var newPreparedResult;
  if ($hasNext_7(this$static)) {
    $checkModCount(this$static);
    if (this$static.resolve_0()) {
      newPreparedResult = $resolveProxy_1(this$static.featureMap, this$static.eStructuralFeature, this$static.entryCursor, this$static.cursor, this$static.preparedResult);
      this$static.preparedResult = newPreparedResult;
    }
    this$static.lastCursor = this$static.cursor;
    ++this$static.cursor;
    ++this$static.entryCursor;
    this$static.prepared = 0;
    return this$static.preparedResult;
  }
   else {
    throw toJs(new NoSuchElementException);
  }
}

defineClass(1652, 1, $intern_18);
_.forEachRemaining = function forEachRemaining_52(consumer){
  $forEachRemaining(this, consumer);
}
;
_.add_2 = function add_66(o){
  if (this.lastCursor == -1) {
    throw toJs(new IllegalStateException);
  }
  $checkModCount(this);
  try {
    $add_32(this.featureMap, this.eStructuralFeature, this.cursor, o);
    this.expectedModCount = this.featureMap.modCount;
    $next_18(this);
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      throw toJs(new ConcurrentModificationException);
    }
     else 
      throw toJs($e0);
  }
}
;
_.hasNext_0 = function hasNext_49(){
  return $hasNext_7(this);
}
;
_.hasPrevious = function hasPrevious_12(){
  return $hasPrevious(this);
}
;
_.next_1 = function next_49(){
  return $next_18(this);
}
;
_.nextIndex_0 = function nextIndex_13(){
  return this.cursor;
}
;
_.previous_0 = function previous_13(){
  var newPreparedResult;
  if ($hasPrevious(this)) {
    $checkModCount(this);
    this.lastCursor = --this.cursor;
    if (this.resolve_0()) {
      newPreparedResult = $resolveProxy_1(this.featureMap, this.eStructuralFeature, this.entryCursor, this.cursor, this.preparedResult);
      this.preparedResult = newPreparedResult;
    }
    this.prepared = 0;
    return this.preparedResult;
  }
   else {
    throw toJs(new NoSuchElementException);
  }
}
;
_.previousIndex = function previousIndex_12(){
  return this.cursor - 1;
}
;
_.remove_0 = function remove_125(){
  if (this.lastCursor == -1) {
    throw toJs(new IllegalStateException);
  }
  $checkModCount(this);
  try {
    $remove_42(this.featureMap, this.eStructuralFeature, this.lastCursor);
    this.expectedModCount = this.featureMap.modCount;
    if (this.lastCursor < this.cursor) {
      --this.cursor;
      --this.entryCursor;
    }
    --this.lastCursor;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      throw toJs(new ConcurrentModificationException);
    }
     else 
      throw toJs($e0);
  }
}
;
_.resolve_0 = function resolve_10(){
  return false;
}
;
_.set_1 = function set_38(o){
  if (this.lastCursor == -1) {
    throw toJs(new IllegalStateException);
  }
  $checkModCount(this);
  try {
    $set_15(this.featureMap, this.eStructuralFeature, this.lastCursor, o);
    this.expectedModCount = this.featureMap.modCount;
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 80)) {
      throw toJs(new ConcurrentModificationException);
    }
     else 
      throw toJs($e0);
  }
}
;
_.cursor = 0;
_.entryCursor = 0;
_.expectedModCount = 0;
_.isFeatureMap = false;
_.lastCursor = 0;
_.prepared = 0;
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$BasicFeatureEIterator_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'FeatureMapUtil/BasicFeatureEIterator', 1652);
function BasicFeatureMap$FeatureEIterator(eStructuralFeature, featureMap){
  this.eStructuralFeature = eStructuralFeature;
  this.featureMap = featureMap;
  this.expectedModCount = featureMap.modCount;
  this.isFeatureMap = ($clinit_FeatureMapUtil() , castTo(eStructuralFeature, 63).isFeatureMap_0());
  this.validator = getValidator(featureMap.owner.eClass_0(), eStructuralFeature);
}

defineClass(391, 1652, $intern_18, BasicFeatureMap$FeatureEIterator);
_.scanNext = function scanNext(){
  var entries, entry, size_0;
  size_0 = this.featureMap.size_0;
  entries = castTo(this.featureMap.data_0, 127);
  while (this.entryCursor < size_0) {
    entry = entries[this.entryCursor];
    if (this.validator.isValid(entry.getEStructuralFeature())) {
      this.preparedResult = this.isFeatureMap?entry:entry.getValue();
      this.prepared = 2;
      return true;
    }
    ++this.entryCursor;
  }
  this.prepared = 1;
  this.lastCursor = -1;
  return false;
}
;
_.scanPrevious = function scanPrevious(){
  var entries, entry;
  entries = castTo(this.featureMap.data_0, 127);
  while (--this.entryCursor >= 0) {
    entry = entries[this.entryCursor];
    if (this.validator.isValid(entry.getEStructuralFeature())) {
      this.preparedResult = this.isFeatureMap?entry:entry.getValue();
      this.prepared = -2;
      return true;
    }
  }
  this.prepared = -1;
  this.lastCursor = -1;
  return false;
}
;
var Lorg_eclipse_emf_ecore_util_BasicFeatureMap$FeatureEIterator_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'BasicFeatureMap/FeatureEIterator', 391);
function BasicFeatureMap$ResolvingFeatureEIterator(eStructuralFeature, featureMap){
  BasicFeatureMap$FeatureEIterator.call(this, eStructuralFeature, featureMap);
}

defineClass(621, 391, $intern_18, BasicFeatureMap$ResolvingFeatureEIterator);
_.resolve_0 = function resolve_11(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_BasicFeatureMap$ResolvingFeatureEIterator_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'BasicFeatureMap/ResolvingFeatureEIterator', 621);
function EContentsEList$1(){
  EContentsEList.call(this, null, null);
}

defineClass(904, 460, $intern_159, EContentsEList$1);
_.basicList = function basicList_3(){
  return this;
}
;
var Lorg_eclipse_emf_ecore_util_EContentsEList$1_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EContentsEList/1', 904);
function EContentsEList$2($anonymous0, $anonymous1){
  EContentsEList.call(this, $anonymous0, $anonymous1);
}

defineClass(905, 460, $intern_159, EContentsEList$2);
_.resolve_0 = function resolve_12(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_util_EContentsEList$2_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EContentsEList/2', 905);
function EContentsEList$FeatureIteratorImpl$1(){
  EContentsEList$FeatureIteratorImpl.call(this, null, null);
}

defineClass(903, 272, $intern_160, EContentsEList$FeatureIteratorImpl$1);
_.filter_0 = function filter_3(featureFilter){
}
;
_.hasNext_0 = function hasNext_50(){
  return false;
}
;
_.hasPrevious = function hasPrevious_13(){
  return false;
}
;
var Lorg_eclipse_emf_ecore_util_EContentsEList$FeatureIteratorImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EContentsEList/FeatureIteratorImpl/1', 903);
function EDataTypeEList$Unsettable(dataClass, owner, featureID){
  EDataTypeEList.call(this, dataClass, owner, featureID);
}

defineClass(762, 553, $intern_156, EDataTypeEList$Unsettable);
_.didChange = function didChange_2(){
  this.isSet = true;
}
;
_.isSet_0 = function isSet_11(){
  return this.isSet;
}
;
_.unset = function unset_6(){
  var oldIsSet;
  $clear_11(this);
  if ($eNotificationRequired(this.owner)) {
    oldIsSet = this.isSet;
    this.isSet = false;
    $eNotify(this.owner, new ENotificationImpl_4(this.owner, 2, this.featureID, oldIsSet, false));
  }
   else {
    this.isSet = false;
  }
}
;
_.isSet = false;
var Lorg_eclipse_emf_ecore_util_EDataTypeEList$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EDataTypeEList/Unsettable', 762);
function EDataTypeUniqueEList(dataClass, owner, featureID){
  EDataTypeEList.call(this, dataClass, owner, featureID);
}

defineClass(1650, 553, $intern_156, EDataTypeUniqueEList);
_.isUnique = function isUnique_8(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_EDataTypeUniqueEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EDataTypeUniqueEList', 1650);
function EDataTypeUniqueEList$Unsettable(dataClass, owner, featureID){
  EDataTypeEList$Unsettable.call(this, dataClass, owner, featureID);
}

defineClass(1651, 762, $intern_156, EDataTypeUniqueEList$Unsettable);
_.isUnique = function isUnique_9(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_EDataTypeUniqueEList$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EDataTypeUniqueEList/Unsettable', 1651);
function EObjectContainmentEList$Resolving(dataClass, owner, featureID){
  EObjectContainmentEList.call(this, dataClass, owner, featureID);
}

defineClass(157, 84, $intern_156, EObjectContainmentEList$Resolving);
_.hasProxies = function hasProxies_4(){
  return true;
}
;
_.resolve = function resolve_13(index_0, object){
  return $resolve(this, index_0, castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_util_EObjectContainmentEList$Resolving_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectContainmentEList/Resolving', 157);
function EObjectContainmentEList$Unsettable$Resolving(dataClass, owner, featureID){
  EObjectContainmentEList$Unsettable.call(this, dataClass, owner, featureID);
}

defineClass(1051, 509, $intern_156, EObjectContainmentEList$Unsettable$Resolving);
_.hasProxies = function hasProxies_5(){
  return true;
}
;
_.resolve = function resolve_14(index_0, object){
  return $resolve(this, index_0, castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_util_EObjectContainmentEList$Unsettable$Resolving_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectContainmentEList/Unsettable/Resolving', 1051);
function EObjectContainmentWithInverseEList$Unsettable(dataClass, owner, featureID, inverseFeatureID){
  EObjectContainmentWithInverseEList.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(697, 18, $intern_156, EObjectContainmentWithInverseEList$Unsettable);
_.didChange = function didChange_3(){
  this.isSet = true;
}
;
_.isSet_0 = function isSet_12(){
  return this.isSet;
}
;
_.unset = function unset_7(){
  var oldIsSet;
  $clear_11(this);
  if ($eNotificationRequired(this.owner)) {
    oldIsSet = this.isSet;
    this.isSet = false;
    $eNotify(this.owner, new ENotificationImpl_4(this.owner, 2, this.featureID, oldIsSet, false));
  }
   else {
    this.isSet = false;
  }
}
;
_.isSet = false;
var Lorg_eclipse_emf_ecore_util_EObjectContainmentWithInverseEList$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectContainmentWithInverseEList/Unsettable', 697);
function EObjectContainmentWithInverseEList$Unsettable$Resolving(dataClass, owner, featureID, inverseFeatureID){
  EObjectContainmentWithInverseEList$Unsettable.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(1130, 697, $intern_156, EObjectContainmentWithInverseEList$Unsettable$Resolving);
_.hasProxies = function hasProxies_6(){
  return true;
}
;
_.resolve = function resolve_15(index_0, object){
  return $resolve(this, index_0, castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_util_EObjectContainmentWithInverseEList$Unsettable$Resolving_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectContainmentWithInverseEList/Unsettable/Resolving', 1130);
function EObjectEList$Unsettable(dataClass, owner, featureID){
  EObjectEList.call(this, dataClass, owner, featureID);
}

defineClass(692, 466, $intern_156, EObjectEList$Unsettable);
_.didChange = function didChange_4(){
  this.isSet = true;
}
;
_.isSet_0 = function isSet_13(){
  return this.isSet;
}
;
_.unset = function unset_8(){
  var oldIsSet;
  $clear_11(this);
  if ($eNotificationRequired(this.owner)) {
    oldIsSet = this.isSet;
    this.isSet = false;
    $eNotify(this.owner, new ENotificationImpl_4(this.owner, 2, this.featureID, oldIsSet, false));
  }
   else {
    this.isSet = false;
  }
}
;
_.isSet = false;
var Lorg_eclipse_emf_ecore_util_EObjectEList$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectEList/Unsettable', 692);
function EObjectResolvingEList(dataClass, owner, featureID){
  EObjectEList.call(this, dataClass, owner, featureID);
}

defineClass(387, 466, $intern_156, EObjectResolvingEList);
_.hasProxies = function hasProxies_7(){
  return true;
}
;
_.resolve = function resolve_16(index_0, object){
  return $resolve(this, index_0, castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_util_EObjectResolvingEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectResolvingEList', 387);
function EObjectResolvingEList$Unsettable(dataClass, owner, featureID){
  EObjectEList$Unsettable.call(this, dataClass, owner, featureID);
}

defineClass(1594, 692, $intern_156, EObjectResolvingEList$Unsettable);
_.hasProxies = function hasProxies_8(){
  return true;
}
;
_.resolve = function resolve_17(index_0, object){
  return $resolve(this, index_0, castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_util_EObjectResolvingEList$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectResolvingEList/Unsettable', 1594);
function $clinit_EObjectValidator(){
  $clinit_EObjectValidator = emptyMethod;
  INSTANCE_9 = new EObjectValidator;
}

function EObjectValidator(){
}

defineClass(1338, 1, {}, EObjectValidator);
var INSTANCE_9;
var Lorg_eclipse_emf_ecore_util_EObjectValidator_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectValidator', 1338);
function EObjectWithInverseEList(dataClass, owner, featureID, inverseFeatureID){
  EObjectEList.call(this, dataClass, owner, featureID);
  this.inverseFeatureID = inverseFeatureID;
}

defineClass(521, 466, $intern_156, EObjectWithInverseEList);
_.getInverseFeatureClass = function getInverseFeatureClass_1(){
  return this.dataClass;
}
;
_.getInverseFeatureID = function getInverseFeatureID_1(){
  return this.inverseFeatureID;
}
;
_.hasInverse = function hasInverse_12(){
  return true;
}
;
_.hasNavigableInverse = function hasNavigableInverse_5(){
  return true;
}
;
_.inverseFeatureID = 0;
var Lorg_eclipse_emf_ecore_util_EObjectWithInverseEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectWithInverseEList', 521);
function EObjectWithInverseEList$ManyInverse(dataClass, owner, featureID, inverseFeatureID){
  EObjectWithInverseEList.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(1135, 521, $intern_156, EObjectWithInverseEList$ManyInverse);
_.hasManyInverse = function hasManyInverse_3(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_EObjectWithInverseEList$ManyInverse_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectWithInverseEList/ManyInverse', 1135);
function EObjectWithInverseEList$Unsettable(dataClass, owner, featureID, inverseFeatureID){
  EObjectWithInverseEList.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(594, 521, $intern_156, EObjectWithInverseEList$Unsettable);
_.didChange = function didChange_5(){
  this.isSet = true;
}
;
_.isSet_0 = function isSet_14(){
  return this.isSet;
}
;
_.unset = function unset_9(){
  var oldIsSet;
  $clear_11(this);
  if ($eNotificationRequired(this.owner)) {
    oldIsSet = this.isSet;
    this.isSet = false;
    $eNotify(this.owner, new ENotificationImpl_4(this.owner, 2, this.featureID, oldIsSet, false));
  }
   else {
    this.isSet = false;
  }
}
;
_.isSet = false;
var Lorg_eclipse_emf_ecore_util_EObjectWithInverseEList$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectWithInverseEList/Unsettable', 594);
function EObjectWithInverseEList$Unsettable$ManyInverse(dataClass, owner, featureID, inverseFeatureID){
  EObjectWithInverseEList$Unsettable.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(1134, 594, $intern_156, EObjectWithInverseEList$Unsettable$ManyInverse);
_.hasManyInverse = function hasManyInverse_4(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_EObjectWithInverseEList$Unsettable$ManyInverse_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectWithInverseEList/Unsettable/ManyInverse', 1134);
function EObjectWithInverseResolvingEList(dataClass, owner, featureID, inverseFeatureID){
  EObjectWithInverseEList.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(700, 521, $intern_156, EObjectWithInverseResolvingEList);
_.hasProxies = function hasProxies_9(){
  return true;
}
;
_.resolve = function resolve_18(index_0, object){
  return $resolve(this, index_0, castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_util_EObjectWithInverseResolvingEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectWithInverseResolvingEList', 700);
function EObjectWithInverseResolvingEList$ManyInverse(dataClass, owner, featureID, inverseFeatureID){
  EObjectWithInverseResolvingEList.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(31, 700, $intern_156, EObjectWithInverseResolvingEList$ManyInverse);
_.hasManyInverse = function hasManyInverse_5(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_EObjectWithInverseResolvingEList$ManyInverse_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectWithInverseResolvingEList/ManyInverse', 31);
function EObjectWithInverseResolvingEList$Unsettable(dataClass, owner, featureID, inverseFeatureID){
  EObjectWithInverseEList$Unsettable.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(701, 594, $intern_156, EObjectWithInverseResolvingEList$Unsettable);
_.hasProxies = function hasProxies_10(){
  return true;
}
;
_.resolve = function resolve_19(index_0, object){
  return $resolve(this, index_0, castTo(object, 51));
}
;
var Lorg_eclipse_emf_ecore_util_EObjectWithInverseResolvingEList$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectWithInverseResolvingEList/Unsettable', 701);
function EObjectWithInverseResolvingEList$Unsettable$ManyInverse(dataClass, owner, featureID, inverseFeatureID){
  EObjectWithInverseResolvingEList$Unsettable.call(this, dataClass, owner, featureID, inverseFeatureID);
}

defineClass(1133, 701, $intern_156, EObjectWithInverseResolvingEList$Unsettable$ManyInverse);
_.hasManyInverse = function hasManyInverse_6(){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_EObjectWithInverseResolvingEList$Unsettable$ManyInverse_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EObjectWithInverseResolvingEList/Unsettable/ManyInverse', 1133);
function kind_0(eStructuralFeature){
  var eClassifier, eReference, instanceClass, inverseEReference, result, upper;
  result = 0;
  eClassifier = $getEType(eStructuralFeature);
  !!eClassifier.getInstanceClass() && (result |= 4);
  (eStructuralFeature.eFlags & $intern_151) != 0 && (result |= 2);
  if (instanceOf(eStructuralFeature, 66)) {
    eReference = castTo(eStructuralFeature, 17);
    inverseEReference = $getEOpposite(eReference);
    (eReference.eFlags & $intern_138) != 0 && (result |= 32);
    if (inverseEReference) {
      $getFeatureCount($getEContainingClass(inverseEReference));
      result |= 8;
      upper = inverseEReference.upperBound;
      (upper > 1 || upper == -1) && (result |= 16);
      (inverseEReference.eFlags & $intern_138) != 0 && (result |= 64);
    }
    (eReference.eFlags & $intern_66) != 0 && (result |= $intern_152);
    result |= $intern_89;
  }
   else {
    if (instanceOf(eClassifier, 436)) {
      result |= 512;
    }
     else {
      instanceClass = eClassifier.getInstanceClass();
      !!instanceClass && (instanceClass.modifiers & 1) != 0 && (result |= 256);
    }
  }
  (eStructuralFeature.eFlags & 512) != 0 && (result |= 128);
  return result;
}

defineClass(1052, 589, $intern_156);
_.canContainNull = function canContainNull_6(){
  return (this.kind & 1792) == 0;
}
;
_.didChange = function didChange_6(){
  this.kind |= 1;
}
;
_.hasInstanceClass = function hasInstanceClass_3(){
  return (this.kind & 4) != 0;
}
;
_.hasInverse = function hasInverse_13(){
  return (this.kind & 40) != 0;
}
;
_.hasManyInverse = function hasManyInverse_7(){
  return (this.kind & 16) != 0;
}
;
_.hasNavigableInverse = function hasNavigableInverse_6(){
  return (this.kind & 8) != 0;
}
;
_.hasProxies = function hasProxies_11(){
  return (this.kind & $intern_152) != 0;
}
;
_.isContainment = function isContainment_9(){
  return (this.kind & 32) != 0;
}
;
_.isEObject = function isEObject_5(){
  return (this.kind & $intern_89) != 0;
}
;
_.isInstance = function isInstance_49(object){
  return !this.dataClass?this.getEStructuralFeature().getEType().isInstance(object):isInstance(this.dataClass, object);
}
;
_.isSet_0 = function isSet_15(){
  return (this.kind & 2) != 0?(this.kind & 1) != 0:this.size_0 != 0;
}
;
_.isUnique = function isUnique_10(){
  return (this.kind & 128) != 0;
}
;
_.unset = function unset_10(){
  var oldIsSet;
  $clear_11(this);
  if ((this.kind & 2) != 0) {
    if ($eNotificationRequired(this.owner)) {
      oldIsSet = (this.kind & 1) != 0;
      this.kind &= -2;
      $dispatchNotification(this, new ENotificationImpl_4(this.owner, 2, $getFeatureID(this.owner.eClass_0(), this.getEStructuralFeature()), oldIsSet, false));
    }
     else {
      this.kind &= -2;
    }
  }
}
;
_.useEquals = function useEquals_15(){
  return (this.kind & 1536) == 0;
}
;
_.kind = 0;
var Lorg_eclipse_emf_ecore_util_EcoreEList$Generic_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEList/Generic', 1052);
function EcoreEList$Dynamic(kind, dataClass, owner, eStructuralFeature){
  EcoreEList.call(this, dataClass, owner);
  this.kind = kind;
  this.eStructuralFeature = eStructuralFeature;
}

defineClass(1053, 1052, $intern_156, EcoreEList$Dynamic);
_.getEStructuralFeature = function getEStructuralFeature_3(){
  return this.eStructuralFeature;
}
;
var Lorg_eclipse_emf_ecore_util_EcoreEList$Dynamic_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEList/Dynamic', 1053);
function EcoreEMap$1(this$0){
  this.this$01 = this$0;
}

defineClass(699, 55, $intern_141, EcoreEMap$1);
_.newData = function newData_15(listCapacity){
  return newInstance_10(this.this$01.entryClass, listCapacity);
}
;
var Lorg_eclipse_emf_ecore_util_EcoreEMap$1_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEMap/1', 699);
function EcoreEMap$DelegateEObjectContainmentEList(this$0, entryClass, owner, featureID){
  this.this$01 = this$0;
  EObjectContainmentEList.call(this, entryClass, owner, featureID);
}

defineClass(698, 84, $intern_156, EcoreEMap$DelegateEObjectContainmentEList);
_.didAdd = function didAdd_4(index_0, newObject){
  $doPut(this.this$01, castTo(newObject, 140));
}
;
_.didClear = function didClear_2(size_0, oldObjects){
  $doClear_0(this.this$01);
}
;
_.didRemove = function didRemove_3(index_0, oldObject){
  $doRemove(this.this$01, castTo(oldObject, 140));
}
;
_.didSet = function didSet_2(index_0, newObject, oldObject){
  $doRemove(this.this$01, castTo(oldObject, 140));
  maskUndefined(oldObject) === maskUndefined(newObject) && castTo(oldObject, 140).setHash($hashOf(castTo(newObject, 140).getKey()));
  $doPut(this.this$01, castTo(newObject, 140));
}
;
var Lorg_eclipse_emf_ecore_util_EcoreEMap$DelegateEObjectContainmentEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEMap/DelegateEObjectContainmentEList', 698);
function EcoreEMap$Unsettable(entryEClass, entryClass, owner, featureID){
  this.initializeDelegateEList();
  this.entryClass = entryClass;
  this.entryEClass = entryEClass;
  this.delegateEList = null;
  this.delegateEList = new EcoreEMap$Unsettable$UnsettableDelegateEObjectContainmentEList(this, entryClass, owner, featureID);
}

defineClass(1131, 146, $intern_150, EcoreEMap$Unsettable);
var Lorg_eclipse_emf_ecore_util_EcoreEMap$Unsettable_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEMap/Unsettable', 1131);
function EcoreEMap$Unsettable$UnsettableDelegateEObjectContainmentEList(this$1, dataClass, owner, featureID){
  EcoreEMap$DelegateEObjectContainmentEList.call(this, this$1, dataClass, owner, featureID);
}

defineClass(1132, 698, $intern_156, EcoreEMap$Unsettable$UnsettableDelegateEObjectContainmentEList);
_.didChange = function didChange_7(){
  this.isSet = true;
}
;
_.isSet_0 = function isSet_16(){
  return this.isSet;
}
;
_.unset = function unset_11(){
  var oldIsSet;
  $clear_11(this);
  if ($eNotificationRequired(this.owner)) {
    oldIsSet = this.isSet;
    this.isSet = false;
    $eNotify(this.owner, new ENotificationImpl_4(this.owner, 2, this.featureID, oldIsSet, false));
  }
   else {
    this.isSet = false;
  }
}
;
_.isSet = false;
var Lorg_eclipse_emf_ecore_util_EcoreEMap$Unsettable$UnsettableDelegateEObjectContainmentEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreEMap/Unsettable/UnsettableDelegateEObjectContainmentEList', 1132);
function convertToString_2(eDataType, value_0){
  return eDataType.getEPackage().getEFactoryInstance().convertToString(eDataType, value_0);
}

function createFromString_2(eDataType, literal){
  return eDataType.getEPackage().getEFactoryInstance().createFromString(eDataType, literal);
}

function getConversionDelegateFactory(eDataType){
  var eDataTypeDelegate, eDataTypeDelegate$iterator;
  for (eDataTypeDelegate$iterator = getConversionDelegates($getEPackage(eDataType)).iterator_0(); eDataTypeDelegate$iterator.hasNext_0();) {
    eDataTypeDelegate = castToString(eDataTypeDelegate$iterator.next_1());
    if ($getEAnnotation(eDataType, eDataTypeDelegate)) {
      return $getFactory(($clinit_EDataType$Internal$ConversionDelegate$Factory$Registry() , INSTANCE_5), eDataTypeDelegate);
    }
  }
  return null;
}

function getConversionDelegates(ePackage){
  var eAnnotation, eDataTypeDelegate, eDataTypeDelegate$array, eDataTypeDelegate$index, eDataTypeDelegate$max, eDataTypeDelegates, result;
  if (ePackage) {
    eAnnotation = ePackage.getEAnnotation('http://www.eclipse.org/emf/2002/Ecore');
    if (eAnnotation) {
      eDataTypeDelegates = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'conversionDelegates'));
      if (eDataTypeDelegates != null) {
        result = new ArrayList;
        for (eDataTypeDelegate$array = $split_0(eDataTypeDelegates, '\\w+') , eDataTypeDelegate$index = 0 , eDataTypeDelegate$max = eDataTypeDelegate$array.length; eDataTypeDelegate$index < eDataTypeDelegate$max; ++eDataTypeDelegate$index) {
          eDataTypeDelegate = eDataTypeDelegate$array[eDataTypeDelegate$index];
          result.array[result.array.length] = eDataTypeDelegate;
        }
        return result;
      }
    }
  }
  return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
}

function getRootContainer(eObject){
  var count, parent_0, result;
  result = eObject;
  if (eObject) {
    count = 0;
    for (parent_0 = eObject.eContainer_0(); parent_0; parent_0 = parent_0.eContainer_0()) {
      if (++count > $intern_70) {
        return getRootContainer(parent_0);
      }
      result = parent_0;
      if (parent_0 == eObject) {
        throw toJs(new IllegalStateException_0('There is a cycle in the containment hierarchy of ' + eObject));
      }
    }
  }
  return result;
}

function getSettingDelegateFactory(eStructuralFeature){
  var settingDelegate, settingDelegate$iterator;
  for (settingDelegate$iterator = getSettingDelegates($getEPackage($getEContainingClass(eStructuralFeature))).iterator_0(); settingDelegate$iterator.hasNext_0();) {
    settingDelegate = castToString(settingDelegate$iterator.next_1());
    if ($getEAnnotation(eStructuralFeature, settingDelegate))
      return $getFactory_0(($clinit_EStructuralFeature$Internal$SettingDelegate$Factory$Registry() , INSTANCE_7), settingDelegate);
  }
  return null;
}

function getSettingDelegates(ePackage){
  var eAnnotation, result, settingDelegate, settingDelegate$array, settingDelegate$index, settingDelegate$max, settingDelegates;
  eAnnotation = ePackage.getEAnnotation('http://www.eclipse.org/emf/2002/Ecore');
  if (eAnnotation) {
    settingDelegates = castToString($get_17((!eAnnotation.details && (eAnnotation.details = new EAnnotationImpl$1(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, eAnnotation)) , eAnnotation.details), 'settingDelegates'));
    if (settingDelegates != null) {
      result = new ArrayList;
      for (settingDelegate$array = $split_0(settingDelegates, '\\w+') , settingDelegate$index = 0 , settingDelegate$max = settingDelegate$array.length; settingDelegate$index < settingDelegate$max; ++settingDelegate$index) {
        settingDelegate = settingDelegate$array[settingDelegate$index];
        result.array[result.array.length] = settingDelegate;
      }
      return result;
    }
  }
  return $clinit_Collections() , $clinit_Collections() , EMPTY_LIST;
}

function isAncestor(ancestorEObject, eObject){
  var count, eContainer;
  if (eObject) {
    if (eObject == ancestorEObject) {
      return true;
    }
    count = 0;
    for (eContainer = castTo(eObject, 46).eInternalContainer(); !!eContainer && eContainer != eObject; eContainer = eContainer.eInternalContainer()) {
      if (++count > $intern_70) {
        return isAncestor(ancestorEObject, eContainer);
      }
      if (eContainer == ancestorEObject) {
        return true;
      }
    }
  }
  return false;
}

function resolve_20(proxy){
  var ePackage, proxyURI, resolvedObject, resource;
  proxyURI = castTo(proxy, 46).eProxyURI_0();
  if (proxyURI) {
    try {
      resolvedObject = null;
      ePackage = $getEPackage_0(($clinit_EPackage$Registry() , INSTANCE_6), $toString_22($trimFragment(proxyURI)));
      if (ePackage) {
        resource = ePackage.eResource_0();
        !!resource && (resolvedObject = resource.getEObject(castToString(checkNotNull_1(proxyURI.fragment))));
      }
      if (!!resolvedObject && resolvedObject != proxy) {
        return resolve_20(resolvedObject);
      }
    }
     catch ($e0) {
      $e0 = toJava($e0);
      if (!instanceOf($e0, 54))
        throw toJs($e0);
    }
  }
  return proxy;
}

function wrapperClassFor(javaClass){
  return !javaClass?null:(javaClass.modifiers & 1) != 0?javaClass == Z_classLit?Ljava_lang_Boolean_2_classLit:javaClass == I_classLit?Ljava_lang_Integer_2_classLit:javaClass == F_classLit?Ljava_lang_Float_2_classLit:javaClass == D_classLit?Ljava_lang_Double_2_classLit:javaClass == J_classLit?Ljava_lang_Long_2_classLit:javaClass == S_classLit?Ljava_lang_Short_2_classLit:javaClass == B_classLit?Ljava_lang_Byte_2_classLit:Ljava_lang_Character_2_classLit:javaClass;
}

function $hasNext_8(this$static){
  if (this$static.preparedResult == null) {
    while (this$static.iterator.hasNext_0()) {
      this$static.preparedResult = this$static.iterator.next_1();
      if (!castTo(this$static.preparedResult, 46).eDirectResource()) {
        return true;
      }
    }
    this$static.preparedResult = null;
    return false;
  }
   else {
    return true;
  }
}

function EcoreUtil$ProperContentIterator(eObject){
  var contents;
  contents = eObject.eContents_0();
  this.iterator = instanceOf(contents, 69)?castTo(contents, 69).basicIterator():contents.iterator_0();
}

defineClass(688, 1, $intern_4, EcoreUtil$ProperContentIterator);
_.forEachRemaining = function forEachRemaining_53(consumer){
  $forEachRemaining(this, consumer);
}
;
_.hasNext_0 = function hasNext_51(){
  return $hasNext_8(this);
}
;
_.next_1 = function next_50(){
  var result;
  $hasNext_8(this);
  result = this.preparedResult;
  this.preparedResult = null;
  return result;
}
;
_.remove_0 = function remove_126(){
  this.iterator.remove_0();
}
;
var Lorg_eclipse_emf_ecore_util_EcoreUtil$ProperContentIterator_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreUtil/ProperContentIterator', 688);
function $clinit_EcoreValidator(){
  $clinit_EcoreValidator = emptyMethod;
  $clinit_EObjectValidator();
  INSTANCE_10 = new EcoreValidator;
}

function EcoreValidator(){
  $clinit_XMLTypeValidator();
}

defineClass(1339, 1338, {}, EcoreValidator);
var INSTANCE_10;
var Lorg_eclipse_emf_ecore_util_EcoreValidator_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'EcoreValidator', 1339);
function $clinit_FeatureMapUtil(){
  $clinit_FeatureMapUtil = emptyMethod;
  NULL_VALIDATOR = new FeatureMapUtil$1;
}

function createEntry_5(eStructuralFeature, value_0){
  $clinit_FeatureMapUtil();
  var prototype_0;
  prototype_0 = castTo(eStructuralFeature, 63).getFeatureMapEntryPrototype();
  $validate_2(prototype_0, value_0);
  return prototype_0.createEntry(value_0);
}

function getValidator(containingClass, eStructuralFeature){
  $clinit_FeatureMapUtil();
  var extendedMetaData, holder, result, validatorMap;
  if (!eStructuralFeature) {
    return NULL_VALIDATOR;
  }
   else if (eStructuralFeature == ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__MIXED) || (eStructuralFeature == ANY_TYPE__MIXED || eStructuralFeature == ANY_TYPE__ANY || eStructuralFeature == ANY_TYPE__ANY_ATTRIBUTE) && containingClass != ANY_TYPE) {
    return new FeatureMapUtil$BasicValidator(containingClass, eStructuralFeature);
  }
   else {
    holder = castTo(eStructuralFeature, 634);
    extendedMetaData = holder.getExtendedMetaData_0();
    if (!extendedMetaData) {
      $getName_2($getExtendedMetaData_1(($clinit_ExtendedMetaData() , INSTANCE_11), eStructuralFeature));
      extendedMetaData = holder.getExtendedMetaData_0();
    }
    validatorMap = (!extendedMetaData.validatorMap && (extendedMetaData.validatorMap = new HashMap) , extendedMetaData.validatorMap);
    result = castTo(getEntryValueOrNull($getEntry(validatorMap.hashCodeMap, containingClass)), 1721);
    !result && $put_1(validatorMap, containingClass, result = new FeatureMapUtil$BasicValidator(containingClass, eStructuralFeature));
    return result;
  }
}

function isMany_1(owner, feature){
  $clinit_FeatureMapUtil();
  var affiliation, affiliationUpperBound, eClass;
  if (feature.isMany()) {
    return true;
  }
   else if (feature.getUpperBound() == -2) {
    if (feature == ($clinit_XMLTypeFeatures() , TEXT) || feature == CDATA || feature == COMMENT || feature == PROCESSING_INSTRUCTION) {
      return true;
    }
     else {
      eClass = owner.eClass_0();
      if ($getFeatureID(eClass, feature) >= 0) {
        return false;
      }
       else {
        affiliation = $getAffiliation(($clinit_ExtendedMetaData() , INSTANCE_11), eClass, feature);
        if (!affiliation) {
          return true;
        }
         else {
          affiliationUpperBound = affiliation.getUpperBound();
          return (affiliationUpperBound > 1 || affiliationUpperBound == -1) && $getFeatureKind($getExtendedMetaData_1(INSTANCE_11, affiliation)) != 3;
        }
      }
    }
  }
   else {
    return false;
  }
}

var NULL_VALIDATOR;
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$Validator_2_classLit = createForInterface('org.eclipse.emf.ecore.util', 'FeatureMapUtil/Validator');
function FeatureMapUtil$1(){
}

defineClass(1161, 1, {1721:1}, FeatureMapUtil$1);
_.isValid = function isValid_0(eStructuralFeature){
  return true;
}
;
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$1_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'FeatureMapUtil/1', 1161);
function $clinit_FeatureMapUtil$BasicValidator(){
  $clinit_FeatureMapUtil$BasicValidator = emptyMethod;
  ANY_WILDCARD = ($clinit_Collections() , new Collections$SingletonList('##any'));
}

function $isIncluded(this$static, feature){
  var featureKind;
  if (this$static.wildcards == ANY_WILDCARD) {
    featureKind = $getFeatureKind($getExtendedMetaData_1(($clinit_ExtendedMetaData() , INSTANCE_11), feature));
    return this$static.isElement?featureKind == 4 && feature != ($clinit_XMLTypeFeatures() , TEXT) && feature != ($clinit_XMLTypeFeatures() , CDATA) && feature != ($clinit_XMLTypeFeatures() , COMMENT) && feature != ($clinit_XMLTypeFeatures() , PROCESSING_INSTRUCTION):featureKind == 2;
  }
  if (!!this$static.groupMembers && (this$static.groupMembers.contains(feature) || this$static.groupMembers.contains($getGroup($getExtendedMetaData_1(($clinit_ExtendedMetaData() , INSTANCE_11), feature))) || this$static.groupMembers.contains($getAffiliation(($clinit_ExtendedMetaData() , INSTANCE_11), this$static.containingClass, feature)))) {
    return true;
  }
  if (this$static.wildcards) {
    if ($matches(($clinit_ExtendedMetaData() , this$static.wildcards), $getNamespace_0($getExtendedMetaData_1(INSTANCE_11, feature)))) {
      featureKind = $getFeatureKind($getExtendedMetaData_1(INSTANCE_11, feature));
      return this$static.isElement?featureKind == 4:featureKind == 2;
    }
  }
  return false;
}

function FeatureMapUtil$BasicValidator(containingClass, eStructuralFeature){
  $clinit_FeatureMapUtil$BasicValidator();
  var eAllStructuralFeaturesData, feature, feature$iterator, group, i, mixedFeature, size_0;
  this.cache = new FeatureMapUtil$BasicValidator$Cache(this);
  this.containingClass = containingClass;
  this.eStructuralFeature = eStructuralFeature;
  this.wildcards = $getWildcards($getExtendedMetaData_1(($clinit_ExtendedMetaData() , INSTANCE_11), eStructuralFeature));
  if (this.wildcards.isEmpty()) {
    if ((mixedFeature = $getMixedFeature(INSTANCE_11, containingClass)) == eStructuralFeature) {
      this.isElement = true;
      this.groupMembers = new ArrayList;
      this.wildcards = new UniqueEList;
      this.wildcards.add_1('http://www.eclipse.org/emf/2003/XMLType');
      castTo($getType_1($getExtendedMetaData_0(INSTANCE_11, $getEPackage(containingClass)), ''), 26) == containingClass && this.wildcards.add_1($getNamespace(INSTANCE_11, $getEPackage(containingClass)));
      for (feature$iterator = $getAllElements(INSTANCE_11, containingClass).iterator_0(); feature$iterator.hasNext_0();) {
        feature = castTo(feature$iterator.next_1(), 159);
        switch ($getFeatureKind($getExtendedMetaData_1(INSTANCE_11, feature))) {
          case 4:
            {
              this.groupMembers.add_1(feature);
              break;
            }

          case 5:
            {
              this.wildcards.addAll($getWildcards($getExtendedMetaData_1(INSTANCE_11, feature)));
              break;
            }

        }
      }
    }
     else {
      $clinit_FeatureMapUtil();
      if (castTo(eStructuralFeature, 63).isFeatureMap_0()) {
        this.isElement = true;
        this.wildcards = null;
        this.groupMembers = new ArrayList;
        for (i = 0 , size_0 = (containingClass.eAllStructuralFeaturesData == null && $getEAllStructuralFeatures(containingClass) , containingClass.eAllStructuralFeaturesData).length; i < size_0; ++i) {
          feature = (eAllStructuralFeaturesData = (containingClass.eAllStructuralFeaturesData == null && $getEAllStructuralFeatures(containingClass) , containingClass.eAllStructuralFeaturesData) , i >= 0 && i < eAllStructuralFeaturesData.length?eAllStructuralFeaturesData[i]:null);
          for (group = $getGroup($getExtendedMetaData_1(INSTANCE_11, feature)); group; group = $getGroup($getExtendedMetaData_1(INSTANCE_11, group))) {
            group == eStructuralFeature && this.groupMembers.add_1(feature);
          }
        }
      }
       else if ($getFeatureKind($getExtendedMetaData_1(INSTANCE_11, eStructuralFeature)) == 1 && !!mixedFeature) {
        this.wildcards = null;
        this.groupMembers = ($clinit_XMLTypeFeatures() , TEXTUAL_FEATURES);
      }
       else {
        this.wildcards = null;
        this.isElement = true;
        this.groupMembers = ($clinit_Collections() , new Collections$SingletonList(eStructuralFeature));
      }
    }
  }
   else {
    this.isElement = $getFeatureKind($getExtendedMetaData_1(INSTANCE_11, eStructuralFeature)) == 5;
    this.wildcards.equals_0(ANY_WILDCARD) && (this.wildcards = ANY_WILDCARD);
  }
}

defineClass(706, 1, {1721:1}, FeatureMapUtil$BasicValidator);
_.isValid = function isValid_1(feature){
  var result;
  if (this.eStructuralFeature == feature)
    return true;
  result = castToBoolean($get_6(this.cache, feature));
  if (result == null) {
    if ($isIncluded(this, feature)) {
      $put_10(this.cache, feature, ($clinit_Boolean() , TRUE_0));
      return true;
    }
     else {
      $put_10(this.cache, feature, ($clinit_Boolean() , FALSE_0));
      return false;
    }
  }
   else {
    return result == ($clinit_Boolean() , TRUE_0);
  }
}
;
_.isElement = false;
var ANY_WILDCARD;
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$BasicValidator_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'FeatureMapUtil/BasicValidator', 706);
function $put_10(this$static, eStructuralFeature, isValid){
  var newCache;
  newCache = new FeatureMapUtil$BasicValidator$Cache(this$static.this$11);
  $putAll(newCache, this$static.this$11.cache);
  $put_4(newCache.hashCodeMap, eStructuralFeature, isValid);
  this$static.this$11.cache = newCache;
}

function FeatureMapUtil$BasicValidator$Cache(this$1){
  this.this$11 = this$1;
  HashMap.call(this);
}

defineClass(707, 41, $intern_78, FeatureMapUtil$BasicValidator$Cache);
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$BasicValidator$Cache_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'FeatureMapUtil/BasicValidator/Cache', 707);
function $addAll_9(this$static, collection){
  return $addAll_8(this$static.featureMap, this$static.feature, collection);
}

function $basicRemove_4(this$static, object, notifications){
  return $basicRemove_3(this$static.featureMap, this$static.feature, object, notifications);
}

function $clear_14(this$static){
  $clear_13(this$static.featureMap, this$static.feature);
}

function $isEmpty_2(this$static){
  return $isEmpty_1(this$static.featureMap, this$static.feature);
}

function FeatureMapUtil$FeatureEList(feature, featureMap){
  this.feature = feature;
  this.featureMap = featureMap;
}

defineClass(471, 43, {20:1, 28:1, 43:1, 13:1, 15:1, 52:1, 82:1, 69:1}, FeatureMapUtil$FeatureEList);
_.add_3 = function add_67(index_0, object){
  $add_32(this.featureMap, this.feature, index_0, object);
}
;
_.add_1 = function add_68(object){
  return $add_33(this.featureMap, this.feature, object);
}
;
_.addAll = function addAll_21(collection){
  return $addAll_9(this, collection);
}
;
_.basicAdd = function basicAdd_5(object, notifications){
  return $basicAdd_2(this.featureMap, this.feature, object, notifications);
}
;
_.basicGet = function basicGet_6(index_0){
  return $get_19(this.featureMap, this.feature, index_0, false);
}
;
_.basicIterator = function basicIterator_7(){
  return $basicIterator(this.featureMap, this.feature);
}
;
_.basicListIterator = function basicListIterator_15(){
  return $basicListIterator_0(this.featureMap, this.feature);
}
;
_.basicListIterator_0 = function basicListIterator_16(index_0){
  return $basicListIterator_1(this.featureMap, this.feature, index_0);
}
;
_.basicRemove = function basicRemove_6(object, notifications){
  return $basicRemove_4(this, object, notifications);
}
;
_.clear_0 = function clear_62(){
  $clear_14(this);
}
;
_.contains = function contains_61(object){
  return $contains_12(this.featureMap, this.feature, object);
}
;
_.containsAll = function containsAll_16(collection){
  return $containsAll_1(this.featureMap, this.feature, collection);
}
;
_.get_3 = function get_52(index_0){
  return $get_19(this.featureMap, this.feature, index_0, true);
}
;
_.get_6 = function get_53(resolve){
  return this;
}
;
_.indexOf_0 = function indexOf_17(object){
  return $indexOf_7(this.featureMap, this.feature, object);
}
;
_.isEmpty = function isEmpty_30(){
  return $isEmpty_2(this);
}
;
_.isSet_0 = function isSet_17(){
  return !$isEmpty_1(this.featureMap, this.feature);
}
;
_.iterator_0 = function iterator_82(){
  return $iterator_5(this.featureMap, this.feature);
}
;
_.listIterator_0 = function listIterator_31(){
  return $listIterator_2(this.featureMap, this.feature);
}
;
_.listIterator_1 = function listIterator_32(index_0){
  return $listIterator_3(this.featureMap, this.feature, index_0);
}
;
_.remove_2 = function remove_127(index_0){
  return $remove_42(this.featureMap, this.feature, index_0);
}
;
_.remove_1 = function remove_128(object){
  return $remove_43(this.featureMap, this.feature, object);
}
;
_.set_2 = function set_39(index_0, object){
  return $set_15(this.featureMap, this.feature, index_0, object);
}
;
_.set_1 = function set_40(newValue){
  $clear_13(this.featureMap, this.feature);
  $addAll_9(this, castTo(newValue, 15));
}
;
_.size_1 = function size_71(){
  return $size_1(this.featureMap, this.feature);
}
;
_.toArray = function toArray_44(){
  return $toArray_7(this.featureMap, this.feature);
}
;
_.toArray_0 = function toArray_45(array){
  return $toArray_9(this.featureMap, this.feature, array);
}
;
_.toString_0 = function toString_156(){
  var i, stringBuffer;
  stringBuffer = new StringBuffer;
  stringBuffer.string += '[';
  for (i = $basicIterator(this.featureMap, this.feature); $hasNext_7(i);) {
    $append_3(stringBuffer, valueOf_7($next_18(i)));
    $hasNext_7(i) && (stringBuffer.string += ', ' , stringBuffer);
  }
  stringBuffer.string += ']';
  return stringBuffer.string;
}
;
_.unset = function unset_12(){
  $clear_13(this.featureMap, this.feature);
}
;
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$FeatureEList_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'FeatureMapUtil/FeatureEList', 471);
function $getFeatureID_0(this$static, expectedClass){
  var containerClass;
  if (this$static.featureID == -1 && !!this$static.feature) {
    containerClass = this$static.feature.getContainerClass();
    this$static.featureID = !containerClass?$getFeatureID(this$static.notifier.eClass_0(), this$static.feature):this$static.notifier.eDerivedStructuralFeatureID(this$static.feature.getFeatureID_0(), containerClass);
  }
  return this$static.notifier.eBaseStructuralFeatureID(this$static.featureID, expectedClass);
}

function FeatureMapUtil$FeatureENotificationImpl(owner, eventType, feature, oldObject, newObject, index_0, wasSet){
  NotificationImpl_2.call(this, eventType, oldObject, newObject, index_0, wasSet);
  this.notifier = owner;
  this.feature = feature;
}

defineClass(598, 33, $intern_145, FeatureMapUtil$FeatureENotificationImpl);
_.getFeatureID = function getFeatureID_14(expectedClass){
  return $getFeatureID_0(this, expectedClass);
}
;
_.merge_0 = function merge_4(notification){
  var addedValues, collection, newPositions, notificationEventType, notificationNotifier, positions, removedValues;
  switch (this.eventType) {
    case 1:
    case 2:
      {
        notificationNotifier = notification.getNotifier();
        if (maskUndefined(notificationNotifier) === maskUndefined(this.notifier) && $getFeatureID_0(this, null) == notification.getFeatureID(null)) {
          this.newValue = notification.getNewValue();
          notification.getEventType() == 1 && (this.eventType = 1);
          return true;
        }
        break;
      }

    case 3:
      {
        notificationEventType = notification.getEventType();
        switch (notificationEventType) {
          case 3:
            {
              notificationNotifier = notification.getNotifier();
              if (maskUndefined(notificationNotifier) === maskUndefined(this.notifier) && $getFeatureID_0(this, null) == notification.getFeatureID(null)) {
                this.eventType = 5;
                addedValues = new BasicEList_0(2);
                $add_21(addedValues, this.newValue);
                $add_21(addedValues, notification.getNewValue());
                this.newValue = addedValues;
                return true;
              }
              break;
            }

        }
        break;
      }

    case 5:
      {
        notificationEventType = notification.getEventType();
        switch (notificationEventType) {
          case 3:
            {
              notificationNotifier = notification.getNotifier();
              if (maskUndefined(notificationNotifier) === maskUndefined(this.notifier) && $getFeatureID_0(this, null) == notification.getFeatureID(null)) {
                collection = castTo(this.newValue, 13);
                collection.add_1(notification.getNewValue());
                return true;
              }
              break;
            }

        }
        break;
      }

    case 4:
      {
        notificationEventType = notification.getEventType();
        switch (notificationEventType) {
          case 3:
            {
              notificationNotifier = notification.getNotifier();
              if (maskUndefined(notificationNotifier) === maskUndefined(this.notifier) && $getFeatureID_0(this, null) == notification.getFeatureID(null)) {
                this.eventType = 1;
                this.newValue = notification.getNewValue();
                return true;
              }
              break;
            }

          case 4:
            {
              notificationNotifier = notification.getNotifier();
              if (maskUndefined(notificationNotifier) === maskUndefined(this.notifier) && $getFeatureID_0(this, null) == notification.getFeatureID(null)) {
                this.eventType = 6;
                removedValues = new BasicEList_0(2);
                $add_21(removedValues, this.oldValue);
                $add_21(removedValues, notification.getOldValue());
                this.oldValue = removedValues;
                positions = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [this.position, notification.getPosition_0()]);
                this.newValue = positions;
                return true;
              }
              break;
            }

        }
        break;
      }

    case 6:
      {
        notificationEventType = notification.getEventType();
        switch (notificationEventType) {
          case 4:
            {
              notificationNotifier = notification.getNotifier();
              if (maskUndefined(notificationNotifier) === maskUndefined(this.notifier) && $getFeatureID_0(this, null) == notification.getFeatureID(null)) {
                collection = castTo(this.oldValue, 13);
                collection.add_1(notification.getOldValue());
                positions = castTo(this.newValue, 40);
                newPositions = initUnidimensionalArray(I_classLit, $intern_49, 23, positions.length + 1, 15, 1);
                arraycopy(positions, 0, newPositions, 0, positions.length);
                newPositions[positions.length] = notification.getPosition_0();
                this.newValue = newPositions;
                return true;
              }
              break;
            }

        }
        break;
      }

  }
  return false;
}
;
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$FeatureENotificationImpl_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'FeatureMapUtil/FeatureENotificationImpl', 598);
function FeatureMapUtil$FeatureFeatureMap(feature, featureMap){
  FeatureMapUtil$FeatureEList.call(this, feature, featureMap);
  this.wrapper = this;
}

defineClass(523, 471, {20:1, 28:1, 43:1, 13:1, 15:1, 52:1, 82:1, 188:1, 248:1, 1716:1, 69:1}, FeatureMapUtil$FeatureFeatureMap);
_.basicAdd_0 = function basicAdd_6(feature, object, notifications){
  return $basicAdd_2(this.featureMap, feature, object, notifications);
}
;
_.basicRemove_0 = function basicRemove_7(feature, object, notifications){
  return $basicRemove_3(this.featureMap, feature, object, notifications);
}
;
_.featureMap_0 = function featureMap_1(){
  return this;
}
;
_.get_7 = function get_54(feature, resolve){
  return $get_20(this.featureMap, feature, resolve);
}
;
_.getEStructuralFeature_0 = function getEStructuralFeature_4(index_0){
  return castTo($get_19(this.featureMap, this.feature, index_0, false), 76).getEStructuralFeature();
}
;
_.getValue_0 = function getValue_17(index_0){
  return castTo($get_19(this.featureMap, this.feature, index_0, false), 76).getValue();
}
;
_.getWrapper = function getWrapper_0(){
  return this.wrapper;
}
;
_.isSet_1 = function isSet_18(feature){
  return !$isEmpty_1(this.featureMap, feature);
}
;
_.set_3 = function set_41(feature, object){
  $set_16(this.featureMap, feature, object);
}
;
_.setting = function setting_1(feature){
  return $setting(this.featureMap, feature);
}
;
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$FeatureFeatureMap_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'FeatureMapUtil/FeatureFeatureMap', 523);
function FeatureMapUtil$FeatureValue(feature, featureMap){
  this.feature = feature;
  this.featureMap = featureMap;
}

defineClass(1160, 1, {82:1}, FeatureMapUtil$FeatureValue);
_.get_6 = function get_55(resolve){
  return $get_19(this.featureMap, this.feature, -1, resolve);
}
;
_.isSet_0 = function isSet_19(){
  return !$isEmpty_1(this.featureMap, this.feature);
}
;
_.set_1 = function set_42(newValue){
  $set_16(this.featureMap, this.feature, newValue);
}
;
_.unset = function unset_13(){
  $clear_13(this.featureMap, this.feature);
}
;
var Lorg_eclipse_emf_ecore_util_FeatureMapUtil$FeatureValue_2_classLit = createForClass('org.eclipse.emf.ecore.util', 'FeatureMapUtil/FeatureValue', 1160);
function $clinit_XMLTypeFeatures(){
  $clinit_XMLTypeFeatures = emptyMethod;
  TEXT = castTo($get_16($getEStructuralFeatures(($clinit_XMLTypePackage() , eINSTANCE_4).xmlTypeDocumentRootEClass), 6), 29);
  CDATA = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 3), 29);
  COMMENT = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 4), 29);
  PROCESSING_INSTRUCTION = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 5), 17);
  $getFeatureMapEntryPrototype(TEXT);
  $getFeatureMapEntryPrototype(CDATA);
  $getFeatureMapEntryPrototype(COMMENT);
  $getFeatureMapEntryPrototype(PROCESSING_INSTRUCTION);
  TEXTUAL_FEATURES = new Arrays$ArrayList(stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EStructuralFeature_2_classLit, 1), $intern_153, 159, 0, [TEXT, CDATA]));
}

var CDATA, COMMENT, PROCESSING_INSTRUCTION, TEXT, TEXTUAL_FEATURES;
var Lorg_eclipse_emf_ecore_xml_type_AnyType_2_classLit = createForInterface('org.eclipse.emf.ecore.xml.type', 'AnyType');
function InvalidDatatypeValueException(reason){
  RuntimeException_0.call(this, reason);
}

defineClass(623, 54, $intern_44, InvalidDatatypeValueException);
var Lorg_eclipse_emf_ecore_xml_type_InvalidDatatypeValueException_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type', 'InvalidDatatypeValueException', 623);
var Lorg_eclipse_emf_ecore_xml_type_ProcessingInstruction_2_classLit = createForInterface('org.eclipse.emf.ecore.xml.type', 'ProcessingInstruction');
var Lorg_eclipse_emf_ecore_xml_type_SimpleAnyType_2_classLit = createForInterface('org.eclipse.emf.ecore.xml.type', 'SimpleAnyType');
var Lorg_eclipse_emf_ecore_xml_type_XMLTypeDocumentRoot_2_classLit = createForInterface('org.eclipse.emf.ecore.xml.type', 'XMLTypeDocumentRoot');
function $clinit_XMLTypeFactory(){
  $clinit_XMLTypeFactory = emptyMethod;
  eINSTANCE_3 = init_5();
}

var eINSTANCE_3;
function $clinit_XMLTypePackage(){
  $clinit_XMLTypePackage = emptyMethod;
  eINSTANCE_4 = init_6();
}

var eINSTANCE_4;
function $clinit_XMLTypePackage$Literals(){
  $clinit_XMLTypePackage$Literals = emptyMethod;
  ANY_TYPE = ($clinit_XMLTypePackage() , eINSTANCE_4).anyTypeEClass;
  ANY_TYPE__MIXED = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.anyTypeEClass), 0), 29);
  ANY_TYPE__ANY = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.anyTypeEClass), 1), 29);
  ANY_TYPE__ANY_ATTRIBUTE = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.anyTypeEClass), 2), 29);
  PROCESSING_INSTRUCTION_0 = eINSTANCE_4.processingInstructionEClass;
  castTo($get_16($getEStructuralFeatures(eINSTANCE_4.processingInstructionEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_4.processingInstructionEClass), 1), 29);
  SIMPLE_ANY_TYPE = eINSTANCE_4.simpleAnyTypeEClass;
  SIMPLE_ANY_TYPE__RAW_VALUE = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.simpleAnyTypeEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_4.simpleAnyTypeEClass), 1), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_4.simpleAnyTypeEClass), 2), 17);
  XML_TYPE_DOCUMENT_ROOT = eINSTANCE_4.xmlTypeDocumentRootEClass;
  XML_TYPE_DOCUMENT_ROOT__MIXED = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 0), 29);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 1), 17);
  castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 2), 17);
  XML_TYPE_DOCUMENT_ROOT__CDATA = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 3), 29);
  XML_TYPE_DOCUMENT_ROOT__COMMENT = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 4), 29);
  XML_TYPE_DOCUMENT_ROOT__TEXT = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 6), 29);
  XML_TYPE_DOCUMENT_ROOT__PROCESSING_INSTRUCTION = castTo($get_16($getEStructuralFeatures(eINSTANCE_4.xmlTypeDocumentRootEClass), 5), 17);
  DATE = eINSTANCE_4.dateEDataType;
  DATE_TIME = eINSTANCE_4.dateTimeEDataType;
  DURATION = eINSTANCE_4.durationEDataType;
  GDAY = eINSTANCE_4.gDayEDataType;
  GMONTH = eINSTANCE_4.gMonthEDataType;
  GMONTH_DAY = eINSTANCE_4.gMonthDayEDataType;
  GYEAR = eINSTANCE_4.gYearEDataType;
  GYEAR_MONTH = eINSTANCE_4.gYearMonthEDataType;
  NOTATION = eINSTANCE_4.notationEDataType;
  QNAME = eINSTANCE_4.qNameEDataType;
  TIME = eINSTANCE_4.timeEDataType;
}

var ANY_TYPE, ANY_TYPE__ANY, ANY_TYPE__ANY_ATTRIBUTE, ANY_TYPE__MIXED, DATE, DATE_TIME, DURATION, GDAY, GMONTH, GMONTH_DAY, GYEAR, GYEAR_MONTH, NOTATION, PROCESSING_INSTRUCTION_0, QNAME, SIMPLE_ANY_TYPE, SIMPLE_ANY_TYPE__RAW_VALUE, TIME, XML_TYPE_DOCUMENT_ROOT, XML_TYPE_DOCUMENT_ROOT__CDATA, XML_TYPE_DOCUMENT_ROOT__COMMENT, XML_TYPE_DOCUMENT_ROOT__MIXED, XML_TYPE_DOCUMENT_ROOT__PROCESSING_INSTRUCTION, XML_TYPE_DOCUMENT_ROOT__TEXT;
function AnyTypeImpl(){
  EObjectImpl.call(this);
}

defineClass(765, 479, {98:1, 92:1, 89:1, 51:1, 46:1, 93:1, 776:1}, AnyTypeImpl);
_.eGet = function eGet_32(featureID, resolve, coreType){
  switch (featureID) {
    case 0:
      if (coreType)
        return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , this.mixed;
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , this.mixed.wrapper;
    case 1:
      if (coreType)
        return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188);
      return (!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo(castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188), 248)).getWrapper();
    case 2:
      if (coreType)
        return !this.anyAttribute && (this.anyAttribute = new BasicFeatureMap(this, 2)) , this.anyAttribute;
      return !this.anyAttribute && (this.anyAttribute = new BasicFeatureMap(this, 2)) , this.anyAttribute.wrapper;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((this.eFlags & 2) == 0?this.eStaticClass():(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), resolve, coreType);
}
;
_.eInverseRemove_0 = function eInverseRemove_23(otherEnd, featureID, msgs){
  var feature;
  switch (featureID) {
    case 0:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , $basicRemove_2(this.mixed, otherEnd, msgs);
    case 1:
      return (!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo(castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188), 69)).basicRemove(otherEnd, msgs);
    case 2:
      return !this.anyAttribute && (this.anyAttribute = new BasicFeatureMap(this, 2)) , $basicRemove_2(this.anyAttribute, otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((this.eFlags & 2) == 0?this.eStaticClass():(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings(this), featureID - $getFeatureCount(this.eStaticClass()), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_31(featureID){
  switch (featureID) {
    case 0:
      return !!this.mixed && this.mixed.size_0 != 0;
    case 1:
      return !(!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188)).isEmpty();
    case 2:
      return !!this.anyAttribute && this.anyAttribute.size_0 != 0;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((this.eFlags & 2) == 0?this.eStaticClass():(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID));
}
;
_.eSet = function eSet_29(featureID, newValue){
  switch (featureID) {
    case 0:
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $set_14(this.mixed, newValue);
      return;
    case 1:
      (!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo(castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188), 248)).set_1(newValue);
      return;
    case 2:
      !this.anyAttribute && (this.anyAttribute = new BasicFeatureMap(this, 2));
      $set_14(this.anyAttribute, newValue);
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(this.eStaticClass()), $getEStructuralFeature((this.eFlags & 2) == 0?this.eStaticClass():(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_31(){
  return $clinit_XMLTypePackage$Literals() , ANY_TYPE;
}
;
_.toString_0 = function toString_157(){
  var result;
  if ((this.eFlags & 4) != 0)
    return $toString_12(this);
  result = new StringBuffer_1($toString_12(this));
  result.string += ' (mixed: ';
  $append_2(result, this.mixed);
  result.string += ', anyAttribute: ';
  $append_2(result, this.anyAttribute);
  result.string += ')';
  return result.string;
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_AnyTypeImpl_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'AnyTypeImpl', 765);
function $setData_0(this$static, newData){
  this$static.data_0 = newData;
}

function $setTarget_1(this$static, newTarget){
  this$static.target = newTarget;
}

function ProcessingInstructionImpl(){
}

defineClass(624, 479, {98:1, 92:1, 89:1, 51:1, 46:1, 93:1, 1789:1, 624:1}, ProcessingInstructionImpl);
_.eGet = function eGet_33(featureID, resolve, coreType){
  switch (featureID) {
    case 0:
      return this.data_0;
    case 1:
      return this.target;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , PROCESSING_INSTRUCTION_0)), $getEStructuralFeature((this.eFlags & 2) == 0?PROCESSING_INSTRUCTION_0:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), resolve, coreType);
}
;
_.eIsSet = function eIsSet_32(featureID){
  switch (featureID) {
    case 0:
      return this.data_0 != null;
    case 1:
      return this.target != null;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , PROCESSING_INSTRUCTION_0)), $getEStructuralFeature((this.eFlags & 2) == 0?PROCESSING_INSTRUCTION_0:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID));
}
;
_.eSet = function eSet_30(featureID, newValue){
  switch (featureID) {
    case 0:
      $setData_0(this, castToString(newValue));
      return;
    case 1:
      $setTarget_1(this, castToString(newValue));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , PROCESSING_INSTRUCTION_0)), $getEStructuralFeature((this.eFlags & 2) == 0?PROCESSING_INSTRUCTION_0:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_32(){
  return $clinit_XMLTypePackage$Literals() , PROCESSING_INSTRUCTION_0;
}
;
_.toString_0 = function toString_158(){
  var result;
  if ((this.eFlags & 4) != 0)
    return $toString_12(this);
  result = new StringBuffer_1($toString_12(this));
  result.string += ' (data: ';
  $append_3(result, this.data_0);
  result.string += ', target: ';
  $append_3(result, this.target);
  result.string += ')';
  return result.string;
}
;
_.data_0 = null;
_.target = null;
var Lorg_eclipse_emf_ecore_xml_type_impl_ProcessingInstructionImpl_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'ProcessingInstructionImpl', 624);
function $setInstanceType(this$static, newInstanceType){
  this$static.instanceType = newInstanceType;
}

function $setRawValue(this$static, newRawValue){
  !this$static.mixed && (this$static.mixed = new BasicFeatureMap(this$static, 0));
  $set_16(this$static.mixed, ($clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE__RAW_VALUE), newRawValue);
}

function SimpleAnyTypeImpl(){
  AnyTypeImpl.call(this);
}

defineClass(625, 765, {98:1, 92:1, 89:1, 51:1, 46:1, 93:1, 776:1, 1790:1, 625:1}, SimpleAnyTypeImpl);
_.eGet = function eGet_34(featureID, resolve, coreType){
  switch (featureID) {
    case 0:
      if (coreType)
        return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , this.mixed;
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , this.mixed.wrapper;
    case 1:
      if (coreType)
        return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188);
      return (!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo(castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188), 248)).getWrapper();
    case 2:
      if (coreType)
        return !this.anyAttribute && (this.anyAttribute = new BasicFeatureMap(this, 2)) , this.anyAttribute;
      return !this.anyAttribute && (this.anyAttribute = new BasicFeatureMap(this, 2)) , this.anyAttribute.wrapper;
    case 3:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castToString($get_20(this.mixed, ($clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE__RAW_VALUE), true));
    case 4:
      return createFromString_2(this.instanceType, (!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castToString($get_20(this.mixed, ($clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE__RAW_VALUE), true))));
    case 5:
      return this.instanceType;
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE)), $getEStructuralFeature((this.eFlags & 2) == 0?SIMPLE_ANY_TYPE:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), resolve, coreType);
}
;
_.eIsSet = function eIsSet_33(featureID){
  switch (featureID) {
    case 0:
      return !!this.mixed && this.mixed.size_0 != 0;
    case 1:
      return !(!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188)).isEmpty();
    case 2:
      return !!this.anyAttribute && this.anyAttribute.size_0 != 0;
    case 3:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castToString($get_20(this.mixed, ($clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE__RAW_VALUE), true)) != null;
    case 4:
      return createFromString_2(this.instanceType, (!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castToString($get_20(this.mixed, ($clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE__RAW_VALUE), true)))) != null;
    case 5:
      return !!this.instanceType;
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE)), $getEStructuralFeature((this.eFlags & 2) == 0?SIMPLE_ANY_TYPE:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID));
}
;
_.eSet = function eSet_31(featureID, newValue){
  switch (featureID) {
    case 0:
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $set_14(this.mixed, newValue);
      return;
    case 1:
      (!this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , castTo(castTo($list(this.mixed, ($clinit_XMLTypePackage$Literals() , ANY_TYPE__ANY)), 188), 248)).set_1(newValue);
      return;
    case 2:
      !this.anyAttribute && (this.anyAttribute = new BasicFeatureMap(this, 2));
      $set_14(this.anyAttribute, newValue);
      return;
    case 3:
      $setRawValue(this, castToString(newValue));
      return;
    case 4:
      $setRawValue(this, convertToString_2(this.instanceType, newValue));
      return;
    case 5:
      $setInstanceType(this, castTo(newValue, 144));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE)), $getEStructuralFeature((this.eFlags & 2) == 0?SIMPLE_ANY_TYPE:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_33(){
  return $clinit_XMLTypePackage$Literals() , SIMPLE_ANY_TYPE;
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_SimpleAnyTypeImpl_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'SimpleAnyTypeImpl', 625);
function XMLTypeDocumentRootImpl(){
  EObjectImpl.call(this);
}

defineClass(626, 479, {98:1, 92:1, 89:1, 51:1, 46:1, 93:1, 1791:1, 626:1}, XMLTypeDocumentRootImpl);
_.eGet = function eGet_35(featureID, resolve, coreType){
  switch (featureID) {
    case 0:
      if (coreType)
        return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , this.mixed;
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , this.mixed.wrapper;
    case 1:
      return coreType?(!this.xMLNSPrefixMap && (this.xMLNSPrefixMap = new EcoreEMap(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this, 1)) , this.xMLNSPrefixMap):(!this.xMLNSPrefixMap && (this.xMLNSPrefixMap = new EcoreEMap(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this, 1)) , $map_0(this.xMLNSPrefixMap));
    case 2:
      return coreType?(!this.xSISchemaLocation && (this.xSISchemaLocation = new EcoreEMap(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this, 2)) , this.xSISchemaLocation):(!this.xSISchemaLocation && (this.xSISchemaLocation = new EcoreEMap(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this, 2)) , $map_0(this.xSISchemaLocation));
    case 3:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , $list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__CDATA));
    case 4:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , $list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__COMMENT));
    case 5:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , $list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__PROCESSING_INSTRUCTION));
    case 6:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , $list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__TEXT));
  }
  return $eDynamicGet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT)), $getEStructuralFeature((this.eFlags & 2) == 0?XML_TYPE_DOCUMENT_ROOT:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), resolve, coreType);
}
;
_.eInverseRemove_0 = function eInverseRemove_24(otherEnd, featureID, msgs){
  var feature;
  switch (featureID) {
    case 0:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , $basicRemove_2(this.mixed, otherEnd, msgs);
    case 1:
      return !this.xMLNSPrefixMap && (this.xMLNSPrefixMap = new EcoreEMap(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this, 1)) , $basicRemove_1(this.xMLNSPrefixMap, otherEnd, msgs);
    case 2:
      return !this.xSISchemaLocation && (this.xSISchemaLocation = new EcoreEMap(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this, 2)) , $basicRemove_1(this.xSISchemaLocation, otherEnd, msgs);
    case 5:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , $basicRemove_4($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__PROCESSING_INSTRUCTION)), otherEnd, msgs);
  }
  return feature = castTo($getEStructuralFeature((this.eFlags & 2) == 0?($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT):(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), 63) , feature.getSettingDelegate().dynamicInverseRemove(this, $eSettings(this), featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT)), otherEnd, msgs);
}
;
_.eIsSet = function eIsSet_34(featureID){
  switch (featureID) {
    case 0:
      return !!this.mixed && this.mixed.size_0 != 0;
    case 1:
      return !!this.xMLNSPrefixMap && this.xMLNSPrefixMap.size_0 != 0;
    case 2:
      return !!this.xSISchemaLocation && this.xSISchemaLocation.size_0 != 0;
    case 3:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , !$isEmpty_2($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__CDATA)));
    case 4:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , !$isEmpty_2($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__COMMENT)));
    case 5:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , !$isEmpty_2($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__PROCESSING_INSTRUCTION)));
    case 6:
      return !this.mixed && (this.mixed = new BasicFeatureMap(this, 0)) , !$isEmpty_2($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__TEXT)));
  }
  return $eDynamicIsSet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT)), $getEStructuralFeature((this.eFlags & 2) == 0?XML_TYPE_DOCUMENT_ROOT:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID));
}
;
_.eSet = function eSet_32(featureID, newValue){
  switch (featureID) {
    case 0:
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $set_14(this.mixed, newValue);
      return;
    case 1:
      !this.xMLNSPrefixMap && (this.xMLNSPrefixMap = new EcoreEMap(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this, 1));
      $set_11(this.xMLNSPrefixMap, newValue);
      return;
    case 2:
      !this.xSISchemaLocation && (this.xSISchemaLocation = new EcoreEMap(($clinit_EcorePackage$Literals() , ESTRING_TO_STRING_MAP_ENTRY), Lorg_eclipse_emf_ecore_impl_EStringToStringMapEntryImpl_2_classLit, this, 2));
      $set_11(this.xSISchemaLocation, newValue);
      return;
    case 3:
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $clear_14($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__CDATA)));
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $addAll_9($list(this.mixed, XML_TYPE_DOCUMENT_ROOT__CDATA), castTo(newValue, 13));
      return;
    case 4:
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $clear_14($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__COMMENT)));
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $addAll_9($list(this.mixed, XML_TYPE_DOCUMENT_ROOT__COMMENT), castTo(newValue, 13));
      return;
    case 5:
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $clear_14($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__PROCESSING_INSTRUCTION)));
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $addAll_9($list(this.mixed, XML_TYPE_DOCUMENT_ROOT__PROCESSING_INSTRUCTION), castTo(newValue, 13));
      return;
    case 6:
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $clear_14($list(this.mixed, ($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT__TEXT)));
      !this.mixed && (this.mixed = new BasicFeatureMap(this, 0));
      $addAll_9($list(this.mixed, XML_TYPE_DOCUMENT_ROOT__TEXT), castTo(newValue, 13));
      return;
  }
  $eDynamicSet(this, featureID - $getFeatureCount(($clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT)), $getEStructuralFeature((this.eFlags & 2) == 0?XML_TYPE_DOCUMENT_ROOT:(!this.eProperties && (this.eProperties = new BasicEObjectImpl$EPropertiesHolderImpl) , this.eProperties).getEClass(), featureID), newValue);
}
;
_.eStaticClass = function eStaticClass_34(){
  return $clinit_XMLTypePackage$Literals() , XML_TYPE_DOCUMENT_ROOT;
}
;
_.toString_0 = function toString_159(){
  var result;
  if ((this.eFlags & 4) != 0)
    return $toString_12(this);
  result = new StringBuffer_1($toString_12(this));
  result.string += ' (mixed: ';
  $append_2(result, this.mixed);
  result.string += ')';
  return result.string;
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypeDocumentRootImpl_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypeDocumentRootImpl', 626);
function $clinit_XMLTypeFactoryImpl(){
  $clinit_XMLTypeFactoryImpl = emptyMethod;
  $clinit_EFactoryImpl();
  DOUBLE_POSITIVE_INFINITY = $intern_62;
  DOUBLE_NEGATIVE_INFINITY = $intern_63;
  FLOAT_POSITIVE_INFINITY = new Float($intern_62);
  FLOAT_NEGATIVE_INFINITY = new Float($intern_63);
}

function $booleanValueOf_0(initialValue){
  initialValue = normalize(initialValue, true);
  if ($equals_4('true', initialValue) || $equals_4('1', initialValue)) {
    return $clinit_Boolean() , TRUE_0;
  }
   else if ($equals_4('false', initialValue) || $equals_4('0', initialValue)) {
    return $clinit_Boolean() , FALSE_0;
  }
  throw toJs(new InvalidDatatypeValueException("Invalid boolean value: '" + initialValue + "'"));
}

function $convertBase64Binary(instanceValue){
  return instanceValue == null?null:encode(instanceValue);
}

function $convertDouble(instanceValue){
  return instanceValue == $intern_62?'INF':instanceValue == $intern_63?'-INF':'' + instanceValue;
}

function $convertENTITIESBaseToString(instanceValue){
  var i, list, result;
  if (instanceValue == null)
    return null;
  list = castTo(instanceValue, 15);
  if (list.isEmpty())
    return '';
  result = new StringBuffer;
  for (i = list.iterator_0(); i.hasNext_0();) {
    $append_3(result, ($clinit_XMLTypePackage$Literals() , castToString(i.next_1())));
    result.string += ' ';
  }
  return $substring(result, result.string.length - 1);
}

function $convertFloat(instanceValue){
  return instanceValue == $intern_62?'INF':instanceValue == $intern_63?'-INF':'' + instanceValue;
}

function $convertHexBinary(instanceValue){
  return instanceValue == null?null:encode_0(instanceValue);
}

function $convertIDREFSBase(instanceValue){
  var item_0, item$iterator, result;
  if (!instanceValue)
    return null;
  if (instanceValue.isEmpty())
    return '';
  result = new StringBuffer;
  for (item$iterator = instanceValue.iterator_0(); item$iterator.hasNext_0();) {
    item_0 = item$iterator.next_1();
    $append_3(result, castToString(item_0));
    result.string += ' ';
  }
  return $substring(result, result.string.length - 1);
}

function $convertNMTOKENSBaseToString(instanceValue){
  var i, list, result;
  if (instanceValue == null)
    return null;
  list = castTo(instanceValue, 15);
  if (list.isEmpty())
    return '';
  result = new StringBuffer;
  for (i = list.iterator_0(); i.hasNext_0();) {
    $append_3(result, ($clinit_XMLTypePackage$Literals() , castToString(i.next_1())));
    result.string += ' ';
  }
  return $substring(result, result.string.length - 1);
}

function $convertNonNegativeIntegerToString(instanceValue){
  return instanceValue == null?null:toString_41(instanceValue);
}

function $convertNonPositiveIntegerToString(instanceValue){
  return instanceValue == null?null:toString_41(instanceValue);
}

function $createBase64Binary(literal){
  var value_0;
  if (literal == null)
    return null;
  value_0 = decode_0(normalize(literal, true));
  if (value_0 == null) {
    throw toJs(new InvalidDatatypeValueException("Invalid base64Binary value: '" + literal + "'"));
  }
  return value_0;
}

function $createDoubleObject(literal){
  var ch_0, length_0, normalizedLiteral, suffixlength;
  if (literal == null) {
    return null;
  }
   else {
    normalizedLiteral = normalize(literal, true);
    suffixlength = 'INF'.length;
    if ($equals_4(normalizedLiteral.substr(normalizedLiteral.length - suffixlength, suffixlength), 'INF')) {
      length_0 = normalizedLiteral.length;
      if (length_0 == 4) {
        ch_0 = normalizedLiteral.charCodeAt(0);
        if (ch_0 == 43) {
          return DOUBLE_POSITIVE_INFINITY;
        }
         else if (ch_0 == 45) {
          return DOUBLE_NEGATIVE_INFINITY;
        }
      }
       else if (length_0 == 3) {
        return DOUBLE_POSITIVE_INFINITY;
      }
    }
    return __parseAndValidateDouble(normalizedLiteral);
  }
}

function $createENTITIESBase(literal){
  var item_0, item$array, item$index, item$max, result;
  if (literal == null)
    return null;
  result = new ArrayList;
  for (item$array = $split_5(literal) , item$index = 0 , item$max = item$array.length; item$index < item$max; ++item$index) {
    item_0 = item$array[item$index];
    $add_4(result, normalize(item_0, true));
  }
  return result;
}

function $createFloatObject(literal){
  var ch_0, length_0, normalizedLiteral, suffixlength;
  if (literal == null) {
    return null;
  }
   else {
    normalizedLiteral = normalize(literal, true);
    suffixlength = 'INF'.length;
    if ($equals_4(normalizedLiteral.substr(normalizedLiteral.length - suffixlength, suffixlength), 'INF')) {
      length_0 = normalizedLiteral.length;
      if (length_0 == 4) {
        ch_0 = normalizedLiteral.charCodeAt(0);
        if (ch_0 == 43) {
          return FLOAT_POSITIVE_INFINITY;
        }
         else if (ch_0 == 45) {
          return FLOAT_NEGATIVE_INFINITY;
        }
      }
       else if (length_0 == 3) {
        return FLOAT_POSITIVE_INFINITY;
      }
    }
    return new Float_0(normalizedLiteral);
  }
}

function $createHexBinary(literal){
  var value_0;
  if (literal == null)
    return null;
  value_0 = decode_1(normalize(literal, true));
  if (value_0 == null) {
    throw toJs(new InvalidDatatypeValueException("Invalid hexBinary value: '" + literal + "'"));
  }
  return value_0;
}

function $createIDREFSBase(literal){
  var item_0, item$array, item$index, item$max, result;
  if (literal == null)
    return null;
  result = new ArrayList;
  for (item$array = $split_5(literal) , item$index = 0 , item$max = item$array.length; item$index < item$max; ++item$index) {
    item_0 = item$array[item$index];
    $add_4(result, normalize(item_0, true));
  }
  return result;
}

function $createNMTOKENSBase(literal){
  var item_0, item$array, item$index, item$max, result;
  if (literal == null)
    return null;
  result = new ArrayList;
  for (item$array = $split_5(literal) , item$index = 0 , item$max = item$array.length; item$index < item$max; ++item$index) {
    item_0 = item$array[item$index];
    $add_4(result, normalize(item_0, true));
  }
  return result;
}

function $createNonNegativeIntegerFromString(initialValue){
  var result;
  return initialValue == null?null:new BigInteger_4((result = normalize(initialValue, true) , result.length > 0 && result.charCodeAt(0) == 43?result.substr(1, result.length - 1):result));
}

function $createNonPositiveIntegerFromString(initialValue){
  var result;
  return initialValue == null?null:new BigInteger_4((result = normalize(initialValue, true) , result.length > 0 && result.charCodeAt(0) == 43?result.substr(1, result.length - 1):result));
}

function XMLTypeFactoryImpl(){
}

function init_5(){
  $clinit_XMLTypeFactoryImpl();
  var exception, theXMLTypeFactory;
  try {
    theXMLTypeFactory = castTo($getEFactory(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/emf/2003/XMLType'), 1792);
    if (theXMLTypeFactory) {
      return theXMLTypeFactory;
    }
  }
   catch ($e0) {
    $e0 = toJava($e0);
    if (instanceOf($e0, 102)) {
      exception = $e0;
      $log(($clinit_EcorePlugin() , exception));
    }
     else 
      throw toJs($e0);
  }
  return new XMLTypeFactoryImpl;
}

defineClass(1710, 660, {98:1, 92:1, 89:1, 445:1, 143:1, 51:1, 106:1, 46:1, 93:1, 145:1, 109:1, 110:1, 1792:1}, XMLTypeFactoryImpl);
_.convertToString = function convertToString_3(eDataType, instanceValue){
  switch (eDataType.getClassifierID()) {
    case 7:
    case 8:
    case 9:
    case 10:
    case 16:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 32:
    case 33:
    case 34:
    case 36:
    case 37:
    case 44:
    case 45:
    case 50:
    case 51:
    case 53:
    case 55:
    case 56:
    case 57:
    case 58:
    case 60:
    case 61:
    case 4:
      return instanceValue == null?null:toString_41(instanceValue);
    case 19:
    case 28:
    case 29:
    case 35:
    case 38:
    case 39:
    case 41:
    case 46:
    case 52:
    case 54:
    case 5:
      return castToString(instanceValue);
    case 6:
      return $convertBase64Binary(castTo(instanceValue, 178));
    case 12:
    case 47:
    case 49:
    case 11:
      return $convertToString(this, eDataType, instanceValue);
    case 13:
      return instanceValue == null?null:$toPlainString(castTo(instanceValue, 222));
    case 15:
    case 14:
      return instanceValue == null?null:$convertDouble(checkNotNull_1(castToDouble(instanceValue)));
    case 17:
      return $convertENTITIESBaseToString(($clinit_XMLTypePackage$Literals() , instanceValue));
    case 18:
      return $convertENTITIESBaseToString(instanceValue);
    case 21:
    case 20:
      return instanceValue == null?null:$convertFloat(castTo(instanceValue, 128).value_0);
    case 27:
      return $convertHexBinary(castTo(instanceValue, 178));
    case 30:
      return $convertIDREFSBase(($clinit_XMLTypePackage$Literals() , castTo(instanceValue, 15)));
    case 31:
      return $convertIDREFSBase(castTo(instanceValue, 15));
    case 40:
      return $convertNonPositiveIntegerToString(($clinit_XMLTypePackage$Literals() , instanceValue));
    case 42:
      return $convertNMTOKENSBaseToString(($clinit_XMLTypePackage$Literals() , instanceValue));
    case 43:
      return $convertNMTOKENSBaseToString(instanceValue);
    case 59:
    case 48:
      return $convertNonNegativeIntegerToString(($clinit_XMLTypePackage$Literals() , instanceValue));
    default:throw toJs(new IllegalArgumentException_0("The datatype '" + eDataType.getName() + "' is not a valid classifier"));
  }
}
;
_.create_3 = function create_43(eClass){
  var anyType, ePackage, processingInstruction, simpleAnyType, xmlTypeDocumentRoot;
  switch (eClass.metaObjectID == -1 && (eClass.metaObjectID = (ePackage = $getEPackage(eClass) , ePackage?$indexOf_6(ePackage.getEClassifiers(), eClass):-1)) , eClass.metaObjectID) {
    case 0:
      return anyType = new AnyTypeImpl , anyType;
    case 1:
      return processingInstruction = new ProcessingInstructionImpl , processingInstruction;
    case 2:
      return simpleAnyType = new SimpleAnyTypeImpl , simpleAnyType;
    case 3:
      return xmlTypeDocumentRoot = new XMLTypeDocumentRootImpl , xmlTypeDocumentRoot;
    default:throw toJs(new IllegalArgumentException_0("The class '" + eClass.name_0 + "' is not a valid classifier"));
  }
}
;
_.createFromString = function createFromString_3(eDataType, initialValue){
  var result, result0, result1, result10, result11, result12, result13, result14, result2, result3, result4, result5, result6, result7, result8, result9;
  switch (eDataType.getClassifierID()) {
    case 5:
    case 52:
    case 4:
      return initialValue;
    case 6:
      return $createBase64Binary(initialValue);
    case 8:
    case 7:
      return initialValue == null?null:$booleanValueOf_0(initialValue);
    case 9:
      return initialValue == null?null:valueOf_2(__parseAndValidateInt((result0 = normalize(initialValue, true) , result0.length > 0 && result0.charCodeAt(0) == 43?result0.substr(1, result0.length - 1):result0), -128, 127) << 24 >> 24);
    case 10:
      return initialValue == null?null:valueOf_2(__parseAndValidateInt((result1 = normalize(initialValue, true) , result1.length > 0 && result1.charCodeAt(0) == 43?result1.substr(1, result1.length - 1):result1), -128, 127) << 24 >> 24);
    case 11:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , DATE), initialValue));
    case 12:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , DATE_TIME), initialValue));
    case 13:
      return initialValue == null?null:new BigDecimal_0(normalize(initialValue, true));
    case 15:
    case 14:
      return $createDoubleObject(initialValue);
    case 16:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , DURATION), initialValue));
    case 17:
      return $createENTITIESBase(($clinit_XMLTypePackage$Literals() , initialValue));
    case 18:
      return $createENTITIESBase(initialValue);
    case 28:
    case 29:
    case 35:
    case 38:
    case 39:
    case 41:
    case 54:
    case 19:
      return normalize(initialValue, true);
    case 21:
    case 20:
      return $createFloatObject(initialValue);
    case 22:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , GDAY), initialValue));
    case 23:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , GMONTH), initialValue));
    case 24:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , GMONTH_DAY), initialValue));
    case 25:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , GYEAR), initialValue));
    case 26:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , GYEAR_MONTH), initialValue));
    case 27:
      return $createHexBinary(initialValue);
    case 30:
      return $createIDREFSBase(($clinit_XMLTypePackage$Literals() , initialValue));
    case 31:
      return $createIDREFSBase(initialValue);
    case 32:
      return initialValue == null?null:valueOf_4(__parseAndValidateInt((result2 = normalize(initialValue, true) , result2.length > 0 && result2.charCodeAt(0) == 43?result2.substr(1, result2.length - 1):result2), $intern_43, $intern_0));
    case 33:
      return initialValue == null?null:new BigInteger_4((result3 = normalize(initialValue, true) , result3.length > 0 && result3.charCodeAt(0) == 43?result3.substr(1, result3.length - 1):result3));
    case 34:
      return initialValue == null?null:valueOf_4(__parseAndValidateInt((result4 = normalize(initialValue, true) , result4.length > 0 && result4.charCodeAt(0) == 43?result4.substr(1, result4.length - 1):result4), $intern_43, $intern_0));
    case 36:
      return initialValue == null?null:valueOf_5(__parseAndValidateLong((result5 = normalize(initialValue, true) , result5.length > 0 && result5.charCodeAt(0) == 43?result5.substr(1, result5.length - 1):result5)));
    case 37:
      return initialValue == null?null:valueOf_5(__parseAndValidateLong((result6 = normalize(initialValue, true) , result6.length > 0 && result6.charCodeAt(0) == 43?result6.substr(1, result6.length - 1):result6)));
    case 40:
      return $createNonPositiveIntegerFromString(($clinit_XMLTypePackage$Literals() , initialValue));
    case 42:
      return $createNMTOKENSBase(($clinit_XMLTypePackage$Literals() , initialValue));
    case 43:
      return $createNMTOKENSBase(initialValue);
    case 44:
      return initialValue == null?null:new BigInteger_4((result7 = normalize(initialValue, true) , result7.length > 0 && result7.charCodeAt(0) == 43?result7.substr(1, result7.length - 1):result7));
    case 45:
      return initialValue == null?null:new BigInteger_4((result8 = normalize(initialValue, true) , result8.length > 0 && result8.charCodeAt(0) == 43?result8.substr(1, result8.length - 1):result8));
    case 46:
      return normalize(initialValue, false);
    case 47:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , NOTATION), initialValue));
    case 59:
    case 48:
      return $createNonNegativeIntegerFromString(($clinit_XMLTypePackage$Literals() , initialValue));
    case 49:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , QNAME), initialValue));
    case 50:
      return initialValue == null?null:valueOf_6(__parseAndValidateInt((result9 = normalize(initialValue, true) , result9.length > 0 && result9.charCodeAt(0) == 43?result9.substr(1, result9.length - 1):result9), $intern_163, 32767) << 16 >> 16);
    case 51:
      return initialValue == null?null:valueOf_6(__parseAndValidateInt((result10 = normalize(initialValue, true) , result10.length > 0 && result10.charCodeAt(0) == 43?result10.substr(1, result10.length - 1):result10), $intern_163, 32767) << 16 >> 16);
    case 53:
      return castToString($createFromString(this, ($clinit_XMLTypePackage$Literals() , TIME), initialValue));
    case 55:
      return initialValue == null?null:valueOf_6(__parseAndValidateInt((result11 = normalize(initialValue, true) , result11.length > 0 && result11.charCodeAt(0) == 43?result11.substr(1, result11.length - 1):result11), $intern_163, 32767) << 16 >> 16);
    case 56:
      return initialValue == null?null:valueOf_6(__parseAndValidateInt((result12 = normalize(initialValue, true) , result12.length > 0 && result12.charCodeAt(0) == 43?result12.substr(1, result12.length - 1):result12), $intern_163, 32767) << 16 >> 16);
    case 57:
      return initialValue == null?null:valueOf_5(__parseAndValidateLong((result13 = normalize(initialValue, true) , result13.length > 0 && result13.charCodeAt(0) == 43?result13.substr(1, result13.length - 1):result13)));
    case 58:
      return initialValue == null?null:valueOf_5(__parseAndValidateLong((result14 = normalize(initialValue, true) , result14.length > 0 && result14.charCodeAt(0) == 43?result14.substr(1, result14.length - 1):result14)));
    case 60:
      return initialValue == null?null:valueOf_4(__parseAndValidateInt((result = normalize(initialValue, true) , result.length > 0 && result.charCodeAt(0) == 43?result.substr(1, result.length - 1):result), $intern_43, $intern_0));
    case 61:
      return initialValue == null?null:valueOf_4(__parseAndValidateInt(normalize(initialValue, true), $intern_43, $intern_0));
    default:throw toJs(new IllegalArgumentException_0("The datatype '" + eDataType.getName() + "' is not a valid classifier"));
  }
}
;
var DOUBLE_NEGATIVE_INFINITY, DOUBLE_POSITIVE_INFINITY, FLOAT_NEGATIVE_INFINITY, FLOAT_POSITIVE_INFINITY;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypeFactoryImpl_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypeFactoryImpl', 1710);
function $$init_14(this$static){
  this$static.anyTypeEClass = null;
  this$static.processingInstructionEClass = null;
  this$static.simpleAnyTypeEClass = null;
  this$static.xmlTypeDocumentRootEClass = null;
  this$static.anySimpleTypeEDataType = null;
  this$static.anyURIEDataType = null;
  this$static.base64BinaryEDataType = null;
  this$static.booleanEDataType = null;
  this$static.booleanObjectEDataType = null;
  this$static.decimalEDataType = null;
  this$static.integerEDataType = null;
  this$static.intObjectEDataType = null;
  this$static.longEDataType = null;
  this$static.longObjectEDataType = null;
  this$static.intEDataType = null;
  this$static.shortEDataType = null;
  this$static.shortObjectEDataType = null;
  this$static.byteEDataType = null;
  this$static.byteObjectEDataType = null;
  this$static.dateEDataType = null;
  this$static.dateTimeEDataType = null;
  this$static.stringEDataType = null;
  this$static.doubleEDataType = null;
  this$static.doubleObjectEDataType = null;
  this$static.durationEDataType = null;
  this$static.entitiesBaseEDataType = null;
  this$static.normalizedStringEDataType = null;
  this$static.tokenEDataType = null;
  this$static.nameEDataType = null;
  this$static.ncNameEDataType = null;
  this$static.entityEDataType = null;
  this$static.entitiesEDataType = null;
  this$static.floatEDataType = null;
  this$static.floatObjectEDataType = null;
  this$static.gDayEDataType = null;
  this$static.gMonthEDataType = null;
  this$static.gMonthDayEDataType = null;
  this$static.gYearEDataType = null;
  this$static.gYearMonthEDataType = null;
  this$static.hexBinaryEDataType = null;
  this$static.idEDataType = null;
  this$static.idrefEDataType = null;
  this$static.idrefsBaseEDataType = null;
  this$static.idrefsEDataType = null;
  this$static.languageEDataType = null;
  this$static.nonPositiveIntegerEDataType = null;
  this$static.negativeIntegerEDataType = null;
  this$static.nmtokenEDataType = null;
  this$static.nmtokensBaseEDataType = null;
  this$static.nmtokensEDataType = null;
  this$static.nonNegativeIntegerEDataType = null;
  this$static.notationEDataType = null;
  this$static.positiveIntegerEDataType = null;
  this$static.qNameEDataType = null;
  this$static.timeEDataType = null;
  this$static.unsignedLongEDataType = null;
  this$static.unsignedIntEDataType = null;
  this$static.unsignedIntObjectEDataType = null;
  this$static.unsignedShortEDataType = null;
  this$static.unsignedShortObjectEDataType = null;
  this$static.unsignedByteEDataType = null;
  this$static.unsignedByteObjectEDataType = null;
  this$static.isCreated = false;
  this$static.isInitialized = false;
}

function $createExtendedMetaDataAnnotations_0(this$static){
  $addAnnotation(this$static.anySimpleTypeEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'anySimpleType']));
  $addAnnotation(this$static.anyTypeEClass, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'anyType', 'kind', 'mixed']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.anyTypeEClass), 0), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'elementWildcard', 'name', ':mixed']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.anyTypeEClass), 1), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'elementWildcard', 'wildcards', '##any', 'name', ':1', 'processing', 'lax']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.anyTypeEClass), 2), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'attributeWildcard', 'wildcards', '##any', 'name', ':2', 'processing', 'lax']));
  $addAnnotation(this$static.anyURIEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'anyURI', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.base64BinaryEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'base64Binary', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.booleanEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'boolean', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.booleanObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'boolean:Object', 'baseType', 'boolean']));
  $addAnnotation(this$static.byteEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'byte']));
  $addAnnotation(this$static.byteObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'byte:Object', 'baseType', 'byte']));
  $addAnnotation(this$static.dateEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'date', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.dateTimeEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'dateTime', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.decimalEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'decimal', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.doubleEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'double', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.doubleObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'double:Object', 'baseType', 'double']));
  $addAnnotation(this$static.durationEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'duration', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.entitiesEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'ENTITIES', 'baseType', 'ENTITIES_._base', 'minLength', '1']));
  $addAnnotation(this$static.entitiesBaseEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'ENTITIES_._base', 'itemType', 'ENTITY']));
  $addAnnotation(this$static.entityEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'ENTITY', 'baseType', 'NCName']));
  $addAnnotation(this$static.floatEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'float', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.floatObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'float:Object', 'baseType', 'float']));
  $addAnnotation(this$static.gDayEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'gDay', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.gMonthEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'gMonth', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.gMonthDayEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'gMonthDay', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.gYearEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'gYear', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.gYearMonthEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'gYearMonth', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.hexBinaryEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'hexBinary', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.idEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'ID', 'baseType', 'NCName']));
  $addAnnotation(this$static.idrefEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'IDREF', 'baseType', 'NCName']));
  $addAnnotation(this$static.idrefsEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'IDREFS', 'baseType', 'IDREFS_._base', 'minLength', '1']));
  $addAnnotation(this$static.idrefsBaseEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'IDREFS_._base', 'itemType', 'IDREF']));
  $addAnnotation(this$static.intEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'int']));
  $addAnnotation(this$static.integerEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'integer']));
  $addAnnotation(this$static.intObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'int:Object', 'baseType', 'int']));
  $addAnnotation(this$static.languageEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'language', 'baseType', 'token', 'pattern', '[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*']));
  $addAnnotation(this$static.longEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'long']));
  $addAnnotation(this$static.longObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'long:Object', 'baseType', 'long']));
  $addAnnotation(this$static.nameEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'Name', 'baseType', 'token', 'pattern', '\\i\\c*']));
  $addAnnotation(this$static.ncNameEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'NCName', 'baseType', 'Name', 'pattern', '[\\i-[:]][\\c-[:]]*']));
  $addAnnotation(this$static.negativeIntegerEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'negativeInteger', 'baseType', 'nonPositiveInteger', 'maxInclusive', '-1']));
  $addAnnotation(this$static.nmtokenEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'NMTOKEN', 'baseType', 'token', 'pattern', '\\c+']));
  $addAnnotation(this$static.nmtokensEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'NMTOKENS', 'baseType', 'NMTOKENS_._base', 'minLength', '1']));
  $addAnnotation(this$static.nmtokensBaseEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'NMTOKENS_._base', 'itemType', 'NMTOKEN']));
  $addAnnotation(this$static.nonNegativeIntegerEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'nonNegativeInteger', 'baseType', 'integer', 'minInclusive', '0']));
  $addAnnotation(this$static.nonPositiveIntegerEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'nonPositiveInteger', 'baseType', 'integer', 'maxInclusive', '0']));
  $addAnnotation(this$static.normalizedStringEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'normalizedString', 'baseType', 'string', 'whiteSpace', 'replace']));
  $addAnnotation(this$static.notationEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'NOTATION', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.positiveIntegerEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'positiveInteger', 'baseType', 'nonNegativeInteger', 'minInclusive', '1']));
  $addAnnotation(this$static.processingInstructionEClass, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'processingInstruction_._type', 'kind', 'empty']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.processingInstructionEClass), 0), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'attribute', 'name', 'data']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.processingInstructionEClass), 1), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'attribute', 'name', 'target']));
  $addAnnotation(this$static.qNameEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'QName', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.shortEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'short']));
  $addAnnotation(this$static.shortObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'short:Object', 'baseType', 'short']));
  $addAnnotation(this$static.simpleAnyTypeEClass, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'simpleAnyType', 'kind', 'simple']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.simpleAnyTypeEClass), 0), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', ':3', 'kind', 'simple']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.simpleAnyTypeEClass), 1), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', ':4', 'kind', 'simple']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.simpleAnyTypeEClass), 2), 17), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', ':5', 'kind', 'simple']));
  $addAnnotation(this$static.stringEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'string', 'whiteSpace', 'preserve']));
  $addAnnotation(this$static.timeEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'time', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.tokenEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'token', 'baseType', 'normalizedString', 'whiteSpace', 'collapse']));
  $addAnnotation(this$static.unsignedByteEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'unsignedByte', 'maxInclusive', '255', 'minInclusive', '0']));
  $addAnnotation(this$static.unsignedByteObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'unsignedByte:Object', 'baseType', 'unsignedByte']));
  $addAnnotation(this$static.unsignedIntEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'unsignedInt', 'maxInclusive', '4294967295', 'minInclusive', '0']));
  $addAnnotation(this$static.unsignedIntObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'unsignedInt:Object', 'baseType', 'unsignedInt']));
  $addAnnotation(this$static.unsignedLongEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'unsignedLong', 'baseType', 'nonNegativeInteger', 'maxInclusive', '18446744073709551615', 'minInclusive', '0']));
  $addAnnotation(this$static.unsignedShortEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'unsignedShort', 'maxInclusive', '65535', 'minInclusive', '0']));
  $addAnnotation(this$static.unsignedShortObjectEDataType, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', 'unsignedShort:Object', 'baseType', 'unsignedShort']));
  $addAnnotation(this$static.xmlTypeDocumentRootEClass, 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['name', '', 'kind', 'mixed']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 0), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'elementWildcard', 'name', ':mixed']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 1), 17), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'attribute', 'name', 'xmlns:prefix']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 2), 17), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'attribute', 'name', 'xsi:schemaLocation']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 3), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'element', 'name', 'cDATA', 'namespace', '##targetNamespace']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 4), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'element', 'name', 'comment', 'namespace', '##targetNamespace']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 5), 17), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'element', 'name', 'processingInstruction', 'namespace', '##targetNamespace']));
  $addAnnotation(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 6), 29), 'http:///org/eclipse/emf/ecore/util/ExtendedMetaData', stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['kind', 'element', 'name', 'text', 'namespace', '##targetNamespace']));
}

function $createPackageContents_1(this$static){
  if (this$static.isCreated)
    return;
  this$static.isCreated = true;
  this$static.anyTypeEClass = $createEClass(this$static, 0);
  $createEAttribute(this$static.anyTypeEClass, 0);
  $createEAttribute(this$static.anyTypeEClass, 1);
  $createEAttribute(this$static.anyTypeEClass, 2);
  this$static.processingInstructionEClass = $createEClass(this$static, 1);
  $createEAttribute(this$static.processingInstructionEClass, 0);
  $createEAttribute(this$static.processingInstructionEClass, 1);
  this$static.simpleAnyTypeEClass = $createEClass(this$static, 2);
  $createEAttribute(this$static.simpleAnyTypeEClass, 3);
  $createEAttribute(this$static.simpleAnyTypeEClass, 4);
  $createEReference(this$static.simpleAnyTypeEClass, 5);
  this$static.xmlTypeDocumentRootEClass = $createEClass(this$static, 3);
  $createEAttribute(this$static.xmlTypeDocumentRootEClass, 0);
  $createEReference(this$static.xmlTypeDocumentRootEClass, 1);
  $createEReference(this$static.xmlTypeDocumentRootEClass, 2);
  $createEAttribute(this$static.xmlTypeDocumentRootEClass, 3);
  $createEAttribute(this$static.xmlTypeDocumentRootEClass, 4);
  $createEReference(this$static.xmlTypeDocumentRootEClass, 5);
  $createEAttribute(this$static.xmlTypeDocumentRootEClass, 6);
  this$static.anySimpleTypeEDataType = $createEDataType(this$static, 4);
  this$static.anyURIEDataType = $createEDataType(this$static, 5);
  this$static.base64BinaryEDataType = $createEDataType(this$static, 6);
  this$static.booleanEDataType = $createEDataType(this$static, 7);
  this$static.booleanObjectEDataType = $createEDataType(this$static, 8);
  this$static.byteEDataType = $createEDataType(this$static, 9);
  this$static.byteObjectEDataType = $createEDataType(this$static, 10);
  this$static.dateEDataType = $createEDataType(this$static, 11);
  this$static.dateTimeEDataType = $createEDataType(this$static, 12);
  this$static.decimalEDataType = $createEDataType(this$static, 13);
  this$static.doubleEDataType = $createEDataType(this$static, 14);
  this$static.doubleObjectEDataType = $createEDataType(this$static, 15);
  this$static.durationEDataType = $createEDataType(this$static, 16);
  this$static.entitiesEDataType = $createEDataType(this$static, 17);
  this$static.entitiesBaseEDataType = $createEDataType(this$static, 18);
  this$static.entityEDataType = $createEDataType(this$static, 19);
  this$static.floatEDataType = $createEDataType(this$static, 20);
  this$static.floatObjectEDataType = $createEDataType(this$static, 21);
  this$static.gDayEDataType = $createEDataType(this$static, 22);
  this$static.gMonthEDataType = $createEDataType(this$static, 23);
  this$static.gMonthDayEDataType = $createEDataType(this$static, 24);
  this$static.gYearEDataType = $createEDataType(this$static, 25);
  this$static.gYearMonthEDataType = $createEDataType(this$static, 26);
  this$static.hexBinaryEDataType = $createEDataType(this$static, 27);
  this$static.idEDataType = $createEDataType(this$static, 28);
  this$static.idrefEDataType = $createEDataType(this$static, 29);
  this$static.idrefsEDataType = $createEDataType(this$static, 30);
  this$static.idrefsBaseEDataType = $createEDataType(this$static, 31);
  this$static.intEDataType = $createEDataType(this$static, 32);
  this$static.integerEDataType = $createEDataType(this$static, 33);
  this$static.intObjectEDataType = $createEDataType(this$static, 34);
  this$static.languageEDataType = $createEDataType(this$static, 35);
  this$static.longEDataType = $createEDataType(this$static, 36);
  this$static.longObjectEDataType = $createEDataType(this$static, 37);
  this$static.nameEDataType = $createEDataType(this$static, 38);
  this$static.ncNameEDataType = $createEDataType(this$static, 39);
  this$static.negativeIntegerEDataType = $createEDataType(this$static, 40);
  this$static.nmtokenEDataType = $createEDataType(this$static, 41);
  this$static.nmtokensEDataType = $createEDataType(this$static, 42);
  this$static.nmtokensBaseEDataType = $createEDataType(this$static, 43);
  this$static.nonNegativeIntegerEDataType = $createEDataType(this$static, 44);
  this$static.nonPositiveIntegerEDataType = $createEDataType(this$static, 45);
  this$static.normalizedStringEDataType = $createEDataType(this$static, 46);
  this$static.notationEDataType = $createEDataType(this$static, 47);
  this$static.positiveIntegerEDataType = $createEDataType(this$static, 48);
  this$static.qNameEDataType = $createEDataType(this$static, 49);
  this$static.shortEDataType = $createEDataType(this$static, 50);
  this$static.shortObjectEDataType = $createEDataType(this$static, 51);
  this$static.stringEDataType = $createEDataType(this$static, 52);
  this$static.timeEDataType = $createEDataType(this$static, 53);
  this$static.tokenEDataType = $createEDataType(this$static, 54);
  this$static.unsignedByteEDataType = $createEDataType(this$static, 55);
  this$static.unsignedByteObjectEDataType = $createEDataType(this$static, 56);
  this$static.unsignedIntEDataType = $createEDataType(this$static, 57);
  this$static.unsignedIntObjectEDataType = $createEDataType(this$static, 58);
  this$static.unsignedLongEDataType = $createEDataType(this$static, 59);
  this$static.unsignedShortEDataType = $createEDataType(this$static, 60);
  this$static.unsignedShortObjectEDataType = $createEDataType(this$static, 61);
}

function $initializePackageContents_1(this$static){
  var theXMLTypePackage_1;
  if (this$static.isInitialized)
    return;
  this$static.isInitialized = true;
  $setName(this$static, 'type');
  $setNsPrefix(this$static, 'ecore.xml.type');
  $setNsURI(this$static, 'http://www.eclipse.org/emf/2003/XMLType');
  theXMLTypePackage_1 = castTo($getEPackage_0(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/emf/2003/XMLType'), 1723);
  $add_21($getESuperTypes(this$static.simpleAnyTypeEClass), this$static.anyTypeEClass);
  $initEClass(this$static.anyTypeEClass, Lorg_eclipse_emf_ecore_xml_type_AnyType_2_classLit, 'AnyType', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.anyTypeEClass), 0), 29), this$static.ecorePackage.eFeatureMapEntryEDataType, 'mixed', null, 0, -1, Lorg_eclipse_emf_ecore_xml_type_AnyType_2_classLit, false, false, true, false, false, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.anyTypeEClass), 1), 29), this$static.ecorePackage.eFeatureMapEntryEDataType, 'any', null, 0, -1, Lorg_eclipse_emf_ecore_xml_type_AnyType_2_classLit, true, true, true, false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.anyTypeEClass), 2), 29), this$static.ecorePackage.eFeatureMapEntryEDataType, 'anyAttribute', null, 0, -1, Lorg_eclipse_emf_ecore_xml_type_AnyType_2_classLit, false, false, true, false, false, false);
  $initEClass(this$static.processingInstructionEClass, Lorg_eclipse_emf_ecore_xml_type_ProcessingInstruction_2_classLit, 'ProcessingInstruction', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.processingInstructionEClass), 0), 29), this$static.stringEDataType, 'data', null, 0, 1, Lorg_eclipse_emf_ecore_xml_type_ProcessingInstruction_2_classLit, false, false, true, false, true, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.processingInstructionEClass), 1), 29), this$static.stringEDataType, 'target', null, 1, 1, Lorg_eclipse_emf_ecore_xml_type_ProcessingInstruction_2_classLit, false, false, true, false, true, false);
  $initEClass(this$static.simpleAnyTypeEClass, Lorg_eclipse_emf_ecore_xml_type_SimpleAnyType_2_classLit, 'SimpleAnyType', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.simpleAnyTypeEClass), 0), 29), theXMLTypePackage_1.stringEDataType, 'rawValue', null, 0, 1, Lorg_eclipse_emf_ecore_xml_type_SimpleAnyType_2_classLit, true, true, true, false, true, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.simpleAnyTypeEClass), 1), 29), theXMLTypePackage_1.anySimpleTypeEDataType, 'value', null, 0, 1, Lorg_eclipse_emf_ecore_xml_type_SimpleAnyType_2_classLit, true, true, true, false, true, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.simpleAnyTypeEClass), 2), 17), this$static.ecorePackage.eDataTypeEClass, null, 'instanceType', 1, 1, Lorg_eclipse_emf_ecore_xml_type_SimpleAnyType_2_classLit, false, false, true, false, false, false, false);
  $initEClass(this$static.xmlTypeDocumentRootEClass, Lorg_eclipse_emf_ecore_xml_type_XMLTypeDocumentRoot_2_classLit, 'XMLTypeDocumentRoot', false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 0), 29), this$static.ecorePackage.eFeatureMapEntryEDataType, 'mixed', null, 0, -1, null, false, false, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 1), 17), this$static.ecorePackage.eStringToStringMapEntryEClass, null, 'xMLNSPrefixMap', 0, -1, null, true, false, true, true, false, false, false);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 2), 17), this$static.ecorePackage.eStringToStringMapEntryEClass, null, 'xSISchemaLocation', 0, -1, null, true, false, true, true, false, false, false);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 3), 29), this$static.stringEDataType, 'cDATA', null, 0, -2, null, true, true, true, false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 4), 29), this$static.stringEDataType, 'comment', null, 0, -2, null, true, true, true, false, false, true);
  $initEReference(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 5), 17), this$static.processingInstructionEClass, null, 'processingInstruction', 0, -2, null, true, true, true, true, false, false, true);
  $initEAttribute(castTo($get_16($getEStructuralFeatures(this$static.xmlTypeDocumentRootEClass), 6), 29), this$static.stringEDataType, 'text', null, 0, -2, null, true, true, true, false, false, true);
  $initEDataType(this$static.anySimpleTypeEDataType, Ljava_lang_Object_2_classLit, 'AnySimpleType', true);
  $initEDataType(this$static.anyURIEDataType, Ljava_lang_String_2_classLit, 'AnyURI', true);
  $initEDataType(this$static.base64BinaryEDataType, getClassLiteralForArray(B_classLit, 1), 'Base64Binary', true);
  $initEDataType(this$static.booleanEDataType, Z_classLit, 'Boolean', true);
  $initEDataType(this$static.booleanObjectEDataType, Ljava_lang_Boolean_2_classLit, 'BooleanObject', true);
  $initEDataType(this$static.byteEDataType, B_classLit, 'Byte', true);
  $initEDataType(this$static.byteObjectEDataType, Ljava_lang_Byte_2_classLit, 'ByteObject', true);
  $initEDataType(this$static.dateEDataType, Ljava_lang_String_2_classLit, 'Date', true);
  $initEDataType(this$static.dateTimeEDataType, Ljava_lang_String_2_classLit, 'DateTime', true);
  $initEDataType(this$static.decimalEDataType, Ljava_math_BigDecimal_2_classLit, 'Decimal', true);
  $initEDataType(this$static.doubleEDataType, D_classLit, 'Double', true);
  $initEDataType(this$static.doubleObjectEDataType, Ljava_lang_Double_2_classLit, 'DoubleObject', true);
  $initEDataType(this$static.durationEDataType, Ljava_lang_String_2_classLit, 'Duration', true);
  $initEDataType(this$static.entitiesEDataType, Ljava_util_List_2_classLit, 'ENTITIES', true);
  $initEDataType(this$static.entitiesBaseEDataType, Ljava_util_List_2_classLit, 'ENTITIESBase', true);
  $initEDataType(this$static.entityEDataType, Ljava_lang_String_2_classLit, 'ENTITY', true);
  $initEDataType(this$static.floatEDataType, F_classLit, 'Float', true);
  $initEDataType(this$static.floatObjectEDataType, Ljava_lang_Float_2_classLit, 'FloatObject', true);
  $initEDataType(this$static.gDayEDataType, Ljava_lang_String_2_classLit, 'GDay', true);
  $initEDataType(this$static.gMonthEDataType, Ljava_lang_String_2_classLit, 'GMonth', true);
  $initEDataType(this$static.gMonthDayEDataType, Ljava_lang_String_2_classLit, 'GMonthDay', true);
  $initEDataType(this$static.gYearEDataType, Ljava_lang_String_2_classLit, 'GYear', true);
  $initEDataType(this$static.gYearMonthEDataType, Ljava_lang_String_2_classLit, 'GYearMonth', true);
  $initEDataType(this$static.hexBinaryEDataType, getClassLiteralForArray(B_classLit, 1), 'HexBinary', true);
  $initEDataType(this$static.idEDataType, Ljava_lang_String_2_classLit, 'ID', true);
  $initEDataType(this$static.idrefEDataType, Ljava_lang_String_2_classLit, 'IDREF', true);
  $initEDataType(this$static.idrefsEDataType, Ljava_util_List_2_classLit, 'IDREFS', true);
  $initEDataType(this$static.idrefsBaseEDataType, Ljava_util_List_2_classLit, 'IDREFSBase', true);
  $initEDataType(this$static.intEDataType, I_classLit, 'Int', true);
  $initEDataType(this$static.integerEDataType, Ljava_math_BigInteger_2_classLit, 'Integer', true);
  $initEDataType(this$static.intObjectEDataType, Ljava_lang_Integer_2_classLit, 'IntObject', true);
  $initEDataType(this$static.languageEDataType, Ljava_lang_String_2_classLit, 'Language', true);
  $initEDataType(this$static.longEDataType, J_classLit, 'Long', true);
  $initEDataType(this$static.longObjectEDataType, Ljava_lang_Long_2_classLit, 'LongObject', true);
  $initEDataType(this$static.nameEDataType, Ljava_lang_String_2_classLit, 'Name', true);
  $initEDataType(this$static.ncNameEDataType, Ljava_lang_String_2_classLit, 'NCName', true);
  $initEDataType(this$static.negativeIntegerEDataType, Ljava_math_BigInteger_2_classLit, 'NegativeInteger', true);
  $initEDataType(this$static.nmtokenEDataType, Ljava_lang_String_2_classLit, 'NMTOKEN', true);
  $initEDataType(this$static.nmtokensEDataType, Ljava_util_List_2_classLit, 'NMTOKENS', true);
  $initEDataType(this$static.nmtokensBaseEDataType, Ljava_util_List_2_classLit, 'NMTOKENSBase', true);
  $initEDataType(this$static.nonNegativeIntegerEDataType, Ljava_math_BigInteger_2_classLit, 'NonNegativeInteger', true);
  $initEDataType(this$static.nonPositiveIntegerEDataType, Ljava_math_BigInteger_2_classLit, 'NonPositiveInteger', true);
  $initEDataType(this$static.normalizedStringEDataType, Ljava_lang_String_2_classLit, 'NormalizedString', true);
  $initEDataType(this$static.notationEDataType, Ljava_lang_String_2_classLit, 'NOTATION', true);
  $initEDataType(this$static.positiveIntegerEDataType, Ljava_lang_String_2_classLit, 'PositiveInteger', true);
  $initEDataType(this$static.qNameEDataType, Ljava_lang_String_2_classLit, 'QName', true);
  $initEDataType(this$static.shortEDataType, S_classLit, 'Short', true);
  $initEDataType(this$static.shortObjectEDataType, Ljava_lang_Short_2_classLit, 'ShortObject', true);
  $initEDataType(this$static.stringEDataType, Ljava_lang_String_2_classLit, 'String', true);
  $initEDataType(this$static.timeEDataType, Ljava_lang_String_2_classLit, 'Time', true);
  $initEDataType(this$static.tokenEDataType, Ljava_lang_String_2_classLit, 'Token', true);
  $initEDataType(this$static.unsignedByteEDataType, S_classLit, 'UnsignedByte', true);
  $initEDataType(this$static.unsignedByteObjectEDataType, Ljava_lang_Short_2_classLit, 'UnsignedByteObject', true);
  $initEDataType(this$static.unsignedIntEDataType, J_classLit, 'UnsignedInt', true);
  $initEDataType(this$static.unsignedIntObjectEDataType, Ljava_lang_Long_2_classLit, 'UnsignedIntObject', true);
  $initEDataType(this$static.unsignedLongEDataType, Ljava_math_BigInteger_2_classLit, 'UnsignedLong', true);
  $initEDataType(this$static.unsignedShortEDataType, I_classLit, 'UnsignedShort', true);
  $initEDataType(this$static.unsignedShortObjectEDataType, Ljava_lang_Integer_2_classLit, 'UnsignedShortObject', true);
  $createResource(this$static, 'http://www.eclipse.org/emf/2003/XMLType');
  $createExtendedMetaDataAnnotations_0(this$static);
}

function XMLTypePackageImpl(){
  EPackageImpl_0.call(this, 'http://www.eclipse.org/emf/2003/XMLType', ($clinit_XMLTypeFactory() , eINSTANCE_3));
  $$init_14(this);
}

function init_6(){
  var theXMLTypePackage;
  if (isInited_1)
    return castTo($getEPackage_0(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/emf/2003/XMLType'), 1723);
  initializeRegistryHelpers();
  theXMLTypePackage = castTo(instanceOf($getStringValue(($clinit_EPackage$Registry() , INSTANCE_6), 'http://www.eclipse.org/emf/2003/XMLType'), 554)?$getStringValue(INSTANCE_6, 'http://www.eclipse.org/emf/2003/XMLType'):new XMLTypePackageImpl, 554);
  isInited_1 = true;
  $createPackageContents_1(theXMLTypePackage);
  $initializePackageContents_1(theXMLTypePackage);
  $put_1(($clinit_EValidator$Registry() , INSTANCE_8), theXMLTypePackage, new XMLTypePackageImpl$1);
  $freeze_0(theXMLTypePackage);
  $putStringValue(INSTANCE_6, 'http://www.eclipse.org/emf/2003/XMLType', theXMLTypePackage);
  return theXMLTypePackage;
}

function initializeRegistryHelpers(){
  register_0(Lorg_eclipse_emf_ecore_xml_type_AnyType_2_classLit, new XMLTypePackageImpl$2);
  register_0(Lorg_eclipse_emf_ecore_xml_type_ProcessingInstruction_2_classLit, new XMLTypePackageImpl$3);
  register_0(Lorg_eclipse_emf_ecore_xml_type_SimpleAnyType_2_classLit, new XMLTypePackageImpl$4);
  register_0(Lorg_eclipse_emf_ecore_xml_type_XMLTypeDocumentRoot_2_classLit, new XMLTypePackageImpl$5);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$6);
  register_0(getClassLiteralForArray(B_classLit, 1), new XMLTypePackageImpl$7);
  register_0(Ljava_lang_Boolean_2_classLit, new XMLTypePackageImpl$8);
  register_0(Ljava_lang_Byte_2_classLit, new XMLTypePackageImpl$9);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$10);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$11);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$12);
  register_0(Ljava_lang_Double_2_classLit, new XMLTypePackageImpl$13);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$14);
  register_0(Ljava_util_List_2_classLit, new XMLTypePackageImpl$15);
  register_0(Ljava_util_List_2_classLit, new XMLTypePackageImpl$16);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$17);
  register_0(Ljava_lang_Float_2_classLit, new XMLTypePackageImpl$18);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$19);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$20);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$21);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$22);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$23);
  register_0(getClassLiteralForArray(B_classLit, 1), new XMLTypePackageImpl$24);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$25);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$26);
  register_0(Ljava_util_List_2_classLit, new XMLTypePackageImpl$27);
  register_0(Ljava_util_List_2_classLit, new XMLTypePackageImpl$28);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$29);
  register_0(Ljava_lang_Integer_2_classLit, new XMLTypePackageImpl$30);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$31);
  register_0(Ljava_lang_Long_2_classLit, new XMLTypePackageImpl$32);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$33);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$34);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$35);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$36);
  register_0(Ljava_util_List_2_classLit, new XMLTypePackageImpl$37);
  register_0(Ljava_util_List_2_classLit, new XMLTypePackageImpl$38);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$39);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$40);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$41);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$42);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$43);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$44);
  register_0(Ljava_lang_Short_2_classLit, new XMLTypePackageImpl$45);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$46);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$47);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$48);
  register_0(Ljava_lang_Short_2_classLit, new XMLTypePackageImpl$49);
  register_0(Ljava_lang_Long_2_classLit, new XMLTypePackageImpl$50);
  register_0(Ljava_lang_String_2_classLit, new XMLTypePackageImpl$51);
  register_0(Ljava_lang_Integer_2_classLit, new XMLTypePackageImpl$52);
}

defineClass(554, 255, {98:1, 92:1, 89:1, 143:1, 179:1, 51:1, 214:1, 106:1, 46:1, 93:1, 145:1, 255:1, 109:1, 110:1, 632:1, 1723:1, 554:1}, XMLTypePackageImpl);
_.isCreated = false;
_.isInitialized = false;
var isInited_1 = false;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl', 554);
function XMLTypePackageImpl$1(){
}

defineClass(1653, 1, {773:1}, XMLTypePackageImpl$1);
_.getEValidator = function getEValidator_0(){
  return $clinit_XMLTypeValidator() , INSTANCE_12;
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$1_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/1', 1653);
function XMLTypePackageImpl$10(){
}

defineClass(1662, 1, $intern_164, XMLTypePackageImpl$10);
_.isInstance = function isInstance_50(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_42(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$10_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/10', 1662);
function XMLTypePackageImpl$11(){
}

defineClass(1663, 1, $intern_164, XMLTypePackageImpl$11);
_.isInstance = function isInstance_51(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_43(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$11_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/11', 1663);
function XMLTypePackageImpl$12(){
}

defineClass(1664, 1, $intern_164, XMLTypePackageImpl$12);
_.isInstance = function isInstance_52(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_44(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$12_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/12', 1664);
function XMLTypePackageImpl$13(){
}

defineClass(1665, 1, $intern_164, XMLTypePackageImpl$13);
_.isInstance = function isInstance_53(instance){
  return instanceOfDouble(instance);
}
;
_.newArrayInstance = function newArrayInstance_45(size_0){
  return initUnidimensionalArray(Ljava_lang_Double_2_classLit, $intern_33, 323, size_0, 7, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$13_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/13', 1665);
function XMLTypePackageImpl$14(){
}

defineClass(1666, 1, $intern_164, XMLTypePackageImpl$14);
_.isInstance = function isInstance_54(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_46(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$14_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/14', 1666);
function XMLTypePackageImpl$15(){
}

defineClass(1667, 1, $intern_164, XMLTypePackageImpl$15);
_.isInstance = function isInstance_55(instance){
  return instanceOf(instance, 15);
}
;
_.newArrayInstance = function newArrayInstance_47(size_0){
  return initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$15_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/15', 1667);
function XMLTypePackageImpl$16(){
}

defineClass(1668, 1, $intern_164, XMLTypePackageImpl$16);
_.isInstance = function isInstance_56(instance){
  return instanceOf(instance, 15);
}
;
_.newArrayInstance = function newArrayInstance_48(size_0){
  return initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$16_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/16', 1668);
function XMLTypePackageImpl$17(){
}

defineClass(1669, 1, $intern_164, XMLTypePackageImpl$17);
_.isInstance = function isInstance_57(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_49(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$17_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/17', 1669);
function XMLTypePackageImpl$18(){
}

defineClass(1670, 1, $intern_164, XMLTypePackageImpl$18);
_.isInstance = function isInstance_58(instance){
  return instanceOf(instance, 128);
}
;
_.newArrayInstance = function newArrayInstance_50(size_0){
  return initUnidimensionalArray(Ljava_lang_Float_2_classLit, $intern_33, 128, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$18_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/18', 1670);
function XMLTypePackageImpl$19(){
}

defineClass(1671, 1, $intern_164, XMLTypePackageImpl$19);
_.isInstance = function isInstance_59(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_51(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$19_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/19', 1671);
function XMLTypePackageImpl$2(){
}

defineClass(1654, 1, $intern_164, XMLTypePackageImpl$2);
_.isInstance = function isInstance_60(instance){
  return instanceOf(instance, 776);
}
;
_.newArrayInstance = function newArrayInstance_52(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_xml_type_AnyType_2_classLit, $intern_1, 776, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$2_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/2', 1654);
function XMLTypePackageImpl$20(){
}

defineClass(1672, 1, $intern_164, XMLTypePackageImpl$20);
_.isInstance = function isInstance_61(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_53(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$20_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/20', 1672);
function XMLTypePackageImpl$21(){
}

defineClass(1673, 1, $intern_164, XMLTypePackageImpl$21);
_.isInstance = function isInstance_62(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_54(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$21_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/21', 1673);
function XMLTypePackageImpl$22(){
}

defineClass(1674, 1, $intern_164, XMLTypePackageImpl$22);
_.isInstance = function isInstance_63(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_55(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$22_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/22', 1674);
function XMLTypePackageImpl$23(){
}

defineClass(1675, 1, $intern_164, XMLTypePackageImpl$23);
_.isInstance = function isInstance_64(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_56(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$23_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/23', 1675);
function XMLTypePackageImpl$24(){
}

defineClass(1676, 1, $intern_164, XMLTypePackageImpl$24);
_.isInstance = function isInstance_65(instance){
  return instanceOf(instance, 178);
}
;
_.newArrayInstance = function newArrayInstance_57(size_0){
  return initUnidimensionalArray(B_classLit, $intern_33, 178, size_0, 0, 2);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$24_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/24', 1676);
function XMLTypePackageImpl$25(){
}

defineClass(1677, 1, $intern_164, XMLTypePackageImpl$25);
_.isInstance = function isInstance_66(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_58(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$25_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/25', 1677);
function XMLTypePackageImpl$26(){
}

defineClass(1678, 1, $intern_164, XMLTypePackageImpl$26);
_.isInstance = function isInstance_67(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_59(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$26_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/26', 1678);
function XMLTypePackageImpl$27(){
}

defineClass(1679, 1, $intern_164, XMLTypePackageImpl$27);
_.isInstance = function isInstance_68(instance){
  return instanceOf(instance, 15);
}
;
_.newArrayInstance = function newArrayInstance_60(size_0){
  return initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$27_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/27', 1679);
function XMLTypePackageImpl$28(){
}

defineClass(1680, 1, $intern_164, XMLTypePackageImpl$28);
_.isInstance = function isInstance_69(instance){
  return instanceOf(instance, 15);
}
;
_.newArrayInstance = function newArrayInstance_61(size_0){
  return initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$28_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/28', 1680);
function XMLTypePackageImpl$29(){
}

defineClass(1681, 1, $intern_164, XMLTypePackageImpl$29);
_.isInstance = function isInstance_70(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_62(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$29_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/29', 1681);
function XMLTypePackageImpl$3(){
}

defineClass(1655, 1, $intern_164, XMLTypePackageImpl$3);
_.isInstance = function isInstance_71(instance){
  return instanceOf(instance, 624);
}
;
_.newArrayInstance = function newArrayInstance_63(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_xml_type_ProcessingInstruction_2_classLit, $intern_1, 1789, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$3_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/3', 1655);
function XMLTypePackageImpl$30(){
}

defineClass(1682, 1, $intern_164, XMLTypePackageImpl$30);
_.isInstance = function isInstance_72(instance){
  return instanceOf(instance, 21);
}
;
_.newArrayInstance = function newArrayInstance_64(size_0){
  return initUnidimensionalArray(Ljava_lang_Integer_2_classLit, $intern_33, 21, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$30_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/30', 1682);
function XMLTypePackageImpl$31(){
}

defineClass(1683, 1, $intern_164, XMLTypePackageImpl$31);
_.isInstance = function isInstance_73(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_65(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$31_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/31', 1683);
function XMLTypePackageImpl$32(){
}

defineClass(1684, 1, $intern_164, XMLTypePackageImpl$32);
_.isInstance = function isInstance_74(instance){
  return instanceOf(instance, 152);
}
;
_.newArrayInstance = function newArrayInstance_66(size_0){
  return initUnidimensionalArray(Ljava_lang_Long_2_classLit, $intern_33, 152, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$32_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/32', 1684);
function XMLTypePackageImpl$33(){
}

defineClass(1685, 1, $intern_164, XMLTypePackageImpl$33);
_.isInstance = function isInstance_75(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_67(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$33_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/33', 1685);
function XMLTypePackageImpl$34(){
}

defineClass(1686, 1, $intern_164, XMLTypePackageImpl$34);
_.isInstance = function isInstance_76(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_68(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$34_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/34', 1686);
function XMLTypePackageImpl$35(){
}

defineClass(1687, 1, $intern_164, XMLTypePackageImpl$35);
_.isInstance = function isInstance_77(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_69(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$35_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/35', 1687);
function XMLTypePackageImpl$36(){
}

defineClass(1688, 1, $intern_164, XMLTypePackageImpl$36);
_.isInstance = function isInstance_78(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_70(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$36_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/36', 1688);
function XMLTypePackageImpl$37(){
}

defineClass(1689, 1, $intern_164, XMLTypePackageImpl$37);
_.isInstance = function isInstance_79(instance){
  return instanceOf(instance, 15);
}
;
_.newArrayInstance = function newArrayInstance_71(size_0){
  return initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$37_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/37', 1689);
function XMLTypePackageImpl$38(){
}

defineClass(1690, 1, $intern_164, XMLTypePackageImpl$38);
_.isInstance = function isInstance_80(instance){
  return instanceOf(instance, 15);
}
;
_.newArrayInstance = function newArrayInstance_72(size_0){
  return initUnidimensionalArray(Ljava_util_List_2_classLit, $intern_102, 15, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$38_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/38', 1690);
function XMLTypePackageImpl$39(){
}

defineClass(1691, 1, $intern_164, XMLTypePackageImpl$39);
_.isInstance = function isInstance_81(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_73(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$39_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/39', 1691);
function XMLTypePackageImpl$4(){
}

defineClass(1656, 1, $intern_164, XMLTypePackageImpl$4);
_.isInstance = function isInstance_82(instance){
  return instanceOf(instance, 625);
}
;
_.newArrayInstance = function newArrayInstance_74(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_xml_type_SimpleAnyType_2_classLit, $intern_1, 1790, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$4_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/4', 1656);
function XMLTypePackageImpl$40(){
}

defineClass(1692, 1, $intern_164, XMLTypePackageImpl$40);
_.isInstance = function isInstance_83(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_75(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$40_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/40', 1692);
function XMLTypePackageImpl$41(){
}

defineClass(1693, 1, $intern_164, XMLTypePackageImpl$41);
_.isInstance = function isInstance_84(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_76(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$41_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/41', 1693);
function XMLTypePackageImpl$42(){
}

defineClass(1694, 1, $intern_164, XMLTypePackageImpl$42);
_.isInstance = function isInstance_85(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_77(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$42_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/42', 1694);
function XMLTypePackageImpl$43(){
}

defineClass(1695, 1, $intern_164, XMLTypePackageImpl$43);
_.isInstance = function isInstance_86(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_78(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$43_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/43', 1695);
function XMLTypePackageImpl$44(){
}

defineClass(1696, 1, $intern_164, XMLTypePackageImpl$44);
_.isInstance = function isInstance_87(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_79(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$44_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/44', 1696);
function XMLTypePackageImpl$45(){
}

defineClass(1697, 1, $intern_164, XMLTypePackageImpl$45);
_.isInstance = function isInstance_88(instance){
  return instanceOf(instance, 171);
}
;
_.newArrayInstance = function newArrayInstance_80(size_0){
  return initUnidimensionalArray(Ljava_lang_Short_2_classLit, $intern_33, 171, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$45_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/45', 1697);
function XMLTypePackageImpl$46(){
}

defineClass(1698, 1, $intern_164, XMLTypePackageImpl$46);
_.isInstance = function isInstance_89(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_81(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$46_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/46', 1698);
function XMLTypePackageImpl$47(){
}

defineClass(1699, 1, $intern_164, XMLTypePackageImpl$47);
_.isInstance = function isInstance_90(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_82(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$47_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/47', 1699);
function XMLTypePackageImpl$48(){
}

defineClass(1700, 1, $intern_164, XMLTypePackageImpl$48);
_.isInstance = function isInstance_91(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_83(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$48_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/48', 1700);
function XMLTypePackageImpl$49(){
}

defineClass(1701, 1, $intern_164, XMLTypePackageImpl$49);
_.isInstance = function isInstance_92(instance){
  return instanceOf(instance, 171);
}
;
_.newArrayInstance = function newArrayInstance_84(size_0){
  return initUnidimensionalArray(Ljava_lang_Short_2_classLit, $intern_33, 171, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$49_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/49', 1701);
function XMLTypePackageImpl$5(){
}

defineClass(1657, 1, $intern_164, XMLTypePackageImpl$5);
_.isInstance = function isInstance_93(instance){
  return instanceOf(instance, 626);
}
;
_.newArrayInstance = function newArrayInstance_85(size_0){
  return initUnidimensionalArray(Lorg_eclipse_emf_ecore_xml_type_XMLTypeDocumentRoot_2_classLit, $intern_1, 1791, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$5_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/5', 1657);
function XMLTypePackageImpl$50(){
}

defineClass(1702, 1, $intern_164, XMLTypePackageImpl$50);
_.isInstance = function isInstance_94(instance){
  return instanceOf(instance, 152);
}
;
_.newArrayInstance = function newArrayInstance_86(size_0){
  return initUnidimensionalArray(Ljava_lang_Long_2_classLit, $intern_33, 152, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$50_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/50', 1702);
function XMLTypePackageImpl$51(){
}

defineClass(1703, 1, $intern_164, XMLTypePackageImpl$51);
_.isInstance = function isInstance_95(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_87(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$51_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/51', 1703);
function XMLTypePackageImpl$52(){
}

defineClass(1704, 1, $intern_164, XMLTypePackageImpl$52);
_.isInstance = function isInstance_96(instance){
  return instanceOf(instance, 21);
}
;
_.newArrayInstance = function newArrayInstance_88(size_0){
  return initUnidimensionalArray(Ljava_lang_Integer_2_classLit, $intern_33, 21, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$52_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/52', 1704);
function XMLTypePackageImpl$6(){
}

defineClass(1658, 1, $intern_164, XMLTypePackageImpl$6);
_.isInstance = function isInstance_97(instance){
  return instanceOfString(instance);
}
;
_.newArrayInstance = function newArrayInstance_89(size_0){
  return initUnidimensionalArray(Ljava_lang_String_2_classLit, $intern_33, 2, size_0, 6, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$6_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/6', 1658);
function XMLTypePackageImpl$7(){
}

defineClass(1659, 1, $intern_164, XMLTypePackageImpl$7);
_.isInstance = function isInstance_98(instance){
  return instanceOf(instance, 178);
}
;
_.newArrayInstance = function newArrayInstance_90(size_0){
  return initUnidimensionalArray(B_classLit, $intern_33, 178, size_0, 0, 2);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$7_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/7', 1659);
function XMLTypePackageImpl$8(){
}

defineClass(1660, 1, $intern_164, XMLTypePackageImpl$8);
_.isInstance = function isInstance_99(instance){
  return instanceOfBoolean(instance);
}
;
_.newArrayInstance = function newArrayInstance_91(size_0){
  return initUnidimensionalArray(Ljava_lang_Boolean_2_classLit, $intern_33, 449, size_0, 8, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$8_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/8', 1660);
function XMLTypePackageImpl$9(){
}

defineClass(1661, 1, $intern_164, XMLTypePackageImpl$9);
_.isInstance = function isInstance_100(instance){
  return instanceOf(instance, 196);
}
;
_.newArrayInstance = function newArrayInstance_92(size_0){
  return initUnidimensionalArray(Ljava_lang_Byte_2_classLit, $intern_33, 196, size_0, 0, 1);
}
;
var Lorg_eclipse_emf_ecore_xml_type_impl_XMLTypePackageImpl$9_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.impl', 'XMLTypePackageImpl/9', 1661);
function $clinit_DataValue$Base64(){
  $clinit_DataValue$Base64 = emptyMethod;
  var i, i0, i1, i2, i3, i4, i5, j, j0;
  base64Alphabet = initUnidimensionalArray(B_classLit, $intern_140, 23, 255, 15, 1);
  lookUpBase64Alphabet = initUnidimensionalArray(C_classLit, $intern_45, 23, 64, 15, 1);
  for (i0 = 0; i0 < 255; i0++) {
    base64Alphabet[i0] = -1;
  }
  for (i1 = 90; i1 >= 65; i1--) {
    base64Alphabet[i1] = i1 - 65 << 24 >> 24;
  }
  for (i2 = 122; i2 >= 97; i2--) {
    base64Alphabet[i2] = i2 - 97 + 26 << 24 >> 24;
  }
  for (i3 = 57; i3 >= 48; i3--) {
    base64Alphabet[i3] = i3 - 48 + 52 << 24 >> 24;
  }
  base64Alphabet[43] = 62;
  base64Alphabet[47] = 63;
  for (i4 = 0; i4 <= 25; i4++)
    lookUpBase64Alphabet[i4] = 65 + i4 & $intern_47;
  for (i5 = 26 , j0 = 0; i5 <= 51; ++i5 , j0++)
    lookUpBase64Alphabet[i5] = 97 + j0 & $intern_47;
  for (i = 52 , j = 0; i <= 61; ++i , j++)
    lookUpBase64Alphabet[i] = 48 + j & $intern_47;
  lookUpBase64Alphabet[62] = 43;
  lookUpBase64Alphabet[63] = 47;
}

function decode_0(encoded){
  $clinit_DataValue$Base64();
  var b1, b2, b3, b4, base64Data, d1, d2, d3, d4, dataIndex, decodedData, encodedIndex, i, len, numberQuadruple, tmp;
  if (encoded == null)
    return null;
  base64Data = $toCharArray(encoded);
  len = removeWhiteSpace(base64Data);
  if (len % 4 != 0) {
    return null;
  }
  numberQuadruple = len / 4 | 0;
  if (numberQuadruple == 0)
    return initUnidimensionalArray(B_classLit, $intern_140, 23, 0, 15, 1);
  d2 = 0;
  d3 = 0;
  d4 = 0;
  i = 0;
  encodedIndex = 0;
  dataIndex = 0;
  decodedData = initUnidimensionalArray(B_classLit, $intern_140, 23, numberQuadruple * 3, 15, 1);
  for (; i < numberQuadruple - 1; i++) {
    if (!isData(d1 = base64Data[dataIndex++]) || !isData(d2 = base64Data[dataIndex++]) || !isData(d3 = base64Data[dataIndex++]) || !isData(d4 = base64Data[dataIndex++]))
      return null;
    b1 = base64Alphabet[d1];
    b2 = base64Alphabet[d2];
    b3 = base64Alphabet[d3];
    b4 = base64Alphabet[d4];
    decodedData[encodedIndex++] = (b1 << 2 | b2 >> 4) << 24 >> 24;
    decodedData[encodedIndex++] = ((b2 & 15) << 4 | b3 >> 2 & 15) << 24 >> 24;
    decodedData[encodedIndex++] = (b3 << 6 | b4) << 24 >> 24;
  }
  if (!isData(d1 = base64Data[dataIndex++]) || !isData(d2 = base64Data[dataIndex++])) {
    return null;
  }
  b1 = base64Alphabet[d1];
  b2 = base64Alphabet[d2];
  d3 = base64Data[dataIndex++];
  d4 = base64Data[dataIndex++];
  if (base64Alphabet[d3] == -1 || base64Alphabet[d4] == -1) {
    if (d3 == 61 && d4 == 61) {
      if ((b2 & 15) != 0)
        return null;
      tmp = initUnidimensionalArray(B_classLit, $intern_140, 23, i * 3 + 1, 15, 1);
      arraycopy(decodedData, 0, tmp, 0, i * 3);
      tmp[encodedIndex] = (b1 << 2 | b2 >> 4) << 24 >> 24;
      return tmp;
    }
     else if (d3 != 61 && d4 == 61) {
      b3 = base64Alphabet[d3];
      if ((b3 & 3) != 0)
        return null;
      tmp = initUnidimensionalArray(B_classLit, $intern_140, 23, i * 3 + 2, 15, 1);
      arraycopy(decodedData, 0, tmp, 0, i * 3);
      tmp[encodedIndex++] = (b1 << 2 | b2 >> 4) << 24 >> 24;
      tmp[encodedIndex] = ((b2 & 15) << 4 | b3 >> 2 & 15) << 24 >> 24;
      return tmp;
    }
     else {
      return null;
    }
  }
   else {
    b3 = base64Alphabet[d3];
    b4 = base64Alphabet[d4];
    decodedData[encodedIndex++] = (b1 << 2 | b2 >> 4) << 24 >> 24;
    decodedData[encodedIndex++] = ((b2 & 15) << 4 | b3 >> 2 & 15) << 24 >> 24;
    decodedData[encodedIndex++] = (b3 << 6 | b4) << 24 >> 24;
  }
  return decodedData;
}

function encode(binaryData){
  $clinit_DataValue$Base64();
  var b1, b2, b3, dataIndex, encodedData, encodedIndex, fewerThan24bits, i, k, l, lengthDataBits, numberQuartet, numberTriplets, val1, val2, val3;
  if (binaryData == null)
    return null;
  lengthDataBits = binaryData.length * 8;
  if (lengthDataBits == 0) {
    return '';
  }
  fewerThan24bits = lengthDataBits % 24;
  numberTriplets = lengthDataBits / 24 | 0;
  numberQuartet = fewerThan24bits != 0?numberTriplets + 1:numberTriplets;
  encodedData = initUnidimensionalArray(C_classLit, $intern_45, 23, numberQuartet * 4, 15, 1);
  encodedIndex = 0;
  dataIndex = 0;
  for (i = 0; i < numberTriplets; i++) {
    b1 = binaryData[dataIndex++];
    b2 = binaryData[dataIndex++];
    b3 = binaryData[dataIndex++];
    l = (b2 & 15) << 24 >> 24;
    k = (b1 & 3) << 24 >> 24;
    val1 = (b1 & -128) == 0?b1 >> 2 << 24 >> 24:(b1 >> 2 ^ 192) << 24 >> 24;
    val2 = (b2 & -128) == 0?b2 >> 4 << 24 >> 24:(b2 >> 4 ^ 240) << 24 >> 24;
    val3 = (b3 & -128) == 0?b3 >> 6 << 24 >> 24:(b3 >> 6 ^ 252) << 24 >> 24;
    encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
    encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | k << 4];
    encodedData[encodedIndex++] = lookUpBase64Alphabet[l << 2 | val3];
    encodedData[encodedIndex++] = lookUpBase64Alphabet[b3 & 63];
  }
  if (fewerThan24bits == 8) {
    b1 = binaryData[dataIndex];
    k = (b1 & 3) << 24 >> 24;
    val1 = (b1 & -128) == 0?b1 >> 2 << 24 >> 24:(b1 >> 2 ^ 192) << 24 >> 24;
    encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
    encodedData[encodedIndex++] = lookUpBase64Alphabet[k << 4];
    encodedData[encodedIndex++] = 61;
    encodedData[encodedIndex++] = 61;
  }
   else if (fewerThan24bits == 16) {
    b1 = binaryData[dataIndex];
    b2 = binaryData[dataIndex + 1];
    l = (b2 & 15) << 24 >> 24;
    k = (b1 & 3) << 24 >> 24;
    val1 = (b1 & -128) == 0?b1 >> 2 << 24 >> 24:(b1 >> 2 ^ 192) << 24 >> 24;
    val2 = (b2 & -128) == 0?b2 >> 4 << 24 >> 24:(b2 >> 4 ^ 240) << 24 >> 24;
    encodedData[encodedIndex++] = lookUpBase64Alphabet[val1];
    encodedData[encodedIndex++] = lookUpBase64Alphabet[val2 | k << 4];
    encodedData[encodedIndex++] = lookUpBase64Alphabet[l << 2];
    encodedData[encodedIndex++] = 61;
  }
  return valueOf_9(encodedData, 0, encodedData.length);
}

function isData(octect){
  return base64Alphabet[octect] != -1;
}

function removeWhiteSpace(data_0){
  var i, len, newSize;
  newSize = 0;
  len = data_0.length;
  for (i = 0; i < len; i++) {
    data_0[i] == 32 || data_0[i] == 13 || data_0[i] == 10 || data_0[i] == 9 || (data_0[newSize++] = data_0[i]);
  }
  return newSize;
}

var base64Alphabet, lookUpBase64Alphabet;
function $clinit_DataValue$HexBin(){
  $clinit_DataValue$HexBin = emptyMethod;
  var i, i0, i1, i2, i3, i4;
  hexNumberTable = initUnidimensionalArray(B_classLit, $intern_140, 23, 255, 15, 1);
  lookUpHexAlphabet = initUnidimensionalArray(C_classLit, $intern_45, 23, 16, 15, 1);
  for (i0 = 0; i0 < 255; i0++) {
    hexNumberTable[i0] = -1;
  }
  for (i1 = 57; i1 >= 48; i1--) {
    hexNumberTable[i1] = i1 - 48 << 24 >> 24;
  }
  for (i2 = 70; i2 >= 65; i2--) {
    hexNumberTable[i2] = i2 - 65 + 10 << 24 >> 24;
  }
  for (i3 = 102; i3 >= 97; i3--) {
    hexNumberTable[i3] = i3 - 97 + 10 << 24 >> 24;
  }
  for (i4 = 0; i4 < 10; i4++)
    lookUpHexAlphabet[i4] = 48 + i4 & $intern_47;
  for (i = 10; i <= 15; i++)
    lookUpHexAlphabet[i] = 65 + i - 10 & $intern_47;
}

function decode_1(encoded){
  $clinit_DataValue$HexBin();
  var binaryData, decodedData, i, lengthData, lengthDecode, temp1, temp2;
  if (encoded == null)
    return null;
  lengthData = encoded.length;
  if (lengthData % 2 != 0)
    return null;
  binaryData = $toCharArray(encoded);
  lengthDecode = lengthData / 2 | 0;
  decodedData = initUnidimensionalArray(B_classLit, $intern_140, 23, lengthDecode, 15, 1);
  for (i = 0; i < lengthDecode; i++) {
    temp1 = hexNumberTable[binaryData[i * 2]];
    if (temp1 == -1)
      return null;
    temp2 = hexNumberTable[binaryData[i * 2 + 1]];
    if (temp2 == -1)
      return null;
    decodedData[i] = (temp1 << 4 | temp2) << 24 >> 24;
  }
  return decodedData;
}

function encode_0(binaryData){
  $clinit_DataValue$HexBin();
  var encodedData, i, lengthData, lengthEncode, temp;
  if (binaryData == null)
    return null;
  lengthData = binaryData.length;
  lengthEncode = lengthData * 2;
  encodedData = initUnidimensionalArray(C_classLit, $intern_45, 23, lengthEncode, 15, 1);
  for (i = 0; i < lengthData; i++) {
    temp = binaryData[i];
    temp < 0 && (temp += 256);
    encodedData[i * 2] = lookUpHexAlphabet[temp >> 4];
    encodedData[i * 2 + 1] = lookUpHexAlphabet[temp & 15];
  }
  return valueOf_9(encodedData, 0, encodedData.length);
}

var hexNumberTable, lookUpHexAlphabet;
function $clinit_DataValue$XMLChar(){
  $clinit_DataValue$XMLChar = emptyMethod;
  CHARS = initUnidimensionalArray(B_classLit, $intern_140, 23, $intern_66, 15, 1);
  CHARS[9] = 35;
  CHARS[10] = 19;
  CHARS[13] = 19;
  CHARS[32] = 51;
  CHARS[33] = 49;
  CHARS[34] = 33;
  fill_0(CHARS, 35, 38, 49);
  CHARS[38] = 1;
  fill_0(CHARS, 39, 45, 49);
  fill_0(CHARS, 45, 47, -71);
  CHARS[47] = 49;
  fill_0(CHARS, 48, 58, -71);
  CHARS[58] = 61;
  CHARS[59] = 49;
  CHARS[60] = 1;
  CHARS[61] = 49;
  CHARS[62] = 33;
  fill_0(CHARS, 63, 65, 49);
  fill_0(CHARS, 65, 91, -3);
  fill_0(CHARS, 91, 93, 33);
  CHARS[93] = 1;
  CHARS[94] = 33;
  CHARS[95] = -3;
  CHARS[96] = 33;
  fill_0(CHARS, 97, 123, -3);
  fill_0(CHARS, 123, 183, 33);
  CHARS[183] = -87;
  fill_0(CHARS, 184, 192, 33);
  fill_0(CHARS, 192, 215, -19);
  CHARS[215] = 33;
  fill_0(CHARS, 216, 247, -19);
  CHARS[247] = 33;
  fill_0(CHARS, 248, 306, -19);
  fill_0(CHARS, 306, 308, 33);
  fill_0(CHARS, 308, 319, -19);
  fill_0(CHARS, 319, 321, 33);
  fill_0(CHARS, 321, 329, -19);
  CHARS[329] = 33;
  fill_0(CHARS, 330, 383, -19);
  CHARS[383] = 33;
  fill_0(CHARS, 384, 452, -19);
  fill_0(CHARS, 452, 461, 33);
  fill_0(CHARS, 461, 497, -19);
  fill_0(CHARS, 497, 500, 33);
  fill_0(CHARS, 500, 502, -19);
  fill_0(CHARS, 502, 506, 33);
  fill_0(CHARS, 506, 536, -19);
  fill_0(CHARS, 536, 592, 33);
  fill_0(CHARS, 592, 681, -19);
  fill_0(CHARS, 681, 699, 33);
  fill_0(CHARS, 699, 706, -19);
  fill_0(CHARS, 706, 720, 33);
  fill_0(CHARS, 720, 722, -87);
  fill_0(CHARS, 722, 768, 33);
  fill_0(CHARS, 768, 838, -87);
  fill_0(CHARS, 838, 864, 33);
  fill_0(CHARS, 864, 866, -87);
  fill_0(CHARS, 866, 902, 33);
  CHARS[902] = -19;
  CHARS[903] = -87;
  fill_0(CHARS, 904, 907, -19);
  CHARS[907] = 33;
  CHARS[908] = -19;
  CHARS[909] = 33;
  fill_0(CHARS, 910, 930, -19);
  CHARS[930] = 33;
  fill_0(CHARS, 931, 975, -19);
  CHARS[975] = 33;
  fill_0(CHARS, 976, 983, -19);
  fill_0(CHARS, 983, 986, 33);
  CHARS[986] = -19;
  CHARS[987] = 33;
  CHARS[988] = -19;
  CHARS[989] = 33;
  CHARS[990] = -19;
  CHARS[991] = 33;
  CHARS[992] = -19;
  CHARS[993] = 33;
  fill_0(CHARS, 994, 1012, -19);
  fill_0(CHARS, 1012, 1025, 33);
  fill_0(CHARS, 1025, 1037, -19);
  CHARS[1037] = 33;
  fill_0(CHARS, 1038, 1104, -19);
  CHARS[1104] = 33;
  fill_0(CHARS, 1105, 1117, -19);
  CHARS[1117] = 33;
  fill_0(CHARS, 1118, 1154, -19);
  CHARS[1154] = 33;
  fill_0(CHARS, 1155, 1159, -87);
  fill_0(CHARS, 1159, 1168, 33);
  fill_0(CHARS, 1168, 1221, -19);
  fill_0(CHARS, 1221, 1223, 33);
  fill_0(CHARS, 1223, 1225, -19);
  fill_0(CHARS, 1225, 1227, 33);
  fill_0(CHARS, 1227, 1229, -19);
  fill_0(CHARS, 1229, 1232, 33);
  fill_0(CHARS, 1232, 1260, -19);
  fill_0(CHARS, 1260, 1262, 33);
  fill_0(CHARS, 1262, 1270, -19);
  fill_0(CHARS, 1270, 1272, 33);
  fill_0(CHARS, 1272, 1274, -19);
  fill_0(CHARS, 1274, 1329, 33);
  fill_0(CHARS, 1329, 1367, -19);
  fill_0(CHARS, 1367, 1369, 33);
  CHARS[1369] = -19;
  fill_0(CHARS, 1370, 1377, 33);
  fill_0(CHARS, 1377, 1415, -19);
  fill_0(CHARS, 1415, 1425, 33);
  fill_0(CHARS, 1425, 1442, -87);
  CHARS[1442] = 33;
  fill_0(CHARS, 1443, 1466, -87);
  CHARS[1466] = 33;
  fill_0(CHARS, 1467, 1470, -87);
  CHARS[1470] = 33;
  CHARS[1471] = -87;
  CHARS[1472] = 33;
  fill_0(CHARS, 1473, 1475, -87);
  CHARS[1475] = 33;
  CHARS[1476] = -87;
  fill_0(CHARS, 1477, 1488, 33);
  fill_0(CHARS, 1488, 1515, -19);
  fill_0(CHARS, 1515, 1520, 33);
  fill_0(CHARS, 1520, 1523, -19);
  fill_0(CHARS, 1523, 1569, 33);
  fill_0(CHARS, 1569, 1595, -19);
  fill_0(CHARS, 1595, 1600, 33);
  CHARS[1600] = -87;
  fill_0(CHARS, 1601, 1611, -19);
  fill_0(CHARS, 1611, 1619, -87);
  fill_0(CHARS, 1619, 1632, 33);
  fill_0(CHARS, 1632, 1642, -87);
  fill_0(CHARS, 1642, 1648, 33);
  CHARS[1648] = -87;
  fill_0(CHARS, 1649, 1720, -19);
  fill_0(CHARS, 1720, 1722, 33);
  fill_0(CHARS, 1722, 1727, -19);
  CHARS[1727] = 33;
  fill_0(CHARS, 1728, $intern_51, -19);
  CHARS[$intern_51] = 33;
  fill_0(CHARS, 1744, 1748, -19);
  CHARS[1748] = 33;
  CHARS[1749] = -19;
  fill_0(CHARS, 1750, 1765, -87);
  fill_0(CHARS, 1765, 1767, -19);
  fill_0(CHARS, 1767, 1769, -87);
  CHARS[1769] = 33;
  fill_0(CHARS, 1770, 1774, -87);
  fill_0(CHARS, 1774, 1776, 33);
  fill_0(CHARS, 1776, 1786, -87);
  fill_0(CHARS, 1786, 2305, 33);
  fill_0(CHARS, 2305, 2308, -87);
  CHARS[2308] = 33;
  fill_0(CHARS, 2309, 2362, -19);
  fill_0(CHARS, 2362, 2364, 33);
  CHARS[2364] = -87;
  CHARS[2365] = -19;
  fill_0(CHARS, 2366, 2382, -87);
  fill_0(CHARS, 2382, 2385, 33);
  fill_0(CHARS, 2385, 2389, -87);
  fill_0(CHARS, 2389, 2392, 33);
  fill_0(CHARS, 2392, 2402, -19);
  fill_0(CHARS, 2402, 2404, -87);
  fill_0(CHARS, 2404, 2406, 33);
  fill_0(CHARS, 2406, 2416, -87);
  fill_0(CHARS, 2416, 2433, 33);
  fill_0(CHARS, 2433, 2436, -87);
  CHARS[2436] = 33;
  fill_0(CHARS, 2437, 2445, -19);
  fill_0(CHARS, 2445, 2447, 33);
  fill_0(CHARS, 2447, 2449, -19);
  fill_0(CHARS, 2449, 2451, 33);
  fill_0(CHARS, 2451, 2473, -19);
  CHARS[2473] = 33;
  fill_0(CHARS, 2474, 2481, -19);
  CHARS[2481] = 33;
  CHARS[2482] = -19;
  fill_0(CHARS, 2483, 2486, 33);
  fill_0(CHARS, 2486, 2490, -19);
  fill_0(CHARS, 2490, 2492, 33);
  CHARS[2492] = -87;
  CHARS[2493] = 33;
  fill_0(CHARS, 2494, 2501, -87);
  fill_0(CHARS, 2501, 2503, 33);
  fill_0(CHARS, 2503, 2505, -87);
  fill_0(CHARS, 2505, 2507, 33);
  fill_0(CHARS, 2507, 2510, -87);
  fill_0(CHARS, 2510, 2519, 33);
  CHARS[2519] = -87;
  fill_0(CHARS, 2520, 2524, 33);
  fill_0(CHARS, 2524, 2526, -19);
  CHARS[2526] = 33;
  fill_0(CHARS, 2527, 2530, -19);
  fill_0(CHARS, 2530, 2532, -87);
  fill_0(CHARS, 2532, 2534, 33);
  fill_0(CHARS, 2534, 2544, -87);
  fill_0(CHARS, 2544, 2546, -19);
  fill_0(CHARS, 2546, 2562, 33);
  CHARS[2562] = -87;
  fill_0(CHARS, 2563, 2565, 33);
  fill_0(CHARS, 2565, 2571, -19);
  fill_0(CHARS, 2571, 2575, 33);
  fill_0(CHARS, 2575, 2577, -19);
  fill_0(CHARS, 2577, 2579, 33);
  fill_0(CHARS, 2579, 2601, -19);
  CHARS[2601] = 33;
  fill_0(CHARS, 2602, 2609, -19);
  CHARS[2609] = 33;
  fill_0(CHARS, 2610, 2612, -19);
  CHARS[2612] = 33;
  fill_0(CHARS, 2613, 2615, -19);
  CHARS[2615] = 33;
  fill_0(CHARS, 2616, 2618, -19);
  fill_0(CHARS, 2618, 2620, 33);
  CHARS[2620] = -87;
  CHARS[2621] = 33;
  fill_0(CHARS, 2622, 2627, -87);
  fill_0(CHARS, 2627, 2631, 33);
  fill_0(CHARS, 2631, 2633, -87);
  fill_0(CHARS, 2633, 2635, 33);
  fill_0(CHARS, 2635, 2638, -87);
  fill_0(CHARS, 2638, 2649, 33);
  fill_0(CHARS, 2649, 2653, -19);
  CHARS[2653] = 33;
  CHARS[2654] = -19;
  fill_0(CHARS, 2655, 2662, 33);
  fill_0(CHARS, 2662, 2674, -87);
  fill_0(CHARS, 2674, 2677, -19);
  fill_0(CHARS, 2677, 2689, 33);
  fill_0(CHARS, 2689, 2692, -87);
  CHARS[2692] = 33;
  fill_0(CHARS, 2693, 2700, -19);
  CHARS[2700] = 33;
  CHARS[2701] = -19;
  CHARS[2702] = 33;
  fill_0(CHARS, 2703, 2706, -19);
  CHARS[2706] = 33;
  fill_0(CHARS, 2707, 2729, -19);
  CHARS[2729] = 33;
  fill_0(CHARS, 2730, 2737, -19);
  CHARS[2737] = 33;
  fill_0(CHARS, 2738, 2740, -19);
  CHARS[2740] = 33;
  fill_0(CHARS, 2741, 2746, -19);
  fill_0(CHARS, 2746, 2748, 33);
  CHARS[2748] = -87;
  CHARS[2749] = -19;
  fill_0(CHARS, 2750, 2758, -87);
  CHARS[2758] = 33;
  fill_0(CHARS, 2759, 2762, -87);
  CHARS[2762] = 33;
  fill_0(CHARS, 2763, 2766, -87);
  fill_0(CHARS, 2766, 2784, 33);
  CHARS[2784] = -19;
  fill_0(CHARS, 2785, 2790, 33);
  fill_0(CHARS, 2790, 2800, -87);
  fill_0(CHARS, 2800, 2817, 33);
  fill_0(CHARS, 2817, 2820, -87);
  CHARS[2820] = 33;
  fill_0(CHARS, 2821, 2829, -19);
  fill_0(CHARS, 2829, 2831, 33);
  fill_0(CHARS, 2831, 2833, -19);
  fill_0(CHARS, 2833, 2835, 33);
  fill_0(CHARS, 2835, 2857, -19);
  CHARS[2857] = 33;
  fill_0(CHARS, 2858, 2865, -19);
  CHARS[2865] = 33;
  fill_0(CHARS, 2866, 2868, -19);
  fill_0(CHARS, 2868, 2870, 33);
  fill_0(CHARS, 2870, 2874, -19);
  fill_0(CHARS, 2874, 2876, 33);
  CHARS[2876] = -87;
  CHARS[2877] = -19;
  fill_0(CHARS, 2878, 2884, -87);
  fill_0(CHARS, 2884, 2887, 33);
  fill_0(CHARS, 2887, 2889, -87);
  fill_0(CHARS, 2889, 2891, 33);
  fill_0(CHARS, 2891, 2894, -87);
  fill_0(CHARS, 2894, 2902, 33);
  fill_0(CHARS, 2902, 2904, -87);
  fill_0(CHARS, 2904, 2908, 33);
  fill_0(CHARS, 2908, 2910, -19);
  CHARS[2910] = 33;
  fill_0(CHARS, 2911, 2914, -19);
  fill_0(CHARS, 2914, 2918, 33);
  fill_0(CHARS, 2918, 2928, -87);
  fill_0(CHARS, 2928, 2946, 33);
  fill_0(CHARS, 2946, 2948, -87);
  CHARS[2948] = 33;
  fill_0(CHARS, 2949, 2955, -19);
  fill_0(CHARS, 2955, 2958, 33);
  fill_0(CHARS, 2958, 2961, -19);
  CHARS[2961] = 33;
  fill_0(CHARS, 2962, 2966, -19);
  fill_0(CHARS, 2966, 2969, 33);
  fill_0(CHARS, 2969, 2971, -19);
  CHARS[2971] = 33;
  CHARS[2972] = -19;
  CHARS[2973] = 33;
  fill_0(CHARS, 2974, 2976, -19);
  fill_0(CHARS, 2976, 2979, 33);
  fill_0(CHARS, 2979, 2981, -19);
  fill_0(CHARS, 2981, 2984, 33);
  fill_0(CHARS, 2984, 2987, -19);
  fill_0(CHARS, 2987, 2990, 33);
  fill_0(CHARS, 2990, 2998, -19);
  CHARS[2998] = 33;
  fill_0(CHARS, 2999, 3002, -19);
  fill_0(CHARS, 3002, 3006, 33);
  fill_0(CHARS, 3006, 3011, -87);
  fill_0(CHARS, 3011, 3014, 33);
  fill_0(CHARS, 3014, 3017, -87);
  CHARS[3017] = 33;
  fill_0(CHARS, 3018, 3022, -87);
  fill_0(CHARS, 3022, 3031, 33);
  CHARS[3031] = -87;
  fill_0(CHARS, 3032, 3047, 33);
  fill_0(CHARS, 3047, 3056, -87);
  fill_0(CHARS, 3056, 3073, 33);
  fill_0(CHARS, 3073, 3076, -87);
  CHARS[3076] = 33;
  fill_0(CHARS, 3077, 3085, -19);
  CHARS[3085] = 33;
  fill_0(CHARS, 3086, 3089, -19);
  CHARS[3089] = 33;
  fill_0(CHARS, 3090, 3113, -19);
  CHARS[3113] = 33;
  fill_0(CHARS, 3114, 3124, -19);
  CHARS[3124] = 33;
  fill_0(CHARS, 3125, 3130, -19);
  fill_0(CHARS, 3130, 3134, 33);
  fill_0(CHARS, 3134, 3141, -87);
  CHARS[3141] = 33;
  fill_0(CHARS, 3142, 3145, -87);
  CHARS[3145] = 33;
  fill_0(CHARS, 3146, 3150, -87);
  fill_0(CHARS, 3150, 3157, 33);
  fill_0(CHARS, 3157, 3159, -87);
  fill_0(CHARS, 3159, 3168, 33);
  fill_0(CHARS, 3168, 3170, -19);
  fill_0(CHARS, 3170, 3174, 33);
  fill_0(CHARS, 3174, 3184, -87);
  fill_0(CHARS, 3184, 3202, 33);
  fill_0(CHARS, 3202, 3204, -87);
  CHARS[3204] = 33;
  fill_0(CHARS, 3205, 3213, -19);
  CHARS[3213] = 33;
  fill_0(CHARS, 3214, 3217, -19);
  CHARS[3217] = 33;
  fill_0(CHARS, 3218, 3241, -19);
  CHARS[3241] = 33;
  fill_0(CHARS, 3242, 3252, -19);
  CHARS[3252] = 33;
  fill_0(CHARS, 3253, 3258, -19);
  fill_0(CHARS, 3258, 3262, 33);
  fill_0(CHARS, 3262, 3269, -87);
  CHARS[3269] = 33;
  fill_0(CHARS, 3270, 3273, -87);
  CHARS[3273] = 33;
  fill_0(CHARS, 3274, 3278, -87);
  fill_0(CHARS, 3278, 3285, 33);
  fill_0(CHARS, 3285, 3287, -87);
  fill_0(CHARS, 3287, 3294, 33);
  CHARS[3294] = -19;
  CHARS[3295] = 33;
  fill_0(CHARS, 3296, 3298, -19);
  fill_0(CHARS, 3298, 3302, 33);
  fill_0(CHARS, 3302, 3312, -87);
  fill_0(CHARS, 3312, 3330, 33);
  fill_0(CHARS, 3330, 3332, -87);
  CHARS[3332] = 33;
  fill_0(CHARS, 3333, 3341, -19);
  CHARS[3341] = 33;
  fill_0(CHARS, 3342, 3345, -19);
  CHARS[3345] = 33;
  fill_0(CHARS, 3346, 3369, -19);
  CHARS[3369] = 33;
  fill_0(CHARS, 3370, 3386, -19);
  fill_0(CHARS, 3386, 3390, 33);
  fill_0(CHARS, 3390, 3396, -87);
  fill_0(CHARS, 3396, 3398, 33);
  fill_0(CHARS, 3398, 3401, -87);
  CHARS[3401] = 33;
  fill_0(CHARS, 3402, 3406, -87);
  fill_0(CHARS, 3406, 3415, 33);
  CHARS[3415] = -87;
  fill_0(CHARS, 3416, 3424, 33);
  fill_0(CHARS, 3424, 3426, -19);
  fill_0(CHARS, 3426, 3430, 33);
  fill_0(CHARS, 3430, 3440, -87);
  fill_0(CHARS, 3440, 3585, 33);
  fill_0(CHARS, 3585, 3631, -19);
  CHARS[3631] = 33;
  CHARS[3632] = -19;
  CHARS[3633] = -87;
  fill_0(CHARS, 3634, 3636, -19);
  fill_0(CHARS, 3636, 3643, -87);
  fill_0(CHARS, 3643, 3648, 33);
  fill_0(CHARS, 3648, 3654, -19);
  fill_0(CHARS, 3654, 3663, -87);
  CHARS[3663] = 33;
  fill_0(CHARS, 3664, 3674, -87);
  fill_0(CHARS, 3674, 3713, 33);
  fill_0(CHARS, 3713, 3715, -19);
  CHARS[3715] = 33;
  CHARS[3716] = -19;
  fill_0(CHARS, 3717, 3719, 33);
  fill_0(CHARS, 3719, 3721, -19);
  CHARS[3721] = 33;
  CHARS[3722] = -19;
  fill_0(CHARS, 3723, 3725, 33);
  CHARS[3725] = -19;
  fill_0(CHARS, 3726, 3732, 33);
  fill_0(CHARS, 3732, 3736, -19);
  CHARS[3736] = 33;
  fill_0(CHARS, 3737, 3744, -19);
  CHARS[3744] = 33;
  fill_0(CHARS, 3745, 3748, -19);
  CHARS[3748] = 33;
  CHARS[3749] = -19;
  CHARS[3750] = 33;
  CHARS[3751] = -19;
  fill_0(CHARS, 3752, 3754, 33);
  fill_0(CHARS, 3754, 3756, -19);
  CHARS[3756] = 33;
  fill_0(CHARS, 3757, 3759, -19);
  CHARS[3759] = 33;
  CHARS[3760] = -19;
  CHARS[3761] = -87;
  fill_0(CHARS, 3762, 3764, -19);
  fill_0(CHARS, 3764, 3770, -87);
  CHARS[3770] = 33;
  fill_0(CHARS, 3771, 3773, -87);
  CHARS[3773] = -19;
  fill_0(CHARS, 3774, 3776, 33);
  fill_0(CHARS, 3776, 3781, -19);
  CHARS[3781] = 33;
  CHARS[3782] = -87;
  CHARS[3783] = 33;
  fill_0(CHARS, 3784, 3790, -87);
  fill_0(CHARS, 3790, 3792, 33);
  fill_0(CHARS, 3792, 3802, -87);
  fill_0(CHARS, 3802, 3864, 33);
  fill_0(CHARS, 3864, 3866, -87);
  fill_0(CHARS, 3866, 3872, 33);
  fill_0(CHARS, 3872, 3882, -87);
  fill_0(CHARS, 3882, 3893, 33);
  CHARS[3893] = -87;
  CHARS[3894] = 33;
  CHARS[3895] = -87;
  CHARS[3896] = 33;
  CHARS[3897] = -87;
  fill_0(CHARS, 3898, 3902, 33);
  fill_0(CHARS, 3902, 3904, -87);
  fill_0(CHARS, 3904, 3912, -19);
  CHARS[3912] = 33;
  fill_0(CHARS, 3913, 3946, -19);
  fill_0(CHARS, 3946, 3953, 33);
  fill_0(CHARS, 3953, 3973, -87);
  CHARS[3973] = 33;
  fill_0(CHARS, 3974, 3980, -87);
  fill_0(CHARS, 3980, 3984, 33);
  fill_0(CHARS, 3984, 3990, -87);
  CHARS[3990] = 33;
  CHARS[3991] = -87;
  CHARS[3992] = 33;
  fill_0(CHARS, 3993, 4014, -87);
  fill_0(CHARS, 4014, 4017, 33);
  fill_0(CHARS, 4017, 4024, -87);
  CHARS[4024] = 33;
  CHARS[4025] = -87;
  fill_0(CHARS, 4026, 4256, 33);
  fill_0(CHARS, 4256, 4294, -19);
  fill_0(CHARS, 4294, 4304, 33);
  fill_0(CHARS, 4304, 4343, -19);
  fill_0(CHARS, 4343, 4352, 33);
  CHARS[4352] = -19;
  CHARS[4353] = 33;
  fill_0(CHARS, 4354, 4356, -19);
  CHARS[4356] = 33;
  fill_0(CHARS, 4357, 4360, -19);
  CHARS[4360] = 33;
  CHARS[4361] = -19;
  CHARS[4362] = 33;
  fill_0(CHARS, 4363, 4365, -19);
  CHARS[4365] = 33;
  fill_0(CHARS, 4366, 4371, -19);
  fill_0(CHARS, 4371, 4412, 33);
  CHARS[4412] = -19;
  CHARS[4413] = 33;
  CHARS[4414] = -19;
  CHARS[4415] = 33;
  CHARS[4416] = -19;
  fill_0(CHARS, 4417, 4428, 33);
  CHARS[4428] = -19;
  CHARS[4429] = 33;
  CHARS[4430] = -19;
  CHARS[4431] = 33;
  CHARS[4432] = -19;
  fill_0(CHARS, 4433, 4436, 33);
  fill_0(CHARS, 4436, 4438, -19);
  fill_0(CHARS, 4438, 4441, 33);
  CHARS[4441] = -19;
  fill_0(CHARS, 4442, 4447, 33);
  fill_0(CHARS, 4447, 4450, -19);
  CHARS[4450] = 33;
  CHARS[4451] = -19;
  CHARS[4452] = 33;
  CHARS[4453] = -19;
  CHARS[4454] = 33;
  CHARS[4455] = -19;
  CHARS[4456] = 33;
  CHARS[4457] = -19;
  fill_0(CHARS, 4458, 4461, 33);
  fill_0(CHARS, 4461, 4463, -19);
  fill_0(CHARS, 4463, 4466, 33);
  fill_0(CHARS, 4466, 4468, -19);
  CHARS[4468] = 33;
  CHARS[4469] = -19;
  fill_0(CHARS, 4470, 4510, 33);
  CHARS[4510] = -19;
  fill_0(CHARS, 4511, 4520, 33);
  CHARS[4520] = -19;
  fill_0(CHARS, 4521, 4523, 33);
  CHARS[4523] = -19;
  fill_0(CHARS, 4524, 4526, 33);
  fill_0(CHARS, 4526, 4528, -19);
  fill_0(CHARS, 4528, 4535, 33);
  fill_0(CHARS, 4535, 4537, -19);
  CHARS[4537] = 33;
  CHARS[4538] = -19;
  CHARS[4539] = 33;
  fill_0(CHARS, 4540, 4547, -19);
  fill_0(CHARS, 4547, 4587, 33);
  CHARS[4587] = -19;
  fill_0(CHARS, 4588, 4592, 33);
  CHARS[4592] = -19;
  fill_0(CHARS, 4593, 4601, 33);
  CHARS[4601] = -19;
  fill_0(CHARS, 4602, 7680, 33);
  fill_0(CHARS, 7680, 7836, -19);
  fill_0(CHARS, 7836, 7840, 33);
  fill_0(CHARS, 7840, 7930, -19);
  fill_0(CHARS, 7930, 7936, 33);
  fill_0(CHARS, 7936, 7958, -19);
  fill_0(CHARS, 7958, 7960, 33);
  fill_0(CHARS, 7960, 7966, -19);
  fill_0(CHARS, 7966, 7968, 33);
  fill_0(CHARS, 7968, 8006, -19);
  fill_0(CHARS, 8006, 8008, 33);
  fill_0(CHARS, 8008, 8014, -19);
  fill_0(CHARS, 8014, 8016, 33);
  fill_0(CHARS, 8016, 8024, -19);
  CHARS[8024] = 33;
  CHARS[8025] = -19;
  CHARS[8026] = 33;
  CHARS[8027] = -19;
  CHARS[8028] = 33;
  CHARS[8029] = -19;
  CHARS[8030] = 33;
  fill_0(CHARS, 8031, 8062, -19);
  fill_0(CHARS, 8062, 8064, 33);
  fill_0(CHARS, 8064, 8117, -19);
  CHARS[8117] = 33;
  fill_0(CHARS, 8118, 8125, -19);
  CHARS[8125] = 33;
  CHARS[8126] = -19;
  fill_0(CHARS, 8127, 8130, 33);
  fill_0(CHARS, 8130, 8133, -19);
  CHARS[8133] = 33;
  fill_0(CHARS, 8134, 8141, -19);
  fill_0(CHARS, 8141, 8144, 33);
  fill_0(CHARS, 8144, 8148, -19);
  fill_0(CHARS, 8148, 8150, 33);
  fill_0(CHARS, 8150, 8156, -19);
  fill_0(CHARS, 8156, 8160, 33);
  fill_0(CHARS, 8160, 8173, -19);
  fill_0(CHARS, 8173, 8178, 33);
  fill_0(CHARS, 8178, 8181, -19);
  CHARS[8181] = 33;
  fill_0(CHARS, 8182, 8189, -19);
  fill_0(CHARS, 8189, 8400, 33);
  fill_0(CHARS, 8400, 8413, -87);
  fill_0(CHARS, 8413, 8417, 33);
  CHARS[8417] = -87;
  fill_0(CHARS, 8418, 8486, 33);
  CHARS[8486] = -19;
  fill_0(CHARS, 8487, 8490, 33);
  fill_0(CHARS, 8490, 8492, -19);
  fill_0(CHARS, 8492, 8494, 33);
  CHARS[8494] = -19;
  fill_0(CHARS, 8495, 8576, 33);
  fill_0(CHARS, 8576, 8579, -19);
  fill_0(CHARS, 8579, 12293, 33);
  CHARS[12293] = -87;
  CHARS[12294] = 33;
  CHARS[12295] = -19;
  fill_0(CHARS, 12296, 12321, 33);
  fill_0(CHARS, 12321, 12330, -19);
  fill_0(CHARS, 12330, 12336, -87);
  CHARS[12336] = 33;
  fill_0(CHARS, 12337, 12342, -87);
  fill_0(CHARS, 12342, 12353, 33);
  fill_0(CHARS, 12353, 12437, -19);
  fill_0(CHARS, 12437, 12441, 33);
  fill_0(CHARS, 12441, 12443, -87);
  fill_0(CHARS, 12443, 12445, 33);
  fill_0(CHARS, 12445, 12447, -87);
  fill_0(CHARS, 12447, 12449, 33);
  fill_0(CHARS, 12449, 12539, -19);
  CHARS[12539] = 33;
  fill_0(CHARS, 12540, 12543, -87);
  fill_0(CHARS, 12543, 12549, 33);
  fill_0(CHARS, 12549, 12589, -19);
  fill_0(CHARS, 12589, 19968, 33);
  fill_0(CHARS, 19968, 40870, -19);
  fill_0(CHARS, 40870, 44032, 33);
  fill_0(CHARS, 44032, 55204, -19);
  fill_0(CHARS, 55204, $intern_67, 33);
  fill_0(CHARS, 57344, 65534, 33);
}

var CHARS;
function RegEx$ParseException(mes){
  RuntimeException_0.call(this, mes);
}

defineClass(42, 54, $intern_44, RegEx$ParseException);
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$ParseException_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/ParseException', 42);
function $next_19(this$static){
  var ch_0, low, ret;
  if (this$static.offset >= this$static.regexlen) {
    this$static.chardata = -1;
    this$static.nexttoken = 1;
    return;
  }
  ch_0 = $charAt(this$static.regex, this$static.offset++);
  this$static.chardata = ch_0;
  if (this$static.context == 1) {
    switch (ch_0) {
      case 92:
        ret = 10;
        if (this$static.offset >= this$static.regexlen)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.1'))));
        this$static.chardata = $charAt(this$static.regex, this$static.offset++);
        break;
      case 45:
        if ((this$static.options_0 & 512) == 512 && this$static.offset < this$static.regexlen && $charAt(this$static.regex, this$static.offset) == 91) {
          ++this$static.offset;
          ret = 24;
        }
         else 
          ret = 0;
        break;
      case 91:
        if ((this$static.options_0 & 512) != 512 && this$static.offset < this$static.regexlen && $charAt(this$static.regex, this$static.offset) == 58) {
          ++this$static.offset;
          ret = 20;
          break;
        }

      default:if ((ch_0 & 64512) == $intern_67 && this$static.offset < this$static.regexlen) {
          low = $charAt(this$static.regex, this$static.offset);
          if ((low & 64512) == 56320) {
            this$static.chardata = $intern_66 + (ch_0 - $intern_67 << 10) + low - 56320;
            ++this$static.offset;
          }
        }

        ret = 0;
    }
    this$static.nexttoken = ret;
    return;
  }
  switch (ch_0) {
    case 124:
      ret = 2;
      break;
    case 42:
      ret = 3;
      break;
    case 43:
      ret = 4;
      break;
    case 63:
      ret = 5;
      break;
    case 41:
      ret = 7;
      break;
    case 46:
      ret = 8;
      break;
    case 91:
      ret = 9;
      break;
    case 94:
      ret = 11;
      break;
    case 36:
      ret = 12;
      break;
    case 40:
      ret = 6;
      if (this$static.offset >= this$static.regexlen)
        break;
      if ($charAt(this$static.regex, this$static.offset) != 63)
        break;
      if (++this$static.offset >= this$static.regexlen)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.2'))));
      ch_0 = $charAt(this$static.regex, this$static.offset++);
      switch (ch_0) {
        case 58:
          ret = 13;
          break;
        case 61:
          ret = 14;
          break;
        case 33:
          ret = 15;
          break;
        case 91:
          ret = 19;
          break;
        case 62:
          ret = 18;
          break;
        case 60:
          if (this$static.offset >= this$static.regexlen)
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.2'))));
          ch_0 = $charAt(this$static.regex, this$static.offset++);
          if (ch_0 == 61) {
            ret = 16;
          }
           else if (ch_0 == 33) {
            ret = 17;
          }
           else 
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.3'))));
          break;
        case 35:
          while (this$static.offset < this$static.regexlen) {
            ch_0 = $charAt(this$static.regex, this$static.offset++);
            if (ch_0 == 41)
              break;
          }

          if (ch_0 != 41)
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.4'))));
          ret = 21;
          break;
        default:if (ch_0 == 45 || 97 <= ch_0 && ch_0 <= 122 || 65 <= ch_0 && ch_0 <= 90) {
            --this$static.offset;
            ret = 22;
            break;
          }
           else if (ch_0 == 40) {
            ret = 23;
            break;
          }

          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.2'))));
      }

      break;
    case 92:
      ret = 10;
      if (this$static.offset >= this$static.regexlen)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.1'))));
      this$static.chardata = $charAt(this$static.regex, this$static.offset++);
      break;
    default:ret = 0;
  }
  this$static.nexttoken = ret;
}

function $parse_3(this$static, regex, options){
  var i, position, ret;
  this$static.options_0 = options;
  this$static.offset = 0;
  this$static.context = 0;
  this$static.parennumber = 1;
  this$static.regex = regex;
  (this$static.options_0 & 16) == 16 && (this$static.regex = stripExtendedComment(this$static.regex));
  this$static.regexlen = this$static.regex.length;
  $next_19(this$static);
  ret = $parseRegex(this$static);
  if (this$static.offset != this$static.regexlen)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.parse.1'))));
  if (this$static.references) {
    for (i = 0; i < this$static.references.arrayList.array.length; i++) {
      position = castTo($elementAt(this$static.references, i), 552);
      if (this$static.parennumber <= position.refNumber)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.parse.2'))));
    }
    this$static.references.arrayList.array = initUnidimensionalArray(Ljava_lang_Object_2_classLit, $intern_1, 1, 0, 5, 1);
  }
  return ret;
}

function $parseAtom(this$static){
  var ch_0, ch2, high, sur, tok;
  ch_0 = this$static.nexttoken;
  switch (ch_0) {
    case 6:
      return this$static.processParen();
    case 13:
      return this$static.processParen2();
    case 23:
      return this$static.processCondition();
    case 22:
      return this$static.processModifiers();
    case 18:
      return this$static.processIndependent();
    case 8:
      $next_19(this$static);
      tok = ($clinit_RegEx$Token() , token_dot);
      break;
    case 9:
      return this$static.parseCharacterClass(true);
    case 19:
      return this$static.parseSetOperations();
    case 10:
      switch (this$static.chardata) {
        case 100:
        case 68:
        case 119:
        case 87:
        case 115:
        case 83:
          tok = this$static.getTokenForShorthand(this$static.chardata);
          $next_19(this$static);
          return tok;
        case 101:
        case 102:
        case 110:
        case 114:
        case 116:
        case 117:
        case 118:
        case 120:
          {
            ch2 = this$static.decodeEscaped();
            ch2 < $intern_66?(tok = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$CharToken(0, ch2))):(tok = createString_0(decomposeToSurrogates(ch2)));
          }

          break;
        case 99:
          return this$static.processBacksolidus_c();
        case 67:
          return this$static.processBacksolidus_C();
        case 105:
          return this$static.processBacksolidus_i();
        case 73:
          return this$static.processBacksolidus_I();
        case 103:
          return this$static.processBacksolidus_g();
        case 88:
          return this$static.processBacksolidus_X();
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this$static.processBackreference();
        case 80:
        case 112:
          tok = $processBacksolidus_pP(this$static, this$static.chardata);
          if (!tok)
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.atom.5'))));
          break;
        default:tok = createChar(this$static.chardata);
      }

      $next_19(this$static);
      break;
    case 0:
      if (this$static.chardata == 93 || this$static.chardata == 123 || this$static.chardata == 125)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.atom.4'))));
      tok = createChar(this$static.chardata);
      high = this$static.chardata;
      $next_19(this$static);
      if ((high & 64512) == $intern_67 && this$static.nexttoken == 0 && (this$static.chardata & 64512) == 56320) {
        sur = initUnidimensionalArray(C_classLit, $intern_45, 23, 2, 15, 1);
        sur[0] = high & $intern_47;
        sur[1] = this$static.chardata & $intern_47;
        tok = createParen(createString_0(valueOf_9(sur, 0, sur.length)), 0);
        $next_19(this$static);
      }

      break;
    default:throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.atom.4'))));
  }
  return tok;
}

function $parseFactor(this$static){
  var ch_0, max_0, min_0, off, tok;
  ch_0 = this$static.nexttoken;
  switch (ch_0) {
    case 11:
      return this$static.processCaret();
    case 12:
      return this$static.processDollar();
    case 14:
      return this$static.processLookahead();
    case 15:
      return this$static.processNegativelookahead();
    case 16:
      return this$static.processLookbehind();
    case 17:
      return this$static.processNegativelookbehind();
    case 21:
      $next_19(this$static);
      return $clinit_RegEx$Token() , $clinit_RegEx$Token() , token_empty;
    case 10:
      switch (this$static.chardata) {
        case 65:
          return this$static.processBacksolidus_A();
        case 90:
          return this$static.processBacksolidus_Z();
        case 122:
          return this$static.processBacksolidus_z();
        case 98:
          return this$static.processBacksolidus_b();
        case 66:
          return this$static.processBacksolidus_B();
        case 60:
          return this$static.processBacksolidus_lt();
        case 62:
          return this$static.processBacksolidus_gt();
      }

  }
  tok = $parseAtom(this$static);
  ch_0 = this$static.nexttoken;
  switch (ch_0) {
    case 3:
      return this$static.processStar(tok);
    case 4:
      return this$static.processPlus(tok);
    case 5:
      return this$static.processQuestion(tok);
    case 0:
      if (this$static.chardata == 123 && this$static.offset < this$static.regexlen) {
        off = this$static.offset;
        if ((ch_0 = $charAt(this$static.regex, off++)) >= 48 && ch_0 <= 57) {
          min_0 = ch_0 - 48;
          while (off < this$static.regexlen && (ch_0 = $charAt(this$static.regex, off++)) >= 48 && ch_0 <= 57) {
            min_0 = min_0 * 10 + ch_0 - 48;
            if (min_0 < 0)
              throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.quantifier.5'))));
          }
        }
         else {
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.quantifier.1'))));
        }
        max_0 = min_0;
        if (ch_0 == 44) {
          if (off >= this$static.regexlen) {
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.quantifier.3'))));
          }
           else if ((ch_0 = $charAt(this$static.regex, off++)) >= 48 && ch_0 <= 57) {
            max_0 = ch_0 - 48;
            while (off < this$static.regexlen && (ch_0 = $charAt(this$static.regex, off++)) >= 48 && ch_0 <= 57) {
              max_0 = max_0 * 10 + ch_0 - 48;
              if (max_0 < 0)
                throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.quantifier.5'))));
            }
            if (min_0 > max_0)
              throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.quantifier.4'))));
          }
           else {
            max_0 = -1;
          }
        }
        if (ch_0 != 125)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.quantifier.2'))));
        if (this$static.checkQuestion(off)) {
          tok = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ClosureToken(9, tok));
          this$static.offset = off + 1;
        }
         else {
          tok = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ClosureToken(3, tok));
          this$static.offset = off;
        }
        tok.setMin(min_0);
        tok.setMax(max_0);
        $next_19(this$static);
      }

  }
  return tok;
}

function $parseRegex(this$static){
  var parent_0, tok;
  tok = $parseTerm(this$static);
  parent_0 = null;
  while (this$static.nexttoken == 2) {
    $next_19(this$static);
    if (!parent_0) {
      parent_0 = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$UnionToken(2));
      $addChild(parent_0, tok);
      tok = parent_0;
    }
    tok.addChild($parseTerm(this$static));
  }
  return tok;
}

function $parseTerm(this$static){
  var ch_0, concat, tok;
  ch_0 = this$static.nexttoken;
  if (ch_0 == 2 || ch_0 == 7 || ch_0 == 1) {
    return $clinit_RegEx$Token() , $clinit_RegEx$Token() , token_empty;
  }
   else {
    tok = $parseFactor(this$static);
    concat = null;
    while ((ch_0 = this$static.nexttoken) != 2 && ch_0 != 7 && ch_0 != 1) {
      if (!concat) {
        concat = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$UnionToken(1));
        $addChild(concat, tok);
        tok = concat;
      }
      $addChild(concat, $parseFactor(this$static));
    }
    return tok;
  }
}

function $processBacksolidus_pP(this$static, c){
  var nameend, namestart, pname, positive;
  $next_19(this$static);
  if (this$static.nexttoken != 0 || this$static.chardata != 123)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.atom.2'))));
  positive = c == 112;
  namestart = this$static.offset;
  nameend = $indexOf_0(this$static.regex, 125, namestart);
  if (nameend < 0)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.atom.3'))));
  pname = $substring_1(this$static.regex, namestart, nameend);
  this$static.offset = nameend + 1;
  return getRange_1(pname, positive, (this$static.options_0 & 512) == 512);
}

function RegEx$RegexParser(){
}

function hexChar(ch_0){
  if (ch_0 < 48)
    return -1;
  if (ch_0 > 102)
    return -1;
  if (ch_0 <= 57)
    return ch_0 - 48;
  if (ch_0 < 65)
    return -1;
  if (ch_0 <= 70)
    return ch_0 - 65 + 10;
  if (ch_0 < 97)
    return -1;
  return ch_0 - 97 + 10;
}

defineClass(758, 1, {}, RegEx$RegexParser);
_.checkQuestion = function checkQuestion(off){
  return off < this.regexlen && $charAt(this.regex, off) == 63;
}
;
_.decodeEscaped = function decodeEscaped(){
  var c, uv, uv0, v1, v10;
  if (this.nexttoken != 10)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.1'))));
  c = this.chardata;
  switch (c) {
    case 101:
      c = 27;
      break;
    case 102:
      c = 12;
      break;
    case 110:
      c = 10;
      break;
    case 114:
      c = 13;
      break;
    case 116:
      c = 9;
      break;
    case 120:
      $next_19(this);
      if (this.nexttoken != 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      if (this.chardata == 123) {
        uv0 = 0;
        do {
          $next_19(this);
          if (this.nexttoken != 0)
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
          if ((v10 = hexChar(this.chardata)) < 0)
            break;
          if (uv0 > uv0 * 16)
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.2'))));
          uv0 = uv0 * 16 + v10;
        }
         while (true);
        if (this.chardata != 125)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.3'))));
        if (uv0 > $intern_167)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.4'))));
        c = uv0;
      }
       else {
        v10 = 0;
        if (this.nexttoken != 0 || (v10 = hexChar(this.chardata)) < 0)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
        uv0 = v10;
        $next_19(this);
        if (this.nexttoken != 0 || (v10 = hexChar(this.chardata)) < 0)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
        uv0 = uv0 * 16 + v10;
        c = uv0;
      }

      break;
    case 117:
      v1 = 0;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = v1;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = uv * 16 + v1;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = uv * 16 + v1;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = uv * 16 + v1;
      c = uv;
      break;
    case 118:
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = v1;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = uv * 16 + v1;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = uv * 16 + v1;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = uv * 16 + v1;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = uv * 16 + v1;
      $next_19(this);
      if (this.nexttoken != 0 || (v1 = hexChar(this.chardata)) < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.1'))));
      uv = uv * 16 + v1;
      if (uv > $intern_167)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descappe.4'))));
      c = uv;
      break;
    case 65:
    case 90:
    case 122:
      throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.descape.5'))));
  }
  return c;
}
;
_.getTokenForShorthand = function getTokenForShorthand(ch_0){
  var tok;
  switch (ch_0) {
    case 100:
      tok = (this.options_0 & 32) == 32?getRange_0('Nd', true):($clinit_RegEx$Token() , token_0to9);
      break;
    case 68:
      tok = (this.options_0 & 32) == 32?getRange_0('Nd', false):($clinit_RegEx$Token() , token_not_0to9);
      break;
    case 119:
      tok = (this.options_0 & 32) == 32?getRange_0('IsWord', true):($clinit_RegEx$Token() , token_wordchars);
      break;
    case 87:
      tok = (this.options_0 & 32) == 32?getRange_0('IsWord', false):($clinit_RegEx$Token() , token_not_wordchars);
      break;
    case 115:
      tok = (this.options_0 & 32) == 32?getRange_0('IsSpace', true):($clinit_RegEx$Token() , token_spaces);
      break;
    case 83:
      tok = (this.options_0 & 32) == 32?getRange_0('IsSpace', false):($clinit_RegEx$Token() , token_not_spaces);
      break;
    default:throw toJs(new RuntimeException_0('Internal Error: shorthands: \\u' + ch_0.toString(16)));
  }
  return tok;
}
;
_.parseCharacterClass = function parseCharacterClass(useNrange){
  var base, c, end, firstloop, name_0, nameend, positive, range, rangeend, tok, tok2, type_0;
  this.context = 1;
  $next_19(this);
  base = null;
  if (this.nexttoken == 0 && this.chardata == 94) {
    $next_19(this);
    if (useNrange) {
      tok = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$RangeToken(5));
    }
     else {
      base = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$RangeToken(4));
      $addRange(base, 0, $intern_167);
      tok = (null , ++tokens_0 , new RegEx$RangeToken(4));
    }
  }
   else {
    tok = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$RangeToken(4));
  }
  firstloop = true;
  while ((type_0 = this.nexttoken) != 1) {
    if (type_0 == 0 && this.chardata == 93 && !firstloop)
      break;
    firstloop = false;
    c = this.chardata;
    end = false;
    if (type_0 == 10) {
      switch (c) {
        case 100:
        case 68:
        case 119:
        case 87:
        case 115:
        case 83:
          $mergeRanges(tok, this.getTokenForShorthand(c));
          end = true;
          break;
        case 105:
        case 73:
        case 99:
        case 67:
          c = this.processCIinCharacterClass(tok, c);
          c < 0 && (end = true);
          break;
        case 112:
        case 80:
          tok2 = $processBacksolidus_pP(this, c);
          if (!tok2)
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.atom.5'))));
          $mergeRanges(tok, tok2);
          end = true;
          break;
        default:c = this.decodeEscaped();
      }
    }
     else if (type_0 == 20) {
      nameend = $indexOf_0(this.regex, 58, this.offset);
      if (nameend < 0)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.1'))));
      positive = true;
      if ($charAt(this.regex, this.offset) == 94) {
        ++this.offset;
        positive = false;
      }
      name_0 = $substring_1(this.regex, this.offset, nameend);
      range = getRange_1(name_0, positive, (this.options_0 & 512) == 512);
      if (!range)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.3'))));
      $mergeRanges(tok, range);
      end = true;
      if (nameend + 1 >= this.regexlen || $charAt(this.regex, nameend + 1) != 93)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.1'))));
      this.offset = nameend + 2;
    }
    $next_19(this);
    if (!end) {
      if (this.nexttoken != 0 || this.chardata != 45) {
        $addRange(tok, c, c);
      }
       else {
        $next_19(this);
        if ((type_0 = this.nexttoken) == 1)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.2'))));
        if (type_0 == 0 && this.chardata == 93) {
          $addRange(tok, c, c);
          $addRange(tok, 45, 45);
        }
         else {
          rangeend = this.chardata;
          type_0 == 10 && (rangeend = this.decodeEscaped());
          $next_19(this);
          $addRange(tok, c, rangeend);
        }
      }
    }
    (this.options_0 & $intern_89) == $intern_89 && this.nexttoken == 0 && this.chardata == 44 && $next_19(this);
  }
  if (this.nexttoken == 1)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.2'))));
  if (base) {
    $subtractRanges(base, tok);
    tok = base;
  }
  $sortRanges(tok);
  $compactRanges(tok);
  this.context = 0;
  $next_19(this);
  return tok;
}
;
_.parseSetOperations = function parseSetOperations(){
  var ch_0, t2, tok, type_0;
  tok = this.parseCharacterClass(false);
  while ((type_0 = this.nexttoken) != 7) {
    ch_0 = this.chardata;
    if (type_0 == 0 && (ch_0 == 45 || ch_0 == 38) || type_0 == 4) {
      $next_19(this);
      if (this.nexttoken != 9)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.ope.1'))));
      t2 = this.parseCharacterClass(false);
      if (type_0 == 4)
        $mergeRanges(tok, t2);
      else if (ch_0 == 45)
        $subtractRanges(tok, t2);
      else if (ch_0 == 38)
        $intersectRanges(tok, t2);
      else 
        throw toJs(new RuntimeException_0('ASSERT'));
    }
     else {
      throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.ope.2'))));
    }
  }
  $next_19(this);
  return tok;
}
;
_.processBackreference = function processBackreference(){
  var refnum, tok;
  refnum = this.chardata - 48;
  tok = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$StringToken(12, null, refnum));
  !this.references && (this.references = new Vector);
  $addElement(this.references, new RegEx$RegexParser$ReferencePosition(refnum));
  $next_19(this);
  return tok;
}
;
_.processBacksolidus_A = function processBacksolidus_A(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_stringbeginning;
}
;
_.processBacksolidus_B = function processBacksolidus_B(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_not_wordedge;
}
;
_.processBacksolidus_C = function processBacksolidus_C(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_I = function processBacksolidus_I(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_X = function processBacksolidus_X(){
  $next_19(this);
  return getCombiningCharacterSequence();
}
;
_.processBacksolidus_Z = function processBacksolidus_Z(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_stringend2;
}
;
_.processBacksolidus_b = function processBacksolidus_b(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_wordedge;
}
;
_.processBacksolidus_c = function processBacksolidus_c(){
  var ch2;
  if (this.offset >= this.regexlen || ((ch2 = $charAt(this.regex, this.offset++)) & 65504) != 64)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.atom.1'))));
  $next_19(this);
  return $clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$CharToken(0, ch2 - 64);
}
;
_.processBacksolidus_g = function processBacksolidus_g(){
  $next_19(this);
  return getGraphemePattern();
}
;
_.processBacksolidus_gt = function processBacksolidus_gt(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_wordend;
}
;
_.processBacksolidus_i = function processBacksolidus_i(){
  var tok;
  tok = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$CharToken(0, 105));
  $next_19(this);
  return tok;
}
;
_.processBacksolidus_lt = function processBacksolidus_lt(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_wordbeginning;
}
;
_.processBacksolidus_z = function processBacksolidus_z(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_stringend;
}
;
_.processCIinCharacterClass = function processCIinCharacterClass(tok, c){
  return this.decodeEscaped();
}
;
_.processCaret = function processCaret(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_linebeginning;
}
;
_.processCondition = function processCondition(){
  var ch_0, condition, noPattern, refno, yesPattern;
  if (this.offset + 1 >= this.regexlen)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.4'))));
  refno = -1;
  condition = null;
  ch_0 = $charAt(this.regex, this.offset);
  if (49 <= ch_0 && ch_0 <= 57) {
    refno = ch_0 - 48;
    !this.references && (this.references = new Vector);
    $addElement(this.references, new RegEx$RegexParser$ReferencePosition(refno));
    ++this.offset;
    if ($charAt(this.regex, this.offset) != 41)
      throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
    ++this.offset;
  }
   else {
    ch_0 == 63 && --this.offset;
    $next_19(this);
    condition = $parseFactor(this);
    switch (condition.type_0) {
      case 20:
      case 21:
      case 22:
      case 23:
        break;
      case 8:
        if (this.nexttoken != 7)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
        break;
      default:throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.5'))));
    }
  }
  $next_19(this);
  yesPattern = $parseRegex(this);
  noPattern = null;
  if (yesPattern.type_0 == 2) {
    if (yesPattern.size_2() != 2)
      throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.6'))));
    noPattern = yesPattern.getChild(1);
    yesPattern = yesPattern.getChild(0);
  }
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return $clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ConditionToken(refno, condition, yesPattern, noPattern);
}
;
_.processDollar = function processDollar(){
  $next_19(this);
  return $clinit_RegEx$Token() , token_lineend;
}
;
_.processIndependent = function processIndependent(){
  var tok;
  $next_19(this);
  tok = createLook(24, $parseRegex(this));
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return tok;
}
;
_.processLookahead = function processLookahead(){
  var tok;
  $next_19(this);
  tok = createLook(20, $parseRegex(this));
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return tok;
}
;
_.processLookbehind = function processLookbehind(){
  var tok;
  $next_19(this);
  tok = createLook(22, $parseRegex(this));
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return tok;
}
;
_.processModifiers = function processModifiers(){
  var add_0, ch_0, mask, tok, v;
  add_0 = 0;
  mask = 0;
  ch_0 = -1;
  while (this.offset < this.regexlen) {
    ch_0 = $charAt(this.regex, this.offset);
    v = getOptionValue(ch_0);
    if (v == 0)
      break;
    add_0 |= v;
    ++this.offset;
  }
  if (this.offset >= this.regexlen)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.2'))));
  if (ch_0 == 45) {
    ++this.offset;
    while (this.offset < this.regexlen) {
      ch_0 = $charAt(this.regex, this.offset);
      v = getOptionValue(ch_0);
      if (v == 0)
        break;
      mask |= v;
      ++this.offset;
    }
    if (this.offset >= this.regexlen)
      throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.2'))));
  }
  if (ch_0 == 58) {
    ++this.offset;
    $next_19(this);
    tok = createModifierGroup($parseRegex(this), add_0, mask);
    if (this.nexttoken != 7)
      throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
    $next_19(this);
  }
   else if (ch_0 == 41) {
    ++this.offset;
    $next_19(this);
    tok = createModifierGroup($parseRegex(this), add_0, mask);
  }
   else 
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.3'))));
  return tok;
}
;
_.processNegativelookahead = function processNegativelookahead(){
  var tok;
  $next_19(this);
  tok = createLook(21, $parseRegex(this));
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return tok;
}
;
_.processNegativelookbehind = function processNegativelookbehind(){
  var tok;
  $next_19(this);
  tok = createLook(23, $parseRegex(this));
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return tok;
}
;
_.processParen = function processParen(){
  var p, tok;
  $next_19(this);
  p = this.parennumber++;
  tok = createParen($parseRegex(this), p);
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return tok;
}
;
_.processParen2 = function processParen2(){
  var tok;
  $next_19(this);
  tok = createParen($parseRegex(this), 0);
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return tok;
}
;
_.processPlus = function processPlus(tok){
  $next_19(this);
  if (this.nexttoken == 5) {
    $next_19(this);
    return createConcat(tok, ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ClosureToken(9, tok)));
  }
   else 
    return createConcat(tok, ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ClosureToken(3, tok)));
}
;
_.processQuestion = function processQuestion(tok){
  var par;
  $next_19(this);
  par = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$UnionToken(2));
  if (this.nexttoken == 5) {
    $next_19(this);
    $addChild(par, (null , token_empty));
    $addChild(par, tok);
  }
   else {
    $addChild(par, tok);
    $addChild(par, (null , token_empty));
  }
  return par;
}
;
_.processStar = function processStar(tok){
  $next_19(this);
  if (this.nexttoken == 5) {
    $next_19(this);
    return $clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ClosureToken(9, tok);
  }
   else 
    return $clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ClosureToken(3, tok);
}
;
_.chardata = 0;
_.context = 0;
_.nexttoken = 0;
_.offset = 0;
_.options_0 = 0;
_.parennumber = 1;
_.references = null;
_.regexlen = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$RegexParser_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/RegexParser', 758);
function $decodeEscaped(this$static){
  var c;
  if (this$static.nexttoken != 10)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.next.1'))));
  c = this$static.chardata;
  switch (c) {
    case 110:
      c = 10;
      break;
    case 114:
      c = 13;
      break;
    case 116:
      c = 9;
      break;
    case 92:
    case 124:
    case 46:
    case 94:
    case 45:
    case 63:
    case 42:
    case 43:
    case 123:
    case 125:
    case 40:
    case 41:
    case 91:
    case 93:
      break;
    default:throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
  }
  return c;
}

function $getTokenForShorthand(ch_0){
  switch (ch_0) {
    case 100:
      return getRange('xml:isDigit', true);
    case 68:
      return getRange('xml:isDigit', false);
    case 119:
      return getRange('xml:isWord', true);
    case 87:
      return getRange('xml:isWord', false);
    case 115:
      return getRange('xml:isSpace', true);
    case 83:
      return getRange('xml:isSpace', false);
    case 99:
      return getRange('xml:isNameChar', true);
    case 67:
      return getRange('xml:isNameChar', false);
    case 105:
      return getRange('xml:isInitialNameChar', true);
    case 73:
      return getRange('xml:isInitialNameChar', false);
    default:throw toJs(new RuntimeException_0('Internal Error: shorthands: \\u' + ch_0.toString(16)));
  }
}

function $parseCharacterClass(this$static){
  var base, c, end, firstloop, range2, rangeend, tok, tok2, type_0;
  this$static.context = 1;
  $next_19(this$static);
  base = null;
  if (this$static.nexttoken == 0 && this$static.chardata == 94) {
    $next_19(this$static);
    base = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$RangeToken(4));
    $addRange(base, 0, $intern_167);
    tok = (null , ++tokens_0 , new RegEx$RangeToken(4));
  }
   else {
    tok = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$RangeToken(4));
  }
  firstloop = true;
  while ((type_0 = this$static.nexttoken) != 1) {
    if (type_0 == 0 && this$static.chardata == 93 && !firstloop) {
      if (base) {
        $subtractRanges(base, tok);
        tok = base;
      }
      break;
    }
    c = this$static.chardata;
    end = false;
    if (type_0 == 10) {
      switch (c) {
        case 100:
        case 68:
        case 119:
        case 87:
        case 115:
        case 83:
          $mergeRanges(tok, $getTokenForShorthand(c));
          end = true;
          break;
        case 105:
        case 73:
        case 99:
        case 67:
          c = ($mergeRanges(tok, $getTokenForShorthand(c)) , -1);
          end = true;
          break;
        case 112:
        case 80:
          tok2 = $processBacksolidus_pP(this$static, c);
          if (!tok2)
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.atom.5'))));
          $mergeRanges(tok, tok2);
          end = true;
          break;
        default:c = $decodeEscaped(this$static);
      }
    }
     else if (type_0 == 24 && !firstloop) {
      if (base) {
        $subtractRanges(base, tok);
        tok = base;
      }
      range2 = $parseCharacterClass(this$static);
      $subtractRanges(tok, range2);
      if (this$static.nexttoken != 0 || this$static.chardata != 93)
        throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.5'))));
      break;
    }
    $next_19(this$static);
    if (!end) {
      if (type_0 == 0) {
        if (c == 91)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.6'))));
        if (c == 93)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.7'))));
        if (c == 45 && !firstloop && this$static.chardata != 93)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.8'))));
      }
      if (this$static.nexttoken != 0 || this$static.chardata != 45 || c == 45 && firstloop) {
        $addRange(tok, c, c);
      }
       else {
        $next_19(this$static);
        if ((type_0 = this$static.nexttoken) == 1)
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.2'))));
        if (type_0 == 0 && this$static.chardata == 93) {
          $addRange(tok, c, c);
          $addRange(tok, 45, 45);
        }
         else if (type_0 == 0 && this$static.chardata == 93 || type_0 == 24) {
          throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.8'))));
        }
         else {
          rangeend = this$static.chardata;
          if (type_0 == 0) {
            if (rangeend == 91)
              throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.6'))));
            if (rangeend == 93)
              throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.7'))));
            if (rangeend == 45)
              throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.8'))));
          }
           else 
            type_0 == 10 && (rangeend = $decodeEscaped(this$static));
          $next_19(this$static);
          if (c > rangeend)
            throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.ope.3'))));
          $addRange(tok, c, rangeend);
        }
      }
    }
    firstloop = false;
  }
  if (this$static.nexttoken == 1)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.cc.2'))));
  $sortRanges(tok);
  $compactRanges(tok);
  this$static.context = 0;
  $next_19(this$static);
  return tok;
}

function RegEx$ParserForXMLSchema(){
  RegEx$RegexParser.call(this);
}

function getRange(name_0, positive){
  var tok, tok0;
  if (!ranges_0) {
    ranges_0 = new HashMap;
    ranges2 = new HashMap;
    tok0 = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$RangeToken(4));
    setupRange(tok0, '\t\n\r\r  ');
    $putStringValue(ranges_0, 'xml:isSpace', tok0);
    $putStringValue(ranges2, 'xml:isSpace', complementRanges(tok0));
    tok0 = (null , ++tokens_0 , new RegEx$RangeToken(4));
    setupRange(tok0, '09\u0660\u0669\u06F0\u06F9\u0966\u096F\u09E6\u09EF\u0A66\u0A6F\u0AE6\u0AEF\u0B66\u0B6F\u0BE7\u0BEF\u0C66\u0C6F\u0CE6\u0CEF\u0D66\u0D6F\u0E50\u0E59\u0ED0\u0ED9\u0F20\u0F29');
    $putStringValue(ranges_0, 'xml:isDigit', tok0);
    $putStringValue(ranges2, 'xml:isDigit', complementRanges(tok0));
    tok0 = (null , ++tokens_0 , new RegEx$RangeToken(4));
    setupRange(tok0, '09\u0660\u0669\u06F0\u06F9\u0966\u096F\u09E6\u09EF\u0A66\u0A6F\u0AE6\u0AEF\u0B66\u0B6F\u0BE7\u0BEF\u0C66\u0C6F\u0CE6\u0CEF\u0D66\u0D6F\u0E50\u0E59\u0ED0\u0ED9\u0F20\u0F29');
    $putStringValue(ranges_0, 'xml:isDigit', tok0);
    $putStringValue(ranges2, 'xml:isDigit', complementRanges(tok0));
    tok0 = (null , ++tokens_0 , new RegEx$RangeToken(4));
    setupRange(tok0, 'AZaz\xC0\xD6\xD8\xF6\xF8\u0131\u0134\u013E\u0141\u0148\u014A\u017E\u0180\u01C3\u01CD\u01F0\u01F4\u01F5\u01FA\u0217\u0250\u02A8\u02BB\u02C1\u0386\u0386\u0388\u038A\u038C\u038C\u038E\u03A1\u03A3\u03CE\u03D0\u03D6\u03DA\u03DA\u03DC\u03DC\u03DE\u03DE\u03E0\u03E0\u03E2\u03F3\u0401\u040C\u040E\u044F\u0451\u045C\u045E\u0481\u0490\u04C4\u04C7\u04C8\u04CB\u04CC\u04D0\u04EB\u04EE\u04F5\u04F8\u04F9\u0531\u0556\u0559\u0559\u0561\u0586\u05D0\u05EA\u05F0\u05F2\u0621\u063A\u0641\u064A\u0671\u06B7\u06BA\u06BE\u06C0\u06CE\u06D0\u06D3\u06D5\u06D5\u06E5\u06E6\u0905\u0939\u093D\u093D\u0958\u0961\u0985\u098C\u098F\u0990\u0993\u09A8\u09AA\u09B0\u09B2\u09B2\u09B6\u09B9\u09DC\u09DD\u09DF\u09E1\u09F0\u09F1\u0A05\u0A0A\u0A0F\u0A10\u0A13\u0A28\u0A2A\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59\u0A5C\u0A5E\u0A5E\u0A72\u0A74\u0A85\u0A8B\u0A8D\u0A8D\u0A8F\u0A91\u0A93\u0AA8\u0AAA\u0AB0\u0AB2\u0AB3\u0AB5\u0AB9\u0ABD\u0ABD\u0AE0\u0AE0\u0B05\u0B0C\u0B0F\u0B10\u0B13\u0B28\u0B2A\u0B30\u0B32\u0B33\u0B36\u0B39\u0B3D\u0B3D\u0B5C\u0B5D\u0B5F\u0B61\u0B85\u0B8A\u0B8E\u0B90\u0B92\u0B95\u0B99\u0B9A\u0B9C\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8\u0BAA\u0BAE\u0BB5\u0BB7\u0BB9\u0C05\u0C0C\u0C0E\u0C10\u0C12\u0C28\u0C2A\u0C33\u0C35\u0C39\u0C60\u0C61\u0C85\u0C8C\u0C8E\u0C90\u0C92\u0CA8\u0CAA\u0CB3\u0CB5\u0CB9\u0CDE\u0CDE\u0CE0\u0CE1\u0D05\u0D0C\u0D0E\u0D10\u0D12\u0D28\u0D2A\u0D39\u0D60\u0D61\u0E01\u0E2E\u0E30\u0E30\u0E32\u0E33\u0E40\u0E45\u0E81\u0E82\u0E84\u0E84\u0E87\u0E88\u0E8A\u0E8A\u0E8D\u0E8D\u0E94\u0E97\u0E99\u0E9F\u0EA1\u0EA3\u0EA5\u0EA5\u0EA7\u0EA7\u0EAA\u0EAB\u0EAD\u0EAE\u0EB0\u0EB0\u0EB2\u0EB3\u0EBD\u0EBD\u0EC0\u0EC4\u0F40\u0F47\u0F49\u0F69\u10A0\u10C5\u10D0\u10F6\u1100\u1100\u1102\u1103\u1105\u1107\u1109\u1109\u110B\u110C\u110E\u1112\u113C\u113C\u113E\u113E\u1140\u1140\u114C\u114C\u114E\u114E\u1150\u1150\u1154\u1155\u1159\u1159\u115F\u1161\u1163\u1163\u1165\u1165\u1167\u1167\u1169\u1169\u116D\u116E\u1172\u1173\u1175\u1175\u119E\u119E\u11A8\u11A8\u11AB\u11AB\u11AE\u11AF\u11B7\u11B8\u11BA\u11BA\u11BC\u11C2\u11EB\u11EB\u11F0\u11F0\u11F9\u11F9\u1E00\u1E9B\u1EA0\u1EF9\u1F00\u1F15\u1F18\u1F1D\u1F20\u1F45\u1F48\u1F4D\u1F50\u1F57\u1F59\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F7D\u1F80\u1FB4\u1FB6\u1FBC\u1FBE\u1FBE\u1FC2\u1FC4\u1FC6\u1FCC\u1FD0\u1FD3\u1FD6\u1FDB\u1FE0\u1FEC\u1FF2\u1FF4\u1FF6\u1FFC\u2126\u2126\u212A\u212B\u212E\u212E\u2180\u2182\u3007\u3007\u3021\u3029\u3041\u3094\u30A1\u30FA\u3105\u312C\u4E00\u9FA5\uAC00\uD7A3');
    $mergeRanges(tok0, castTo($getStringValue(ranges_0, 'xml:isDigit'), 113));
    $putStringValue(ranges_0, 'xml:isWord', tok0);
    $putStringValue(ranges2, 'xml:isWord', complementRanges(tok0));
    tok0 = (null , ++tokens_0 , new RegEx$RangeToken(4));
    setupRange(tok0, '-.0:AZ__az\xB7\xB7\xC0\xD6\xD8\xF6\xF8\u0131\u0134\u013E\u0141\u0148\u014A\u017E\u0180\u01C3\u01CD\u01F0\u01F4\u01F5\u01FA\u0217\u0250\u02A8\u02BB\u02C1\u02D0\u02D1\u0300\u0345\u0360\u0361\u0386\u038A\u038C\u038C\u038E\u03A1\u03A3\u03CE\u03D0\u03D6\u03DA\u03DA\u03DC\u03DC\u03DE\u03DE\u03E0\u03E0\u03E2\u03F3\u0401\u040C\u040E\u044F\u0451\u045C\u045E\u0481\u0483\u0486\u0490\u04C4\u04C7\u04C8\u04CB\u04CC\u04D0\u04EB\u04EE\u04F5\u04F8\u04F9\u0531\u0556\u0559\u0559\u0561\u0586\u0591\u05A1\u05A3\u05B9\u05BB\u05BD\u05BF\u05BF\u05C1\u05C2\u05C4\u05C4\u05D0\u05EA\u05F0\u05F2\u0621\u063A\u0640\u0652\u0660\u0669\u0670\u06B7\u06BA\u06BE\u06C0\u06CE\u06D0\u06D3\u06D5\u06E8\u06EA\u06ED\u06F0\u06F9\u0901\u0903\u0905\u0939\u093C\u094D\u0951\u0954\u0958\u0963\u0966\u096F\u0981\u0983\u0985\u098C\u098F\u0990\u0993\u09A8\u09AA\u09B0\u09B2\u09B2\u09B6\u09B9\u09BC\u09BC\u09BE\u09C4\u09C7\u09C8\u09CB\u09CD\u09D7\u09D7\u09DC\u09DD\u09DF\u09E3\u09E6\u09F1\u0A02\u0A02\u0A05\u0A0A\u0A0F\u0A10\u0A13\u0A28\u0A2A\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3C\u0A3E\u0A42\u0A47\u0A48\u0A4B\u0A4D\u0A59\u0A5C\u0A5E\u0A5E\u0A66\u0A74\u0A81\u0A83\u0A85\u0A8B\u0A8D\u0A8D\u0A8F\u0A91\u0A93\u0AA8\u0AAA\u0AB0\u0AB2\u0AB3\u0AB5\u0AB9\u0ABC\u0AC5\u0AC7\u0AC9\u0ACB\u0ACD\u0AE0\u0AE0\u0AE6\u0AEF\u0B01\u0B03\u0B05\u0B0C\u0B0F\u0B10\u0B13\u0B28\u0B2A\u0B30\u0B32\u0B33\u0B36\u0B39\u0B3C\u0B43\u0B47\u0B48\u0B4B\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F\u0B61\u0B66\u0B6F\u0B82\u0B83\u0B85\u0B8A\u0B8E\u0B90\u0B92\u0B95\u0B99\u0B9A\u0B9C\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8\u0BAA\u0BAE\u0BB5\u0BB7\u0BB9\u0BBE\u0BC2\u0BC6\u0BC8\u0BCA\u0BCD\u0BD7\u0BD7\u0BE7\u0BEF\u0C01\u0C03\u0C05\u0C0C\u0C0E\u0C10\u0C12\u0C28\u0C2A\u0C33\u0C35\u0C39\u0C3E\u0C44\u0C46\u0C48\u0C4A\u0C4D\u0C55\u0C56\u0C60\u0C61\u0C66\u0C6F\u0C82\u0C83\u0C85\u0C8C\u0C8E\u0C90\u0C92\u0CA8\u0CAA\u0CB3\u0CB5\u0CB9\u0CBE\u0CC4\u0CC6\u0CC8\u0CCA\u0CCD\u0CD5\u0CD6\u0CDE\u0CDE\u0CE0\u0CE1\u0CE6\u0CEF\u0D02\u0D03\u0D05\u0D0C\u0D0E\u0D10\u0D12\u0D28\u0D2A\u0D39\u0D3E\u0D43\u0D46\u0D48\u0D4A\u0D4D\u0D57\u0D57\u0D60\u0D61\u0D66\u0D6F\u0E01\u0E2E\u0E30\u0E3A\u0E40\u0E4E\u0E50\u0E59\u0E81\u0E82\u0E84\u0E84\u0E87\u0E88\u0E8A\u0E8A\u0E8D\u0E8D\u0E94\u0E97\u0E99\u0E9F\u0EA1\u0EA3\u0EA5\u0EA5\u0EA7\u0EA7\u0EAA\u0EAB\u0EAD\u0EAE\u0EB0\u0EB9\u0EBB\u0EBD\u0EC0\u0EC4\u0EC6\u0EC6\u0EC8\u0ECD\u0ED0\u0ED9\u0F18\u0F19\u0F20\u0F29\u0F35\u0F35\u0F37\u0F37\u0F39\u0F39\u0F3E\u0F47\u0F49\u0F69\u0F71\u0F84\u0F86\u0F8B\u0F90\u0F95\u0F97\u0F97\u0F99\u0FAD\u0FB1\u0FB7\u0FB9\u0FB9\u10A0\u10C5\u10D0\u10F6\u1100\u1100\u1102\u1103\u1105\u1107\u1109\u1109\u110B\u110C\u110E\u1112\u113C\u113C\u113E\u113E\u1140\u1140\u114C\u114C\u114E\u114E\u1150\u1150\u1154\u1155\u1159\u1159\u115F\u1161\u1163\u1163\u1165\u1165\u1167\u1167\u1169\u1169\u116D\u116E\u1172\u1173\u1175\u1175\u119E\u119E\u11A8\u11A8\u11AB\u11AB\u11AE\u11AF\u11B7\u11B8\u11BA\u11BA\u11BC\u11C2\u11EB\u11EB\u11F0\u11F0\u11F9\u11F9\u1E00\u1E9B\u1EA0\u1EF9\u1F00\u1F15\u1F18\u1F1D\u1F20\u1F45\u1F48\u1F4D\u1F50\u1F57\u1F59\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F7D\u1F80\u1FB4\u1FB6\u1FBC\u1FBE\u1FBE\u1FC2\u1FC4\u1FC6\u1FCC\u1FD0\u1FD3\u1FD6\u1FDB\u1FE0\u1FEC\u1FF2\u1FF4\u1FF6\u1FFC\u20D0\u20DC\u20E1\u20E1\u2126\u2126\u212A\u212B\u212E\u212E\u2180\u2182\u3005\u3005\u3007\u3007\u3021\u302F\u3031\u3035\u3041\u3094\u3099\u309A\u309D\u309E\u30A1\u30FA\u30FC\u30FE\u3105\u312C\u4E00\u9FA5\uAC00\uD7A3');
    $putStringValue(ranges_0, 'xml:isNameChar', tok0);
    $putStringValue(ranges2, 'xml:isNameChar', complementRanges(tok0));
    tok0 = (null , ++tokens_0 , new RegEx$RangeToken(4));
    setupRange(tok0, 'AZaz\xC0\xD6\xD8\xF6\xF8\u0131\u0134\u013E\u0141\u0148\u014A\u017E\u0180\u01C3\u01CD\u01F0\u01F4\u01F5\u01FA\u0217\u0250\u02A8\u02BB\u02C1\u0386\u0386\u0388\u038A\u038C\u038C\u038E\u03A1\u03A3\u03CE\u03D0\u03D6\u03DA\u03DA\u03DC\u03DC\u03DE\u03DE\u03E0\u03E0\u03E2\u03F3\u0401\u040C\u040E\u044F\u0451\u045C\u045E\u0481\u0490\u04C4\u04C7\u04C8\u04CB\u04CC\u04D0\u04EB\u04EE\u04F5\u04F8\u04F9\u0531\u0556\u0559\u0559\u0561\u0586\u05D0\u05EA\u05F0\u05F2\u0621\u063A\u0641\u064A\u0671\u06B7\u06BA\u06BE\u06C0\u06CE\u06D0\u06D3\u06D5\u06D5\u06E5\u06E6\u0905\u0939\u093D\u093D\u0958\u0961\u0985\u098C\u098F\u0990\u0993\u09A8\u09AA\u09B0\u09B2\u09B2\u09B6\u09B9\u09DC\u09DD\u09DF\u09E1\u09F0\u09F1\u0A05\u0A0A\u0A0F\u0A10\u0A13\u0A28\u0A2A\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59\u0A5C\u0A5E\u0A5E\u0A72\u0A74\u0A85\u0A8B\u0A8D\u0A8D\u0A8F\u0A91\u0A93\u0AA8\u0AAA\u0AB0\u0AB2\u0AB3\u0AB5\u0AB9\u0ABD\u0ABD\u0AE0\u0AE0\u0B05\u0B0C\u0B0F\u0B10\u0B13\u0B28\u0B2A\u0B30\u0B32\u0B33\u0B36\u0B39\u0B3D\u0B3D\u0B5C\u0B5D\u0B5F\u0B61\u0B85\u0B8A\u0B8E\u0B90\u0B92\u0B95\u0B99\u0B9A\u0B9C\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8\u0BAA\u0BAE\u0BB5\u0BB7\u0BB9\u0C05\u0C0C\u0C0E\u0C10\u0C12\u0C28\u0C2A\u0C33\u0C35\u0C39\u0C60\u0C61\u0C85\u0C8C\u0C8E\u0C90\u0C92\u0CA8\u0CAA\u0CB3\u0CB5\u0CB9\u0CDE\u0CDE\u0CE0\u0CE1\u0D05\u0D0C\u0D0E\u0D10\u0D12\u0D28\u0D2A\u0D39\u0D60\u0D61\u0E01\u0E2E\u0E30\u0E30\u0E32\u0E33\u0E40\u0E45\u0E81\u0E82\u0E84\u0E84\u0E87\u0E88\u0E8A\u0E8A\u0E8D\u0E8D\u0E94\u0E97\u0E99\u0E9F\u0EA1\u0EA3\u0EA5\u0EA5\u0EA7\u0EA7\u0EAA\u0EAB\u0EAD\u0EAE\u0EB0\u0EB0\u0EB2\u0EB3\u0EBD\u0EBD\u0EC0\u0EC4\u0F40\u0F47\u0F49\u0F69\u10A0\u10C5\u10D0\u10F6\u1100\u1100\u1102\u1103\u1105\u1107\u1109\u1109\u110B\u110C\u110E\u1112\u113C\u113C\u113E\u113E\u1140\u1140\u114C\u114C\u114E\u114E\u1150\u1150\u1154\u1155\u1159\u1159\u115F\u1161\u1163\u1163\u1165\u1165\u1167\u1167\u1169\u1169\u116D\u116E\u1172\u1173\u1175\u1175\u119E\u119E\u11A8\u11A8\u11AB\u11AB\u11AE\u11AF\u11B7\u11B8\u11BA\u11BA\u11BC\u11C2\u11EB\u11EB\u11F0\u11F0\u11F9\u11F9\u1E00\u1E9B\u1EA0\u1EF9\u1F00\u1F15\u1F18\u1F1D\u1F20\u1F45\u1F48\u1F4D\u1F50\u1F57\u1F59\u1F59\u1F5B\u1F5B\u1F5D\u1F5D\u1F5F\u1F7D\u1F80\u1FB4\u1FB6\u1FBC\u1FBE\u1FBE\u1FC2\u1FC4\u1FC6\u1FCC\u1FD0\u1FD3\u1FD6\u1FDB\u1FE0\u1FEC\u1FF2\u1FF4\u1FF6\u1FFC\u2126\u2126\u212A\u212B\u212E\u212E\u2180\u2182\u3007\u3007\u3021\u3029\u3041\u3094\u30A1\u30FA\u3105\u312C\u4E00\u9FA5\uAC00\uD7A3');
    $addRange(tok0, 95, 95);
    $addRange(tok0, 58, 58);
    $putStringValue(ranges_0, 'xml:isInitialNameChar', tok0);
    $putStringValue(ranges2, 'xml:isInitialNameChar', complementRanges(tok0));
  }
  tok = positive?castTo($getStringValue(ranges_0, name_0), 133):castTo($getStringValue(ranges2, name_0), 133);
  return tok;
}

function setupRange(range, src_0){
  var i, len;
  len = src_0.length;
  for (i = 0; i < len; i += 2)
    $addRange(range, src_0.charCodeAt(i), src_0.charCodeAt(i + 1));
}

defineClass(1639, 758, {}, RegEx$ParserForXMLSchema);
_.checkQuestion = function checkQuestion_0(off){
  return false;
}
;
_.decodeEscaped = function decodeEscaped_0(){
  return $decodeEscaped(this);
}
;
_.getTokenForShorthand = function getTokenForShorthand_0(ch_0){
  return $getTokenForShorthand(ch_0);
}
;
_.parseCharacterClass = function parseCharacterClass_0(useNrange){
  return $parseCharacterClass(this);
}
;
_.parseSetOperations = function parseSetOperations_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBackreference = function processBackreference_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_A = function processBacksolidus_A_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_B = function processBacksolidus_B_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_C = function processBacksolidus_C_0(){
  $next_19(this);
  return $getTokenForShorthand(67);
}
;
_.processBacksolidus_I = function processBacksolidus_I_0(){
  $next_19(this);
  return $getTokenForShorthand(73);
}
;
_.processBacksolidus_X = function processBacksolidus_X_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_Z = function processBacksolidus_Z_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_b = function processBacksolidus_b_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_c = function processBacksolidus_c_0(){
  $next_19(this);
  return $getTokenForShorthand(99);
}
;
_.processBacksolidus_g = function processBacksolidus_g_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_gt = function processBacksolidus_gt_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_i = function processBacksolidus_i_0(){
  $next_19(this);
  return $getTokenForShorthand(105);
}
;
_.processBacksolidus_lt = function processBacksolidus_lt_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processBacksolidus_z = function processBacksolidus_z_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processCIinCharacterClass = function processCIinCharacterClass_0(tok, c){
  return $mergeRanges(tok, $getTokenForShorthand(c)) , -1;
}
;
_.processCaret = function processCaret_0(){
  $next_19(this);
  return $clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$CharToken(0, 94);
}
;
_.processCondition = function processCondition_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processDollar = function processDollar_0(){
  $next_19(this);
  return $clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$CharToken(0, 36);
}
;
_.processIndependent = function processIndependent_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processLookahead = function processLookahead_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processLookbehind = function processLookbehind_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processModifiers = function processModifiers_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processNegativelookahead = function processNegativelookahead_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processNegativelookbehind = function processNegativelookbehind_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processParen = function processParen_0(){
  var tok;
  $next_19(this);
  tok = createParen($parseRegex(this), 0);
  if (this.nexttoken != 7)
    throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.factor.1'))));
  $next_19(this);
  return tok;
}
;
_.processParen2 = function processParen2_0(){
  throw toJs(new RegEx$ParseException($getString(($clinit_EcorePlugin() , 'parser.process.1'))));
}
;
_.processPlus = function processPlus_0(tok){
  $next_19(this);
  return createConcat(tok, ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ClosureToken(3, tok)));
}
;
_.processQuestion = function processQuestion_0(tok){
  var par;
  $next_19(this);
  par = ($clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$UnionToken(2));
  $addChild(par, tok);
  $addChild(par, (null , token_empty));
  return par;
}
;
_.processStar = function processStar_0(tok){
  $next_19(this);
  return $clinit_RegEx$Token() , $clinit_RegEx$Token() , ++tokens_0 , new RegEx$Token$ClosureToken(3, tok);
}
;
var ranges_0 = null, ranges2 = null;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$ParserForXMLSchema_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/ParserForXMLSchema', 1639);
function createOptionString(options){
  var sb;
  sb = new StringBuffer_0;
  (options & 256) != 0 && (sb.string += 'F' , sb);
  (options & 128) != 0 && (sb.string += 'H' , sb);
  (options & 512) != 0 && (sb.string += 'X' , sb);
  (options & 2) != 0 && (sb.string += 'i' , sb);
  (options & 8) != 0 && (sb.string += 'm' , sb);
  (options & 4) != 0 && (sb.string += 's' , sb);
  (options & 32) != 0 && (sb.string += 'u' , sb);
  (options & 64) != 0 && (sb.string += 'w' , sb);
  (options & 16) != 0 && (sb.string += 'x' , sb);
  (options & $intern_89) != 0 && (sb.string += ',' , sb);
  return castToString(checkNotNull_1(sb.string));
}

function decomposeToSurrogates(ch_0){
  var chs;
  chs = initUnidimensionalArray(C_classLit, $intern_45, 23, 2, 15, 1);
  ch_0 -= $intern_66;
  chs[0] = (ch_0 >> 10) + $intern_67 & $intern_47;
  chs[1] = (ch_0 & 1023) + 56320 & $intern_47;
  return valueOf_9(chs, 0, chs.length);
}

function getOptionValue(ch_0){
  var ret;
  ret = 0;
  switch (ch_0) {
    case 105:
      ret = 2;
      break;
    case 109:
      ret = 8;
      break;
    case 115:
      ret = 4;
      break;
    case 120:
      ret = 16;
      break;
    case 117:
      ret = 32;
      break;
    case 119:
      ret = 64;
      break;
    case 70:
      ret = 256;
      break;
    case 72:
      ret = 128;
      break;
    case 88:
      ret = 512;
      break;
    case 44:
      ret = $intern_89;
  }
  return ret;
}

function parseOptions(){
  var i, options, v;
  options = 0;
  for (i = 0; i < 'X'.length; i++) {
    v = getOptionValue('X'.charCodeAt(i));
    if (v == 0)
      throw toJs(new RegEx$ParseException('Unknown Option: ' + 'X'.substr(i, 'X'.length - i)));
    options |= v;
  }
  return options;
}

function quoteMeta(literal){
  var buffer, ch_0, i, len;
  len = literal.length;
  buffer = null;
  for (i = 0; i < len; i++) {
    ch_0 = literal.charCodeAt(i);
    if ($indexOf_1('.*+?{[()|\\^$', fromCodePoint(ch_0)) >= 0) {
      if (!buffer) {
        buffer = new StringBuffer_0;
        i > 0 && $append_3(buffer, literal.substr(0, i));
      }
      buffer.string += '\\';
      $append(buffer, ch_0 & $intern_47);
    }
     else 
      !!buffer && $append(buffer, ch_0 & $intern_47);
  }
  return buffer?buffer.string:literal;
}

function stripExtendedComment(regex){
  var buffer, ch_0, len, next, offset;
  len = regex.length;
  buffer = new StringBuffer_0;
  offset = 0;
  while (offset < len) {
    ch_0 = $charAt(regex, offset++);
    if (ch_0 == 9 || ch_0 == 10 || ch_0 == 12 || ch_0 == 13 || ch_0 == 32)
      continue;
    if (ch_0 == 35) {
      while (offset < len) {
        ch_0 = $charAt(regex, offset++);
        if (ch_0 == 13 || ch_0 == 10)
          break;
      }
      continue;
    }
    if (ch_0 == 92 && offset < len) {
      if ((next = regex.charCodeAt(offset)) == 35 || next == 9 || next == 10 || next == 12 || next == 13 || next == 32) {
        $append(buffer, next & $intern_47);
        ++offset;
      }
       else {
        buffer.string += '\\';
        $append(buffer, next & $intern_47);
        ++offset;
      }
    }
     else 
      $append(buffer, ch_0 & $intern_47);
  }
  return buffer.string;
}

function $clinit_RegEx$Token(){
  $clinit_RegEx$Token = emptyMethod;
  token_empty = new RegEx$Token(7);
  token_linebeginning = (++tokens_0 , new RegEx$Token$CharToken(8, 94));
  ++tokens_0;
  new RegEx$Token$CharToken(8, 64);
  token_lineend = (++tokens_0 , new RegEx$Token$CharToken(8, 36));
  token_stringbeginning = (++tokens_0 , new RegEx$Token$CharToken(8, 65));
  token_stringend = (++tokens_0 , new RegEx$Token$CharToken(8, 122));
  token_stringend2 = (++tokens_0 , new RegEx$Token$CharToken(8, 90));
  token_wordedge = (++tokens_0 , new RegEx$Token$CharToken(8, 98));
  token_not_wordedge = (++tokens_0 , new RegEx$Token$CharToken(8, 66));
  token_wordbeginning = (++tokens_0 , new RegEx$Token$CharToken(8, 60));
  token_wordend = (++tokens_0 , new RegEx$Token$CharToken(8, 62));
  token_dot = new RegEx$Token(11);
  token_0to9 = (++tokens_0 , new RegEx$RangeToken(4));
  $addRange(token_0to9, 48, 57);
  token_wordchars = (++tokens_0 , new RegEx$RangeToken(4));
  $addRange(token_wordchars, 48, 57);
  $addRange(token_wordchars, 65, 90);
  $addRange(token_wordchars, 95, 95);
  $addRange(token_wordchars, 97, 122);
  token_spaces = (++tokens_0 , new RegEx$RangeToken(4));
  $addRange(token_spaces, 9, 9);
  $addRange(token_spaces, 10, 10);
  $addRange(token_spaces, 12, 12);
  $addRange(token_spaces, 13, 13);
  $addRange(token_spaces, 32, 32);
  token_not_0to9 = complementRanges(token_0to9);
  token_not_wordchars = complementRanges(token_wordchars);
  token_not_spaces = complementRanges(token_spaces);
  categories = new HashMap;
  categories2 = new HashMap;
  categoryNames = stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Cn', 'Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Mn', 'Me', 'Mc', 'Nd', 'Nl', 'No', 'Zs', 'Zl', 'Zp', 'Cc', 'Cf', null, 'Co', 'Cs', 'Pd', 'Ps', 'Pe', 'Pc', 'Po', 'Sm', 'Sc', 'Sk', 'So', 'Pi', 'Pf', 'L', 'M', 'N', 'Z', 'C', 'P', 'S']);
  blockNames = stampJavaTypeInfo(getClassLiteralForArray(Ljava_lang_String_2_classLit, 1), $intern_33, 2, 6, ['Basic Latin', 'Latin-1 Supplement', 'Latin Extended-A', 'Latin Extended-B', 'IPA Extensions', 'Spacing Modifier Letters', 'Combining Diacritical Marks', 'Greek', 'Cyrillic', 'Armenian', 'Hebrew', 'Arabic', 'Syriac', 'Thaana', 'Devanagari', 'Bengali', 'Gurmukhi', 'Gujarati', 'Oriya', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhala', 'Thai', 'Lao', 'Tibetan', 'Myanmar', 'Georgian', 'Hangul Jamo', 'Ethiopic', 'Cherokee', 'Unified Canadian Aboriginal Syllabics', 'Ogham', 'Runic', 'Khmer', 'Mongolian', 'Latin Extended Additional', 'Greek Extended', 'General Punctuation', 'Superscripts and Subscripts', 'Currency Symbols', 'Combining Marks for Symbols', 'Letterlike Symbols', 'Number Forms', 'Arrows', 'Mathematical Operators', 'Miscellaneous Technical', 'Control Pictures', 'Optical Character Recognition', 'Enclosed Alphanumerics', 'Box Drawing', 'Block Elements', 'Geometric Shapes', 'Miscellaneous Symbols', 'Dingbats', 'Braille Patterns', 'CJK Radicals Supplement', 'Kangxi Radicals', 'Ideographic Description Characters', 'CJK Symbols and Punctuation', 'Hiragana', 'Katakana', 'Bopomofo', 'Hangul Compatibility Jamo', 'Kanbun', 'Bopomofo Extended', 'Enclosed CJK Letters and Months', 'CJK Compatibility', 'CJK Unified Ideographs Extension A', 'CJK Unified Ideographs', 'Yi Syllables', 'Yi Radicals', 'Hangul Syllables', 'Private Use', 'CJK Compatibility Ideographs', 'Alphabetic Presentation Forms', 'Arabic Presentation Forms-A', 'Combining Half Marks', 'CJK Compatibility Forms', 'Small Form Variants', 'Arabic Presentation Forms-B', 'Specials', 'Halfwidth and Fullwidth Forms', 'Old Italic', 'Gothic', 'Deseret', 'Byzantine Musical Symbols', 'Musical Symbols', 'Mathematical Alphanumeric Symbols', 'CJK Unified Ideographs Extension B', 'CJK Compatibility Ideographs Supplement', 'Tags']);
  nonBMPBlockRanges = stampJavaTypeInfo(getClassLiteralForArray(I_classLit, 1), $intern_49, 23, 15, [66304, 66351, 66352, 66383, 66560, 66639, 118784, 119039, 119040, 119295, 119808, 120831, 131072, 173782, 194560, 195103, 917504, 917631]);
}

function RegEx$Token(type_0){
  this.type_0 = type_0;
}

function createChar(ch_0){
  $clinit_RegEx$Token();
  ++tokens_0;
  return new RegEx$Token$CharToken(0, ch_0);
}

function createClosure(tok){
  ++tokens_0;
  return new RegEx$Token$ClosureToken(3, tok);
}

function createConcat(tok1, tok2){
  $clinit_RegEx$Token();
  ++tokens_0;
  return new RegEx$Token$ConcatToken(tok1, tok2);
}

function createLook(type_0, child){
  $clinit_RegEx$Token();
  ++tokens_0;
  return new RegEx$Token$ParenToken(type_0, child, 0);
}

function createModifierGroup(child, add_0, mask){
  $clinit_RegEx$Token();
  ++tokens_0;
  return new RegEx$Token$ModifierToken(child, add_0, mask);
}

function createParen(child, pnumber){
  $clinit_RegEx$Token();
  ++tokens_0;
  return new RegEx$Token$ParenToken(6, child, pnumber);
}

function createString_0(str){
  $clinit_RegEx$Token();
  ++tokens_0;
  return new RegEx$Token$StringToken(10, str, 0);
}

function getCombiningCharacterSequence(){
  $clinit_RegEx$Token();
  var foo;
  if (token_ccs)
    return token_ccs;
  foo = createClosure(getRange_0('M', true));
  foo = createConcat(getRange_0('M', false), foo);
  token_ccs = foo;
  return token_ccs;
}

function getGraphemePattern(){
  $clinit_RegEx$Token();
  var base_char, combiner_wo_virama, foo, i, left, virama;
  if (token_grapheme)
    return token_grapheme;
  base_char = (++tokens_0 , new RegEx$RangeToken(4));
  $mergeRanges(base_char, getRange_0('ASSIGNED', true));
  $subtractRanges(base_char, getRange_0('M', true));
  $subtractRanges(base_char, getRange_0('C', true));
  virama = (++tokens_0 , new RegEx$RangeToken(4));
  for (i = 0; i < 11; i++) {
    $addRange(virama, i, i);
  }
  combiner_wo_virama = (++tokens_0 , new RegEx$RangeToken(4));
  $mergeRanges(combiner_wo_virama, getRange_0('M', true));
  $addRange(combiner_wo_virama, 4448, 4607);
  $addRange(combiner_wo_virama, 65438, 65439);
  left = (++tokens_0 , new RegEx$Token$UnionToken(2));
  $addChild(left, base_char);
  $addChild(left, token_empty);
  foo = (++tokens_0 , new RegEx$Token$UnionToken(2));
  foo.addChild(createConcat(virama, getRange_0('L', true)));
  foo.addChild(combiner_wo_virama);
  foo = (++tokens_0 , new RegEx$Token$ClosureToken(3, foo));
  foo = (++tokens_0 , new RegEx$Token$ConcatToken(left, foo));
  token_grapheme = foo;
  return token_grapheme;
}

function getRange_0(name_0, positive){
  $clinit_RegEx$Token();
  var all, buffer, ci, i, i0, location_0, n, oldLength, r1, ranges, rend, rstart, tok;
  if ($size_0(categories) == 0) {
    ranges = initUnidimensionalArray(Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token_2_classLit, $intern_33, 113, categoryNames.length, 0, 1);
    for (i0 = 0; i0 < ranges.length; i0++) {
      ranges[i0] = (++tokens_0 , new RegEx$RangeToken(4));
    }
    buffer = new StringBuffer_0;
    for (i = 0; i < blockNames.length; i++) {
      r1 = (++tokens_0 , new RegEx$RangeToken(4));
      if (i < 84) {
        location_0 = i * 2;
        rstart = '\x00\x7F\x80\xFF\u0100\u017F\u0180\u024F\u0250\u02AF\u02B0\u02FF\u0300\u036F\u0370\u03FF\u0400\u04FF\u0530\u058F\u0590\u05FF\u0600\u06FF\u0700\u074F\u0780\u07BF\u0900\u097F\u0980\u09FF\u0A00\u0A7F\u0A80\u0AFF\u0B00\u0B7F\u0B80\u0BFF\u0C00\u0C7F\u0C80\u0CFF\u0D00\u0D7F\u0D80\u0DFF\u0E00\u0E7F\u0E80\u0EFF\u0F00\u0FFF\u1000\u109F\u10A0\u10FF\u1100\u11FF\u1200\u137F\u13A0\u13FF\u1400\u167F\u1680\u169F\u16A0\u16FF\u1780\u17FF\u1800\u18AF\u1E00\u1EFF\u1F00\u1FFF\u2000\u206F\u2070\u209F\u20A0\u20CF\u20D0\u20FF\u2100\u214F\u2150\u218F\u2190\u21FF\u2200\u22FF\u2300\u23FF\u2400\u243F\u2440\u245F\u2460\u24FF\u2500\u257F\u2580\u259F\u25A0\u25FF\u2600\u26FF\u2700\u27BF\u2800\u28FF\u2E80\u2EFF\u2F00\u2FDF\u2FF0\u2FFF\u3000\u303F\u3040\u309F\u30A0\u30FF\u3100\u312F\u3130\u318F\u3190\u319F\u31A0\u31BF\u3200\u32FF\u3300\u33FF\u3400\u4DB5\u4E00\u9FFF\uA000\uA48F\uA490\uA4CF\uAC00\uD7A3\uE000\uF8FF\uF900\uFAFF\uFB00\uFB4F\uFB50\uFDFF\uFE20\uFE2F\uFE30\uFE4F\uFE50\uFE6F\uFE70\uFEFE\uFEFF\uFEFF\uFF00\uFFEF'.charCodeAt(location_0);
        rend = '\x00\x7F\x80\xFF\u0100\u017F\u0180\u024F\u0250\u02AF\u02B0\u02FF\u0300\u036F\u0370\u03FF\u0400\u04FF\u0530\u058F\u0590\u05FF\u0600\u06FF\u0700\u074F\u0780\u07BF\u0900\u097F\u0980\u09FF\u0A00\u0A7F\u0A80\u0AFF\u0B00\u0B7F\u0B80\u0BFF\u0C00\u0C7F\u0C80\u0CFF\u0D00\u0D7F\u0D80\u0DFF\u0E00\u0E7F\u0E80\u0EFF\u0F00\u0FFF\u1000\u109F\u10A0\u10FF\u1100\u11FF\u1200\u137F\u13A0\u13FF\u1400\u167F\u1680\u169F\u16A0\u16FF\u1780\u17FF\u1800\u18AF\u1E00\u1EFF\u1F00\u1FFF\u2000\u206F\u2070\u209F\u20A0\u20CF\u20D0\u20FF\u2100\u214F\u2150\u218F\u2190\u21FF\u2200\u22FF\u2300\u23FF\u2400\u243F\u2440\u245F\u2460\u24FF\u2500\u257F\u2580\u259F\u25A0\u25FF\u2600\u26FF\u2700\u27BF\u2800\u28FF\u2E80\u2EFF\u2F00\u2FDF\u2FF0\u2FFF\u3000\u303F\u3040\u309F\u30A0\u30FF\u3100\u312F\u3130\u318F\u3190\u319F\u31A0\u31BF\u3200\u32FF\u3300\u33FF\u3400\u4DB5\u4E00\u9FFF\uA000\uA48F\uA490\uA4CF\uAC00\uD7A3\uE000\uF8FF\uF900\uFAFF\uFB00\uFB4F\uFB50\uFDFF\uFE20\uFE2F\uFE30\uFE4F\uFE50\uFE6F\uFE70\uFEFE\uFEFF\uFEFF\uFF00\uFFEF'.charCodeAt(location_0 + 1);
        $addRange(r1, rstart, rend);
      }
       else {
        location_0 = (i - 84) * 2;
        $addRange(r1, nonBMPBlockRanges[location_0], nonBMPBlockRanges[location_0 + 1]);
      }
      n = blockNames[i];
      $equals_4(n, 'Specials') && $addRange(r1, 65520, 65533);
      if ($equals_4(n, 'Private Use')) {
        $addRange(r1, 983040, 1048573);
        $addRange(r1, 1048576, 1114109);
      }
      $putStringValue(categories, n, r1);
      $putStringValue(categories2, n, complementRanges(r1));
      oldLength = buffer.string.length;
      0 < oldLength?(buffer.string = buffer.string.substr(0, 0)):0 > oldLength && (buffer.string += valueOf_8(initUnidimensionalArray(C_classLit, $intern_45, 23, -oldLength, 15, 1)));
      buffer.string += 'Is';
      if ($indexOf_1(n, fromCodePoint(32)) >= 0) {
        for (ci = 0; ci < n.length; ci++)
          n.charCodeAt(ci) != 32 && $append(buffer, n.charCodeAt(ci));
      }
       else {
        buffer.string += '' + n;
      }
      setAlias(buffer.string, n, true);
    }
    setAlias('ASSIGNED', 'Cn', false);
    setAlias('UNASSIGNED', 'Cn', true);
    all = (++tokens_0 , new RegEx$RangeToken(4));
    $addRange(all, 0, $intern_167);
    $putStringValue(categories, 'ALL', all);
    $putStringValue(categories2, 'ALL', complementRanges(all));
    !nonxs && (nonxs = new HashMap);
    $putStringValue(nonxs, 'ASSIGNED', 'ASSIGNED');
    !nonxs && (nonxs = new HashMap);
    $putStringValue(nonxs, 'UNASSIGNED', 'UNASSIGNED');
    !nonxs && (nonxs = new HashMap);
    $putStringValue(nonxs, 'ALL', 'ALL');
  }
  tok = positive?castTo($getStringValue(categories, name_0), 133):castTo($getStringValue(categories2, name_0), 133);
  return tok;
}

function getRange_1(name_0, positive, xs){
  $clinit_RegEx$Token();
  var range;
  range = getRange_0(name_0, positive);
  xs && !!range && isRegisterNonXS(name_0) && (range = null);
  return range;
}

function isRegisterNonXS(name_0){
  if (!nonxs)
    return false;
  return $hasStringValue(nonxs, name_0);
}

function setAlias(newName, name_0, positive){
  var t1, t2;
  t1 = castTo($getStringValue(categories, name_0), 113);
  t2 = castTo($getStringValue(categories2, name_0), 113);
  if (positive) {
    $putStringValue(categories, newName, t1);
    $putStringValue(categories2, newName, t2);
  }
   else {
    $putStringValue(categories2, newName, t1);
    $putStringValue(categories, newName, t2);
  }
}

defineClass(113, 1, $intern_168, RegEx$Token);
_.addChild = function addChild(tok){
  throw toJs(new RuntimeException_0('Not supported.'));
}
;
_.getChar = function getChar(){
  return -1;
}
;
_.getChild = function getChild(index_0){
  return null;
}
;
_.getString = function getString(){
  return null;
}
;
_.setMax = function setMax(max_0){
}
;
_.setMin = function setMin(min_0){
}
;
_.size_2 = function size_72(){
  return 0;
}
;
_.toString_0 = function toString_160(){
  return this.toString_2(0);
}
;
_.toString_2 = function toString_161(options){
  return this.type_0 == 11?'.':'';
}
;
_.type_0 = 0;
var blockNames, categories, categories2, categoryNames, nonBMPBlockRanges, nonxs = null, token_0to9, token_ccs = null, token_dot, token_empty, token_grapheme = null, token_linebeginning, token_lineend, token_not_0to9, token_not_spaces, token_not_wordchars, token_not_wordedge, token_spaces, token_stringbeginning, token_stringend, token_stringend2, token_wordbeginning, token_wordchars, token_wordedge, token_wordend, tokens_0 = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token', 113);
function $addRange(this$static, start_0, end){
  var pos, r1, r2, temp;
  if (start_0 <= end) {
    r1 = start_0;
    r2 = end;
  }
   else {
    r1 = end;
    r2 = start_0;
  }
  if (this$static.ranges == null) {
    this$static.ranges = initUnidimensionalArray(I_classLit, $intern_49, 23, 2, 15, 1);
    this$static.ranges[0] = r1;
    this$static.ranges[1] = r2;
    this$static.sorted = true;
  }
   else {
    pos = this$static.ranges.length;
    if (this$static.ranges[pos - 1] + 1 == r1) {
      this$static.ranges[pos - 1] = r2;
      return;
    }
    temp = initUnidimensionalArray(I_classLit, $intern_49, 23, pos + 2, 15, 1);
    arraycopy(this$static.ranges, 0, temp, 0, pos);
    this$static.ranges = temp;
    this$static.ranges[pos - 1] >= r1 && (this$static.sorted = false , this$static.compacted = false);
    this$static.ranges[pos++] = r1;
    this$static.ranges[pos] = r2;
    this$static.sorted || $sortRanges(this$static);
  }
}

function $compactRanges(this$static){
  var base, baseend, result, target;
  if (this$static.ranges == null || this$static.ranges.length <= 2)
    return;
  if (this$static.compacted)
    return;
  base = 0;
  target = 0;
  while (target < this$static.ranges.length) {
    if (base != target) {
      this$static.ranges[base] = this$static.ranges[target++];
      this$static.ranges[base + 1] = this$static.ranges[target++];
    }
     else 
      target += 2;
    baseend = this$static.ranges[base + 1];
    while (target < this$static.ranges.length) {
      if (baseend + 1 < this$static.ranges[target])
        break;
      if (baseend + 1 == this$static.ranges[target]) {
        this$static.ranges[base + 1] = this$static.ranges[target + 1];
        baseend = this$static.ranges[base + 1];
        target += 2;
      }
       else if (baseend >= this$static.ranges[target + 1]) {
        target += 2;
      }
       else if (baseend < this$static.ranges[target + 1]) {
        this$static.ranges[base + 1] = this$static.ranges[target + 1];
        baseend = this$static.ranges[base + 1];
        target += 2;
      }
       else {
        throw toJs(new RuntimeException_0('Token#compactRanges(): Internel Error: [' + this$static.ranges[base] + ',' + this$static.ranges[base + 1] + '] [' + this$static.ranges[target] + ',' + this$static.ranges[target + 1] + ']'));
      }
    }
    base += 2;
  }
  if (base != this$static.ranges.length) {
    result = initUnidimensionalArray(I_classLit, $intern_49, 23, base, 15, 1);
    arraycopy(this$static.ranges, 0, result, 0, base);
    this$static.ranges = result;
  }
  this$static.compacted = true;
}

function $intersectRanges(this$static, token){
  var result, src1, src1begin, src1end, src2, src2begin, src2end, wp;
  if (token.ranges == null || this$static.ranges == null)
    return;
  $sortRanges(this$static);
  $compactRanges(this$static);
  $sortRanges(token);
  $compactRanges(token);
  result = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.ranges.length + token.ranges.length, 15, 1);
  wp = 0;
  src1 = 0;
  src2 = 0;
  while (src1 < this$static.ranges.length && src2 < token.ranges.length) {
    src1begin = this$static.ranges[src1];
    src1end = this$static.ranges[src1 + 1];
    src2begin = token.ranges[src2];
    src2end = token.ranges[src2 + 1];
    if (src1end < src2begin) {
      src1 += 2;
    }
     else if (src1end >= src2begin && src1begin <= src2end) {
      if (src2begin <= src1begin && src1end <= src2end) {
        result[wp++] = src1begin;
        result[wp++] = src1end;
        src1 += 2;
      }
       else if (src2begin <= src1begin) {
        result[wp++] = src1begin;
        result[wp++] = src2end;
        this$static.ranges[src1] = src2end + 1;
        src2 += 2;
      }
       else if (src1end <= src2end) {
        result[wp++] = src2begin;
        result[wp++] = src1end;
        src1 += 2;
      }
       else {
        result[wp++] = src2begin;
        result[wp++] = src2end;
        this$static.ranges[src1] = src2end + 1;
      }
    }
     else if (src2end < src1begin) {
      src2 += 2;
    }
     else {
      throw toJs(new RuntimeException_0('Token#intersectRanges(): Internal Error: [' + this$static.ranges[src1] + ',' + this$static.ranges[src1 + 1] + '] & [' + token.ranges[src2] + ',' + token.ranges[src2 + 1] + ']'));
    }
  }
  while (src1 < this$static.ranges.length) {
    result[wp++] = this$static.ranges[src1++];
    result[wp++] = this$static.ranges[src1++];
  }
  this$static.ranges = initUnidimensionalArray(I_classLit, $intern_49, 23, wp, 15, 1);
  arraycopy(result, 0, this$static.ranges, 0, wp);
}

function $mergeRanges(this$static, token){
  var i, j, k, result, tok;
  tok = castTo(token, 133);
  $sortRanges(this$static);
  $sortRanges(tok);
  if (tok.ranges == null)
    return;
  this$static.sorted = true;
  if (this$static.ranges == null) {
    this$static.ranges = initUnidimensionalArray(I_classLit, $intern_49, 23, tok.ranges.length, 15, 1);
    arraycopy(tok.ranges, 0, this$static.ranges, 0, tok.ranges.length);
    return;
  }
  result = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.ranges.length + tok.ranges.length, 15, 1);
  for (i = 0 , j = 0 , k = 0; i < this$static.ranges.length || j < tok.ranges.length;) {
    if (i >= this$static.ranges.length) {
      result[k++] = tok.ranges[j++];
      result[k++] = tok.ranges[j++];
    }
     else if (j >= tok.ranges.length) {
      result[k++] = this$static.ranges[i++];
      result[k++] = this$static.ranges[i++];
    }
     else if (tok.ranges[j] < this$static.ranges[i] || tok.ranges[j] === this$static.ranges[i] && tok.ranges[j + 1] < this$static.ranges[i + 1]) {
      result[k++] = tok.ranges[j++];
      result[k++] = tok.ranges[j++];
    }
     else {
      result[k++] = this$static.ranges[i++];
      result[k++] = this$static.ranges[i++];
    }
  }
  this$static.ranges = result;
}

function $sortRanges(this$static){
  var i, j, tmp;
  if (this$static.sorted)
    return;
  if (this$static.ranges == null)
    return;
  for (i = this$static.ranges.length - 4; i >= 0; i -= 2) {
    for (j = 0; j <= i; j += 2) {
      if (this$static.ranges[j] > this$static.ranges[j + 2] || this$static.ranges[j] === this$static.ranges[j + 2] && this$static.ranges[j + 1] > this$static.ranges[j + 3]) {
        tmp = this$static.ranges[j + 2];
        this$static.ranges[j + 2] = this$static.ranges[j];
        this$static.ranges[j] = tmp;
        tmp = this$static.ranges[j + 3];
        this$static.ranges[j + 3] = this$static.ranges[j + 1];
        this$static.ranges[j + 1] = tmp;
      }
    }
  }
  this$static.sorted = true;
}

function $subtractRanges(this$static, token){
  var result, src_0, srcbegin, srcend, sub_0, subbegin, subend, wp;
  if (token.type_0 == 5) {
    $intersectRanges(this$static, token);
    return;
  }
  if (token.ranges == null || this$static.ranges == null)
    return;
  $sortRanges(this$static);
  $compactRanges(this$static);
  $sortRanges(token);
  $compactRanges(token);
  result = initUnidimensionalArray(I_classLit, $intern_49, 23, this$static.ranges.length + token.ranges.length, 15, 1);
  wp = 0;
  src_0 = 0;
  sub_0 = 0;
  while (src_0 < this$static.ranges.length && sub_0 < token.ranges.length) {
    srcbegin = this$static.ranges[src_0];
    srcend = this$static.ranges[src_0 + 1];
    subbegin = token.ranges[sub_0];
    subend = token.ranges[sub_0 + 1];
    if (srcend < subbegin) {
      result[wp++] = this$static.ranges[src_0++];
      result[wp++] = this$static.ranges[src_0++];
    }
     else if (srcend >= subbegin && srcbegin <= subend) {
      if (subbegin <= srcbegin && srcend <= subend) {
        src_0 += 2;
      }
       else if (subbegin <= srcbegin) {
        this$static.ranges[src_0] = subend + 1;
        sub_0 += 2;
      }
       else if (srcend <= subend) {
        result[wp++] = srcbegin;
        result[wp++] = subbegin - 1;
        src_0 += 2;
      }
       else {
        result[wp++] = srcbegin;
        result[wp++] = subbegin - 1;
        this$static.ranges[src_0] = subend + 1;
        sub_0 += 2;
      }
    }
     else if (subend < srcbegin) {
      sub_0 += 2;
    }
     else {
      throw toJs(new RuntimeException_0('Token#subtractRanges(): Internal Error: [' + this$static.ranges[src_0] + ',' + this$static.ranges[src_0 + 1] + '] - [' + token.ranges[sub_0] + ',' + token.ranges[sub_0 + 1] + ']'));
    }
  }
  while (src_0 < this$static.ranges.length) {
    result[wp++] = this$static.ranges[src_0++];
    result[wp++] = this$static.ranges[src_0++];
  }
  this$static.ranges = initUnidimensionalArray(I_classLit, $intern_49, 23, wp, 15, 1);
  arraycopy(result, 0, this$static.ranges, 0, wp);
}

function RegEx$RangeToken(type_0){
  $clinit_RegEx$Token();
  RegEx$Token.call(this, type_0);
  this.sorted = false;
  this.compacted = false;
}

function complementRanges(token){
  $clinit_RegEx$Token();
  var i, last, len, ret, wp;
  if (token.type_0 != 4 && token.type_0 != 5)
    throw toJs(new IllegalArgumentException_0('Token#complementRanges(): must be RANGE: ' + token.type_0));
  $sortRanges(token);
  $compactRanges(token);
  len = token.ranges.length + 2;
  token.ranges[0] == 0 && (len -= 2);
  last = token.ranges[token.ranges.length - 1];
  last == $intern_167 && (len -= 2);
  ret = (++tokens_0 , new RegEx$RangeToken(4));
  ret.ranges = initUnidimensionalArray(I_classLit, $intern_49, 23, len, 15, 1);
  wp = 0;
  if (token.ranges[0] > 0) {
    ret.ranges[wp++] = 0;
    ret.ranges[wp++] = token.ranges[0] - 1;
  }
  for (i = 1; i < token.ranges.length - 2; i += 2) {
    ret.ranges[wp++] = token.ranges[i] + 1;
    ret.ranges[wp++] = token.ranges[i + 1] - 1;
  }
  if (last != $intern_167) {
    ret.ranges[wp++] = last + 1;
    ret.ranges[wp] = $intern_167;
  }
  ret.compacted = true;
  return ret;
}

function escapeCharInCharClass(ch_0){
  var pre, ret;
  switch (ch_0) {
    case 91:
    case 93:
    case 45:
    case 94:
    case 44:
    case 92:
      ret = '\\' + String.fromCharCode(ch_0 & $intern_47);
      break;
    case 12:
      ret = '\\f';
      break;
    case 10:
      ret = '\\n';
      break;
    case 13:
      ret = '\\r';
      break;
    case 9:
      ret = '\\t';
      break;
    case 27:
      ret = '\\e';
      break;
    default:if (ch_0 < 32) {
        pre = '0' + (ch_0 >>> 0).toString(16);
        ret = '\\x' + $substring_1(pre, pre.length - 2, pre.length);
      }
       else if (ch_0 >= $intern_66) {
        pre = '0' + (ch_0 >>> 0).toString(16);
        ret = '\\v' + $substring_1(pre, pre.length - 6, pre.length);
      }
       else 
        ret = '' + String.fromCharCode(ch_0 & $intern_47);
  }
  return ret;
}

defineClass(133, 113, {3:1, 133:1, 113:1}, RegEx$RangeToken);
_.toString_2 = function toString_162(options){
  var i, ret, sb;
  if (this.type_0 == 4) {
    if (this == token_dot)
      ret = '.';
    else if (this == token_0to9)
      ret = '\\d';
    else if (this == token_wordchars)
      ret = '\\w';
    else if (this == token_spaces)
      ret = '\\s';
    else {
      sb = new StringBuffer;
      sb.string += '[';
      for (i = 0; i < this.ranges.length; i += 2) {
        (options & $intern_89) != 0 && i > 0 && (sb.string += ',' , sb);
        if (this.ranges[i] === this.ranges[i + 1]) {
          $append_3(sb, escapeCharInCharClass(this.ranges[i]));
        }
         else {
          $append_3(sb, escapeCharInCharClass(this.ranges[i]));
          sb.string += '-';
          $append_3(sb, escapeCharInCharClass(this.ranges[i + 1]));
        }
      }
      sb.string += ']';
      ret = sb.string;
    }
  }
   else {
    if (this == token_not_0to9)
      ret = '\\D';
    else if (this == token_not_wordchars)
      ret = '\\W';
    else if (this == token_not_spaces)
      ret = '\\S';
    else {
      sb = new StringBuffer;
      sb.string += '[^';
      for (i = 0; i < this.ranges.length; i += 2) {
        (options & $intern_89) != 0 && i > 0 && (sb.string += ',' , sb);
        if (this.ranges[i] === this.ranges[i + 1]) {
          $append_3(sb, escapeCharInCharClass(this.ranges[i]));
        }
         else {
          $append_3(sb, escapeCharInCharClass(this.ranges[i]));
          sb.string += '-';
          $append_3(sb, escapeCharInCharClass(this.ranges[i + 1]));
        }
      }
      sb.string += ']';
      ret = sb.string;
    }
  }
  return ret;
}
;
_.compacted = false;
_.sorted = false;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$RangeToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/RangeToken', 133);
function RegEx$RegexParser$ReferencePosition(n){
  this.refNumber = n;
}

defineClass(552, 1, {552:1}, RegEx$RegexParser$ReferencePosition);
_.refNumber = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$RegexParser$ReferencePosition_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/RegexParser/ReferencePosition', 552);
function $setPattern(this$static, newPattern, options){
  var rp;
  this$static.regex = newPattern;
  this$static.options_0 = options;
  rp = (this$static.options_0 & 512) == 512?new RegEx$ParserForXMLSchema:new RegEx$RegexParser;
  this$static.tokentree = $parse_3(rp, this$static.regex, this$static.options_0);
}

function RegEx$RegularExpression(regex){
  $setPattern(this, regex, parseOptions());
}

defineClass(551, 1, {3:1, 551:1}, RegEx$RegularExpression);
_.equals_0 = function equals_191(obj){
  var r;
  if (obj == null)
    return false;
  if (!instanceOf(obj, 551))
    return false;
  r = castTo(obj, 551);
  return $equals_4(this.regex, r.regex) && this.options_0 == r.options_0;
}
;
_.hashCode_1 = function hashCode_79(){
  return getHashCode_1(this.regex + '/' + createOptionString(this.options_0));
}
;
_.toString_0 = function toString_163(){
  return this.tokentree.toString_2(this.options_0);
}
;
_.options_0 = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$RegularExpression_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/RegularExpression', 551);
function RegEx$Token$CharToken(type_0, ch_0){
  $clinit_RegEx$Token();
  RegEx$Token.call(this, type_0);
  this.chardata = ch_0;
}

defineClass(199, 113, $intern_168, RegEx$Token$CharToken);
_.getChar = function getChar_0(){
  return this.chardata;
}
;
_.toString_2 = function toString_164(options){
  var pre, ret;
  switch (this.type_0) {
    case 0:
      switch (this.chardata) {
        case 124:
        case 42:
        case 43:
        case 63:
        case 40:
        case 41:
        case 46:
        case 91:
        case 123:
        case 92:
          ret = '\\' + charToString(this.chardata & $intern_47);
          break;
        case 12:
          ret = '\\f';
          break;
        case 10:
          ret = '\\n';
          break;
        case 13:
          ret = '\\r';
          break;
        case 9:
          ret = '\\t';
          break;
        case 27:
          ret = '\\e';
          break;
        default:if (this.chardata >= $intern_66) {
            pre = '0' + (this.chardata >>> 0).toString(16);
            ret = '\\v' + $substring_1(pre, pre.length - 6, pre.length);
          }
           else 
            ret = '' + charToString(this.chardata & $intern_47);
      }

      break;
    case 8:
      this == token_linebeginning || this == token_lineend?(ret = '' + charToString(this.chardata & $intern_47)):(ret = '\\' + charToString(this.chardata & $intern_47));
      break;
    default:ret = null;
  }
  return ret;
}
;
_.chardata = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token$CharToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token/CharToken', 199);
function RegEx$Token$ClosureToken(type_0, tok){
  $clinit_RegEx$Token();
  RegEx$Token.call(this, type_0);
  this.child = tok;
  this.min_0 = -1;
  this.max_0 = -1;
}

defineClass(294, 113, $intern_168, RegEx$Token$ClosureToken);
_.getChild = function getChild_0(index_0){
  return this.child;
}
;
_.setMax = function setMax_0(max_0){
  this.max_0 = max_0;
}
;
_.setMin = function setMin_0(min_0){
  this.min_0 = min_0;
}
;
_.size_2 = function size_73(){
  return 1;
}
;
_.toString_2 = function toString_165(options){
  var ret;
  if (this.type_0 == 3) {
    if (this.min_0 < 0 && this.max_0 < 0) {
      ret = this.child.toString_2(options) + '*';
    }
     else if (this.min_0 == this.max_0) {
      ret = this.child.toString_2(options) + '{' + this.min_0 + '}';
    }
     else if (this.min_0 >= 0 && this.max_0 >= 0) {
      ret = this.child.toString_2(options) + '{' + this.min_0 + ',' + this.max_0 + '}';
    }
     else if (this.min_0 >= 0 && this.max_0 < 0) {
      ret = this.child.toString_2(options) + '{' + this.min_0 + ',}';
    }
     else 
      throw toJs(new RuntimeException_0('Token#toString(): CLOSURE ' + this.min_0 + ', ' + this.max_0));
  }
   else {
    if (this.min_0 < 0 && this.max_0 < 0) {
      ret = this.child.toString_2(options) + '*?';
    }
     else if (this.min_0 == this.max_0) {
      ret = this.child.toString_2(options) + '{' + this.min_0 + '}?';
    }
     else if (this.min_0 >= 0 && this.max_0 >= 0) {
      ret = this.child.toString_2(options) + '{' + this.min_0 + ',' + this.max_0 + '}?';
    }
     else if (this.min_0 >= 0 && this.max_0 < 0) {
      ret = this.child.toString_2(options) + '{' + this.min_0 + ',}?';
    }
     else 
      throw toJs(new RuntimeException_0('Token#toString(): NONGREEDYCLOSURE ' + this.min_0 + ', ' + this.max_0));
  }
  return ret;
}
;
_.max_0 = 0;
_.min_0 = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token$ClosureToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token/ClosureToken', 294);
function RegEx$Token$ConcatToken(t1, t2){
  RegEx$Token.call(this, 1);
  this.child = t1;
  this.child2 = t2;
}

defineClass(759, 113, $intern_168, RegEx$Token$ConcatToken);
_.getChild = function getChild_1(index_0){
  return index_0 == 0?this.child:this.child2;
}
;
_.size_2 = function size_74(){
  return 2;
}
;
_.toString_2 = function toString_166(options){
  var ret;
  this.child2.type_0 == 3 && this.child2.getChild(0) == this.child?(ret = this.child.toString_2(options) + '+'):this.child2.type_0 == 9 && this.child2.getChild(0) == this.child?(ret = this.child.toString_2(options) + '+?'):(ret = this.child.toString_2(options) + ('' + this.child2.toString_2(options)));
  return ret;
}
;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token$ConcatToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token/ConcatToken', 759);
function RegEx$Token$ConditionToken(refno, cond, yespat, nopat){
  $clinit_RegEx$Token();
  RegEx$Token.call(this, 26);
  this.refNumber = refno;
  this.condition = cond;
  this.yes = yespat;
  this.no = nopat;
}

defineClass(1637, 113, $intern_168, RegEx$Token$ConditionToken);
_.getChild = function getChild_2(index_0){
  if (index_0 == 0)
    return this.yes;
  if (index_0 == 1)
    return this.no;
  throw toJs(new RuntimeException_0('Internal Error: ' + index_0));
}
;
_.size_2 = function size_75(){
  return !this.no?1:2;
}
;
_.toString_2 = function toString_167(options){
  var ret;
  this.refNumber > 0?(ret = '(?(' + this.refNumber + ')'):this.condition.type_0 == 8?(ret = '(?(' + this.condition + ')'):(ret = '(?' + this.condition);
  !this.no?(ret += this.yes + ')'):(ret += this.yes + '|' + this.no + ')');
  return ret;
}
;
_.refNumber = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token$ConditionToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token/ConditionToken', 1637);
function RegEx$Token$ModifierToken(tok, add_0, mask){
  RegEx$Token.call(this, 25);
  this.child = tok;
  this.add_0 = add_0;
  this.mask = mask;
}

defineClass(1638, 113, $intern_168, RegEx$Token$ModifierToken);
_.getChild = function getChild_3(index_0){
  return this.child;
}
;
_.size_2 = function size_76(){
  return 1;
}
;
_.toString_2 = function toString_168(options){
  return '(?' + (this.add_0 == 0?'':createOptionString(this.add_0)) + (this.mask == 0?'':createOptionString(this.mask)) + ':' + this.child.toString_2(options) + ')';
}
;
_.add_0 = 0;
_.mask = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token$ModifierToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token/ModifierToken', 1638);
function RegEx$Token$ParenToken(type_0, tok, paren){
  RegEx$Token.call(this, type_0);
  this.child = tok;
  this.parennumber = paren;
}

defineClass(760, 113, $intern_168, RegEx$Token$ParenToken);
_.getChild = function getChild_4(index_0){
  return this.child;
}
;
_.size_2 = function size_77(){
  return 1;
}
;
_.toString_2 = function toString_169(options){
  var ret;
  ret = null;
  switch (this.type_0) {
    case 6:
      this.parennumber == 0?(ret = '(?:' + this.child.toString_2(options) + ')'):(ret = '(' + this.child.toString_2(options) + ')');
      break;
    case 20:
      ret = '(?=' + this.child.toString_2(options) + ')';
      break;
    case 21:
      ret = '(?!' + this.child.toString_2(options) + ')';
      break;
    case 22:
      ret = '(?<=' + this.child.toString_2(options) + ')';
      break;
    case 23:
      ret = '(?<!' + this.child.toString_2(options) + ')';
      break;
    case 24:
      ret = '(?>' + this.child.toString_2(options) + ')';
  }
  return ret;
}
;
_.parennumber = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token$ParenToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token/ParenToken', 760);
function RegEx$Token$StringToken(type_0, str, n){
  $clinit_RegEx$Token();
  RegEx$Token.call(this, type_0);
  this.string = str;
  this.refNumber = n;
}

defineClass(491, 113, {3:1, 113:1, 491:1}, RegEx$Token$StringToken);
_.getString = function getString_0(){
  return this.string;
}
;
_.toString_2 = function toString_170(options){
  return this.type_0 == 12?'\\' + this.refNumber:quoteMeta(this.string);
}
;
_.refNumber = 0;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token$StringToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token/StringToken', 491);
function $addChild(this$static, tok){
  var buffer, ch_0, i, nextMaxLength, previous, size_0;
  if (!tok)
    return;
  !this$static.children && (this$static.children = new Vector);
  if (this$static.type_0 == 2) {
    $addElement(this$static.children, tok);
    return;
  }
  if (tok.type_0 == 1) {
    for (i = 0; i < tok.size_2(); i++)
      $addChild(this$static, tok.getChild(i));
    return;
  }
  size_0 = this$static.children.arrayList.array.length;
  if (size_0 == 0) {
    $addElement(this$static.children, tok);
    return;
  }
  previous = castTo($elementAt(this$static.children, size_0 - 1), 113);
  if (!((previous.type_0 == 0 || previous.type_0 == 10) && (tok.type_0 == 0 || tok.type_0 == 10))) {
    $addElement(this$static.children, tok);
    return;
  }
  nextMaxLength = tok.type_0 == 0?2:tok.getString().length;
  if (previous.type_0 == 0) {
    buffer = new StringBuffer_0;
    ch_0 = previous.getChar();
    ch_0 >= $intern_66?$append_3(buffer, decomposeToSurrogates(ch_0)):$append(buffer, ch_0 & $intern_47);
    previous = (++tokens_0 , new RegEx$Token$StringToken(10, null, 0));
    $setElementAt(this$static.children, previous, size_0 - 1);
  }
   else {
    buffer = (previous.getString().length + nextMaxLength , new StringBuffer_0);
    $append_3(buffer, previous.getString());
  }
  if (tok.type_0 == 0) {
    ch_0 = tok.getChar();
    ch_0 >= $intern_66?$append_3(buffer, decomposeToSurrogates(ch_0)):$append(buffer, ch_0 & $intern_47);
  }
   else {
    $append_3(buffer, tok.getString());
  }
  castTo(previous, 491).string = buffer.string;
}

function RegEx$Token$UnionToken(type_0){
  $clinit_RegEx$Token();
  RegEx$Token.call(this, type_0);
}

defineClass(441, 113, $intern_168, RegEx$Token$UnionToken);
_.addChild = function addChild_0(tok){
  $addChild(this, tok);
}
;
_.getChild = function getChild_5(index_0){
  return castTo($elementAt(this.children, index_0), 113);
}
;
_.size_2 = function size_78(){
  return !this.children?0:this.children.arrayList.array.length;
}
;
_.toString_2 = function toString_171(options){
  var ch_0, ch2, i, ret, sb;
  if (this.type_0 == 1) {
    if (this.children.arrayList.array.length == 2) {
      ch_0 = castTo($elementAt(this.children, 0), 113);
      ch2 = castTo($elementAt(this.children, 1), 113);
      ch2.type_0 == 3 && ch2.getChild(0) == ch_0?(ret = ch_0.toString_2(options) + '+'):ch2.type_0 == 9 && ch2.getChild(0) == ch_0?(ret = ch_0.toString_2(options) + '+?'):(ret = ch_0.toString_2(options) + ('' + ch2.toString_2(options)));
    }
     else {
      sb = new StringBuffer;
      for (i = 0; i < this.children.arrayList.array.length; i++) {
        $append_3(sb, castTo($elementAt(this.children, i), 113).toString_2(options));
      }
      ret = sb.string;
    }
    return ret;
  }
  if (this.children.arrayList.array.length == 2 && castTo($elementAt(this.children, 1), 113).type_0 == 7) {
    ret = castTo($elementAt(this.children, 0), 113).toString_2(options) + '?';
  }
   else if (this.children.arrayList.array.length == 2 && castTo($elementAt(this.children, 0), 113).type_0 == 7) {
    ret = castTo($elementAt(this.children, 1), 113).toString_2(options) + '??';
  }
   else {
    sb = new StringBuffer;
    $append_3(sb, castTo($elementAt(this.children, 0), 113).toString_2(options));
    for (i = 1; i < this.children.arrayList.array.length; i++) {
      sb.string += '|';
      $append_3(sb, castTo($elementAt(this.children, i), 113).toString_2(options));
    }
    ret = sb.string;
  }
  return ret;
}
;
var Lorg_eclipse_emf_ecore_xml_type_internal_RegEx$Token$UnionToken_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.internal', 'RegEx/Token/UnionToken', 441);
function normalize(value_0, collapse){
  var buffer, c, i, length_0, offset, skipSpace, valueArray;
  if (value_0 == null) {
    return null;
  }
  length_0 = value_0.length;
  if (length_0 == 0) {
    return '';
  }
  valueArray = initUnidimensionalArray(C_classLit, $intern_45, 23, length_0, 15, 1);
  checkCriticalStringBounds(0, length_0, value_0.length);
  checkCriticalStringBounds(0, length_0, valueArray.length);
  $getChars0(value_0, 0, length_0, valueArray, 0);
  buffer = null;
  skipSpace = collapse;
  for (i = 0 , offset = 0; i < length_0; i++) {
    c = valueArray[i];
    $clinit_DataValue$XMLChar();
    if (c <= 32 && (CHARS[c] & 2) != 0) {
      if (skipSpace) {
        !buffer && (buffer = new StringBuffer_1(value_0));
        $deleteCharAt(buffer, i - offset++);
      }
       else {
        skipSpace = collapse;
        if (c != 32) {
          !buffer && (buffer = new StringBuffer_1(value_0));
          $replace0(buffer, i - offset, i - offset + 1, String.fromCharCode(32));
        }
      }
    }
     else {
      skipSpace = false;
    }
  }
  if (skipSpace) {
    if (!buffer) {
      return value_0.substr(0, length_0 - 1);
    }
     else {
      length_0 = buffer.string.length;
      return length_0 > 0?$substring_1(buffer.string, 0, length_0 - 1):'';
    }
  }
   else {
    return !buffer?value_0:buffer.string;
  }
}

function XMLTypeUtil$PatternMatcherImpl(pattern){
  this.regularExpression = new RegEx$RegularExpression(pattern);
}

defineClass(489, 1, {560:1}, XMLTypeUtil$PatternMatcherImpl);
_.toString_0 = function toString_172(){
  return this.regularExpression.regex;
}
;
var Lorg_eclipse_emf_ecore_xml_type_util_XMLTypeUtil$PatternMatcherImpl_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.util', 'XMLTypeUtil/PatternMatcherImpl', 489);
function $clinit_XMLTypeValidator(){
  $clinit_XMLTypeValidator = emptyMethod;
  $clinit_EObjectValidator();
  INSTANCE_12 = new XMLTypeValidator;
  stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 2), $intern_33, 354, 0, [stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 1), $intern_169, 560, 0, [new XMLTypeUtil$PatternMatcherImpl('[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*')])]);
  stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 2), $intern_33, 354, 0, [stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 1), $intern_169, 560, 0, [new XMLTypeUtil$PatternMatcherImpl('\\i\\c*')])]);
  stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 2), $intern_33, 354, 0, [stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 1), $intern_169, 560, 0, [new XMLTypeUtil$PatternMatcherImpl('[\\i-[:]][\\c-[:]]*')]), stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 1), $intern_169, 560, 0, [new XMLTypeUtil$PatternMatcherImpl('\\i\\c*')])]);
  new BigInteger_4('-1');
  stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 2), $intern_33, 354, 0, [stampJavaTypeInfo(getClassLiteralForArray(Lorg_eclipse_emf_ecore_EValidator$PatternMatcher_2_classLit, 1), $intern_169, 560, 0, [new XMLTypeUtil$PatternMatcherImpl('\\c+')])]);
  new BigInteger_4('0');
  new BigInteger_4('0');
  new BigInteger_4('1');
  new BigInteger_4('0');
  new BigInteger_4('18446744073709551615');
}

function XMLTypeValidator(){
}

defineClass(1489, 1338, {}, XMLTypeValidator);
var INSTANCE_12;
var Lorg_eclipse_emf_ecore_xml_type_util_XMLTypeValidator_2_classLit = createForClass('org.eclipse.emf.ecore.xml.type.util', 'XMLTypeValidator', 1489);
function $clinit_ExclusiveRange(){
  $clinit_ExclusiveRange = emptyMethod;
  EMPTY_LIST_ITERATOR_0 = new ExclusiveRange$1;
}

function ExclusiveRange(end){
  $clinit_ExclusiveRange();
  this.first = 0;
  this.last = end - 1;
  this.step = 1;
}

defineClass(254, 1, $intern_27, ExclusiveRange);
_.forEach_0 = function forEach_35(action){
  $forEach(this, action);
}
;
_.iterator_0 = function iterator_83(){
  return (this.last - this.first) * this.step < 0?EMPTY_LIST_ITERATOR_0:new ExclusiveRange$RangeIterator(this);
}
;
_.first = 0;
_.last = 0;
_.step = 0;
var EMPTY_LIST_ITERATOR_0;
var Lorg_eclipse_xtext_xbase_lib_ExclusiveRange_2_classLit = createForClass('org.eclipse.xtext.xbase.lib', 'ExclusiveRange', 254);
function $add_35(){
  throw toJs(new UnsupportedOperationException_0('Cannot add elements to a Range'));
}

function $next_20(){
  throw toJs(new NoSuchElementException);
}

function $previous_2(){
  throw toJs(new NoSuchElementException);
}

function $set_17(){
  throw toJs(new UnsupportedOperationException_0('Cannot set elements in a Range'));
}

function ExclusiveRange$1(){
}

defineClass(994, 1, $intern_18, ExclusiveRange$1);
_.add_2 = function add_69(e){
  castTo(e, 21);
  $add_35();
}
;
_.forEachRemaining = function forEachRemaining_54(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_51(){
  return $next_20();
}
;
_.previous_0 = function previous_14(){
  return $previous_2();
}
;
_.set_1 = function set_43(e){
  castTo(e, 21);
  $set_17();
}
;
_.hasNext_0 = function hasNext_52(){
  return false;
}
;
_.hasPrevious = function hasPrevious_14(){
  return false;
}
;
_.nextIndex_0 = function nextIndex_14(){
  return -1;
}
;
_.previousIndex = function previousIndex_13(){
  return -1;
}
;
_.remove_0 = function remove_129(){
  throw toJs(new UnsupportedOperationException_0('Cannot remove elements from a Range'));
}
;
var Lorg_eclipse_xtext_xbase_lib_ExclusiveRange$1_2_classLit = createForClass('org.eclipse.xtext.xbase.lib', 'ExclusiveRange/1', 994);
function $add_36(){
  throw toJs(new UnsupportedOperationException_0('Cannot add elements to a Range'));
}

function $next_21(this$static){
  var value_0;
  if (!(this$static.this$01.step < 0?this$static.next_0 >= this$static.this$01.last:this$static.next_0 <= this$static.this$01.last)) {
    throw toJs(new NoSuchElementException);
  }
  value_0 = this$static.next_0;
  this$static.next_0 += this$static.this$01.step;
  ++this$static.nextIndex;
  return valueOf_4(value_0);
}

function $previous_3(this$static){
  if (this$static.nextIndex <= 0)
    throw toJs(new NoSuchElementException);
  --this$static.nextIndex;
  this$static.next_0 -= this$static.this$01.step;
  return valueOf_4(this$static.next_0);
}

function $set_18(){
  throw toJs(new UnsupportedOperationException_0('Cannot set elements in a Range'));
}

function ExclusiveRange$RangeIterator(this$0){
  this.this$01 = this$0;
  this.next_0 = this.this$01.first;
}

defineClass(239, 1, $intern_18, ExclusiveRange$RangeIterator);
_.add_2 = function add_70(e){
  castTo(e, 21);
  $add_36();
}
;
_.forEachRemaining = function forEachRemaining_55(consumer){
  $forEachRemaining(this, consumer);
}
;
_.next_1 = function next_52(){
  return $next_21(this);
}
;
_.previous_0 = function previous_15(){
  return $previous_3(this);
}
;
_.set_1 = function set_44(e){
  castTo(e, 21);
  $set_18();
}
;
_.hasNext_0 = function hasNext_53(){
  return this.this$01.step < 0?this.next_0 >= this.this$01.last:this.next_0 <= this.this$01.last;
}
;
_.hasPrevious = function hasPrevious_15(){
  return this.nextIndex > 0;
}
;
_.nextIndex_0 = function nextIndex_15(){
  return this.nextIndex;
}
;
_.previousIndex = function previousIndex_14(){
  return this.nextIndex - 1;
}
;
_.remove_0 = function remove_130(){
  throw toJs(new UnsupportedOperationException_0('Cannot remove elements from a Range'));
}
;
_.next_0 = 0;
_.nextIndex = 0;
var Lorg_eclipse_xtext_xbase_lib_ExclusiveRange$RangeIterator_2_classLit = createForClass('org.eclipse.xtext.xbase.lib', 'ExclusiveRange/RangeIterator', 239);
function forEach_36(iterable, procedure){
  forEach_38(new AbstractEList$EIterator(iterable), procedure);
}

function isEmpty_31(iterable){
  if (iterable)
    return iterable.isEmpty();
  return !null.iterator_0().hasNext_0();
}

function isNullOrEmpty(iterable){
  return !iterable || isEmpty_31(iterable);
}

function forEach_37(iterator, procedure){
  while (iterator.data_0 == null && !iterator.includeRoot?$hasAnyChildren(iterator):iterator.data_0 == null || iterator.size_0 != 0 && castTo(iterator.data_0[iterator.size_0 - 1], 47).hasNext_0()) {
    $apply_31(procedure, $next_16(iterator));
  }
}

function forEach_38(iterator, procedure){
  var i;
  i = 0;
  while (iterator.cursor != iterator.this$01_2.size_1()) {
    $apply_32(procedure, $doNext(iterator), valueOf_4(i));
    i != $intern_0 && ++i;
  }
}

var C_classLit = createForPrimitive('char', 'C');
var I_classLit = createForPrimitive('int', 'I');
var Z_classLit = createForPrimitive('boolean', 'Z');
var J_classLit = createForPrimitive('long', 'J');
var B_classLit = createForPrimitive('byte', 'B');
var D_classLit = createForPrimitive('double', 'D');
var F_classLit = createForPrimitive('float', 'F');
var S_classLit = createForPrimitive('short', 'S');
var Lorg_eclipse_elk_core_labels_ILabelManager_2_classLit = createForInterface('org.eclipse.elk.core.labels', 'ILabelManager');
var Lorg_eclipse_emf_common_util_DiagnosticChain_2_classLit = createForInterface('org.eclipse.emf.common.util', 'DiagnosticChain');
var Lorg_eclipse_emf_ecore_resource_ResourceSet_2_classLit = createForInterface('org.eclipse.emf.ecore.resource', 'ResourceSet');
var Lorg_eclipse_emf_common_util_InvocationTargetException_2_classLit = createForClass('org.eclipse.emf.common.util', 'InvocationTargetException', null);
var $entry = ($clinit_Impl() , entry_0);
var gwtOnLoad = gwtOnLoad = gwtOnLoad_0;
addInitFunctions(init);
setGwtProperty('permProps', [[['locale', 'default'], ['user.agent', 'gecko1_8']], [['locale', 'default'], ['user.agent', 'ie10']], [['locale', 'default'], ['user.agent', 'ie8']], [['locale', 'default'], ['user.agent', 'ie9']], [['locale', 'default'], ['user.agent', 'safari']]]);

// --------------    RUN GWT INITIALIZATION CODE    -------------- 
gwtOnLoad(null, 'elk', null);
