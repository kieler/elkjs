/*******************************************************************************
 * Copyright (c) 2019 TypeFox and others.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *******************************************************************************/

type ContentAlignmentHozizontal = "H_LEFT" | "H_CENTER" | "H_RIGHT";
type ContentAlignmentVertical = "V_TOP" | "V_CENTER" | "V_BOTTOM";
type ContentAlignment =
    `[${ContentAlignmentHozizontal},${OptionalSpace}${ContentAlignmentVertical}]`;

type Direction = "UNDEFINED" | "RIGHT" | "LEFT" | "DOWN" | "UP";

type EdgeRouting = "UNDEFINED" | "POLYLINE" | "ORTHOGONAL" | "SPLINES";

type HierarchyHandling = "INHERIT" | "INCLUDE_CHILDREN" | "SEPARATE_CHILDREN";

type OptionalSpace = "" | " ";

type Spacing =
    `[top=${number},${OptionalSpace}left=${number},${OptionalSpace}bottom=${number},${OptionalSpace}right=${number}]`;

type ElkMargin = Spacing;
type ElkPadding = Spacing;

type BoxLayoutProviderPackingMode =
    | "SIMPLE"
    | "GROUP_DEC"
    | "GROUP_MIXED"
    | "GROUP_INC";

type DirectionCongruency = "READING_DIRECTION" | "ROTATION";

type InteractiveReferencePoint = "CENTER" | "TOP_LEFT";

type PortSortingStrategy = "INPUT_ORDER" | "PORT_DEGREE";

type CycleBreakingStrategy =
    | "GREEDY"
    | "DEPTH_FIRST"
    | "INTERACTIVE"
    | "MODEL_ORDER"
    | "GREEDY_MODEL_ORDER";

type NodeLayeringStrategy =
    | "NETWORK_SIMPLEX"
    | "LONGEST_PATH"
    | "COFFMAN_GRAHAM"
    | "INTERACTIVE"
    | "STRETCH_WIDTH"
    | "MIN_WIDTH";

type NodePromotionStrategy =
    | "NONE"
    | "NIKOLOV"
    | "NIKOLOV_PIXEL"
    | "NIKOLOV_IMPROVED"
    | "NIKOLOV_IMPROVED_PIXEL"
    | "DUMMYNODE_PERCENTAGE"
    | "NODECOUNT_PERCENTAGE"
    | "NO_BOUNDARY";

type CrossingMinimizationStrategy = "LAYER_SWEEP" | "INTERACTIVE" | "NONE";

type GreedySwitchType = "ONE_SIDED" | "TWO_SIDED" | "OFF";

type NodePlacementStrategy =
    | "SIMPLE"
    | "INTERACTIVE"
    | "LINEAR_SEGMENTS"
    | "BRANDES_KOEPF"
    | "NETWORK_SIMPLEX";

type EdgeStraighteningStrategy = "NONE" | "IMPROVE_STRAIGHTNESS";

type FixedAlignment =
    | "NONE"
    | "LEFTUP"
    | "RIGHTUP"
    | "LEFTDOWN"
    | "RIGHTDOWN"
    | "BALANCED";

type NodeFlexibility =
    | "NONE"
    | "PORT_POSITION"
    | "NODE_SIZE_WHERE_SPACE_PERMITS"
    | "NODE_SIZE";

type SplineRoutingMode = "CONSERVATIVE" | "CONSERVATIVE_SOFT" | "SLOPPY";

type GraphCompactionStrategy =
    | "NONE"
    | "LEFT"
    | "RIGHT"
    | "LEFT_RIGHT_CONSTRAINT_LOCKING"
    | "LEFT_RIGHT_CONNECTION_LOCKING"
    | "EDGE_LENGTH";

type ConstraintCalculationStrategy = "QUADRATIC" | "SCANLINE";

type WrappingStrategy = "OFF" | "SINGLE_EDGE" | "MULTI_EDGE";

type CuttingStrategy = "ARD" | "MSD" | "MANUAL";

type ValidifyStrategy = "NO" | "GREEDY" | "LOOK_BACK";

type EdgeLabelSideSelection =
    | "ALWAYS_UP"
    | "ALWAYS_DOWN"
    | "DIRECTION_UP"
    | "DIRECTION_DOWN"
    | "SMART_UP"
    | "SMART_DOWN";

type CenterEdgeLabelPlacementStrategy =
    | "MEDIAN_LAYER"
    | "TAIL_LAYER"
    | "HEAD_LAYER"
    | "SPACE_EFFICIENT_LAYER"
    | "WIDEST_LAYER"
    | "CENTER_LAYER";

type OrderingStrategy = "NONE" | "NODES_AND_EDGES" | "PREFER_EDGES";

type ComponentOrderingStrategy =
    | "NONE"
    | "INSIDE_PORT_SIDE_GROUPS"
    | "FORCE_MODEL_ORDER";

type LongEdgeOrderingStrategy =
    | "DUMMY_NODE_OVER"
    | "DUMMY_NODE_UNDER"
    | "EQUAL";

type StressMajorizationDimension = "XY" | "X" | "Y";

type OrderWeighting = "DESCENDANTS" | "FAN";

type TreeifyingOrder = "DFS" | "BFS";

type RadialCompactionStrategy =
    | "NONE"
    | "RADIAL_COMPACTION"
    | "WEDGE_COMPACTION";

type SortingStrategy = "NONE" | "POLAR_COORDINATE" | "ID";

type AnnulusWedgeCriteria = "LEAF_NUMBER" | "NODE_SIZE";

type RadialTranslationStrategy =
    | "NONE"
    | "EDGE_LENGTH"
    | "EDGE_LENGTH_BY_POSITION"
    | "CROSSING_MINIMIZATION_BY_POSITION";

type ForceModelStrategy = "EADES" | "FRUCHTERMAN_REINGOLD";

type TraversalStrategy =
    | "SPIRAL"
    | "LINE_BY_LINE"
    | "MANHATTAN"
    | "JITTER"
    | "QUADRANTS_LINE_BY_LINE"
    | "QUADRANTS_MANHATTAN"
    | "QUADRANTS_JITTER"
    | "COMBINE_LINE_BY_LINE_MANHATTAN"
    | "COMBINE_JITTER_MANHATTAN";

type HighLevelSortingCriterion =
    | "NUM_OF_EXTERNAL_SIDES_THAN_NUM_OF_EXTENSIONS_LAST"
    | "CORNER_CASES_THAN_SINGLE_SIDE_LAST";

type DiscoCompactionStrategy = "POLYOMINO";

type StructureExtractionStrategy = "DELAUNAY_TRIANGULATION";

type TreeConstructionStrategy =
    | "MINIMUM_SPANNING_TREE"
    | "MAXIMUM_SPANNING_TREE";

type SpanningTreeCostFunction =
    | "CENTER_DISTANCE"
    | "CIRCLE_UNDERLAP"
    | "RECTANGLE_UNDERLAP"
    | "INVERTED_OVERLAP"
    | "MINIMUM_ROOT_DISTANCE";

type RootSelection = "FIXED" | "CENTER_NODE";

type CompactionStrategy = "DEPTH_FIRST";

type Alignment = "AUTOMATIC" | "LEFT" | "RIGHT" | "TOP" | "BOTTOM" | "CENTER";

type PortConstraints =
    | "UNDEFINED"
    | "FREE"
    | "FIXED_SIDE"
    | "FIXED_ORDER"
    | "FIXED_RATIO"
    | "FIXED_POS";

type NodeLabelPlacementOptionsHorizontal =
    | "H_LEFT"
    | "H_CENTER"
    | "H_RIGHT"
    | "H_PRIORITY";
type NodeLabelPlacementOptionsVertical = "V_TOP" | "V_CENTER" | "V_BOTTOM";
type NodeLabelPlacementOptionsInOutside = "INSIDE" | "OUTSIDE";
type NodeLabelPlacement =
    `[${NodeLabelPlacementOptionsHorizontal},${OptionalSpace}${NodeLabelPlacementOptionsVertical},${OptionalSpace}${NodeLabelPlacementOptionsInOutside}]`;

type PortAlignment = "DISTRIBUTED" | "JUSTIFIED" | "BEGIN" | "CENTER" | "END";

type SizeConstraintOption =
    | "PORTS"
    | "PORT_LABELS"
    | "NODE_LABELS"
    | "MINIMUM_SIZE";

// ToDo: Is there another Layout how Values are represented
// ToDo: If constraining to specific option Order the Size can be greatly reduced. Constrains the user at the order - It that wanted or prefered all options?
type SizeConstraint =
    // Alternativ with a lot of duplicates
    //   | `[${SizeConstraintOption}]`
    //   | `[${SizeConstraintOption}, ${SizeConstraintOption}]`
    //   | `[${SizeConstraintOption}, ${SizeConstraintOption}, ${SizeConstraintOption}]`
    //   | `[${SizeConstraintOption}, ${SizeConstraintOption}, ${SizeConstraintOption}, ${SizeConstraintOption}]`;
    | "[MINIMUM_SIZE]"
    | "[MINIMUM_SIZE, NODE_LABELS]"
    | "[MINIMUM_SIZE, NODE_LABELS, PORT_LABELS]"
    | "[MINIMUM_SIZE, NODE_LABELS, PORT_LABELS, PORTS]"
    | "[MINIMUM_SIZE, NODE_LABELS, PORTS]"
    | "[MINIMUM_SIZE, NODE_LABELS, PORTS, PORT_LABELS]"
    | "[MINIMUM_SIZE, PORT_LABELS]"
    | "[MINIMUM_SIZE, PORT_LABELS, NODE_LABELS]"
    | "[MINIMUM_SIZE, PORT_LABELS, NODE_LABELS, PORTS]"
    | "[MINIMUM_SIZE, PORT_LABELS, PORTS]"
    | "[MINIMUM_SIZE, PORT_LABELS, PORTS, NODE_LABELS]"
    | "[MINIMUM_SIZE, PORTS]"
    | "[MINIMUM_SIZE, PORTS, NODE_LABELS]"
    | "[MINIMUM_SIZE, PORTS, NODE_LABELS, PORT_LABELS]"
    | "[MINIMUM_SIZE, PORTS, PORT_LABELS]"
    | "[MINIMUM_SIZE, PORTS, PORT_LABELS, NODE_LABELS]"
    | "[NODE_LABELS]"
    | "[NODE_LABELS, MINIMUM_SIZE]"
    | "[NODE_LABELS, MINIMUM_SIZE, PORT_LABELS]"
    | "[NODE_LABELS, MINIMUM_SIZE, PORT_LABELS, PORTS]"
    | "[NODE_LABELS, MINIMUM_SIZE, PORTS]"
    | "[NODE_LABELS, MINIMUM_SIZE, PORTS, PORT_LABELS]"
    | "[NODE_LABELS, PORT_LABELS]"
    | "[NODE_LABELS, PORT_LABELS, MINIMUM_SIZE]"
    | "[NODE_LABELS, PORT_LABELS, MINIMUM_SIZE, PORTS]"
    | "[NODE_LABELS, PORT_LABELS, PORTS]"
    | "[NODE_LABELS, PORT_LABELS, PORTS, MINIMUM_SIZE]"
    | "[NODE_LABELS, PORTS]"
    | "[NODE_LABELS, PORTS, MINIMUM_SIZE]"
    | "[NODE_LABELS, PORTS, MINIMUM_SIZE, PORT_LABELS]"
    | "[NODE_LABELS, PORTS, PORT_LABELS]"
    | "[NODE_LABELS, PORTS, PORT_LABELS, MINIMUM_SIZE]"
    | "[PORT_LABELS]"
    | "[PORT_LABELS, MINIMUM_SIZE]"
    | "[PORT_LABELS, MINIMUM_SIZE, NODE_LABELS]"
    | "[PORT_LABELS, MINIMUM_SIZE, NODE_LABELS, PORTS]"
    | "[PORT_LABELS, MINIMUM_SIZE, PORTS]"
    | "[PORT_LABELS, MINIMUM_SIZE, PORTS, NODE_LABELS]"
    | "[PORT_LABELS, NODE_LABELS]"
    | "[PORT_LABELS, NODE_LABELS, MINIMUM_SIZE]"
    | "[PORT_LABELS, NODE_LABELS, MINIMUM_SIZE, PORTS]"
    | "[PORT_LABELS, NODE_LABELS, PORTS]"
    | "[PORT_LABELS, NODE_LABELS, PORTS, MINIMUM_SIZE]"
    | "[PORT_LABELS, PORTS]"
    | "[PORT_LABELS, PORTS, MINIMUM_SIZE]"
    | "[PORT_LABELS, PORTS, MINIMUM_SIZE, NODE_LABELS]"
    | "[PORT_LABELS, PORTS, NODE_LABELS]"
    | "[PORT_LABELS, PORTS, NODE_LABELS, MINIMUM_SIZE]"
    | "[PORTS]"
    | "[PORTS, MINIMUM_SIZE]"
    | "[PORTS, MINIMUM_SIZE, NODE_LABELS]"
    | "[PORTS, MINIMUM_SIZE, NODE_LABELS, PORT_LABELS]"
    | "[PORTS, MINIMUM_SIZE, PORT_LABELS]"
    | "[PORTS, MINIMUM_SIZE, PORT_LABELS, NODE_LABELS]"
    | "[PORTS, NODE_LABELS]"
    | "[PORTS, NODE_LABELS, MINIMUM_SIZE]"
    | "[PORTS, NODE_LABELS, MINIMUM_SIZE, PORT_LABELS]"
    | "[PORTS, NODE_LABELS, PORT_LABELS]"
    | "[PORTS, NODE_LABELS, PORT_LABELS, MINIMUM_SIZE]"
    | "[PORTS, PORT_LABELS]"
    | "[PORTS, PORT_LABELS, MINIMUM_SIZE]"
    | "[PORTS, PORT_LABELS, MINIMUM_SIZE, NODE_LABELS]"
    | "[PORTS, PORT_LABELS, NODE_LABELS]"
    | "[PORTS, PORT_LABELS, NODE_LABELS, MINIMUM_SIZE]";

type SizeOptionsOptions =
    | "DEFAULT_MINIMUM_SIZE"
    | "MINIMUM_SIZE_ACCOUNTS_FOR_PADDING"
    | "COMPUTE_PADDING"
    | "OUTSIDE_NODE_LABELS_OVERHANG"
    | "PORTS_OVERHANG"
    | "UNIFORM_PORT_SPACING"
    | "SPACE_EFFICIENT_PORT_LABELS"
    | "FORCE_TABULAR_NODE_LABELS"
    | "ASYMMETRICAL";

// ToDo: Is 3 Options at the same time Enugth?
// ToDo: Which Options can't be activa at the same time?
// ToDo: Is there another Layout how Values are represented
// ToDo: If constraining to specific option Order the Size can be greatly reduced. Constrains the user at the order - It that wanted or prefered all options?
// Used https://calculla.com/variations to generate Variations of Values. The generating seems to not have cached in VSCode, so the Code Completion needed more time.
type SizeOptions =
    // | `[${SizeOptionsOptions}]`
    // | `[${SizeOptionsOptions}, ${SizeOptionsOptions}]`
    // | `[${SizeOptionsOptions}, ${SizeOptionsOptions}, ${SizeOptionsOptions}]`;
    | "[ASYMMETRICAL]"
    | "[ASYMMETRICAL, COMPUTE_PADDING]"
    | "[ASYMMETRICAL, COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[ASYMMETRICAL, COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[ASYMMETRICAL, COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[ASYMMETRICAL, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[ASYMMETRICAL, COMPUTE_PADDING, PORTS_OVERHANG]"
    | "[ASYMMETRICAL, COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[ASYMMETRICAL, COMPUTE_PADDING, UNIFORM_PORT_SPACING]"
    | "[ASYMMETRICAL, DEFAULT_MINIMUM_SIZE]"
    | "[ASYMMETRICAL, DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING]"
    | "[ASYMMETRICAL, DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS]"
    | "[ASYMMETRICAL, DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[ASYMMETRICAL, DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[ASYMMETRICAL, DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG]"
    | "[ASYMMETRICAL, DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS]"
    | "[ASYMMETRICAL, DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING]"
    | "[ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS]"
    | "[ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING]"
    | "[ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG]"
    | "[ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS]"
    | "[ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING]"
    | "[ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING]"
    | "[ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG]"
    | "[ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING]"
    | "[ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING]"
    | "[ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG]"
    | "[ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[ASYMMETRICAL, PORTS_OVERHANG]"
    | "[ASYMMETRICAL, PORTS_OVERHANG, COMPUTE_PADDING]"
    | "[ASYMMETRICAL, PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[ASYMMETRICAL, PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[ASYMMETRICAL, PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[ASYMMETRICAL, PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[ASYMMETRICAL, PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[ASYMMETRICAL, PORTS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS]"
    | "[ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING]"
    | "[ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS]"
    | "[ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG]"
    | "[ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING]"
    | "[ASYMMETRICAL, UNIFORM_PORT_SPACING]"
    | "[ASYMMETRICAL, UNIFORM_PORT_SPACING, COMPUTE_PADDING]"
    | "[ASYMMETRICAL, UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE]"
    | "[ASYMMETRICAL, UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS]"
    | "[ASYMMETRICAL, UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[ASYMMETRICAL, UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[ASYMMETRICAL, UNIFORM_PORT_SPACING, PORTS_OVERHANG]"
    | "[ASYMMETRICAL, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[COMPUTE_PADDING]"
    | "[COMPUTE_PADDING, ASYMMETRICAL]"
    | "[COMPUTE_PADDING, ASYMMETRICAL, DEFAULT_MINIMUM_SIZE]"
    | "[COMPUTE_PADDING, ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS]"
    | "[COMPUTE_PADDING, ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[COMPUTE_PADDING, ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[COMPUTE_PADDING, ASYMMETRICAL, PORTS_OVERHANG]"
    | "[COMPUTE_PADDING, ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS]"
    | "[COMPUTE_PADDING, ASYMMETRICAL, UNIFORM_PORT_SPACING]"
    | "[COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE, ASYMMETRICAL]"
    | "[COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS]"
    | "[COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG]"
    | "[COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS]"
    | "[COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING]"
    | "[COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]"
    | "[COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG]"
    | "[COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS]"
    | "[COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING]"
    | "[COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL]"
    | "[COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG]"
    | "[COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING]"
    | "[COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL]"
    | "[COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG]"
    | "[COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[COMPUTE_PADDING, PORTS_OVERHANG]"
    | "[COMPUTE_PADDING, PORTS_OVERHANG, ASYMMETRICAL]"
    | "[COMPUTE_PADDING, PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[COMPUTE_PADDING, PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[COMPUTE_PADDING, PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[COMPUTE_PADDING, PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[COMPUTE_PADDING, PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[COMPUTE_PADDING, PORTS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL]"
    | "[COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS]"
    | "[COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG]"
    | "[COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING]"
    | "[COMPUTE_PADDING, UNIFORM_PORT_SPACING]"
    | "[COMPUTE_PADDING, UNIFORM_PORT_SPACING, ASYMMETRICAL]"
    | "[COMPUTE_PADDING, UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE]"
    | "[COMPUTE_PADDING, UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS]"
    | "[COMPUTE_PADDING, UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[COMPUTE_PADDING, UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[COMPUTE_PADDING, UNIFORM_PORT_SPACING, PORTS_OVERHANG]"
    | "[COMPUTE_PADDING, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE]"
    | "[DEFAULT_MINIMUM_SIZE, ASYMMETRICAL]"
    | "[DEFAULT_MINIMUM_SIZE, ASYMMETRICAL, COMPUTE_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, ASYMMETRICAL, PORTS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, ASYMMETRICAL, UNIFORM_PORT_SPACING]"
    | "[DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING, ASYMMETRICAL]"
    | "[DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING, PORTS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING, UNIFORM_PORT_SPACING]"
    | "[DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]"
    | "[DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING]"
    | "[DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL]"
    | "[DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING]"
    | "[DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL]"
    | "[DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG, ASYMMETRICAL]"
    | "[DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG, COMPUTE_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL]"
    | "[DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING]"
    | "[DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING]"
    | "[DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING, ASYMMETRICAL]"
    | "[DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING, COMPUTE_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS]"
    | "[DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING, PORTS_OVERHANG]"
    | "[DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]"
    | "[FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL, COMPUTE_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL, DEFAULT_MINIMUM_SIZE]"
    | "[FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL, PORTS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL, UNIFORM_PORT_SPACING]"
    | "[FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING, ASYMMETRICAL]"
    | "[FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING, PORTS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING, UNIFORM_PORT_SPACING]"
    | "[FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE, ASYMMETRICAL]"
    | "[FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING]"
    | "[FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL]"
    | "[FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING]"
    | "[FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL]"
    | "[FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG, ASYMMETRICAL]"
    | "[FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG, COMPUTE_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS]"
    | "[FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL]"
    | "[FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING]"
    | "[FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING]"
    | "[FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING, ASYMMETRICAL]"
    | "[FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING, COMPUTE_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE]"
    | "[FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING, PORTS_OVERHANG]"
    | "[FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL, COMPUTE_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL, DEFAULT_MINIMUM_SIZE]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL, PORTS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL, UNIFORM_PORT_SPACING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, ASYMMETRICAL]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, PORTS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING, UNIFORM_PORT_SPACING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE, ASYMMETRICAL]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG, ASYMMETRICAL]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG, COMPUTE_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING, ASYMMETRICAL]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING, COMPUTE_PADDING]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING, PORTS_OVERHANG]"
    | "[MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL, COMPUTE_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL, DEFAULT_MINIMUM_SIZE]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL, PORTS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL, UNIFORM_PORT_SPACING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING, ASYMMETRICAL]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING, PORTS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING, UNIFORM_PORT_SPACING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE, ASYMMETRICAL]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, ASYMMETRICAL]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, COMPUTE_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING, ASYMMETRICAL]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING, COMPUTE_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING, PORTS_OVERHANG]"
    | "[OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[PORTS_OVERHANG]"
    | "[PORTS_OVERHANG, ASYMMETRICAL]"
    | "[PORTS_OVERHANG, ASYMMETRICAL, COMPUTE_PADDING]"
    | "[PORTS_OVERHANG, ASYMMETRICAL, DEFAULT_MINIMUM_SIZE]"
    | "[PORTS_OVERHANG, ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS]"
    | "[PORTS_OVERHANG, ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[PORTS_OVERHANG, ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[PORTS_OVERHANG, ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS]"
    | "[PORTS_OVERHANG, ASYMMETRICAL, UNIFORM_PORT_SPACING]"
    | "[PORTS_OVERHANG, COMPUTE_PADDING]"
    | "[PORTS_OVERHANG, COMPUTE_PADDING, ASYMMETRICAL]"
    | "[PORTS_OVERHANG, COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[PORTS_OVERHANG, COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[PORTS_OVERHANG, COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[PORTS_OVERHANG, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[PORTS_OVERHANG, COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[PORTS_OVERHANG, COMPUTE_PADDING, UNIFORM_PORT_SPACING]"
    | "[PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE, ASYMMETRICAL]"
    | "[PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING]"
    | "[PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS]"
    | "[PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS]"
    | "[PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING]"
    | "[PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]"
    | "[PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING]"
    | "[PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS]"
    | "[PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING]"
    | "[PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL]"
    | "[PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING]"
    | "[PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING]"
    | "[PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL]"
    | "[PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING]"
    | "[PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL]"
    | "[PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING]"
    | "[PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS]"
    | "[PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING]"
    | "[PORTS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[PORTS_OVERHANG, UNIFORM_PORT_SPACING, ASYMMETRICAL]"
    | "[PORTS_OVERHANG, UNIFORM_PORT_SPACING, COMPUTE_PADDING]"
    | "[PORTS_OVERHANG, UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE]"
    | "[PORTS_OVERHANG, UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS]"
    | "[PORTS_OVERHANG, UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[PORTS_OVERHANG, UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[PORTS_OVERHANG, UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL]"
    | "[SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL, COMPUTE_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL, DEFAULT_MINIMUM_SIZE]"
    | "[SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL, PORTS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL, UNIFORM_PORT_SPACING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING, ASYMMETRICAL]"
    | "[SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING, PORTS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING, UNIFORM_PORT_SPACING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE, ASYMMETRICAL]"
    | "[SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE, UNIFORM_PORT_SPACING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]"
    | "[SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS, UNIFORM_PORT_SPACING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL]"
    | "[SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, UNIFORM_PORT_SPACING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL]"
    | "[SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG, ASYMMETRICAL]"
    | "[SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG, COMPUTE_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG, UNIFORM_PORT_SPACING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING, ASYMMETRICAL]"
    | "[SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING, COMPUTE_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE]"
    | "[SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS]"
    | "[SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[SPACE_EFFICIENT_PORT_LABELS, UNIFORM_PORT_SPACING, PORTS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING]"
    | "[UNIFORM_PORT_SPACING, ASYMMETRICAL]"
    | "[UNIFORM_PORT_SPACING, ASYMMETRICAL, COMPUTE_PADDING]"
    | "[UNIFORM_PORT_SPACING, ASYMMETRICAL, DEFAULT_MINIMUM_SIZE]"
    | "[UNIFORM_PORT_SPACING, ASYMMETRICAL, FORCE_TABULAR_NODE_LABELS]"
    | "[UNIFORM_PORT_SPACING, ASYMMETRICAL, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[UNIFORM_PORT_SPACING, ASYMMETRICAL, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, ASYMMETRICAL, PORTS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, ASYMMETRICAL, SPACE_EFFICIENT_PORT_LABELS]"
    | "[UNIFORM_PORT_SPACING, COMPUTE_PADDING]"
    | "[UNIFORM_PORT_SPACING, COMPUTE_PADDING, ASYMMETRICAL]"
    | "[UNIFORM_PORT_SPACING, COMPUTE_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[UNIFORM_PORT_SPACING, COMPUTE_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[UNIFORM_PORT_SPACING, COMPUTE_PADDING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[UNIFORM_PORT_SPACING, COMPUTE_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, COMPUTE_PADDING, PORTS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, COMPUTE_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE]"
    | "[UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE, ASYMMETRICAL]"
    | "[UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE, COMPUTE_PADDING]"
    | "[UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE, FORCE_TABULAR_NODE_LABELS]"
    | "[UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE, PORTS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, DEFAULT_MINIMUM_SIZE, SPACE_EFFICIENT_PORT_LABELS]"
    | "[UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS]"
    | "[UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS, ASYMMETRICAL]"
    | "[UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS, COMPUTE_PADDING]"
    | "[UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS, PORTS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, FORCE_TABULAR_NODE_LABELS, SPACE_EFFICIENT_PORT_LABELS]"
    | "[UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, ASYMMETRICAL]"
    | "[UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, COMPUTE_PADDING]"
    | "[UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, DEFAULT_MINIMUM_SIZE]"
    | "[UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, FORCE_TABULAR_NODE_LABELS]"
    | "[UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, PORTS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG, ASYMMETRICAL]"
    | "[UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG, COMPUTE_PADDING]"
    | "[UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG, PORTS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, OUTSIDE_NODE_LABELS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[UNIFORM_PORT_SPACING, PORTS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, PORTS_OVERHANG, ASYMMETRICAL]"
    | "[UNIFORM_PORT_SPACING, PORTS_OVERHANG, COMPUTE_PADDING]"
    | "[UNIFORM_PORT_SPACING, PORTS_OVERHANG, DEFAULT_MINIMUM_SIZE]"
    | "[UNIFORM_PORT_SPACING, PORTS_OVERHANG, FORCE_TABULAR_NODE_LABELS]"
    | "[UNIFORM_PORT_SPACING, PORTS_OVERHANG, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[UNIFORM_PORT_SPACING, PORTS_OVERHANG, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, PORTS_OVERHANG, SPACE_EFFICIENT_PORT_LABELS]"
    | "[UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS]"
    | "[UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, ASYMMETRICAL]"
    | "[UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, COMPUTE_PADDING]"
    | "[UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, DEFAULT_MINIMUM_SIZE]"
    | "[UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, FORCE_TABULAR_NODE_LABELS]"
    | "[UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, MINIMUM_SIZE_ACCOUNTS_FOR_PADDING]"
    | "[UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, OUTSIDE_NODE_LABELS_OVERHANG]"
    | "[UNIFORM_PORT_SPACING, SPACE_EFFICIENT_PORT_LABELS, PORTS_OVERHANG]";

type KVector = `(${number},${OptionalSpace}${number})`;
// ToDo: How to represent this as string? - No Example found
type KVectorChain = string;

type PortLabelPlacementOption =
    | "OUTSIDE"
    | "INSIDE"
    | "NEXT_TO_PORT_IF_POSSIBLE"
    | "ALWAYS_SAME_SIDE"
    | "ALWAYS_OTHER_SAME_SIDE"
    | "SPACE_EFFICIENT";

// ToDo: Any Options not alloewd at the same time?
// ToDo: Is there another Layout how Values are represented
// ToDo: If constraining to specific option Order the Size can be greatly reduced. Constrains the user at the order - It that wanted or prefered all options?
type PortLabelPlacement =
    // Alternativ with a lot of duplicates
    //   | `[${PortLabelPlacementOption}]`
    //   | `[${PortLabelPlacementOption}, ${PortLabelPlacementOption}]`
    //   | `[${PortLabelPlacementOption}, ${PortLabelPlacementOption}, ${PortLabelPlacementOption}]`
    //   | `[${PortLabelPlacementOption}, ${PortLabelPlacementOption}, ${PortLabelPlacementOption}, ${PortLabelPlacementOption}]`;
    | "[ALWAYS_OTHER_SAME_SIDE, INSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[ALWAYS_OTHER_SAME_SIDE, INSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_OTHER_SAME_SIDE, INSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_OTHER_SAME_SIDE, INSIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_OTHER_SAME_SIDE, INSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, INSIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, INSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, INSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, OUTSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_OTHER_SAME_SIDE, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[ALWAYS_OTHER_SAME_SIDE, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_OTHER_SAME_SIDE, OUTSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_OTHER_SAME_SIDE, OUTSIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_OTHER_SAME_SIDE, OUTSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, INSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, INSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, INSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, OUTSIDE]"
    | "[ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_OTHER_SAME_SIDE]"
    | "[ALWAYS_SAME_SIDE, INSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[ALWAYS_SAME_SIDE, INSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_SAME_SIDE, INSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_SAME_SIDE, INSIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_SAME_SIDE, INSIDE]"
    | "[ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, INSIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, INSIDE]"
    | "[ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE]"
    | "[ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, INSIDE]"
    | "[ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, OUTSIDE]"
    | "[ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_SAME_SIDE, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[ALWAYS_SAME_SIDE, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_SAME_SIDE, OUTSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_SAME_SIDE, OUTSIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_SAME_SIDE, OUTSIDE]"
    | "[ALWAYS_SAME_SIDE, SPACE_EFFICIENT, INSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_SAME_SIDE, SPACE_EFFICIENT, INSIDE]"
    | "[ALWAYS_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, INSIDE]"
    | "[ALWAYS_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE]"
    | "[ALWAYS_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_SAME_SIDE, SPACE_EFFICIENT, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[ALWAYS_SAME_SIDE, SPACE_EFFICIENT, OUTSIDE]"
    | "[ALWAYS_SAME_SIDE, SPACE_EFFICIENT]"
    | "[ALWAYS_SAME_SIDE]"
    | "[INSIDE, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[INSIDE, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[INSIDE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[INSIDE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT]"
    | "[INSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[INSIDE, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[INSIDE, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[INSIDE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[INSIDE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT]"
    | "[INSIDE, ALWAYS_SAME_SIDE]"
    | "[INSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT]"
    | "[INSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE]"
    | "[INSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT]"
    | "[INSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE]"
    | "[INSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE]"
    | "[INSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE]"
    | "[INSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[INSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[INSIDE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[INSIDE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE]"
    | "[INSIDE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[INSIDE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE]"
    | "[INSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE]"
    | "[INSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE]"
    | "[INSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[INSIDE, SPACE_EFFICIENT]"
    | "[INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, INSIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, OUTSIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, OUTSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, OUTSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, INSIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, OUTSIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, OUTSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT, INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT, OUTSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, INSIDE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, INSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, INSIDE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, INSIDE, ALWAYS_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, INSIDE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, INSIDE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, INSIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, ALWAYS_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, OUTSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE, INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE, OUTSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, INSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, INSIDE, ALWAYS_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, INSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, OUTSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, OUTSIDE, ALWAYS_SAME_SIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, OUTSIDE]"
    | "[NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[OUTSIDE, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT]"
    | "[OUTSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[OUTSIDE, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[OUTSIDE, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT]"
    | "[OUTSIDE, ALWAYS_SAME_SIDE]"
    | "[OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, SPACE_EFFICIENT]"
    | "[OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE]"
    | "[OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, SPACE_EFFICIENT]"
    | "[OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE]"
    | "[OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE]"
    | "[OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE]"
    | "[OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, SPACE_EFFICIENT]"
    | "[OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE]"
    | "[OUTSIDE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, SPACE_EFFICIENT, ALWAYS_SAME_SIDE]"
    | "[OUTSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE]"
    | "[OUTSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE]"
    | "[OUTSIDE, SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[OUTSIDE, SPACE_EFFICIENT]"
    | "[OUTSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, INSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, INSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, INSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE, OUTSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_OTHER_SAME_SIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_SAME_SIDE, INSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, ALWAYS_SAME_SIDE, INSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, INSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, ALWAYS_SAME_SIDE, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, ALWAYS_SAME_SIDE, OUTSIDE]"
    | "[SPACE_EFFICIENT, ALWAYS_SAME_SIDE]"
    | "[SPACE_EFFICIENT, INSIDE, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, INSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[SPACE_EFFICIENT, INSIDE, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, INSIDE, ALWAYS_SAME_SIDE]"
    | "[SPACE_EFFICIENT, INSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE]"
    | "[SPACE_EFFICIENT, INSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE]"
    | "[SPACE_EFFICIENT, INSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, INSIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, INSIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE, OUTSIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, INSIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE, OUTSIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, INSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, INSIDE, ALWAYS_SAME_SIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, INSIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE, ALWAYS_SAME_SIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE, OUTSIDE]"
    | "[SPACE_EFFICIENT, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, OUTSIDE, ALWAYS_OTHER_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, OUTSIDE, ALWAYS_OTHER_SAME_SIDE]"
    | "[SPACE_EFFICIENT, OUTSIDE, ALWAYS_SAME_SIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, OUTSIDE, ALWAYS_SAME_SIDE]"
    | "[SPACE_EFFICIENT, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_OTHER_SAME_SIDE]"
    | "[SPACE_EFFICIENT, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE, ALWAYS_SAME_SIDE]"
    | "[SPACE_EFFICIENT, OUTSIDE, NEXT_TO_PORT_IF_POSSIBLE]"
    | "[SPACE_EFFICIENT, OUTSIDE]"
    | "[SPACE_EFFICIENT]";

type LayerConstraint =
    | "NONE"
    | "FIRST"
    | "FIRST_SEPARATE"
    | "LAST"
    | "LAST_SEPARATE";

type SelfLoopDistributionStrategy = "EQUALLY" | "NORTH" | "NORTH_SOUTH";

type SelfLoopOrderingStrategy = "STACKED" | "SEQUENCED";

type OptimizationGoal =
    | "ASPECT_RATIO_DRIVEN"
    | "MAX_SCALE_DRIVEN"
    | "AREA_DRIVEN";

type EdgeType =
    | "NONE"
    | "DIRECTED"
    | "UNDIRECTED"
    | "ASSOCIATION"
    | "GENERALIZATION"
    | "DEPENDENCY";

type PortSide = "UNDEFINED" | "NORTH" | "EAST" | "SOUTH" | "WEST";

type EdgeLabelPlacement = "CENTER" | "HEAD" | "TAIL";

export interface LayoutOptionsParents {
    /** Layout Algorithm:
     *  Select a specific layout algorithm.
     */
    "elk.algorithm"?: string;

    /** Resolved Layout Algorithm:
     *  Meta data associated with the selected algorithm.
     */
    "elk.resolvedAlgorithm"?: any;

    /** Aspect Ratio:
     *  The desired aspect ratio of the drawing, that is the quotient of width by height.
     */
    "elk.aspectRatio"?: number;

    /** Content Alignment:
     *  Specifies how the content of a node are aligned. Each node can individually control the alignment of its contents. I.e. if a node should be aligned top left in its parent node, the parent node should specify that option.
     */
    "elk.contentAlignment"?: ContentAlignment;

    /** Debug Mode:
     *  Whether additional debug information shall be generated.
     */
    "elk.debugMode"?: boolean;

    /** Direction:
     *  Overall direction of edges: horizontal (right / left) or vertical (down / up).
     */
    "elk.direction"?: Direction;

    /** Edge Routing:
     *  What kind of edge routing style should be applied for the content of a parent node. Algorithms may also set this option to single edges in order to mark them as splines. The bend point list of edges with this option set to SPLINES must be interpreted as control points for a piecewise cubic spline.
     */
    "elk.edgeRouting"?: EdgeRouting;

    /** Expand Nodes:
     *  If active, nodes are expanded to fill the area of their parent.
     */
    "elk.expandNodes"?: boolean;

    /** Hierarchy Handling:
     *  Determines whether separate layout runs are triggered for different compound nodes in a hierarchical graph. Setting a node's hierarchy handling to `INCLUDE_CHILDREN` will lay out that node and all of its descendants in a single layout run, until a descendant is encountered which has its hierarchy handling set to `SEPARATE_CHILDREN`. In general, `SEPARATE_CHILDREN` will ensure that a new layout run is triggered for a node with that setting. Including multiple levels of hierarchy in a single layout run may allow cross-hierarchical edges to be laid out properly. If the root node is set to `INHERIT` (or not set at all), the default behavior is `SEPARATE_CHILDREN`.
     */
    "elk.hierarchyHandling"?: HierarchyHandling;

    /** Padding:
     *  The padding to be left to a parent element's border when placing child elements. This can also serve as an output option of a layout algorithm if node size calculation is setup appropriately.
     */
    "elk.padding"?: ElkPadding;

    /** Interactive:
     *  Whether the algorithm should be run in interactive mode for the content of a parent node. What this means exactly depends on how the specific algorithm interprets this option. Usually in the interactive mode algorithms try to modify the current layout as little as possible.
     */
    "elk.interactive"?: boolean;

    /** interactive Layout:
     *  Whether the graph should be changeable interactively and by setting constraints
     */
    "elk.interactiveLayout"?: boolean;

    /** Omit Node Micro Layout:
     *  Node micro layout comprises the computation of node dimensions (if requested), the placement of ports and their labels, and the placement of node labels. The functionality is implemented independent of any specific layout algorithm and shouldn't have any negative impact on the layout algorithm's performance itself. Yet, if any unforeseen behavior occurs, this option allows to deactivate the micro layout.
     */
    "elk.omitNodeMicroLayout"?: boolean;

    /** Randomization Seed:
     *  Seed used for pseudo-random number generators to control the layout algorithm. If the value is 0, the seed shall be determined pseudo-randomly (e.g. from the system time).
     */
    "elk.randomSeed"?: number;

    /** Separate Connected Components:
     *  Whether each connected component should be processed separately.
     */
    "elk.separateConnectedComponents"?: boolean;

    /** Label Manager:
     *  Label managers can shorten labels upon a layout algorithm's request.
     */
    "elk.labelManager"?: any;

    /** Animate:
     *  Whether the shift from the old layout to the new computed layout shall be animated.
     */
    "elk.animate"?: boolean;

    /** Animation Time Factor:
     *  Factor for computation of animation time. The higher the value, the longer the animation time. If the value is 0, the resulting time is always equal to the minimum defined by 'Minimal Animation Time'.
     */
    "elk.animTimeFactor"?: number;

    /** Layout Ancestors:
     *  Whether the hierarchy levels on the path from the selected element to the root of the diagram shall be included in the layout process.
     */
    "elk.layoutAncestors"?: boolean;

    /** Maximal Animation Time:
     *  The maximal time for animations, in milliseconds.
     */
    "elk.maxAnimTime"?: number;

    /** Minimal Animation Time:
     *  The minimal time for animations, in milliseconds.
     */
    "elk.minAnimTime"?: number;

    /** Progress Bar:
     *  Whether a progress bar shall be displayed during layout computations.
     */
    "elk.progressBar"?: boolean;

    /** Validate Graph:
     *  Whether the graph shall be validated before any layout algorithm is applied. If this option is enabled and at least one error is found, the layout process is aborted and a message is shown to the user.
     */
    "elk.validateGraph"?: boolean;

    /** Validate Options:
     *  Whether layout options shall be validated before any layout algorithm is applied. If this option is enabled and at least one error is found, the layout process is aborted and a message is shown to the user.
     */
    "elk.validateOptions"?: boolean;

    /** Zoom to Fit:
     *  Whether the zoom level shall be set to view the whole diagram after layout.
     */
    "elk.zoomToFit"?: boolean;

    /** Box Layout Mode:
     *  Configures the packing mode used by the {@link BoxLayoutProvider}. If SIMPLE is not required (neither priorities are used nor the interactive mode), GROUP_DEC can improve the packing and decrease the area. GROUP_MIXED and GROUP_INC may, in very specific scenarios, work better.
     */
    "elk.box.packingMode"?: BoxLayoutProviderPackingMode;

    /** Comment Comment Spacing:
     *  Spacing to be preserved between a comment box and other comment boxes connected to the same node. The space left between comment boxes of different nodes is controlled by the node-node spacing.
     */
    "elk.spacing.commentComment"?: number;

    /** Comment Node Spacing:
     *  Spacing to be preserved between a node and its connected comment boxes. The space left between a node and the comments of another node is controlled by the node-node spacing.
     */
    "elk.spacing.commentNode"?: number;

    /** Components Spacing:
     *  Spacing to be preserved between pairs of connected components. This option is only relevant if 'separateConnectedComponents' is activated.
     */
    "elk.spacing.componentComponent"?: number;

    /** Edge Spacing:
     *  Spacing to be preserved between any two edges. Note that while this can somewhat easily be satisfied for the segments of orthogonally drawn edges, it is harder for general polylines or splines.
     */
    "elk.spacing.edgeEdge"?: number;

    /** Edge Label Spacing:
     *  The minimal distance to be preserved between a label and the edge it is associated with. Note that the placement of a label is influenced by the 'edgelabels.placement' option.
     */
    "elk.spacing.edgeLabel"?: number;

    /** Edge Node Spacing:
     *  Spacing to be preserved between nodes and edges.
     */
    "elk.spacing.edgeNode"?: number;

    /** Label Spacing:
     *  Determines the amount of space to be left between two labels of the same graph element.
     */
    "elk.spacing.labelLabel"?: number;

    /** Label Node Spacing:
     *  Spacing to be preserved between labels and the border of node they are associated with. Note that the placement of a label is influenced by the 'nodelabels.placement' option.
     */
    "elk.spacing.labelNode"?: number;

    /** Horizontal spacing between Label and Port:
     *  Horizontal spacing to be preserved between labels and the ports they are associated with. Note that the placement of a label is influenced by the 'portlabels.placement' option.
     */
    "elk.spacing.labelPortHorizontal"?: number;

    /** Vertical spacing between Label and Port:
     *  Vertical spacing to be preserved between labels and the ports they are associated with. Note that the placement of a label is influenced by the 'portlabels.placement' option.
     */
    "elk.spacing.labelPortVertical"?: number;

    /** Node Spacing:
     *  The minimal distance to be preserved between each two nodes.
     */
    "elk.spacing.nodeNode"?: number;

    /** Node Self Loop Spacing:
     *  Spacing to be preserved between a node and its self loops.
     */
    "elk.spacing.nodeSelfLoop"?: number;

    /** Port Spacing:
     *  Spacing between pairs of ports of the same node.
     */
    "elk.spacing.portPort"?: number;

    /** Additional Port Space:
     *  Additional space around the sets of ports on each node side. For each side of a node, this option can reserve additional space before and after the ports on each side. For example, a top spacing of 20 makes sure that the first port on the western and eastern side is 20 units away from the northern border.
     */
    "elk.spacing.portsSurrounding"?: ElkMargin;

    /** Layout Partition:
     *  Partition to which the node belongs. This requires Layout Partitioning to be active. Nodes with lower partition IDs will appear to the left of nodes with higher partition IDs (assuming a left-to-right layout direction).
     */
    "elk.partitioning.partition"?: number;

    /** Layout Partitioning:
     *  Whether to activate partitioned layout. This will allow to group nodes through the Layout Partition option. a pair of nodes with different partition indices is then placed such that the node with lower index is placed to the left of the other node (with left-to-right layout direction). Depending on the layout algorithm, this may only be guaranteed to work if all nodes have a layout partition configured, or at least if edges that cross partitions are not part of a partition-crossing cycle.
     */
    "elk.partitioning.activate"?: boolean;

    /** Node Label Padding:
     *  Define padding for node labels that are placed inside of a node.
     */
    "elk.nodeLabels.padding"?: ElkPadding;

    /** Fixed Graph Size:
     *  By default, the fixed layout provider will enlarge a graph until it is large enough to contain its children. If this option is set, it won't do so.
     */
    "elk.nodeSize.fixedGraphSize"?: boolean;

    /** Direction Congruency:
     *  Specifies how drawings of the same graph with different layout directions compare to each other: either a natural reading direction is preserved or the drawings are rotated versions of each other.
     */
    "elk.layered.directionCongruency"?: DirectionCongruency;

    /** Feedback Edges:
     *  Whether feedback edges should be highlighted by routing around the nodes.
     */
    "elk.layered.feedbackEdges"?: boolean;

    /** Interactive Reference Point:
     *  Determines which point of a node is considered by interactive layout phases.
     */
    "elk.layered.interactiveReferencePoint"?: InteractiveReferencePoint;

    /** Merge Edges:
     *  Edges that have no ports are merged so they touch the connected nodes at the same points. When this option is disabled, one port is created for each edge directly connected to a node. When it is enabled, all such incoming edges share an input port, and all outgoing edges share an output port.
     */
    "elk.layered.mergeEdges"?: boolean;

    /** Merge Hierarchy-Crossing Edges:
     *  If hierarchical layout is active, hierarchy-crossing edges use as few hierarchical ports as possible. They are broken by the algorithm, with hierarchical ports inserted as required. Usually, one such port is created for each edge at each hierarchy crossing point. With this option set to true, we try to create as few hierarchical ports as possible in the process. In particular, all edges that form a hyperedge can share a port.
     */
    "elk.layered.mergeHierarchyEdges"?: boolean;

    /** Port Sorting Strategy:
     *  Only relevant for nodes with FIXED_SIDE port constraints. Determines the way a node's ports are distributed on the sides of a node if their order is not prescribed. The option is set on parent nodes.
     */
    "elk.layered.portSortingStrategy"?: PortSortingStrategy;

    /** Thoroughness:
     *  How much effort should be spent to produce a nice layout.
     */
    "elk.layered.thoroughness"?: number;

    /** Add Unnecessary Bendpoints:
     *  Adds bend points even if an edge does not change direction. If true, each long edge dummy will contribute a bend point to its edges and hierarchy-crossing edges will always get a bend point where they cross hierarchy boundaries. By default, bend points are only added where an edge changes direction.
     */
    "elk.layered.unnecessaryBendpoints"?: boolean;

    /** Generate Position and Layer IDs:
     *  If enabled position id and layer id are generated, which are usually only used internally when setting the interactiveLayout option. This option should be specified on the root node.
     */
    "elk.layered.generatePositionAndLayerIds"?: boolean;

    /** Cycle Breaking Strategy:
     *  Strategy for cycle breaking. Cycle breaking looks for cycles in the graph and determines which edges to reverse to break the cycles. Reversed edges will end up pointing to the opposite direction of regular edges (that is, reversed edges will point left if edges usually point right).
     */
    "elk.layered.cycleBreaking.strategy"?: CycleBreakingStrategy;

    /** Node Layering Strategy:
     *  Strategy for node layering.
     */
    "elk.layered.layering.strategy"?: NodeLayeringStrategy;

    /** Upper Bound On Width [MinWidth Layerer]:
     *  Defines a loose upper bound on the width of the MinWidth layerer. If set to '-1' multiple values are tested and the best result is selected.
     */
    "elk.layered.layering.minWidth.upperBoundOnWidth"?: number;

    /** Upper Layer Estimation Scaling Factor [MinWidth Layerer]:
     *  Multiplied with Upper Bound On Width for defining an upper bound on the width of layers which haven't been determined yet, but whose maximum width had been (roughly) estimated by the MinWidth algorithm. Compensates for too high estimations. If set to '-1' multiple values are tested and the best result is selected.
     */
    "elk.layered.layering.minWidth.upperLayerEstimationScalingFactor"?: number;

    /** Node Promotion Strategy:
     *  Reduces number of dummy nodes after layering phase (if possible).
     */
    "elk.layered.layering.nodePromotion.strategy"?: NodePromotionStrategy;

    /** Max Node Promotion Iterations:
     *  Limits the number of iterations for node promotion.
     */
    "elk.layered.layering.nodePromotion.maxIterations"?: number;

    /** Layer Bound:
     *  The maximum number of nodes allowed per layer.
     */
    "elk.layered.layering.coffmanGraham.layerBound"?: number;

    /** Crossing Minimization Strategy:
     *  Strategy for crossing minimization.
     */
    "elk.layered.crossingMinimization.strategy"?: CrossingMinimizationStrategy;

    /** Force Node Model Order:
     *  The node order given by the model does not change to produce a better layout. E.g. if node A is before node B in the model this is not changed during crossing minimization. This assumes that the node model order is already respected before crossing minimization. This can be achieved by setting considerModelOrder.strategy to NODES_AND_EDGES.
     */
    "elk.layered.crossingMinimization.forceNodeModelOrder"?: boolean;

    /** Hierarchical Sweepiness:
     *  How likely it is to use cross-hierarchy (1) vs bottom-up (-1).
     */
    "elk.layered.crossingMinimization.hierarchicalSweepiness"?: number;

    /** Semi-Interactive Crossing Minimization:
     *  Preserves the order of nodes within a layer but still minimizes crossings between edges connecting long edge dummies. Derives the desired order from positions specified by the 'org.eclipse.elk.position' layout option. Requires a crossing minimization strategy that is able to process 'in-layer' constraints.
     */
    "elk.layered.crossingMinimization.semiInteractive"?: boolean;

    /** Greedy Switch Activation Threshold:
     *  By default it is decided automatically if the greedy switch is activated or not. The decision is based on whether the size of the input graph (without dummy nodes) is smaller than the value of this option. A '0' enforces the activation.
     */
    "elk.layered.crossingMinimization.greedySwitch.activationThreshold"?: number;

    /** Greedy Switch Crossing Minimization:
     *  Greedy Switch strategy for crossing minimization. The greedy switch heuristic is executed after the regular crossing minimization as a post-processor. Note that if 'hierarchyHandling' is set to 'INCLUDE_CHILDREN', the 'greedySwitchHierarchical.type' option must be used.
     */
    "elk.layered.crossingMinimization.greedySwitch.type"?: GreedySwitchType;

    /** Greedy Switch Crossing Minimization (hierarchical):
     *  Activates the greedy switch heuristic in case hierarchical layout is used. The differences to the non-hierarchical case (see 'greedySwitch.type') are: 1) greedy switch is inactive by default, 3) only the option value set on the node at which hierarchical layout starts is relevant, and 2) if it's activated by the user, it properly addresses hierarchy-crossing edges.
     */
    "elk.layered.crossingMinimization.greedySwitchHierarchical.type"?: GreedySwitchType;

    /** Node Placement Strategy:
     *  Strategy for node placement.
     */
    "elk.layered.nodePlacement.strategy"?: NodePlacementStrategy;

    /** Favor Straight Edges Over Balancing:
     *  Favor straight edges over a balanced node placement. The default behavior is determined automatically based on the used 'edgeRouting'. For an orthogonal style it is set to true, for all other styles to false.
     */
    "elk.layered.nodePlacement.favorStraightEdges"?: boolean;

    /** BK Edge Straightening:
     *  Specifies whether the Brandes Koepf node placer tries to increase the number of straight edges at the expense of diagram size. There is a subtle difference to the 'favorStraightEdges' option, which decides whether a balanced placement of the nodes is desired, or not. In bk terms this means combining the four alignments into a single balanced one, or not. This option on the other hand tries to straighten additional edges during the creation of each of the four alignments.
     */
    "elk.layered.nodePlacement.bk.edgeStraightening"?: EdgeStraighteningStrategy;

    /** BK Fixed Alignment:
     *  Tells the BK node placer to use a certain alignment (out of its four) instead of the one producing the smallest height, or the combination of all four.
     */
    "elk.layered.nodePlacement.bk.fixedAlignment"?: FixedAlignment;

    /** Linear Segments Deflection Dampening:
     *  Dampens the movement of nodes to keep the diagram from getting too large.
     */
    "elk.layered.nodePlacement.linearSegments.deflectionDampening"?: number;

    /** Node Flexibility Default:
     *  Default value of the 'nodeFlexibility' option for the children of a hierarchical node.
     */
    "elk.layered.nodePlacement.networkSimplex.nodeFlexibility.default"?: NodeFlexibility;

    /** Spline Routing Mode:
     *  Specifies the way control points are assembled for each individual edge. CONSERVATIVE ensures that edges are properly routed around the nodes but feels rather orthogonal at times. SLOPPY uses fewer control points to obtain curvier edge routes but may result in edges overlapping nodes.
     */
    "elk.layered.edgeRouting.splines.mode"?: SplineRoutingMode;

    /** Sloppy Spline Layer Spacing Factor:
     *  Spacing factor for routing area between layers when using sloppy spline routing.
     */
    "elk.layered.edgeRouting.splines.sloppy.layerSpacingFactor"?: number;

    /** Sloped Edge Zone Width:
     *  Width of the strip to the left and to the right of each layer where the polyline edge router is allowed to refrain from ensuring that edges are routed horizontally. This prevents awkward bend points for nodes that extent almost to the edge of their layer.
     */
    "elk.layered.edgeRouting.polyline.slopedEdgeZoneWidth"?: number;

    /** Spacing Base Value:
     *  An optional base value for all other layout options of the 'spacing' group. It can be used to conveniently alter the overall 'spaciousness' of the drawing. Whenever an explicit value is set for the other layout options, this base value will have no effect. The base value is not inherited, i.e. it must be set for each hierarchical node.
     */
    "elk.layered.spacing.baseValue"?: number;

    /** Edge Node Between Layers Spacing:
     *  The spacing to be preserved between nodes and edges that are routed next to the node's layer. For the spacing between nodes and edges that cross the node's layer 'spacing.edgeNode' is used.
     */
    "elk.layered.spacing.edgeNodeBetweenLayers"?: number;

    /** Edge Edge Between Layer Spacing:
     *  Spacing to be preserved between pairs of edges that are routed between the same pair of layers. Note that 'spacing.edgeEdge' is used for the spacing between pairs of edges crossing the same layer.
     */
    "elk.layered.spacing.edgeEdgeBetweenLayers"?: number;

    /** Node Node Between Layers Spacing:
     *  The spacing to be preserved between any pair of nodes of two adjacent layers. Note that 'spacing.nodeNode' is used for the spacing between nodes within the layer itself.
     */
    "elk.layered.spacing.nodeNodeBetweenLayers"?: number;

    /** Connected Components Compaction:
     *  Tries to further compact components (disconnected sub-graphs).
     */
    "elk.layered.compaction.connectedComponents"?: boolean;

    /** Post Compaction Strategy:
     *  Specifies whether and how post-process compaction is applied.
     */
    "elk.layered.compaction.postCompaction.strategy"?: GraphCompactionStrategy;

    /** Post Compaction Constraint Calculation:
     *  Specifies whether and how post-process compaction is applied.
     */
    "elk.layered.compaction.postCompaction.constraints"?: ConstraintCalculationStrategy;

    /** High Degree Node Treatment:
     *  Makes room around high degree nodes to place leafs and trees.
     */
    "elk.layered.highDegreeNodes.treatment"?: boolean;

    /** High Degree Node Threshold:
     *  Whether a node is considered to have a high degree.
     */
    "elk.layered.highDegreeNodes.threshold"?: number;

    /** High Degree Node Maximum Tree Height:
     *  Maximum height of a subtree connected to a high degree node to be moved to separate layers.
     */
    "elk.layered.highDegreeNodes.treeHeight"?: number;

    /** Graph Wrapping Strategy:
     *  For certain graphs and certain prescribed drawing areas it may be desirable to split the laid out graph into chunks that are placed side by side. The edges that connect different chunks are 'wrapped' around from the end of one chunk to the start of the other chunk. The points between the chunks are referred to as 'cuts'.
     */
    "elk.layered.wrapping.strategy"?: WrappingStrategy;

    /** Additional Wrapped Edges Spacing:
     *  To visually separate edges that are wrapped from regularly routed edges an additional spacing value can be specified in form of this layout option. The spacing is added to the regular edgeNode spacing.
     */
    "elk.layered.wrapping.additionalEdgeSpacing"?: number;

    /** Correction Factor for Wrapping:
     *  At times and for certain types of graphs the executed wrapping may produce results that are consistently biased in the same fashion: either wrapping to often or to rarely. This factor can be used to correct the bias. Internally, it is simply multiplied with the 'aspect ratio' layout option.
     */
    "elk.layered.wrapping.correctionFactor"?: number;

    /** Cutting Strategy:
     *  The strategy by which the layer indexes are determined at which the layering crumbles into chunks.
     */
    "elk.layered.wrapping.cutting.strategy"?: CuttingStrategy;

    /** Manually Specified Cuts:
     *  Allows the user to specify her own cuts for a certain graph.
     */
    "elk.layered.wrapping.cutting.cuts"?: any;

    /** MSD Freedom:
     *  The MSD cutting strategy starts with an initial guess on the number of chunks the graph should be split into. The freedom specifies how much the strategy may deviate from this guess. E.g. if an initial number of 3 is computed, a freedom of 1 allows 2, 3, and 4 cuts.
     */
    "elk.layered.wrapping.cutting.msd.freedom"?: number;

    /** Validification Strategy:
     *  When wrapping graphs, one can specify indices that are not allowed as split points. The validification strategy makes sure every computed split point is allowed.
     */
    "elk.layered.wrapping.validify.strategy"?: ValidifyStrategy;

    /** Valid Indices for Wrapping:
     *  undefined
     */
    "elk.layered.wrapping.validify.forbiddenIndices"?: any;

    /** Improve Cuts:
     *  For general graphs it is important that not too many edges wrap backwards. Thus a compromise between evenly-distributed cuts and the total number of cut edges is sought.
     */
    "elk.layered.wrapping.multiEdge.improveCuts"?: boolean;

    /** Distance Penalty When Improving Cuts:
     *  undefined
     */
    "elk.layered.wrapping.multiEdge.distancePenalty"?: number;

    /** Improve Wrapped Edges:
     *  The initial wrapping is performed in a very simple way. As a consequence, edges that wrap from one chunk to another may be unnecessarily long. Activating this option tries to shorten such edges.
     */
    "elk.layered.wrapping.multiEdge.improveWrappedEdges"?: boolean;

    /** Edge Label Side Selection:
     *  Method to decide on edge label sides.
     */
    "elk.layered.edgeLabels.sideSelection"?: EdgeLabelSideSelection;

    /** Edge Center Label Placement Strategy:
     *  Determines in which layer center labels of long edges should be placed.
     */
    "elk.layered.edgeLabels.centerLabelPlacementStrategy"?: CenterEdgeLabelPlacementStrategy;

    /** Consider Model Order:
     *  Preserves the order of nodes and edges in the model file if this does not lead to additional edge crossings. Depending on the strategy this is not always possible since the node and edge order might be conflicting.
     */
    "elk.layered.considerModelOrder.strategy"?: OrderingStrategy;

    /** Consider Model Order for Components:
     *  If set to NONE the usual ordering strategy (by cumulative node priority and size of nodes) is used. INSIDE_PORT_SIDES orders the components with external ports only inside the groups with the same port side. FORCE_MODEL_ORDER enforces the mode order on components. This option might produce bad alignments and sub optimal drawings in terms of used area since the ordering should be respected.
     */
    "elk.layered.considerModelOrder.components"?: ComponentOrderingStrategy;

    /** Long Edge Ordering Strategy:
     *  Indicates whether long edges are sorted under, over, or equal to nodes that have no connection to a previous layer in a left-to-right or right-to-left layout. Under and over changes to right and left in a vertical layout.
     */
    "elk.layered.considerModelOrder.longEdgeStrategy"?: LongEdgeOrderingStrategy;

    /** Crossing Counter Node Order Influence:
     *  Indicates with what percentage (1 for 100%) violations of the node model order are weighted against the crossings e.g. a value of 0.5 means two model order violations are as important as on edge crossing. This allows some edge crossings in favor of preserving the model order. It is advised to set this value to a very small positive value (e.g. 0.001) to have minimal crossing and a optimal node order. Defaults to no influence (0).
     */
    "elk.layered.considerModelOrder.crossingCounterNodeInfluence"?: number;

    /** Crossing Counter Port Order Influence:
     *  Indicates with what percentage (1 for 100%) violations of the port model order are weighted against the crossings e.g. a value of 0.5 means two model order violations are as important as on edge crossing. This allows some edge crossings in favor of preserving the model order. It is advised to set this value to a very small positive value (e.g. 0.001) to have minimal crossing and a optimal port order. Defaults to no influence (0).
     */
    "elk.layered.considerModelOrder.crossingCounterPortInfluence"?: number;

    /** Desired Edge Length:
     *  Either specified for parent nodes or for individual edges, where the latter takes higher precedence.
     */
    "elk.stress.desiredEdgeLength"?: number;

    /** Layout Dimension:
     *  Dimensions that are permitted to be altered during layout.
     */
    "elk.stress.dimension"?: StressMajorizationDimension;

    /** Stress Epsilon:
     *  Termination criterion for the iterative process.
     */
    "elk.stress.epsilon"?: number;

    /** Iteration Limit:
     *  Maximum number of performed iterations. Takes higher precedence than 'epsilon'.
     */
    "elk.stress.iterationLimit"?: number;

    /** Weighting of Nodes:
     *  Which weighting to use when computing a node order.
     */
    "elk.mrtree.weighting"?: OrderWeighting;

    /** Search Order:
     *  Which search order to use when computing a spanning tree.
     */
    "elk.mrtree.searchOrder"?: TreeifyingOrder;

    /** Radius:
     *  The radius option can be used to set the initial radius for the radial layouter.
     */
    "elk.radial.radius"?: number;

    /** Compaction:
     *  With the compacter option it can be determined how compaction on the graph is done. It can be chosen between none, the radial compaction or the compaction of wedges separately.
     */
    "elk.radial.compactor"?: RadialCompactionStrategy;

    /** Compaction Step Size:
     *  Determine the size of steps with which the compaction is done. Step size 1 correlates to a compaction of 1 pixel per Iteration.
     */
    "elk.radial.compactionStepSize"?: number;

    /** Sorter:
     *  Sort the nodes per radius according to the sorting algorithm. The strategies are none, by the given order id, or sorting them by polar coordinates.
     */
    "elk.radial.sorter"?: SortingStrategy;

    /** Annulus Wedge Criteria:
     *  Determine how the wedge for the node placement is calculated. It can be chosen between wedge determination by the number of leaves or by the maximum sum of diagonals.
     */
    "elk.radial.wedgeCriteria"?: AnnulusWedgeCriteria;

    /** Translation Optimization:
     *  Find the optimal translation of the nodes of the first radii according to this criteria. For example edge crossings can be minimized.
     */
    "elk.radial.optimizationCriteria"?: RadialTranslationStrategy;

    /** Force Model:
     *  Determines the model for force calculation.
     */
    "elk.force.model"?: ForceModelStrategy;

    /** Iterations:
     *  The number of iterations on the force model.
     */
    "elk.force.iterations"?: number;

    /** FR Temperature:
     *  The temperature is used as a scaling factor for particle displacements.
     */
    "elk.force.temperature"?: number;

    /** Eades Repulsion:
     *  Factor for repulsive forces in Eades' model.
     */
    "elk.force.repulsion"?: number;

    /** Polyomino Traversal Strategy:
     *  Traversal strategy for trying different candidate positions for polyominoes.
     */
    "elk.polyomino.traversalStrategy"?: TraversalStrategy;

    /** Polyomino Secondary Sorting Criterion:
     *  Possible secondary sorting criteria for the processing order of polyominoes. They are used when polyominoes are equal according to the primary sorting criterion HighLevelSortingCriterion.
     */
    "elk.polyomino.lowLevelSort"?: TraversalStrategy;

    /** Polyomino Primary Sorting Criterion:
     *  Possible primary sorting criteria for the processing order of polyominoes.
     */
    "elk.polyomino.highLevelSort"?: HighLevelSortingCriterion;

    /** Fill Polyominoes:
     *  Use the Profile Fill algorithm to fill polyominoes to prevent small polyominoes from being placed inside of big polyominoes with large holes. Might increase packing area.
     */
    "elk.polyomino.fill"?: boolean;

    /** Connected Components Compaction Strategy:
     *  Strategy for packing different connected components in order to save space and enhance readability of a graph.
     */
    "elk.disco.componentCompaction.strategy"?: DiscoCompactionStrategy;

    /** Connected Components Layout Algorithm:
     *  A layout algorithm that is to be applied to each connected component before the components themselves are compacted. If unspecified, the positions of the components' nodes are not altered.
     */
    "elk.disco.componentCompaction.componentLayoutAlgorithm"?: string;

    /** DCGraph:
     *  Access to the DCGraph is intended for the debug view,
     */
    "elk.disco.debug.discoGraph"?: any;

    /** List of Polyominoes:
     *  Access to the polyominoes is intended for the debug view,
     */
    "elk.disco.debug.discoPolys"?: any;

    /** Underlying Layout Algorithm:
     *  A layout algorithm that is applied to the graph before it is compacted. If this is null, nothing is applied before compaction.
     */
    "elk.underlyingLayoutAlgorithm"?: string;

    /** Structure Extraction Strategy:
     *  This option defines what kind of triangulation or other partitioning of the plane is applied to the vertices.
     */
    "elk.structure.structureExtractionStrategy"?: StructureExtractionStrategy;

    /** Tree Construction Strategy:
     *  Whether a minimum spanning tree or a maximum spanning tree should be constructed.
     */
    "elk.processingOrder.treeConstruction"?: TreeConstructionStrategy;

    /** Cost Function for Spanning Tree:
     *  The cost function is used in the creation of the spanning tree.
     */
    "elk.processingOrder.spanningTreeCostFunction"?: SpanningTreeCostFunction;

    /** Root node for spanning tree construction:
     *  The identifier of the node that is preferred as the root of the spanning tree. If this is null, the first node is chosen.
     */
    "elk.processingOrder.preferredRoot"?: string;

    /** Root selection for spanning tree:
     *  This sets the method used to select a root node for the construction of a spanning tree
     */
    "elk.processingOrder.rootSelection"?: RootSelection;

    /** Compaction Strategy:
     *  This option defines how the compaction is applied.
     */
    "elk.compaction.compactionStrategy"?: CompactionStrategy;

    /** Orthogonal Compaction:
     *  Restricts the translation of  /** nodes to orthogonal directions in the compaction phase.
     */
    "elk.compaction.orthogonal"?: boolean;

    /** Upper limit for iterations of overlap removal:
     *  undefined
     */
    "elk.overlapRemoval.maxIterations"?: number;

    /** Whether to run a supplementary scanline overlap check.:
     *  undefined
     */
    "elk.overlapRemoval.runScanline"?: boolean;

    [key: string]: any;
}

export interface LayoutOptionsNodes {
    /** Alignment:
     *  Alignment of the selected node relative to other nodes; the exact meaning depends on the used algorithm.
     */
    "elk.alignment"?: Alignment;

    /** Hierarchy Handling:
     *  Determines whether separate layout runs are triggered for different compound nodes in a hierarchical graph. Setting a node's hierarchy handling to `INCLUDE_CHILDREN` will lay out that node and all of its descendants in a single layout run, until a descendant is encountered which has its hierarchy handling set to `SEPARATE_CHILDREN`. In general, `SEPARATE_CHILDREN` will ensure that a new layout run is triggered for a node with that setting. Including multiple levels of hierarchy in a single layout run may allow cross-hierarchical edges to be laid out properly. If the root node is set to `INHERIT` (or not set at all), the default behavior is `SEPARATE_CHILDREN`.
     */
    "elk.hierarchyHandling"?: HierarchyHandling;

    /** Padding:
     *  The padding to be left to a parent element's border when placing child elements. This can also serve as an output option of a layout algorithm if node size calculation is setup appropriately.
     */
    "elk.padding"?: ElkPadding;

    /** Port Constraints:
     *  Defines constraints of the position of the ports of a node.
     */
    "elk.portConstraints"?: PortConstraints;

    /** Position:
     *  The position of a node, port, or label. This is used by the 'Fixed Layout' algorithm to specify a pre-defined position.
     */
    "elk.position"?: KVector;

    /** Priority:
     *  Defines the priority of an object; its meaning depends on the specific layout algorithm and the context where it is used.
     */
    "elk.priority"?: number;

    /** Comment Box:
     *  Whether the node should be regarded as a comment box instead of a regular node. In that case its placement should be similar to how labels are handled. Any edges incident to a comment box specify to which graph elements the comment is related.
     */
    "elk.commentBox"?: boolean;

    /** Hypernode:
     *  Whether the node should be handled as a hypernode.
     */
    "elk.hypernode"?: boolean;

    /** Margins:
     *  Margins define additional space around the actual bounds of a graph element. For instance, ports or labels being placed on the outside of a node's border might introduce such a margin. The margin is used to guarantee non-overlap of other graph elements with those ports or labels.
     */
    "elk.margins"?: ElkMargin;

    /** No Layout:
     *  No layout is done for the associated element. This is used to mark parts of a diagram to avoid their inclusion in the layout graph, or to mark parts of the layout graph to prevent layout engines from processing them. If you wish to exclude the contents of a compound node from automatic layout, while the node itself is still considered on its own layer, use the 'Fixed Layout' algorithm for that node.
     */
    "elk.noLayout"?: boolean;

    /** Scale Factor:
     *  The scaling factor to be applied to the corresponding node in recursive layout. It causes the corresponding node's size to be adjusted, and its ports and labels to be sized and placed accordingly after the layout of that node has been determined (and before the node itself and its siblings are arranged). The scaling is not reverted afterwards, so the resulting layout graph contains the adjusted size and position data. This option is currently not supported if 'Layout Hierarchy' is set.
     */
    "elk.scaleFactor"?: number;

    /** Port Spacing:
     *  Spacing between pairs of ports of the same node.
     */
    "elk.spacing.portPort"?: number;

    /** Individual Spacing:
     *  Allows to specify individual spacing values for graph elements that shall be different from the value specified for the element's parent.
     */
    "elk.spacing.individual"?: any;

    /** Layout Partition:
     *  Partition to which the node belongs. This requires Layout Partitioning to be active. Nodes with lower partition IDs will appear to the left of nodes with higher partition IDs (assuming a left-to-right layout direction).
     */
    "elk.partitioning.partition"?: number;

    /** Node Label Placement:
     *  Hints for where node labels are to be placed; if empty, the node label's position is not modified.
     */
    "elk.nodeLabels.placement"?: NodeLabelPlacement;

    /** Port Alignment:
     *  Defines the default port distribution for a node. May be overridden for each side individually.
     */
    "elk.portAlignment.default"?: PortAlignment;

    /** Port Alignment (North):
     *  Defines how ports on the northern side are placed, overriding the node's general port alignment.
     */
    "elk.portAlignment.north"?: PortAlignment;

    /** Port Alignment (South):
     *  Defines how ports on the southern side are placed, overriding the node's general port alignment.
     */
    "elk.portAlignment.south"?: PortAlignment;

    /** Port Alignment (West):
     *  Defines how ports on the western side are placed, overriding the node's general port alignment.
     */
    "elk.portAlignment.west"?: PortAlignment;

    /** Port Alignment (East):
     *  Defines how ports on the eastern side are placed, overriding the node's general port alignment.
     */
    "elk.portAlignment.east"?: PortAlignment;

    /** Node Size Constraints:
     *  What should be taken into account when calculating a node's size. Empty size constraints specify that a node's size is already fixed and should not be changed.
     */
    "elk.nodeSize.constraints"?: SizeConstraint;

    /** Node Size Options:
     *  Options modifying the behavior of the size constraints set on a node. Each member of the set specifies something that should be taken into account when calculating node sizes. The empty set corresponds to no further modifications.
     */
    "elk.nodeSize.options"?: SizeOptions;

    /** Node Size Minimum:
     *  The minimal size to which a node can be reduced.
     */
    "elk.nodeSize.minimum"?: KVector;

    /** Port Label Placement:
     *  Decides on a placement method for port labels; if empty, the node label's position is not modified.
     */
    "elk.portLabels.placement"?: PortLabelPlacement;

    /** Port Labels Next to Port:
     *  Use 'portLabels.placement': NEXT_TO_PORT_OF_POSSIBLE.
     */
    "elk.portLabels.nextToPortIfPossible"?: boolean;

    /** Treat Port Labels as Group:
     *  If this option is true (default), the labels of a port will be treated as a group when it comes to centering them next to their port. If this option is false, only the first label will be centered next to the port, with the others being placed below. This only applies to labels of eastern and western ports and will have no effect if labels are not placed next to their port.
     */
    "elk.portLabels.treatAsGroup"?: boolean;

    /** Activate Inside Self Loops:
     *  Whether this node allows to route self loops inside of it instead of around it. If set to true, this will make the node a compound node if it isn't already, and will require the layout algorithm to support compound nodes with hierarchical ports.
     */
    "elk.insideSelfLoops.activate"?: boolean;

    /** Layer Constraint:
     *  Determines a constraint on the placement of the node regarding the layering.
     */
    "elk.layered.layering.layerConstraint"?: LayerConstraint;

    /** Layer Choice Constraint:
     *  Allows to set a constraint regarding the layer placement of a node. Let i be the value of teh constraint. Assumed the drawing has n layers and i < n. If set to i, it expresses that the node should be placed in i-th layer. Should i>=n be true then the node is placed in the last layer of the drawing. Note that this option is not part of any of ELK Layered's default configurations but is only evaluated as part of the `InteractiveLayeredGraphVisitor`, which must be applied manually or used via the `DiagramLayoutEngine.
     */
    "elk.layered.layering.layerChoiceConstraint"?: number;

    /** Layer ID:
     *  Layer identifier that was calculated by ELK Layered for a node. This is only generated if interactiveLayot or generatePositionAndLayerIds is set.
     */
    "elk.layered.layering.layerId"?: number;

    /** Position Choice Constraint:
     *  Allows to set a constraint regarding the position placement of a node in a layer. Assumed the layer in which the node placed includes n other nodes and i < n. If set to i, it expresses that the node should be placed at the i-th position. Should i>=n be true then the node is placed at the last position in the layer. Note that this option is not part of any of ELK Layered's default configurations but is only evaluated as part of the `InteractiveLayeredGraphVisitor`, which must be applied manually or used via the `DiagramLayoutEngine.
     */
    "elk.layered.crossingMinimization.positionChoiceConstraint"?: number;

    /** Position ID:
     *  Position within a layer that was determined by ELK Layered for a node. This is only generated if interactiveLayot or generatePositionAndLayerIds is set.
     */
    "elk.layered.crossingMinimization.positionId"?: number;

    /** Node Flexibility:
     *  Aims at shorter and straighter edges. Two configurations are possible: (a) allow ports to move freely on the side they are assigned to (the order is always defined beforehand), (b) additionally allow to enlarge a node wherever it helps. If this option is not configured for a node, the 'nodeFlexibility.default' value is used, which is specified for the node's parent.
     */
    "elk.layered.nodePlacement.networkSimplex.nodeFlexibility"?: NodeFlexibility;

    /** Self-Loop Distribution:
     *  Alter the distribution of the loops around the node. It only takes effect for PortConstraints.FREE.
     */
    "elk.layered.edgeRouting.selfLoopDistribution"?: SelfLoopDistributionStrategy;

    /** Self-Loop Ordering:
     *  Alter the ordering of the loops they can either be stacked or sequenced. It only takes effect for PortConstraints.FREE.
     */
    "elk.layered.edgeRouting.selfLoopOrdering"?: SelfLoopOrderingStrategy;

    /** No Model Order:
     *  Set on a node to not set a model order for this node even though it is a real node.
     */
    "elk.layered.considerModelOrder.noModelOrder"?: boolean;

    /** Fixed Position:
     *  Prevent that the node is moved by the layout algorithm.
     */
    "elk.stress.fixed"?: boolean;

    /** Order ID:
     *  The id can be used to define an order for nodes of one radius. This can be used to sort them in the layer accordingly.
     */
    "elk.radial.orderId"?: number;

    /** Optimization Goal:
     *  Optimization goal for approximation of the bounding box given by the first iteration. Determines whether layout is sorted by the maximum scaling, aspect ratio, or area. Depending on the strategy the aspect ratio might be nearly ignored.
     */
    "elk.rectpacking.optimizationGoal"?: OptimizationGoal;

    /** Shift Last Placed.:
     *  When placing a rectangle behind or below the last placed rectangle in the first iteration, it is sometimes possible to shift the rectangle further to the left or right, resulting in less whitespace. True (default) enables the shift and false disables it. Disabling the shift produces a greater approximated area by the first iteration and a layout, when using ONLY the first iteration (default not the case), where it is sometimes impossible to implement a size transformation of rectangles that will fill the bounding box and eliminate empty spaces.
     */
    "elk.rectpacking.lastPlaceShift"?: boolean;

    /** Current position of a node in the order of nodes:
     *  The rectangles are ordered. Normally according to their definition the the model. This option specifies the current position of a node.
     */
    "elk.rectpacking.currentPosition"?: number;

    /** Desired index of node:
     *  The rectangles are ordered. Normally according to their definition the the model. This option allows to specify a desired position that has preference over the original position.
     */
    "elk.rectpacking.desiredPosition"?: number;

    /** Only Area Approximation:
     *  If enabled only the width approximation step is executed and the nodes are placed accordingly. The nodes are layouted according to the packingStrategy. If set to true not expansion of nodes is taking place.
     */
    "elk.rectpacking.onlyFirstIteration"?: boolean;

    /** Compact Rows:
     *  Enables compaction. Compacts blocks if they do not use the full height of the row. This option allows to have a smaller drawing. If this option is disabled all nodes are placed next to each other in rows.
     */
    "elk.rectpacking.rowCompaction"?: boolean;

    /** Fit Aspect Ratio:
     *  Expands nodes if expandNodes is true to fit the aspect ratio instead of only in their bounds. The option is only useful if the used packingStrategy is ASPECT_RATIO_DRIVEN, otherwise this may result in unreasonable ndoe expansion.
     */
    "elk.rectpacking.expandToAspectRatio"?: boolean;

    /** Target Width:
     *  Option to place the rectangles in the given target width instead of approximating the width using the desired aspect ratio. The padding is not included in this. Meaning a drawing will have width of targetwidth + horizontal padding.
     */
    "elk.rectpacking.targetWidth"?: number;

    [key: string]: any;
}

export interface LayoutOptionsEdges {
    /** Bend Points:
     *  A fixed list of bend points for the edge. This is used by the 'Fixed Layout' algorithm to specify a pre-defined routing for an edge. The vector chain must include the source point, any bend points, and the target point, so it must have at least two points.
     */
    "elk.bendPoints"?: KVectorChain;

    /** Priority:
     *  Defines the priority of an object; its meaning depends on the specific layout algorithm and the context where it is used.
     */
    "elk.priority"?: number;

    /** Junction Points:
     *  This option is not used as option, but as output of the layout algorithms. It is attached to edges and determines the points where junction symbols should be drawn in order to represent hyperedges with orthogonal routing. Whether such points are computed depends on the chosen layout algorithm and edge routing style. The points are put into the vector chain with no specific order.
     */
    "elk.junctionPoints"?: KVectorChain;

    /** No Layout:
     *  No layout is done for the associated element. This is used to mark parts of a diagram to avoid their inclusion in the layout graph, or to mark parts of the layout graph to prevent layout engines from processing them. If you wish to exclude the contents of a compound node from automatic layout, while the node itself is still considered on its own layer, use the 'Fixed Layout' algorithm for that node.
     */
    "elk.noLayout"?: boolean;

    /** Individual Spacing:
     *  Allows to specify individual spacing values for graph elements that shall be different from the value specified for the element's parent.
     */
    "elk.spacing.individual"?: any;

    /** Inside Self Loop:
     *  Whether a self loop should be routed inside a node instead of around that node.
     */
    "elk.insideSelfLoops.yo"?: boolean;

    /** Edge Thickness:
     *  The thickness of an edge. This is a hint on the line width used to draw an edge, possibly requiring more space to be reserved for it.
     */
    "elk.edge.thickness"?: number;

    /** Edge Type:
     *  The type of an edge. This is usually used for UML class diagrams, where associations must be handled differently from generalizations.
     */
    "elk.edge.type"?: EdgeType;

    /** Direction Priority:
     *  Defines how important it is to have a certain edge point into the direction of the overall layout. This option is evaluated during the cycle breaking phase.
     */
    "elk.layered.priority.direction"?: number;

    /** Shortness Priority:
     *  Defines how important it is to keep an edge as short as possible. This option is evaluated during the layering phase.
     */
    "elk.layered.priority.shortness"?: number;

    /** Straightness Priority:
     *  Defines how important it is to keep an edge straight, i.e. aligned with one of the two axes. This option is evaluated during node placement.
     */
    "elk.layered.priority.straightness"?: number;

    /** Desired Edge Length:
     *  Either specified for parent nodes or for individual edges, where the latter takes higher precedence.
     */
    "elk.stress.desiredEdgeLength"?: number;

    /** Repulsive Power:
     *  Determines how many bend points are added to the edge; such bend points are regarded as repelling particles in the force model
     */
    "elk.force.repulsivePower"?: number;

    [key: string]: any;
}

export interface LayoutOptionsPorts {
    /** Position:
     *  The position of a node, port, or label. This is used by the 'Fixed Layout' algorithm to specify a pre-defined position.
     */
    "elk.position"?: KVector;

    /** No Layout:
     *  No layout is done for the associated element. This is used to mark parts of a diagram to avoid their inclusion in the layout graph, or to mark parts of the layout graph to prevent layout engines from processing them. If you wish to exclude the contents of a compound node from automatic layout, while the node itself is still considered on its own layer, use the 'Fixed Layout' algorithm for that node.
     */
    "elk.noLayout"?: boolean;

    /** Individual Spacing:
     *  Allows to specify individual spacing values for graph elements that shall be different from the value specified for the element's parent.
     */
    "elk.spacing.individual"?: any;

    /** Port Anchor Offset:
     *  The offset to the port position where connections shall be attached.
     */
    "elk.port.anchor"?: KVector;

    /** Port Index:
     *  The index of a port in the fixed order around a node. The order is assumed as clockwise, starting with the leftmost port on the top side. This option must be set if 'Port Constraints' is set to FIXED_ORDER and no specific positions are given for the ports. Additionally, the option 'Port Side' must be defined in this case.
     */
    "elk.port.index"?: number;

    /** Port Side:
     *  The side of a node on which a port is situated. This option must be set if 'Port Constraints' is set to FIXED_SIDE or FIXED_ORDER and no specific positions are given for the ports.
     */
    "elk.port.side"?: PortSide;

    /** Port Border Offset:
     *  The offset of ports on the node border. With a positive offset the port is moved outside of the node, while with a negative offset the port is moved towards the inside. An offset of 0 means that the port is placed directly on the node border, i.e. if the port side is north, the port's south border touches the nodes's north border; if the port side is east, the port's west border touches the nodes's east border; if the port side is south, the port's north border touches the node's south border; if the port side is west, the port's east border touches the node's west border.
     */
    "elk.port.borderOffset"?: number;

    /** Allow Non-Flow Ports To Switch Sides:
     *  Specifies whether non-flow ports may switch sides if their node's port constraints are either FIXED_SIDE or FIXED_ORDER. A non-flow port is a port on a side that is not part of the currently configured layout flow. For instance, given a left-to-right layout direction, north and south ports would be considered non-flow ports. Further note that the underlying criterium whether to switch sides or not solely relies on the minimization of edge crossings. Hence, edge length and other aesthetics criteria are not addressed.
     */
    "elk.layered.allowNonFlowPortsToSwitchSides"?: boolean;

    [key: string]: any;
}

export interface LayoutOptionsLabels {
    /** Position:
     *  The position of a node, port, or label. This is used by the 'Fixed Layout' algorithm to specify a pre-defined position.
     */
    "elk.position"?: KVector;

    /** Label Manager:
     *  Label managers can shorten labels upon a layout algorithm's request.
     */
    "elk.labelManager"?: any;

    /** No Layout:
     *  No layout is done for the associated element. This is used to mark parts of a diagram to avoid their inclusion in the layout graph, or to mark parts of the layout graph to prevent layout engines from processing them. If you wish to exclude the contents of a compound node from automatic layout, while the node itself is still considered on its own layer, use the 'Fixed Layout' algorithm for that node.
     */
    "elk.noLayout"?: boolean;

    /** Individual Spacing:
     *  Allows to specify individual spacing values for graph elements that shall be different from the value specified for the element's parent.
     */
    "elk.spacing.individual"?: any;

    /** Node Label Placement:
     *  Hints for where node labels are to be placed; if empty, the node label's position is not modified.
     */
    "elk.nodeLabels.placement"?: NodeLabelPlacement;

    /** Edge Label Placement:
     *  Gives a hint on where to put edge labels.
     */
    "elk.edgeLabels.placement"?: EdgeLabelPlacement;

    /** Inline Edge Labels:
     *  If true, an edge label is placed directly on its edge. May only apply to center edge labels. This kind of label placement is only advisable if the label's rendering is such that it is not crossed by its edge and thus stays legible.
     */
    "elk.edgeLabels.inline"?: boolean;

    /** Font Name:
     *  Font name used for a label.
     */
    "elk.font.name"?: string;

    /** Font Size:
     *  Font size used for a label.
     */
    "elk.font.size"?: number;

    /** Edge Center Label Placement Strategy:
     *  Determines in which layer center labels of long edges should be placed.
     */
    "elk.layered.edgeLabels.centerLabelPlacementStrategy"?: CenterEdgeLabelPlacementStrategy;

    [key: string]: any;
}

export interface LayoutOptions
    extends LayoutOptionsParents,
    LayoutOptionsNodes,
    LayoutOptionsEdges,
    LayoutOptionsPorts,
    LayoutOptionsLabels { }

export interface ElkPoint {
    x: number;
    y: number;
}

export interface ElkGraphElement {
    id?: string;
    labels?: ElkLabel[];
}

export interface ElkShape extends ElkGraphElement {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
}

export interface ElkNode extends ElkShape {
    id: string;
    children?: ElkNode[];
    ports?: ElkPort[];
    edges?: ElkExtendedEdge[];
    layoutOptions?: LayoutOptionsNodes & LayoutOptionsParents;
}

export interface ElkPort extends ElkShape {
    id: string;
    layoutOptions?: LayoutOptionsPorts;
}

export interface ElkLabel extends ElkShape {
    text?: string;
    layoutOptions?: LayoutOptionsLabels;
}

/**
 * @deprecated use ElkExtendedEdge directly
 */
export interface ElkEdge extends ElkGraphElement {
    id: string;
    junctionPoints?: ElkPoint[];
    layoutOptions?: LayoutOptionsEdges;
}

/**
 * @deprecated use ElkExtendedEdge instead
 */
export interface ElkPrimitiveEdge extends ElkEdge {
    source: string;
    sourcePort?: string;
    target: string;
    targetPort?: string;
    sourcePoint?: ElkPoint;
    targetPoint?: ElkPoint;
    bendPoints?: ElkPoint[];
}

export interface ElkExtendedEdge extends ElkEdge {
    sources: string[];
    targets: string[];
    sections?: ElkEdgeSection[];
}

export interface ElkEdgeSection extends ElkGraphElement {
    id: string;
    startPoint: ElkPoint;
    endPoint: ElkPoint;
    bendPoints?: ElkPoint[];
    incomingShape?: string;
    outgoingShape?: string;
    incomingSections?: string[];
    outgoingSections?: string[];
    //ToDo: Does this have the LayoutOptionsLabels or not? Wasn't shure, but dont know, if acceptable.
    layoutOptions?: LayoutOptionsEdges & LayoutOptionsLabels;
}

export interface ElkLayoutArguments {
    layoutOptions?: LayoutOptions;
    logging?: boolean;
    measureExecutionTime?: boolean;
}

export interface ElkCommonDescription {
    id?: string;
    name?: string;
    description?: string;
}

export interface ElkLayoutAlgorithmDescription extends ElkCommonDescription {
    category?: string;
    knownOptions?: string[];
    supportedFeatures?: string[];
}

export interface ElkLayoutOptionDescription extends ElkCommonDescription {
    group?: string;
    type?: string;
    targets?: string[];
}

export interface ElkLayoutCategoryDescription extends ElkCommonDescription {
    knownLayouters?: string[];
}

export interface ELK {
    layout(graph: ElkNode, args?: ElkLayoutArguments): Promise<ElkNode>;
    knownLayoutAlgorithms(): Promise<ElkLayoutAlgorithmDescription[]>;
    knownLayoutOptions(): Promise<ElkLayoutOptionDescription[]>;
    knownLayoutCategories(): Promise<ElkLayoutCategoryDescription[]>;
}

export interface ELKConstructorArguments {
    defaultLayoutOptions?: LayoutOptions;
    algorithms?: string[];
    workerUrl?: string;
    workerFactory?: (url?: string) => Worker;
}

declare const ElkConstructor: {
    new(args?: ELKConstructorArguments): ELK;
};
export default ElkConstructor;
